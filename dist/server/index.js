/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inheritsLoose; });
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inheritsLoose.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inheritsLoose.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

module.exports = _inheritsLoose;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@hapi/accept/lib/header.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/accept/lib/header.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


exports.selection = function (header, preferences, options) {

    const selections = exports.selections(header, preferences, options);
    return selections.length ? selections[0] : '';
};


exports.selections = function (header, preferences, options) {

    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');

    return internals.parse(header || '', preferences, options);
};


//      RFC 7231 Section 5.3.3 (https://tools.ietf.org/html/rfc7231#section-5.3.3)
//
//      Accept-Charset  = *( "," OWS ) ( ( charset / "*" ) [ weight ] ) *( OWS "," [ OWS ( ( charset / "*" ) [ weight ] ) ] )
//      charset         = token
//
//      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8


//      RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)
//
//      Accept-Encoding = [ ( "," / ( codings [ weight ] ) ) *( OWS "," [ OWS ( codings [ weight ] ) ] ) ]
//      codings         = content-coding / "identity" / "*"
//      content-coding  = token
//
//      Accept-Encoding: compress, gzip
//      Accept-Encoding:
//      Accept-Encoding: *
//      Accept-Encoding: compress;q=0.5, gzip;q=1.0
//      Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0


//      RFC 7231 Section 5.3.5 (https://tools.ietf.org/html/rfc7231#section-5.3.5)
//
//      Accept-Language = *( "," OWS ) ( language-range [ weight ] ) *( OWS "," [ OWS ( language-range [ weight ] ) ] )
//      language-range  = ( 1*8ALPHA *( "-" 1*8alphanum ) ) / "*"   ; [RFC4647], Section 2.1
//      alphanum        = ALPHA / DIGIT
//
//       Accept-Language: da, en-gb;q=0.8, en;q=0.7


//      token           = 1*tchar
//      tchar           = "!" / "#" / "$" / "%" / "&" / "'" / "*"
//                        / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
//                        / DIGIT / ALPHA
//                        ; any VCHAR, except delimiters
//      OWS             = *( SP / HTAB )


//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)
//
//      The weight is normalized to a real number in the range 0 through 1,
//      where 0.001 is the least preferred and 1 is the most preferred; a
//      value of 0 means "not acceptable".  If no "q" parameter is present,
//      the default weight is 1.
//
//       weight = OWS ";" OWS "q=" qvalue
//       qvalue = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )


internals.parse = function (raw, preferences, options) {

    // Normalize header (remove spaces and tabs)

    const header = raw.replace(/[ \t]/g, '');

    // Normalize preferences

    const lowers = Object.create(null);
    if (preferences) {
        for (let i = 0; i < preferences.length; ++i) {
            const preference = preferences[i];
            lowers[preference.toLowerCase()] = { orig: preference, pos: i };
        }
    }

    // Parse selections

    const parts = header.split(',');
    const selections = [];
    const map = {};

    for (let i = 0; i < parts.length; ++i) {
        const part = parts[i];
        if (!part) {                            // Ignore empty parts or leading commas
            continue;
        }

        // Parse parameters

        const params = part.split(';');
        if (params.length > 2) {
            throw Boom.badRequest(`Invalid ${options.type} header`);
        }

        let token = params[0].toLowerCase();
        if (!token) {
            throw Boom.badRequest(`Invalid ${options.type} header`);
        }

        if (options.equivalents &&
            options.equivalents[token]) {

            token = options.equivalents[token];
        }

        const selection = {
            token,
            pos: i,
            q: 1,
            specificity: options.specificity ? token.split('-') : null
        };

        if (preferences &&
            lowers[token]) {

            selection.pref = lowers[token].pos;
        }

        map[selection.token] = selection;

        // Parse q=value

        if (params.length === 2) {
            const q = params[1];
            const [key, value] = q.split('=');

            if (!value ||
                (key !== 'q' && key !== 'Q')) {

                throw Boom.badRequest(`Invalid ${options.type} header`);
            }

            const score = parseFloat(value);
            if (score === 0) {
                continue;
            }

            if (Number.isFinite(score) &&
                score <= 1 &&
                score >= 0.001) {

                selection.q = score;
            }
        }

        selections.push(selection);             // Only add allowed selections (q !== 0)
    }

    // Sort selection based on q and then position in header

    selections.sort(internals.sort);

    // Extract tokens

    const values = selections.map((selection) => selection.token);

    if (options.default &&
        !map[options.default]) {

        values.push(options.default);
    }

    if (!preferences ||
        !preferences.length) {

        return values;
    }

    const preferred = [];
    for (const selection of values) {
        if (selection === '*') {
            for (const preference of Object.keys(lowers)) {
                if (!map[preference]) {
                    preferred.push(lowers[preference].orig);
                }
            }
        }
        else {
            const lower = selection.toLowerCase();
            if (lowers[lower]) {
                preferred.push(lowers[lower].orig);
            }
        }
    }

    return preferred;
};


internals.sort = function (a, b) {

    const aFirst = -1;
    const bFirst = 1;

    if (b.q !== a.q) {
        return b.q - a.q;
    }

    if (b.pref !== a.pref) {
        if (a.pref === undefined) {
            return bFirst;
        }

        if (b.pref === undefined) {
            return aFirst;
        }

        return a.pref - b.pref;
    }

    if (a.specificity &&
        a.specificity[0] === b.specificity[0] &&
        a.specificity.length !== b.specificity.length) {

        return b.specificity.length - a.specificity.length;
    }

    return a.pos - b.pos;
};


/***/ }),

/***/ "./node_modules/@hapi/accept/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/accept/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Header = __webpack_require__(/*! ./header */ "./node_modules/@hapi/accept/lib/header.js");
const Media = __webpack_require__(/*! ./media */ "./node_modules/@hapi/accept/lib/media.js");


const internals = {
    options: {
        charset: {
            type: 'accept-charset'
        },
        encoding: {
            type: 'accept-encoding',
            default: 'identity',
            equivalents: {
                'x-compress': 'compress',
                'x-gzip': 'gzip'
            }
        },
        language: {
            type: 'accept-language',
            specificity: true
        }
    }
};


for (const type in internals.options) {
    exports[type] = (header, preferences) => Header.selection(header, preferences, internals.options[type]);

    exports[`${type}s`] = (header, preferences) => Header.selections(header, preferences, internals.options[type]);
}


exports.mediaType = (header, preferences) => Media.selection(header, preferences);

exports.mediaTypes = (header, preferences) => Media.selections(header, preferences);


exports.parseAll = function (requestHeaders) {

    return {
        charsets: exports.charsets(requestHeaders['accept-charset']),
        encodings: exports.encodings(requestHeaders['accept-encoding']),
        languages: exports.languages(requestHeaders['accept-language']),
        mediaTypes: exports.mediaTypes(requestHeaders.accept)
    };
};


/***/ }),

/***/ "./node_modules/@hapi/accept/lib/media.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/accept/lib/media.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


exports.selection = function (header, preferences) {

    const selections = exports.selections(header, preferences);
    return selections.length ? selections[0] : '';
};


exports.selections = function (header, preferences) {

    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');

    return internals.parse(header, preferences);
};


//      RFC 7231 Section 5.3.2 (https://tools.ietf.org/html/rfc7231#section-5.3.2)
//
//      Accept          = [ ( "," / ( media-range [ accept-params ] ) ) *( OWS "," [ OWS ( media-range [ accept-params ] ) ] ) ]
//      media-range     = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) ) *( OWS ";" OWS parameter )
//      accept-params   = weight *accept-ext
//      accept-ext      = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
//      type            = token
//      subtype         = token
//      parameter       = token "=" ( token / quoted-string )
//
//      quoted-string   = DQUOTE *( qdtext / quoted-pair ) DQUOTE
//      qdtext          = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
//      obs-text        = %x80-FF
//      quoted-pair     = "\" ( HTAB / SP / VCHAR / obs-text )
//      VCHAR           = %x21-7E                                ; visible (printing) characters
//      token           = 1*tchar
//      tchar           = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
//      OWS             = *( SP / HTAB )
//
//      Accept: audio/*; q=0.2, audio/basic
//      Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
//      Accept: text/plain, application/json;q=0.5, text/html, */*; q = 0.1
//      Accept: text/plain, application/json;q=0.5, text/html, text/drop;q=0
//      Accept: text/*, text/plain, text/plain;format=flowed, */*
//      Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5


//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)
//
//      The weight is normalized to a real number in the range 0 through 1,
//      where 0.001 is the least preferred and 1 is the most preferred; a
//      value of 0 means "not acceptable".  If no "q" parameter is present,
//      the default weight is 1.
//
//       weight = OWS ";" OWS "q=" qvalue
//       qvalue = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )


//                         */*        type/*                              type/subtype
internals.validMediaRx = /^(?:\*\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/[\w\!#\$%&'\*\+\-\.\^`\|~]+)$/;


internals.parse = function (raw, preferences) {

    // Normalize header (remove spaces and temporary remove quoted strings)

    const { header, quoted } = internals.normalize(raw);

    // Parse selections

    const parts = header.split(',');
    const selections = [];
    const map = {};

    for (let i = 0; i < parts.length; ++i) {
        const part = parts[i];
        if (!part) {                                    // Ignore empty parts or leading commas
            continue;
        }

        // Parse parameters

        const pairs = part.split(';');
        const token = pairs.shift().toLowerCase();

        if (!internals.validMediaRx.test(token)) {       // Ignore invalid types
            continue;
        }

        const selection = {
            token,
            params: {},
            exts: {},
            pos: i
        };

        // Parse key=value

        let target = 'params';
        for (const pair of pairs) {
            const kv = pair.split('=');
            if (kv.length !== 2 ||
                !kv[1]) {

                throw Boom.badRequest(`Invalid accept header`);
            }

            const key = kv[0];
            let value = kv[1];

            if (key === 'q' ||
                key === 'Q') {

                target = 'exts';

                value = parseFloat(value);
                if (!Number.isFinite(value) ||
                    value > 1 ||
                    (value < 0.001 && value !== 0)) {

                    value = 1;
                }

                selection.q = value;
            }
            else {
                if (value[0] === '"') {
                    value = `"${quoted[value]}"`;
                }

                selection[target][kv[0]] = value;
            }
        }

        const params = Object.keys(selection.params);
        selection.original = [''].concat(params.map((key) => `${key}=${selection.params[key]}`)).join(';');
        selection.specificity = params.length;

        if (selection.q === undefined) {     // Default no preference to q=1 (top preference)
            selection.q = 1;
        }

        const tparts = selection.token.split('/');
        selection.type = tparts[0];
        selection.subtype = tparts[1];

        map[selection.token] = selection;

        if (selection.q) {                   // Skip denied selections (q=0)
            selections.push(selection);
        }
    }

    // Sort selection based on q and then position in header

    selections.sort(internals.sort);

    return internals.preferences(map, selections, preferences);
};


internals.normalize = function (raw) {

    raw = raw || '*/*';

    const normalized = {
        header: raw,
        quoted: {}
    };

    if (raw.includes('"')) {
        let i = 0;
        normalized.header = raw.replace(/="([^"]*)"/g, ($0, $1) => {

            const key = '"' + ++i;
            normalized.quoted[key] = $1;
            return '=' + key;
        });
    }

    normalized.header = normalized.header.replace(/[ \t]/g, '');
    return normalized;
};


internals.sort = function (a, b) {

    // Sort by quality score

    if (b.q !== a.q) {
        return b.q - a.q;
    }

    // Sort by type

    if (a.type !== b.type) {
        return internals.innerSort(a, b, 'type');
    }

    // Sort by subtype

    if (a.subtype !== b.subtype) {
        return internals.innerSort(a, b, 'subtype');
    }

    // Sort by specificity

    if (a.specificity !== b.specificity) {
        return b.specificity - a.specificity;
    }

    return a.pos - b.pos;
};


internals.innerSort = function (a, b, key) {

    const aFirst = -1;
    const bFirst = 1;

    if (a[key] === '*') {
        return bFirst;
    }

    if (b[key] === '*') {
        return aFirst;
    }

    return a[key] < b[key] ? aFirst : bFirst;       // Group alphabetically
};


internals.preferences = function (map, selections, preferences) {

    // Return selections if no preferences

    if (!preferences ||
        !preferences.length) {

        return selections.map((selection) => selection.token + selection.original);
    }

    // Map wildcards and filter selections to preferences

    const lowers = Object.create(null);
    const flat = Object.create(null);
    let any = false;

    for (const preference of preferences) {
        const lower = preference.toLowerCase();
        flat[lower] = preference;
        const parts = lower.split('/');
        const type = parts[0];
        const subtype = parts[1];

        if (type === '*') {
            Hoek.assert(subtype === '*', 'Invalid media type preference contains wildcard type with a subtype');
            any = true;
            continue;
        }

        lowers[type] = lowers[type] || Object.create(null);
        lowers[type][subtype] = preference;
    }

    const preferred = [];
    for (const selection of selections) {
        const token = selection.token;
        const { type, subtype } = map[token];
        const subtypes = lowers[type];

        // */*

        if (type === '*') {
            for (const preference of Object.keys(flat)) {
                if (!map[preference]) {
                    preferred.push(flat[preference]);
                }
            }

            if (any) {
                preferred.push('*/*');
            }

            continue;
        }

        // any

        if (any) {
            preferred.push((flat[token] || token) + selection.original);
            continue;
        }

        // type/subtype

        if (subtype !== '*') {
            const pref = flat[token];
            if (pref ||
                (subtypes && subtypes['*'])) {

                preferred.push((pref || token) + selection.original);
            }

            continue;
        }

        // type/*

        if (subtypes) {
            for (const psub of Object.keys(subtypes)) {
                if (!map[`${type}/${psub}`]) {
                    preferred.push(subtypes[psub]);
                }
            }
        }
    }

    return preferred;
};


/***/ }),

/***/ "./node_modules/@hapi/address/lib/domain.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/address/lib/domain.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Url = __webpack_require__(/*! url */ "url");


const internals = {
    minDomainSegments: 2,
    nonAsciiRx: /[^\x00-\x7f]/,
    domainControlRx: /[\x00-\x20]/,                                                     // Control + space
    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    URL: Url.URL || URL                                                                 // $lab:coverage:ignore$
};


exports.analyze = function (domain, options = {}) {

    if (typeof domain !== 'string') {
        throw new Error('Invalid input: domain must be a string');
    }

    if (!domain) {
        return { error: 'Domain must be a non-empty string' };
    }

    if (domain.length > 256) {
        return { error: 'Domain too long' };
    }

    const ascii = !internals.nonAsciiRx.test(domain);
    if (!ascii) {
        if (options.allowUnicode === false) {                                           // Defaults to true
            return { error: 'Domain contains forbidden Unicode characters' };
        }

        domain = domain.normalize('NFC');
    }

    if (internals.domainControlRx.test(domain)) {
        return { error: 'Domain contains invalid character' };
    }

    domain = internals.punycode(domain);

    // https://tools.ietf.org/html/rfc1035 section 2.3.1

    const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;

    const segments = domain.split('.');
    if (segments.length < minDomainSegments) {
        return { error: 'Domain lacks the minimum required number of segments' };
    }

    const tlds = options.tlds;
    if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) ||
            tlds.allow && !tlds.allow.has(tld)) {

            return { error: 'Domain uses forbidden TLD' };
        }
    }

    for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];

        if (!segment.length) {
            return { error: 'Domain contains empty dot-separated segment' };
        }

        if (segment.length > 63) {
            return { error: 'Domain contains dot-separated segment that is too long' };
        }

        if (i < segments.length - 1) {
            if (!internals.domainSegmentRx.test(segment)) {
                return { error: 'Domain contains invalid character' };
            }
        }
        else {
            if (!internals.tldSegmentRx.test(segment)) {
                return { error: 'Domain contains invalid tld character' };
            }
        }
    }
};


exports.isValid = function (domain, options) {

    return !exports.analyze(domain, options);
};


internals.punycode = function (domain) {

    try {
        return new internals.URL(`http://${domain}`).host;
    }
    catch (err) {
        return domain;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/address/lib/email.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/address/lib/email.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Util = __webpack_require__(/*! util */ "util");

const Domain = __webpack_require__(/*! ./domain */ "./node_modules/@hapi/address/lib/domain.js");


const internals = {
    nonAsciiRx: /[^\x00-\x7f]/,
    encoder: new (Util.TextEncoder || TextEncoder)()                                            // $lab:coverage:ignore$
};


exports.analyze = function (email, options) {

    return internals.email(email, options);
};


exports.isValid = function (email, options) {

    return !internals.email(email, options);
};


internals.email = function (email, options = {}) {

    if (typeof email !== 'string') {
        throw new Error('Invalid input: email must be a string');
    }

    if (!email) {
        return { error: 'Address must be a non-empty string' };
    }

    // Unicode

    const ascii = !internals.nonAsciiRx.test(email);
    if (!ascii) {
        if (options.allowUnicode === false) {                                                   // Defaults to true
            return { error: 'Address contains forbidden Unicode characters' };
        }

        email = email.normalize('NFC');
    }

    // Basic structure

    const parts = email.split('@');
    if (parts.length !== 2) {
        return { error: parts.length > 2 ? 'Address cannot contain more than one @ character' : 'Address must contain one @ character' };
    }

    const [local, domain] = parts;

    if (!local) {
        return { error: 'Address local part cannot be empty' };
    }

    if (!options.ignoreLength) {
        if (email.length > 254) {                                           // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
            return { error: 'Address too long' };
        }

        if (internals.encoder.encode(local).length > 64) {                  // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
            return { error: 'Address local part too long' };
        }
    }

    // Validate parts

    return internals.local(local, ascii) || Domain.analyze(domain, options);
};


internals.local = function (local, ascii) {

    const segments = local.split('.');
    for (const segment of segments) {
        if (!segment.length) {
            return { error: 'Address local part contains empty dot-separated segment' };
        }

        if (ascii) {
            if (!internals.atextRx.test(segment)) {
                return { error: 'Address local part contains invalid character' };
            }

            continue;
        }

        for (const char of segment) {
            if (internals.atextRx.test(char)) {
                continue;
            }

            const binary = internals.binary(char);
            if (!internals.atomRx.test(binary)) {
                return { error: 'Address local part contains invalid character' };
            }
        }
    }
};


internals.binary = function (char) {

    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join('');
};


/*
    From RFC 5321:

        Mailbox         =   Local-part "@" ( Domain / address-literal )

        Local-part      =   Dot-string / Quoted-string
        Dot-string      =   Atom *("."  Atom)
        Atom            =   1*atext
        atext           =   ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"

        Domain          =   sub-domain *("." sub-domain)
        sub-domain      =   Let-dig [Ldh-str]
        Let-dig         =   ALPHA / DIGIT
        Ldh-str         =   *( ALPHA / DIGIT / "-" ) Let-dig

        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z
        DIGIT           =   %x30-39                  ; 0-9

    From RFC 6531:

        sub-domain      =/  U-label
        atext           =/  UTF8-non-ascii

        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4

        UTF8-2          =   %xC2-DF UTF8-tail
        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /
                            %xE1-EC 2( UTF8-tail ) /
                            %xED %x80-9F UTF8-tail /
                            %xEE-EF 2( UTF8-tail )
        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /
                            %xF1-F3 3( UTF8-tail ) /
                            %xF4 %x80-8F 2( UTF8-tail )

        UTF8-tail       =   %x80-BF

    Note: The following are not supported:

        RFC 5321: address-literal, Quoted-string
        RFC 5322: obs-*, CFWS
*/


internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;               // _ included in \w


internals.atomRx = new RegExp([

    //  %xC2-DF UTF8-tail
    '(?:[\\xc2-\\xdf][\\x80-\\xbf])',

    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
    '(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})',

    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
    '(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})'

].join('|'));


/***/ }),

/***/ "./node_modules/@hapi/address/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/address/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Domain = __webpack_require__(/*! ./domain */ "./node_modules/@hapi/address/lib/domain.js");
const Email = __webpack_require__(/*! ./email */ "./node_modules/@hapi/address/lib/email.js");
const Tlds = __webpack_require__(/*! ./tlds */ "./node_modules/@hapi/address/lib/tlds.js");


const internals = {
    defaultTlds: { allow: Tlds, deny: null }
};


module.exports = {
    domain: {
        analyze(domain, options) {

            options = internals.options(options);
            return Domain.analyze(domain, options);
        },

        isValid(domain, options) {

            options = internals.options(options);
            return Domain.isValid(domain, options);
        }
    },
    email: {
        analyze(email, options) {

            options = internals.options(options);
            return Email.analyze(email, options);
        },

        isValid(email, options) {

            options = internals.options(options);
            return Email.isValid(email, options);
        }
    }
};


internals.options = function (options) {

    if (!options) {
        return { tlds: internals.defaultTlds };
    }

    if (options.tlds === false) {                // Defaults to true
        return options;
    }

    if (!options.tlds ||
        options.tlds === true) {

        return Object.assign({}, options, { tlds: internals.defaultTlds });
    }

    if (typeof options.tlds !== 'object') {
        throw new Error('Invalid options: tlds must be a boolean or an object');
    }

    if (options.tlds.deny) {
        if (options.tlds.deny instanceof Set === false) {
            throw new Error('Invalid options: tlds.deny must be a Set object');
        }

        if (options.tlds.allow) {
            throw new Error('Invalid options: cannot specify both tlds.allow and tlds.deny lists');
        }

        return options;
    }

    if (options.tlds.allow === true) {
        return Object.assign({}, options, { tlds: internals.defaultTlds });
    }

    if (options.tlds.allow instanceof Set === false) {
        throw new Error('Invalid options: tlds.allow must be a Set object or true');
    }

    return options;
};


/***/ }),

/***/ "./node_modules/@hapi/address/lib/tlds.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/address/lib/tlds.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


// http://data.iana.org/TLD/tlds-alpha-by-domain.txt
// # Version 2019091902, Last Updated Fri Sep 20 07: 07: 02 2019 UTC


internals.tlds = [
    'AAA',
    'AARP',
    'ABARTH',
    'ABB',
    'ABBOTT',
    'ABBVIE',
    'ABC',
    'ABLE',
    'ABOGADO',
    'ABUDHABI',
    'AC',
    'ACADEMY',
    'ACCENTURE',
    'ACCOUNTANT',
    'ACCOUNTANTS',
    'ACO',
    'ACTOR',
    'AD',
    'ADAC',
    'ADS',
    'ADULT',
    'AE',
    'AEG',
    'AERO',
    'AETNA',
    'AF',
    'AFAMILYCOMPANY',
    'AFL',
    'AFRICA',
    'AG',
    'AGAKHAN',
    'AGENCY',
    'AI',
    'AIG',
    'AIGO',
    'AIRBUS',
    'AIRFORCE',
    'AIRTEL',
    'AKDN',
    'AL',
    'ALFAROMEO',
    'ALIBABA',
    'ALIPAY',
    'ALLFINANZ',
    'ALLSTATE',
    'ALLY',
    'ALSACE',
    'ALSTOM',
    'AM',
    'AMERICANEXPRESS',
    'AMERICANFAMILY',
    'AMEX',
    'AMFAM',
    'AMICA',
    'AMSTERDAM',
    'ANALYTICS',
    'ANDROID',
    'ANQUAN',
    'ANZ',
    'AO',
    'AOL',
    'APARTMENTS',
    'APP',
    'APPLE',
    'AQ',
    'AQUARELLE',
    'AR',
    'ARAB',
    'ARAMCO',
    'ARCHI',
    'ARMY',
    'ARPA',
    'ART',
    'ARTE',
    'AS',
    'ASDA',
    'ASIA',
    'ASSOCIATES',
    'AT',
    'ATHLETA',
    'ATTORNEY',
    'AU',
    'AUCTION',
    'AUDI',
    'AUDIBLE',
    'AUDIO',
    'AUSPOST',
    'AUTHOR',
    'AUTO',
    'AUTOS',
    'AVIANCA',
    'AW',
    'AWS',
    'AX',
    'AXA',
    'AZ',
    'AZURE',
    'BA',
    'BABY',
    'BAIDU',
    'BANAMEX',
    'BANANAREPUBLIC',
    'BAND',
    'BANK',
    'BAR',
    'BARCELONA',
    'BARCLAYCARD',
    'BARCLAYS',
    'BAREFOOT',
    'BARGAINS',
    'BASEBALL',
    'BASKETBALL',
    'BAUHAUS',
    'BAYERN',
    'BB',
    'BBC',
    'BBT',
    'BBVA',
    'BCG',
    'BCN',
    'BD',
    'BE',
    'BEATS',
    'BEAUTY',
    'BEER',
    'BENTLEY',
    'BERLIN',
    'BEST',
    'BESTBUY',
    'BET',
    'BF',
    'BG',
    'BH',
    'BHARTI',
    'BI',
    'BIBLE',
    'BID',
    'BIKE',
    'BING',
    'BINGO',
    'BIO',
    'BIZ',
    'BJ',
    'BLACK',
    'BLACKFRIDAY',
    'BLOCKBUSTER',
    'BLOG',
    'BLOOMBERG',
    'BLUE',
    'BM',
    'BMS',
    'BMW',
    'BN',
    'BNPPARIBAS',
    'BO',
    'BOATS',
    'BOEHRINGER',
    'BOFA',
    'BOM',
    'BOND',
    'BOO',
    'BOOK',
    'BOOKING',
    'BOSCH',
    'BOSTIK',
    'BOSTON',
    'BOT',
    'BOUTIQUE',
    'BOX',
    'BR',
    'BRADESCO',
    'BRIDGESTONE',
    'BROADWAY',
    'BROKER',
    'BROTHER',
    'BRUSSELS',
    'BS',
    'BT',
    'BUDAPEST',
    'BUGATTI',
    'BUILD',
    'BUILDERS',
    'BUSINESS',
    'BUY',
    'BUZZ',
    'BV',
    'BW',
    'BY',
    'BZ',
    'BZH',
    'CA',
    'CAB',
    'CAFE',
    'CAL',
    'CALL',
    'CALVINKLEIN',
    'CAM',
    'CAMERA',
    'CAMP',
    'CANCERRESEARCH',
    'CANON',
    'CAPETOWN',
    'CAPITAL',
    'CAPITALONE',
    'CAR',
    'CARAVAN',
    'CARDS',
    'CARE',
    'CAREER',
    'CAREERS',
    'CARS',
    'CARTIER',
    'CASA',
    'CASE',
    'CASEIH',
    'CASH',
    'CASINO',
    'CAT',
    'CATERING',
    'CATHOLIC',
    'CBA',
    'CBN',
    'CBRE',
    'CBS',
    'CC',
    'CD',
    'CEB',
    'CENTER',
    'CEO',
    'CERN',
    'CF',
    'CFA',
    'CFD',
    'CG',
    'CH',
    'CHANEL',
    'CHANNEL',
    'CHARITY',
    'CHASE',
    'CHAT',
    'CHEAP',
    'CHINTAI',
    'CHRISTMAS',
    'CHROME',
    'CHRYSLER',
    'CHURCH',
    'CI',
    'CIPRIANI',
    'CIRCLE',
    'CISCO',
    'CITADEL',
    'CITI',
    'CITIC',
    'CITY',
    'CITYEATS',
    'CK',
    'CL',
    'CLAIMS',
    'CLEANING',
    'CLICK',
    'CLINIC',
    'CLINIQUE',
    'CLOTHING',
    'CLOUD',
    'CLUB',
    'CLUBMED',
    'CM',
    'CN',
    'CO',
    'COACH',
    'CODES',
    'COFFEE',
    'COLLEGE',
    'COLOGNE',
    'COM',
    'COMCAST',
    'COMMBANK',
    'COMMUNITY',
    'COMPANY',
    'COMPARE',
    'COMPUTER',
    'COMSEC',
    'CONDOS',
    'CONSTRUCTION',
    'CONSULTING',
    'CONTACT',
    'CONTRACTORS',
    'COOKING',
    'COOKINGCHANNEL',
    'COOL',
    'COOP',
    'CORSICA',
    'COUNTRY',
    'COUPON',
    'COUPONS',
    'COURSES',
    'CR',
    'CREDIT',
    'CREDITCARD',
    'CREDITUNION',
    'CRICKET',
    'CROWN',
    'CRS',
    'CRUISE',
    'CRUISES',
    'CSC',
    'CU',
    'CUISINELLA',
    'CV',
    'CW',
    'CX',
    'CY',
    'CYMRU',
    'CYOU',
    'CZ',
    'DABUR',
    'DAD',
    'DANCE',
    'DATA',
    'DATE',
    'DATING',
    'DATSUN',
    'DAY',
    'DCLK',
    'DDS',
    'DE',
    'DEAL',
    'DEALER',
    'DEALS',
    'DEGREE',
    'DELIVERY',
    'DELL',
    'DELOITTE',
    'DELTA',
    'DEMOCRAT',
    'DENTAL',
    'DENTIST',
    'DESI',
    'DESIGN',
    'DEV',
    'DHL',
    'DIAMONDS',
    'DIET',
    'DIGITAL',
    'DIRECT',
    'DIRECTORY',
    'DISCOUNT',
    'DISCOVER',
    'DISH',
    'DIY',
    'DJ',
    'DK',
    'DM',
    'DNP',
    'DO',
    'DOCS',
    'DOCTOR',
    'DODGE',
    'DOG',
    'DOMAINS',
    'DOT',
    'DOWNLOAD',
    'DRIVE',
    'DTV',
    'DUBAI',
    'DUCK',
    'DUNLOP',
    'DUPONT',
    'DURBAN',
    'DVAG',
    'DVR',
    'DZ',
    'EARTH',
    'EAT',
    'EC',
    'ECO',
    'EDEKA',
    'EDU',
    'EDUCATION',
    'EE',
    'EG',
    'EMAIL',
    'EMERCK',
    'ENERGY',
    'ENGINEER',
    'ENGINEERING',
    'ENTERPRISES',
    'EPSON',
    'EQUIPMENT',
    'ER',
    'ERICSSON',
    'ERNI',
    'ES',
    'ESQ',
    'ESTATE',
    'ESURANCE',
    'ET',
    'ETISALAT',
    'EU',
    'EUROVISION',
    'EUS',
    'EVENTS',
    'EVERBANK',
    'EXCHANGE',
    'EXPERT',
    'EXPOSED',
    'EXPRESS',
    'EXTRASPACE',
    'FAGE',
    'FAIL',
    'FAIRWINDS',
    'FAITH',
    'FAMILY',
    'FAN',
    'FANS',
    'FARM',
    'FARMERS',
    'FASHION',
    'FAST',
    'FEDEX',
    'FEEDBACK',
    'FERRARI',
    'FERRERO',
    'FI',
    'FIAT',
    'FIDELITY',
    'FIDO',
    'FILM',
    'FINAL',
    'FINANCE',
    'FINANCIAL',
    'FIRE',
    'FIRESTONE',
    'FIRMDALE',
    'FISH',
    'FISHING',
    'FIT',
    'FITNESS',
    'FJ',
    'FK',
    'FLICKR',
    'FLIGHTS',
    'FLIR',
    'FLORIST',
    'FLOWERS',
    'FLY',
    'FM',
    'FO',
    'FOO',
    'FOOD',
    'FOODNETWORK',
    'FOOTBALL',
    'FORD',
    'FOREX',
    'FORSALE',
    'FORUM',
    'FOUNDATION',
    'FOX',
    'FR',
    'FREE',
    'FRESENIUS',
    'FRL',
    'FROGANS',
    'FRONTDOOR',
    'FRONTIER',
    'FTR',
    'FUJITSU',
    'FUJIXEROX',
    'FUN',
    'FUND',
    'FURNITURE',
    'FUTBOL',
    'FYI',
    'GA',
    'GAL',
    'GALLERY',
    'GALLO',
    'GALLUP',
    'GAME',
    'GAMES',
    'GAP',
    'GARDEN',
    'GAY',
    'GB',
    'GBIZ',
    'GD',
    'GDN',
    'GE',
    'GEA',
    'GENT',
    'GENTING',
    'GEORGE',
    'GF',
    'GG',
    'GGEE',
    'GH',
    'GI',
    'GIFT',
    'GIFTS',
    'GIVES',
    'GIVING',
    'GL',
    'GLADE',
    'GLASS',
    'GLE',
    'GLOBAL',
    'GLOBO',
    'GM',
    'GMAIL',
    'GMBH',
    'GMO',
    'GMX',
    'GN',
    'GODADDY',
    'GOLD',
    'GOLDPOINT',
    'GOLF',
    'GOO',
    'GOODYEAR',
    'GOOG',
    'GOOGLE',
    'GOP',
    'GOT',
    'GOV',
    'GP',
    'GQ',
    'GR',
    'GRAINGER',
    'GRAPHICS',
    'GRATIS',
    'GREEN',
    'GRIPE',
    'GROCERY',
    'GROUP',
    'GS',
    'GT',
    'GU',
    'GUARDIAN',
    'GUCCI',
    'GUGE',
    'GUIDE',
    'GUITARS',
    'GURU',
    'GW',
    'GY',
    'HAIR',
    'HAMBURG',
    'HANGOUT',
    'HAUS',
    'HBO',
    'HDFC',
    'HDFCBANK',
    'HEALTH',
    'HEALTHCARE',
    'HELP',
    'HELSINKI',
    'HERE',
    'HERMES',
    'HGTV',
    'HIPHOP',
    'HISAMITSU',
    'HITACHI',
    'HIV',
    'HK',
    'HKT',
    'HM',
    'HN',
    'HOCKEY',
    'HOLDINGS',
    'HOLIDAY',
    'HOMEDEPOT',
    'HOMEGOODS',
    'HOMES',
    'HOMESENSE',
    'HONDA',
    'HORSE',
    'HOSPITAL',
    'HOST',
    'HOSTING',
    'HOT',
    'HOTELES',
    'HOTELS',
    'HOTMAIL',
    'HOUSE',
    'HOW',
    'HR',
    'HSBC',
    'HT',
    'HU',
    'HUGHES',
    'HYATT',
    'HYUNDAI',
    'IBM',
    'ICBC',
    'ICE',
    'ICU',
    'ID',
    'IE',
    'IEEE',
    'IFM',
    'IKANO',
    'IL',
    'IM',
    'IMAMAT',
    'IMDB',
    'IMMO',
    'IMMOBILIEN',
    'IN',
    'INC',
    'INDUSTRIES',
    'INFINITI',
    'INFO',
    'ING',
    'INK',
    'INSTITUTE',
    'INSURANCE',
    'INSURE',
    'INT',
    'INTEL',
    'INTERNATIONAL',
    'INTUIT',
    'INVESTMENTS',
    'IO',
    'IPIRANGA',
    'IQ',
    'IR',
    'IRISH',
    'IS',
    'ISMAILI',
    'IST',
    'ISTANBUL',
    'IT',
    'ITAU',
    'ITV',
    'IVECO',
    'JAGUAR',
    'JAVA',
    'JCB',
    'JCP',
    'JE',
    'JEEP',
    'JETZT',
    'JEWELRY',
    'JIO',
    'JLL',
    'JM',
    'JMP',
    'JNJ',
    'JO',
    'JOBS',
    'JOBURG',
    'JOT',
    'JOY',
    'JP',
    'JPMORGAN',
    'JPRS',
    'JUEGOS',
    'JUNIPER',
    'KAUFEN',
    'KDDI',
    'KE',
    'KERRYHOTELS',
    'KERRYLOGISTICS',
    'KERRYPROPERTIES',
    'KFH',
    'KG',
    'KH',
    'KI',
    'KIA',
    'KIM',
    'KINDER',
    'KINDLE',
    'KITCHEN',
    'KIWI',
    'KM',
    'KN',
    'KOELN',
    'KOMATSU',
    'KOSHER',
    'KP',
    'KPMG',
    'KPN',
    'KR',
    'KRD',
    'KRED',
    'KUOKGROUP',
    'KW',
    'KY',
    'KYOTO',
    'KZ',
    'LA',
    'LACAIXA',
    'LADBROKES',
    'LAMBORGHINI',
    'LAMER',
    'LANCASTER',
    'LANCIA',
    'LANCOME',
    'LAND',
    'LANDROVER',
    'LANXESS',
    'LASALLE',
    'LAT',
    'LATINO',
    'LATROBE',
    'LAW',
    'LAWYER',
    'LB',
    'LC',
    'LDS',
    'LEASE',
    'LECLERC',
    'LEFRAK',
    'LEGAL',
    'LEGO',
    'LEXUS',
    'LGBT',
    'LI',
    'LIAISON',
    'LIDL',
    'LIFE',
    'LIFEINSURANCE',
    'LIFESTYLE',
    'LIGHTING',
    'LIKE',
    'LILLY',
    'LIMITED',
    'LIMO',
    'LINCOLN',
    'LINDE',
    'LINK',
    'LIPSY',
    'LIVE',
    'LIVING',
    'LIXIL',
    'LK',
    'LLC',
    'LOAN',
    'LOANS',
    'LOCKER',
    'LOCUS',
    'LOFT',
    'LOL',
    'LONDON',
    'LOTTE',
    'LOTTO',
    'LOVE',
    'LPL',
    'LPLFINANCIAL',
    'LR',
    'LS',
    'LT',
    'LTD',
    'LTDA',
    'LU',
    'LUNDBECK',
    'LUPIN',
    'LUXE',
    'LUXURY',
    'LV',
    'LY',
    'MA',
    'MACYS',
    'MADRID',
    'MAIF',
    'MAISON',
    'MAKEUP',
    'MAN',
    'MANAGEMENT',
    'MANGO',
    'MAP',
    'MARKET',
    'MARKETING',
    'MARKETS',
    'MARRIOTT',
    'MARSHALLS',
    'MASERATI',
    'MATTEL',
    'MBA',
    'MC',
    'MCKINSEY',
    'MD',
    'ME',
    'MED',
    'MEDIA',
    'MEET',
    'MELBOURNE',
    'MEME',
    'MEMORIAL',
    'MEN',
    'MENU',
    'MERCKMSD',
    'METLIFE',
    'MG',
    'MH',
    'MIAMI',
    'MICROSOFT',
    'MIL',
    'MINI',
    'MINT',
    'MIT',
    'MITSUBISHI',
    'MK',
    'ML',
    'MLB',
    'MLS',
    'MM',
    'MMA',
    'MN',
    'MO',
    'MOBI',
    'MOBILE',
    'MODA',
    'MOE',
    'MOI',
    'MOM',
    'MONASH',
    'MONEY',
    'MONSTER',
    'MOPAR',
    'MORMON',
    'MORTGAGE',
    'MOSCOW',
    'MOTO',
    'MOTORCYCLES',
    'MOV',
    'MOVIE',
    'MOVISTAR',
    'MP',
    'MQ',
    'MR',
    'MS',
    'MSD',
    'MT',
    'MTN',
    'MTR',
    'MU',
    'MUSEUM',
    'MUTUAL',
    'MV',
    'MW',
    'MX',
    'MY',
    'MZ',
    'NA',
    'NAB',
    'NADEX',
    'NAGOYA',
    'NAME',
    'NATIONWIDE',
    'NATURA',
    'NAVY',
    'NBA',
    'NC',
    'NE',
    'NEC',
    'NET',
    'NETBANK',
    'NETFLIX',
    'NETWORK',
    'NEUSTAR',
    'NEW',
    'NEWHOLLAND',
    'NEWS',
    'NEXT',
    'NEXTDIRECT',
    'NEXUS',
    'NF',
    'NFL',
    'NG',
    'NGO',
    'NHK',
    'NI',
    'NICO',
    'NIKE',
    'NIKON',
    'NINJA',
    'NISSAN',
    'NISSAY',
    'NL',
    'NO',
    'NOKIA',
    'NORTHWESTERNMUTUAL',
    'NORTON',
    'NOW',
    'NOWRUZ',
    'NOWTV',
    'NP',
    'NR',
    'NRA',
    'NRW',
    'NTT',
    'NU',
    'NYC',
    'NZ',
    'OBI',
    'OBSERVER',
    'OFF',
    'OFFICE',
    'OKINAWA',
    'OLAYAN',
    'OLAYANGROUP',
    'OLDNAVY',
    'OLLO',
    'OM',
    'OMEGA',
    'ONE',
    'ONG',
    'ONL',
    'ONLINE',
    'ONYOURSIDE',
    'OOO',
    'OPEN',
    'ORACLE',
    'ORANGE',
    'ORG',
    'ORGANIC',
    'ORIGINS',
    'OSAKA',
    'OTSUKA',
    'OTT',
    'OVH',
    'PA',
    'PAGE',
    'PANASONIC',
    'PARIS',
    'PARS',
    'PARTNERS',
    'PARTS',
    'PARTY',
    'PASSAGENS',
    'PAY',
    'PCCW',
    'PE',
    'PET',
    'PF',
    'PFIZER',
    'PG',
    'PH',
    'PHARMACY',
    'PHD',
    'PHILIPS',
    'PHONE',
    'PHOTO',
    'PHOTOGRAPHY',
    'PHOTOS',
    'PHYSIO',
    'PIAGET',
    'PICS',
    'PICTET',
    'PICTURES',
    'PID',
    'PIN',
    'PING',
    'PINK',
    'PIONEER',
    'PIZZA',
    'PK',
    'PL',
    'PLACE',
    'PLAY',
    'PLAYSTATION',
    'PLUMBING',
    'PLUS',
    'PM',
    'PN',
    'PNC',
    'POHL',
    'POKER',
    'POLITIE',
    'PORN',
    'POST',
    'PR',
    'PRAMERICA',
    'PRAXI',
    'PRESS',
    'PRIME',
    'PRO',
    'PROD',
    'PRODUCTIONS',
    'PROF',
    'PROGRESSIVE',
    'PROMO',
    'PROPERTIES',
    'PROPERTY',
    'PROTECTION',
    'PRU',
    'PRUDENTIAL',
    'PS',
    'PT',
    'PUB',
    'PW',
    'PWC',
    'PY',
    'QA',
    'QPON',
    'QUEBEC',
    'QUEST',
    'QVC',
    'RACING',
    'RADIO',
    'RAID',
    'RE',
    'READ',
    'REALESTATE',
    'REALTOR',
    'REALTY',
    'RECIPES',
    'RED',
    'REDSTONE',
    'REDUMBRELLA',
    'REHAB',
    'REISE',
    'REISEN',
    'REIT',
    'RELIANCE',
    'REN',
    'RENT',
    'RENTALS',
    'REPAIR',
    'REPORT',
    'REPUBLICAN',
    'REST',
    'RESTAURANT',
    'REVIEW',
    'REVIEWS',
    'REXROTH',
    'RICH',
    'RICHARDLI',
    'RICOH',
    'RIGHTATHOME',
    'RIL',
    'RIO',
    'RIP',
    'RMIT',
    'RO',
    'ROCHER',
    'ROCKS',
    'RODEO',
    'ROGERS',
    'ROOM',
    'RS',
    'RSVP',
    'RU',
    'RUGBY',
    'RUHR',
    'RUN',
    'RW',
    'RWE',
    'RYUKYU',
    'SA',
    'SAARLAND',
    'SAFE',
    'SAFETY',
    'SAKURA',
    'SALE',
    'SALON',
    'SAMSCLUB',
    'SAMSUNG',
    'SANDVIK',
    'SANDVIKCOROMANT',
    'SANOFI',
    'SAP',
    'SARL',
    'SAS',
    'SAVE',
    'SAXO',
    'SB',
    'SBI',
    'SBS',
    'SC',
    'SCA',
    'SCB',
    'SCHAEFFLER',
    'SCHMIDT',
    'SCHOLARSHIPS',
    'SCHOOL',
    'SCHULE',
    'SCHWARZ',
    'SCIENCE',
    'SCJOHNSON',
    'SCOR',
    'SCOT',
    'SD',
    'SE',
    'SEARCH',
    'SEAT',
    'SECURE',
    'SECURITY',
    'SEEK',
    'SELECT',
    'SENER',
    'SERVICES',
    'SES',
    'SEVEN',
    'SEW',
    'SEX',
    'SEXY',
    'SFR',
    'SG',
    'SH',
    'SHANGRILA',
    'SHARP',
    'SHAW',
    'SHELL',
    'SHIA',
    'SHIKSHA',
    'SHOES',
    'SHOP',
    'SHOPPING',
    'SHOUJI',
    'SHOW',
    'SHOWTIME',
    'SHRIRAM',
    'SI',
    'SILK',
    'SINA',
    'SINGLES',
    'SITE',
    'SJ',
    'SK',
    'SKI',
    'SKIN',
    'SKY',
    'SKYPE',
    'SL',
    'SLING',
    'SM',
    'SMART',
    'SMILE',
    'SN',
    'SNCF',
    'SO',
    'SOCCER',
    'SOCIAL',
    'SOFTBANK',
    'SOFTWARE',
    'SOHU',
    'SOLAR',
    'SOLUTIONS',
    'SONG',
    'SONY',
    'SOY',
    'SPACE',
    'SPORT',
    'SPOT',
    'SPREADBETTING',
    'SR',
    'SRL',
    'SRT',
    'SS',
    'ST',
    'STADA',
    'STAPLES',
    'STAR',
    'STATEBANK',
    'STATEFARM',
    'STC',
    'STCGROUP',
    'STOCKHOLM',
    'STORAGE',
    'STORE',
    'STREAM',
    'STUDIO',
    'STUDY',
    'STYLE',
    'SU',
    'SUCKS',
    'SUPPLIES',
    'SUPPLY',
    'SUPPORT',
    'SURF',
    'SURGERY',
    'SUZUKI',
    'SV',
    'SWATCH',
    'SWIFTCOVER',
    'SWISS',
    'SX',
    'SY',
    'SYDNEY',
    'SYMANTEC',
    'SYSTEMS',
    'SZ',
    'TAB',
    'TAIPEI',
    'TALK',
    'TAOBAO',
    'TARGET',
    'TATAMOTORS',
    'TATAR',
    'TATTOO',
    'TAX',
    'TAXI',
    'TC',
    'TCI',
    'TD',
    'TDK',
    'TEAM',
    'TECH',
    'TECHNOLOGY',
    'TEL',
    'TELEFONICA',
    'TEMASEK',
    'TENNIS',
    'TEVA',
    'TF',
    'TG',
    'TH',
    'THD',
    'THEATER',
    'THEATRE',
    'TIAA',
    'TICKETS',
    'TIENDA',
    'TIFFANY',
    'TIPS',
    'TIRES',
    'TIROL',
    'TJ',
    'TJMAXX',
    'TJX',
    'TK',
    'TKMAXX',
    'TL',
    'TM',
    'TMALL',
    'TN',
    'TO',
    'TODAY',
    'TOKYO',
    'TOOLS',
    'TOP',
    'TORAY',
    'TOSHIBA',
    'TOTAL',
    'TOURS',
    'TOWN',
    'TOYOTA',
    'TOYS',
    'TR',
    'TRADE',
    'TRADING',
    'TRAINING',
    'TRAVEL',
    'TRAVELCHANNEL',
    'TRAVELERS',
    'TRAVELERSINSURANCE',
    'TRUST',
    'TRV',
    'TT',
    'TUBE',
    'TUI',
    'TUNES',
    'TUSHU',
    'TV',
    'TVS',
    'TW',
    'TZ',
    'UA',
    'UBANK',
    'UBS',
    'UCONNECT',
    'UG',
    'UK',
    'UNICOM',
    'UNIVERSITY',
    'UNO',
    'UOL',
    'UPS',
    'US',
    'UY',
    'UZ',
    'VA',
    'VACATIONS',
    'VANA',
    'VANGUARD',
    'VC',
    'VE',
    'VEGAS',
    'VENTURES',
    'VERISIGN',
    'VERSICHERUNG',
    'VET',
    'VG',
    'VI',
    'VIAJES',
    'VIDEO',
    'VIG',
    'VIKING',
    'VILLAS',
    'VIN',
    'VIP',
    'VIRGIN',
    'VISA',
    'VISION',
    'VISTAPRINT',
    'VIVA',
    'VIVO',
    'VLAANDEREN',
    'VN',
    'VODKA',
    'VOLKSWAGEN',
    'VOLVO',
    'VOTE',
    'VOTING',
    'VOTO',
    'VOYAGE',
    'VU',
    'VUELOS',
    'WALES',
    'WALMART',
    'WALTER',
    'WANG',
    'WANGGOU',
    'WARMAN',
    'WATCH',
    'WATCHES',
    'WEATHER',
    'WEATHERCHANNEL',
    'WEBCAM',
    'WEBER',
    'WEBSITE',
    'WED',
    'WEDDING',
    'WEIBO',
    'WEIR',
    'WF',
    'WHOSWHO',
    'WIEN',
    'WIKI',
    'WILLIAMHILL',
    'WIN',
    'WINDOWS',
    'WINE',
    'WINNERS',
    'WME',
    'WOLTERSKLUWER',
    'WOODSIDE',
    'WORK',
    'WORKS',
    'WORLD',
    'WOW',
    'WS',
    'WTC',
    'WTF',
    'XBOX',
    'XEROX',
    'XFINITY',
    'XIHUAN',
    'XIN',
    'XN--11B4C3D',
    'XN--1CK2E1B',
    'XN--1QQW23A',
    'XN--2SCRJ9C',
    'XN--30RR7Y',
    'XN--3BST00M',
    'XN--3DS443G',
    'XN--3E0B707E',
    'XN--3HCRJ9C',
    'XN--3OQ18VL8PN36A',
    'XN--3PXU8K',
    'XN--42C2D9A',
    'XN--45BR5CYL',
    'XN--45BRJ9C',
    'XN--45Q11C',
    'XN--4GBRIM',
    'XN--54B7FTA0CC',
    'XN--55QW42G',
    'XN--55QX5D',
    'XN--5SU34J936BGSG',
    'XN--5TZM5G',
    'XN--6FRZ82G',
    'XN--6QQ986B3XL',
    'XN--80ADXHKS',
    'XN--80AO21A',
    'XN--80AQECDR1A',
    'XN--80ASEHDB',
    'XN--80ASWG',
    'XN--8Y0A063A',
    'XN--90A3AC',
    'XN--90AE',
    'XN--90AIS',
    'XN--9DBQ2A',
    'XN--9ET52U',
    'XN--9KRT00A',
    'XN--B4W605FERD',
    'XN--BCK1B9A5DRE4C',
    'XN--C1AVG',
    'XN--C2BR7G',
    'XN--CCK2B3B',
    'XN--CG4BKI',
    'XN--CLCHC0EA0B2G2A9GCD',
    'XN--CZR694B',
    'XN--CZRS0T',
    'XN--CZRU2D',
    'XN--D1ACJ3B',
    'XN--D1ALF',
    'XN--E1A4C',
    'XN--ECKVDTC9D',
    'XN--EFVY88H',
    'XN--ESTV75G',
    'XN--FCT429K',
    'XN--FHBEI',
    'XN--FIQ228C5HS',
    'XN--FIQ64B',
    'XN--FIQS8S',
    'XN--FIQZ9S',
    'XN--FJQ720A',
    'XN--FLW351E',
    'XN--FPCRJ9C3D',
    'XN--FZC2C9E2C',
    'XN--FZYS8D69UVGM',
    'XN--G2XX48C',
    'XN--GCKR3F0F',
    'XN--GECRJ9C',
    'XN--GK3AT1E',
    'XN--H2BREG3EVE',
    'XN--H2BRJ9C',
    'XN--H2BRJ9C8C',
    'XN--HXT814E',
    'XN--I1B6B1A6A2E',
    'XN--IMR513N',
    'XN--IO0A7I',
    'XN--J1AEF',
    'XN--J1AMH',
    'XN--J6W193G',
    'XN--JLQ61U9W7B',
    'XN--JVR189M',
    'XN--KCRX77D1X4A',
    'XN--KPRW13D',
    'XN--KPRY57D',
    'XN--KPU716F',
    'XN--KPUT3I',
    'XN--L1ACC',
    'XN--LGBBAT1AD8J',
    'XN--MGB9AWBF',
    'XN--MGBA3A3EJT',
    'XN--MGBA3A4F16A',
    'XN--MGBA7C0BBN0A',
    'XN--MGBAAKC7DVF',
    'XN--MGBAAM7A8H',
    'XN--MGBAB2BD',
    'XN--MGBAH1A3HJKRD',
    'XN--MGBAI9AZGQP6J',
    'XN--MGBAYH7GPA',
    'XN--MGBBH1A',
    'XN--MGBBH1A71E',
    'XN--MGBC0A9AZCG',
    'XN--MGBCA7DZDO',
    'XN--MGBERP4A5D4AR',
    'XN--MGBGU82A',
    'XN--MGBI4ECEXP',
    'XN--MGBPL2FH',
    'XN--MGBT3DHD',
    'XN--MGBTX2B',
    'XN--MGBX4CD0AB',
    'XN--MIX891F',
    'XN--MK1BU44C',
    'XN--MXTQ1M',
    'XN--NGBC5AZD',
    'XN--NGBE9E0A',
    'XN--NGBRX',
    'XN--NODE',
    'XN--NQV7F',
    'XN--NQV7FS00EMA',
    'XN--NYQY26A',
    'XN--O3CW4H',
    'XN--OGBPF8FL',
    'XN--OTU796D',
    'XN--P1ACF',
    'XN--P1AI',
    'XN--PBT977C',
    'XN--PGBS0DH',
    'XN--PSSY2U',
    'XN--Q9JYB4C',
    'XN--QCKA1PMC',
    'XN--QXA6A',
    'XN--QXAM',
    'XN--RHQV96G',
    'XN--ROVU88B',
    'XN--RVC1E0AM3E',
    'XN--S9BRJ9C',
    'XN--SES554G',
    'XN--T60B56A',
    'XN--TCKWE',
    'XN--TIQ49XQYJ',
    'XN--UNUP4Y',
    'XN--VERMGENSBERATER-CTB',
    'XN--VERMGENSBERATUNG-PWB',
    'XN--VHQUV',
    'XN--VUQ861B',
    'XN--W4R85EL8FHU5DNRA',
    'XN--W4RS40L',
    'XN--WGBH1C',
    'XN--WGBL6A',
    'XN--XHQ521B',
    'XN--XKC2AL3HYE2A',
    'XN--XKC2DL3A5EE0H',
    'XN--Y9A3AQ',
    'XN--YFRO4I67O',
    'XN--YGBI2AMMX',
    'XN--ZFR164B',
    'XXX',
    'XYZ',
    'YACHTS',
    'YAHOO',
    'YAMAXUN',
    'YANDEX',
    'YE',
    'YODOBASHI',
    'YOGA',
    'YOKOHAMA',
    'YOU',
    'YOUTUBE',
    'YT',
    'YUN',
    'ZA',
    'ZAPPOS',
    'ZARA',
    'ZERO',
    'ZIP',
    'ZM',
    'ZONE',
    'ZUERICH',
    'ZW'
];


// Keep as upper-case to make updating from source easier

module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));


/***/ }),

/***/ "./node_modules/@hapi/ammo/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/ammo/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


internals.Range = class {

    constructor(from, to) {

        this.from = from;
        this.to = to;
    }
};


exports.header = function (header, length) {

    // Parse header

    const parts = header.split('=');
    if (parts.length !== 2 ||
        parts[0] !== 'bytes') {

        return null;
    }

    const lastPos = length - 1;

    const result = [];
    const ranges = parts[1].match(/\d*\-\d*/g);

    // Handle headers with multiple ranges

    for (let i = 0; i < ranges.length; ++i) {
        let range = ranges[i];
        if (range.length === 1) {               // '-'
            return null;
        }

        let from;
        let to;
        range = range.split('-');
        if (range[0]) {
            from = parseInt(range[0], 10);
        }

        if (range[1]) {
            to = parseInt(range[1], 10);
            if (from !== undefined) {      // Can be 0
                // From-To
                if (to > lastPos) {
                    to = lastPos;
                }
            }
            else {
                // -To
                from = length - to;
                to = lastPos;
            }
        }
        else {
            // From-
            to = lastPos;
        }

        if (from > to) {
            return null;
        }

        result.push(new internals.Range(from, to));
    }

    if (result.length === 1) {
        return result;
    }

    // Sort and consolidate ranges

    result.sort((a, b) => a.from - b.from);

    const consolidated = [];
    for (let i = result.length - 1; i > 0; --i) {
        const current = result[i];
        const before = result[i - 1];
        if (current.from <= before.to + 1) {
            before.to = current.to;
        }
        else {
            consolidated.unshift(current);
        }
    }

    consolidated.unshift(result[0]);

    return consolidated;
};


exports.Stream = internals.Stream = class extends Stream.Transform {

    constructor(range) {

        if (!(range instanceof internals.Range)) {
            Hoek.assert(typeof range === 'object', 'Expected "range" object');

            const from = range.from || 0;
            Hoek.assert(typeof from === 'number', '"range.from" must be falsy, or a number');
            Hoek.assert(from === parseInt(from, 10) && from >= 0, '"range.from" must be a positive integer');

            const to = range.to || 0;
            Hoek.assert(typeof to === 'number', '"range.to" must be falsy, or a number');
            Hoek.assert(to === parseInt(to, 10) && to >= 0, '"range.to" must be a positive integer');

            Hoek.assert(to >= from, '"range.to" must be greater than or equal to "range.from"');

            range = new internals.Range(from, to);
        }

        super();

        this._range = range;
        this._next = 0;
    }

    processChunk(chunk) {

        // Read desired range from a stream

        const pos = this._next;
        this._next = this._next + chunk.length;

        if (this._next <= this._range.from ||       // Before range
            pos > this._range.to) {                 // After range

            return;
        }

        // Calc bounds of chunk to read

        const from = Math.max(0, this._range.from - pos);
        const to = Math.min(chunk.length, this._range.to - pos + 1);

        this.push(chunk.slice(from, to));
    }

    _transform(chunk, encoding, done) {

        try {
            this.processChunk(chunk);
        }
        catch (err) {
            return done(err);
        }

        return done();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/b64/lib/decoder.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/b64/lib/decoder.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    Decode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

const Stream = __webpack_require__(/*! stream */ "stream");


const internals = {
    decodeChars: [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
    ]
};


exports.decode = function (buffer) {

    const decodeChars = internals.decodeChars;
    const len = buffer.length;
    const allocated = Math.ceil(len / 4) * 3;
    const result = Buffer.alloc(allocated);

    let c1;
    let c2;
    let c3;
    let c4;
    let j = 0;

    for (let i = 0; i < len; ) {
        do {
            c1 = decodeChars[buffer[i++] & 0xff];
        }
        while (i < len && c1 === -1);

        if (c1 === -1) {
            break;
        }

        do {
            c2 = decodeChars[buffer[i++] & 0xff];
        }
        while (i < len && c2 === -1);

        if (c2 === -1) {
            break;
        }

        result[j++] = (c1 << 2) | ((c2 & 0x30) >> 4);

        do {
            c3 = buffer[i++] & 0xff;
            if (c3 === 61) {                        // =
                return result.slice(0, j);
            }

            c3 = decodeChars[c3];
        }
        while (i < len && c3 === -1);

        if (c3 === -1) {
            break;
        }

        result[j++] = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);

        do {
            c4 = buffer[i++] & 0xff;
            if (c4 === 61) {                        // =
                return result.slice(0, j);
            }

            c4 = decodeChars[c4];
        }
        while (i < len && c4 === -1);

        if (c4 !== -1) {
            result[j++] = ((c3 & 0x03) << 6) | c4;
        }
    }

    return (j === allocated ? result : result.slice(0, j));
};


exports.Decoder = class Decoder extends Stream.Transform {
    constructor() {

        super();
        this._reminder = null;
    }

    _transform(chunk, encoding, callback) {

        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 4;
        if (remaining) {
            this._reminder = part.slice(part.length - remaining);
            part = part.slice(0, part.length - remaining);
        }
        else {
            this._reminder = null;
        }

        this.push(exports.decode(part));
        return callback();
    }

    _flush(callback) {

        if (this._reminder) {
            this.push(exports.decode(this._reminder));
        }

        return callback();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/b64/lib/encoder.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/b64/lib/encoder.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    Encode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

const Stream = __webpack_require__(/*! stream */ "stream");


const internals = {};


exports.encode = function (buffer) {

    return Buffer.from(buffer.toString('base64'));
};


exports.Encoder = class Encoder extends Stream.Transform {
    constructor() {

        super();
        this._reminder = null;
    }

    _transform(chunk, encoding, callback) {

        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 3;
        if (remaining) {
            this._reminder = part.slice(part.length - remaining);
            part = part.slice(0, part.length - remaining);
        }
        else {
            this._reminder = null;
        }

        this.push(exports.encode(part));
        return callback();
    }

    _flush(callback) {

        if (this._reminder) {
            this.push(exports.encode(this._reminder));
        }

        return callback();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/b64/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/b64/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/@hapi/b64/lib/decoder.js");
const Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/@hapi/b64/lib/encoder.js");


exports.decode = Decoder.decode;

exports.encode = Encoder.encode;

exports.Decoder = Decoder.Decoder;

exports.Encoder = Encoder.Encoder;


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value, encoding) {

    Hoek.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');
    const buf = (Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || 'binary'));
    return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (value, encoding) {

    if (typeof value !== 'string') {

        throw new Error('Value not a string');
    }

    if (!/^[\w\-]*$/.test(value)) {

        throw new Error('Invalid character');
    }

    const buf = Buffer.from(value, 'base64');
    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
};


/***/ }),

/***/ "./node_modules/@hapi/boom/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/boom/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    codes: new Map([
        [100, 'Continue'],
        [101, 'Switching Protocols'],
        [102, 'Processing'],
        [200, 'OK'],
        [201, 'Created'],
        [202, 'Accepted'],
        [203, 'Non-Authoritative Information'],
        [204, 'No Content'],
        [205, 'Reset Content'],
        [206, 'Partial Content'],
        [207, 'Multi-Status'],
        [300, 'Multiple Choices'],
        [301, 'Moved Permanently'],
        [302, 'Moved Temporarily'],
        [303, 'See Other'],
        [304, 'Not Modified'],
        [305, 'Use Proxy'],
        [307, 'Temporary Redirect'],
        [400, 'Bad Request'],
        [401, 'Unauthorized'],
        [402, 'Payment Required'],
        [403, 'Forbidden'],
        [404, 'Not Found'],
        [405, 'Method Not Allowed'],
        [406, 'Not Acceptable'],
        [407, 'Proxy Authentication Required'],
        [408, 'Request Time-out'],
        [409, 'Conflict'],
        [410, 'Gone'],
        [411, 'Length Required'],
        [412, 'Precondition Failed'],
        [413, 'Request Entity Too Large'],
        [414, 'Request-URI Too Large'],
        [415, 'Unsupported Media Type'],
        [416, 'Requested Range Not Satisfiable'],
        [417, 'Expectation Failed'],
        [418, 'I\'m a teapot'],
        [422, 'Unprocessable Entity'],
        [423, 'Locked'],
        [424, 'Failed Dependency'],
        [425, 'Unordered Collection'],
        [426, 'Upgrade Required'],
        [428, 'Precondition Required'],
        [429, 'Too Many Requests'],
        [431, 'Request Header Fields Too Large'],
        [451, 'Unavailable For Legal Reasons'],
        [500, 'Internal Server Error'],
        [501, 'Not Implemented'],
        [502, 'Bad Gateway'],
        [503, 'Service Unavailable'],
        [504, 'Gateway Time-out'],
        [505, 'HTTP Version Not Supported'],
        [506, 'Variant Also Negotiates'],
        [507, 'Insufficient Storage'],
        [509, 'Bandwidth Limit Exceeded'],
        [510, 'Not Extended'],
        [511, 'Network Authentication Required']
    ])
};


module.exports = internals.Boom = class extends Error {

    constructor(message, options = {}) {

        if (message instanceof Error) {
            return internals.Boom.boomify(Hoek.clone(message), options);
        }

        const { statusCode = 500, data = null, ctor = internals.Boom } = options;
        const error = new Error(message ? message : undefined);         // Avoids settings null message
        Error.captureStackTrace(error, ctor);                           // Filter the stack to our external API
        error.data = data;
        const boom = internals.initialize(error, statusCode);

        Object.defineProperty(boom, 'typeof', { value: ctor });

        if (options.decorate) {
            Object.assign(boom, options.decorate);
        }

        return boom;
    }

    static [Symbol.hasInstance](instance) {

        return internals.Boom.isBoom(instance);
    }

    static isBoom(err) {

        return err instanceof Error && !!err.isBoom;
    }

    static boomify(err, options) {

        Hoek.assert(err instanceof Error, 'Cannot wrap non-Error object');

        options = options || {};

        if (options.data !== undefined) {
            err.data = options.data;
        }

        if (options.decorate) {
            Object.assign(err, options.decorate);
        }

        if (!err.isBoom) {
            return internals.initialize(err, options.statusCode || 500, options.message);
        }

        if (options.override === false ||                           // Defaults to true
            !options.statusCode && !options.message) {

            return err;
        }

        return internals.initialize(err, options.statusCode || err.output.statusCode, options.message);
    }

    // 4xx Client Errors

    static badRequest(message, data) {

        return new internals.Boom(message, { statusCode: 400, data, ctor: internals.Boom.badRequest });
    }

    static unauthorized(message, scheme, attributes) {          // Or (message, wwwAuthenticate[])

        const err = new internals.Boom(message, { statusCode: 401, ctor: internals.Boom.unauthorized });

        // function (message)

        if (!scheme) {
            return err;
        }

        // function (message, wwwAuthenticate[])

        if (typeof scheme !== 'string') {
            err.output.headers['WWW-Authenticate'] = scheme.join(', ');
            return err;
        }

        // function (message, scheme, attributes)

        let wwwAuthenticate = `${scheme} `;

        if (attributes ||
            message) {

            err.output.payload.attributes = {};
        }

        if (attributes) {
            if (typeof attributes === 'string') {
                wwwAuthenticate += Hoek.escapeHeaderAttribute(attributes);
                err.output.payload.attributes = attributes;
            }
            else {
                wwwAuthenticate += Object.keys(attributes).map((name) => {

                    let value = attributes[name];
                    if (value === null ||
                        value === undefined) {

                        value = '';
                    }

                    err.output.payload.attributes[name] = value;
                    return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
                })
                    .join(', ');
            }
        }

        if (message) {
            if (attributes) {
                wwwAuthenticate += ', ';
            }

            wwwAuthenticate += `error="${Hoek.escapeHeaderAttribute(message)}"`;
            err.output.payload.attributes.error = message;
        }
        else {
            err.isMissing = true;
        }

        err.output.headers['WWW-Authenticate'] = wwwAuthenticate;
        return err;
    }

    static paymentRequired(message, data) {

        return new internals.Boom(message, { statusCode: 402, data, ctor: internals.Boom.paymentRequired });
    }

    static forbidden(message, data) {

        return new internals.Boom(message, { statusCode: 403, data, ctor: internals.Boom.forbidden });
    }

    static notFound(message, data) {

        return new internals.Boom(message, { statusCode: 404, data, ctor: internals.Boom.notFound });
    }

    static methodNotAllowed(message, data, allow) {

        const err = new internals.Boom(message, { statusCode: 405, data, ctor: internals.Boom.methodNotAllowed });

        if (typeof allow === 'string') {
            allow = [allow];
        }

        if (Array.isArray(allow)) {
            err.output.headers.Allow = allow.join(', ');
        }

        return err;
    }

    static notAcceptable(message, data) {

        return new internals.Boom(message, { statusCode: 406, data, ctor: internals.Boom.notAcceptable });
    }

    static proxyAuthRequired(message, data) {

        return new internals.Boom(message, { statusCode: 407, data, ctor: internals.Boom.proxyAuthRequired });
    }

    static clientTimeout(message, data) {

        return new internals.Boom(message, { statusCode: 408, data, ctor: internals.Boom.clientTimeout });
    }

    static conflict(message, data) {

        return new internals.Boom(message, { statusCode: 409, data, ctor: internals.Boom.conflict });
    }

    static resourceGone(message, data) {

        return new internals.Boom(message, { statusCode: 410, data, ctor: internals.Boom.resourceGone });
    }

    static lengthRequired(message, data) {

        return new internals.Boom(message, { statusCode: 411, data, ctor: internals.Boom.lengthRequired });
    }

    static preconditionFailed(message, data) {

        return new internals.Boom(message, { statusCode: 412, data, ctor: internals.Boom.preconditionFailed });
    }

    static entityTooLarge(message, data) {

        return new internals.Boom(message, { statusCode: 413, data, ctor: internals.Boom.entityTooLarge });
    }

    static uriTooLong(message, data) {

        return new internals.Boom(message, { statusCode: 414, data, ctor: internals.Boom.uriTooLong });
    }

    static unsupportedMediaType(message, data) {

        return new internals.Boom(message, { statusCode: 415, data, ctor: internals.Boom.unsupportedMediaType });
    }

    static rangeNotSatisfiable(message, data) {

        return new internals.Boom(message, { statusCode: 416, data, ctor: internals.Boom.rangeNotSatisfiable });
    }

    static expectationFailed(message, data) {

        return new internals.Boom(message, { statusCode: 417, data, ctor: internals.Boom.expectationFailed });
    }

    static teapot(message, data) {

        return new internals.Boom(message, { statusCode: 418, data, ctor: internals.Boom.teapot });
    }

    static badData(message, data) {

        return new internals.Boom(message, { statusCode: 422, data, ctor: internals.Boom.badData });
    }

    static locked(message, data) {

        return new internals.Boom(message, { statusCode: 423, data, ctor: internals.Boom.locked });
    }

    static failedDependency(message, data) {

        return new internals.Boom(message, { statusCode: 424, data, ctor: internals.Boom.failedDependency });
    }

    static preconditionRequired(message, data) {

        return new internals.Boom(message, { statusCode: 428, data, ctor: internals.Boom.preconditionRequired });
    }

    static tooManyRequests(message, data) {

        return new internals.Boom(message, { statusCode: 429, data, ctor: internals.Boom.tooManyRequests });
    }

    static illegal(message, data) {

        return new internals.Boom(message, { statusCode: 451, data, ctor: internals.Boom.illegal });
    }

    // 5xx Server Errors

    static internal(message, data, statusCode = 500) {

        return internals.serverError(message, data, statusCode, internals.Boom.internal);
    }

    static notImplemented(message, data) {

        return internals.serverError(message, data, 501, internals.Boom.notImplemented);
    }

    static badGateway(message, data) {

        return internals.serverError(message, data, 502, internals.Boom.badGateway);
    }

    static serverUnavailable(message, data) {

        return internals.serverError(message, data, 503, internals.Boom.serverUnavailable);
    }

    static gatewayTimeout(message, data) {

        return internals.serverError(message, data, 504, internals.Boom.gatewayTimeout);
    }

    static badImplementation(message, data) {

        const err = internals.serverError(message, data, 500, internals.Boom.badImplementation);
        err.isDeveloperError = true;
        return err;
    }
};


internals.Boom.default = internals.Boom;        // Support ES6 module import


internals.initialize = function (err, statusCode, message) {

    const numberCode = parseInt(statusCode, 10);
    Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);

    err.isBoom = true;
    err.isServer = numberCode >= 500;

    if (!err.hasOwnProperty('data')) {
        err.data = null;
    }

    err.output = {
        statusCode: numberCode,
        payload: {},
        headers: {}
    };

    Object.defineProperty(err, 'reformat', { value: internals.reformat });

    if (!message &&
        !err.message) {

        err.reformat();
        message = err.output.payload.error;
    }

    if (message) {
        const props = Object.getOwnPropertyDescriptor(err, 'message') || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), 'message');
        Hoek.assert(props.configurable && !props.get, 'The error is not compatible with boom');

        err.message = message + (err.message ? ': ' + err.message : '');
        err.output.payload.message = err.message;
    }

    err.reformat();
    return err;
};


internals.reformat = function (debug = false) {

    this.output.payload.statusCode = this.output.statusCode;
    this.output.payload.error = internals.codes.get(this.output.statusCode) || 'Unknown';

    if (this.output.statusCode === 500 && debug !== true) {
        this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user
    }
    else if (this.message) {
        this.output.payload.message = this.message;
    }
};


internals.serverError = function (message, data, statusCode, ctor) {

    if (data instanceof Error &&
        !data.isBoom) {

        return internals.Boom.boomify(data, { statusCode, message });
    }

    return new internals.Boom(message, { statusCode, data, ctor });
};


/***/ }),

/***/ "./node_modules/@hapi/bounce/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/bounce/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! assert */ "assert");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    system: [

        // JavaScript

        EvalError,
        RangeError,
        ReferenceError,
        SyntaxError,
        TypeError,
        URIError,

        // Node

        Assert.AssertionError,

        // Hoek

        Hoek.Error
    ]
};


exports.rethrow = function (err, types, options = {}) {

    return internals.catch(err, types, options, true);
};


exports.ignore = function (err, types, options = {}) {

    return internals.catch(err, types, options, false);
};


internals.catch = function (err, types, options, match) {

    if (internals.match(err, types) !== match) {
        return;
    }

    // Error replacement

    if (options.override) {
        err = options.override;
    }

    // Error decorations

    if (options.decorate) {
        Object.assign(err, options.decorate);
    }

    if (options.return) {
        return err;
    }

    throw err;
};


exports.background = async function (operation, action = 'rethrow', types = 'system', options = {}) {

    try {
        if (typeof operation === 'function') {
            await operation();
        }
        else {
            await operation;
        }
    }
    catch (err) {
        exports[action](err, types, options);
    }
};


exports.isBoom = function (err) {

    return Boom.isBoom(err);
};


exports.isError = function (err) {

    return err instanceof Error;
};


exports.isSystem = function (err) {

    if (!err) {
        return false;
    }

    if (err.isBoom) {
        return false;
    }

    for (const system of internals.system) {
        if (err instanceof system) {
            return true;
        }
    }

    return false;
};


internals.rules = {
    system: exports.isSystem,
    boom: exports.isBoom
};


internals.match = function (err, types) {

    if (!types) {
        return true;
    }

    types = Array.isArray(types) ? types : [types];
    for (const type of types) {
        if (typeof type === 'string') {
            if (internals.rules[type](err)) {
                return true;
            }
        }
        else if (typeof type === 'object') {
            if (Hoek.contain(err, type, { deep: true, part: true })) {
                return true;
            }
        }
        else if (err instanceof type) {
            return true;
        }
    }

    return false;
};


/***/ }),

/***/ "./node_modules/@hapi/bourne/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/bourne/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



const internals = {
    suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
};


exports.parse = function (text, reviver, options) {

    // Normalize arguments

    if (!options) {
        if (reviver &&
            typeof reviver === 'object') {

            options = reviver;
            reviver = undefined;
        }
        else {
            options = {};
        }
    }

    // Parse normally, allowing exceptions

    const obj = JSON.parse(text, reviver);

    // options.protoAction: 'error' (default) / 'remove' / 'ignore'

    if (options.protoAction === 'ignore') {
        return obj;
    }

    // Ignore null and non-objects

    if (!obj ||
        typeof obj !== 'object') {

        return obj;
    }

    // Check original string for potential exploit

    if (!text.match(internals.suspectRx)) {
        return obj;
    }

    // Scan result for proto keys

    exports.scan(obj, options);

    return obj;
};


exports.scan = function (obj, options) {

    options = options || {};

    let next = [obj];

    while (next.length) {
        const nodes = next;
        next = [];

        for (const node of nodes) {
            if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {      // Avoid calling node.hasOwnProperty directly
                if (options.protoAction !== 'remove') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }

                delete node.__proto__;
            }

            for (const key in node) {
                const value = node[key];
                if (value &&
                    typeof value === 'object') {

                    next.push(node[key]);
                }
            }
        }
    }
};


exports.safeParse = function (text, reviver) {

    try {
        return exports.parse(text, reviver);
    }
    catch (ignoreError) {
        return null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/call/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/call/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");

const Regex = __webpack_require__(/*! ./regex */ "./node_modules/@hapi/call/lib/regex.js");
const Segment = __webpack_require__(/*! ./segment */ "./node_modules/@hapi/call/lib/segment.js");


const internals = {
    pathRegex: Regex.generate(),
    defaults: {
        isCaseSensitive: true
    }
};


exports.Router = internals.Router = function (options) {

    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});

    this.routes = {};                               // Key: HTTP method or * for catch-all, value: sorted array of routes
    this.ids = {};                                  // Key: route id, value: record
    this.vhosts = null;                             // {} where Key: hostname, value: see this.routes

    this.specials = {
        badRequest: null,
        notFound: null,
        options: null
    };
};


internals.Router.prototype.add = function (config, route) {

    const method = config.method.toLowerCase();

    const vhost = config.vhost || '*';
    if (vhost !== '*') {
        this.vhosts = this.vhosts || {};
        this.vhosts[vhost] = this.vhosts[vhost] || {};
    }

    const table = (vhost === '*' ? this.routes : this.vhosts[vhost]);
    table[method] = table[method] || { routes: [], router: new Segment() };

    const analysis = config.analysis || this.analyze(config.path);
    const record = {
        path: config.path,
        route: route || config.path,
        segments: analysis.segments,
        params: analysis.params,
        fingerprint: analysis.fingerprint,
        settings: this.settings
    };

    // Add route

    table[method].router.add(analysis.segments, record);
    table[method].routes.push(record);
    table[method].routes.sort(internals.sort);

    const last = record.segments[record.segments.length - 1];
    if (last.empty) {
        table[method].router.add(analysis.segments.slice(0, -1), record);
    }

    if (config.id) {
        Hoek.assert(!this.ids[config.id], 'Route id', config.id, 'for path', config.path, 'conflicts with existing path', this.ids[config.id] && this.ids[config.id].path);
        this.ids[config.id] = record;
    }

    return record;
};


internals.Router.prototype.special = function (type, route) {

    Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, 'Unknown special route type:', type);

    this.specials[type] = { route };
};


internals.Router.prototype.route = function (method, path, hostname) {

    const segments = path.split('/').slice(1);

    const vhost = (this.vhosts && hostname && this.vhosts[hostname]);
    const route = (vhost && this._lookup(path, segments, vhost, method)) ||
        this._lookup(path, segments, this.routes, method) ||
        (method === 'head' && vhost && this._lookup(path, segments, vhost, 'get')) ||
        (method === 'head' && this._lookup(path, segments, this.routes, 'get')) ||
        (method === 'options' && this.specials.options) ||
        (vhost && this._lookup(path, segments, vhost, '*')) ||
        this._lookup(path, segments, this.routes, '*') ||
        this.specials.notFound || Boom.notFound();

    return route;
};


internals.Router.prototype._lookup = function (path, segments, table, method) {

    const set = table[method];
    if (!set) {
        return null;
    }

    const match = set.router.lookup(path, segments, this.settings);
    if (!match) {
        return null;
    }

    const assignments = {};
    const array = [];
    for (let i = 0; i < match.array.length; ++i) {
        const name = match.record.params[i];
        const value = internals.decode(match.array[i]);
        if (value.isBoom) {
            return this.specials.badRequest || value;
        }

        if (assignments[name] !== undefined) {
            assignments[name] = assignments[name] + '/' + value;
        }
        else {
            assignments[name] = value;
        }

        if (i + 1 === match.array.length ||                 // Only include the last segment of a multi-segment param
            name !== match.record.params[i + 1]) {

            array.push(assignments[name]);
        }
    }

    return { params: assignments, paramsArray: array, route: match.record.route };
};


internals.decode = function (value) {

    try {
        return decodeURIComponent(value);
    }
    catch (err) {
        return Boom.badRequest('Invalid request path');
    }
};


internals.Router.prototype.normalize = function (path) {

    if (path &&
        path.indexOf('%') !== -1) {

        // Uppercase %encoded values

        const uppercase = path.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, (encoded) => encoded.toUpperCase());

        // Decode non-reserved path characters: a-z A-Z 0-9 _!$&'()*+,;=:@-.~
        // ! (%21) $ (%24) & (%26) ' (%27) ( (%28) ) (%29) * (%2A) + (%2B) , (%2C) - (%2D) . (%2E)
        // 0-9 (%30-39) : (%3A) ; (%3B) = (%3D)
        // @ (%40) A-Z (%41-5A) _ (%5F) a-z (%61-7A) ~ (%7E)

        const decoded = uppercase.replace(/%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g, (encoded) => String.fromCharCode(parseInt(encoded.substring(1), 16)));

        path = decoded;
    }

    // Normalize path segments

    if (path &&
        (path.indexOf('/.') !== -1 || path[0] === '.')) {

        const hasLeadingDash = path[0] === '/';
        const segments = path.split('/');
        const normalized = [];
        let segment;

        for (let i = 0; i < segments.length; ++i) {
            segment = segments[i];
            if (segment === '..') {
                normalized.pop();
            }
            else if (segment !== '.') {
                normalized.push(segment);
            }
        }

        if (segment === '.' ||
            segment === '..') {         // Add trailing slash when needed

            normalized.push('');
        }

        path = normalized.join('/');

        if (path[0] !== '/' &&
            hasLeadingDash) {

            path = '/' + path;
        }
    }

    return path;
};


internals.Router.prototype.analyze = function (path) {

    Hoek.assert(internals.pathRegex.validatePath.test(path), 'Invalid path:', path);
    Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path), 'Path cannot contain encoded non-reserved path characters:', path);

    const pathParts = path.split('/');
    const segments = [];
    const params = [];
    const fingers = [];

    for (let i = 1; i < pathParts.length; ++i) {                            // Skip first empty segment
        let segment = pathParts[i];

        // Literal

        if (segment.indexOf('{') === -1) {
            segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();
            fingers.push(segment);
            segments.push({ literal: segment });
            continue;
        }

        // Parameter

        const parts = internals.parseParams(segment);
        if (parts.length === 1) {

            // Simple parameter

            const item = parts[0];
            Hoek.assert(params.indexOf(item.name) === -1, 'Cannot repeat the same parameter name:', item.name, 'in:', path);
            params.push(item.name);

            if (item.wilcard) {
                if (item.count) {
                    for (let j = 0; j < item.count; ++j) {
                        fingers.push('?');
                        segments.push({});
                        if (j) {
                            params.push(item.name);
                        }
                    }
                }
                else {
                    fingers.push('#');
                    segments.push({ wildcard: true });
                }
            }
            else {
                fingers.push('?');
                segments.push({ empty: item.empty });
            }
        }
        else {

            // Mixed parameter

            const seg = {
                length: parts.length,
                first: typeof parts[0] !== 'string',
                segments: []
            };

            let finger = '';
            let regex = '^';
            for (let j = 0; j < parts.length; ++j) {
                const part = parts[j];
                if (typeof part === 'string') {
                    finger = finger + part;
                    regex = regex + Hoek.escapeRegex(part);
                    seg.segments.push(part);
                }
                else {
                    Hoek.assert(params.indexOf(part.name) === -1, 'Cannot repeat the same parameter name:', part.name, 'in:', path);
                    params.push(part.name);

                    finger = finger + '?';
                    regex = regex + '(.' + (part.empty ? '*' : '+') + ')';
                }
            }

            seg.mixed = new RegExp(regex + '$', (!this.settings.isCaseSensitive ? 'i' : ''));
            fingers.push(finger);
            segments.push(seg);
        }
    }

    return {
        segments,
        fingerprint: '/' + fingers.join('/'),
        params
    };
};


internals.parseParams = function (segment) {

    const parts = [];
    segment.replace(internals.pathRegex.parseParam, (match, literal, name, wilcard, count, empty) => {

        if (literal) {
            parts.push(literal);
        }
        else {
            parts.push({
                name,
                wilcard: !!wilcard,
                count: count && parseInt(count, 10),
                empty: !!empty
            });
        }

        return '';
    });

    return parts;
};


internals.Router.prototype.table = function (host) {

    const result = [];
    const collect = (table) => {

        if (!table) {
            return;
        }

        Object.keys(table).forEach((method) => {

            table[method].routes.forEach((record) => {

                result.push(record.route);
            });
        });
    };

    if (this.vhosts) {
        const vhosts = host ? [].concat(host) : Object.keys(this.vhosts);
        for (let i = 0; i < vhosts.length; ++i) {
            collect(this.vhosts[vhosts[i]]);
        }
    }

    collect(this.routes);

    return result;
};


internals.sort = function (a, b) {

    const aFirst = -1;
    const bFirst = 1;

    const as = a.segments;
    const bs = b.segments;

    if (as.length !== bs.length) {
        return (as.length > bs.length ? bFirst : aFirst);
    }

    for (let i = 0; ; ++i) {
        if (as[i].literal) {
            if (bs[i].literal) {
                if (as[i].literal === bs[i].literal) {
                    continue;
                }

                return (as[i].literal > bs[i].literal ? bFirst : aFirst);
            }

            return aFirst;
        }

        if (bs[i].literal) {
            return bFirst;
        }

        return (as[i].wildcard ? bFirst : aFirst);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/call/lib/regex.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/call/lib/regex.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.generate = function () {

    /*
        /path/{param}/path/{param?}
        /path/{param*2}/path
        /path/{param*2}
        /path/x{param}x
        /{param*}
    */

    const empty = '(?:^\\/$)';

    const legalChars = '[\\w\\!\\$&\'\\(\\)\\*\\+\\,;\\=\\:@\\-\\.~]';
    const encoded = '%[A-F0-9]{2}';

    const literalChar = '(?:' + legalChars + '|' + encoded + ')';
    const literal = literalChar + '+';
    const literalOptional = literalChar + '*';

    const midParam = '(?:\\{\\w+(?:\\*[1-9]\\d*)?\\})';                               // {p}, {p*2}
    const endParam = '(?:\\/(?:\\{\\w+(?:(?:\\*(?:[1-9]\\d*)?)|(?:\\?))?\\})?)?';     // {p}, {p*2}, {p*}, {p?}

    const partialParam = '(?:\\{\\w+\\??\\})';                                        // {p}, {p?}
    const mixedParam = '(?:(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + '(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + literal + ')';

    const segmentContent = '(?:' + literal + '|' + midParam + '|' + mixedParam + ')';
    const segment = '\\/' + segmentContent;
    const segments = '(?:' + segment + ')*';

    const path = '(?:^' + segments + endParam + '$)';

    //                1:literal               2:name   3:*  4:count  5:?
    const parseParam = '(' + literal + ')|(?:\\{(\\w+)(?:(\\*)(\\d+)?)?(\\?)?\\})';

    const expressions = {
        parseParam: new RegExp(parseParam, 'g'),
        validatePath: new RegExp(empty + '|' + path),
        validatePathEncoded: /%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g
    };

    return expressions;
};


/***/ }),

/***/ "./node_modules/@hapi/call/lib/segment.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/call/lib/segment.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports = module.exports = internals.Segment = function () {

    this._edge = null;              // { segment, record }
    this._fulls = null;             // { path: { segment, record }
    this._literals = null;          // { literal: { segment, <node> } }
    this._param = null;             // <node>
    this._mixed = null;             // [{ segment, <node> }]
    this._wildcard = null;          // { segment, record }
};


internals.Segment.prototype.add = function (segments, record) {

    /*
        { literal: 'x' }        -> x
        { empty: false }        -> {p}
        { wildcard: true }      -> {p*}
        { mixed: /regex/ }      -> a{p}b
    */

    const current = segments[0];
    const remaining = segments.slice(1);
    const isEdge = !remaining.length;

    const literals = [];
    let isLiteral = true;
    for (let i = 0; i < segments.length && isLiteral; ++i) {
        isLiteral = segments[i].literal !== undefined;
        literals.push(segments[i].literal);
    }

    if (isLiteral) {
        this._fulls = this._fulls || {};
        let literal = '/' + literals.join('/');
        if (!record.settings.isCaseSensitive) {
            literal = literal.toLowerCase();
        }

        Hoek.assert(!this._fulls[literal], 'New route', record.path, 'conflicts with existing', this._fulls[literal] && this._fulls[literal].record.path);
        this._fulls[literal] = { segment: current, record };
    }
    else if (current.literal !== undefined) {               // Can be empty string

        // Literal

        this._literals = this._literals || {};
        const currentLiteral = (record.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase());
        this._literals[currentLiteral] = this._literals[currentLiteral] || new internals.Segment();
        this._literals[currentLiteral].add(remaining, record);
    }
    else if (current.wildcard) {

        // Wildcard

        Hoek.assert(!this._wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);
        Hoek.assert(!this._param || !this._param._wildcard, 'New route', record.path, 'conflicts with existing', this._param && this._param._wildcard && this._param._wildcard.record.path);
        this._wildcard = { segment: current, record };
    }
    else if (current.mixed) {

        // Mixed

        this._mixed = this._mixed || [];

        let mixed = this._mixedLookup(current);
        if (!mixed) {
            mixed = { segment: current, node: new internals.Segment() };
            this._mixed.push(mixed);
            this._mixed.sort(internals.mixed);
        }

        if (isEdge) {
            Hoek.assert(!mixed.node._edge, 'New route', record.path, 'conflicts with existing', mixed.node._edge && mixed.node._edge.record.path);
            mixed.node._edge = { segment: current, record };
        }
        else {
            mixed.node.add(remaining, record);
        }
    }
    else {

        // Parameter

        this._param = this._param || new internals.Segment();

        if (isEdge) {
            Hoek.assert(!this._param._edge, 'New route', record.path, 'conflicts with existing', this._param._edge && this._param._edge.record.path);
            this._param._edge = { segment: current, record };
        }
        else {
            Hoek.assert(!this._wildcard || !remaining[0].wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);
            this._param.add(remaining, record);
        }
    }
};


internals.Segment.prototype._mixedLookup = function (segment) {

    for (let i = 0; i < this._mixed.length; ++i) {
        if (internals.mixed({ segment }, this._mixed[i]) === 0) {
            return this._mixed[i];
        }
    }

    return null;
};


internals.mixed = function (a, b) {

    const aFirst = -1;
    const bFirst = 1;

    const as = a.segment;
    const bs = b.segment;

    if (as.length !== bs.length) {
        return (as.length > bs.length ? aFirst : bFirst);
    }

    if (as.first !== bs.first) {
        return (as.first ? bFirst : aFirst);
    }

    for (let i = 0; i < as.segments.length; ++i) {
        const am = as.segments[i];
        const bm = bs.segments[i];

        if (am === bm) {
            continue;
        }

        if (am.length === bm.length) {
            return (am > bm ? bFirst : aFirst);
        }

        return (am.length < bm.length ? bFirst : aFirst);
    }

    return 0;
};


internals.Segment.prototype.lookup = function (path, segments, options) {

    let match = null;

    // Literal edge

    if (this._fulls) {
        match = this._fulls[options.isCaseSensitive ? path : path.toLowerCase()];
        if (match) {
            return { record: match.record, array: [] };
        }
    }

    // Literal node

    const current = segments[0];
    const nextPath = path.slice(current.length + 1);
    const remainder = (segments.length > 1 ? segments.slice(1) : null);

    if (this._literals) {
        const literal = options.isCaseSensitive ? current : current.toLowerCase();
        match = this._literals.hasOwnProperty(literal) && this._literals[literal];
        if (match) {
            const record = internals.deeper(match, nextPath, remainder, [], options);
            if (record) {
                return record;
            }
        }
    }

    // Mixed

    if (this._mixed) {
        for (let i = 0; i < this._mixed.length; ++i) {
            match = this._mixed[i];
            const params = current.match(match.segment.mixed);
            if (params) {
                const array = [];
                for (let j = 1; j < params.length; ++j) {
                    array.push(params[j]);
                }

                const record = internals.deeper(match.node, nextPath, remainder, array, options);
                if (record) {
                    return record;
                }
            }
        }
    }

    // Param

    if (this._param) {
        if (current ||
            (this._param._edge && this._param._edge.segment.empty)) {

            const record = internals.deeper(this._param, nextPath, remainder, [current], options);
            if (record) {
                return record;
            }
        }
    }

    // Wildcard

    if (this._wildcard) {
        return { record: this._wildcard.record, array: [path.slice(1)] };
    }

    return null;
};


internals.deeper = function (match, path, segments, array, options) {

    if (!segments) {
        if (match._edge) {
            return { record: match._edge.record, array };
        }

        if (match._wildcard) {
            return { record: match._wildcard.record, array };
        }
    }
    else {
        const result = match.lookup(path, segments, options);
        if (result) {
            return { record: result.record, array: array.concat(result.array) };
        }
    }

    return null;
};


/***/ }),

/***/ "./node_modules/@hapi/catbox-memory/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@hapi/catbox-memory/lib/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    maxTimer: 2147483647,   // 2 ^ 31 - 1
    entrySize: 144          // Approximate cache entry size without value: 144 bytes
};


internals.defaults = {
    maxByteSize: 100 * 1024 * 1024,          // 100MB
    minCleanupIntervalMsec: 1000,
    cloneBuffersOnGet: false
};


exports = module.exports = internals.Connection = class {

    constructor(options = {}) {

        Hoek.assert(this.constructor === internals.Connection, 'Memory cache client must be instantiated using new');
        Hoek.assert(options.maxByteSize === undefined || options.maxByteSize >= 0, 'Invalid cache maxByteSize value');
        Hoek.assert(options.allowMixedContent === undefined, 'allowMixedContent no longer supported');
        Hoek.assert(options.minCleanupIntervalMsec === undefined || options.minCleanupIntervalMsec < internals.maxTimer, 'Invalid cache minCleanupIntervalMsec value');
        Hoek.assert(options.cloneBuffersOnGet === undefined || typeof options.cloneBuffersOnGet === 'boolean', 'Invalid cloneBuffersOnGet value');

        this.settings = Hoek.applyToDefaults(internals.defaults, options);
        this.cache = null;

        this._timer = null;
        this._timerDue = null;
    }

    start() {

        if (!this.cache) {
            this.cache = new Map();
            this.byteSize = 0;
        }
    }

    _scheduleCleanup(msec) {

        const cleanup = () => {

            this._timer = null;
            this._timerDue = null;

            const now = Date.now();
            let next = Infinity;
            for (const [, segment] of this.cache) {
                for (const [id, envelope] of segment) {
                    const ttl = envelope.stored + envelope.ttl - now;
                    if (ttl <= 0) {
                        segment.delete(id);
                        this.byteSize -= envelope.byteSize;
                    }
                    else {
                        next = Math.min(next, ttl);
                    }
                }
            }

            if (next !== Infinity) {
                this._scheduleCleanup(next);
            }
        };

        const now = Date.now();
        const timeout = Math.min(Math.max(this.settings.minCleanupIntervalMsec, msec), internals.maxTimer);
        if (this._timer) {
            if (this._timerDue - now < msec) {
                return;
            }

            clearTimeout(this._timer);
        }

        this._timerDue = now + timeout;
        this._timer = setTimeout(cleanup, timeout);
    }

    stop() {

        clearTimeout(this._timer);
        this._timer = null;
        this._timerDue = null;

        this.cache = null;
        this.byteSize = 0;
    }

    isReady() {

        return !!this.cache;
    }

    validateSegmentName(name) {

        if (!name) {
            throw new Boom('Empty string');
        }

        if (name.indexOf('\u0000') !== -1) {
            throw new Boom('Includes null character');
        }

        return null;
    }

    get(key) {

        if (!this.cache) {
            throw new Boom('Connection not started');
        }

        const segment = this.cache.get(key.segment);
        if (!segment) {
            return null;
        }

        const envelope = segment.get(key.id);
        if (!envelope) {
            return null;
        }

        if (envelope.stored + envelope.ttl < Date.now()) {
            this.drop(key);
            return null;
        }

        let item = null;
        if (Buffer.isBuffer(envelope.item)) {
            item = envelope.item;
            if (this.settings.cloneBuffersOnGet) {
                const copy = Buffer.alloc(item.length);
                item.copy(copy);
                item = copy;
            }
        }
        else {
            try {
                item = JSON.parse(envelope.item);
            }
            catch (err) {
                throw new Boom('Bad value content');
            }
        }

        const result = {
            item,
            stored: envelope.stored,
            ttl: envelope.ttl
        };

        return result;
    }

    set(key, value, ttl) {

        if (!this.cache) {
            throw new Boom('Connection not started');
        }

        const envelope = new internals.MemoryCacheEntry(key, value, ttl);

        let segment = this.cache.get(key.segment);
        if (!segment) {
            segment = new Map();
            this.cache.set(key.segment, segment);
        }

        const cachedItem = segment.get(key.id);
        if (cachedItem) {
            this.byteSize -= cachedItem.byteSize;       // If the item existed, decrement the byteSize as the value could be different
        }

        if (this.settings.maxByteSize &&
            (this.byteSize + envelope.byteSize > this.settings.maxByteSize)) {

            throw new Boom('Cache size limit reached');
        }

        this._scheduleCleanup(ttl);
        segment.set(key.id, envelope);
        this.byteSize += envelope.byteSize;
    }

    drop(key) {

        if (!this.cache) {
            throw new Boom('Connection not started');
        }

        const segment = this.cache.get(key.segment);
        if (segment) {
            const item = segment.get(key.id);
            if (item) {
                this.byteSize -= item.byteSize;
                segment.delete(key.id);
            }
        }
    }
};


internals.MemoryCacheEntry = class {

    constructor(key, value, ttl) {

        let valueByteSize = 0;

        if (Buffer.isBuffer(value)) {
            this.item = Buffer.alloc(value.length);
            value.copy(this.item);                                  // Copy buffer to prevent value from changing while in the cache
            valueByteSize = this.item.length;
        }
        else {
            this.item = JSON.stringify(value);                      // stringify() to prevent value from changing while in the cache
            valueByteSize = Buffer.byteLength(this.item);
        }

        this.stored = Date.now();
        this.ttl = ttl;
        this.byteSize = internals.entrySize + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);
        this.timeoutId = null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/client.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/client.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {
    validate: Symbol('validate')
};


internals.defaults = {
    partition: 'catbox'
};


module.exports = class {

    constructor(engine, options) {

        Hoek.assert(engine, 'Missing catbox client engine');
        Hoek.assert(typeof engine === 'object' || typeof engine === 'function', 'engine must be an engine object or engine prototype (function)');
        Hoek.assert(typeof engine === 'function' || !options, 'Can only specify options with function engine config');

        const settings = Object.assign({}, internals.defaults, options);
        Hoek.assert(settings.partition.match(/^[\w\-]+$/), 'Invalid partition name:' + settings.partition);

        this.connection = (typeof engine === 'object' ? engine : new engine(settings));
    }

    async start() {

        await this.connection.start();
    }

    async stop() {

        await this.connection.stop();
    }

    isReady() {

        return this.connection.isReady();
    }

    validateSegmentName(name) {

        return this.connection.validateSegmentName(name);
    }

    async get(key) {

        this[internals.validate](key, null);

        if (key === null) {
            return null;
        }

        const result = await this.connection.get(key);
        if (!result ||
            result.item === undefined ||
            result.item === null) {

            return null;                                                        // Not found
        }

        const now = Date.now();
        const expires = result.stored + result.ttl;
        const ttl = expires - now;
        if (ttl <= 0) {
            return null;                                                        // Expired
        }

        const cached = {
            item: result.item,
            stored: result.stored,
            ttl
        };

        return cached;                                                          // Valid
    }

    async set(key, value, ttl) {

        this[internals.validate](key);

        if (ttl <= 0) {
            return;                                                             // Not cachable (or bad rules)
        }

        await this.connection.set(key, value, ttl);
    }

    async drop(key) {

        this[internals.validate](key);

        await this.connection.drop(key);                                       // Always drop, regardless of caching rules
    }

    [internals.validate](key, allow = {}) {

        if (!this.isReady()) {
            throw Boom.internal('Disconnected');                                // Disconnected
        }

        const isValidKey = (key && typeof key.id === 'string' &&
                            key.segment && typeof key.segment === 'string');

        if (!isValidKey && key !== allow) {
            throw Boom.internal('Invalid key');
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Client = __webpack_require__(/*! ./client */ "./node_modules/@hapi/catbox/lib/client.js");
const Policy = __webpack_require__(/*! ./policy */ "./node_modules/@hapi/catbox/lib/policy.js");


const internals = {};


exports.Client = Client;


exports.Policy = exports.policy = Policy;


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/pending.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/pending.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = class {

    constructor(id, rule) {

        this.id = id;
        this.timeoutTimer = null;
        this.count = 1;
        this.rule = rule;

        this.promise = new Promise((resolve, reject) => {

            this.resolve = resolve;
            this.reject = reject;
        });
    }

    join() {

        ++this.count;
        return this.promise;
    }

    send(err, value, cached, report) {

        clearTimeout(this.timeoutTimer);

        if (err &&
            !cached) {

            this.reject(err);
            return;
        }

        if (!this.rule.getDecoratedValue) {
            this.resolve(value);
            return;
        }

        if (err) {
            report.error = err;
        }

        this.resolve({ value, cached, report });
    }

    setTimeout(fn, timeoutMs) {

        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = setTimeout(fn, timeoutMs);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/policy.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/policy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");

const Pending = __webpack_require__(/*! ./pending */ "./node_modules/@hapi/catbox/lib/pending.js");


const internals = {
    day: 24 * 60 * 60 * 1000,
    events: Podium.validate([
        { name: 'error', channels: ['generate', 'persist'] }
    ])
};


internals.schema = Joi.object({
    expiresIn: Joi.number().integer().min(1),
    expiresAt: Joi.string().regex(/^\d\d?\:\d\d$/),
    staleIn: [
        Joi.number().integer().min(1).when('expiresAt', { is: Joi.required(), then: Joi.number().max(86400000 - 1) }),       // One day - 1 (max is inclusive)
        Joi.func()
    ],
    staleTimeout: Joi.number().integer().min(1),
    generateFunc: Joi.func(),
    generateTimeout: Joi.number().integer().min(1).allow(false),
    generateOnReadError: Joi.boolean(),
    generateIgnoreWriteError: Joi.boolean(),
    dropOnError: Joi.boolean(),
    pendingGenerateTimeout: Joi.number().integer().min(1),
    getDecoratedValue: Joi.boolean().default(false),

    // Ignored external keys (hapi)

    privacy: Joi.any(),
    cache: Joi.any(),
    segment: Joi.any(),
    shared: Joi.any()
})
    .without('expiresIn', 'expiresAt')
    .with('staleIn', 'generateFunc')
    .with('generateOnReadError', 'generateFunc')
    .with('generateIgnoreWriteError', 'generateFunc')
    .with('dropOnError', 'generateFunc')
    .and('generateFunc', 'generateTimeout')
    .and('staleIn', 'staleTimeout');


exports = module.exports = internals.Policy = class {

    constructor(options, cache, segment) {

        this._events = null;
        this._cache = cache;
        this._pendings = new Map();                       // id -> Pending
        this._pendingGenerateCall = new Map();            // id -> timer
        this.rules(options);

        this.stats = {
            sets: 0,
            gets: 0,
            hits: 0,
            stales: 0,
            generates: 0,
            errors: 0
        };

        if (cache) {
            const nameErr = cache.validateSegmentName(segment);
            Hoek.assert(nameErr === null, 'Invalid segment name: ' + segment + (nameErr ? ' (' + nameErr.message + ')' : ''));

            this._segment = segment;
        }
    }

    get events() {

        if (!this._events) {
            this._events = new Podium(internals.events);
        }

        return this._events;
    }

    _error(source, error) {

        if (!this._events) {
            return;
        }

        this._events.emit({ name: 'error', channel: source }, { source, error });
    }

    rules(options) {

        this.rule = internals.Policy.compile(options, !!this._cache);
    }

    async get(key) {     // key: string or { id: 'id' }

        ++this.stats.gets;

        // Check if request is already pending

        const id = (key && typeof key === 'object') ? key.id : key;
        let pending = this._pendings.get(id);
        if (pending !== undefined) {
            return await pending.join();
        }

        pending = new Pending(id, this.rule);
        this._pendings.set(id, pending);

        try {
            await this._get(pending, key);
        }
        catch (err) {
            this._send(pending, err);               // Safeguard to ensure that the pending rejects on any processing errors
        }

        return pending.promise;
    }

    async _get(pending, key) {

        // Prepare report

        const report = {};

        // Lookup in cache

        const timer = new Hoek.Bench();

        let cached = null;
        if (this._cache) {
            try {
                cached = await this._cache.get({ segment: this._segment, id: pending.id });
            }
            catch (err) {
                report.error = err;
                ++this.stats.errors;
                this._error('persist', err);
            }
        }

        report.msec = timer.elapsed();

        if (cached) {
            report.stored = cached.stored;
            report.ttl = cached.ttl;
            const staleIn = typeof this.rule.staleIn === 'function' ? this.rule.staleIn(cached.stored, cached.ttl) : this.rule.staleIn;
            cached.isStale = (staleIn ? (Date.now() - cached.stored) >= staleIn : false);
            report.isStale = cached.isStale;

            if (cached.isStale) {
                ++this.stats.stales;
            }
        }

        // No generate method

        if (!this.rule.generateFunc ||
            (report.error && !this.rule.generateOnReadError)) {

            this._send(pending, report.error, cached ? cached.item : null, cached, report);
            return;
        }

        // Check if found and fresh

        if (cached &&
            !cached.isStale) {

            this._send(pending, null, cached.item, cached, report);
            return;
        }

        // Wait until generated or otherwise resolved

        await Promise.race([
            pending.promise,
            this._generate(pending, key, cached, report)
        ]);
    }

    _generate(pending, key, cached, report) {

        if (cached) {                                       // Must be stale

            // Set stale timeout

            cached.ttl = cached.ttl - this.rule.staleTimeout;       // Adjust TTL for when the timeout is invoked (staleTimeout must be valid if isStale is true)
        }

        if (cached &&
            cached.ttl > 0) {

            pending.setTimeout(() => this._send(pending, null, cached.item, cached, report), this.rule.staleTimeout);
        }
        else if (this.rule.generateTimeout) {

            // Set item generation timeout (when not in cache)

            pending.setTimeout(() => this._send(pending, Boom.serverUnavailable(), null, null, report), this.rule.generateTimeout);
        }

        // Check if a generate call is already in progress

        if (this._pendingGenerateCall.has(pending.id)) {
            return;
        }

        // Generate new value

        ++this.stats.generates;                                 // Record generation before call in case it times out

        if (this.rule.pendingGenerateTimeout) {
            const timeout = setTimeout(() => this._pendingGenerateCall.delete(pending.id), this.rule.pendingGenerateTimeout);
            this._pendingGenerateCall.set(pending.id, timeout);
        }

        return this._callGenerateFunc(pending, key, cached, report);
    }

    async _callGenerateFunc(pending, key, cached, report) {

        const flags = {};

        try {
            var value = await this.rule.generateFunc(key, flags);
        }
        catch (err) {
            var generateError = err;
            this._error('generate', err);
        }

        const pendingTimeout = this._pendingGenerateCall.get(pending.id);
        if (pendingTimeout) {
            clearTimeout(pendingTimeout);
            this._pendingGenerateCall.delete(pending.id);

            pending = this._pendings.get(pending.id) || pending;                    // Fetch latest - it might have changed
        }

        // Error (if dropOnError is not set to false) or not cached

        try {
            if (flags.ttl === 0 ||                                                  // null or undefined means use policy
                (generateError && this.rule.dropOnError)) {

                await this.drop(pending.id);                                        // Invalidate cache
            }
            else if (!generateError) {
                await this.set(pending.id, value, flags.ttl);                       // Replace stale cache copy with late-coming fresh copy
            }
        }
        catch (err) {
            var persistError = err;
            this._error('persist', err);
        }

        const error = generateError || (this.rule.generateIgnoreWriteError ? null : persistError);
        if (cached &&
            error &&
            !this.rule.dropOnError) {

            this._send(pending, error, cached.item, cached, report);
            return;
        }

        this._send(pending, error, value, null, report);                            // Ignored if stale value already returned
    }

    _send(pending, err, value, cached, report) {

        pending.send(err, value, cached, report);
        this._pendings.delete(pending.id);

        if (report && report.isStale !== undefined) {
            this.stats.hits = this.stats.hits + pending.count;
        }
    }

    async set(key, value, ttl) {

        ++this.stats.sets;

        if (!this._cache) {
            return;
        }

        ttl = ttl || internals.Policy.ttl(this.rule);
        const id = (key && typeof key === 'object') ? key.id : key;

        try {
            await this._cache.set({ segment: this._segment, id }, value, ttl);
        }
        catch (err) {
            ++this.stats.errors;
            throw err;
        }
    }

    async drop(key) {

        if (!this._cache) {
            return;
        }

        const id = (key && typeof key === 'object') ? key.id : key;

        try {
            await this._cache.drop({ segment: this._segment, id });
            return;
        }
        catch (err) {
            ++this.stats.errors;
            throw err;
        }
    }

    ttl(created) {

        return internals.Policy.ttl(this.rule, created);
    }

    isReady() {

        if (!this._cache) {
            return false;
        }

        return this._cache.connection.isReady();
    }

    static compile(options, serverSide) {

        /*
            {
                expiresIn: 30000,
                expiresAt: '13:00',
                generateFunc: (id, flags) => { throw err; } / { return result; } / { flags.ttl = ttl; return result; }
                generateTimeout: 500,
                generateOnReadError: true,
                generateIgnoreWriteError: true,
                staleIn: 20000,
                staleTimeout: 500,
                dropOnError: true,
                getDecoratedValue: false
            }
         */

        const rule = {};

        if (!options ||
            !Object.keys(options).length) {

            return rule;
        }

        // Validate rule

        options = Joi.attempt(options, internals.schema, 'Invalid cache policy configuration');

        const hasExpiresIn = options.expiresIn !== undefined && options.expiresIn !== null;
        const hasExpiresAt = options.expiresAt !== undefined && options.expiresAt !== null;

        Hoek.assert(!hasExpiresIn || !options.staleIn || typeof options.staleIn === 'function' || options.staleIn < options.expiresIn, 'staleIn must be less than expiresIn');
        Hoek.assert(!options.staleIn || serverSide, 'Cannot use stale options without server-side caching');
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || options.staleTimeout < options.expiresIn, 'staleTimeout must be less than expiresIn');
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || typeof options.staleIn === 'function' || options.staleTimeout < (options.expiresIn - options.staleIn), 'staleTimeout must be less than the delta between expiresIn and staleIn');
        Hoek.assert(!options.staleTimeout || !options.pendingGenerateTimeout || options.staleTimeout < options.pendingGenerateTimeout, 'pendingGenerateTimeout must be greater than staleTimeout if specified');

        // Expiration

        if (hasExpiresAt) {

            // expiresAt

            const time = /^(\d\d?):(\d\d)$/.exec(options.expiresAt);
            rule.expiresAt = {
                hours: parseInt(time[1], 10),
                minutes: parseInt(time[2], 10)
            };
        }
        else {

            // expiresIn

            rule.expiresIn = options.expiresIn || 0;
        }

        // generateTimeout

        if (options.generateFunc) {
            rule.generateFunc = options.generateFunc;
            rule.generateTimeout = options.generateTimeout;

            // Stale

            if (options.staleIn) {
                rule.staleIn = options.staleIn;
                rule.staleTimeout = options.staleTimeout;
            }

            rule.dropOnError = options.dropOnError !== undefined ? options.dropOnError : true;                                          // Defaults to true
            rule.pendingGenerateTimeout = options.pendingGenerateTimeout !== undefined ? options.pendingGenerateTimeout : 0;            // Defaults to zero
        }

        rule.generateOnReadError = options.generateOnReadError !== undefined ? options.generateOnReadError : true;                      // Defaults to true
        rule.generateIgnoreWriteError = options.generateIgnoreWriteError !== undefined ? options.generateIgnoreWriteError : true;       // Defaults to true

        // Decorations

        rule.getDecoratedValue = options.getDecoratedValue;

        return rule;
    }

    static ttl(rule, created, now) {

        now = now || Date.now();
        created = created || now;
        const age = now - created;

        if (age < 0) {
            return 0;                                                                   // Created in the future, assume expired/bad
        }

        if (rule.expiresIn) {
            return Math.max(rule.expiresIn - age, 0);
        }

        if (rule.expiresAt) {
            if (age > internals.day) {                                                  // If the item was created more than a 24 hours ago
                return 0;
            }

            const expiresAt = new Date(created);                                        // Compare expiration time on the same day
            expiresAt.setHours(rule.expiresAt.hours);
            expiresAt.setMinutes(rule.expiresAt.minutes);
            expiresAt.setSeconds(0);
            expiresAt.setMilliseconds(0);
            let expires = expiresAt.getTime();

            if (expires <= created) {
                expires = expires + internals.day;                                     // Move to tomorrow
            }

            if (now >= expires) {                                                      // Expired
                return 0;
            }

            return expires - now;
        }

        return 0;                                                                       // No rule
    }
};


/***/ }),

/***/ "./node_modules/@hapi/content/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/content/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


/*
    RFC 7231 Section 3.1.1.1

    media-type = type "/" subtype *( OWS ";" OWS parameter )
    type       = token
    subtype    = token
    parameter  = token "=" ( token / quoted-string )
*/

//                             1: type/subtype    2: params
internals.contentTypeRegex = /^([^\/\s]+\/[^\s;]+)(.*)?$/;

//                                        1: "b"   2: b
internals.paramsRegex = /;\s*boundary=(?:"([^"]+)"|([^;"\s]+))/i;


exports.type = function (header) {

    if (!header) {
        throw Boom.badRequest('Invalid content-type header');
    }

    const match = header.match(internals.contentTypeRegex);
    if (!match) {
        throw Boom.badRequest('Invalid content-type header');
    }

    const result = {
        mime: match[1].toLowerCase()
    };

    if (result.mime.indexOf('multipart/') === 0) {
        const params = match[2];
        if (params) {
            const param = params.match(internals.paramsRegex);
            if (param) {
                result.boundary = param[1] || param[2];
            }
        }

        if (!result.boundary) {
            throw Boom.badRequest('Invalid content-type header: multipart missing boundary');
        }
    }

    return result;
};


/*
    RFC 6266 Section 4.1 (http://tools.ietf.org/html/rfc6266#section-4.1)

    content-disposition = "Content-Disposition" ":" disposition-type *( ";" disposition-parm )
    disposition-type    = "inline" | "attachment" | token                                           ; case-insensitive
    disposition-parm    = filename-parm | token [ "*" ] "=" ( token | quoted-string | ext-value)    ; ext-value defined in [RFC5987], Section 3.2

    Content-Disposition header field values with multiple instances of the same parameter name are invalid.

    Note that due to the rules for implied linear whitespace (Section 2.1 of [RFC2616]), OPTIONAL whitespace
    can appear between words (token or quoted-string) and separator characters.

    Furthermore, note that the format used for ext-value allows specifying a natural language (e.g., "en"); this is of limited use
    for filenames and is likely to be ignored by recipients.
*/


internals.contentDispositionRegex = /^\s*form-data\s*(?:;\s*(.+))?$/i;

//                                        1: name     2: *            3: ext-value                      4: quoted  5: token
internals.contentDispositionParamRegex = /([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;'"\s]+\'[\w-]*\'[^;\s]+)|(?:\"([^"]*)\")|([^;\s]*))(?:\s*(?:;\s*)|$)/g;

exports.disposition = function (header) {

    if (!header) {
        throw Boom.badRequest('Missing content-disposition header');
    }

    const match = header.match(internals.contentDispositionRegex);
    if (!match) {
        throw Boom.badRequest('Invalid content-disposition header format');
    }

    const parameters = match[1];
    if (!parameters) {
        throw Boom.badRequest('Invalid content-disposition header missing parameters');
    }

    const result = {};
    parameters.replace(internals.contentDispositionParamRegex, ($0, $1, $2, $3, $4, $5) => {

        if ($2) {
            if (!$3) {
                throw Boom.badRequest('Invalid content-disposition header format includes invalid parameters');
            }

            try {
                result[$1] = decodeURIComponent($3.split('\'')[2]);
            }
            catch (err) {
                throw Boom.badRequest('Invalid content-disposition header format includes invalid parameters');
            }
        }
        else {
            result[$1] = $4 || $5 || '';
        }
    });

    if (!result.name) {
        throw Boom.badRequest('Invalid content-disposition header missing name parameter');
    }

    return result;
};


/***/ }),

/***/ "./node_modules/@hapi/cryptiles/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/cryptiles/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


// Generate a cryptographically strong pseudo-random data

exports.randomString = function (size) {

    const buffer = exports.randomBits((size + 1) * 6);
    const string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    return string.slice(0, size);
};


// Return a random string of digits

exports.randomDigits = function (size) {

    const digits = [];

    let buffer = internals.random(size * 2);            // Provision twice the amount of bytes needed to increase chance of single pass
    let pos = 0;

    while (digits.length < size) {
        if (pos >= buffer.length) {
            buffer = internals.random(size * 2);
            pos = 0;
        }

        if (buffer[pos] < 250) {
            digits.push(buffer[pos] % 10);
        }

        ++pos;
    }

    return digits.join('');
};


// Generate a buffer of random bits

exports.randomBits = function (bits) {

    if (!bits ||
        bits < 0) {

        throw Boom.internal('Invalid random bits count');
    }

    const bytes = Math.ceil(bits / 8);
    return internals.random(bytes);
};


exports.fixedTimeComparison = function (a, b) {

    try {
        return Crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
    }
    catch (err) {
        return false;
    }
};


internals.random = function (bytes) {

    try {
        return Crypto.randomBytes(bytes);
    }
    catch (err) {
        throw Boom.internal('Failed generating random bits: ' + err.message);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/file/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/file/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");
const Path = __webpack_require__(/*! path */ "path");


const internals = {};


exports.uniqueFilename = function (path, extension) {

    if (extension) {
        extension = extension[0] !== '.' ? '.' + extension : extension;
    }
    else {
        extension = '';
    }

    path = Path.resolve(path);
    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
    return Path.join(path, name);
};


/***/ }),

/***/ "./node_modules/@hapi/formula/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/formula/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {
    operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],
    operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],
    operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],
    operatorsPrefix: ['!', 'n'],

    literals: {
        '"': '"',
        '`': '`',
        '\'': '\'',
        '[': ']'
    },

    numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/,
    tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,

    symbol: Symbol('formula'),
    settings: Symbol('settings')
};


exports = module.exports = internals.Formula = class {

    constructor(string, options = {}) {

        if (!options[internals.settings] &&
            options.constants) {

            for (const constant in options.constants) {
                const value = options.constants[constant];
                if (value !== null &&
                    !['boolean', 'number', 'string'].includes(typeof value)) {

                    throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
                }
            }
        }

        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;

        this._parts = null;
        this._parse(string);
    }

    _parse(string) {

        let parts = [];
        let current = '';
        let parenthesis = 0;
        let literal = false;

        const flush = (inner) => {

            if (parenthesis) {
                throw new Error('Formula missing closing parenthesis');
            }

            const last = parts.length ? parts[parts.length - 1] : null;

            if (!literal &&
                !current &&
                !inner) {

                return;
            }

            if (last &&
                last.type === 'reference' &&
                inner === ')') {                                                                // Function

                last.type = 'function';
                last.value = this._subFormula(current, last.value);
                current = '';
                return;
            }

            if (inner === ')') {                                                                // Segment
                const sub = new internals.Formula(current, this.settings);
                parts.push({ type: 'segment', value: sub });
            }
            else if (literal) {
                if (literal === ']') {                                                          // Reference
                    parts.push({ type: 'reference', value: current });
                    current = '';
                    return;
                }

                parts.push({ type: 'literal', value: current });                                // Literal
            }
            else if (internals.operatorCharacters.includes(current)) {                          // Operator
                if (last &&
                    last.type === 'operator' &&
                    internals.operators.includes(last.value + current)) {                       // 2 characters operator

                    last.value += current;
                }
                else {
                    parts.push({ type: 'operator', value: current });
                }
            }
            else if (current.match(internals.numberRx)) {                                       // Number
                parts.push({ type: 'constant', value: parseFloat(current) });
            }
            else if (this.settings.constants[current] !== undefined) {                          // Constant
                parts.push({ type: 'constant', value: this.settings.constants[current] });
            }
            else {                                                                              // Reference
                if (!current.match(internals.tokenRx)) {
                    throw new Error(`Formula contains invalid token: ${current}`);
                }

                parts.push({ type: 'reference', value: current });
            }

            current = '';
        };

        for (const c of string) {
            if (literal) {
                if (c === literal) {
                    flush();
                    literal = false;
                }
                else {
                    current += c;
                }
            }
            else if (parenthesis) {
                if (c === '(') {
                    current += c;
                    ++parenthesis;
                }
                else if (c === ')') {
                    --parenthesis;
                    if (!parenthesis) {
                        flush(c);
                    }
                    else {
                        current += c;
                    }
                }
                else {
                    current += c;
                }
            }
            else if (c in internals.literals) {
                literal = internals.literals[c];
            }
            else if (c === '(') {
                flush();
                ++parenthesis;
            }
            else if (internals.operatorCharacters.includes(c)) {
                flush();
                current = c;
                flush();
            }
            else if (c !== ' ') {
                current += c;
            }
            else {
                flush();
            }
        }

        flush();

        // Replace prefix - to internal negative operator

        parts = parts.map((part, i) => {

            if (part.type !== 'operator' ||
                part.value !== '-' ||
                i && parts[i - 1].type !== 'operator') {

                return part;
            }

            return { type: 'operator', value: 'n' };
        });

        // Validate tokens order

        let operator = false;
        for (const part of parts) {
            if (part.type === 'operator') {
                if (internals.operatorsPrefix.includes(part.value)) {
                    continue;
                }

                if (!operator) {
                    throw new Error('Formula contains an operator in invalid position');
                }

                if (!internals.operators.includes(part.value)) {
                    throw new Error(`Formula contains an unknown operator ${part.value}`);
                }
            }
            else if (operator) {
                throw new Error('Formula missing expected operator');
            }

            operator = !operator;
        }

        if (!operator) {
            throw new Error('Formula contains invalid trailing operator');
        }

        // Identify single part

        if (parts.length === 1 &&
            ['reference', 'literal', 'constant'].includes(parts[0].type)) {

            this.single = { type: parts[0].type === 'reference' ? 'reference' : 'value', value: parts[0].value };
        }

        // Process parts

        this._parts = parts.map((part) => {

            // Operators

            if (part.type === 'operator') {
                return internals.operatorsPrefix.includes(part.value) ? part : part.value;
            }

            // Literals, constants, segments

            if (part.type !== 'reference') {
                return part.value;
            }

            // References

            if (this.settings.tokenRx &&
                !this.settings.tokenRx.test(part.value)) {

                throw new Error(`Formula contains invalid reference ${part.value}`);
            }

            if (this.settings.reference) {
                return this.settings.reference(part.value);
            }

            return internals.reference(part.value);
        });
    }

    _subFormula(string, name) {

        const method = this.settings.functions[name];
        if (typeof method !== 'function') {
            throw new Error(`Formula contains unknown function ${name}`);
        }

        let args = [];
        if (string) {
            let current = '';
            let parenthesis = 0;
            let literal = false;

            const flush = () => {

                if (!current) {
                    throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
                }

                args.push(current);
                current = '';
            };

            for (let i = 0; i < string.length; ++i) {
                const c = string[i];
                if (literal) {
                    current += c;
                    if (c === literal) {
                        literal = false;
                    }
                }
                else if (c in internals.literals &&
                    !parenthesis) {

                    current += c;
                    literal = internals.literals[c];
                }
                else if (c === ',' &&
                    !parenthesis) {

                    flush();
                }
                else {
                    current += c;
                    if (c === '(') {
                        ++parenthesis;
                    }
                    else if (c === ')') {
                        --parenthesis;
                    }
                }
            }

            flush();
        }

        args = args.map((arg) => new internals.Formula(arg, this.settings));

        return function (context) {

            const innerValues = [];
            for (const arg of args) {
                innerValues.push(arg.evaluate(context));
            }

            return method.call(context, ...innerValues);
        };
    }

    evaluate(context) {

        const parts = this._parts.slice();

        // Prefix operators

        for (let i = parts.length - 2; i >= 0; --i) {
            const part = parts[i];
            if (part &&
                part.type === 'operator') {

                const current = parts[i + 1];
                parts.splice(i + 1, 1);
                const value = internals.evaluate(current, context);
                parts[i] = internals.single(part.value, value);
            }
        }

        // Left-right operators

        internals.operatorsOrder.forEach((set) => {

            for (let i = 1; i < parts.length - 1;) {
                if (set.includes(parts[i])) {
                    const operator = parts[i];
                    const left = internals.evaluate(parts[i - 1], context);
                    const right = internals.evaluate(parts[i + 1], context);

                    parts.splice(i, 2);
                    const result = internals.calculate(operator, left, right);
                    parts[i - 1] = result === 0 ? 0 : result;                               // Convert -0
                }
                else {
                    i += 2;
                }
            }
        });

        return internals.evaluate(parts[0], context);
    }
};


internals.Formula.prototype[internals.symbol] = true;


internals.reference = function (name) {

    return function (context) {

        return context && context[name] !== undefined ? context[name] : null;
    };
};


internals.evaluate = function (part, context) {

    if (part === null) {
        return null;
    }

    if (typeof part === 'function') {
        return part(context);
    }

    if (part[internals.symbol]) {
        return part.evaluate(context);
    }

    return part;
};


internals.single = function (operator, value) {

    if (operator === '!') {
        return value ? false : true;
    }

    // operator === 'n'

    const negative = -value;
    if (negative === 0) {       // Override -0
        return 0;
    }

    return negative;
};


internals.calculate = function (operator, left, right) {

    if (operator === '??') {
        return internals.exists(left) ? left : right;
    }

    if (typeof left === 'string' ||
        typeof right === 'string') {

        if (operator === '+') {
            left = internals.exists(left) ? left : '';
            right = internals.exists(right) ? right : '';
            return left + right;
        }
    }
    else {
        switch (operator) {
            case '^': return Math.pow(left, right);
            case '*': return left * right;
            case '/': return left / right;
            case '%': return left % right;
            case '+': return left + right;
            case '-': return left - right;
        }
    }

    switch (operator) {
        case '<': return left < right;
        case '<=': return left <= right;
        case '>': return left > right;
        case '>=': return left >= right;
        case '==': return left === right;
        case '!=': return left !== right;
        case '&&': return left && right;
        case '||': return left || right;
    }

    return null;
};


internals.exists = function (value) {

    return value !== null && value !== undefined;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/auth.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/auth.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");


const internals = {
    missing: Symbol('missing')
};


exports = module.exports = internals.Auth = class {

    constructor(core) {

        this._core = core;
        this._schemes = {};
        this._strategies = {};
        this.settings = {
            default: null           // Strategy used as default if route has no auth settings
        };

        this.api = {};
    }

    scheme(name, scheme) {

        Hoek.assert(name, 'Authentication scheme must have a name');
        Hoek.assert(!this._schemes[name], 'Authentication scheme name already exists:', name);
        Hoek.assert(typeof scheme === 'function', 'scheme must be a function:', name);

        this._schemes[name] = scheme;
    }

    _strategy(server, name, scheme, options = {}) {

        Hoek.assert(name, 'Authentication strategy must have a name');
        Hoek.assert(typeof options === 'object', 'options must be an object');
        Hoek.assert(!this._strategies[name], 'Authentication strategy name already exists');
        Hoek.assert(scheme, 'Authentication strategy', name, 'missing scheme');
        Hoek.assert(this._schemes[scheme], 'Authentication strategy', name, 'uses unknown scheme:', scheme);

        server = server._clone();
        const strategy = this._schemes[scheme](server, options);

        Hoek.assert(strategy.authenticate, 'Invalid scheme:', name, 'missing authenticate() method');
        Hoek.assert(typeof strategy.authenticate === 'function', 'Invalid scheme:', name, 'invalid authenticate() method');
        Hoek.assert(!strategy.payload || typeof strategy.payload === 'function', 'Invalid scheme:', name, 'invalid payload() method');
        Hoek.assert(!strategy.response || typeof strategy.response === 'function', 'Invalid scheme:', name, 'invalid response() method');
        strategy.options = strategy.options || {};
        Hoek.assert(strategy.payload || !strategy.options.payload, 'Cannot require payload validation without a payload method');

        this._strategies[name] = {
            methods: strategy,
            realm: server.realm
        };

        if (strategy.api) {
            this.api[name] = strategy.api;
        }
    }

    default(options) {

        Hoek.assert(!this.settings.default, 'Cannot set default strategy more than once');
        options = Config.apply('auth', options, 'default strategy');

        this.settings.default = this._setupRoute(Hoek.clone(options));      // Prevent changes to options

        const routes = this._core.router.table();
        for (const route of routes) {
            route.rebuild();
        }
    }

    async test(name, request) {

        Hoek.assert(name, 'Missing authentication strategy name');
        const strategy = this._strategies[name];
        Hoek.assert(strategy, 'Unknown authentication strategy:', name);

        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });

        if (!response.isAuth) {
            throw response;
        }

        if (response.error) {
            throw response.error;
        }

        return response.data;
    }

    async verify(request) {

        const auth = request.auth;

        if (auth.error) {
            throw auth.error;
        }

        if (!auth.isAuthenticated) {
            return;
        }

        const strategy = this._strategies[auth.strategy];
        Hoek.assert(strategy, 'Unknown authentication strategy:', auth.strategy);

        if (!strategy.methods.verify) {
            return;
        }

        const bind = strategy.methods;
        await strategy.methods.verify.call(bind, auth);
    }

    static testAccess(request, route) {

        const auth = request._core.auth;

        try {
            return auth._access(request, route);
        }
        catch (err) {
            Bounce.rethrow(err, 'system');
            return false;
        }
    }

    _setupRoute(options, path) {

        if (!options) {
            return options;         // Preserve the difference between undefined and false
        }

        if (typeof options === 'string') {
            options = { strategies: [options] };
        }
        else if (options.strategy) {
            options.strategies = [options.strategy];
            delete options.strategy;
        }

        if (path &&
            !options.strategies) {

            Hoek.assert(this.settings.default, 'Route missing authentication strategy and no default defined:', path);
            options = Hoek.applyToDefaults(this.settings.default, options);
        }

        path = path || 'default strategy';
        Hoek.assert(options.strategies && options.strategies.length, 'Missing authentication strategy:', path);

        options.mode = options.mode || 'required';

        if (options.entity !== undefined ||                                             // Backwards compatibility with <= 11.x.x
            options.scope !== undefined) {

            options.access = [{ entity: options.entity, scope: options.scope }];
            delete options.entity;
            delete options.scope;
        }

        if (options.access) {
            for (const access of options.access) {
                access.scope = internals.setupScope(access);
            }
        }

        if (options.payload === true) {
            options.payload = 'required';
        }

        let hasAuthenticatePayload = false;
        for (const name of options.strategies) {
            const strategy = this._strategies[name];
            Hoek.assert(strategy, 'Unknown authentication strategy', name, 'in', path);

            Hoek.assert(strategy.methods.payload || options.payload !== 'required', 'Payload validation can only be required when all strategies support it in', path);
            hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;
            Hoek.assert(!strategy.methods.options.payload || options.payload === undefined || options.payload === 'required', 'Cannot set authentication payload to', options.payload, 'when a strategy requires payload validation in', path);
        }

        Hoek.assert(!options.payload || hasAuthenticatePayload, 'Payload authentication requires at least one strategy with payload support in', path);

        return options;
    }

    lookup(route) {

        if (route.settings.auth === false) {
            return false;
        }

        return route.settings.auth || this.settings.default;
    }

    _enabled(route, type) {

        const config = this.lookup(route);
        if (!config) {
            return false;
        }

        if (type === 'authenticate') {
            return true;
        }

        if (type === 'access') {
            return !!config.access;
        }

        for (const name of config.strategies) {
            const strategy = this._strategies[name];
            if (strategy.methods[type]) {
                return true;
            }
        }

        return false;
    }

    static authenticate(request) {

        const auth = request._core.auth;
        return auth._authenticate(request);
    }

    async _authenticate(request) {

        const config = this.lookup(request.route);

        const errors = [];
        request.auth.mode = config.mode;

        // Injection bypass

        if (request.auth.credentials) {
            internals.validate(null, { credentials: request.auth.credentials, artifacts: request.auth.artifacts }, request.auth.strategy, config, request, errors);
            return;
        }

        // Try each strategy

        for (const name of config.strategies) {
            const strategy = this._strategies[name];

            const bind = strategy.methods;
            const realm = strategy.realm;
            const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });

            const message = (response.isAuth ? internals.validate(response.error, response.data, name, config, request, errors) : internals.validate(response, null, name, config, request, errors));
            if (!message) {
                return;
            }

            if (message !== internals.missing) {
                return message;
            }
        }

        // No more strategies

        const err = Boom.unauthorized('Missing authentication', errors);
        if (config.mode === 'required') {
            throw err;
        }

        request.auth.isAuthenticated = false;
        request.auth.credentials = null;
        request.auth.error = err;
        request._log(['auth', 'unauthenticated']);
    }

    static access(request) {

        const auth = request._core.auth;
        request.auth.isAuthorized = auth._access(request);
    }

    _access(request, route) {

        const config = this.lookup(route || request.route);
        if (!config ||
            !config.access) {

            return true;
        }

        const credentials = request.auth.credentials;
        if (!credentials) {
            if (config.mode !== 'required') {
                return false;
            }

            throw Boom.forbidden('Request is unauthenticated');
        }

        const requestEntity = (credentials.user ? 'user' : 'app');

        const scopeErrors = [];
        for (const access of config.access) {

            // Check entity

            const entity = access.entity;
            if (entity &&
                entity !== 'any' &&
                entity !== requestEntity) {

                continue;
            }

            // Check scope

            let scope = access.scope;
            if (scope) {
                if (!credentials.scope) {
                    scopeErrors.push(scope);
                    continue;
                }

                scope = internals.expandScope(request, scope);
                if (!internals.validateScope(credentials, scope, 'required') ||
                    !internals.validateScope(credentials, scope, 'selection') ||
                    !internals.validateScope(credentials, scope, 'forbidden')) {

                    scopeErrors.push(scope);
                    continue;
                }
            }

            return true;
        }

        // Scope error

        if (scopeErrors.length) {
            request._log(['auth', 'scope', 'error']);
            throw Boom.forbidden('Insufficient scope', { got: credentials.scope, need: scopeErrors });
        }

        // Entity error

        if (requestEntity === 'app') {
            request._log(['auth', 'entity', 'user', 'error']);
            throw Boom.forbidden('Application credentials cannot be used on a user endpoint');
        }

        request._log(['auth', 'entity', 'app', 'error']);
        throw Boom.forbidden('User credentials cannot be used on an application endpoint');
    }

    static async payload(request) {

        if (!request.auth.isAuthenticated) {
            return;
        }

        const auth = request._core.auth;
        const strategy = auth._strategies[request.auth.strategy];
        Hoek.assert(strategy, 'Unknown authentication strategy:', request.auth.strategy);

        if (!strategy.methods.payload) {
            return;
        }

        const config = auth.lookup(request.route);
        const setting = config.payload || (strategy.methods.options.payload ? 'required' : false);
        if (!setting) {
            return;
        }

        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.payload, request, { bind, realm });

        if (response.isBoom &&
            response.isMissing) {

            return (setting === 'optional' ? undefined : Boom.unauthorized('Missing payload authentication'));
        }

        return response;
    }

    static async response(request) {

        const auth = request._core.auth;
        if (!request.auth.isAuthenticated) {
            return;
        }

        const strategy = auth._strategies[request.auth.strategy];
        Hoek.assert(strategy, 'Unknown authentication strategy:', request.auth.strategy);

        if (!strategy.methods.response) {
            return;
        }

        const bind = strategy.methods;
        const realm = strategy.realm;
        const error = await request._core.toolkit.execute(strategy.methods.response, request, { bind, realm, continue: 'undefined' });
        if (error) {
            throw error;
        }
    }
};


internals.setupScope = function (access) {

    if (!access.scope) {
        return false;
    }

    const scope = {};
    for (const value of access.scope) {
        const prefix = value[0];
        const type = (prefix === '+' ? 'required' : (prefix === '!' ? 'forbidden' : 'selection'));
        const clean = (type === 'selection' ? value : value.slice(1));
        scope[type] = scope[type] || [];
        scope[type].push(clean);

        if ((!scope._hasParameters || !scope._hasParameters[type]) &&
            /{([^}]+)}/.test(clean)) {

            scope._hasParameters = scope._hasParameters || {};
            scope._hasParameters[type] = true;
        }
    }

    return scope;
};


internals.validate = function (err, result, name, config, request, errors) {                 // err can be Boom, Error, or a valid response object

    result = result || {};

    // Unauthenticated

    if (err) {
        if (err instanceof Error === false) {
            request._log(['auth', 'unauthenticated', 'response', name], { statusCode: err.statusCode });
            return err;     // Non-error response
        }

        if (err.isMissing) {

            // Try next strategy

            request._log(['auth', 'unauthenticated', 'missing', name], err);
            errors.push(err.output.headers['WWW-Authenticate']);
            return internals.missing;
        }

        if (config.mode === 'try') {
            request.auth.isAuthenticated = false;
            request.auth.strategy = name;
            request.auth.credentials = result.credentials;
            request.auth.artifacts = result.artifacts;
            request.auth.error = err;
            request._log(['auth', 'unauthenticated', 'try', name], err);
            return;
        }

        request._log(['auth', 'unauthenticated', 'error', name], err);
        throw err;
    }

    // Authenticated

    const credentials = result.credentials;
    request.auth.strategy = name;
    request.auth.credentials = credentials;
    request.auth.artifacts = result.artifacts;
    request.auth.isAuthenticated = true;
};


internals.expandScope = function (request, scope) {

    if (!scope._hasParameters) {
        return scope;
    }

    const expanded = {
        required: internals.expandScopeType(request, scope, 'required'),
        selection: internals.expandScopeType(request, scope, 'selection'),
        forbidden: internals.expandScopeType(request, scope, 'forbidden')
    };

    return expanded;
};


internals.expandScopeType = function (request, scope, type) {

    if (!scope._hasParameters[type]) {
        return scope[type];
    }

    const expanded = [];
    const context = {
        params: request.params,
        query: request.query,
        payload: request.payload,
        credentials: request.auth.credentials
    };

    for (const template of scope[type]) {
        expanded.push(Hoek.reachTemplate(context, template));
    }

    return expanded;
};


internals.validateScope = function (credentials, scope, type) {

    if (!scope[type]) {
        return true;
    }

    const count = typeof credentials.scope === 'string' ?
        (scope[type].indexOf(credentials.scope) !== -1 ? 1 : 0) :
        Hoek.intersect(scope[type], credentials.scope).length;

    if (type === 'forbidden') {
        return count === 0;
    }

    if (type === 'required') {
        return count === scope.required.length;
    }

    return !!count;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/compression.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/compression.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Zlib = __webpack_require__(/*! zlib */ "zlib");

const Accept = __webpack_require__(/*! @hapi/accept */ "./node_modules/@hapi/accept/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    common: ['gzip, deflate', 'deflate, gzip', 'gzip', 'deflate', 'gzip, deflate, br']
};


exports = module.exports = internals.Compression = class {

    constructor() {

        this.encodings = ['identity', 'gzip', 'deflate'];
        this._encoders = {
            identity: null,
            gzip: (options) => Zlib.createGzip(options),
            deflate: (options) => Zlib.createDeflate(options)
        };

        this._decoders = {
            gzip: (options) => Zlib.createGunzip(options),
            deflate: (options) => Zlib.createInflate(options)
        };

        this._updateCommons();
    }

    _updateCommons() {

        this._common = new Map();
        internals.common.forEach((header) => {

            this._common.set(header, Accept.encoding(header, this.encodings));
        });
    }

    addEncoder(encoding, encoder) {

        Hoek.assert(this._encoders[encoding] === undefined, `Cannot override existing encoder for ${encoding}`);
        Hoek.assert(typeof encoder === 'function', `Invalid encoder function for ${encoding}`);
        this._encoders[encoding] = encoder;
        this.encodings.unshift(encoding);
        this._updateCommons();
    }

    addDecoder(encoding, decoder) {

        Hoek.assert(this._decoders[encoding] === undefined, `Cannot override existing decoder for ${encoding}`);
        Hoek.assert(typeof decoder === 'function', `Invalid decoder function for ${encoding}`);
        this._decoders[encoding] = decoder;
    }

    accept(request) {

        const header = request.headers['accept-encoding'];
        const common = this._common.get(header);
        if (common) {
            return common;
        }

        try {
            return Accept.encoding(header, this.encodings);
        }
        catch (err) {
            Bounce.rethrow(err, 'system');
            err.header = header;
            request._log(['accept-encoding', 'error'], err);
            return 'identity';
        }
    }

    encoding(response, length) {

        if (response.settings.compressed) {
            response.headers['content-encoding'] = response.settings.compressed;
            return null;
        }

        const request = response.request;
        if (!request._core.settings.compression ||
            length !== null && length < request._core.settings.compression.minBytes) {

            return null;
        }

        const mime = request._core.mime.type(response.headers['content-type'] || 'application/octet-stream');
        if (!mime.compressible) {
            return null;
        }

        response.vary('accept-encoding');

        if (response.headers['content-encoding']) {
            return null;
        }

        return request.info.acceptEncoding === 'identity' ? null : request.info.acceptEncoding;
    }

    encoder(request, encoding) {

        const encoder = this._encoders[encoding];
        Hoek.assert(encoder !== undefined, `Unknown encoding ${encoding}`);
        return encoder(request.route.settings.compression[encoding]);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/config.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/config.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Os = __webpack_require__(/*! os */ "os");

const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");


const internals = {};


exports.symbol = Symbol('hapi-response');


exports.apply = function (type, options, ...message) {

    const result = Joi.validate(options, internals[type]);

    if (result.error) {
        throw new Error(`Invalid ${type} options ${message.length ? '(' + message.join(' ') + ')' : ''} ${result.error.annotate()}`);
    }

    return result.value;
};


exports.enable = function (options) {

    const settings = (options ? Object.assign({}, options) : {});       // Shallow cloned

    if (settings.security === true) {
        settings.security = {};
    }

    if (settings.cors === true) {
        settings.cors = {};
    }

    return settings;
};


internals.access = Joi.object({
    entity: Joi.valid('user', 'app', 'any'),
    scope: [false, Joi.array().items(Joi.string()).single().min(1)]
});


internals.auth = Joi.alternatives([
    Joi.string(),
    internals.access.keys({
        mode: Joi.valid('required', 'optional', 'try'),
        strategy: Joi.string(),
        strategies: Joi.array().items(Joi.string()).min(1),
        access: Joi.array().items(internals.access.min(1)).single().min(1),
        payload: [
            Joi.valid('required', 'optional'),
            Joi.boolean()
        ]
    })
        .without('strategy', 'strategies')
        .without('access', ['scope', 'entity'])
]);


internals.event = Joi.object({
    method: Joi.array().items(Joi.func()).single(),
    options: Joi.object({
        before: Joi.array().items(Joi.string()).single(),
        after: Joi.array().items(Joi.string()).single(),
        bind: Joi.any(),
        sandbox: Joi.valid('server', 'plugin'),
        timeout: Joi.number().integer().min(1)
    })
        .default({})
});


internals.exts = Joi.array().items(internals.event.keys({ type: Joi.string().required() })).single();


internals.failAction = Joi.alternatives([
    Joi.valid('error', 'log', 'ignore'),
    Joi.func()
])
    .default('error');


internals.routeBase = Joi.object({
    app: Joi.object().allow(null),
    auth: internals.auth.allow(false),
    bind: Joi.object().allow(null),
    cache: Joi.object({
        expiresIn: Joi.number(),
        expiresAt: Joi.string(),
        privacy: Joi.valid('default', 'public', 'private'),
        statuses: Joi.array().items(Joi.number().integer().min(200)).min(1).single().default([200, 204]),
        otherwise: Joi.string().default('no-cache')
    })
        .allow(false)
        .default(),
    compression: Joi.object()
        .pattern(/.+/, Joi.object())
        .default(),
    cors: Joi.object({
        origin: Joi.array().min(1).allow('ignore').default(['*']),
        maxAge: Joi.number().default(86400),
        headers: Joi.array().items(Joi.string()).default(['Accept', 'Authorization', 'Content-Type', 'If-None-Match']),
        additionalHeaders: Joi.array().items(Joi.string()).default([]),
        exposedHeaders: Joi.array().items(Joi.string()).default(['WWW-Authenticate', 'Server-Authorization']),
        additionalExposedHeaders: Joi.array().items(Joi.string()).default([]),
        credentials: Joi.boolean().when('origin', { is: 'ignore', then: false }).default(false)
    })
        .allow(false, true)
        .default(false),
    ext: Joi.object({
        onPreAuth: Joi.array().items(internals.event).single(),
        onCredentials: Joi.array().items(internals.event).single(),
        onPostAuth: Joi.array().items(internals.event).single(),
        onPreHandler: Joi.array().items(internals.event).single(),
        onPostHandler: Joi.array().items(internals.event).single(),
        onPreResponse: Joi.array().items(internals.event).single()
    })
        .default({}),
    files: Joi.object({
        relativeTo: Joi.string().regex(/^([\/\.])|([A-Za-z]:\\)|(\\\\)/).default('.')
    })
        .default(),
    json: Joi.object({
        replacer: Joi.alternatives(Joi.func(), Joi.array()).allow(null).default(null),
        space: Joi.number().allow(null).default(null),
        suffix: Joi.string().allow(null).default(null),
        escape: Joi.boolean().default(false)
    })
        .default(),
    jsonp: Joi.string(),
    log: Joi.object({
        collect: Joi.boolean().default(false)
    })
        .default(),
    payload: Joi.object({
        output: Joi.valid('data', 'stream', 'file').default('data'),
        parse: Joi.boolean().allow('gunzip').default(true),
        multipart: Joi.object({
            output: Joi.valid('data', 'stream', 'file', 'annotated').required()
        })
            .allow(false),
        allow: Joi.array().items(Joi.string()).single(),
        override: Joi.string(),
        protoAction: Joi.valid('error', 'remove', 'ignore').default('error'),
        maxBytes: Joi.number().integer().positive().default(1024 * 1024),
        uploads: Joi.string().default(Os.tmpdir()),
        failAction: internals.failAction,
        timeout: Joi.number().integer().positive().allow(false).default(10 * 1000),
        defaultContentType: Joi.string().default('application/json'),
        compression: Joi.object()
            .pattern(/.+/, Joi.object())
            .default()
    })
        .default(),
    plugins: Joi.object(),
    response: Joi.object({
        disconnectStatusCode: Joi.number().integer().min(400).default(499),
        emptyStatusCode: Joi.valid(200, 204).default(200),
        failAction: internals.failAction,
        modify: Joi.boolean(),
        options: Joi.object().default(),
        ranges: Joi.boolean().default(true),
        sample: Joi.number().min(0).max(100).when('modify', { is: true, then: Joi.forbidden() }),
        schema: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(true, false),
        status: Joi.object().pattern(/\d\d\d/, Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(true, false))
    })
        .default()
        .assert('options.stripUnknown', Joi.when('modify', { is: true, otherwise: false }), 'meet requirement of having peer modify set to true'),
    security: Joi.object({
        hsts: Joi.alternatives([
            Joi.object({
                maxAge: Joi.number(),
                includeSubdomains: Joi.boolean(),
                includeSubDomains: Joi.boolean(),
                preload: Joi.boolean()
            }),
            Joi.boolean(),
            Joi.number()
        ])
            .default(15768000),
        xframe: Joi.alternatives([
            Joi.boolean(),
            Joi.valid('sameorigin', 'deny'),
            Joi.object({
                rule: Joi.valid('sameorigin', 'deny', 'allow-from'),
                source: Joi.string()
            })
        ])
            .default('deny'),
        xss: Joi.boolean().default(true),
        noOpen: Joi.boolean().default(true),
        noSniff: Joi.boolean().default(true),
        referrer: Joi.alternatives([
            Joi.boolean().valid(false),
            Joi.valid('', 'no-referrer', 'no-referrer-when-downgrade',
                'unsafe-url', 'same-origin', 'origin', 'strict-origin',
                'origin-when-cross-origin', 'strict-origin-when-cross-origin')
        ])
            .default(false)
    })
        .allow(null, false, true)
        .default(false),
    state: Joi.object({
        parse: Joi.boolean().default(true),
        failAction: internals.failAction
    })
        .default(),
    timeout: Joi.object({
        socket: Joi.number().integer().positive().allow(false),
        server: Joi.number().integer().positive().allow(false).default(false)
    })
        .default(),
    validate: Joi.object({
        headers: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, true),
        params: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, true),
        query: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),
        payload: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),
        state: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),
        failAction: internals.failAction,
        errorFields: Joi.object(),
        options: Joi.object().default()
    })
        .default()
});


internals.server = Joi.object({
    address: Joi.string().hostname(),
    app: Joi.object().allow(null),
    autoListen: Joi.boolean(),
    cache: Joi.allow(null),                                 // Validated elsewhere
    compression: Joi.object({
        minBytes: Joi.number().min(1).integer().default(1024)
    })
        .allow(false)
        .default(),
    debug: Joi.object({
        request: Joi.array().items(Joi.string()).single().allow(false).default(['implementation']),
        log: Joi.array().items(Joi.string()).single().allow(false)
    })
        .allow(false)
        .default(),
    host: Joi.string().hostname().allow(null),
    listener: Joi.any(),
    load: Joi.object({
        sampleInterval: Joi.number().integer().min(0).default(0),
        concurrent: Joi.number().integer().min(0).default(0)
    })
        .unknown()
        .default(),
    mime: Joi.object().allow(null).default(null),
    operations: Joi.object({
        cleanStop: Joi.boolean().default(true)
    })
        .default(),
    plugins: Joi.object(),
    port: Joi.alternatives([
        Joi.number().integer().min(0),          // TCP port
        Joi.string().regex(/\//),               // Unix domain socket
        Joi.string().regex(/^\\\\\.\\pipe\\/)   // Windows named pipe
    ])
        .allow(null),
    query: Joi.object({
        parser: Joi.func()
    })
        .default(),
    router: Joi.object({
        isCaseSensitive: Joi.boolean().default(true),
        stripTrailingSlash: Joi.boolean().default(false)
    })
        .default(),
    routes: internals.routeBase.default(),
    state: Joi.object(),                                    // Cookie defaults
    tls: Joi.alternatives([
        Joi.object().allow(null),
        Joi.boolean()
    ]),
    uri: Joi.string().regex(/[^/]$/)
});


internals.vhost = Joi.alternatives([
    Joi.string().hostname(),
    Joi.array().items(Joi.string().hostname()).min(1)
]);


internals.handler = Joi.alternatives([
    Joi.func(),
    Joi.object().length(1)
]);


internals.route = Joi.object({
    method: Joi.string().regex(/^[a-zA-Z0-9!#\$%&'\*\+\-\.^_`\|~]+$/).required(),
    path: Joi.string().required(),
    rules: Joi.object(),
    vhost: internals.vhost,

    // Validated in route construction

    handler: Joi.any(),
    options: Joi.any(),
    config: Joi.any()               // Backwards compatibility
})
    .without('config', 'options');


internals.pre = [
    Joi.func(),
    Joi.object({
        method: Joi.alternatives(Joi.string(), Joi.func()).required(),
        assign: Joi.string(),
        mode: Joi.valid('serial', 'parallel'),
        failAction: internals.failAction
    })
];


internals.routeConfig = internals.routeBase.keys({
    description: Joi.string(),
    id: Joi.string(),
    isInternal: Joi.boolean(),
    notes: [
        Joi.string(),
        Joi.array().items(Joi.string())
    ],
    pre: Joi.array().items(internals.pre.concat(Joi.array().items(internals.pre).min(1))),
    tags: [
        Joi.string(),
        Joi.array().items(Joi.string())
    ]
});


internals.cacheConfig = Joi.alternatives([
    Joi.func(),
    Joi.object({
        name: Joi.string().invalid('_default'),
        shared: Joi.boolean(),
        provider: [
            Joi.func(),
            {
                constructor: Joi.func().required(),
                options: Joi.object({
                    partition: Joi.string().default('hapi-cache')
                })
                    .unknown()      // Catbox client validates other keys
                    .default({})
            }
        ],
        engine: Joi.object()
    })
        .xor('provider', 'engine')
]);


internals.cache = Joi.array().items(internals.cacheConfig).min(1).single();


internals.cachePolicy = Joi.object({
    cache: Joi.string().allow(null).allow(''),
    segment: Joi.string(),
    shared: Joi.boolean()
})
    .unknown();                     // Catbox policy validates other keys


internals.method = Joi.object({
    bind: Joi.object().allow(null),
    generateKey: Joi.func(),
    cache: internals.cachePolicy
});


internals.methodObject = Joi.object({
    name: Joi.string().required(),
    method: Joi.func().required(),
    options: Joi.object()
});


internals.register = Joi.object({
    once: true,
    routes: Joi.object({
        prefix: Joi.string().regex(/^\/.+/),
        vhost: internals.vhost
    })
        .default({})
});


internals.semver = Joi.string();


internals.plugin = internals.register.keys({
    options: Joi.any(),
    plugin: Joi.object({
        register: Joi.func().required(),
        name: Joi.string().when('pkg.name', { is: Joi.exist(), otherwise: Joi.required() }),
        version: Joi.string(),
        multiple: Joi.boolean().default(false),
        dependencies: [
            Joi.array().items(Joi.string()).single(),
            Joi.object().pattern(/.+/, internals.semver)
        ],
        once: true,
        requirements: Joi.object({
            hapi: Joi.string(),
            node: Joi.string()
        })
            .default(),
        pkg: Joi.object({
            name: Joi.string(),
            version: Joi.string().default('0.0.0')
        })
            .unknown()
            .default({})
    })
        .unknown()
})
    .without('once', 'options')
    .unknown();


internals.rules = Joi.object({
    validate: Joi.object({
        schema: Joi.alternatives(Joi.object(), Joi.array()).required(),
        options: Joi.object()
            .default({ allowUnknown: true })
    })
});


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/core.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/core.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Http = __webpack_require__(/*! http */ "http");
const Https = __webpack_require__(/*! https */ "https");
const Os = __webpack_require__(/*! os */ "os");
const Path = __webpack_require__(/*! path */ "path");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Call = __webpack_require__(/*! @hapi/call */ "./node_modules/@hapi/call/lib/index.js");
const Catbox = __webpack_require__(/*! @hapi/catbox */ "./node_modules/@hapi/catbox/lib/index.js");
const CatboxMemory = __webpack_require__(/*! @hapi/catbox-memory */ "./node_modules/@hapi/catbox-memory/lib/index.js");
const Heavy = __webpack_require__(/*! @hapi/heavy */ "./node_modules/@hapi/heavy/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Mimos = __webpack_require__(/*! @hapi/mimos */ "./node_modules/@hapi/mimos/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");
const Somever = __webpack_require__(/*! @hapi/somever */ "./node_modules/@hapi/somever/lib/index.js");
const Statehood = __webpack_require__(/*! @hapi/statehood */ "./node_modules/@hapi/statehood/lib/index.js");

const Auth = __webpack_require__(/*! ./auth */ "./node_modules/@hapi/hapi/lib/auth.js");
const Compression = __webpack_require__(/*! ./compression */ "./node_modules/@hapi/hapi/lib/compression.js");
const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Ext = __webpack_require__(/*! ./ext */ "./node_modules/@hapi/hapi/lib/ext.js");
const Methods = __webpack_require__(/*! ./methods */ "./node_modules/@hapi/hapi/lib/methods.js");
const Request = __webpack_require__(/*! ./request */ "./node_modules/@hapi/hapi/lib/request.js");
const Route = __webpack_require__(/*! ./route */ "./node_modules/@hapi/hapi/lib/route.js");
const Toolkit = __webpack_require__(/*! ./toolkit */ "./node_modules/@hapi/hapi/lib/toolkit.js");


const internals = {
    counter: {
        min: 10000,
        max: 99999
    },
    events: [
        { name: 'log', channels: ['app', 'internal'], tags: true },
        { name: 'request', channels: ['app', 'internal', 'error'], tags: true, spread: true },
        'response',
        'route',
        'start',
        'stop'
    ],
    badRequestResponse: Buffer.from('HTTP/1.1 400 Bad Request\r\n\r\n', 'ascii')
};


exports = module.exports = internals.Core = class {

    constructor(options) {

        this.root = null;                                                               // Dispatch reference of the root server

        const { settings, type } = internals.setup(options);

        this.settings = settings;
        this.type = type;

        this.app = {};
        this.auth = new Auth(this);
        this.caches = new Map();                                                        // Cache clients
        this.compression = new Compression();
        this.controlled = null;                                                         // Other servers linked to the phases of this server
        this.decorations = { handler: [], request: [], server: [], toolkit: [] };       // Public decoration names
        this.dependencies = [];                                                         // Plugin dependencies
        this.events = new Podium(internals.events);
        this.heavy = new Heavy(this.settings.load);
        this.instances = new Set();
        this.methods = new Methods(this);                                               // Server methods
        this.mime = new Mimos(this.settings.mime);
        this.onConnection = null;                                                       // Used to remove event listener on stop
        this.plugins = {};                                                              // Exposed plugin properties by name
        this.queue = new internals.Queue(this.settings.load);
        this.registrations = {};                                                        // Tracks plugin for dependency validation { name -> { version } }
        this.registring = 0;                                                            // > 0 while register() is waiting for plugin callbacks
        this.requestCounter = { value: internals.counter.min, min: internals.counter.min, max: internals.counter.max };
        this.router = new Call.Router(this.settings.router);
        this.phase = 'stopped';                                                         // 'stopped', 'initializing', 'initialized', 'starting', 'started', 'stopping', 'invalid'
        this.sockets = null;                                                            // Track open sockets for graceful shutdown
        this.actives = new WeakMap();                                                   // Active requests being processed
        this.started = false;
        this.states = new Statehood.Definitions(this.settings.state);
        this.toolkit = new Toolkit();

        this.extensionsSeq = 0;                                                         // Used to keep absolute order of extensions based on the order added across locations
        this.extensions = {
            server: {
                onPreStart: new Ext('onPreStart', this),
                onPostStart: new Ext('onPostStart', this),
                onPreStop: new Ext('onPreStop', this),
                onPostStop: new Ext('onPostStop', this)
            },
            route: {
                onRequest: new Ext('onRequest', this),
                onPreAuth: new Ext('onPreAuth', this),
                onCredentials: new Ext('onCredentials', this),
                onPostAuth: new Ext('onPostAuth', this),
                onPreHandler: new Ext('onPreHandler', this),
                onPostHandler: new Ext('onPostHandler', this),
                onPreResponse: new Ext('onPreResponse', this)
            }
        };

        this.Request = class extends Request { };

        this._debug();
        this._decorations = { handler: {}, request: {}, server: {}, toolkit: {}, requestApply: null };
        this._initializeCache();

        this.listener = this._createListener();
        this._initializeListener();
        this.info = this._info();
    }

    _debug() {

        // Subscribe to server log events

        if (this.settings.debug) {
            const debug = (request, event) => {

                const data = event.error || event.data;
                console.error('Debug:', event.tags.join(', '), data ? '\n    ' + (data.stack || (typeof data === 'object' ? Hoek.stringify(data) : data)) : '');
            };

            if (this.settings.debug.log) {
                const filter = this.settings.debug.log.some((tag) => tag === '*') ? undefined : this.settings.debug.log;
                this.events.on({ name: 'log', filter }, (event) => debug(null, event));
            }

            if (this.settings.debug.request) {
                const filter = this.settings.debug.request.some((tag) => tag === '*') ? undefined : this.settings.debug.request;
                this.events.on({ name: 'request', filter }, debug);
            }
        }
    }

    _initializeCache() {

        if (this.settings.cache) {
            this._createCache(this.settings.cache);
        }

        if (!this.caches.has('_default')) {
            this._createCache([{ provider: CatboxMemory }]);        // Defaults to memory-based
        }
    }

    _info() {

        const now = Date.now();
        const protocol = this.type === 'tcp' ? (this.settings.tls ? 'https' : 'http') : this.type;
        const host = this.settings.host || Os.hostname() || 'localhost';
        const port = this.settings.port;

        const info = {
            created: now,
            started: 0,
            host,
            port,
            protocol,
            id: Os.hostname() + ':' + process.pid + ':' + now.toString(36),
            uri: this.settings.uri || (protocol + ':' + (this.type === 'tcp' ? '//' + host + (port ? ':' + port : '') : port))
        };

        return info;
    }

    _createCache(configs) {

        Hoek.assert(this.phase !== 'initializing', 'Cannot provision server cache while server is initializing');

        configs = Config.apply('cache', configs);

        const added = [];
        for (let config of configs) {

            // <function>
            // { provider: <function> }
            // { provider: { constructor: <function>, options } }
            // { engine }

            if (typeof config === 'function') {
                config = { provider: { constructor: config } };
            }

            const name = config.name || '_default';
            Hoek.assert(!this.caches.has(name), 'Cannot configure the same cache more than once: ', name === '_default' ? 'default cache' : name);

            let client = null;

            if (config.provider) {
                let provider = config.provider;
                if (typeof provider === 'function') {
                    provider = { constructor: provider };
                }

                client = new Catbox.Client(provider.constructor, provider.options || { partition: 'hapi-cache' });
            }
            else {
                client = new Catbox.Client(config.engine);
            }

            this.caches.set(name, { client, segments: {}, shared: config.shared || false });
            added.push(client);
        }

        return added;
    }

    registerServer(server) {

        if (!this.root) {
            this.root = server;
            this._defaultRoutes();
        }

        this.instances.add(server);
    }

    async _start() {

        if (this.phase === 'initialized' ||
            this.phase === 'started') {

            this._validateDeps();
        }

        if (this.phase === 'started') {
            return;
        }

        if (this.phase !== 'stopped' &&
            this.phase !== 'initialized') {

            throw new Error('Cannot start server while it is in ' + this.phase + ' phase');
        }

        if (this.phase !== 'initialized') {
            await this._initialize();
        }

        this.phase = 'starting';
        this.started = true;
        this.info.started = Date.now();

        try {
            await this._listen();
        }
        catch (err) {
            this.started = false;
            this.phase = 'invalid';
            throw err;
        }

        this.phase = 'started';
        await this.events.emit('start');

        try {
            if (this.controlled) {
                await Promise.all(this.controlled.map((control) => control.start()));
            }

            await this._invoke('onPostStart');
        }
        catch (err) {
            this.phase = 'invalid';
            throw err;
        }
    }

    _listen() {

        return new Promise((resolve, reject) => {

            if (!this.settings.autoListen) {
                resolve();
                return;
            }

            const onError = (err) => {

                reject(err);
                return;
            };

            this.listener.once('error', onError);

            const finalize = () => {

                this.listener.removeListener('error', onError);
                resolve();
                return;
            };

            if (this.type !== 'tcp') {
                this.listener.listen(this.settings.port, finalize);
            }
            else {
                const address = this.settings.address || this.settings.host || '0.0.0.0';
                this.listener.listen(this.settings.port, address, finalize);
            }
        });
    }

    async _initialize() {

        if (this.registring) {
            throw new Error('Cannot start server before plugins finished registration');
        }

        if (this.phase === 'initialized') {
            return;
        }

        if (this.phase !== 'stopped') {
            throw new Error('Cannot initialize server while it is in ' + this.phase + ' phase');
        }

        this._validateDeps();
        this.phase = 'initializing';

        // Start cache

        try {
            const caches = [];
            this.caches.forEach((cache) => caches.push(cache.client.start()));
            await Promise.all(caches);
            await this._invoke('onPreStart');
            this.heavy.start();
            this.phase = 'initialized';

            if (this.controlled) {
                await Promise.all(this.controlled.map((control) => control.initialize()));
            }
        }
        catch (err) {
            this.phase = 'invalid';
            throw err;
        }
    }

    _validateDeps() {

        for (const { deps, plugin } of this.dependencies) {
            for (const dep in deps) {
                const version = deps[dep];
                Hoek.assert(this.registrations[dep], 'Plugin', plugin, 'missing dependency', dep);
                Hoek.assert(version === '*' || Somever.match(this.registrations[dep].version, version), 'Plugin', plugin, 'requires', dep, 'version', version, 'but found', this.registrations[dep].version);
            }
        }
    }

    async _stop(options = {}) {

        options.timeout = options.timeout || 5000;          // Default timeout to 5 seconds

        if (['stopped', 'initialized', 'started', 'invalid'].indexOf(this.phase) === -1) {
            throw new Error('Cannot stop server while in ' + this.phase + ' phase');
        }

        this.phase = 'stopping';

        try {
            await this._invoke('onPreStop');

            if (this.started) {
                this.started = false;
                this.info.started = 0;

                await this._unlisten(options.timeout);
            }

            const caches = [];
            this.caches.forEach((cache) => caches.push(cache.client.stop()));
            await Promise.all(caches);

            await this.events.emit('stop');
            this.heavy.stop();

            if (this.controlled) {
                await Promise.all(this.controlled.map((control) => control.stop(options)));
            }

            await this._invoke('onPostStop');
            this.phase = 'stopped';
        }
        catch (err) {
            this.phase = 'invalid';
            throw err;
        }
    }

    _unlisten(timeout) {

        let timeoutId = null;
        if (this.settings.operations.cleanStop) {

            // Set connections timeout

            const destroy = () => {

                this.sockets.forEach((connection) => connection.destroy());
                this.sockets.clear();
            };

            timeoutId = setTimeout(destroy, timeout);

            // Tell idle keep-alive connections to close

            this.sockets.forEach((connection) => {

                if (!this.actives.has(connection)) {
                    connection.end();
                }
            });
        }

        // Close connection

        return new Promise((resolve) => {

            this.listener.close(() => {

                if (this.settings.operations.cleanStop) {
                    this.listener.removeListener(this.settings.tls ? 'secureConnection' : 'connection', this.onConnection);
                    clearTimeout(timeoutId);
                }

                this._initializeListener();
                resolve();
            });
        });
    }

    async _invoke(type) {

        const exts = this.extensions.server[type];
        if (!exts.nodes) {
            return;
        }

        // Execute extensions

        for (const ext of exts.nodes) {
            const bind = ext.bind || ext.realm.settings.bind;
            const operation = ext.func.call(bind, ext.server, bind);
            await Toolkit.timed(operation, { timeout: ext.timeout, name: type });
        }
    }

    _defaultRoutes() {

        this.router.special('notFound', new Route({ method: '_special', path: '/{p*}', handler: internals.notFound }, this.root, { special: true }));
        this.router.special('badRequest', new Route({ method: '_special', path: '/{p*}', handler: internals.badRequest }, this.root, { special: true }));

        if (this.settings.routes.cors) {
            Cors.handler(this.root);
        }
    }

    _dispatch(options = {}) {

        return (req, res) => {

            // Create request

            const request = Request.generate(this.root, req, res, options);

            // Track socket request processing state

            if (req.socket) {
                this.actives.set(req.socket, request);
                const env = { core: this, req };
                res.on('finish', internals.onFinish.bind(res, env));
            }

            // Check load

            if (this.settings.load.sampleInterval) {
                try {
                    this.heavy.check();
                }
                catch (err) {
                    Bounce.rethrow(err, 'system');
                    this._log(['load'], this.heavy.load);
                    request._reply(err);
                    return;
                }
            }

            this.queue.add(request);
        };
    }

    _createListener() {

        const listener = this.settings.listener || (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());
        listener.on('request', this._dispatch());
        listener.on('checkContinue', this._dispatch({ expectContinue: true }));

        listener.on('clientError', (err, socket) => {

            this._log(['connection', 'client', 'error'], err);

            if (socket.readable) {
                const request = this.actives.get(socket);
                if (request) {
                    const error = Boom.badRequest();
                    error.output.headers = { connection: 'close' };
                    request._reply(error);
                }
                else {
                    socket.end(internals.badRequestResponse);
                }
            }
            else {
                socket.destroy(err);
            }
        });

        return listener;
    }

    _initializeListener() {

        this.listener.once('listening', () => {

            // Update the address, port, and uri with active values

            if (this.type === 'tcp') {
                const address = this.listener.address();
                this.info.address = address.address;
                this.info.port = address.port;
                this.info.uri = this.settings.uri || this.info.protocol + '://' + this.info.host + ':' + this.info.port;
            }

            if (this.settings.operations.cleanStop) {
                this.sockets = new Set();

                const self = this;
                const onClose = function () {           // 'this' is bound to the emitter

                    self.sockets.delete(this);
                };

                this.onConnection = (connection) => {

                    this.sockets.add(connection);
                    connection.on('close', onClose);
                };

                this.listener.on(this.settings.tls ? 'secureConnection' : 'connection', this.onConnection);
            }
        });
    }

    _cachePolicy(options, _segment, realm) {

        options = Config.apply('cachePolicy', options);

        const plugin = realm && realm.plugin;
        const segment = options.segment || _segment || (plugin ? `!${plugin}` : '');
        Hoek.assert(segment, 'Missing cache segment name');

        const cacheName = options.cache || '_default';
        const cache = this.caches.get(cacheName);
        Hoek.assert(cache, 'Unknown cache', cacheName);
        Hoek.assert(!cache.segments[segment] || cache.shared || options.shared, 'Cannot provision the same cache segment more than once');
        cache.segments[segment] = true;

        return new Catbox.Policy(options, cache.client, segment);
    }

    log(tags, data) {

        return this._log(tags, data, 'app');
    }

    _log(tags, data, channel = 'internal') {

        if (!this.events.hasListeners('log')) {
            return;
        }

        if (!Array.isArray(tags)) {
            tags = [tags];
        }

        const timestamp = Date.now();
        const field = data instanceof Error ? 'error' : 'data';

        let event = { timestamp, tags, [field]: data, channel };

        if (typeof data === 'function') {
            event = () => ({ timestamp, tags, data: data(), channel });
        }

        this.events.emit({ name: 'log', tags, channel }, event);
    }
};


internals.setup = function (options = {}) {

    let settings = Hoek.clone(options, { shallow: ['cache', 'listener', 'routes.bind'] });
    settings.routes = Config.enable(settings.routes);
    settings = Config.apply('server', settings);

    if (settings.port === undefined) {
        settings.port = 0;
    }

    const type = (typeof settings.port === 'string' ? 'socket' : 'tcp');
    if (type === 'socket') {
        settings.port = (settings.port.indexOf('/') !== -1 ? Path.resolve(settings.port) : settings.port.toLowerCase());
    }

    if (settings.autoListen === undefined) {
        settings.autoListen = true;
    }

    Hoek.assert(settings.autoListen || !settings.port, 'Cannot specify port when autoListen is false');
    Hoek.assert(settings.autoListen || !settings.address, 'Cannot specify address when autoListen is false');

    return { settings, type };
};


internals.notFound = function () {

    throw Boom.notFound();
};


internals.badRequest = function () {

    throw Boom.badRequest();
};


internals.onFinish = function (env) {

    const { core, req } = env;

    core.actives.delete(req.socket);
    if (!core.started) {
        req.socket.end();
    }
};


internals.Queue = class {

    constructor(options) {

        this.settings = options;

        this.active = 0;
        this.queue = [];
    }

    add(request) {

        if (this.settings.concurrent) {
            this.queue.push(request);
            this.next();
        }
        else {
            request._execute();
        }
    }

    next() {

        if (this.queue.length &&
            this.active < this.settings.concurrent) {

            const request = this.queue.shift();
            ++this.active;
            request._execute();
        }
    }

    release() {

        if (this.settings.concurrent) {
            --this.active;
            this.next();
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/cors.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/cors.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

let Route = null;                           // Delayed load due to circular dependency


const internals = {};


exports.route = function (options) {

    if (!options) {
        return false;
    }

    const settings = Hoek.clone(options);
    settings._headers = settings.headers.concat(settings.additionalHeaders);
    settings._headersString = settings._headers.join(',');
    for (let i = 0; i < settings._headers.length; ++i) {
        settings._headers[i] = settings._headers[i].toLowerCase();
    }

    if (settings._headers.indexOf('origin') === -1) {
        settings._headers.push('origin');
    }

    settings._exposedHeaders = settings.exposedHeaders.concat(settings.additionalExposedHeaders).join(',');

    if (settings.origin === 'ignore') {
        settings._origin = false;
    }
    else if (settings.origin.indexOf('*') !== -1) {
        Hoek.assert(settings.origin.length === 1, 'Cannot specify cors.origin * together with other values');
        settings._origin = true;
    }
    else {
        settings._origin = {
            qualified: [],
            wildcards: []
        };

        for (const origin of settings.origin) {
            if (origin.indexOf('*') !== -1) {
                settings._origin.wildcards.push(new RegExp('^' + Hoek.escapeRegex(origin).replace(/\\\*/g, '.*').replace(/\\\?/g, '.') + '$'));
            }
            else {
                settings._origin.qualified.push(origin);
            }
        }
    }

    return settings;
};


exports.options = function (route, server) {

    if (route.method === 'options' ||
        !route.settings.cors) {

        return;
    }

    exports.handler(server);
};


exports.handler = function (server) {

    Route = Route || __webpack_require__(/*! ./route */ "./node_modules/@hapi/hapi/lib/route.js");

    if (server._core.router.specials.options) {
        return;
    }

    const definition = {
        method: '_special',
        path: '/{p*}',
        handler: internals.handler,
        options: {
            cors: false
        }
    };

    const route = new Route(definition, server, { special: true });
    server._core.router.special('options', route);
};


internals.handler = function (request, h) {

    // Validate CORS preflight request

    const method = request.headers['access-control-request-method'];
    if (!method) {
        throw Boom.notFound('CORS error: Missing Access-Control-Request-Method header');
    }

    // Lookup route

    const route = request.server.match(method, request.path, request.info.hostname);
    if (!route) {
        throw Boom.notFound();
    }

    const settings = route.settings.cors;
    if (!settings) {
        return { message: 'CORS is disabled for this route' };
    }

    // Validate Origin header

    const origin = request.headers.origin;

    if (!origin &&
        settings._origin !== false) {

        throw Boom.notFound('CORS error: Missing Origin header');
    }

    if (!exports.matchOrigin(origin, settings)) {
        return { message: 'CORS error: Origin not allowed' };
    }

    // Validate allowed headers

    let headers = request.headers['access-control-request-headers'];
    if (headers) {
        headers = headers.toLowerCase().split(/\s*,\s*/);
        if (Hoek.intersect(headers, settings._headers).length !== headers.length) {
            return { message: 'CORS error: Some headers are not allowed' };
        }
    }

    // Reply with the route CORS headers

    const response = h.response();
    response._header('access-control-allow-origin', settings._origin ? origin : '*');
    response._header('access-control-allow-methods', method);
    response._header('access-control-allow-headers', settings._headersString);
    response._header('access-control-max-age', settings.maxAge);

    if (settings.credentials) {
        response._header('access-control-allow-credentials', 'true');
    }

    if (settings._exposedHeaders) {
        response._header('access-control-expose-headers', settings._exposedHeaders);
    }

    return response;
};


exports.headers = function (request) {

    const settings = request.route.settings.cors;
    const response = request.response;

    if (settings._origin !== false) {
        response.vary('origin');
    }

    if ((request.info.cors && !request.info.cors.isOriginMatch) ||                          // After route lookup
        !exports.matchOrigin(request.headers.origin, request.route.settings.cors)) {        // Response from onRequest

        return;
    }

    response._header('access-control-allow-origin', settings._origin ? request.headers.origin : '*');

    if (settings.credentials) {
        response._header('access-control-allow-credentials', 'true');
    }

    if (settings._exposedHeaders) {
        response._header('access-control-expose-headers', settings._exposedHeaders, { append: true });
    }
};


exports.matchOrigin = function (origin, settings) {

    if (settings._origin === true ||
        settings._origin === false) {

        return true;
    }

    if (!origin) {
        return false;
    }

    if (settings._origin.qualified.indexOf(origin) !== -1) {
        return true;
    }

    for (const wildcard of settings._origin.wildcards) {
        if (origin.match(wildcard)) {
            return true;
        }
    }

    return false;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/ext.js":
/*!********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/ext.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./node_modules/@hapi/topo/lib/index.js");


const internals = {};


exports = module.exports = internals.Ext = class {

    constructor(type, core) {

        this._topo = new Topo();
        this._core = core;
        this._routes = [];

        this.type = type;
        this.nodes = null;
    }

    add(event) {

        const methods = [].concat(event.method);
        for (const method of methods) {
            const settings = {
                before: event.options.before,
                after: event.options.after,
                group: event.realm.plugin,
                sort: this._core.extensionsSeq++
            };

            const node = {
                func: method,                       // Request: function (request, h), Server: function (server)
                bind: event.options.bind,
                server: event.server,               // Server event
                realm: event.realm,
                timeout: event.options.timeout
            };

            this._topo.add(node, settings);
        }

        this.nodes = this._topo.nodes;

        // Notify routes

        for (const route of this._routes) {
            route.rebuild(event);
        }
    }

    merge(others) {

        const merge = [];
        for (const other of others) {
            merge.push(other._topo);
        }

        this._topo.merge(merge);
        this.nodes = (this._topo.nodes.length ? this._topo.nodes : null);
    }

    subscribe(route) {

        this._routes.push(route);
    }

    static combine(route, type) {

        const ext = new internals.Ext(type, route._core);

        const events = route.settings.ext[type];
        if (events) {
            for (let event of events) {
                event = Object.assign({}, event);       // Shallow cloned
                Hoek.assert(!event.options.sandbox, 'Cannot specify sandbox option for route extension');
                event.realm = route.realm;
                ext.add(event);
            }
        }

        const server = route._core.extensions.route[type];
        const realm = route.realm._extensions[type];

        ext.merge([server, realm]);

        server.subscribe(route);
        realm.subscribe(route);

        return ext;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/handler.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/handler.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports.execute = async function (request) {

    // Prerequisites

    if (request._route._prerequisites) {
        for (const set of request._route._prerequisites) {      // Serial execution of each set
            const pres = [];
            for (const item of set) {
                pres.push(internals.handler(request, item.method, item));
            }

            const responses = await Promise.all(pres);                          // Parallel execution within sets
            for (const response of responses) {
                if (response !== undefined) {
                    return response;
                }
            }
        }
    }

    // Handler

    const result = await internals.handler(request, request.route.settings.handler);
    if (result._takeover ||
        typeof result === 'symbol') {

        return result;
    }

    request._setResponse(result);
};


internals.handler = async function (request, method, pre) {

    const bind = request.route.settings.bind;
    const realm = request.route.realm;
    let response = await request._core.toolkit.execute(method, request, { bind, realm, continue: 'null' });

    // Handler

    if (!pre) {
        if (response.isBoom) {
            request._log(['handler', 'error'], response);
            throw response;
        }

        return response;
    }

    // Pre

    if (response.isBoom) {
        response.assign = pre.assign;
        response = await request._core.toolkit.failAction(request, pre.failAction, response, { tags: ['pre', 'error'], retain: true });
    }

    if (typeof response === 'symbol') {
        return response;
    }

    if (pre.assign) {
        request.pre[pre.assign] = (response.isBoom ? response : response.source);
        request.preResponses[pre.assign] = response;
    }

    if (response._takeover) {
        return response;
    }
};


exports.defaults = function (method, handler, core) {

    let defaults = null;

    if (typeof handler === 'object') {
        const type = Object.keys(handler)[0];
        const serverHandler = core._decorations.handler[type];

        Hoek.assert(serverHandler, 'Unknown handler:', type);

        if (serverHandler.defaults) {
            defaults = (typeof serverHandler.defaults === 'function' ? serverHandler.defaults(method) : serverHandler.defaults);
        }
    }

    return defaults || {};
};


exports.configure = function (handler, route) {

    if (typeof handler === 'object') {
        const type = Object.keys(handler)[0];
        const serverHandler = route._core._decorations.handler[type];

        Hoek.assert(serverHandler, 'Unknown handler:', type);

        return serverHandler(route.public, handler[type]);
    }

    return handler;
};


exports.prerequisitesConfig = function (config) {

    if (!config) {
        return null;
    }

    /*
        [
            [
                function (request, h) { },
                {
                    method: function (request, h) { }
                    assign: key1
                },
                {
                    method: function (request, h) { },
                    assign: key2
                }
            ],
            {
                method: function (request, h) { },
                assign: key3
            }
        ]
    */

    const prerequisites = [];

    for (let pres of config) {
        pres = [].concat(pres);

        const set = [];
        for (let pre of pres) {
            if (typeof pre !== 'object') {
                pre = { method: pre };
            }

            const item = {
                method: pre.method,
                assign: pre.assign,
                failAction: pre.failAction || 'error'
            };

            set.push(item);
        }

        prerequisites.push(set);
    }

    return prerequisites.length ? prerequisites : null;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/headers.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/headers.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



const Stream = __webpack_require__(/*! stream */ "stream");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");

const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");


const internals = {};


exports.cache = function (request) {

    const response = request.response;
    if (response.headers['cache-control']) {
        return;
    }

    const settings = request.route.settings.cache;
    const policy = settings && request._route._cache && (settings._statuses.has(response.statusCode) || (response.statusCode === 304 && settings._statuses.has(200)));

    if (policy ||
        response.settings.ttl) {

        const ttl = (response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl());
        const privacy = (request.auth.isAuthenticated || response.headers['set-cookie'] ? 'private' : settings.privacy || 'default');
        response._header('cache-control', 'max-age=' + Math.floor(ttl / 1000) + ', must-revalidate' + (privacy !== 'default' ? ', ' + privacy : ''));
    }
    else if (settings) {
        response._header('cache-control', settings.otherwise);
    }
};


exports.content = async function (request) {

    const response = request.response;
    if (response._isPayloadSupported() ||
        request.method === 'head') {

        await response._marshal();

        if (request.jsonp &&
            response._payload.jsonp) {

            response._header('content-type', 'text/javascript' + (response.settings.charset ? '; charset=' + response.settings.charset : ''));
            response._header('x-content-type-options', 'nosniff');
            response._payload.jsonp(request.jsonp);
        }

        if (response._payload.size &&
            typeof response._payload.size === 'function') {

            response._header('content-length', response._payload.size(), { override: false });
        }

        if (!response._isPayloadSupported()) {
            response._close(request);                       // Close unused file streams
            response._payload = new internals.Empty();      // Set empty stream
        }

        exports.type(request, true);
    }
    else {

        // Set empty stream

        response._close(request);                           // Close unused file streams
        response._payload = new internals.Empty();
        delete response.headers['content-length'];
    }
};


exports.state = async function (request) {

    const response = request.response;
    const states = [];

    for (const stateName in request._states) {
        states.push(request._states[stateName]);
    }

    try {
        for (const name in request._core.states.cookies) {
            const autoValue = request._core.states.cookies[name].autoValue;
            if (!autoValue || name in request._states || name in request.state) {
                continue;
            }

            if (typeof autoValue !== 'function') {
                states.push({ name, value: autoValue });
                continue;
            }

            const value = await autoValue(request);
            states.push({ name, value });
        }

        if (!states.length) {
            return;
        }

        let header = await request._core.states.format(states);
        const existing = response.headers['set-cookie'];
        if (existing) {
            header = (Array.isArray(existing) ? existing : [existing]).concat(header);
        }

        response._header('set-cookie', header);
    }
    catch (err) {
        const error = Boom.boomify(err);
        request._log(['state', 'response', 'error'], error);
        request._states = {};                                           // Clear broken state
        throw error;
    }
};


exports.type = function (request, postMarshal) {

    const response = request.response;
    let type = response.headers['content-type'];
    if (!type) {
        if (response._contentType) {
            const charset = (response.settings.charset && response._contentType !== 'application/octet-stream' ? '; charset=' + response.settings.charset : '');
            response.type(response._contentType + charset);
        }
    }
    else {
        type = type.trim();
        if ((!response._contentType || !postMarshal) &&
            response.settings.charset &&
            type.match(/^(?:text\/)|(?:application\/(?:json)|(?:javascript))/)) {

            if (!type.match(/; *charset=/)) {
                const semi = (type[type.length - 1] === ';');
                response.type(type + (semi ? ' ' : '; ') + 'charset=' + (response.settings.charset));
            }
        }
    }
};


exports.entity = function (request) {

    if (!request._entity) {
        return;
    }

    const response = request.response;

    if (request._entity.etag &&
        !response.headers.etag) {

        response.etag(request._entity.etag, { vary: request._entity.vary });
    }

    if (request._entity.modified &&
        !response.headers['last-modified']) {

        response.header('last-modified', request._entity.modified);
    }
};


exports.unmodified = function (request) {

    const response = request.response;
    if (response.statusCode === 304) {
        return;
    }

    const entity = {
        etag: response.headers.etag,
        vary: response.settings.varyEtag,
        modified: response.headers['last-modified']
    };

    const etag = Response.unmodified(request, entity);
    if (etag) {
        response.code(304);

        if (etag !== true) {                                // Override etag with incoming weak match
            response.headers.etag = etag;
        }
    }
};


internals.Empty = class extends Stream.Readable {

    _read(/* size */) {

        this.push(null);
    }

    writeToStream(stream) {

        stream.end();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Server = __webpack_require__(/*! ./server */ "./node_modules/@hapi/hapi/lib/server.js");


const internals = {};


exports.Server = Server;

exports.server = Server;


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/methods.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/methods.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");


const internals = {
    methodNameRx: /^[_$a-zA-Z][$\w]*(?:\.[_$a-zA-Z][$\w]*)*$/
};


exports = module.exports = internals.Methods = class {

    constructor(core) {

        this.core = core;
        this.methods = {};
    }

    add(name, method, options, realm) {

        if (typeof name !== 'object') {
            return this._add(name, method, options, realm);
        }

        // {} or [{}, {}]

        const items = [].concat(name);
        for (let item of items) {
            item = Config.apply('methodObject', item);
            this._add(item.name, item.method, item.options || {}, realm);
        }
    }

    _add(name, method, options, realm) {

        Hoek.assert(typeof method === 'function', 'method must be a function');
        Hoek.assert(typeof name === 'string', 'name must be a string');
        Hoek.assert(name.match(internals.methodNameRx), 'Invalid name:', name);
        Hoek.assert(!Hoek.reach(this.methods, name, { functions: false }), 'Server method function name already exists:', name);

        options = Config.apply('method', options, name);

        const settings = Hoek.clone(options, { shallow: ['bind'] });
        settings.generateKey = settings.generateKey || internals.generateKey;

        const bind = settings.bind || realm.settings.bind || null;
        const bound = !bind ? method : (...args) => method.apply(bind, args);

        // Not cached

        if (!settings.cache) {
            return this._assign(name, bound);
        }

        // Cached

        Hoek.assert(!settings.cache.generateFunc, 'Cannot set generateFunc with method caching:', name);
        Hoek.assert(settings.cache.generateTimeout !== undefined, 'Method caching requires a timeout value in generateTimeout:', name);

        settings.cache.generateFunc = (id, flags) => bound(...id.args, flags);
        const cache = this.core._cachePolicy(settings.cache, '#' + name);

        const func = function (...args) {

            const key = settings.generateKey.apply(bind, args);
            if (typeof key !== 'string') {
                return Promise.reject(Boom.badImplementation('Invalid method key when invoking: ' + name, { name, args }));
            }

            return cache.get({ id: key, args });
        };

        func.cache = {
            drop: function (...args) {

                const key = settings.generateKey.apply(bind, args);
                if (typeof key !== 'string') {
                    return Promise.reject(Boom.badImplementation('Invalid method key when invoking: ' + name, { name, args }));
                }

                return cache.drop(key);
            },
            stats: cache.stats
        };

        this._assign(name, func, func);
    }

    _assign(name, method) {

        const path = name.split('.');
        let ref = this.methods;
        for (let i = 0; i < path.length; ++i) {
            if (!ref[path[i]]) {
                ref[path[i]] = (i + 1 === path.length ? method : {});
            }

            ref = ref[path[i]];
        }
    }
};


internals.supportedArgs = ['string', 'number', 'boolean'];


internals.generateKey = function (...args) {

    let key = '';
    for (let i = 0; i < args.length; ++i) {
        const arg = args[i];
        if (!internals.supportedArgs.includes(typeof arg)) {
            return null;
        }

        key = key + (i ? ':' : '') + encodeURIComponent(arg.toString());
    }

    return key;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/request.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/request.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Url = __webpack_require__(/*! url */ "url");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");

const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");
const Transmit = __webpack_require__(/*! ./transmit */ "./node_modules/@hapi/hapi/lib/transmit.js");


const internals = {
    events: Podium.validate(['finish', { name: 'peek', spread: true }, 'disconnect']),
    reserved: ['server', 'url', 'query', 'path', 'method', 'mime', 'setUrl', 'setMethod', 'headers', 'id', 'app', 'plugins', 'route', 'auth', 'pre', 'preResponses', 'info', 'orig', 'params', 'paramsArray', 'payload', 'state', 'jsonp', 'response', 'raw', 'domain', 'log', 'logs', 'generateResponse']
};


exports = module.exports = internals.Request = class {

    constructor(server, req, res, options) {

        this._allowInternals = !!options.allowInternals;
        this._core = server._core;
        this._entity = null;                                                                                // Entity information set via h.entity()
        this._eventContext = { request: this };
        this._events = null;                                                                                // Assigned an emitter when request.events is accessed
        this._expectContinue = !!options.expectContinue;
        this._isPayloadPending = !!(req.headers['content-length'] || req.headers['transfer-encoding']);     // Changes to false when incoming payload fully processed
        this._isReplied = false;                                                                            // true when response processing started
        this._route = this._core.router.specials.notFound.route;                                            // Used prior to routing (only settings are used, not the handler)
        this._serverTimeoutId = null;
        this._states = {};
        this._urlError = null;

        this.app = options.app ? Object.assign({}, options.app) : {};                                       // Place for application-specific state without conflicts with hapi, should not be used by plugins (shallow cloned)
        this.headers = req.headers;
        this.info = internals.info(this._core, req);
        this.jsonp = null;
        this.logs = [];
        this.method = req.method.toLowerCase();
        this.mime = null;
        this.orig = {};
        this.params = null;
        this.paramsArray = null;                                                                            // Array of path parameters in path order
        this.path = null;
        this.payload = null;
        this.plugins = options.plugins ? Object.assign({}, options.plugins) : {};                           // Place for plugins to store state without conflicts with hapi, should be namespaced using plugin name (shallow cloned)
        this.pre = {};                                                                                      // Pre raw values
        this.preResponses = {};                                                                             // Pre response values
        this.raw = { req, res };
        this.response = null;
        this.route = this._route.public;
        this.query = null;
        this.server = server;
        this.state = null;
        this.url = null;

        this.auth = {
            isAuthenticated: false,
            isAuthorized: false,
            credentials: options.auth ? options.auth.credentials : null,                                    // Special keys: 'app', 'user', 'scope'
            artifacts: options.auth && options.auth.artifacts || null,                                      // Scheme-specific artifacts
            strategy: options.auth ? options.auth.strategy : null,
            mode: null,
            error: null
        };

        if (options.auth) {
            this.auth.isInjected = true;
        }

        // Parse request url

        this._initializeUrl();
    }

    static generate(server, req, res, options) {

        const request = new server._core.Request(server, req, res, options);

        // Decorate

        if (server._core._decorations.requestApply) {
            for (const property in server._core._decorations.requestApply) {
                const assignment = server._core._decorations.requestApply[property];
                request[property] = assignment(request);
            }
        }

        request._listen();
        return request;
    }

    get events() {

        if (!this._events) {
            this._events = new Podium(internals.events);
        }

        return this._events;
    }

    _initializeUrl() {

        try {
            this._setUrl(this.raw.req.url, this._core.settings.router.stripTrailingSlash);
        }
        catch (err) {
            this.path = this.raw.req.url;
            this.query = {};

            this._urlError = Boom.boomify(err, { statusCode: 400, override: false });
        }
    }

    setUrl(url, stripTrailingSlash) {

        Hoek.assert(this.params === null, 'Cannot change request URL after routing');

        if (url instanceof Url.URL) {
            url = url.href;
        }

        Hoek.assert(typeof url === 'string', 'Url must be a string or URL object');

        this._setUrl(url, stripTrailingSlash);
        this._urlError = null;
    }

    _setUrl(url, stripTrailingSlash) {

        const base = url[0] === '/' ? `${this._core.info.protocol}://${this.info.host || `${this._core.info.host}:${this._core.info.port}`}` : '';

        url = new Url.URL(base + url);

        // Apply path modifications

        let path = this._core.router.normalize(url.pathname);        // pathname excludes query

        if (stripTrailingSlash &&
            path.length > 1 &&
            path[path.length - 1] === '/') {

            path = path.slice(0, -1);
        }

        url.pathname = path;

        // Parse query (must be done before this.url is set in case query parsing throws)

        this.query = this._parseQuery(url.searchParams);

        // Store request properties

        this.url = url;
        this.path = path;

        this.info.hostname = url.hostname;
        this.info.host = url.host;
    }

    _parseQuery(searchParams) {

        // Flatten map

        let query = Object.create(null);
        for (let [key, value] of searchParams) {
            const entry = query[key];
            if (entry !== undefined) {
                value = [].concat(entry, value);
            }

            query[key] = value;
        }

        // Custom parser

        const parser = this._core.settings.query.parser;
        if (parser) {
            query = parser(query);
            if (!query ||
                typeof query !== 'object') {

                throw Boom.badImplementation('Parsed query must be an object');
            }
        }

        return query;
    }

    setMethod(method) {

        Hoek.assert(this.params === null, 'Cannot change request method after routing');
        Hoek.assert(method && typeof method === 'string', 'Missing method');

        this.method = method.toLowerCase();
    }

    active() {

        return !!this._eventContext.request;
    }

    async _execute() {

        this.info.acceptEncoding = this._core.compression.accept(this);

        try {
            await this._onRequest();
        }
        catch (err) {
            Bounce.rethrow(err, 'system');
            return this._reply(err);
        }

        this._lookup();
        this._setTimeouts();
        await this._lifecycle();
        this._reply();
    }

    async _onRequest() {

        // onRequest (can change request method and url)

        if (this._core.extensions.route.onRequest.nodes) {
            const response = await this._invoke(this._core.extensions.route.onRequest);
            if (response) {
                if (!internals.skip(response)) {
                    throw Boom.badImplementation('onRequest extension methods must return an error, a takeover response, or a continue signal');
                }

                throw response;
            }
        }

        // Validate path

        if (this._urlError) {
            throw this._urlError;
        }
    }

    _listen() {

        if (this._isPayloadPending) {
            this.raw.req.on('end', internals.event.bind(this.raw.req, this._eventContext, 'end'));
        }

        this.raw.req.on('close', internals.event.bind(this.raw.req, this._eventContext, 'close'));
        this.raw.req.on('error', internals.event.bind(this.raw.req, this._eventContext, 'error'));
        this.raw.req.on('aborted', internals.event.bind(this.raw.req, this._eventContext, 'abort'));
    }

    _lookup() {

        const match = this._core.router.route(this.method, this.path, this.info.hostname);
        if (!match.route.settings.isInternal ||
            this._allowInternals) {

            this._route = match.route;
            this.route = this._route.public;
        }

        this.params = match.params || {};
        this.paramsArray = match.paramsArray || [];

        if (this.route.settings.cors) {
            this.info.cors = {
                isOriginMatch: Cors.matchOrigin(this.headers.origin, this.route.settings.cors)
            };
        }
    }

    _setTimeouts() {

        if (this.raw.req.socket &&
            this.route.settings.timeout.socket !== undefined) {

            this.raw.req.socket.setTimeout(this.route.settings.timeout.socket || 0);    // Value can be false or positive
        }

        let serverTimeout = this.route.settings.timeout.server;
        if (!serverTimeout) {
            return;
        }

        const elapsed = Date.now() - this.info.received;
        serverTimeout = Math.floor(serverTimeout - elapsed);            // Calculate the timeout from when the request was constructed

        if (serverTimeout <= 0) {
            internals.timeoutReply(this, serverTimeout);
            return;
        }

        this._serverTimeoutId = setTimeout(internals.timeoutReply, serverTimeout, this, serverTimeout);
    }

    async _lifecycle() {

        for (const func of this._route._cycle) {
            if (this._isReplied ||
                !this._eventContext.request) {

                return;
            }

            try {
                var response = await (typeof func === 'function' ? func(this) : this._invoke(func));
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                response = Response.wrap(err, this);
            }

            if (!response ||
                response === this._core.toolkit.continue) {                     // Continue

                continue;
            }

            if (!internals.skip(response)) {
                response = Boom.badImplementation('Lifecycle methods called before the handler can only return an error, a takeover response, or a continue signal');
            }

            this._setResponse(response);
            return;
        }
    }

    async _invoke(event) {

        for (const ext of event.nodes) {
            const realm = ext.realm;
            const bind = ext.bind || realm.settings.bind;
            const response = await this._core.toolkit.execute(ext.func, this, { bind, realm, timeout: ext.timeout, name: event.type });

            if (response === this._core.toolkit.continue) {
                continue;
            }

            if (internals.skip(response) ||
                this.response === null) {

                return response;
            }

            this._setResponse(response);
        }
    }

    async _reply(exit) {

        if (this._isReplied) {                                          // Prevent any future responses to this request
            return;
        }

        this._isReplied = true;

        if (this._serverTimeoutId) {
            clearTimeout(this._serverTimeoutId);
        }

        if (!this._eventContext.request) {
            this._finalize();
            return;
        }

        if (exit) {                                                     // Can be a valid response or error (if returned from an ext, already handled because this.response is also set)
            this._setResponse(Response.wrap(exit, this));               // Wrap to ensure any object thrown is always a valid Boom or Response object
        }

        if (typeof this.response === 'symbol') {                        // close or abandon
            this._abort();
            return;
        }

        await this._postCycle();

        if (!this._eventContext.request ||
            typeof this.response === 'symbol') {                        // close or abandon

            this._abort();
            return;
        }

        await Transmit.send(this);
        this._finalize();
    }

    async _postCycle() {

        for (const func of this._route._postCycle) {
            if (!this._eventContext.request) {
                return;
            }

            try {
                var response = await (typeof func === 'function' ? func(this) : this._invoke(func));
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                response = Response.wrap(err, this);
            }

            if (response &&
                response !== this._core.toolkit.continue) {                     // Continue

                this._setResponse(response);
            }
        }
    }

    _abort() {

        if (this.response === this._core.toolkit.close) {
            this.raw.res.end();                                     // End the response in case it wasn't already closed
        }

        this._finalize();
    }

    _finalize() {

        if (this.response &&
            this.response.statusCode === 500 &&
            this.response._error) {

            const tags = this.response._error.isDeveloperError ? ['internal', 'implementation', 'error'] : ['internal', 'error'];
            this._log(tags, this.response._error, 'error');
        }

        // Cleanup

        this._eventContext.request = null;              // Disable req events

        if (this.response &&
            this.response._close) {

            this.response._close(this);
        }

        this.info.completed = Date.now();
        this._core.events.emit('response', this);
        this._core.queue.release();
    }

    _setResponse(response) {

        if (this.response &&
            !this.response.isBoom &&
            this.response !== response &&
            (response.isBoom || this.response.source !== response.source)) {

            this.response._close(this);
        }

        if (this.info.completed) {
            if (response._close) {
                response._close(this);
            }

            return;
        }

        this.response = response;
    }

    _setState(name, value, options) {

        const state = { name, value };
        if (options) {
            Hoek.assert(!options.autoValue, 'Cannot set autoValue directly in a response');
            state.options = Hoek.clone(options);
        }

        this._states[name] = state;
    }

    _clearState(name, options = {}) {

        const state = { name };

        state.options = Hoek.clone(options);
        state.options.ttl = 0;

        this._states[name] = state;
    }

    _tap() {

        if (!this._events) {
            return null;
        }

        if (this._events.hasListeners('peek') ||
            this._events.hasListeners('finish')) {

            return new Response.Peek(this._events);
        }

        return null;
    }

    log(tags, data) {

        return this._log(tags, data, 'app');
    }

    _log(tags, data, channel = 'internal') {

        if (!this._core.events.hasListeners('request') &&
            !this.route.settings.log.collect) {

            return;
        }

        if (!Array.isArray(tags)) {
            tags = [tags];
        }

        const timestamp = Date.now();
        const field = data instanceof Error ? 'error' : 'data';

        let event = [this, { request: this.info.id, timestamp, tags, [field]: data, channel }];
        if (typeof data === 'function') {
            event = () => [this, { request: this.info.id, timestamp, tags, data: data(), channel }];
        }

        if (this.route.settings.log.collect) {
            if (typeof data === 'function') {
                event = event();
            }

            this.logs.push(event[1]);
        }

        this._core.events.emit({ name: 'request', channel, tags }, event);
    }

    generateResponse(source, options) {

        return new Response(source, this, options);
    }
};


internals.Request.reserved = internals.reserved;


internals.info = function (core, req) {

    const host = req.headers.host ? req.headers.host.trim() : '';
    const received = Date.now();

    const info = {
        received,
        remoteAddress: req.connection.remoteAddress,
        remotePort: req.connection.remotePort || '',
        referrer: req.headers.referrer || req.headers.referer || '',
        host,
        hostname: host.split(':')[0],
        id: `${received}:${core.info.id}:${core.requestCounter.value++}`,

        // Assigned later

        acceptEncoding: null,
        cors: null,
        responded: 0,
        completed: 0
    };

    if (core.requestCounter.value > core.requestCounter.max) {
        core.requestCounter.value = core.requestCounter.min;
    }

    return info;
};


internals.event = function ({ request }, event, err) {

    if (!request) {
        return;
    }

    request._isPayloadPending = false;

    if (event === 'close' &&
        request.raw.res.finished) {

        return;
    }

    if (event === 'end') {
        return;
    }

    request._log(err ? ['request', 'error'] : ['request', 'error', event], err);

    if (event === 'error') {
        return;
    }

    request._eventContext.request = null;

    if (event === 'abort' &&
        request._events) {

        request._events.emit('disconnect');
    }
};


internals.timeoutReply = function (request, timeout) {

    const elapsed = Date.now() - request.info.received;
    request._log(['request', 'server', 'timeout', 'error'], { timeout, elapsed });
    request._reply(Boom.serverUnavailable());
};


internals.skip = function (response) {

    return response.isBoom || response._takeover || typeof response === 'symbol';
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/response.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/response.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");

const Streams = __webpack_require__(/*! ./streams */ "./node_modules/@hapi/hapi/lib/streams.js");


const internals = {
    events: Podium.validate(['finish', { name: 'peek', spread: true }]),
    hopByHop: {
        connection: true,
        'keep-alive': true,
        'proxy-authenticate': true,
        'proxy-authorization': true,
        'te': true,
        'trailer': true,
        'transfer-encoding': true,
        'upgrade': true
    }
};


exports = module.exports = internals.Response = class {

    constructor(source, request, options = {}) {

        this.app = {};
        this.headers = {};                          // Incomplete as some headers are stored in flags
        this.plugins = {};
        this.request = request;
        this.source = null;
        this.statusCode = null;
        this.variety = null;

        this.settings = {
            charset: 'utf-8',                       // '-' required by IANA
            compressed: null,
            encoding: 'utf8',
            message: null,
            passThrough: true,
            stringify: null,                        // JSON.stringify options
            ttl: null,
            varyEtag: false
        };

        this._events = null;
        this._payload = null;                       // Readable stream
        this._error = null;                         // The boom object when created from an error (used for logging)
        this._contentType = null;                   // Used if no explicit content-type is set and type is known
        this._takeover = false;
        this._statusCode = false;                   // true when code() called

        this._processors = {
            marshal: options.marshal,
            prepare: options.prepare,
            close: options.close
        };

        this.temporary = null;
        this.permanent = null;
        this.rewritable = null;

        this._setSource(source, options.variety);
    }

    static wrap(result, request) {

        if (result instanceof internals.Response ||
            typeof result === 'symbol') {

            return result;
        }

        if (result instanceof Error) {
            return Boom.boomify(result);
        }

        return new internals.Response(result, request);
    }

    _setSource(source, variety) {

        // Method must not set any headers or other properties as source can change later

        this.variety = variety || 'plain';

        if (source === null ||
            source === undefined) {

            source = null;
        }
        else if (Buffer.isBuffer(source)) {
            this.variety = 'buffer';
            this._contentType = 'application/octet-stream';
        }
        else if (Streams.isStream(source)) {
            this.variety = 'stream';
            this._contentType = 'application/octet-stream';
        }

        this.source = source;

        if (this.variety === 'plain' &&
            this.source !== null) {

            this._contentType = (typeof this.source === 'string' ? 'text/html' : 'application/json');
        }
    }

    get events() {

        if (!this._events) {
            this._events = new Podium(internals.events);
        }

        return this._events;
    }

    code(statusCode) {

        Hoek.assert(Number.isSafeInteger(statusCode), 'Status code must be an integer');

        this.statusCode = statusCode;
        this._statusCode = true;

        return this;
    }

    message(httpMessage) {

        this.settings.message = httpMessage;
        return this;
    }

    header(key, value, options) {

        key = key.toLowerCase();
        if (key === 'vary') {
            return this.vary(value);
        }

        return this._header(key, value, options);
    }

    _header(key, value, options = {}) {

        const append = options.append || false;
        const separator = options.separator || ',';
        const override = options.override !== false;
        const duplicate = options.duplicate !== false;

        if (!append && override ||
            !this.headers[key]) {

            this.headers[key] = value;
        }
        else if (override) {
            if (key === 'set-cookie') {
                this.headers[key] = [].concat(this.headers[key], value);
            }
            else {
                const existing = this.headers[key];
                if (!duplicate) {
                    const values = existing.split(separator);
                    for (const v of values) {
                        if (v === value) {
                            return this;
                        }
                    }
                }

                this.headers[key] = existing + separator + value;
            }
        }

        return this;
    }

    vary(value) {

        if (value === '*') {
            this.headers.vary = '*';
        }
        else if (!this.headers.vary) {
            this.headers.vary = value;
        }
        else if (this.headers.vary !== '*') {
            this._header('vary', value, { append: true, duplicate: false });
        }

        return this;
    }

    etag(tag, options) {

        const entity = internals.Response.entity(tag, options);
        this._header('etag', entity.etag);
        this.settings.varyEtag = entity.vary;
        return this;
    }

    static entity(tag, options = {}) {

        Hoek.assert(tag !== '*', 'ETag cannot be *');

        return {
            etag: (options.weak ? 'W/' : '') + '"' + tag + '"',
            vary: options.vary !== false && !options.weak,                      // vary defaults to true
            modified: options.modified
        };
    }

    static unmodified(request, entity) {

        if (request.method !== 'get' &&
            request.method !== 'head') {

            return false;
        }

        // Strong verifier

        if (entity.etag &&
            request.headers['if-none-match']) {

            const ifNoneMatch = request.headers['if-none-match'].split(/\s*,\s*/);
            for (const etag of ifNoneMatch) {

                // Compare tags (https://tools.ietf.org/html/rfc7232#section-2.3.2)

                if (etag === entity.etag) {             // Strong comparison
                    return true;
                }

                if (!entity.vary) {
                    continue;
                }

                if (etag === `W/${entity.etag}`) {      // Weak comparison
                    return etag;
                }

                const etagBase = entity.etag.slice(0, -1);
                const encoders = request._core.compression.encodings;
                for (const encoder of encoders) {
                    if (etag === etagBase + `-${encoder}"`) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Weak verifier

        if (!entity.modified) {
            return false;
        }

        const ifModifiedSinceHeader = request.headers['if-modified-since'];
        if (!ifModifiedSinceHeader) {
            return false;
        }

        const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
        if (!ifModifiedSince) {
            return false;
        }

        const lastModified = internals.parseDate(entity.modified);
        if (!lastModified) {
            return false;
        }

        return ifModifiedSince >= lastModified;
    }

    type(type) {

        this._header('content-type', type);
        return this;
    }

    bytes(bytes) {

        this._header('content-length', bytes);
        return this;
    }

    location(uri) {

        this._header('location', uri);
        return this;
    }

    created(location) {

        Hoek.assert(this.request.method === 'post' ||
            this.request.method === 'put' ||
            this.request.method === 'patch', 'Cannot return 201 status codes for ' + this.request.method.toUpperCase());

        this.statusCode = 201;
        this.location(location);
        return this;
    }

    compressed(encoding) {

        Hoek.assert(encoding && typeof encoding === 'string', 'Invalid content-encoding');
        this.settings.compressed = encoding;
        return this;
    }

    replacer(method) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.replacer = method;
        return this;
    }

    spaces(count) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.space = count;
        return this;
    }

    suffix(suffix) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.suffix = suffix;
        return this;
    }

    escape(escape) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.escape = escape;
        return this;
    }

    passThrough(enabled) {

        this.settings.passThrough = enabled !== false;      // Defaults to true
        return this;
    }

    redirect(location) {

        this.statusCode = 302;
        this.location(location);
        this.temporary = this._temporary;
        this.permanent = this._permanent;
        this.rewritable = this._rewritable;
        return this;
    }

    _temporary(isTemporary) {

        this._setTemporary(isTemporary !== false);           // Defaults to true
        return this;
    }

    _permanent(isPermanent) {

        this._setTemporary(isPermanent === false);           // Defaults to true
        return this;
    }

    _rewritable(isRewritable) {

        this._setRewritable(isRewritable !== false);         // Defaults to true
        return this;
    }

    _isTemporary() {

        return this.statusCode === 302 || this.statusCode === 307;
    }

    _isRewritable() {

        return this.statusCode === 301 || this.statusCode === 302;
    }

    _setTemporary(isTemporary) {

        if (isTemporary) {
            if (this._isRewritable()) {
                this.statusCode = 302;
            }
            else {
                this.statusCode = 307;
            }
        }
        else {
            if (this._isRewritable()) {
                this.statusCode = 301;
            }
            else {
                this.statusCode = 308;
            }
        }
    }

    _setRewritable(isRewritable) {

        if (isRewritable) {
            if (this._isTemporary()) {
                this.statusCode = 302;
            }
            else {
                this.statusCode = 301;
            }
        }
        else {
            if (this._isTemporary()) {
                this.statusCode = 307;
            }
            else {
                this.statusCode = 308;
            }
        }
    }

    encoding(encoding) {

        this.settings.encoding = encoding;
        return this;
    }

    charset(charset) {

        this.settings.charset = charset || null;
        return this;
    }

    ttl(ttl) {

        this.settings.ttl = ttl;
        return this;
    }

    state(name, value, options) {

        this.request._setState(name, value, options);
        return this;
    }

    unstate(name, options) {

        this.request._clearState(name, options);
        return this;
    }

    takeover() {

        this._takeover = true;
        return this;
    }

    _prepare() {

        this._passThrough();

        if (!this._processors.prepare) {
            return this;
        }

        try {
            return this._processors.prepare(this);
        }
        catch (err) {
            throw Boom.boomify(err);
        }
    }

    _passThrough() {

        if (this.variety === 'stream' &&
            this.settings.passThrough) {

            if (this.source.statusCode &&
                !this.statusCode) {

                this.statusCode = this.source.statusCode;                        // Stream is an HTTP response
            }

            if (this.source.headers) {
                let headerKeys = Object.keys(this.source.headers);

                if (headerKeys.length) {
                    const localHeaders = this.headers;
                    this.headers = {};

                    const connection = this.source.headers.connection;
                    const byHop = {};
                    if (connection) {
                        connection.split(/\s*,\s*/).forEach((header) => {

                            byHop[header] = true;
                        });
                    }

                    for (const key of headerKeys) {
                        const lower = key.toLowerCase();
                        if (!internals.hopByHop[lower] &&
                            !byHop[lower]) {

                            this.header(lower, Hoek.clone(this.source.headers[key]));     // Clone arrays
                        }
                    }

                    headerKeys = Object.keys(localHeaders);
                    for (const key of headerKeys) {
                        this.header(key, localHeaders[key], { append: key === 'set-cookie' });
                    }
                }
            }
        }

        this.statusCode = this.statusCode || 200;
    }

    async _marshal() {

        let source = this.source;

        // Processor marshal

        if (this._processors.marshal) {
            try {
                source = await this._processors.marshal(this);
            }
            catch (err) {
                throw Boom.boomify(err);
            }
        }

        // Stream source

        if (Streams.isStream(source)) {
            if (typeof source._read !== 'function') {
                throw Boom.badImplementation('Stream must have a readable interface');
            }

            if (source._readableState.objectMode) {
                throw Boom.badImplementation('Cannot reply with stream in object mode');
            }

            this._payload = source;
            return;
        }

        // Plain source (non string or null)

        const jsonify = this.variety === 'plain' && source !== null && typeof source !== 'string';

        if (!jsonify &&
            this.settings.stringify) {

            throw Boom.badImplementation('Cannot set formatting options on non object response');
        }

        let payload = source;

        if (jsonify) {
            const options = this.settings.stringify || {};
            const space = options.space || this.request.route.settings.json.space;
            const replacer = options.replacer || this.request.route.settings.json.replacer;
            const suffix = options.suffix || this.request.route.settings.json.suffix || '';
            const escape = this.request.route.settings.json.escape || false;

            try {
                if (replacer || space) {
                    payload = JSON.stringify(payload, replacer, space);
                }
                else {
                    payload = JSON.stringify(payload);
                }
            }
            catch (err) {
                throw Boom.boomify(err);
            }

            if (suffix) {
                payload = payload + suffix;
            }

            if (escape) {
                payload = Hoek.escapeJson(payload);
            }
        }

        this._payload = new internals.Response.Payload(payload, this.settings);
    }

    _tap() {

        if (!this._events) {
            return null;
        }

        if (this._events.hasListeners('peek') ||
            this._events.hasListeners('finish')) {

            return new internals.Response.Peek(this._events);
        }

        return null;
    }

    _close(request) {

        if (this._processors.close) {
            try {
                this._processors.close(this);
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                request._log(['response', 'cleanup', 'error'], err);
            }
        }

        const stream = this._payload || this.source;
        if (Streams.isStream(stream)) {
            internals.Response.drain(stream);
        }
    }

    _isPayloadSupported() {

        return this.request.method !== 'head' && this.statusCode !== 304 && this.statusCode !== 204;
    }

    static drain(stream) {

        if (stream.unpipe) {
            stream.unpipe();
        }

        if (stream.close) {
            stream.close();
        }
        else if (stream.destroy) {
            stream.destroy();
        }
        else {
            Streams.drain(stream);
        }
    }
};


internals.parseDate = function (string) {

    try {
        return Date.parse(string);
    }
    catch (errIgnore) { }
};


internals.Response.Payload = class extends Stream.Readable {

    constructor(payload, options) {

        super();

        this._data = payload;
        this._prefix = null;
        this._suffix = null;
        this._sizeOffset = 0;
        this._encoding = options.encoding;
    }

    _read(size) {

        if (this._prefix) {
            this.push(this._prefix, this._encoding);
        }

        if (this._data) {
            this.push(this._data, this._encoding);
        }

        if (this._suffix) {
            this.push(this._suffix, this._encoding);
        }

        this.push(null);
    }

    size() {

        if (!this._data) {
            return this._sizeOffset;
        }

        return (Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding)) + this._sizeOffset;
    }

    jsonp(variable) {

        this._sizeOffset = this._sizeOffset + variable.length + 7;
        this._prefix = '/**/' + variable + '(';                 // '/**/' prefix prevents CVE-2014-4671 security exploit
        this._data = (this._data === null || Buffer.isBuffer(this._data)) ? this._data : this._data.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
        this._suffix = ');';
    }

    writeToStream(stream) {

        if (this._prefix) {
            stream.write(this._prefix, this._encoding);
        }

        if (this._data) {
            stream.write(this._data, this._encoding);
        }

        if (this._suffix) {
            stream.write(this._suffix, this._encoding);
        }

        stream.end();
    }
};


internals.Response.Peek = class extends Stream.Transform {

    constructor(podium) {

        super();

        this._podium = podium;
        this.on('finish', () => podium.emit('finish'));
    }

    _transform(chunk, encoding, callback) {

        this._podium.emit('peek', [chunk, encoding]);
        this.push(chunk, encoding);
        callback();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/route.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/route.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! assert */ "assert");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Catbox = __webpack_require__(/*! @hapi/catbox */ "./node_modules/@hapi/catbox/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");
const Subtext = __webpack_require__(/*! @hapi/subtext */ "./node_modules/@hapi/subtext/lib/index.js");

const Auth = __webpack_require__(/*! ./auth */ "./node_modules/@hapi/hapi/lib/auth.js");
const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Ext = __webpack_require__(/*! ./ext */ "./node_modules/@hapi/hapi/lib/ext.js");
const Handler = __webpack_require__(/*! ./handler */ "./node_modules/@hapi/hapi/lib/handler.js");
const Headers = __webpack_require__(/*! ./headers */ "./node_modules/@hapi/hapi/lib/headers.js");
const Security = __webpack_require__(/*! ./security */ "./node_modules/@hapi/hapi/lib/security.js");
const Streams = __webpack_require__(/*! ./streams */ "./node_modules/@hapi/hapi/lib/streams.js");
const Validation = __webpack_require__(/*! ./validation */ "./node_modules/@hapi/hapi/lib/validation.js");


const internals = {};


exports = module.exports = internals.Route = class {

    constructor(route, server, options = {}) {

        const core = server._core;
        const realm = server.realm;

        // Routing information

        Config.apply('route', route, route.method, route.path);

        const method = route.method.toLowerCase();
        Hoek.assert(method !== 'head', 'Cannot set HEAD route:', route.path);

        const path = (realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (route.path !== '/' ? route.path : '') : route.path);
        Hoek.assert(path === '/' || path[path.length - 1] !== '/' || !core.settings.router.stripTrailingSlash, 'Path cannot end with a trailing slash when configured to strip:', route.method, route.path);

        const vhost = (realm.modifiers.route.vhost || route.vhost);

        // Set identifying members (assert)

        this.method = method;
        this.path = path;

        // Prepare configuration

        let config = route.options || route.config || {};
        if (typeof config === 'function') {
            config = config.call(realm.settings.bind, server);
        }

        config = Config.enable(config);     // Shallow clone

        // Verify route level config (as opposed to the merged settings)

        this._assert(method !== 'get' || !config.payload, 'Cannot set payload settings on HEAD or GET request');
        this._assert(method !== 'get' || !config.validate || !config.validate.payload, 'Cannot validate HEAD or GET request payload');

        // Rules

        this._assert(!route.rules || !config.rules, 'Route rules can only appear once');                    // XOR
        const rules = (route.rules || config.rules);
        const rulesConfig = internals.rules(rules, { method, path, vhost }, server);
        delete config.rules;

        // Handler

        this._assert(route.handler || config.handler, 'Missing or undefined handler');
        this._assert(!!route.handler ^ !!config.handler, 'Handler must only appear once');                  // XOR

        const handler = Config.apply('handler', route.handler || config.handler);
        delete config.handler;

        const handlerDefaults = Handler.defaults(method, handler, core);

        // Apply settings in order: server <- handler <- realm <- route

        const settings = internals.config([core.settings.routes, handlerDefaults, realm.settings, rulesConfig, config]);
        this.settings = Config.apply('routeConfig', settings, method, path);

        // Validate timeouts

        const socketTimeout = (this.settings.timeout.socket === undefined ? 2 * 60 * 1000 : this.settings.timeout.socket);
        this._assert(!this.settings.timeout.server || !socketTimeout || this.settings.timeout.server < socketTimeout, 'Server timeout must be shorter than socket timeout');
        this._assert(!this.settings.payload.timeout || !socketTimeout || this.settings.payload.timeout < socketTimeout, 'Payload timeout must be shorter than socket timeout');

        // Route members

        this._core = core;
        this.realm = realm;

        this.settings.vhost = vhost;
        this.settings.plugins = this.settings.plugins || {};            // Route-specific plugins settings, namespaced using plugin name
        this.settings.app = this.settings.app || {};                    // Route-specific application settings

        // Path parsing

        this._special = !!options.special;
        this._analysis = this._core.router.analyze(this.path);
        this.params = this._analysis.params;
        this.fingerprint = this._analysis.fingerprint;

        this.public = {
            method: this.method,
            path: this.path,
            vhost,
            realm,
            settings: this.settings,
            fingerprint: this.fingerprint,
            auth: {
                access: (request) => Auth.testAccess(request, this.public)
            }
        };

        // Validation

        this._setupValidation();

        // Payload parsing

        if (this.method === 'get') {
            this.settings.payload = null;
        }
        else {
            this.settings.payload.decoders = this._core.compression._decoders;        // Reference the shared object to keep up to date
        }

        this._assert(!this.settings.validate.payload || this.settings.payload.parse, 'Route payload must be set to \'parse\' when payload validation enabled');
        this._assert(!this.settings.validate.state || this.settings.state.parse, 'Route state must be set to \'parse\' when state validation enabled');
        this._assert(!this.settings.jsonp || typeof this.settings.jsonp === 'string', 'Bad route JSONP parameter name');

        // Authentication configuration

        this.settings.auth = (this._special ? false : this._core.auth._setupRoute(this.settings.auth, path));

        // Cache

        if (this.method === 'get' &&
            typeof this.settings.cache === 'object' &&
            (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {

            this.settings.cache._statuses = new Set(this.settings.cache.statuses);
            this._cache = new Catbox.Policy({ expiresIn: this.settings.cache.expiresIn, expiresAt: this.settings.cache.expiresAt });
        }

        // CORS

        this.settings.cors = Cors.route(this.settings.cors);

        // Security

        this.settings.security = Security.route(this.settings.security);

        // Handler

        this.settings.handler = Handler.configure(handler, this);
        this._prerequisites = Handler.prerequisitesConfig(this.settings.pre);

        // Route lifecycle

        this._extensions = {
            onPreResponse: Ext.combine(this, 'onPreResponse')
        };

        if (this._special) {
            this._cycle = [internals.drain, Handler.execute];
            this.rebuild();
            return;
        }

        this._extensions.onPreAuth = Ext.combine(this, 'onPreAuth');
        this._extensions.onCredentials = Ext.combine(this, 'onCredentials');
        this._extensions.onPostAuth = Ext.combine(this, 'onPostAuth');
        this._extensions.onPreHandler = Ext.combine(this, 'onPreHandler');
        this._extensions.onPostHandler = Ext.combine(this, 'onPostHandler');

        this.rebuild();
    }

    _setupValidation() {

        const validation = this.settings.validate;
        if (this.method === 'get') {
            validation.payload = null;
        }

        this._assert(!validation.params || this.params.length, 'Cannot set path parameters validations without path parameters');

        ['headers', 'params', 'query', 'payload', 'state'].forEach((type) => {

            validation[type] = Validation.compile(validation[type]);
        });

        if (this.settings.response.schema !== undefined ||
            this.settings.response.status) {

            this.settings.response._validate = true;

            const rule = this.settings.response.schema;
            this.settings.response.status = this.settings.response.status || {};
            const statuses = Object.keys(this.settings.response.status);

            if (rule === true &&
                !statuses.length) {

                this.settings.response._validate = false;
            }
            else {
                this.settings.response.schema = Validation.compile(rule);
                for (const code of statuses) {
                    this.settings.response.status[code] = Validation.compile(this.settings.response.status[code]);
                }
            }
        }
    }

    rebuild(event) {

        if (event) {
            this._extensions[event.type].add(event);
        }

        if (this._special) {
            this._postCycle = (this._extensions.onPreResponse.nodes ? [this._extensions.onPreResponse] : []);
            this._buildMarshalCycle();
            return;
        }

        // Build lifecycle array

        this._cycle = [];

        // 'onRequest'

        if (this.settings.jsonp) {
            this._cycle.push(internals.parseJSONP);
        }

        if (this.settings.state.parse) {
            this._cycle.push(internals.state);
        }

        if (this._extensions.onPreAuth.nodes) {
            this._cycle.push(this._extensions.onPreAuth);
        }

        if (this._core.auth._enabled(this, 'authenticate')) {
            this._cycle.push(Auth.authenticate);
        }

        if (this.method !== 'get') {
            this._cycle.push(internals.payload);

            if (this._core.auth._enabled(this, 'payload')) {
                this._cycle.push(Auth.payload);
            }
        }

        if (this._core.auth._enabled(this, 'authenticate') &&
            this._extensions.onCredentials.nodes) {

            this._cycle.push(this._extensions.onCredentials);
        }

        if (this._core.auth._enabled(this, 'access')) {
            this._cycle.push(Auth.access);
        }

        if (this._extensions.onPostAuth.nodes) {
            this._cycle.push(this._extensions.onPostAuth);
        }

        if (this.settings.validate.headers) {
            this._cycle.push(Validation.headers);
        }

        if (this.settings.validate.params) {
            this._cycle.push(Validation.params);
        }

        if (this.settings.jsonp) {
            this._cycle.push(internals.cleanupJSONP);
        }

        if (this.settings.validate.query) {
            this._cycle.push(Validation.query);
        }

        if (this.settings.validate.payload) {
            this._cycle.push(Validation.payload);
        }

        if (this.settings.validate.state) {
            this._cycle.push(Validation.state);
        }

        if (this._extensions.onPreHandler.nodes) {
            this._cycle.push(this._extensions.onPreHandler);
        }

        this._cycle.push(Handler.execute);

        if (this._extensions.onPostHandler.nodes) {
            this._cycle.push(this._extensions.onPostHandler);
        }

        this._postCycle = [];

        if (this.settings.response._validate &&
            this.settings.response.sample !== 0) {

            this._postCycle.push(Validation.response);
        }

        if (this._extensions.onPreResponse.nodes) {
            this._postCycle.push(this._extensions.onPreResponse);
        }

        this._buildMarshalCycle();
    }

    _buildMarshalCycle() {

        this._marshalCycle = [Headers.type];

        if (this.settings.cors) {
            this._marshalCycle.push(Cors.headers);
        }

        if (this.settings.security) {
            this._marshalCycle.push(Security.headers);
        }

        this._marshalCycle.push(Headers.entity);

        if (this.method === 'get' ||
            this.method === '*') {

            this._marshalCycle.push(Headers.unmodified);
        }

        this._marshalCycle.push(Headers.cache);
        this._marshalCycle.push(Headers.state);
        this._marshalCycle.push(Headers.content);

        if (this._core.auth._enabled(this, 'response')) {
            this._marshalCycle.push(Auth.response);                            // Must be last in case requires access to headers
        }
    }

    _assert(condition, message) {

        if (condition) {
            return;
        }

        if (this.method[0] !== '_') {
            message = `${message}: ${this.method.toUpperCase()} ${this.path}`;
        }

        throw new Assert.AssertionError({
            message,
            actual: false,
            expected: true,
            operator: '==',
            stackStartFunction: this._assert
        });
    }
};


internals.state = async function (request) {

    request.state = {};

    const req = request.raw.req;
    const cookies = req.headers.cookie;
    if (!cookies) {
        return;
    }

    try {
        var result = await request._core.states.parse(cookies);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        var parseError = err;
    }

    const { states, failed = [] } = result || parseError;
    request.state = states || {};

    // Clear cookies

    for (const item of failed) {
        if (item.settings.clearInvalid) {
            request._clearState(item.name);
        }
    }

    if (!parseError) {
        return;
    }

    parseError.header = cookies;

    return request._core.toolkit.failAction(request, request.route.settings.state.failAction, parseError, { tags: ['state', 'error'] });
};


internals.payload = async function (request) {

    if (request.method === 'get' ||
        request.method === 'head') {            // When route.method is '*'

        return;
    }

    if (request._expectContinue) {
        request.raw.res.writeContinue();
    }

    try {
        const { payload, mime } = await Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload);

        request._isPayloadPending = !!(payload && payload._readableState);
        request.mime = mime;
        request.payload = payload;
    }
    catch (err) {
        Bounce.rethrow(err, 'system');

        if (request._isPayloadPending) {
            await internals.drain(request);
            request._isPayloadPending = false;
        }
        else {
            request._isPayloadPending = true;
        }

        request.mime = err.mime;
        request.payload = null;

        return request._core.toolkit.failAction(request, request.route.settings.payload.failAction, err, { tags: ['payload', 'error'] });
    }
};


internals.drain = async function (request) {

    // Flush out any pending request payload not consumed due to errors

    await Streams.drain(request.raw.req);
    request._isPayloadPending = false;
};


internals.jsonpRegex = /^[\w\$\[\]\.]+$/;


internals.parseJSONP = function (request) {

    const jsonp = request.query[request.route.settings.jsonp];
    if (jsonp) {
        if (internals.jsonpRegex.test(jsonp) === false) {
            throw Boom.badRequest('Invalid JSONP parameter value');
        }

        request.jsonp = jsonp;
    }
};


internals.cleanupJSONP = function (request) {

    if (request.jsonp) {
        delete request.query[request.route.settings.jsonp];
    }
};


internals.config = function (chain) {

    if (!chain.length) {
        return {};
    }

    let config = chain[0];
    for (const item of chain) {
        config = Hoek.applyToDefaults(config, item, { shallow: ['bind', 'validate.headers', 'validate.payload', 'validate.params', 'validate.query', 'validate.state'] });
    }

    return config;
};


internals.rules = function (rules, info, server) {

    const configs = [];

    let realm = server.realm;
    while (realm) {
        if (realm._rules) {
            const source = (!realm._rules.settings.validate ? rules : Joi.attempt(rules, realm._rules.settings.validate.schema, realm._rules.settings.validate.options));
            const config = realm._rules.processor(source, info);
            if (config) {
                configs.unshift(config);
            }
        }

        realm = realm.parent;
    }

    return internals.config(configs);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/security.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/security.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.route = function (settings) {

    if (!settings) {
        return null;
    }

    const security = settings;
    if (security.hsts) {
        if (security.hsts === true) {
            security._hsts = 'max-age=15768000';
        }
        else if (typeof security.hsts === 'number') {
            security._hsts = 'max-age=' + security.hsts;
        }
        else {
            security._hsts = 'max-age=' + (security.hsts.maxAge || 15768000);
            if (security.hsts.includeSubdomains || security.hsts.includeSubDomains) {
                security._hsts = security._hsts + '; includeSubDomains';
            }

            if (security.hsts.preload) {
                security._hsts = security._hsts + '; preload';
            }
        }
    }

    if (security.xframe) {
        if (security.xframe === true) {
            security._xframe = 'DENY';
        }
        else if (typeof security.xframe === 'string') {
            security._xframe = security.xframe.toUpperCase();
        }
        else if (security.xframe.rule === 'allow-from') {
            if (!security.xframe.source) {
                security._xframe = 'SAMEORIGIN';
            }
            else {
                security._xframe = 'ALLOW-FROM ' + security.xframe.source;
            }
        }
        else {
            security._xframe = security.xframe.rule.toUpperCase();
        }
    }

    return security;
};


exports.headers = function (request) {

    const response = request.response;
    const security = response.request.route.settings.security;

    if (security._hsts) {
        response._header('strict-transport-security', security._hsts, { override: false });
    }

    if (security._xframe) {
        response._header('x-frame-options', security._xframe, { override: false });
    }

    if (security.xss) {
        response._header('x-xss-protection', '1; mode=block', { override: false });
    }

    if (security.noOpen) {
        response._header('x-download-options', 'noopen', { override: false });
    }

    if (security.noSniff) {
        response._header('x-content-type-options', 'nosniff', { override: false });
    }

    if (security.referrer !== false) {
        response._header('referrer-policy', security.referrer, { override: false });
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/server.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/server.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");
const Shot = __webpack_require__(/*! @hapi/shot */ "./node_modules/@hapi/shot/lib/index.js");
const Somever = __webpack_require__(/*! @hapi/somever */ "./node_modules/@hapi/somever/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Core = __webpack_require__(/*! ./core */ "./node_modules/@hapi/hapi/lib/core.js");
const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Ext = __webpack_require__(/*! ./ext */ "./node_modules/@hapi/hapi/lib/ext.js");
const Package = __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/hapi/package.json");
const Request = __webpack_require__(/*! ./request */ "./node_modules/@hapi/hapi/lib/request.js");
const Route = __webpack_require__(/*! ./route */ "./node_modules/@hapi/hapi/lib/route.js");


const internals = {};


exports = module.exports = function (options) {

    const core = new Core(options);
    return new internals.Server(core);
};


internals.Server = class {

    constructor(core, name, parent) {

        this._core = core;

        // Public interface

        this.app = core.app;
        this.auth = Object.create(this._core.auth);
        this.auth.strategy = this.auth._strategy.bind(this.auth, this);
        this.decorations = core.decorations;
        this.cache = internals.cache(this);
        this.events = core.events;
        this.info = core.info;
        this.listener = core.listener;
        this.load = core.heavy.load;
        this.methods = core.methods.methods;
        this.mime = core.mime;
        this.plugins = core.plugins;
        this.registrations = core.registrations;
        this.settings = core.settings;
        this.states = core.states;
        this.type = core.type;
        this.version = Package.version;

        this.realm = {
            _extensions: {
                onPreAuth: new Ext('onPreAuth', core),
                onCredentials: new Ext('onCredentials', core),
                onPostAuth: new Ext('onPostAuth', core),
                onPreHandler: new Ext('onPreHandler', core),
                onPostHandler: new Ext('onPostHandler', core),
                onPreResponse: new Ext('onPreResponse', core)
            },
            modifiers: {
                route: {}
            },
            parent: (parent ? parent.realm : null),
            plugin: name,
            pluginOptions: {},
            plugins: {},
            _rules: null,
            settings: {
                bind: undefined,
                files: {
                    relativeTo: undefined
                }
            }
        };

        // Decorations

        for (const method of core.decorations.server) {
            this[method] = core._decorations.server[method];
        }

        core.registerServer(this);
    }

    _clone(name) {

        return new internals.Server(this._core, name, this);
    }

    bind(context) {

        Hoek.assert(typeof context === 'object', 'bind must be an object');
        this.realm.settings.bind = context;
    }

    control(server) {

        Hoek.assert(server instanceof internals.Server, 'Can only control Server objects');

        this._core.controlled = this._core.controlled || [];
        this._core.controlled.push(server);
    }

    decoder(encoding, decoder) {

        return this._core.compression.addDecoder(encoding, decoder);
    }

    decorate(type, property, method, options = {}) {

        Hoek.assert(this._core.decorations[type], 'Unknown decoration type:', type);
        Hoek.assert(property, 'Missing decoration property name');
        Hoek.assert(typeof property === 'string' || typeof property === 'symbol', 'Decoration property must be a string or a symbol');

        const propertyName = property.toString();
        Hoek.assert(propertyName[0] !== '_', 'Property name cannot begin with an underscore:', propertyName);

        const existing = this._core._decorations[type][property];
        if (options.extend) {
            Hoek.assert(type !== 'handler', 'Cannot extent handler decoration:', propertyName);
            Hoek.assert(existing, `Cannot extend missing ${type} decoration: ${propertyName}`);
            Hoek.assert(typeof method === 'function', `Extended ${type} decoration method must be a function: ${propertyName}`);

            method = method(existing);
        }
        else {
            Hoek.assert(existing === undefined, `${type[0].toUpperCase() + type.slice(1)} decoration already defined: ${propertyName}`);
        }

        if (type === 'handler') {

            // Handler

            Hoek.assert(typeof method === 'function', 'Handler must be a function:', propertyName);
            Hoek.assert(!method.defaults || typeof method.defaults === 'object' || typeof method.defaults === 'function', 'Handler defaults property must be an object or function');
            Hoek.assert(!options.extend, 'Cannot extend handler decoration:', propertyName);
        }
        else if (type === 'request') {

            // Request

            Hoek.assert(Request.reserved.indexOf(property) === -1, 'Cannot override built-in request interface decoration:', propertyName);

            if (options.apply) {
                this._core._decorations.requestApply = this._core._decorations.requestApply || {};
                this._core._decorations.requestApply[property] = method;
            }
            else {
                this._core.Request.prototype[property] = method;
            }
        }
        else if (type === 'toolkit') {

            // Toolkit

            Hoek.assert(this._core.toolkit.reserved.indexOf(property) === -1, 'Cannot override built-in toolkit decoration:', propertyName);
        }
        else {

            // Server

            if (typeof property === 'string') {
                Hoek.assert(Object.getOwnPropertyNames(internals.Server.prototype).indexOf(property) === -1, 'Cannot override the built-in server interface method:', propertyName);
            }
            else {
                Hoek.assert(Object.getOwnPropertySymbols(internals.Server.prototype).indexOf(property) === -1, 'Cannot override the built-in server interface method:', propertyName);
            }

            this._core.instances.forEach((server) => {

                server[property] = method;
            });
        }

        this._core._decorations[type][property] = method;
        this._core.decorations[type].push(property);
    }

    dependency(dependencies, after) {

        Hoek.assert(this.realm.plugin, 'Cannot call dependency() outside of a plugin');
        Hoek.assert(!after || typeof after === 'function', 'Invalid after method');

        // Normalize to { plugin: version }

        if (typeof dependencies === 'string') {
            dependencies = { [dependencies]: '*' };
        }
        else if (Array.isArray(dependencies)) {
            const map = {};
            for (const dependency of dependencies) {
                map[dependency] = '*';
            }

            dependencies = map;
        }

        this._core.dependencies.push({ plugin: this.realm.plugin, deps: dependencies });

        if (after) {
            this.ext('onPreStart', after, { after: Object.keys(dependencies) });
        }
    }

    encoder(encoding, encoder) {

        return this._core.compression.addEncoder(encoding, encoder);
    }

    event(event) {

        this._core.events.registerEvent(event);
    }

    expose(key, value) {

        Hoek.assert(this.realm.plugin, 'Cannot call expose() outside of a plugin');

        const plugin = this.realm.plugin;
        this._core.plugins[plugin] = this._core.plugins[plugin] || {};

        if (typeof key === 'string') {
            this._core.plugins[plugin][key] = value;
        }
        else {
            Hoek.merge(this._core.plugins[plugin], key);
        }
    }

    ext(events, method, options) {        // (event, method, options) -OR- (events)

        if (typeof events === 'string') {
            events = { type: events, method, options };
        }

        events = Config.apply('exts', events);
        for (const event of events) {
            this._ext(event);
        }
    }

    _ext(event) {

        event = Object.assign({}, event);       // Shallow cloned
        event.realm = this.realm;
        const type = event.type;

        if (!this._core.extensions.server[type]) {

            // Realm route extensions

            if (event.options.sandbox === 'plugin') {
                Hoek.assert(this.realm._extensions[type], 'Unknown event type', type);
                return this.realm._extensions[type].add(event);
            }

            // Connection route extensions

            Hoek.assert(this._core.extensions.route[type], 'Unknown event type', type);
            return this._core.extensions.route[type].add(event);
        }

        // Server extensions

        Hoek.assert(!event.options.sandbox, 'Cannot specify sandbox option for server extension');
        Hoek.assert(type !== 'onPreStart' || this._core.phase === 'stopped', 'Cannot add onPreStart (after) extension after the server was initialized');

        event.server = this;
        this._core.extensions.server[type].add(event);
    }

    async inject(options) {

        let settings = options;
        if (typeof settings === 'string') {
            settings = { url: settings };
        }

        if (!settings.authority ||
            settings.auth ||
            settings.app ||
            settings.plugins ||
            settings.allowInternals !== undefined) {        // Can be false

            settings = Object.assign({}, settings);         // options can be reused (shallow cloned)
            delete settings.auth;
            delete settings.app;
            delete settings.plugins;
            delete settings.allowInternals;

            settings.authority = settings.authority || (this._core.info.host + ':' + this._core.info.port);
        }

        Hoek.assert(!options.credentials, 'options.credentials no longer supported (use options.auth)');

        if (options.auth) {
            Hoek.assert(typeof options.auth === 'object', 'options.auth must be an object');
            Hoek.assert(options.auth.credentials, 'options.auth.credentials is missing');
            Hoek.assert(options.auth.strategy, 'options.auth.strategy is missing');
        }

        const needle = this._core._dispatch({
            auth: options.auth,
            allowInternals: options.allowInternals,
            app: options.app,
            plugins: options.plugins
        });

        const res = await Shot.inject(needle, settings);
        const custom = res.raw.res[Config.symbol];
        if (custom) {
            res.result = custom.result;
            res.request = custom.request;
            delete res.raw.res[Config.symbol];
        }

        if (res.result === undefined) {
            res.result = res.payload;
        }

        return res;
    }

    log(tags, data) {

        return this._core.log(tags, data);
    }

    lookup(id) {

        Hoek.assert(id && typeof id === 'string', 'Invalid route id:', id);

        const record = this._core.router.ids[id];
        if (!record) {
            return null;
        }

        return record.route.public;
    }

    match(method, path, host) {

        Hoek.assert(method && typeof method === 'string', 'Invalid method:', method);
        Hoek.assert(path && typeof path === 'string' && path[0] === '/', 'Invalid path:', path);
        Hoek.assert(!host || typeof host === 'string', 'Invalid host:', host);

        const match = this._core.router.route(method.toLowerCase(), path, host);
        Hoek.assert(match !== this._core.router.specials.badRequest, 'Invalid path:', path);
        if (match === this._core.router.specials.notFound) {
            return null;
        }

        return match.route.public;
    }

    method(name, method, options = {}) {

        return this._core.methods.add(name, method, options, this.realm);
    }

    path(relativeTo) {

        Hoek.assert(relativeTo && typeof relativeTo === 'string', 'relativeTo must be a non-empty string');
        this.realm.settings.files.relativeTo = relativeTo;
    }

    async register(plugins, options = {}) {

        if (this.realm.modifiers.route.prefix ||
            this.realm.modifiers.route.vhost) {

            options = Hoek.clone(options);
            options.routes = options.routes || {};

            options.routes.prefix = (this.realm.modifiers.route.prefix || '') + (options.routes.prefix || '') || undefined;
            options.routes.vhost = this.realm.modifiers.route.vhost || options.routes.vhost;
        }

        options = Config.apply('register', options);

        ++this._core.registring;

        try {
            const items = [].concat(plugins);
            for (let item of items) {

                /*
                    { register, ...attributes }
                    { plugin: { register, ...attributes }, options, once, routes }
                    { plugin: { plugin: { register, ...attributes } }, options, once, routes }      // Required module
                */

                if (!item.plugin) {
                    item = {
                        plugin: item
                    };
                }
                else if (!item.plugin.register) {
                    item = {
                        options: item.options,
                        once: item.once,
                        routes: item.routes,
                        plugin: item.plugin.plugin
                    };
                }
                else if (typeof item === 'function') {
                    item = Object.assign({}, item);         // Shallow cloned
                }

                item = Config.apply('plugin', item);

                const name = item.plugin.name || item.plugin.pkg.name;
                const clone = this._clone(name);

                clone.realm.modifiers.route.prefix = item.routes.prefix || options.routes.prefix;
                clone.realm.modifiers.route.vhost = item.routes.vhost || options.routes.vhost;
                clone.realm.pluginOptions = item.options || {};

                // Validate requirements

                const requirements = item.plugin.requirements;
                Hoek.assert(!requirements.node || Somever.match(process.version, requirements.node), 'Plugin', name, 'requires node version', requirements.node, 'but found', process.version);
                Hoek.assert(!requirements.hapi || Somever.match(this.version, requirements.hapi), 'Plugin', name, 'requires hapi version', requirements.hapi, 'but found', this.version);

                // Protect against multiple registrations

                if (this._core.registrations[name]) {
                    if (item.plugin.once ||
                        item.once ||
                        options.once) {

                        continue;
                    }

                    Hoek.assert(item.plugin.multiple, 'Plugin', name, 'already registered');
                }
                else {
                    this._core.registrations[name] = {
                        version: item.plugin.version || item.plugin.pkg.version,
                        name,
                        options: item.options
                    };
                }

                if (item.plugin.dependencies) {
                    clone.dependency(item.plugin.dependencies);
                }

                // Register

                await item.plugin.register(clone, item.options || {});
            }
        }
        catch (err) {
            throw err;
        }
        finally {
            --this._core.registring;
        }
    }

    route(options) {

        Hoek.assert(typeof options === 'object', 'Invalid route options');

        options = [].concat(options);
        for (const config of options) {
            if (Array.isArray(config.method)) {
                for (const method of config.method) {
                    const settings = Object.assign({}, config);     // Shallow cloned
                    settings.method = method;
                    this._addRoute(settings, this);
                }
            }
            else {
                this._addRoute(config, this);
            }
        }
    }

    _addRoute(config, server) {

        const route = new Route(config, server);                        // Do no use config beyond this point, use route members
        const vhosts = [].concat(route.settings.vhost || '*');

        for (const vhost of vhosts) {
            const record = this._core.router.add({ method: route.method, path: route.path, vhost, analysis: route._analysis, id: route.settings.id }, route);
            route.fingerprint = record.fingerprint;
            route.params = record.params;
        }

        this.events.emit('route', route.public);
        Cors.options(route.public, server);
    }

    rules(processor, options = {}) {

        Hoek.assert(!this.realm._rules, 'Server realm rules already defined');

        const settings = Config.apply('rules', options);
        if (settings.validate) {
            const schema = settings.validate.schema;
            settings.validate.schema = Joi.compile(schema);
        }

        this.realm._rules = { processor, settings };
    }

    state(name, options) {

        this.states.add(name, options);
    }

    table(host) {

        return this._core.router.table(host);
    }

    start() {

        return this._core._start();
    }

    initialize() {

        return this._core._initialize();
    }

    stop(options) {

        return this._core._stop(options);
    }
};


internals.cache = (plugin) => {

    const policy = function (options, _segment) {

        return this._core._cachePolicy(options, _segment, plugin.realm);
    };

    policy.provision = async (opts) => {

        const clients = plugin._core._createCache(opts);

        // Start cache

        if (['initialized', 'starting', 'started'].indexOf(plugin._core.phase) !== -1) {
            await Promise.all(clients.map((client) => client.start()));
        }
    };

    return policy;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/streams.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/streams.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Teamwork = __webpack_require__(/*! @hapi/teamwork */ "./node_modules/@hapi/teamwork/lib/index.js");


const internals = {
    team: Symbol('team')
};


exports.isStream = function (stream) {

    return stream &&
        typeof stream === 'object' &&
        typeof stream.pipe === 'function';
};


exports.drain = function (stream) {

    const team = new Teamwork();
    stream[internals.team] = team;

    stream.on('readable', internals.read);
    stream.on('error', internals.end);
    stream.on('end', internals.end);
    stream.on('close', internals.end);

    return team.work;
};


internals.read = function () {

    while (this.read()) { }
};


internals.end = function () {

    this.removeListener('readable', internals.read);
    this.removeListener('error', internals.end);
    this.removeListener('end', internals.end);
    this.removeListener('close', internals.end);

    this[internals.team].attend();
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/toolkit.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/toolkit.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");


const internals = {
    reserved: ['abandon', 'authenticated', 'close', 'context', 'continue', 'entity', 'redirect', 'realm', 'request', 'response', 'state', 'unauthenticated', 'unstate']
};


exports = module.exports = internals.Manager = class {

    constructor() {

        this.abandon = Symbol('abandon');
        this.close = Symbol('close');
        this.continue = Symbol('continue');
        this.reserved = internals.reserved;
    }

    async execute(method, request, options) {

        const h = new internals.Toolkit(request, this, options);
        const bind = options.bind || null;

        try {
            let operation;

            if (bind) {
                operation = method.call(bind, request, h);
            }
            else {
                if (options.args) {
                    operation = method(request, h, ...options.args);
                }
                else {
                    operation = method(request, h);
                }
            }

            var response = await internals.Manager.timed(operation, options);
        }
        catch (err) {
            if (Bounce.isSystem(err)) {
                response = Boom.badImplementation(err);
            }
            else if (!Bounce.isError(err)) {
                response = Boom.badImplementation('Cannot throw non-error object', err);
            }
            else {
                response = Boom.boomify(err);
            }
        }

        // Process response

        if (response === undefined) {
            response = Boom.badImplementation(`${method.name} method did not return a value, a promise, or throw an error`);
        }

        if (options.continue &&
            response === this.continue) {

            if (options.continue === 'undefined') {
                return;
            }

            // 'null'

            response = null;
        }

        if (options.auth &&
            response instanceof internals.Auth) {

            return response;
        }

        if (typeof response !== 'symbol') {
            response = Response.wrap(response, request);
            if (!response.isBoom) {
                response = await response._prepare();
            }
        }

        return response;
    }

    failAction(request, failAction, err, options) {

        const retain = options.retain ? err : undefined;
        if (failAction === 'ignore') {
            return retain;
        }

        if (failAction === 'log') {
            request._log(options.tags, err);
            return retain;
        }

        if (failAction === 'error') {
            throw err;
        }

        return this.execute(failAction, request, { realm: request.route.realm, args: [options.details || err] });
    }

    static timed(method, options) {

        if (!options.timeout) {
            return method;
        }

        const timer = new Promise((resolve, reject) => {

            const handler = () => {

                reject(Boom.internal(`${options.name} timed out`));
            };

            setTimeout(handler, options.timeout);
        });

        return Promise.race([timer, method]);
    }
};


/*
    const handler = function (request, h) {

        result / h.response(result)         -> result                           // Not allowed before handler
        h.response(result).takeover()       -> result (respond)
        h.continue                          -> null                             // Defaults to null only in handler and pre, not allowed in auth

        throw error / h.response(error)     -> error (respond)                  // failAction override in pre
        <undefined>                         -> badImplementation (respond)

        // Auth only (scheme.payload and scheme.response use the same interface as pre-handler extension methods)

        h.unauthenticated(error, data)      -> error (respond) + data
        h.authenticated(data )              -> (continue) + data
    };
*/

internals.Toolkit = class {

    constructor(request, manager, options) {

        this.abandon = manager.abandon;
        this.close = manager.close;
        this.continue = manager.continue;
        this.context = options.bind;
        this.realm = options.realm;
        this.request = request;

        if (options.auth) {
            this.authenticated = internals.authenticated;
            this.unauthenticated = internals.unauthenticated;
        }

        for (const method of request._core.decorations.toolkit) {
            this[method] = request._core._decorations.toolkit[method];
        }
    }

    response(result) {

        Hoek.assert(!result || typeof result !== 'object' || typeof result.then !== 'function', 'Cannot wrap a promise');
        Hoek.assert(result instanceof Error === false, 'Cannot wrap an error');
        Hoek.assert(typeof result !== 'symbol', 'Cannot wrap a symbol');

        return Response.wrap(result, this.request);
    }

    redirect(location) {

        return this.response('').redirect(location);
    }

    entity(options) {

        Hoek.assert(options, 'Entity method missing required options');
        Hoek.assert(options.etag || options.modified, 'Entity methods missing required options key');

        this.request._entity = options;

        const entity = Response.entity(options.etag, options);
        if (Response.unmodified(this.request, entity)) {
            return this.response().code(304).takeover();
        }
    }

    state(name, value, options) {

        this.request._setState(name, value, options);
    }

    unstate(name, options) {

        this.request._clearState(name, options);
    }
};


internals.authenticated = function (data) {

    Hoek.assert(data && data.credentials, 'Authentication data missing credentials information');

    return new internals.Auth(null, data);
};


internals.unauthenticated = function (error, data) {

    Hoek.assert(!data || data.credentials, 'Authentication data missing credentials information');

    return new internals.Auth(error, data);
};


internals.Auth = class {

    constructor(error, data) {

        this.isAuth = true;
        this.error = error;
        this.data = data;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/transmit.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/transmit.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Http = __webpack_require__(/*! http */ "http");

const Ammo = __webpack_require__(/*! @hapi/ammo */ "./node_modules/@hapi/ammo/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Shot = __webpack_require__(/*! @hapi/shot */ "./node_modules/@hapi/shot/lib/index.js");
const Teamwork = __webpack_require__(/*! @hapi/teamwork */ "./node_modules/@hapi/teamwork/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");


const internals = {};


exports.send = async function (request) {

    const response = request.response;

    try {
        if (response.isBoom) {
            await internals.fail(request, response);
            return;
        }

        await internals.marshal(request);
        await internals.transmit(response);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        request._setResponse(err);
        return internals.fail(request, err);
    }
};


internals.marshal = async function (request) {

    for (const func of request._route._marshalCycle) {
        await func(request);
    }
};


internals.fail = async function (request, boom) {

    const response = internals.error(request, boom);
    request.response = response;                                // Not using request._setResponse() to avoid double log

    try {
        await internals.marshal(request);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');

        // Failed to marshal an error - replace with minimal representation of original error

        const minimal = {
            statusCode: response.statusCode,
            error: Http.STATUS_CODES[response.statusCode],
            message: boom.message
        };

        response._payload = new Response.Payload(JSON.stringify(minimal), {});
    }

    return internals.transmit(response);
};


internals.error = function (request, boom) {

    const error = boom.output;
    const response = new Response(error.payload, request);
    response._error = boom;
    response.code(error.statusCode);
    response.headers = Hoek.clone(error.headers);               // Prevent source from being modified
    return response;
};


internals.transmit = function (response) {

    const request = response.request;
    const length = internals.length(response);

    // Pipes

    const encoding = request._core.compression.encoding(response, length);
    const ranger = encoding ? null : internals.range(response, length);
    const compressor = internals.encoding(response, encoding);

    // Connection: close

    const isInjection = Shot.isInjection(request.raw.req);
    if (!(isInjection || request._core.started) ||
        request._isPayloadPending && !request.raw.req._readableState.ended) {

        response._header('connection', 'close');
    }

    // Write headers

    internals.writeHead(response);

    // Injection

    if (isInjection) {
        request.raw.res[Config.symbol] = { request };

        if (response.variety === 'plain') {
            request.raw.res[Config.symbol].result = response._isPayloadSupported() ? response.source : null;
        }
    }

    // Finalize response stream

    const stream = internals.chain([response._payload, response._tap(), compressor, ranger]);
    return internals.pipe(request, stream);
};


internals.length = function (response) {

    const request = response.request;

    const header = response.headers['content-length'];
    if (header === undefined) {
        return null;
    }

    let length = header;
    if (typeof length === 'string') {
        length = parseInt(header, 10);
        if (!isFinite(length)) {
            delete response.headers['content-length'];
            return null;
        }
    }

    // Empty response

    if (length === 0 &&
        !response._statusCode &&
        response.statusCode === 200 &&
        request.route.settings.response.emptyStatusCode === 204) {

        response.code(204);
        delete response.headers['content-length'];
    }

    return length;
};


internals.range = function (response, length) {

    const request = response.request;

    if (!length ||
        !request.route.settings.response.ranges ||
        request.method !== 'get' ||
        response.statusCode !== 200) {

        return null;
    }

    response._header('accept-ranges', 'bytes');

    if (!request.headers.range) {
        return null;
    }

    // Check If-Range

    if (request.headers['if-range'] &&
        request.headers['if-range'] !== response.headers.etag) {            // Ignoring last-modified date (weak)

        return null;
    }

    // Parse header

    const ranges = Ammo.header(request.headers.range, length);
    if (!ranges) {
        const error = Boom.rangeNotSatisfiable();
        error.output.headers['content-range'] = 'bytes */' + length;
        throw error;
    }

    // Prepare transform

    if (ranges.length !== 1) {                                              // Ignore requests for multiple ranges
        return null;
    }

    const range = ranges[0];
    response.code(206);
    response.bytes(range.to - range.from + 1);
    response._header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);

    return new Ammo.Stream(range);
};


internals.encoding = function (response, encoding) {

    const request = response.request;

    const header = response.headers['content-encoding'] || encoding;
    if (header &&
        response.headers.etag &&
        response.settings.varyEtag) {

        response.headers.etag = response.headers.etag.slice(0, -1) + '-' + header + '"';
    }

    if (!encoding ||
        response.statusCode === 206 ||
        !response._isPayloadSupported()) {

        return null;
    }

    delete response.headers['content-length'];
    response._header('content-encoding', encoding);
    const compressor = request._core.compression.encoder(request, encoding);
    if (response.variety === 'stream' &&
        typeof response._payload.setCompressor === 'function') {

        response._payload.setCompressor(compressor);
    }

    return compressor;
};


internals.pipe = function (request, stream) {

    const team = new Teamwork();

    // Write payload

    const env = { stream, request, team };

    const aborted = internals.end.bind(null, env, 'aborted');
    const close = internals.end.bind(null, env, 'close');
    const end = internals.end.bind(null, env, null);

    request.raw.req.on('aborted', aborted);
    request.raw.req.on('close', close);

    request.raw.res.on('close', close);
    request.raw.res.on('error', end);
    request.raw.res.on('finish', end);

    if (stream.writeToStream) {
        stream.writeToStream(request.raw.res);
    }
    else {
        stream.on('error', end);
        stream.pipe(request.raw.res);
    }

    return team.work;
};


internals.end = function (env, event, err) {

    const { request, stream, team } = env;

    if (!team) {                                                        // Used instead of cleaning up emitter listeners
        return;
    }

    env.team = null;

    if (request.raw.res.finished) {
        if (event !== 'aborted') {
            request.info.responded = Date.now();
        }

        team.attend();
        return;
    }

    if (err) {
        request.raw.res.destroy();
        Response.drain(stream);
    }

    err = err || new Boom(`Request ${event}`, { statusCode: request.route.settings.response.disconnectStatusCode });
    const error = internals.error(request, Boom.boomify(err));
    request._setResponse(error);

    if (request.raw.res[Config.symbol]) {
        request.raw.res.statusCode = error.statusCode;
        request.raw.res[Config.symbol].result = error.source;       // Force injected response to error
    }

    if (event) {
        request._log(['response', 'error', event]);
    }
    else {
        request._log(['response', 'error'], err);
    }

    request.raw.res.end();                                          // Triggers injection promise resolve
    team.attend();
};


internals.writeHead = function (response) {

    const res = response.request.raw.res;
    const headers = Object.keys(response.headers);
    let i = 0;

    try {
        for (; i < headers.length; ++i) {
            const header = headers[i];
            const value = response.headers[header];
            if (value !== undefined) {
                res.setHeader(header, value);
            }
        }
    }
    catch (err) {
        for (--i; i >= 0; --i) {
            res.removeHeader(headers[i]);       // Undo headers
        }

        throw Boom.boomify(err);
    }

    if (response.settings.message) {
        res.statusMessage = response.settings.message;
    }

    try {
        res.writeHead(response.statusCode);
    }
    catch (err) {
        throw Boom.boomify(err);
    }
};


internals.chain = function (sources) {

    let from = sources[0];
    for (let i = 1; i < sources.length; ++i) {
        const to = sources[i];
        if (to) {
            from.on('error', internals.errorPipe.bind(from, to));
            from = from.pipe(to);
        }
    }

    return from;
};


internals.errorPipe = function (to, err) {

    to.emit('error', err);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/validation.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/validation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");


const internals = {};


exports.compile = function (rule) {

    // false - nothing allowed

    if (rule === false) {
        return Joi.object({}).allow(null);
    }

    // Custom function

    if (typeof rule === 'function') {
        return rule;
    }

    // null, undefined, true - anything allowed

    if (!rule ||                            // false tested above
        rule === true) {

        return null;
    }

    // {...} - ... allowed

    if (typeof rule.validate === 'function') {
        return rule;
    }

    return Joi.compile(rule);
};


exports.headers = function (request) {

    return internals.input('headers', request);
};


exports.params = function (request) {

    return internals.input('params', request);
};


exports.payload = function (request) {

    if (request.method === 'get' ||
        request.method === 'head') {                // When route.method is '*'

        return;
    }

    return internals.input('payload', request);
};


exports.query = function (request) {

    return internals.input('query', request);
};


exports.state = function (request) {

    return internals.input('state', request);
};


internals.input = async function (source, request) {

    const localOptions = {
        context: {
            headers: request.headers,
            params: request.params,
            query: request.query,
            payload: request.payload,
            state: request.state,
            auth: request.auth,
            app: {
                route: request.route.settings.app,
                request: request.app
            }
        }
    };

    delete localOptions.context[source];
    Hoek.merge(localOptions, request.route.settings.validate.options);

    try {
        const schema = request.route.settings.validate[source];
        const bind = request.route.settings.bind;

        var value = await (typeof schema !== 'function' ? internals.validate(request[source], schema, localOptions) : schema.call(bind, request[source], localOptions));
        return;
    }
    catch (err) {
        var validationError = err;
    }
    finally {
        request.orig[source] = request[source];
        if (value !== undefined) {
            request[source] = value;
        }
    }

    if (request.route.settings.validate.failAction === 'ignore') {
        return;
    }

    // Prepare error

    const defaultError = validationError.isBoom ? validationError : Boom.badRequest(`Invalid request ${source} input`);
    const detailedError = Boom.boomify(validationError, { statusCode: 400, override: false });
    detailedError.output.payload.validation = { source, keys: [] };
    if (validationError.details) {
        for (const details of validationError.details) {
            const path = details.path;
            detailedError.output.payload.validation.keys.push(Hoek.escapeHtml(path.join('.')));
        }
    }

    if (request.route.settings.validate.errorFields) {
        for (const field in request.route.settings.validate.errorFields) {
            detailedError.output.payload[field] = request.route.settings.validate.errorFields[field];
        }
    }

    return request._core.toolkit.failAction(request, request.route.settings.validate.failAction, defaultError, { details: detailedError, tags: ['validation', 'error', source] });
};


exports.response = async function (request) {

    if (request.route.settings.response.sample) {
        const currentSample = Math.ceil((Math.random() * 100));
        if (currentSample > request.route.settings.response.sample) {
            return;
        }
    }

    const response = request.response;
    const statusCode = response.isBoom ? response.output.statusCode : response.statusCode;

    const statusSchema = request.route.settings.response.status[statusCode];
    if (statusCode >= 400 &&
        !statusSchema) {

        return;                 // Do not validate errors by default
    }

    const schema = statusSchema !== undefined ? statusSchema : request.route.settings.response.schema;
    if (schema === null) {
        return;                 // No rules
    }

    if (!response.isBoom &&
        request.response.variety !== 'plain') {

        throw Boom.badImplementation('Cannot validate non-object response');
    }

    const localOptions = {
        context: {
            headers: request.headers,
            params: request.params,
            query: request.query,
            payload: request.payload,
            state: request.state,
            auth: request.auth,
            app: {
                route: request.route.settings.app,
                request: request.app
            }
        }
    };

    const source = response.isBoom ? response.output.payload : response.source;
    Hoek.merge(localOptions, request.route.settings.response.options);

    try {
        let value;

        if (typeof schema !== 'function') {
            value = await internals.validate(source, schema, localOptions);
        }
        else {
            value = await schema(source, localOptions);
        }

        if (value !== undefined &&
            request.route.settings.response.modify) {

            if (response.isBoom) {
                response.output.payload = value;
            }
            else {
                response.source = value;
            }
        }
    }
    catch (err) {

        return request._core.toolkit.failAction(request, request.route.settings.response.failAction, err, { tags: ['validation', 'response', 'error'] });
    }
};


internals.validate = function (value, schema, options) {

    if (typeof schema.validateAsync === 'function') {
        return schema.validateAsync(value, options);
    }

    return schema.validate(value, options);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js":
/*!********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


exports.schema = function (Joi, config) {

    if (config !== undefined && config !== null && typeof config === 'object') {

        if (config.isJoi) {
            return config;
        }

        if (Array.isArray(config)) {
            return Joi.alternatives().try(config);
        }

        if (config instanceof RegExp) {
            return Joi.string().regex(config);
        }

        if (config instanceof Date) {
            return Joi.date().valid(config);
        }

        return Joi.object().keys(config);
    }

    if (typeof config === 'string') {
        return Joi.string().valid(config);
    }

    if (typeof config === 'number') {
        return Joi.number().valid(config);
    }

    if (typeof config === 'boolean') {
        return Joi.boolean().valid(config);
    }

    if (Ref.isRef(config)) {
        return Joi.valid(config);
    }

    Hoek.assert(config === null, 'Invalid schema content:', config);

    return Joi.valid(null);
};


exports.ref = function (id) {

    return Ref.isRef(id) ? id : Ref.create(id);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Language = __webpack_require__(/*! ./language */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/language.js");


const internals = {
    annotations: Symbol('joi-annotations')
};


internals.stringify = function (value, wrapArrays) {

    const type = typeof value;

    if (value === null) {
        return 'null';
    }

    if (type === 'string') {
        return value;
    }

    if (value instanceof exports.Err || type === 'function' || type === 'symbol') {
        return value.toString();
    }

    if (type === 'object') {
        if (Array.isArray(value)) {
            let partial = '';

            for (let i = 0; i < value.length; ++i) {
                partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);
            }

            return wrapArrays ? '[' + partial + ']' : partial;
        }

        return value.toString();
    }

    return JSON.stringify(value);
};


exports.Err = class {

    constructor(type, context, state, options, flags, message, template) {

        this.isJoi = true;
        this.type = type;
        this.context = context || {};
        this.context.key = state.path[state.path.length - 1];
        this.context.label = state.key;
        this.path = state.path;
        this.options = options;
        this.flags = flags;
        this.message = message;
        this.template = template;

        const localized = this.options.language;

        if (this.flags.label) {
            this.context.label = this.flags.label;
        }
        else if (localized &&                   // language can be null for arrays exclusion check
            (this.context.label === '' ||
            this.context.label === null)) {
            this.context.label = localized.root || Language.errors.root;
        }
    }

    toString() {

        if (this.message) {
            return this.message;
        }

        let format;

        if (this.template) {
            format = this.template;
        }

        const localized = this.options.language;

        format = format || Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);

        if (format === undefined) {
            return `Error code "${this.type}" is not defined, your custom type is missing the correct language definition`;
        }

        let wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');
        if (typeof wrapArrays !== 'boolean') {
            wrapArrays = Language.errors.messages.wrapArrays;
        }

        if (format === null) {
            const childrenString = internals.stringify(this.context.reason, wrapArrays);
            if (wrapArrays) {
                return childrenString.slice(1, -1);
            }

            return childrenString;
        }

        const hasKey = /{{!?label}}/.test(format);
        const skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';

        if (skipKey) {
            format = format.slice(2);
        }

        if (!hasKey && !skipKey) {
            const localizedKey = Hoek.reach(localized, 'key');
            if (typeof localizedKey === 'string') {
                format = localizedKey + format;
            }
            else {
                format = Hoek.reach(Language.errors, 'key') + format;
            }
        }

        const message =  format.replace(/{{(!?)([^}]+)}}/g, ($0, isSecure, name) => {

            const value = Hoek.reach(this.context, name);
            const normalized = internals.stringify(value, wrapArrays);
            return (isSecure && this.options.escapeHtml ? Hoek.escapeHtml(normalized) : normalized);
        });

        this.toString = () => message;  // Persist result of last toString call, it won't change

        return message;
    }

};


exports.create = function (type, context, state, options, flags, message, template) {

    return new exports.Err(type, context, state, options, flags, message, template);
};


exports.process = function (errors, object) {

    if (!errors) {
        return null;
    }

    // Construct error

    let message = '';
    const details = [];

    const processErrors = function (localErrors, parent, overrideMessage) {

        for (let i = 0; i < localErrors.length; ++i) {
            const item = localErrors[i];

            if (item instanceof Error) {
                return item;
            }

            if (item.flags.error && typeof item.flags.error !== 'function') {
                if (!item.flags.selfError || !item.context.reason) {
                    return item.flags.error;
                }
            }

            let itemMessage;
            if (parent === undefined) {
                itemMessage = item.toString();
                message = message + (message ? '. ' : '') + itemMessage;
            }

            // Do not push intermediate errors, we're only interested in leafs

            if (item.context.reason) {
                const override = processErrors(item.context.reason, item.path, item.type === 'override' ? item.message : null);
                if (override) {
                    return override;
                }
            }
            else {
                details.push({
                    message: overrideMessage || itemMessage || item.toString(),
                    path: item.path,
                    type: item.type,
                    context: item.context
                });
            }
        }
    };

    const override = processErrors(errors);
    if (override) {
        return override;
    }

    const error = new Error(message);
    error.isJoi = true;
    error.name = 'ValidationError';
    error.details = details;
    error._object = object;
    error.annotate = internals.annotate;
    return error;
};


// Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {

    return JSON.stringify(obj, internals.serializer(), spaces);
};


internals.serializer = function () {

    const keys = [];
    const stack = [];

    const cycleReplacer = (key, value) => {

        if (stack[0] === value) {
            return '[Circular ~]';
        }

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };

    return function (key, value) {

        if (stack.length > 0) {
            const thisPos = stack.indexOf(this);
            if (~thisPos) {
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            }
            else {
                stack.push(this);
                keys.push(key);
            }

            if (~stack.indexOf(value)) {
                value = cycleReplacer.call(this, key, value);
            }
        }
        else {
            stack.push(value);
        }

        if (value) {
            const annotations = value[internals.annotations];
            if (annotations) {
                if (Array.isArray(value)) {
                    const annotated = [];

                    for (let i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
                        }

                        annotated.push(value[i]);
                    }

                    value = annotated;
                }
                else {
                    const errorKeys = Object.keys(annotations.errors);
                    for (let i = 0; i < errorKeys.length; ++i) {
                        const errorKey = errorKeys[i];
                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
                        value[errorKey] = undefined;
                    }

                    const missingKeys = Object.keys(annotations.missing);
                    for (let i = 0; i < missingKeys.length; ++i) {
                        const missingKey = missingKeys[i];
                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
                    }
                }

                return value;
            }
        }

        if (value === Infinity || value === -Infinity || Number.isNaN(value) ||
            typeof value === 'function' || typeof value === 'symbol') {
            return '[' + value.toString() + ']';
        }

        return value;
    };
};


internals.annotate = function (stripColorCodes) {

    const redFgEscape = stripColorCodes ? '' : '\u001b[31m';
    const redBgEscape = stripColorCodes ? '' : '\u001b[41m';
    const endColor = stripColorCodes ? '' : '\u001b[0m';

    if (typeof this._object !== 'object') {
        return this.details[0].message;
    }

    const obj = Hoek.clone(this._object || {});

    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let ref = obj;
        for (let j = 0; ; ++j) {
            const seg = path[j];

            if (ref.isImmutable) {
                ref = ref.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step
            }

            if (j + 1 < path.length &&
                ref[seg] &&
                typeof ref[seg] !== 'string') {

                ref = ref[seg];
            }
            else {
                const refAnnotations = ref[internals.annotations] = ref[internals.annotations] || { errors: {}, missing: {} };
                const value = ref[seg];
                const cacheKey = seg || error.context.label;

                if (value !== undefined) {
                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                    refAnnotations.errors[cacheKey].push(pos);
                }
                else {
                    refAnnotations.missing[cacheKey] = pos;
                }

                break;
            }
        }
    }

    const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };

    let message = internals.safeStringify(obj, 2)
        .replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)
        .replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.specials, ($0, $1) => $1);

    message = `${message}\n${redFgEscape}`;

    for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}\n[${pos}] ${this.details[i].message}`;
    }

    message = message + endColor;

    return message;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ./types/any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ./cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js");
const Lazy = __webpack_require__(/*! ./types/lazy */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/lazy/index.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {
    alternatives: __webpack_require__(/*! ./types/alternatives */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js"),
    array: __webpack_require__(/*! ./types/array */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/array/index.js"),
    boolean: __webpack_require__(/*! ./types/boolean */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/boolean/index.js"),
    binary: __webpack_require__(/*! ./types/binary */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/binary/index.js"),
    date: __webpack_require__(/*! ./types/date */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js"),
    func: __webpack_require__(/*! ./types/func */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/func/index.js"),
    number: __webpack_require__(/*! ./types/number */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/number/index.js"),
    object: __webpack_require__(/*! ./types/object */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js"),
    string: __webpack_require__(/*! ./types/string */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/index.js"),
    symbol: __webpack_require__(/*! ./types/symbol */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbol/index.js")
};


internals.callWithDefaults = function (schema, args) {

    Hoek.assert(this, 'Must be invoked on a Joi instance.');

    if (this._defaults) {
        schema = this._defaults(schema);
    }

    schema._currentJoi = this;

    return schema._init(...args);
};


internals.root = function () {

    const any = new Any();

    const root = any.clone();
    Any.prototype._currentJoi = root;
    root._currentJoi = root;
    root._binds = new Set(['any', 'alternatives', 'alt', 'array', 'bool', 'boolean', 'binary', 'date', 'func', 'number', 'object', 'string', 'symbol', 'validate', 'describe', 'compile', 'assert', 'attempt', 'lazy', 'defaults', 'extend', 'allow', 'valid', 'only', 'equal', 'invalid', 'disallow', 'not', 'required', 'exist', 'optional', 'forbidden', 'strip', 'when', 'empty', 'default']);

    root.any = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');

        return internals.callWithDefaults.call(this, any, args);
    };

    root.alternatives = root.alt = function (...args) {

        return internals.callWithDefaults.call(this, internals.alternatives, args);
    };

    root.array = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.array, args);
    };

    root.boolean = root.bool = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.boolean, args);
    };

    root.binary = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.binary, args);
    };

    root.date = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.date, args);
    };

    root.func = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.func, args);
    };

    root.number = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.number, args);
    };

    root.object = function (...args) {

        return internals.callWithDefaults.call(this, internals.object, args);
    };

    root.string = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.string, args);
    };

    root.symbol = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.symbol, args);
    };

    root.ref = function (...args) {

        return Ref.create(...args);
    };

    root.isRef = function (ref) {

        return Ref.isRef(ref);
    };

    root.validate = function (value, ...args /*, [schema], [options], callback */) {

        const last = args[args.length - 1];
        const callback = typeof last === 'function' ? last : null;

        const count = args.length - (callback ? 1 : 0);
        if (count === 0) {
            return any.validate(value, callback);
        }

        const options = count === 2 ? args[1] : undefined;
        const schema = this.compile(args[0]);

        return schema._validateWithOptions(value, options, callback);
    };

    root.describe = function (...args) {

        const schema = args.length ? this.compile(args[0]) : any;
        return schema.describe();
    };

    root.compile = function (schema) {

        try {
            return Cast.schema(this, schema);
        }
        catch (err) {
            if (err.hasOwnProperty('path')) {
                err.message = err.message + '(' + err.path + ')';
            }

            throw err;
        }
    };

    root.assert = function (value, schema, message) {

        this.attempt(value, schema, message);
    };

    root.attempt = function (value, schema, message) {

        const result = this.validate(value, schema);
        const error = result.error;
        if (error) {
            if (!message) {
                if (typeof error.annotate === 'function') {
                    error.message = error.annotate();
                }

                throw error;
            }

            if (!(message instanceof Error)) {
                if (typeof error.annotate === 'function') {
                    error.message = `${message} ${error.annotate()}`;
                }

                throw error;
            }

            throw message;
        }

        return result.value;
    };

    root.reach = function (schema, path) {

        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');
        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');

        const reach = (sourceSchema, schemaPath) => {

            if (!schemaPath.length) {
                return sourceSchema;
            }

            const children = sourceSchema._inner.children;
            if (!children) {
                return;
            }

            const key = schemaPath.shift();
            for (let i = 0; i < children.length; ++i) {
                const child = children[i];
                if (child.key === key) {
                    return reach(child.schema, schemaPath);
                }
            }
        };

        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();

        return reach(schema, schemaPath);
    };

    root.lazy = function (...args) {

        return internals.callWithDefaults.call(this, Lazy, args);
    };

    root.defaults = function (fn) {

        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');

        let joi = Object.create(this.any());
        joi = fn(joi);

        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');

        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults

        joi._defaults = (schema) => {

            if (this._defaults) {
                schema = this._defaults(schema);
                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');
            }

            schema = fn(schema);
            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');
            return schema;
        };

        return joi;
    };

    root.bind = function () {

        const joi = Object.create(this);

        joi._binds.forEach((bind) => {

            joi[bind] = joi[bind].bind(joi);
        });

        return joi;
    };

    root.extend = function (...args) {

        const extensions = Hoek.flatten(args);
        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');

        this.assert(extensions, root.extensionsSchema);

        const joi = Object.create(this.any());
        Object.assign(joi, this);
        joi._currentJoi = joi;
        joi._binds = new Set(joi._binds);

        for (let i = 0; i < extensions.length; ++i) {
            let extension = extensions[i];

            if (typeof extension === 'function') {
                extension = extension(joi);
            }

            this.assert(extension, root.extensionSchema);

            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards
            const ctor = base.constructor;
            const type = class extends ctor { // eslint-disable-line no-loop-func

                constructor() {

                    super();
                    if (extension.base) {
                        Object.assign(this, base);
                    }

                    this._type = extension.name;
                }

            };

            if (extension.language) {
                const lang = {
                    [extension.name]: extension.language
                };
                type.prototype._language = Hoek.applyToDefaults(type.prototype._language || (base._settings && base._settings.language) || {}, lang);
            }


            if (extension.coerce) {
                type.prototype._coerce = function (value, state, options) {

                    if (ctor.prototype._coerce) {
                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);

                        if (baseRet.errors) {
                            return baseRet;
                        }

                        value = baseRet.value;
                    }

                    const ret = extension.coerce.call(this, value, state, options);
                    if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                    }

                    return { value: ret };
                };
            }

            if (extension.pre) {
                type.prototype._base = function (value, state, options) {

                    if (ctor.prototype._base) {
                        const baseRet = ctor.prototype._base.call(this, value, state, options);

                        if (baseRet.errors) {
                            return baseRet;
                        }

                        value = baseRet.value;
                    }

                    const ret = extension.pre.call(this, value, state, options);
                    if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                    }

                    return { value: ret };
                };
            }

            if (extension.rules) {
                for (let j = 0; j < extension.rules.length; ++j) {
                    const rule = extension.rules[j];
                    const ruleArgs = rule.params ?
                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :
                        [];
                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;

                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func

                        if (rArgs.length > ruleArgs.length) {
                            throw new Error('Unexpected number of arguments');
                        }

                        let hasRef = false;
                        let arg = {};

                        for (let k = 0; k < ruleArgs.length; ++k) {
                            arg[ruleArgs[k]] = rArgs[k];
                            if (!hasRef && Ref.isRef(rArgs[k])) {
                                hasRef = true;
                            }
                        }

                        if (validateArgs) {
                            arg = joi.attempt(arg, validateArgs);
                        }

                        let schema;
                        if (rule.validate && !rule.setup) {
                            const validate = function (value, state, options) {

                                return rule.validate.call(this, arg, value, state, options);
                            };

                            schema = this._test(rule.name, arg, validate, {
                                description: rule.description,
                                hasRef
                            });
                        }
                        else {
                            schema = this.clone();
                        }

                        if (rule.setup) {
                            const newSchema = rule.setup.call(schema, arg);
                            if (newSchema !== undefined) {
                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);
                                schema = newSchema;
                            }

                            if (rule.validate) {
                                const validate = function (value, state, options) {

                                    return rule.validate.call(this, arg, value, state, options);
                                };

                                schema = schema._test(rule.name, arg, validate, {
                                    description: rule.description,
                                    hasRef
                                });
                            }
                        }

                        return schema;
                    };
                }
            }

            if (extension.describe) {
                type.prototype.describe = function () {

                    const description = ctor.prototype.describe.call(this);
                    return extension.describe.call(this, description);
                };
            }

            const instance = new type();
            joi[extension.name] = function (...extArgs) {

                return internals.callWithDefaults.call(this, instance, extArgs);
            };

            joi._binds.add(extension.name);
        }

        return joi;
    };

    root.extensionSchema = internals.object.keys({
        base: internals.object.type(Any, 'Joi object'),
        name: internals.string.required(),
        coerce: internals.func.arity(3),
        pre: internals.func.arity(3),
        language: internals.object,
        describe: internals.func.arity(1),
        rules: internals.array.items(internals.object.keys({
            name: internals.string.required(),
            setup: internals.func.arity(1),
            validate: internals.func.arity(4),
            params: [
                internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')),
                internals.object.type(internals.object.constructor, 'Joi object')
            ],
            description: [internals.string, internals.func.arity(1)]
        }).or('setup', 'validate'))
    }).strict();

    root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();

    root.version = __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json").version;

    return root;
};


module.exports = internals.root();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/language.js":
/*!************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/language.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.errors = {
    root: 'value',
    key: '"{{!label}}" ',
    messages: {
        wrapArrays: true
    },
    any: {
        unknown: 'is not allowed',
        invalid: 'contains an invalid value',
        empty: 'is not allowed to be empty',
        required: 'is required',
        allowOnly: 'must be one of {{valids}}',
        default: 'threw an error when running default method'
    },
    alternatives: {
        base: 'not matching any of the allowed alternatives',
        child: null
    },
    array: {
        base: 'must be an array',
        includes: 'at position {{pos}} does not match any of the allowed types',
        includesSingle: 'single value of "{{!label}}" does not match any of the allowed types',
        includesOne: 'at position {{pos}} fails because {{reason}}',
        includesOneSingle: 'single value of "{{!label}}" fails because {{reason}}',
        includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',
        includesRequiredKnowns: 'does not contain {{knownMisses}}',
        includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',
        excludes: 'at position {{pos}} contains an excluded value',
        excludesSingle: 'single value of "{{!label}}" contains an excluded value',
        hasKnown: 'does not contain at least one required match for type "{{!patternLabel}}"',
        hasUnknown: 'does not contain at least one required match',
        min: 'must contain at least {{limit}} items',
        max: 'must contain less than or equal to {{limit}} items',
        length: 'must contain {{limit}} items',
        ordered: 'at position {{pos}} fails because {{reason}}',
        orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',
        ref: 'references "{{ref}}" which is not a positive integer',
        sparse: 'must not be a sparse array',
        unique: 'position {{pos}} contains a duplicate value'
    },
    boolean: {
        base: 'must be a boolean'
    },
    binary: {
        base: 'must be a buffer or a string',
        min: 'must be at least {{limit}} bytes',
        max: 'must be less than or equal to {{limit}} bytes',
        length: 'must be {{limit}} bytes'
    },
    date: {
        base: 'must be a number of milliseconds or valid date string',
        strict: 'must be a valid date',
        min: 'must be larger than or equal to "{{limit}}"',
        max: 'must be less than or equal to "{{limit}}"',
        less: 'must be less than "{{limit}}"',
        greater: 'must be greater than "{{limit}}"',
        isoDate: 'must be a valid ISO 8601 date',
        timestamp: {
            javascript: 'must be a valid timestamp or number of milliseconds',
            unix: 'must be a valid timestamp or number of seconds'
        },
        ref: 'references "{{ref}}" which is not a date'
    },
    function: {
        base: 'must be a Function',
        arity: 'must have an arity of {{n}}',
        minArity: 'must have an arity greater or equal to {{n}}',
        maxArity: 'must have an arity lesser or equal to {{n}}',
        ref: 'must be a Joi reference',
        class: 'must be a class'
    },
    lazy: {
        base: '!!schema error: lazy schema must be set',
        schema: '!!schema error: lazy schema function must return a schema'
    },
    object: {
        base: 'must be an object',
        child: '!!child "{{!child}}" fails because {{reason}}',
        min: 'must have at least {{limit}} children',
        max: 'must have less than or equal to {{limit}} children',
        length: 'must have {{limit}} children',
        allowUnknown: '!!"{{!child}}" is not allowed',
        with: '!!"{{mainWithLabel}}" missing required peer "{{peerWithLabel}}"',
        without: '!!"{{mainWithLabel}}" conflict with forbidden peer "{{peerWithLabel}}"',
        missing: 'must contain at least one of {{peersWithLabels}}',
        xor: 'contains a conflict between exclusive peers {{peersWithLabels}}',
        oxor: 'contains a conflict between optional exclusive peers {{peersWithLabels}}',
        and: 'contains {{presentWithLabels}} without its required peers {{missingWithLabels}}',
        nand: '!!"{{mainWithLabel}}" must not exist simultaneously with {{peersWithLabels}}',
        assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
        rename: {
            multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
            override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists',
            regex: {
                multiple: 'cannot rename children {{from}} because multiple renames are disabled and another key was already renamed to "{{to}}"',
                override: 'cannot rename children {{from}} because override is disabled and target "{{to}}" exists'
            }
        },
        type: 'must be an instance of "{{type}}"',
        schema: 'must be a Joi instance'
    },
    number: {
        base: 'must be a number',
        unsafe: 'must be a safe number',
        min: 'must be larger than or equal to {{limit}}',
        max: 'must be less than or equal to {{limit}}',
        less: 'must be less than {{limit}}',
        greater: 'must be greater than {{limit}}',
        integer: 'must be an integer',
        negative: 'must be a negative number',
        positive: 'must be a positive number',
        precision: 'must have no more than {{limit}} decimal places',
        ref: 'references "{{ref}}" which is not a number',
        multiple: 'must be a multiple of {{multiple}}',
        port: 'must be a valid port'
    },
    string: {
        base: 'must be a string',
        min: 'length must be at least {{limit}} characters long',
        max: 'length must be less than or equal to {{limit}} characters long',
        length: 'length must be {{limit}} characters long',
        alphanum: 'must only contain alpha-numeric characters',
        token: 'must only contain alpha-numeric and underscore characters',
        regex: {
            base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
            name: 'with value "{{!value}}" fails to match the {{name}} pattern',
            invert: {
                base: 'with value "{{!value}}" matches the inverted pattern: {{pattern}}',
                name: 'with value "{{!value}}" matches the inverted {{name}} pattern'
            }
        },
        email: 'must be a valid email',
        uri: 'must be a valid uri',
        uriRelativeOnly: 'must be a valid relative uri',
        uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',
        isoDate: 'must be a valid ISO 8601 date',
        guid: 'must be a valid GUID',
        hex: 'must only contain hexadecimal characters',
        hexAlign: 'hex decoded representation must be byte aligned',
        base64: 'must be a valid base64 string',
        dataUri: 'must be a valid dataUri string',
        hostname: 'must be a valid hostname',
        normalize: 'must be unicode normalized in the {{form}} form',
        lowercase: 'must only contain lowercase characters',
        uppercase: 'must only contain uppercase characters',
        trim: 'must not have leading or trailing whitespace',
        creditCard: 'must be a credit card',
        ref: 'references "{{ref}}" which is not a number',
        ip: 'must be a valid ip address with a {{cidr}} CIDR',
        ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'
    },
    symbol: {
        base: 'must be a symbol',
        map: 'must be one of {{map}}'
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports.create = function (key, options) {

    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);

    const settings = Hoek.clone(options);         // options can be reused and modified

    const ref = function (value, validationOptions) {

        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
    };

    ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));
    ref.key = (ref.isContext ? key.slice(1) : key);
    ref.path = ref.key.split((settings && settings.separator) || '.');
    ref.depth = ref.path.length;
    ref.root = ref.path[0];
    ref.isJoi = true;

    ref.toString = function () {

        return (ref.isContext ? 'context:' : 'ref:') + ref.key;
    };

    return ref;
};


exports.isRef = function (ref) {

    return typeof ref === 'function' && ref.isJoi;
};


exports.push = function (array, ref) {

    if (exports.isRef(ref) &&
        !ref.isContext) {

        array.push(ref.root);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/schemas.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/schemas.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Joi = __webpack_require__(/*! ./index */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");


const internals = {};


exports.options = Joi.object({
    abortEarly: Joi.boolean(),
    convert: Joi.boolean(),
    allowUnknown: Joi.boolean(),
    skipFunctions: Joi.boolean(),
    stripUnknown: [Joi.boolean(), Joi.object({ arrays: Joi.boolean(), objects: Joi.boolean() }).or('arrays', 'objects')],
    language: Joi.object(),
    presence: Joi.string().only('required', 'optional', 'forbidden', 'ignore'),
    context: Joi.object(),
    noDefaults: Joi.boolean(),
    escapeHtml: Joi.boolean()
}).strict();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.extendedCheckForValue = function (value, insensitive) {

    const valueType = typeof value;

    if (valueType === 'object') {
        if (value instanceof Date) {
            return (item) => {

                return item instanceof Date && value.getTime() === item.getTime();
            };
        }

        if (Buffer.isBuffer(value)) {
            return (item) => {

                return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');
            };
        }
    }
    else if (insensitive && valueType === 'string') {
        const lowercaseValue = value.toLowerCase();
        return (item) => {

            return typeof item === 'string' && lowercaseValue === item.toLowerCase();
        };
    }

    return null;
};


module.exports = class InternalSet {

    constructor(from) {

        this._set = new Set(from);
        this._hasRef = false;
    }

    add(value, refs) {

        const isRef = Ref.isRef(value);
        if (!isRef && this.has(value, null, null, false)) {

            return this;
        }

        if (refs !== undefined) { // If it's a merge, we don't have any refs
            Ref.push(refs, value);
        }

        this._set.add(value);

        this._hasRef |= isRef;

        return this;
    }

    merge(add, remove) {

        for (const item of add._set) {
            this.add(item);
        }

        for (const item of remove._set) {
            this.remove(item);
        }

        return this;
    }

    remove(value) {

        this._set.delete(value);
        return this;
    }

    has(value, state, options, insensitive) {

        return !!this.get(value, state, options, insensitive);
    }

    get(value, state, options, insensitive) {

        if (!this._set.size) {
            return false;
        }

        const hasValue = this._set.has(value);
        if (hasValue) {
            return { value };
        }

        const extendedCheck = internals.extendedCheckForValue(value, insensitive);
        if (!extendedCheck) {
            if (state && this._hasRef) {
                for (let item of this._set) {
                    if (Ref.isRef(item)) {
                        item = [].concat(item(state.reference || state.parent, options));
                        const found = item.indexOf(value);
                        if (found >= 0) {
                            return { value: item[found] };
                        }
                    }
                }
            }

            return false;
        }

        return this._has(value, state, options, extendedCheck);
    }

    _has(value, state, options, check) {

        const checkRef = !!(state && this._hasRef);

        const isReallyEqual = function (item) {

            if (value === item) {
                return true;
            }

            return check(item);
        };

        for (let item of this._set) {
            if (checkRef && Ref.isRef(item)) { // Only resolve references if there is a state, otherwise it's a merge
                item = item(state.reference || state.parent, options);

                if (Array.isArray(item)) {
                    const found = item.findIndex(isReallyEqual);
                    if (found >= 0) {
                        return {
                            value: item[found]
                        };
                    }

                    continue;
                }
            }

            if (isReallyEqual(item)) {
                return {
                    value: item
                };
            }
        }

        return false;
    }

    values(options) {

        if (options && options.stripUndefined) {
            const values = [];

            for (const item of this._set) {
                if (item !== undefined) {
                    values.push(item);
                }
            }

            return values;
        }

        return Array.from(this._set);
    }

    slice() {

        const set = new InternalSet(this._set);
        set._hasRef = this._hasRef;
        return set;
    }

    concat(source) {

        const set = new InternalSet([...this._set, ...source._set]);
        set._hasRef = !!(this._hasRef | source._hasRef);
        return set;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.Alternatives = class extends Any {

    constructor() {

        super();
        this._type = 'alternatives';
        this._invalids.remove(null);
        this._inner.matches = [];
    }

    _init(...args) {

        return args.length ? this.try(...args) : this;
    }

    _base(value, state, options) {

        const errors = [];
        const il = this._inner.matches.length;
        const baseType = this._baseType;

        for (let i = 0; i < il; ++i) {
            const item = this._inner.matches[i];
            if (!item.schema) {
                const schema = item.peek || item.is;
                const input = item.is ? item.ref(state.reference || state.parent, options) : value;
                const failed = schema._validate(input, null, options, state.parent).errors;

                if (failed) {
                    if (item.otherwise) {
                        return item.otherwise._validate(value, state, options);
                    }
                }
                else if (item.then) {
                    return item.then._validate(value, state, options);
                }

                if (i === (il - 1) && baseType) {
                    return baseType._validate(value, state, options);
                }

                continue;
            }

            const result = item.schema._validate(value, state, options);
            if (!result.errors) {     // Found a valid match
                return result;
            }

            errors.push(...result.errors);
        }

        if (errors.length) {
            return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };
        }

        return { errors: this.createError('alternatives.base', null, state, options) };
    }

    try(...schemas) {

        schemas = Hoek.flatten(schemas);
        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');

        const obj = this.clone();

        for (let i = 0; i < schemas.length; ++i) {
            const cast = Cast.schema(this._currentJoi, schemas[i]);
            if (cast._refs.length) {
                obj._refs.push(...cast._refs);
            }

            obj._inner.matches.push({ schema: cast });
        }

        return obj;
    }

    when(condition, options) {

        let schemaCondition = false;
        Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);
        Hoek.assert(options, 'Missing options');
        Hoek.assert(typeof options === 'object', 'Invalid options');
        if (schemaCondition) {
            Hoek.assert(!options.hasOwnProperty('is'), '"is" can not be used with a schema condition');
        }
        else {
            Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
        }

        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

        const obj = this.clone();
        let is;
        if (!schemaCondition) {
            is = Cast.schema(this._currentJoi, options.is);

            if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {

                // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing
                is = is.required();
            }
        }

        const item = {
            ref: schemaCondition ? null : Cast.ref(condition),
            peek: schemaCondition ? condition : null,
            is,
            then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,
            otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined
        };

        if (obj._baseType) {

            item.then = item.then && obj._baseType.concat(item.then);
            item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);
        }

        if (!schemaCondition) {
            Ref.push(obj._refs, item.ref);
            obj._refs.push(...item.is._refs);
        }

        if (item.then && item.then._refs.length) {
            obj._refs.push(...item.then._refs);
        }

        if (item.otherwise && item.otherwise._refs.length) {
            obj._refs.push(...item.otherwise._refs);
        }

        obj._inner.matches.push(item);

        return obj;
    }

    label(name) {

        const obj = super.label(name);
        obj._inner.matches = obj._inner.matches.map((match) => {

            if (match.schema) {
                return { schema: match.schema.label(name) };
            }

            match = Object.assign({}, match);
            if (match.then) {
                match.then = match.then.label(name);
            }

            if (match.otherwise) {
                match.otherwise = match.otherwise.label(name);
            }

            return match;
        });
        return obj;
    }

    describe() {

        const description = super.describe();
        const alternatives = [];
        for (let i = 0; i < this._inner.matches.length; ++i) {
            const item = this._inner.matches[i];
            if (item.schema) {

                // try()

                alternatives.push(item.schema.describe());
            }
            else {

                // when()

                const when = item.is ? {
                    ref: item.ref.toString(),
                    is: item.is.describe()
                } : {
                    peek: item.peek.describe()
                };

                if (item.then) {
                    when.then = item.then.describe();
                }

                if (item.otherwise) {
                    when.otherwise = item.otherwise.describe();
                }

                alternatives.push(when);
            }
        }

        description.alternatives = alternatives;
        return description;
    }

};


module.exports = new internals.Alternatives();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Settings = __webpack_require__(/*! ./settings */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/settings.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");
const Errors = __webpack_require__(/*! ../../errors */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js");
const State = __webpack_require__(/*! ../state */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js");
const Symbols = __webpack_require__(/*! ../symbols */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js");

const Pkg = __webpack_require__(/*! ../../../package.json */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json");

let Alternatives = null;                            // Delay-loaded to prevent circular dependencies
let Schemas = null;


const internals = {
    Set: __webpack_require__(/*! ../../set */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js"),
    symbol: Symbol.for('@hapi/joi/schema')
};


internals.defaults = {
    abortEarly: true,
    convert: true,
    allowUnknown: false,
    skipFunctions: false,
    stripUnknown: false,
    language: {},
    presence: 'optional',
    noDefaults: false,
    escapeHtml: false

    // context: null
};


module.exports = internals.Any = class {

    constructor() {

        this.isJoi = true;
        this._type = 'any';
        this._settings = null;
        this._valids = new internals.Set();
        this._invalids = new internals.Set();
        this._tests = [];
        this._refs = [];
        this._flags = {
            /*
             presence: 'optional',                   // optional, required, forbidden, ignore
             allowOnly: false,
             allowUnknown: undefined,
             default: undefined,
             forbidden: false,
             encoding: undefined,
             insensitive: false,
             trim: false,
             normalize: undefined,                   // NFC, NFD, NFKC, NFKD
             case: undefined,                        // upper, lower
             empty: undefined,
             func: false,
             raw: false
             */
        };

        this._description = null;
        this._unit = null;
        this._notes = [];
        this._tags = [];
        this._examples = [];
        this._meta = [];

        this._inner = {};                           // Hash of arrays of immutable objects
    }

    _init() {

        return this;
    }

    get schemaType() {

        return this._type;
    }

    createError(type, context, state, options, flags = this._flags) {

        return Errors.create(type, context, state, options, flags);
    }

    createOverrideError(type, context, state, options, message, template) {

        return Errors.create(type, context, state, options, this._flags, message, template);
    }

    checkOptions(options) {

        Schemas = Schemas || __webpack_require__(/*! ../../schemas */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/schemas.js");

        const result = Schemas.options.validate(options);

        if (result.error) {
            throw new Error(result.error.details[0].message);
        }
    }

    clone() {

        const obj = Object.create(Object.getPrototypeOf(this));

        obj.isJoi = true;
        obj._currentJoi = this._currentJoi;
        obj._type = this._type;
        obj._settings = this._settings;
        obj._baseType = this._baseType;
        obj._valids = this._valids.slice();
        obj._invalids = this._invalids.slice();
        obj._tests = this._tests.slice();
        obj._refs = this._refs.slice();
        obj._flags = Hoek.clone(this._flags);

        obj._description = this._description;
        obj._unit = this._unit;
        obj._notes = this._notes.slice();
        obj._tags = this._tags.slice();
        obj._examples = this._examples.slice();
        obj._meta = this._meta.slice();

        obj._inner = {};
        const inners = Object.keys(this._inner);
        for (let i = 0; i < inners.length; ++i) {
            const key = inners[i];
            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
        }

        return obj;
    }

    concat(schema) {

        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');
        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);

        let obj = this.clone();

        if (this._type === 'any' && schema._type !== 'any') {

            // Reset values as if we were "this"
            const tmpObj = schema.clone();
            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',
                '_notes', '_tags', '_examples', '_meta', '_inner'];

            for (let i = 0; i < keysToRestore.length; ++i) {
                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];
            }

            obj = tmpObj;
        }

        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;
        obj._valids.merge(schema._valids, schema._invalids);
        obj._invalids.merge(schema._invalids, schema._valids);
        obj._tests.push(...schema._tests);
        obj._refs.push(...schema._refs);
        if (obj._flags.empty && schema._flags.empty) {
            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);
            const flags = Object.assign({}, schema._flags);
            delete flags.empty;
            Hoek.merge(obj._flags, flags);
        }
        else if (schema._flags.empty) {
            obj._flags.empty = schema._flags.empty;
            const flags = Object.assign({}, schema._flags);
            delete flags.empty;
            Hoek.merge(obj._flags, flags);
        }
        else {
            Hoek.merge(obj._flags, schema._flags);
        }

        obj._description = schema._description || obj._description;
        obj._unit = schema._unit || obj._unit;
        obj._notes.push(...schema._notes);
        obj._tags.push(...schema._tags);
        obj._examples.push(...schema._examples);
        obj._meta.push(...schema._meta);

        const inners = Object.keys(schema._inner);
        const isObject = obj._type === 'object';
        for (let i = 0; i < inners.length; ++i) {
            const key = inners[i];
            const source = schema._inner[key];
            if (source) {
                const target = obj._inner[key];
                if (target) {
                    if (isObject && key === 'children') {
                        const keys = {};

                        for (let j = 0; j < target.length; ++j) {
                            keys[target[j].key] = j;
                        }

                        for (let j = 0; j < source.length; ++j) {
                            const sourceKey = source[j].key;
                            if (keys[sourceKey] >= 0) {
                                target[keys[sourceKey]] = {
                                    key: sourceKey,
                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)
                                };
                            }
                            else {
                                target.push(source[j]);
                            }
                        }
                    }
                    else {
                        obj._inner[key] = obj._inner[key].concat(source);
                    }
                }
                else {
                    obj._inner[key] = source.slice();
                }
            }
        }

        return obj;
    }

    _test(name, arg, func, options) {

        const obj = this.clone();
        obj._tests.push({ func, name, arg, options });
        return obj;
    }

    _testUnique(name, arg, func, options) {

        const obj = this.clone();
        obj._tests = obj._tests.filter((test) => test.name !== name);
        obj._tests.push({ func, name, arg, options });
        return obj;
    }

    options(options) {

        Hoek.assert(!options.context, 'Cannot override context');
        this.checkOptions(options);

        const obj = this.clone();
        obj._settings = Settings.concat(obj._settings, options);
        return obj;
    }

    strict(isStrict) {

        const obj = this.clone();

        const convert = isStrict === undefined ? false : !isStrict;
        obj._settings = Settings.concat(obj._settings, { convert });
        return obj;
    }

    raw(isRaw) {

        const value = isRaw === undefined ? true : isRaw;

        if (this._flags.raw === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.raw = value;
        return obj;
    }

    error(err, options = { self: false }) {

        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');

        const unknownKeys = Object.keys(options).filter((k) => !['self'].includes(k));
        Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);

        const obj = this.clone();
        obj._flags.error = err;

        if (options.self) {
            obj._flags.selfError = true;
        }

        return obj;
    }

    allow(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            obj._invalids.remove(value);
            obj._valids.add(value, obj._refs);
        }

        return obj;
    }

    valid(...values) {

        const obj = this.allow(...values);
        obj._flags.allowOnly = true;
        return obj;
    }

    invalid(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            obj._valids.remove(value);
            obj._invalids.add(value, obj._refs);
        }

        return obj;
    }

    required() {

        if (this._flags.presence === 'required') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'required';
        return obj;
    }

    optional() {

        if (this._flags.presence === 'optional') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'optional';
        return obj;
    }


    forbidden() {

        if (this._flags.presence === 'forbidden') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'forbidden';
        return obj;
    }


    strip() {

        if (this._flags.strip) {
            return this;
        }

        const obj = this.clone();
        obj._flags.strip = true;
        return obj;
    }

    applyFunctionToChildren(children, fn, args = [], root) {

        children = [].concat(children);

        if (children.length !== 1 || children[0] !== '') {
            root = root ? (root + '.') : '';

            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {

                return root + child;
            });

            throw new Error('unknown key(s) ' + extraChildren.join(', '));
        }

        return this[fn](...args);
    }

    default(value, description) {

        if (typeof value === 'function' &&
            !Ref.isRef(value)) {

            if (!value.description &&
                description) {

                value.description = description;
            }

            if (!this._flags.func) {
                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
            }
        }

        const obj = this.clone();
        obj._flags.default = value;
        Ref.push(obj._refs, value);
        return obj;
    }

    empty(schema) {

        const obj = this.clone();
        if (schema === undefined) {
            delete obj._flags.empty;
        }
        else {
            obj._flags.empty = Cast.schema(this._currentJoi, schema);
        }

        return obj;
    }

    when(condition, options) {

        Hoek.assert(options && typeof options === 'object', 'Invalid options');
        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;
        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;

        Alternatives = Alternatives || __webpack_require__(/*! ../alternatives */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js");

        const alternativeOptions = { then, otherwise };
        if (Object.prototype.hasOwnProperty.call(options, 'is')) {
            alternativeOptions.is = options.is;
        }

        const obj = Alternatives.when(condition, alternativeOptions);
        obj._flags.presence = 'ignore';
        obj._baseType = this;

        return obj;
    }

    description(desc) {

        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

        const obj = this.clone();
        obj._description = desc;
        return obj;
    }

    notes(notes) {

        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');

        const obj = this.clone();
        obj._notes = obj._notes.concat(notes);
        return obj;
    }

    tags(tags) {

        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');

        const obj = this.clone();
        obj._tags = obj._tags.concat(tags);
        return obj;
    }

    meta(meta) {

        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');

        const obj = this.clone();
        obj._meta = obj._meta.concat(meta);
        return obj;
    }

    example(...examples) {

        Hoek.assert(examples.length > 0, 'Missing examples');

        const processed = [];
        for (let i = 0; i < examples.length; ++i) {
            const example = [].concat(examples[i]);
            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);

            const value = example[0];
            let options = example[1];
            if (options !== undefined) {
                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);
                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));
                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);
            }
            else {
                options = {};
            }

            const localState = new State('', [], options.parent || null);
            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));
            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));

            const ex = { value };
            if (Object.keys(options).length) {
                ex.options = options;
            }

            processed.push(ex);
        }

        const obj = this.clone();
        obj._examples = processed;
        return obj;
    }

    unit(name) {

        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

        const obj = this.clone();
        obj._unit = name;
        return obj;
    }

    _prepareEmptyValue(value) {

        if (typeof value === 'string' && this._flags.trim) {
            return value.trim();
        }

        return value;
    }

    _validate(value, state, options, reference) {

        const originalValue = value;

        // Setup state and settings

        state = state || new State('', [], null, reference);

        if (this._settings) {
            const isDefaultOptions = options === internals.defaults;
            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {
                options = this._settings[Symbols.settingsCache];
            }
            else {
                options = Settings.concat(this._language ? Settings.concat({ language: this._language }, options) : options, this._settings);
                if (isDefaultOptions) {
                    this._settings[Symbols.settingsCache] = options;
                }
            }
        }
        else if (this._language) {
            options = Settings.concat({ language: this._language }, options);
        }

        let errors = [];

        if (this._coerce) {
            const coerced = this._coerce(value, state, options);
            if (coerced.errors) {
                value = coerced.value;
                errors = errors.concat(coerced.errors);
                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early
            }

            value = coerced.value;
        }

        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {
            value = undefined;
        }

        // Check presence requirements

        const presence = this._flags.presence || options.presence;
        if (presence === 'optional') {
            if (value === undefined) {
                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;
                if (isDeepDefault && this._type === 'object') {
                    value = {};
                }
                else {
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }
            }
        }
        else if (presence === 'required' &&
            value === undefined) {

            errors.push(this.createError('any.required', null, state, options));
            return this._finalizeValue(value, originalValue, errors, state, options);
        }
        else if (presence === 'forbidden') {
            if (value === undefined) {
                return this._finalizeValue(value, originalValue, errors, state, options);
            }

            errors.push(this.createError('any.unknown', null, state, options));
            return this._finalizeValue(value, originalValue, errors, state, options);
        }

        // Check allowed and denied values using the original value

        let match = this._valids.get(value, state, options, this._flags.insensitive);
        if (match) {
            if (options.convert) {
                value = match.value;
            }

            return this._finalizeValue(value, originalValue, errors, state, options);
        }

        if (this._invalids.has(value, state, options, this._flags.insensitive)) {
            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
            if (options.abortEarly) {

                return this._finalizeValue(value, originalValue, errors, state, options);
            }
        }

        // Convert value and validate type

        if (this._base) {
            const base = this._base(value, state, options);
            if (base.errors) {
                value = base.value;
                errors = errors.concat(base.errors);
                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early
            }

            if (base.value !== value) {
                value = base.value;

                // Check allowed and denied values using the converted value

                match = this._valids.get(value, state, options, this._flags.insensitive);
                if (match) {
                    value = match.value;
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }

                if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
                    if (options.abortEarly) {
                        return this._finalizeValue(value, originalValue, errors, state, options);
                    }
                }
            }
        }

        // Required values did not match

        if (this._flags.allowOnly) {
            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));
            if (options.abortEarly) {
                return this._finalizeValue(value, originalValue, errors, state, options);
            }
        }

        // Validate tests

        for (let i = 0; i < this._tests.length; ++i) {
            const test = this._tests[i];
            const ret = test.func.call(this, value, state, options);
            if (ret instanceof Errors.Err) {
                errors.push(ret);
                if (options.abortEarly) {
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }
            }
            else {
                value = ret;
            }
        }

        return this._finalizeValue(value, originalValue, errors, state, options);
    }

    _finalizeValue(value, originalValue, errors, state, options) {

        let finalValue;

        if (value !== undefined) {
            finalValue = this._flags.raw ? originalValue : value;
        }
        else if (options.noDefaults) {
            finalValue = value;
        }
        else if (Ref.isRef(this._flags.default)) {
            finalValue = this._flags.default(state.parent, options);
        }
        else if (typeof this._flags.default === 'function' &&
            !(this._flags.func && !this._flags.default.description)) {

            let args;

            if (state.parent !== null &&
                this._flags.default.length > 0) {

                args = [Hoek.clone(state.parent), options];
            }

            const defaultValue = internals._try(this._flags.default, args);
            finalValue = defaultValue.value;
            if (defaultValue.error) {
                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));
            }
        }
        else {
            finalValue = Hoek.clone(this._flags.default);
        }

        if (errors.length &&
            typeof this._flags.error === 'function' &&
            (
                !this._flags.selfError ||
                errors.some((e) => state.path.length === e.path.length)
            )
        ) {
            const change = this._flags.error.call(this, errors);

            if (typeof change === 'string') {
                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];
            }
            else {
                errors = [].concat(change)
                    .map((err) => {

                        return err instanceof Error ?
                            err :
                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);
                    });
            }
        }

        return {
            value: this._flags.strip ? undefined : finalValue,
            finalValue,
            errors: errors.length ? errors : null
        };
    }

    _validateWithOptions(value, options, callback) {

        if (options) {
            this.checkOptions(options);
        }

        const settings = Settings.concat(internals.defaults, options);
        const result = this._validate(value, null, settings);
        const errors = Errors.process(result.errors, value);

        if (callback) {
            return callback(errors, result.value);
        }

        return {
            error: errors,
            value: result.value,
            then(resolve, reject) {

                if (errors) {
                    return Promise.reject(errors).catch(reject);
                }

                return Promise.resolve(result.value).then(resolve);
            },
            catch(reject) {

                if (errors) {
                    return Promise.reject(errors).catch(reject);
                }

                return Promise.resolve(result.value);
            }
        };
    }

    validate(value, options, callback) {

        if (typeof options === 'function') {
            return this._validateWithOptions(value, null, options);
        }

        return this._validateWithOptions(value, options, callback);
    }

    describe() {

        const description = {
            type: this._type
        };

        const flags = Object.keys(this._flags);
        if (flags.length) {
            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {
                description.flags = {};
                for (let i = 0; i < flags.length; ++i) {
                    const flag = flags[i];
                    if (flag === 'empty') {
                        description.flags[flag] = this._flags[flag].describe();
                    }
                    else if (flag === 'default') {
                        if (Ref.isRef(this._flags[flag])) {
                            description.flags[flag] = this._flags[flag].toString();
                        }
                        else if (typeof this._flags[flag] === 'function') {
                            description.flags[flag] = {
                                description: this._flags[flag].description,
                                function   : this._flags[flag]
                            };
                        }
                        else {
                            description.flags[flag] = this._flags[flag];
                        }
                    }
                    else if (flag === 'lazy' || flag === 'label') {
                        // We don't want it in the description
                    }
                    else {
                        description.flags[flag] = this._flags[flag];
                    }
                }
            }
            else {
                description.flags = this._flags;
            }
        }

        if (this._settings) {
            description.options = Hoek.clone(this._settings);
        }

        if (this._baseType) {
            description.base = this._baseType.describe();
        }

        if (this._description) {
            description.description = this._description;
        }

        if (this._notes.length) {
            description.notes = this._notes;
        }

        if (this._tags.length) {
            description.tags = this._tags;
        }

        if (this._meta.length) {
            description.meta = this._meta;
        }

        if (this._examples.length) {
            description.examples = this._examples;
        }

        if (this._unit) {
            description.unit = this._unit;
        }

        const valids = this._valids.values();
        if (valids.length) {
            description.valids = valids.map((v) => {

                return Ref.isRef(v) ? v.toString() : v;
            });
        }

        const invalids = this._invalids.values();
        if (invalids.length) {
            description.invalids = invalids.map((v) => {

                return Ref.isRef(v) ? v.toString() : v;
            });
        }

        description.rules = [];

        for (let i = 0; i < this._tests.length; ++i) {
            const validator = this._tests[i];
            const item = { name: validator.name };

            if (validator.arg !== void 0) {
                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;
            }

            const options = validator.options;
            if (options) {
                if (options.hasRef) {
                    item.arg = {};
                    const keys = Object.keys(validator.arg);
                    for (let j = 0; j < keys.length; ++j) {
                        const key = keys[j];
                        const value = validator.arg[key];
                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;
                    }
                }

                if (typeof options.description === 'string') {
                    item.description = options.description;
                }
                else if (typeof options.description === 'function') {
                    item.description = options.description(item.arg);
                }
            }

            description.rules.push(item);
        }

        if (!description.rules.length) {
            delete description.rules;
        }

        const label = this._getLabel();
        if (label) {
            description.label = label;
        }

        return description;
    }

    label(name) {

        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');

        const obj = this.clone();
        obj._flags.label = name;
        return obj;
    }

    _getLabel(def) {

        return this._flags.label || def;
    }

};


internals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects

// Aliases

internals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;
internals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;
internals.Any.prototype.exist = internals.Any.prototype.required;


internals.Any.prototype[internals.symbol] = {
    version: Pkg.version,
    compile: Cast.schema,
    root: '_currentJoi'
};


internals._try = function (fn, args = []) {

    let err;
    let result;

    try {
        result = fn(...args);
    }
    catch (e) {
        err = e;
    }

    return {
        value: result,
        error: err
    };
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/settings.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/settings.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Symbols = __webpack_require__(/*! ../symbols */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js");


const internals = {};


exports.concat = function (target, source) {

    if (!source) {
        return target;
    }

    const obj = Object.assign({}, target);

    const language = source.language;

    Object.assign(obj, source);

    if (language && target && target.language) {
        obj.language = Hoek.applyToDefaults(target.language, language);
    }

    if (obj[Symbols.settingsCache]) {
        delete obj[Symbols.settingsCache];
    }

    return obj;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/array/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/array/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");
const State = __webpack_require__(/*! ../state */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js");


const internals = {};


internals.fastSplice = function (arr, i) {

    let pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];
    }

    --arr.length;
};


internals.Array = class extends Any {

    constructor() {

        super();
        this._type = 'array';
        this._inner.items = [];
        this._inner.ordereds = [];
        this._inner.inclusions = [];
        this._inner.exclusions = [];
        this._inner.requireds = [];
        this._flags.sparse = false;
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            if (value.length > 1 &&
                (value[0] === '[' || /^\s*\[/.test(value))) {

                try {
                    result.value = Bourne.parse(value);
                }
                catch (e) { }
            }
        }

        let isArray = Array.isArray(result.value);
        const wasArray = isArray;
        if (options.convert && this._flags.single && !isArray) {
            result.value = [result.value];
            isArray = true;
        }

        if (!isArray) {
            result.errors = this.createError('array.base', null, state, options);
            return result;
        }

        if (this._inner.inclusions.length ||
            this._inner.exclusions.length ||
            this._inner.requireds.length ||
            this._inner.ordereds.length ||
            !this._flags.sparse) {

            // Clone the array so that we don't modify the original
            if (wasArray) {
                result.value = result.value.slice(0);
            }

            result.errors = this._checkItems(result.value, wasArray, state, options);

            if (result.errors && wasArray && options.convert && this._flags.single) {

                // Attempt a 2nd pass by putting the array inside one.
                const previousErrors = result.errors;

                result.value = [result.value];
                result.errors = this._checkItems(result.value, wasArray, state, options);

                if (result.errors) {

                    // Restore previous errors and value since this didn't validate either.
                    result.errors = previousErrors;
                    result.value = result.value[0];
                }
            }
        }

        return result;
    }

    _checkItems(items, wasArray, state, options) {

        const errors = [];
        let errored;

        const requireds = this._inner.requireds.slice();
        const ordereds = this._inner.ordereds.slice();
        const inclusions = [...this._inner.inclusions, ...requireds];

        let il = items.length;
        for (let i = 0; i < il; ++i) {
            errored = false;
            const item = items[i];
            let isValid = false;
            const key = wasArray ? i : state.key;
            const path = wasArray ? [...state.path, i] : state.path;
            const localState = new State(key, path, state.parent, state.reference);
            let res;

            // Sparse

            if (!this._flags.sparse && item === undefined) {
                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                if (options.abortEarly) {
                    return errors;
                }

                ordereds.shift();

                continue;
            }

            // Exclusions

            for (let j = 0; j < this._inner.exclusions.length; ++j) {
                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults

                if (!res.errors) {
                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;

                    if (options.abortEarly) {
                        return errors;
                    }

                    ordereds.shift();

                    break;
                }
            }

            if (errored) {
                continue;
            }

            // Ordered
            if (this._inner.ordereds.length) {
                if (ordereds.length > 0) {
                    const ordered = ordereds.shift();
                    res = ordered._validate(item, localState, options);
                    if (!res.errors) {
                        if (ordered._flags.strip) {
                            internals.fastSplice(items, i);
                            --i;
                            --il;
                        }
                        else if (!this._flags.sparse && res.value === undefined) {
                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                            if (options.abortEarly) {
                                return errors;
                            }

                            continue;
                        }
                        else {
                            items[i] = res.value;
                        }
                    }
                    else {
                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                        if (options.abortEarly) {
                            return errors;
                        }
                    }

                    continue;
                }
                else if (!this._inner.items.length) {
                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
                    if (options.abortEarly) {
                        return errors;
                    }

                    continue;
                }
            }

            // Requireds

            const requiredChecks = [];
            let jl = requireds.length;
            for (let j = 0; j < jl; ++j) {
                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);
                if (!res.errors) {
                    items[i] = res.value;
                    isValid = true;
                    internals.fastSplice(requireds, j);
                    --j;
                    --jl;

                    if (!this._flags.sparse && res.value === undefined) {
                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                        if (options.abortEarly) {
                            return errors;
                        }
                    }

                    break;
                }
            }

            if (isValid) {
                continue;
            }

            // Inclusions

            const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;

            jl = inclusions.length;
            for (let j = 0; j < jl; ++j) {
                const inclusion = inclusions[j];

                // Avoid re-running requireds that already didn't match in the previous loop
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                    res = requiredChecks[previousCheck];
                }
                else {
                    res = inclusion._validate(item, localState, options);

                    if (!res.errors) {
                        if (inclusion._flags.strip) {
                            internals.fastSplice(items, i);
                            --i;
                            --il;
                        }
                        else if (!this._flags.sparse && res.value === undefined) {
                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));
                            errored = true;
                        }
                        else {
                            items[i] = res.value;
                        }

                        isValid = true;
                        break;
                    }
                }

                // Return the actual error if only one inclusion defined
                if (jl === 1) {
                    if (stripUnknown) {
                        internals.fastSplice(items, i);
                        --i;
                        --il;
                        isValid = true;
                        break;
                    }

                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;

                    if (options.abortEarly) {
                        return errors;
                    }

                    break;
                }
            }

            if (errored) {
                continue;
            }

            if (this._inner.inclusions.length && !isValid) {
                if (stripUnknown) {
                    internals.fastSplice(items, i);
                    --i;
                    --il;
                    continue;
                }

                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));

                if (options.abortEarly) {
                    return errors;
                }
            }
        }

        if (requireds.length) {
            this._fillMissedErrors(errors, requireds, state, options);
        }

        if (ordereds.length) {
            this._fillOrderedErrors(errors, ordereds, state, options);
        }

        return errors.length ? errors : null;
    }

    describe() {

        const description = super.describe();

        if (this._inner.ordereds.length) {
            description.orderedItems = [];

            for (let i = 0; i < this._inner.ordereds.length; ++i) {
                description.orderedItems.push(this._inner.ordereds[i].describe());
            }
        }

        if (this._inner.items.length) {
            description.items = [];

            for (let i = 0; i < this._inner.items.length; ++i) {
                description.items.push(this._inner.items[i].describe());
            }
        }

        if (description.rules) {
            for (let i = 0; i < description.rules.length; ++i) {
                const rule = description.rules[i];
                if (rule.name === 'has') {
                    rule.arg = rule.arg.describe();
                }
            }
        }

        return description;
    }

    items(...schemas) {

        const obj = this.clone();

        Hoek.flatten(schemas).forEach((type, index) => {

            try {
                type = Cast.schema(this._currentJoi, type);
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = index + '.' + castErr.path;
                }
                else {
                    castErr.path = index;
                }

                castErr.message = `${castErr.message}(${castErr.path})`;
                throw castErr;
            }

            obj._inner.items.push(type);

            if (type._flags.presence === 'required') {
                obj._inner.requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                obj._inner.exclusions.push(type.optional());
            }
            else {
                obj._inner.inclusions.push(type);
            }
        });

        return obj;
    }

    ordered(...schemas) {

        const obj = this.clone();

        Hoek.flatten(schemas).forEach((type, index) => {

            try {
                type = Cast.schema(this._currentJoi, type);
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = index + '.' + castErr.path;
                }
                else {
                    castErr.path = index;
                }

                castErr.message = `${castErr.message}(${castErr.path})`;
                throw castErr;
            }

            obj._inner.ordereds.push(type);
        });

        return obj;
    }

    min(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('min', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit, value: compareTo }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length >= compareTo) {
                return value;
            }

            return this.createError('array.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('max', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length <= compareTo) {
                return value;
            }

            return this.createError('array.max', { limit, value }, state, options);
        });
    }

    length(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('length', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length === compareTo) {
                return value;
            }

            return this.createError('array.length', { limit, value }, state, options);
        });
    }

    has(schema) {

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        return this._test('has', schema, function (value, state, options) {

            const isValid = value.some((item, idx) => {

                const localState = new State(idx, [...state.path, idx], state.key, state.reference);
                return !schema._validate(item, localState, options).errors;
            });

            if (isValid) {
                return value;
            }

            const patternLabel = schema._getLabel();
            if (patternLabel) {
                return this.createError('array.hasKnown', { patternLabel }, state, options);
            }

            return this.createError('array.hasUnknown', null, state, options);
        });
    }

    unique(comparator, configs) {

        Hoek.assert(comparator === undefined ||
            typeof comparator === 'function' ||
            typeof comparator === 'string', 'comparator must be a function or a string');

        Hoek.assert(configs === undefined ||
            typeof configs === 'object', 'configs must be an object');

        const settings = {
            ignoreUndefined: (configs && configs.ignoreUndefined) || false
        };


        if (typeof comparator === 'string') {
            settings.path = comparator;
        }
        else if (typeof comparator === 'function') {
            settings.comparator = comparator;
        }

        return this._test('unique', settings, function (value, state, options) {

            const found = {
                string: Object.create(null),
                number: Object.create(null),
                undefined: Object.create(null),
                boolean: Object.create(null),
                object: new Map(),
                function: new Map(),
                custom: new Map()
            };

            const compare = settings.comparator || Hoek.deepEqual;
            const ignoreUndefined = settings.ignoreUndefined;

            for (let i = 0; i < value.length; ++i) {
                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];
                const records = settings.comparator ? found.custom : found[typeof item];

                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
                // I still want to keep the test for future js versions with new types (eg. Symbol).
                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {
                    if (records instanceof Map) {
                        const entries = records.entries();
                        let current;
                        while (!(current = entries.next()).done) {
                            if (compare(current.value[0], item)) {
                                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);
                                const context = {
                                    pos: i,
                                    value: value[i],
                                    dupePos: current.value[1],
                                    dupeValue: value[current.value[1]]
                                };

                                if (settings.path) {
                                    context.path = settings.path;
                                }

                                return this.createError('array.unique', context, localState, options);
                            }
                        }

                        records.set(item, i);
                    }
                    else {
                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {
                            const localState = new State(state.key, [...state.path, i], state.parent, state.reference);

                            const context = {
                                pos: i,
                                value: value[i],
                                dupePos: records[item],
                                dupeValue: value[records[item]]
                            };

                            if (settings.path) {
                                context.path = settings.path;
                            }

                            return this.createError('array.unique', context, localState, options);
                        }

                        records[item] = i;
                    }
                }
            }

            return value;
        });
    }

    sparse(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.sparse === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.sparse = value;
        return obj;
    }

    single(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.single === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.single = value;
        return obj;
    }

    _fillMissedErrors(errors, requireds, state, options) {

        const knownMisses = [];
        let unknownMisses = 0;
        for (let i = 0; i < requireds.length; ++i) {
            const label = requireds[i]._getLabel();
            if (label) {
                knownMisses.push(label);
            }
            else {
                ++unknownMisses;
            }
        }

        if (knownMisses.length) {
            if (unknownMisses) {
                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));
            }
            else {
                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));
            }
        }
        else {
            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));
        }
    }


    _fillOrderedErrors(errors, ordereds, state, options) {

        const requiredOrdereds = [];

        for (let i = 0; i < ordereds.length; ++i) {
            const presence = Hoek.reach(ordereds[i], '_flags.presence');
            if (presence === 'required') {
                requiredOrdereds.push(ordereds[i]);
            }
        }

        if (requiredOrdereds.length) {
            this._fillMissedErrors(errors, requiredOrdereds, state, options);
        }
    }

};


module.exports = new internals.Array();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/binary/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/binary/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Binary = class extends Any {

    constructor() {

        super();
        this._type = 'binary';
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            try {
                result.value = Buffer.from(value, this._flags.encoding);
            }
            catch (e) { }
        }

        result.errors = Buffer.isBuffer(result.value) ? null : this.createError('binary.base', null, state, options);
        return result;
    }

    encoding(encoding) {

        Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

        if (this._flags.encoding === encoding) {
            return this;
        }

        const obj = this.clone();
        obj._flags.encoding = encoding;
        return obj;
    }

    min(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('min', limit, function (value, state, options) {

            if (value.length >= limit) {
                return value;
            }

            return this.createError('binary.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('max', limit, function (value, state, options) {

            if (value.length <= limit) {
                return value;
            }

            return this.createError('binary.max', { limit, value }, state, options);
        });
    }

    length(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('length', limit, function (value, state, options) {

            if (value.length === limit) {
                return value;
            }

            return this.createError('binary.length', { limit, value }, state, options);
        });
    }

};


module.exports = new internals.Binary();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/boolean/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/boolean/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {
    Set: __webpack_require__(/*! ../../set */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js")
};


internals.Boolean = class extends Any {
    constructor() {

        super();
        this._type = 'boolean';
        this._flags.insensitive = true;
        this._inner.truthySet = new internals.Set();
        this._inner.falsySet = new internals.Set();
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            const normalized = this._flags.insensitive ? value.toLowerCase() : value;
            result.value = (normalized === 'true' ? true
                : (normalized === 'false' ? false : value));
        }

        if (typeof result.value !== 'boolean') {
            result.value = (this._inner.truthySet.has(value, null, null, this._flags.insensitive) ? true
                : (this._inner.falsySet.has(value, null, null, this._flags.insensitive) ? false : value));
        }

        result.errors = (typeof result.value === 'boolean') ? null : this.createError('boolean.base', { value }, state, options);
        return result;
    }

    truthy(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call truthy with undefined');
            obj._inner.truthySet.add(value);
        }

        return obj;
    }

    falsy(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call falsy with undefined');
            obj._inner.falsySet.add(value);
        }

        return obj;
    }

    insensitive(enabled) {

        const insensitive = enabled === undefined ? true : !!enabled;

        if (this._flags.insensitive === insensitive) {
            return this;
        }

        const obj = this.clone();
        obj._flags.insensitive = insensitive;
        return obj;
    }

    describe() {

        const description = super.describe();
        description.truthy = [true, ...this._inner.truthySet.values()];
        description.falsy = [false, ...this._inner.falsySet.values()];
        return description;
    }
};


module.exports = new internals.Boolean();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};

internals.isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
internals.invalidDate = new Date('');
internals.isIsoDate = (() => {

    const isoString = internals.isoDate.toString();

    return (date) => {

        return date && (date.toString() === isoString);
    };
})();

internals.Date = class extends Any {

    constructor() {

        super();
        this._type = 'date';
    }

    _base(value, state, options) {

        const result = {
            value: (options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier)) || value
        };

        if (result.value instanceof Date && !isNaN(result.value.getTime())) {
            result.errors = null;
        }
        else if (!options.convert) {
            result.errors = this.createError('date.strict', { value }, state, options);
        }
        else {
            let type;
            if (internals.isIsoDate(this._flags.format)) {
                type = 'isoDate';
            }
            else if (this._flags.timestamp) {
                type = `timestamp.${this._flags.timestamp}`;
            }
            else {
                type = 'base';
            }

            result.errors = this.createError(`date.${type}`, { value }, state, options);
        }

        return result;
    }

    static toDate(value, format, timestamp, multiplier) {

        if (value instanceof Date) {
            return value;
        }

        if (typeof value === 'string' ||
            (typeof value === 'number' && !isNaN(value) && isFinite(value))) {

            const isIsoDate = format && internals.isIsoDate(format);
            if (!isIsoDate &&
                typeof value === 'string' &&
                /^[+-]?\d+(\.\d+)?$/.test(value)) {

                value = parseFloat(value);
            }

            let date;
            if (isIsoDate) {
                date = format.test(value) ? new Date(value.toString()) : internals.invalidDate;
            }
            else if (timestamp) {
                date = /^\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);
            }
            else {
                date = new Date(value);
            }

            if (!isNaN(date.getTime())) {
                return date;
            }
        }

        return null;
    }

    iso() {

        if (this._flags.format === internals.isoDate) {
            return this;
        }

        const obj = this.clone();
        obj._flags.format = internals.isoDate;
        return obj;
    }

    timestamp(type = 'javascript') {

        const allowed = ['javascript', 'unix'];
        Hoek.assert(allowed.includes(type), '"type" must be one of "' + allowed.join('", "') + '"');

        if (this._flags.timestamp === type) {
            return this;
        }

        const obj = this.clone();
        obj._flags.timestamp = type;
        obj._flags.multiplier = type === 'unix' ? 1000 : 1;
        return obj;
    }

    _isIsoDate(value) {

        return internals.isoDate.test(value);
    }

};

internals.compare = function (type, compare) {

    return function (date) {

        const isNow = date === 'now';
        const isRef = Ref.isRef(date);

        if (!isNow && !isRef) {
            date = internals.Date.toDate(date);
        }

        Hoek.assert(date, 'Invalid date format');

        return this._test(type, date, function (value, state, options) {

            let compareTo;
            if (isNow) {
                compareTo = Date.now();
            }
            else if (isRef) {
                const refValue = date(state.reference || state.parent, options);
                compareTo = internals.Date.toDate(refValue);

                if (!compareTo) {
                    return this.createError('date.ref', { ref: date, value: refValue }, state, options);
                }

                compareTo = compareTo.getTime();
            }
            else {
                compareTo = date.getTime();
            }

            if (compare(value.getTime(), compareTo)) {
                return value;
            }

            return this.createError('date.' + type, { limit: new Date(compareTo), value }, state, options);
        });
    };
};


internals.Date.prototype.min = internals.compare('min', (value, date) => value >= date);
internals.Date.prototype.max = internals.compare('max', (value, date) => value <= date);
internals.Date.prototype.greater = internals.compare('greater', (value, date) => value > date);
internals.Date.prototype.less = internals.compare('less', (value, date) => value < date);


module.exports = new internals.Date();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/func/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/func/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const ObjectType = __webpack_require__(/*! ../object */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.Func = class extends ObjectType.constructor {

    constructor() {

        super();
        this._flags.func = true;
    }

    arity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

        return this._test('arity', n, function (value, state, options) {

            if (value.length === n) {
                return value;
            }

            return this.createError('function.arity', { n }, state, options);
        });
    }

    minArity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

        return this._test('minArity', n, function (value, state, options) {

            if (value.length >= n) {
                return value;
            }

            return this.createError('function.minArity', { n }, state, options);
        });
    }

    maxArity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

        return this._test('maxArity', n, function (value, state, options) {

            if (value.length <= n) {
                return value;
            }

            return this.createError('function.maxArity', { n }, state, options);
        });
    }

    ref() {

        return this._test('ref', null, function (value, state, options) {

            if (Ref.isRef(value)) {
                return value;
            }

            return this.createError('function.ref', { value }, state, options);
        });
    }

    class() {

        return this._test('class', null, function (value, state, options) {

            if ((/^\s*class\s/).test(value.toString())) {
                return value;
            }

            return this.createError('function.class', { value }, state, options);
        });
    }
};

module.exports = new internals.Func();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/lazy/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/lazy/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Lazy = class extends Any {

    constructor() {

        super();
        this._type = 'lazy';
        this._flags.once = true;
        this._cache = null;
    }

    _init(fn, options) {

        return this.set(fn, options);
    }

    _base(value, state, options) {

        let schema;
        if (this._cache) {
            schema = this._cache;
        }
        else {
            const result = { value };
            const lazy = this._flags.lazy;

            if (!lazy) {
                result.errors = this.createError('lazy.base', null, state, options);
                return result;
            }

            schema = lazy();

            if (!(schema instanceof Any)) {
                result.errors = this.createError('lazy.schema', { schema }, state, options);
                return result;
            }

            if (this._flags.once) {
                this._cache = schema;
            }
        }

        return schema._validate(value, state, options);
    }

    set(fn, options) {

        Hoek.assert(typeof fn === 'function', 'You must provide a function as first argument');
        Hoek.assert(options === undefined || (options && typeof options === 'object' && !Array.isArray(options)), `Options must be an object`);

        if (options) {
            const unknownOptions = Object.keys(options).filter((key) => !['once'].includes(key));
            Hoek.assert(unknownOptions.length === 0, `Options contain unknown keys: ${unknownOptions}`);
            Hoek.assert(options.once === undefined || typeof options.once === 'boolean', 'Option "once" must be a boolean');
        }

        const obj = this.clone();
        obj._flags.lazy = fn;

        if (options && options.once !== obj._flags.once) {
            obj._flags.once = options.once;
        }

        return obj;
    }

};

module.exports = new internals.Lazy();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/number/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/number/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
    normalizeExponent(str) {

        return str
            .replace(/\.?0+e/, 'e')
            .replace(/e\+/, 'e')
            .replace(/^\+/, '')
            .replace(/^(-?)0+([1-9])/, '$1$2');
    },
    normalizeDecimal(str) {

        str = str
            .replace(/^\+/, '')
            .replace(/\.0+$/, '')
            .replace(/^(-?)0+([1-9])/, '$1$2');

        if (str.includes('.') && str.endsWith('0')) {
            str = str.replace(/0+$/, '');
        }

        return str;
    }
};


internals.Number = class extends Any {

    constructor() {

        super();
        this._type = 'number';
        this._flags.unsafe = false;
        this._invalids.add(Infinity);
        this._invalids.add(-Infinity);
    }

    _base(value, state, options) {

        const result = {
            errors: null,
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            const matches = value.match(/^\s*[+-]?\d+(?:\.\d+)?(?:e([+-]?\d+))?\s*$/i);
            if (matches) {

                value = value.trim();
                result.value = parseFloat(value);

                if (!this._flags.unsafe) {
                    if (value.includes('e')) {
                        if (internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`) !== internals.normalizeExponent(value)) {
                            result.errors = this.createError('number.unsafe', { value }, state, options);
                            return result;
                        }
                    }
                    else {
                        if (result.value.toString() !== internals.normalizeDecimal(value)) {
                            result.errors = this.createError('number.unsafe', { value }, state, options);
                            return result;
                        }
                    }
                }
            }
        }

        const isNumber = typeof result.value === 'number' && !isNaN(result.value);

        if (options.convert && 'precision' in this._flags && isNumber) {

            // This is conceptually equivalent to using toFixed but it should be much faster
            const precision = Math.pow(10, this._flags.precision);
            result.value = Math.round(result.value * precision) / precision;
        }

        if (isNumber) {
            if (!this._flags.unsafe &&
                (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
                result.errors = this.createError('number.unsafe', { value }, state, options);
            }
        }
        else {
            result.errors = this.createError('number.base', { value }, state, options);
        }

        return result;
    }

    multiple(base) {

        const isRef = Ref.isRef(base);

        if (!isRef) {
            Hoek.assert(typeof base === 'number' && isFinite(base), 'multiple must be a number');
            Hoek.assert(base > 0, 'multiple must be greater than 0');
        }

        return this._test('multiple', base, function (value, state, options) {

            const divisor = isRef ? base(state.reference || state.parent, options) : base;

            if (isRef && (typeof divisor !== 'number' || !isFinite(divisor))) {
                return this.createError('number.ref', { ref: base.key }, state, options);
            }

            if (value % divisor === 0) {
                return value;
            }

            return this.createError('number.multiple', { multiple: base, value }, state, options);
        });
    }

    integer() {

        return this._test('integer', undefined, function (value, state, options) {

            return Math.trunc(value) - value === 0 ? value : this.createError('number.integer', { value }, state, options);
        });
    }

    unsafe(enabled = true) {

        Hoek.assert(typeof enabled === 'boolean', 'enabled must be a boolean');

        if (this._flags.unsafe === enabled) {
            return this;
        }

        const obj = this.clone();
        obj._flags.unsafe = enabled;
        return obj;
    }

    negative() {

        return this._test('negative', undefined, function (value, state, options) {

            if (value < 0) {
                return value;
            }

            return this.createError('number.negative', { value }, state, options);
        });
    }

    positive() {

        return this._test('positive', undefined, function (value, state, options) {

            if (value > 0) {
                return value;
            }

            return this.createError('number.positive', { value }, state, options);
        });
    }

    precision(limit) {

        Hoek.assert(Number.isSafeInteger(limit), 'limit must be an integer');
        Hoek.assert(!('precision' in this._flags), 'precision already set');

        const obj = this._test('precision', limit, function (value, state, options) {

            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
                return value;
            }

            return this.createError('number.precision', { limit, value }, state, options);
        });

        obj._flags.precision = limit;
        return obj;
    }

    port() {

        return this._test('port', undefined, function (value, state, options) {

            if (!Number.isSafeInteger(value) || value < 0 || value > 65535) {
                return this.createError('number.port', { value }, state, options);
            }

            return value;
        });
    }

};


internals.compare = function (type, compare) {

    return function (limit) {

        const isRef = Ref.isRef(limit);
        const isNumber = typeof limit === 'number' && !isNaN(limit);

        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');

        return this._test(type, limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {
                    return this.createError('number.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (compare(value, compareTo)) {
                return value;
            }

            return this.createError('number.' + type, { limit: compareTo, value }, state, options);
        });
    };
};


internals.Number.prototype.min = internals.compare('min', (value, limit) => value >= limit);
internals.Number.prototype.max = internals.compare('max', (value, limit) => value <= limit);
internals.Number.prototype.greater = internals.compare('greater', (value, limit) => value > limit);
internals.Number.prototype.less = internals.compare('less', (value, limit) => value < limit);


module.exports = new internals.Number();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./node_modules/@hapi/topo/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Errors = __webpack_require__(/*! ../../errors */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js");
const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const State = __webpack_require__(/*! ../state */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js");


const internals = {};


internals.Object = class extends Any {

    constructor() {

        super();
        this._type = 'object';
        this._inner.children = null;
        this._inner.renames = [];
        this._inner.dependencies = [];
        this._inner.patterns = [];
    }

    _init(...args) {

        return args.length ? this.keys(...args) : this;
    }

    _base(value, state, options) {

        let target = value;
        const errors = [];
        const finish = () => {

            return {
                value: target,
                errors: errors.length ? errors : null
            };
        };

        if (typeof value === 'string' &&
            options.convert) {

            if (value.length > 1 &&
                (value[0] === '{' || /^\s*\{/.test(value))) {

                try {
                    value = Bourne.parse(value);
                }
                catch (e) { }
            }
        }

        const type = this._flags.func ? 'function' : 'object';
        if (!value ||
            typeof value !== type ||
            Array.isArray(value)) {

            errors.push(this.createError(type + '.base', { value }, state, options));
            return finish();
        }

        // Skip if there are no other rules to test

        if (!this._inner.renames.length &&
            !this._inner.dependencies.length &&
            !this._inner.children &&                    // null allows any keys
            !this._inner.patterns.length) {

            target = value;
            return finish();
        }

        // Ensure target is a local copy (parsed) or shallow copy

        if (target === value) {
            if (type === 'object') {
                target = Object.create(Object.getPrototypeOf(value));
            }
            else {
                target = function (...args) {

                    return value.apply(this, args);
                };

                target.prototype = Hoek.clone(value.prototype);
            }

            const valueKeys = Object.keys(value);
            for (let i = 0; i < valueKeys.length; ++i) {
                target[valueKeys[i]] = value[valueKeys[i]];
            }
        }
        else {
            target = value;
        }

        // Rename keys

        const renamed = {};
        for (let i = 0; i < this._inner.renames.length; ++i) {
            const rename = this._inner.renames[i];

            if (rename.isRegExp) {
                const targetKeys = Object.keys(target);
                const matchedTargetKeys = [];

                for (let j = 0; j < targetKeys.length; ++j) {
                    if (rename.from.test(targetKeys[j])) {
                        matchedTargetKeys.push(targetKeys[j]);
                    }
                }

                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);
                if (rename.options.ignoreUndefined && allUndefined) {
                    continue;
                }

                if (!rename.options.multiple &&
                    renamed[rename.to]) {

                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&
                    !rename.options.override &&
                    !renamed[rename.to]) {

                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (allUndefined) {
                    delete target[rename.to];
                }
                else {
                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];
                }

                renamed[rename.to] = true;

                if (!rename.options.alias) {
                    for (let j = 0; j < matchedTargetKeys.length; ++j) {
                        delete target[matchedTargetKeys[j]];
                    }
                }
            }
            else {
                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {
                    continue;
                }

                if (!rename.options.multiple &&
                    renamed[rename.to]) {

                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&
                    !rename.options.override &&
                    !renamed[rename.to]) {

                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (target[rename.from] === undefined) {
                    delete target[rename.to];
                }
                else {
                    target[rename.to] = target[rename.from];
                }

                renamed[rename.to] = true;

                if (!rename.options.alias) {
                    delete target[rename.from];
                }
            }
        }

        // Validate schema

        if (!this._inner.children &&            // null allows any keys
            !this._inner.patterns.length &&
            !this._inner.dependencies.length) {

            return finish();
        }

        const unprocessed = new Set(Object.keys(target));

        if (this._inner.children) {
            const stripProps = [];

            for (let i = 0; i < this._inner.children.length; ++i) {
                const child = this._inner.children[i];
                const key = child.key;
                const item = target[key];

                unprocessed.delete(key);

                const localState = new State(key, [...state.path, key], target, state.reference);
                const result = child.schema._validate(item, localState, options);
                if (result.errors) {
                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));

                    if (options.abortEarly) {
                        return finish();
                    }
                }
                else {
                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {
                        stripProps.push(key);
                        target[key] = result.finalValue;
                    }
                    else if (result.value !== undefined) {
                        target[key] = result.value;
                    }
                }
            }

            for (let i = 0; i < stripProps.length; ++i) {
                delete target[stripProps[i]];
            }
        }

        // Unknown keys

        if (unprocessed.size && this._inner.patterns.length) {

            for (const key of unprocessed) {
                const localState = new State(key, [...state.path, key], target, state.reference);
                const item = target[key];

                for (let i = 0; i < this._inner.patterns.length; ++i) {
                    const pattern = this._inner.patterns[i];

                    if (pattern.regex ?
                        pattern.regex.test(key) :
                        !pattern.schema._validate(key, state, { ...options, abortEarly:true }).errors) {

                        unprocessed.delete(key);

                        const result = pattern.rule._validate(item, localState, options);
                        if (result.errors) {
                            errors.push(this.createError('object.child', {
                                key,
                                child: pattern.rule._getLabel(key),
                                reason: result.errors
                            }, localState, options));

                            if (options.abortEarly) {
                                return finish();
                            }
                        }

                        target[key] = result.value;
                    }
                }
            }
        }

        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {
            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||
                options.skipFunctions) {

                const stripUnknown = options.stripUnknown
                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)
                    : false;


                for (const key of unprocessed) {
                    if (stripUnknown) {
                        delete target[key];
                        unprocessed.delete(key);
                    }
                    else if (typeof target[key] === 'function') {
                        unprocessed.delete(key);
                    }
                }
            }

            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {

                for (const unprocessedKey of unprocessed) {
                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {
                        key: unprocessedKey,
                        path: [...state.path, unprocessedKey]
                    }, options, {}));
                }
            }
        }

        // Validate dependencies

        for (let i = 0; i < this._inner.dependencies.length; ++i) {
            const dep = this._inner.dependencies[i];
            const hasKey = dep.key !== null;
            const splitKey = hasKey && dep.key.split('.');
            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);
            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, { functions: true }), dep.peers, target, localState, options);
            if (err instanceof Errors.Err) {
                errors.push(err);
                if (options.abortEarly) {
                    return finish();
                }
            }
        }

        return finish();
    }

    keys(schema) {

        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');

        const obj = this.clone();

        if (!schema) {
            obj._inner.children = null;
            return obj;
        }

        const children = Object.keys(schema);

        if (!children.length) {
            obj._inner.children = [];
            return obj;
        }

        const topo = new Topo();
        if (obj._inner.children) {
            for (let i = 0; i < obj._inner.children.length; ++i) {
                const child = obj._inner.children[i];

                // Only add the key if we are not going to replace it later
                if (!children.includes(child.key)) {
                    topo.add(child, { after: child._refs, group: child.key });
                }
            }
        }

        for (let i = 0; i < children.length; ++i) {
            const key = children[i];
            const child = schema[key];
            try {
                const cast = Cast.schema(this._currentJoi, child);
                topo.add({ key, schema: cast }, { after: cast._refs, group: key });
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = key + '.' + castErr.path;
                }
                else {
                    castErr.path = key;
                }

                throw castErr;
            }
        }

        obj._inner.children = topo.nodes;

        return obj;
    }

    append(schema) {
        // Skip any changes
        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
            return this;
        }

        return this.keys(schema);
    }

    unknown(allow) {

        const value = allow !== false;

        if (this._flags.allowUnknown === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.allowUnknown = value;
        return obj;
    }

    length(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('length', limit, function (value, state, options) {

            if (Object.keys(value).length === limit) {
                return value;
            }

            return this.createError('object.length', { limit, value }, state, options);
        });
    }

    min(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('min', limit, function (value, state, options) {

            if (Object.keys(value).length >= limit) {
                return value;
            }

            return this.createError('object.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('max', limit, function (value, state, options) {

            if (Object.keys(value).length <= limit) {
                return value;
            }

            return this.createError('object.max', { limit, value }, state, options);
        });
    }

    pattern(pattern, schema) {

        const isRegExp = pattern instanceof RegExp;
        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');
        Hoek.assert(schema !== undefined, 'Invalid rule');

        if (isRegExp) {
            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
        }

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        const obj = this.clone();
        if (isRegExp) {
            obj._inner.patterns.push({ regex: pattern, rule: schema });
        }
        else {
            obj._inner.patterns.push({ schema: pattern, rule: schema });
        }

        return obj;
    }

    schema() {

        return this._test('schema', null, function (value, state, options) {

            if (value instanceof Any) {
                return value;
            }

            return this.createError('object.schema', null, state, options);
        });
    }

    with(key, peers) {

        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

        return this._dependency('with', key, peers);
    }

    without(key, peers) {

        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

        return this._dependency('without', key, peers);
    }

    xor(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('xor', null, peers);
    }

    oxor(...peers) {

        return this._dependency('oxor', null, peers);
    }

    or(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('or', null, peers);
    }

    and(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('and', null, peers);
    }

    nand(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('nand', null, peers);
    }

    requiredKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'required');
    }

    optionalKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'optional');
    }

    forbiddenKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'forbidden');
    }

    rename(from, to, options) {

        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

        for (let i = 0; i < this._inner.renames.length; ++i) {
            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
        }

        const obj = this.clone();

        obj._inner.renames.push({
            from,
            to,
            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),
            isRegExp: from instanceof RegExp
        });

        return obj;
    }

    applyFunctionToChildren(children, fn, args = [], root) {

        children = [].concat(children);
        Hoek.assert(children.length > 0, 'expected at least one children');

        const groupedChildren = internals.groupChildren(children);
        let obj;

        if ('' in groupedChildren) {
            obj = this[fn](...args);
            delete groupedChildren[''];
        }
        else {
            obj = this.clone();
        }

        if (obj._inner.children) {
            root = root ? (root + '.') : '';

            for (let i = 0; i < obj._inner.children.length; ++i) {
                const child = obj._inner.children[i];
                const group = groupedChildren[child.key];

                if (group) {
                    obj._inner.children[i] = {
                        key: child.key,
                        _refs: child._refs,
                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                    };

                    delete groupedChildren[child.key];
                }
            }
        }

        const remaining = Object.keys(groupedChildren);
        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));

        return obj;
    }

    _dependency(type, key, peers) {

        peers = [].concat(peers);
        for (let i = 0; i < peers.length; ++i) {
            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
        }

        const obj = this.clone();
        obj._inner.dependencies.push({ type, key, peers });
        return obj;
    }

    describe(shallow) {

        const description = super.describe();

        if (description.rules) {
            for (let i = 0; i < description.rules.length; ++i) {
                const rule = description.rules[i];
                // Coverage off for future-proof descriptions, only object().assert() is use right now
                if (/* $lab:coverage:off$ */rule.arg &&
                    typeof rule.arg === 'object' &&
                    rule.arg.schema &&
                    rule.arg.ref /* $lab:coverage:on$ */) {
                    rule.arg = {
                        schema: rule.arg.schema.describe(),
                        ref: rule.arg.ref.toString()
                    };
                }
            }
        }

        if (this._inner.children &&
            !shallow) {

            description.children = {};
            for (let i = 0; i < this._inner.children.length; ++i) {
                const child = this._inner.children[i];
                description.children[child.key] = child.schema.describe();
            }
        }

        if (this._inner.dependencies.length) {
            description.dependencies = Hoek.clone(this._inner.dependencies);
        }

        if (this._inner.patterns.length) {
            description.patterns = [];

            for (let i = 0; i < this._inner.patterns.length; ++i) {
                const pattern = this._inner.patterns[i];
                if (pattern.regex) {
                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
                }
                else {
                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });
                }
            }
        }

        if (this._inner.renames.length > 0) {
            description.renames = Hoek.clone(this._inner.renames);
        }

        return description;
    }

    assert(ref, schema, message) {

        ref = Cast.ref(ref);
        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
        message = message || 'pass the assertion test';
        Hoek.assert(typeof message === 'string', 'Message must be a string');

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        const key = ref.path[ref.path.length - 1];
        const path = ref.path.join('.');

        return this._test('assert', { schema, ref }, function (value, state, options) {

            const result = schema._validate(ref(value), null, options, value);
            if (!result.errors) {
                return value;
            }

            const localState = new State(key, ref.path, state.parent, state.reference);
            return this.createError('object.assert', { ref: path, message }, localState, options);
        });
    }

    type(constructor, name = constructor.name) {

        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
        const typeData = {
            name,
            ctor: constructor
        };

        return this._test('type', typeData, function (value, state, options) {

            if (value instanceof constructor) {
                return value;
            }

            return this.createError('object.type', { type: typeData.name, value }, state, options);
        });
    }
};


internals.renameDefaults = {
    alias: false,                   // Keep old value in place
    multiple: false,                // Allow renaming multiple keys into the same target
    override: false                 // Overrides an existing key
};


internals.groupChildren = function (children) {

    children.sort();

    const grouped = {};

    for (let i = 0; i < children.length; ++i) {
        const child = children[i];
        Hoek.assert(typeof child === 'string', 'children must be strings');
        const group = child.split('.')[0];
        const childGroup = grouped[group] = (grouped[group] || []);
        childGroup.push(child.substring(group.length + 1));
    }

    return grouped;
};


internals.keysToLabels = function (schema, keys) {

    const children = schema._inner.children;

    if (!children) {
        return keys;
    }

    const findLabel = function (key) {

        const matchingChild = schema._currentJoi.reach(schema, key);
        return matchingChild ? matchingChild._getLabel(key) : key;
    };

    if (Array.isArray(keys)) {
        return keys.map(findLabel);
    }

    return findLabel(keys);
};


internals.with = function (key, value, peers, parent, state, options) {

    if (value === undefined) {
        return;
    }

    for (let i = 0; i < peers.length; ++i) {

        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist === undefined) {

            return this.createError('object.with', {
                main: key,
                mainWithLabel: internals.keysToLabels(this, key),
                peer,
                peerWithLabel: internals.keysToLabels(this, peer)
            }, state, options);
        }
    }
};


internals.without = function (key, value, peers, parent, state, options) {

    if (value === undefined) {
        return;
    }

    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {

            return this.createError('object.without', {
                main: key,
                mainWithLabel: internals.keysToLabels(this, key),
                peer,
                peerWithLabel: internals.keysToLabels(this, peer)
            }, state, options);
        }
    }
};


internals.xor = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            present.push(peer);
        }
    }

    if (present.length === 1) {
        return;
    }

    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };

    if (present.length === 0) {
        return this.createError('object.missing', context, state, options);
    }

    context.present = present;
    context.presentWithLabels = internals.keysToLabels(this, present);

    return this.createError('object.xor', context, state, options);
};


internals.oxor = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            present.push(peer);
        }
    }

    if (!present.length ||
        present.length === 1) {

        return;
    }

    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };
    context.present = present;
    context.presentWithLabels = internals.keysToLabels(this, present);

    return this.createError('object.oxor', context, state, options);
};


internals.or = function (key, value, peers, parent, state, options) {

    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            return;
        }
    }

    return this.createError('object.missing', {
        peers,
        peersWithLabels: internals.keysToLabels(this, peers)
    }, state, options);
};


internals.and = function (key, value, peers, parent, state, options) {

    const missing = [];
    const present = [];
    const count = peers.length;
    for (let i = 0; i < count; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist === undefined) {

            missing.push(peer);
        }
        else {
            present.push(peer);
        }
    }

    const aon = (missing.length === count || present.length === count);

    if (!aon) {

        return this.createError('object.and', {
            present,
            presentWithLabels: internals.keysToLabels(this, present),
            missing,
            missingWithLabels: internals.keysToLabels(this, missing)
        }, state, options);
    }
};


internals.nand = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {

            present.push(peer);
        }
    }

    const main = peers[0];
    const values = peers.slice(1);
    const allPresent = (present.length === peers.length);
    return allPresent ? this.createError('object.nand', {
        main,
        mainWithLabel: internals.keysToLabels(this, main),
        peers: values,
        peersWithLabels: internals.keysToLabels(this, values)
    }, state, options) : null;
};


module.exports = new internals.Object();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = class {
    constructor(key, path, parent, reference) {

        this.key = key;
        this.path = path;
        this.parent = parent;
        this.reference = reference;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Net = __webpack_require__(/*! net */ "net");

const Address = __webpack_require__(/*! @hapi/address */ "./node_modules/@hapi/address/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");
const JoiDate = __webpack_require__(/*! ../date */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js");

const Uri = __webpack_require__(/*! ./uri */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/uri.js");
const Ip = __webpack_require__(/*! ./ip */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/ip.js");


const internals = {
    uriRegex: Uri.createUriRegex(),
    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
    guidBrackets: {
        '{': '}', '[': ']', '(': ')', '': ''
    },
    guidVersions: {
        uuidv1: '1',
        uuidv2: '2',
        uuidv3: '3',
        uuidv4: '4',
        uuidv5: '5'
    },
    cidrPresences: ['required', 'optional', 'forbidden'],
    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};


internals.String = class extends Any {

    constructor() {

        super();
        this._type = 'string';
        this._invalids.add('');
    }

    _base(value, state, options) {

        if (typeof value === 'string' &&
            options.convert) {

            if (this._flags.normalize) {
                value = value.normalize(this._flags.normalize);
            }

            if (this._flags.case) {
                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
            }

            if (this._flags.trim) {
                value = value.trim();
            }

            if (this._inner.replacements) {

                for (let i = 0; i < this._inner.replacements.length; ++i) {
                    const replacement = this._inner.replacements[i];
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }

            if (this._flags.truncate) {
                for (let i = 0; i < this._tests.length; ++i) {
                    const test = this._tests[i];
                    if (test.name === 'max') {
                        value = value.slice(0, test.arg);
                        break;
                    }
                }
            }

            if (this._flags.byteAligned && value.length % 2 !== 0) {
                value = `0${value}`;
            }
        }

        return {
            value,
            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)
        };
    }

    insensitive() {

        if (this._flags.insensitive) {
            return this;
        }

        const obj = this.clone();
        obj._flags.insensitive = true;
        return obj;
    }

    creditCard() {

        return this._test('creditCard', undefined, function (value, state, options) {

            let i = value.length;
            let sum = 0;
            let mul = 1;

            while (i--) {
                const char = value.charAt(i) * mul;
                sum = sum + (char - (char > 9) * 9);
                mul = mul ^ 3;
            }

            const check = (sum % 10 === 0) && (sum > 0);
            return check ? value : this.createError('string.creditCard', { value }, state, options);
        });
    }

    regex(pattern, patternOptions) {

        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');

        const patternObject = { pattern };

        if (typeof patternOptions === 'string') {
            patternObject.name = patternOptions;
        }
        else if (typeof patternOptions === 'object') {
            patternObject.invert = !!patternOptions.invert;

            if (patternOptions.name) {
                patternObject.name = patternOptions.name;
            }
        }

        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');

        return this._test('regex', patternObject, function (value, state, options) {

            const patternMatch = patternObject.pattern.test(value);

            if (patternMatch ^ patternObject.invert) {
                return value;
            }

            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);
        });
    }

    alphanum() {

        return this._test('alphanum', undefined, function (value, state, options) {

            if (/^[a-zA-Z0-9]+$/.test(value)) {
                return value;
            }

            return this.createError('string.alphanum', { value }, state, options);
        });
    }

    token() {

        return this._test('token', undefined, function (value, state, options) {

            if (/^\w+$/.test(value)) {
                return value;
            }

            return this.createError('string.token', { value }, state, options);
        });
    }

    email(validationOptions) {

        if (validationOptions) {
            Hoek.assert(typeof validationOptions === 'object', 'email options must be an object');

            // Migration validation for unsupported options

            Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');
            Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');
            Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');
            Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');
            Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead');

            // Validate options

            if (validationOptions.tlds &&
                typeof validationOptions.tlds === 'object') {

                Hoek.assert(validationOptions.tlds.allow === undefined ||
                    validationOptions.tlds.allow === false ||
                    validationOptions.tlds.allow === true ||
                    Array.isArray(validationOptions.tlds.allow) ||
                    validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');

                Hoek.assert(validationOptions.tlds.deny === undefined ||
                    Array.isArray(validationOptions.tlds.deny) ||
                    validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');

                const normalizeTable = (table) => {

                    if (table === undefined ||
                        typeof table === 'boolean' ||
                        table instanceof Set) {

                        return table;
                    }

                    return new Set(table);
                };

                validationOptions = Object.assign({}, validationOptions);       // Shallow cloned
                validationOptions.tlds = {
                    allow: normalizeTable(validationOptions.tlds.allow),
                    deny: normalizeTable(validationOptions.tlds.deny)
                };
            }

            Hoek.assert(validationOptions.minDomainSegments === undefined ||
                Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');
        }

        return this._test('email', validationOptions, function (value, state, options) {

            if (Address.email.isValid(value, validationOptions)) {
                return value;
            }

            return this.createError('string.email', { value }, state, options);
        });
    }

    ip(ipOptions = {}) {

        let regex = internals.ipRegex;
        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');

        if (ipOptions.cidr) {
            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
            ipOptions.cidr = ipOptions.cidr.toLowerCase();

            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));

            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default
            if (!ipOptions.version && ipOptions.cidr !== 'optional') {
                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
            }
        }
        else {

            // Set our default cidr strategy
            ipOptions.cidr = 'optional';
        }

        let versions;
        if (ipOptions.version) {
            if (!Array.isArray(ipOptions.version)) {
                ipOptions.version = [ipOptions.version];
            }

            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');

            versions = [];
            for (let i = 0; i < ipOptions.version.length; ++i) {
                let version = ipOptions.version[i];
                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                version = version.toLowerCase();
                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
                versions.push(version);
            }

            // Make sure we have a set of versions
            versions = Array.from(new Set(versions));

            regex = Ip.createIpRegex(versions, ipOptions.cidr);
        }

        return this._test('ip', ipOptions, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            if (versions) {
                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);
            }

            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);
        });
    }

    uri(uriOptions) {

        let customScheme = '';
        let allowRelative = false;
        let relativeOnly = false;
        let allowQuerySquareBrackets = false;
        let regex = internals.uriRegex;

        if (uriOptions) {
            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');

            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));
            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);

            if (uriOptions.scheme) {
                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');

                if (!Array.isArray(uriOptions.scheme)) {
                    uriOptions.scheme = [uriOptions.scheme];
                }

                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');

                // Flatten the array into a string to be used to match the schemes.
                for (let i = 0; i < uriOptions.scheme.length; ++i) {
                    const scheme = uriOptions.scheme[i];
                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

                    // Add OR separators if a value already exists
                    customScheme = customScheme + (customScheme ? '|' : '');

                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
                    if (scheme instanceof RegExp) {
                        customScheme = customScheme + scheme.source;
                    }
                    else {
                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                        customScheme = customScheme + Hoek.escapeRegex(scheme);
                    }
                }
            }

            if (uriOptions.allowRelative) {
                allowRelative = true;
            }

            if (uriOptions.relativeOnly) {
                relativeOnly = true;
            }

            if (uriOptions.allowQuerySquareBrackets) {
                allowQuerySquareBrackets = true;
            }
        }

        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {
            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);
        }

        return this._test('uri', uriOptions, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            if (relativeOnly) {
                return this.createError('string.uriRelativeOnly', { value }, state, options);
            }

            if (customScheme) {
                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);
            }

            return this.createError('string.uri', { value }, state, options);
        });
    }

    isoDate() {

        return this._test('isoDate', undefined, function (value, state, options) {

            if (JoiDate._isIsoDate(value)) {
                if (!options.convert) {
                    return value;
                }

                const d = new Date(value);
                if (!isNaN(d.getTime())) {
                    return d.toISOString();
                }
            }

            return this.createError('string.isoDate', { value }, state, options);
        });
    }

    guid(guidOptions) {

        let versionNumbers = '';

        if (guidOptions && guidOptions.version) {
            if (!Array.isArray(guidOptions.version)) {
                guidOptions.version = [guidOptions.version];
            }

            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');
            const versions = new Set();

            for (let i = 0; i < guidOptions.version.length; ++i) {
                let version = guidOptions.version[i];
                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                version = version.toLowerCase();
                const versionNumber = internals.guidVersions[version];
                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');

                versionNumbers += versionNumber;
                versions.add(versionNumber);
            }
        }

        const guidRegex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, 'i');

        return this._test('guid', guidOptions, function (value, state, options) {

            const results = guidRegex.exec(value);

            if (!results) {
                return this.createError('string.guid', { value }, state, options);
            }

            // Matching braces
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                return this.createError('string.guid', { value }, state, options);
            }

            return value;
        });
    }

    hex(hexOptions = {}) {

        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');
        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',
            'byteAligned must be boolean');

        const byteAligned = hexOptions.byteAligned === true;
        const regex = /^[a-f0-9]+$/i;

        const obj = this._test('hex', regex, function (value, state, options) {

            if (regex.test(value)) {
                if (byteAligned && value.length % 2 !== 0) {
                    return this.createError('string.hexAlign', { value }, state, options);
                }

                return value;
            }

            return this.createError('string.hex', { value }, state, options);
        });

        if (byteAligned) {
            obj._flags.byteAligned = true;
        }

        return obj;
    }

    base64(base64Options = {}) {

        // Validation.
        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');
        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',
            'paddingRequired must be boolean');

        // Determine if padding is required.
        const paddingRequired = base64Options.paddingRequired === false ?
            base64Options.paddingRequired
            : base64Options.paddingRequired || true;

        // Set validation based on preference.
        const regex = paddingRequired ?
            // Padding is required.
            /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
            // Padding is optional.
            : /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;

        return this._test('base64', regex, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            return this.createError('string.base64', { value }, state, options);
        });
    }

    dataUri(dataUriOptions = {}) {

        const regex = /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/;

        // Determine if padding is required.
        const paddingRequired = dataUriOptions.paddingRequired === false ?
            dataUriOptions.paddingRequired
            : dataUriOptions.paddingRequired || true;

        const base64regex = paddingRequired ?
            /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
            : /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;

        return this._test('dataUri', regex, function (value, state, options) {

            const matches = value.match(regex);

            if (matches) {
                if (!matches[2]) {
                    return value;
                }

                if (matches[2] !== 'base64') {
                    return value;
                }

                if (base64regex.test(matches[3])) {
                    return value;
                }
            }

            return this.createError('string.dataUri', { value }, state, options);
        });
    }

    hostname() {

        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;

        return this._test('hostname', undefined, function (value, state, options) {

            if ((value.length <= 255 && regex.test(value)) ||
                Net.isIPv6(value)) {

                return value;
            }

            return this.createError('string.hostname', { value }, state, options);
        });
    }

    normalize(form = 'NFC') {

        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

        const obj = this._test('normalize', form, function (value, state, options) {

            if (options.convert ||
                value === value.normalize(form)) {

                return value;
            }

            return this.createError('string.normalize', { value, form }, state, options);
        });

        obj._flags.normalize = form;
        return obj;
    }

    lowercase() {

        const obj = this._test('lowercase', undefined, function (value, state, options) {

            if (options.convert ||
                value === value.toLocaleLowerCase()) {

                return value;
            }

            return this.createError('string.lowercase', { value }, state, options);
        });

        obj._flags.case = 'lower';
        return obj;
    }

    uppercase() {

        const obj = this._test('uppercase', undefined, function (value, state, options) {

            if (options.convert ||
                value === value.toLocaleUpperCase()) {

                return value;
            }

            return this.createError('string.uppercase', { value }, state, options);
        });

        obj._flags.case = 'upper';
        return obj;
    }

    trim(enabled = true) {

        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');

        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {
            return this;
        }

        let obj;
        if (enabled) {
            obj = this._test('trim', undefined, function (value, state, options) {

                if (options.convert ||
                    value === value.trim()) {

                    return value;
                }

                return this.createError('string.trim', { value }, state, options);
            });
        }
        else {
            obj = this.clone();
            obj._tests = obj._tests.filter((test) => test.name !== 'trim');
        }

        obj._flags.trim = enabled;
        return obj;
    }

    replace(pattern, replacement) {

        if (typeof pattern === 'string') {
            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
        }

        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');

        // This can not be considere a test like trim, we can't "reject"
        // anything from this rule, so just clone the current object
        const obj = this.clone();

        if (!obj._inner.replacements) {
            obj._inner.replacements = [];
        }

        obj._inner.replacements.push({
            pattern,
            replacement
        });

        return obj;
    }

    truncate(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.truncate === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.truncate = value;
        return obj;
    }

};

internals.compare = function (type, compare) {

    return function (limit, encoding) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');
        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

        return this._test(type, limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!Number.isSafeInteger(compareTo)) {
                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (compare(value, compareTo, encoding)) {
                return value;
            }

            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);
        });
    };
};


internals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length >= limit;
});


internals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length <= limit;
});


internals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length === limit;
});

// Aliases

internals.String.prototype.uuid = internals.String.prototype.guid;

module.exports = new internals.String();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/ip.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/ip.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RFC3986 = __webpack_require__(/*! ./rfc3986 */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js");


const internals = {
    Ip: {
        cidrs: {
            ipv4: {
                required: '\\/(?:' + RFC3986.ipv4Cidr + ')',
                optional: '(?:\\/(?:' + RFC3986.ipv4Cidr + '))?',
                forbidden: ''
            },
            ipv6: {
                required: '\\/' + RFC3986.ipv6Cidr,
                optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                forbidden: ''
            },
            ipvfuture: {
                required: '\\/' + RFC3986.ipv6Cidr,
                optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                forbidden: ''
            }
        },
        versions: {
            ipv4: RFC3986.IPv4address,
            ipv6: RFC3986.IPv6address,
            ipvfuture: RFC3986.IPvFuture
        }
    }
};


internals.Ip.createIpRegex = function (versions, cidr) {

    let regex;
    for (let i = 0; i < versions.length; ++i) {
        const version = versions[i];
        if (!regex) {
            regex = '^(?:' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        }
        else {
            regex += '|' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        }
    }

    return new RegExp(regex + ')$');
};

module.exports = internals.Ip;


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {
    rfc3986: {}
};


internals.generate = function () {

    /**
     * elements separated by forward slash ("/") are alternatives.
     */
    const or = '|';

    /**
     * Rule to support zero-padded addresses.
     */
    const zeroPad = '0?';

    /**
     * DIGIT = %x30-39 ; 0-9
     */
    const digit = '0-9';
    const digitOnly = '[' + digit + ']';

    /**
     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
     */
    const alpha = 'a-zA-Z';
    const alphaOnly = '[' + alpha + ']';

    /**
     * IPv4
     * cidr       = DIGIT                ; 0-9
     *            / %x31-32 DIGIT         ; 10-29
     *            / "3" %x30-32           ; 30-32
     */
    internals.rfc3986.ipv4Cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';

    /**
     * IPv6
     * cidr       = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" %x0-1 DIGIT       ; 100-119
     *            / "12" %x0-8            ; 120-128
     */
    internals.rfc3986.ipv6Cidr = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + '[01]' + digitOnly + or + '12[0-8])';

    /**
     * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
     */
    const hexDigit = digit + 'A-Fa-f';
    const hexDigitOnly = '[' + hexDigit + ']';

    /**
     * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
     */
    const unreserved = alpha + digit + '-\\._~';

    /**
     * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
     */
    const subDelims = '!\\$&\'\\(\\)\\*\\+,;=';

    /**
     * pct-encoded = "%" HEXDIG HEXDIG
     */
    const pctEncoded = '%' + hexDigit;

    /**
     * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
     */
    const pchar = unreserved + pctEncoded + subDelims + ':@';
    const pcharOnly = '[' + pchar + ']';

    /**
     * squareBrackets example: []
     */
    const squareBrackets = '\\[\\]';

    /**
     * dec-octet   = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" 2DIGIT            ; 100-199
     *            / "2" %x30-34 DIGIT     ; 200-249
     *            / "25" %x30-35          ; 250-255
     */
    const decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';

    /**
     * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
     */
    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;

    /**
     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
     * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
     * IPv6address =                            6( h16 ":" ) ls32
     *             /                       "::" 5( h16 ":" ) ls32
     *             / [               h16 ] "::" 4( h16 ":" ) ls32
     *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
     *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
     *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
     *             / [ *4( h16 ":" ) h16 ] "::"              ls32
     *             / [ *5( h16 ":" ) h16 ] "::"              h16
     *             / [ *6( h16 ":" ) h16 ] "::"
     */
    const h16 = hexDigitOnly + '{1,4}';
    const ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';
    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';

    /**
     * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
     */
    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';

    /**
     * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
     */
    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';

    /**
     * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
     */
    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';

    /**
     * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
     */
    const IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';

    /**
     * reg-name = *( unreserved / pct-encoded / sub-delims )
     */
    const regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';

    /**
     * host = IP-literal / IPv4address / reg-name
     */
    const host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';

    /**
     * port = *DIGIT
     */
    const port = digitOnly + '*';

    /**
     * authority   = [ userinfo "@" ] host [ ":" port ]
     */
    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';

    /**
     * segment       = *pchar
     * segment-nz    = 1*pchar
     * path          = path-abempty    ; begins with "/" or is empty
     *               / path-absolute   ; begins with "/" but not "//"
     *               / path-noscheme   ; begins with a non-colon segment
     *               / path-rootless   ; begins with a segment
     *               / path-empty      ; zero characters
     * path-abempty  = *( "/" segment )
     * path-absolute = "/" [ segment-nz *( "/" segment ) ]
     * path-rootless = segment-nz *( "/" segment )
     */
    const segment = pcharOnly + '*';
    const segmentNz = pcharOnly + '+';
    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
    const pathEmpty = '';
    const pathAbEmpty = '(?:\\/' + segment + ')*';
    const pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;

    /**
     * hier-part = "//" authority path
     */
    internals.rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';

    /**
     * relative-part = "//" authority path-abempty
     *                 / path-absolute
     *                 / path-noscheme
     *                 / path-empty
     */
    internals.rfc3986.relativeRef = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty  + ')' + or + pathAbsolute + or + pathNoScheme + or + pathEmpty + ')';

    /**
     * query = *( pchar / "/" / "?" )
     */
    internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

    /**
     * query = *( pchar / "[" / "]" / "/" / "?" )
     */
    internals.rfc3986.queryWithSquareBrackets = '[' + pchar + squareBrackets + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

    /**
     * fragment = *( pchar / "/" / "?" )
     */
    internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';
};


internals.generate();

module.exports = internals.rfc3986;


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/uri.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/uri.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RFC3986 = __webpack_require__(/*! ./rfc3986 */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js");


const internals = {
    Uri: {
        createUriRegex: function (optionalScheme, allowRelative, relativeOnly, allowQuerySquareBrackets) {

            let scheme = RFC3986.scheme;
            let prefix;

            if (relativeOnly) {
                prefix = '(?:' + RFC3986.relativeRef + ')';
            }
            else {
                // If we were passed a scheme, use it instead of the generic one
                if (optionalScheme) {

                    // Have to put this in a non-capturing group to handle the OR statements
                    scheme = '(?:' + optionalScheme + ')';
                }

                const withScheme = '(?:' + scheme + ':' + RFC3986.hierPart + ')';

                prefix = allowRelative ? '(?:' + withScheme + '|' + RFC3986.relativeRef + ')' : withScheme;
            }

            /**
             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
             *
             * OR
             *
             * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
             */
            return new RegExp('^' + prefix + '(?:\\?' + (allowQuerySquareBrackets ? RFC3986.queryWithSquareBrackets : RFC3986.query) + ')?' + '(?:#' + RFC3986.fragment + ')?$');
        }
    }
};

module.exports = internals.Uri;


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbol/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbol/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Util = __webpack_require__(/*! util */ "util");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Map = class extends Map {

    slice() {

        return new internals.Map(this);
    }

    toString() {

        return Util.inspect(this);
    }
};


internals.Symbol = class extends Any {

    constructor() {

        super();
        this._type = 'symbol';
        this._inner.map = new internals.Map();
    }

    _base(value, state, options) {

        if (options.convert) {
            const lookup = this._inner.map.get(value);
            if (lookup) {
                value = lookup;
            }

            if (this._flags.allowOnly) {
                return {
                    value,
                    errors: (typeof value === 'symbol') ? null : this.createError('symbol.map', { value, map: this._inner.map }, state, options)
                };
            }
        }

        return {
            value,
            errors: (typeof value === 'symbol') ? null : this.createError('symbol.base', { value }, state, options)
        };
    }

    map(iterable) {

        if (iterable && !iterable[Symbol.iterator] && typeof iterable === 'object') {
            iterable = Object.entries(iterable);
        }

        Hoek.assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');
        const obj = this.clone();

        const symbols = [];
        for (const entry of iterable) {
            Hoek.assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');
            const [key, value] = entry;

            Hoek.assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be an object, function, or Symbol');
            Hoek.assert(typeof value === 'symbol', 'Value must be a Symbol');
            obj._inner.map.set(key, value);
            symbols.push(value);
        }

        return obj.valid(...symbols);
    }

    describe() {

        const description = super.describe();
        description.map = new Map(this._inner.map);
        return description;
    }
};


module.exports = new internals.Symbol();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = {
    settingsCache: Symbol('settingsCache')
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json":
/*!*********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json ***!
  \*********************************************************************/
/*! exports provided: name, description, version, homepage, repository, main, keywords, dependencies, devDependencies, scripts, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/joi\",\"description\":\"Object schema validation\",\"version\":\"15.1.1\",\"homepage\":\"https://github.com/hapijs/joi\",\"repository\":\"git://github.com/hapijs/joi\",\"main\":\"lib/index.js\",\"keywords\":[\"schema\",\"validation\"],\"dependencies\":{\"@hapi/address\":\"2.x.x\",\"@hapi/bourne\":\"1.x.x\",\"@hapi/hoek\":\"8.x.x\",\"@hapi/topo\":\"3.x.x\"},\"devDependencies\":{\"@hapi/code\":\"6.x.x\",\"@hapi/lab\":\"20.x.x\"},\"scripts\":{\"test\":\"lab -t 100 -a @hapi/code -L\",\"test-cov-html\":\"lab -r html -o coverage.html -a @hapi/code\"},\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/hapi/package.json":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hapi/package.json ***!
  \**********************************************/
/*! exports provided: name, description, homepage, version, repository, main, keywords, dependencies, devDependencies, scripts, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/hapi\",\"description\":\"HTTP Server framework\",\"homepage\":\"https://hapijs.com\",\"version\":\"18.4.0\",\"repository\":\"git://github.com/hapijs/hapi\",\"main\":\"lib/index.js\",\"keywords\":[\"framework\",\"http\",\"api\",\"web\"],\"dependencies\":{\"@hapi/accept\":\"3.x.x\",\"@hapi/ammo\":\"3.x.x\",\"@hapi/boom\":\"7.x.x\",\"@hapi/bounce\":\"1.x.x\",\"@hapi/call\":\"5.x.x\",\"@hapi/catbox\":\"10.x.x\",\"@hapi/catbox-memory\":\"4.x.x\",\"@hapi/heavy\":\"6.x.x\",\"@hapi/hoek\":\"8.x.x\",\"@hapi/joi\":\"15.x.x\",\"@hapi/mimos\":\"4.x.x\",\"@hapi/podium\":\"3.x.x\",\"@hapi/shot\":\"4.x.x\",\"@hapi/somever\":\"2.x.x\",\"@hapi/statehood\":\"6.x.x\",\"@hapi/subtext\":\"6.x.x\",\"@hapi/teamwork\":\"3.x.x\",\"@hapi/topo\":\"3.x.x\"},\"devDependencies\":{\"@hapi/code\":\"6.x.x\",\"@hapi/inert\":\"5.x.x\",\"@hapi/joi-next-test\":\"npm:@hapi/joi@16.x.x\",\"@hapi/lab\":\"20.x.x\",\"@hapi/wreck\":\"15.x.x\",\"@hapi/vision\":\"5.x.x\",\"handlebars\":\"4.x.x\"},\"scripts\":{\"test\":\"lab -a @hapi/code -t 100 -L -m 5000\",\"test-tap\":\"lab -a @hapi/code -r tap -o tests.tap -m 5000\",\"test-cov-html\":\"lab -a @hapi/code -r html -o coverage.html -m 5000\"},\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/heavy/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/heavy/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {};


internals.schema = Joi.object({
    sampleInterval: Joi.number().min(0),
    maxHeapUsedBytes: Joi.number().min(0),
    maxEventLoopDelay: Joi.number().min(0),
    maxRssBytes: Joi.number().min(0)
})
    .unknown();


internals.defaults = {
    sampleInterval: 0,                          // Frequency of load sampling in milliseconds (zero is no sampling)
    maxHeapUsedBytes: 0,                        // Reject requests when V8 heap is over size in bytes (zero is no max)
    maxRssBytes: 0,                             // Reject requests when process RSS is over size in bytes (zero is no max)
    maxEventLoopDelay: 0                        // Milliseconds of delay after which requests are rejected (zero is no max)
};


exports = module.exports = internals.Heavy = function (options) {

    options = options || {};

    Joi.assert(options, internals.schema, 'Invalid load monitoring options');
    this.settings = Hoek.applyToDefaults(internals.defaults, options);
    Hoek.assert(this.settings.sampleInterval || (!this.settings.maxEventLoopDelay && !this.settings.maxHeapUsedBytes && !this.settings.maxRssBytes), 'Load sample interval must be set to enable load limits');

    this._eventLoopTimer = null;
    this._loadBench = new Hoek.Bench();
    this.load = {
        eventLoopDelay: 0,
        heapUsed: 0,
        rss: 0
    };
};


internals.Heavy.prototype.start = function () {

    if (!this.settings.sampleInterval) {
        return;
    }

    const loopSample = () => {

        this._loadBench.reset();
        const measure = () => {

            const mem = process.memoryUsage();

            // Retain the same this.load object to keep external references valid

            this.load.eventLoopDelay = (this._loadBench.elapsed() - this.settings.sampleInterval);
            this.load.heapUsed = mem.heapUsed;
            this.load.rss = mem.rss;

            loopSample();
        };

        this._eventLoopTimer = setTimeout(measure, this.settings.sampleInterval);
    };

    loopSample();
};


internals.Heavy.prototype.stop = function () {

    clearTimeout(this._eventLoopTimer);
    this._eventLoopTimer = null;
};


internals.Heavy.prototype.check = function () {

    if (!this.settings.sampleInterval) {
        return;
    }

    Hoek.assert(this._eventLoopTimer, 'Cannot check load when sampler is not started');

    const elapsed = this._loadBench.elapsed();
    const load = this.load;

    if (elapsed > this.settings.sampleInterval) {
        load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this.settings.sampleInterval);
    }

    if (this.settings.maxEventLoopDelay &&
        load.eventLoopDelay > this.settings.maxEventLoopDelay) {

        throw Boom.serverUnavailable('Server under heavy load (event loop)', load);
    }

    if (this.settings.maxHeapUsedBytes &&
        load.heapUsed > this.settings.maxHeapUsedBytes) {

        throw Boom.serverUnavailable('Server under heavy load (heap)', load);
    }

    if (this.settings.maxRssBytes &&
        load.rss > this.settings.maxRssBytes) {

        throw Boom.serverUnavailable('Server under heavy load (rss)', load);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/applyToDefaults.js":
/*!********************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/applyToDefaults.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Merge = __webpack_require__(/*! ./merge */ "./node_modules/@hapi/hoek/lib/merge.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = function (defaults, source, options = {}) {

    Assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    Assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');
    Assert(typeof options === 'object', 'Invalid options: must be an object');

    if (!source) {                                                  // If no source, return null
        return null;
    }

    if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
    }

    const copy = Clone(defaults);

    if (source === true) {                                          // If source is set to true, use defaults
        return copy;
    }

    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
};


internals.applyToDefaultsWithShallow = function (defaults, source, options) {

    const keys = options.shallow;
    Assert(Array.isArray(keys), 'Invalid keys');

    options = Object.assign({}, options);
    options.shallow = false;

    const copy = Clone(defaults, { shallow: keys });

    if (source === true) {                                                      // If source is set to true, use defaults
        return copy;
    }

    const storage = Utils.store(source, keys);                              // Move shallow copy items to storage
    Merge(copy, source, { mergeArrays: false, nullOverride: false });   // Deep copy the rest
    Utils.restore(copy, source, storage);                                   // Shallow copy the stored items and restore
    return copy;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/assert.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/assert.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const AssertError = __webpack_require__(/*! ./error */ "./node_modules/@hapi/hoek/lib/error.js");

const internals = {};


module.exports = function (condition, ...args) {

    if (condition) {
        return;
    }

    if (args.length === 1 &&
        args[0] instanceof Error) {

        throw args[0];
    }

    throw new AssertError(args);
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/bench.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/bench.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = internals.Bench = class {

    constructor() {

        this.ts = 0;
        this.reset();
    }

    reset() {

        this.ts = internals.Bench.now();
    }

    elapsed() {

        return internals.Bench.now() - this.ts;
    }

    static now() {

        const ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/block.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/block.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Ignore = __webpack_require__(/*! ./ignore */ "./node_modules/@hapi/hoek/lib/ignore.js");


const internals = {};


module.exports = function () {

    return new Promise(Ignore);         // $lab:coverage:ignore$
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/clone.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/clone.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Types = __webpack_require__(/*! ./types */ "./node_modules/@hapi/hoek/lib/types.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
};


module.exports = internals.clone = function (obj, options = {}, _seen = null) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    let clone = internals.clone;
    let seen = _seen;

    if (options.shallow) {
        if (options.shallow !== true) {
            return internals.cloneWithShallow(obj, options);
        }

        clone = (value) => value;
    }
    else {
        seen = seen || new Map();

        const lookup = seen.get(obj);
        if (lookup) {
            return lookup;
        }
    }

    // Built-in object types

    const baseProto = Types.getInternalProto(obj);
    if (baseProto === Types.buffer) {
        return Buffer && Buffer.from(obj);              // $lab:coverage:ignore$
    }

    if (baseProto === Types.date) {
        return new Date(obj.getTime());
    }

    if (baseProto === Types.regex) {
        return new RegExp(obj);
    }

    // Generic objects

    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
        return obj;
    }

    if (seen) {
        seen.set(obj, newObj);                              // Set seen, since obj could recurse
    }

    if (baseProto === Types.set) {
        for (const value of obj) {
            newObj.add(clone(value, options, seen));
        }
    }
    else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
            newObj.set(key, clone(value, options, seen));
        }
    }

    const keys = Utils.keys(obj, options);
    for (const key of keys) {
        if (baseProto === Types.array &&
            key === 'length') {

            newObj.length = obj.length;
            continue;
        }

        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
            if (descriptor.get ||
                descriptor.set) {

                Object.defineProperty(newObj, key, descriptor);
            }
            else if (descriptor.enumerable) {
                newObj[key] = clone(obj[key], options, seen);
            }
            else {
                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
            }
        }
        else {
            Object.defineProperty(newObj, key, {
                enumerable: true,
                writable: true,
                configurable: true,
                value: clone(obj[key], options, seen)
            });
        }
    }

    return newObj;
};


internals.cloneWithShallow = function (source, options) {

    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;

    const storage = Utils.store(source, keys);    // Move shallow copy items to storage
    const copy = internals.clone(source, options);      // Deep copy the rest
    Utils.restore(copy, source, storage);         // Shallow copy the stored items and restore
    return copy;
};


internals.base = function (obj, baseProto, options) {

    if (baseProto === Types.array) {
        return [];
    }

    if (options.prototype === false) {                  // Defaults to true
        if (internals.needsProtoHack.has(baseProto)) {
            return new baseProto.constructor();
        }

        return {};
    }

    const proto = Object.getPrototypeOf(obj);
    if (proto &&
        proto.isImmutable) {

        return obj;
    }

    if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
            Object.setPrototypeOf(newObj, proto);
        }

        return newObj;
    }

    return Object.create(proto);
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/contain.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/contain.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! ./deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const EscapeRegex = __webpack_require__(/*! ./escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    if (typeof values !== 'object') {
        values = [values];
    }

    Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty');

    // String

    if (typeof ref === 'string') {
        return internals.string(ref, values, options);
    }

    // Array

    if (Array.isArray(ref)) {
        return internals.array(ref, values, options);
    }

    // Object

    Assert(typeof ref === 'object', 'Reference must be string or an object');
    return internals.object(ref, values, options);
};


internals.array = function (ref, values, options) {

    if (!Array.isArray(values)) {
        values = [values];
    }

    if (!ref.length) {
        return false;
    }

    if (options.only &&
        options.once &&
        ref.length !== values.length) {

        return false;
    }

    let compare;

    // Map values

    const map = new Map();
    for (const value of values) {
        if (!options.deep ||
            !value ||
            typeof value !== 'object') {

            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
        else {
            compare = compare || internals.compare(options);

            let found = false;
            for (const [key, existing] of map.entries()) {
                if (compare(key, value)) {
                    ++existing.allowed;
                    found = true;
                    break;
                }
            }

            if (!found) {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
    }

    // Lookup values

    let hits = 0;
    for (const item of ref) {
        let match;
        if (!options.deep ||
            !item ||
            typeof item !== 'object') {

            match = map.get(item);
        }
        else {
            for (const [key, existing] of map.entries()) {
                if (compare(key, item)) {
                    match = existing;
                    break;
                }
            }
        }

        if (match) {
            ++match.hits;
            ++hits;

            if (options.once &&
                match.hits > match.allowed) {

                return false;
            }
        }
    }

    // Validate results

    if (options.only &&
        hits !== ref.length) {

        return false;
    }

    for (const match of map.values()) {
        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }
    }

    return !!hits;
};


internals.object = function (ref, values, options) {

    Assert(options.once === undefined, 'Cannot use option once with object');

    const keys = Utils.keys(ref, options);
    if (!keys.length) {
        return false;
    }

    // Keys list

    if (Array.isArray(values)) {
        return internals.array(keys, values, options);
    }

    // Key value pairs

    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
    const targets = [...Object.keys(values), ...symbols];

    const compare = internals.compare(options);
    const set = new Set(targets);

    for (const key of keys) {
        if (!set.has(key)) {
            if (options.only) {
                return false;
            }

            continue;
        }

        if (!compare(values[key], ref[key])) {
            return false;
        }

        set.delete(key);
    }

    if (set.size) {
        return options.part ? set.size < targets.length : false;
    }

    return true;
};


internals.string = function (ref, values, options) {

    // Empty string

    if (ref === '') {
        return values.length === 1 && values[0] === '' ||               // '' contains ''
            !options.once && !values.some((v) => v !== '');             // '' contains multiple '' if !once
    }

    // Map values

    const map = new Map();
    const patterns = [];

    for (const value of values) {
        Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');

        if (value) {
            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
                patterns.push(EscapeRegex(value));
            }
        }
        else if (options.once ||
            options.only) {

            return false;
        }
    }

    if (!patterns.length) {                     // Non-empty string contains unlimited empty string
        return true;
    }

    // Match patterns

    const regex = new RegExp(`(${patterns.join('|')})`, 'g');
    const leftovers = ref.replace(regex, ($0, $1) => {

        ++map.get($1).hits;
        return '';                              // Remove from string
    });

    // Validate results

    if (options.only &&
        leftovers) {

        return false;
    }

    let any = false;
    for (const match of map.values()) {
        if (match.hits) {
            any = true;
        }

        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }

        // match.hits > match.allowed

        if (options.once) {
            return false;
        }
    }

    return !!any;
};


internals.compare = function (options) {

    if (!options.deep) {
        return internals.shallow;
    }

    const hasOnly = options.only !== undefined;
    const hasPart = options.part !== undefined;

    const flags = {
        prototype: hasOnly ? options.only : hasPart ? !options.part : false,
        part: hasOnly ? !options.only : hasPart ? options.part : false
    };

    return (a, b) => DeepEqual(a, b, flags);
};


internals.shallow = function (a, b) {

    return a === b;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/deepEqual.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/deepEqual.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Types = __webpack_require__(/*! ./types */ "./node_modules/@hapi/hoek/lib/types.js");


const internals = {
    mismatched: null
};


module.exports = function (obj, ref, options) {

    options = Object.assign({ prototype: true }, options);

    return !!internals.isDeepEqual(obj, ref, options, []);
};


internals.isDeepEqual = function (obj, ref, options, seen) {

    if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
        return obj !== 0 || 1 / obj === 1 / ref;
    }

    const type = typeof obj;

    if (type !== typeof ref) {
        return false;
    }

    if (obj === null ||
        ref === null) {

        return false;
    }

    if (type === 'function') {
        if (!options.deepFunction ||
            obj.toString() !== ref.toString()) {

            return false;
        }

        // Continue as object
    }
    else if (type !== 'object') {
        return obj !== obj && ref !== ref;                                  // NaN
    }

    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
        case Types.buffer:
            return Buffer && Buffer.prototype.equals.call(obj, ref);        // $lab:coverage:ignore$
        case Types.promise:
            return obj === ref;
        case Types.regex:
            return obj.toString() === ref.toString();
        case internals.mismatched:
            return false;
    }

    for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
            return true;                                                    // If previous comparison failed, it would have stopped execution
        }
    }

    seen.push(new internals.SeenEntry(obj, ref));

    try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    }
    finally {
        seen.pop();
    }
};


internals.getSharedType = function (obj, ref, checkPrototype) {

    if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
            return internals.mismatched;
        }

        return Types.getInternalProto(obj);
    }

    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
    }

    return type;
};


internals.valueOf = function (obj) {

    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
        return obj;
    }

    try {
        return objValueOf.call(obj);
    }
    catch (err) {
        return err;
    }
};


internals.hasOwnEnumerableProperty = function (obj, key) {

    return Object.prototype.propertyIsEnumerable.call(obj, key);
};


internals.isSetSimpleEqual = function (obj, ref) {

    for (const entry of obj) {
        if (!ref.has(entry)) {
            return false;
        }
    }

    return true;
};


internals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {

    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;

    if (instanceType === Types.array) {
        if (options.part) {

            // Check if any index match any other index

            for (const objValue of obj) {
                for (const refValue of ref) {
                    if (isDeepEqual(objValue, refValue, options, seen)) {
                        return true;
                    }
                }
            }
        }
        else {
            if (obj.length !== ref.length) {
                return false;
            }

            for (let i = 0; i < obj.length; ++i) {
                if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }

            return true;
        }
    }
    else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
            return false;
        }

        if (!internals.isSetSimpleEqual(obj, ref)) {

            // Check for deep equality

            const ref2 = new Set(ref);
            for (const objEntry of obj) {
                if (ref2.delete(objEntry)) {
                    continue;
                }

                let found = false;
                for (const refEntry of ref2) {
                    if (isDeepEqual(objEntry, refEntry, options, seen)) {
                        ref2.delete(refEntry);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }
    }
    else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
            return false;
        }

        for (const [key, value] of obj) {
            if (value === undefined && !ref.has(key)) {
                return false;
            }

            if (!isDeepEqual(value, ref.get(key), options, seen)) {
                return false;
            }
        }
    }
    else if (instanceType === Types.error) {

        // Always check name and message

        if (obj.name !== ref.name ||
            obj.message !== ref.message) {

            return false;
        }
    }

    // Check .valueOf()

    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) &&
        !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {

        return false;
    }

    // Check properties

    const objKeys = keys(obj);
    if (!options.part &&
        objKeys.length !== keys(ref).length &&
        !options.skip) {

        return false;
    }

    let skipped = 0;
    for (const key of objKeys) {
        if (options.skip &&
            options.skip.includes(key)) {

            if (ref[key] === undefined) {
                ++skipped;
            }

            continue;
        }

        if (!hasOwnEnumerableProperty(ref, key)) {
            return false;
        }

        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
            return false;
        }
    }

    if (!options.part &&
        objKeys.length - skipped !== keys(ref).length) {

        return false;
    }

    // Check symbols

    if (options.symbols !== false) {                                // Defaults to true
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));

        for (const key of objSymbols) {
            if (!options.skip ||
                !options.skip.includes(key)) {

                if (hasOwnEnumerableProperty(obj, key)) {
                    if (!hasOwnEnumerableProperty(ref, key)) {
                        return false;
                    }

                    if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                        return false;
                    }
                }
                else if (hasOwnEnumerableProperty(ref, key)) {
                    return false;
                }
            }

            refSymbols.delete(key);
        }

        for (const key of refSymbols) {
            if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }
        }
    }

    return true;
};


internals.SeenEntry = class {

    constructor(obj, ref) {

        this.obj = obj;
        this.ref = ref;
    }

    isSame(obj, ref) {

        return this.obj === obj && this.ref === ref;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/error.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/error.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stringify = __webpack_require__(/*! ./stringify */ "./node_modules/@hapi/hoek/lib/stringify.js");


const internals = {};


module.exports = class extends Error {

    constructor(args) {

        const msgs = args
            .filter((arg) => arg !== '')
            .map((arg) => {

                return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : Stringify(arg);
            });

        super(msgs.join(' ') || 'Unknown error');

        if (typeof Error.captureStackTrace === 'function') {            // $lab:coverage:ignore$
            Error.captureStackTrace(this, exports.assert);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js":
/*!**************************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeHtml.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeHtml.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    let escaped = '';

    for (let i = 0; i < input.length; ++i) {

        const charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeHtmlChar = function (charCode) {

    const namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    const hexValue = charCode.toString(16).padStart(2, '0');
    return `&#x${hexValue};`;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    const safe = {};

    for (let i = 32; i < 123; ++i) {

        if ((i >= 97) ||                    // a-z
            (i >= 65 && i <= 90) ||         // A-Z
            (i >= 48 && i <= 57) ||         // 0-9
            i === 32 ||                     // space
            i === 46 ||                     // .
            i === 44 ||                     // ,
            i === 45 ||                     // -
            i === 58 ||                     // :
            i === 95) {                     // _

            safe[i] = null;
        }
    }

    return safe;
}());


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeJson.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeJson.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    const lessThan = 0x3C;
    const greaterThan = 0x3E;
    const andSymbol = 0x26;
    const lineSeperator = 0x2028;

    // replace method
    let charCode;
    return input.replace(/[<>&\u2028\u2029]/g, (match) => {

        charCode = match.charCodeAt(0);

        if (charCode === lessThan) {
            return '\\u003c';
        }

        if (charCode === greaterThan) {
            return '\\u003e';
        }

        if (charCode === andSymbol) {
            return '\\u0026';
        }

        if (charCode === lineSeperator) {
            return '\\u2028';
        }

        return '\\u2029';
    });
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeRegex.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeRegex.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},

    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/flatten.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/flatten.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = internals.flatten = function (array, target) {

    const result = target || [];

    for (let i = 0; i < array.length; ++i) {
        if (Array.isArray(array[i])) {
            internals.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/ignore.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/ignore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function () { };


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = {
    applyToDefaults: __webpack_require__(/*! ./applyToDefaults */ "./node_modules/@hapi/hoek/lib/applyToDefaults.js"),
    assert: __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js"),
    Bench: __webpack_require__(/*! ./bench */ "./node_modules/@hapi/hoek/lib/bench.js"),
    block: __webpack_require__(/*! ./block */ "./node_modules/@hapi/hoek/lib/block.js"),
    clone: __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js"),
    contain: __webpack_require__(/*! ./contain */ "./node_modules/@hapi/hoek/lib/contain.js"),
    deepEqual: __webpack_require__(/*! ./deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js"),
    Error: __webpack_require__(/*! ./error */ "./node_modules/@hapi/hoek/lib/error.js"),
    escapeHeaderAttribute: __webpack_require__(/*! ./escapeHeaderAttribute */ "./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js"),
    escapeHtml: __webpack_require__(/*! ./escapeHtml */ "./node_modules/@hapi/hoek/lib/escapeHtml.js"),
    escapeJson: __webpack_require__(/*! ./escapeJson */ "./node_modules/@hapi/hoek/lib/escapeJson.js"),
    escapeRegex: __webpack_require__(/*! ./escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js"),
    flatten: __webpack_require__(/*! ./flatten */ "./node_modules/@hapi/hoek/lib/flatten.js"),
    ignore: __webpack_require__(/*! ./ignore */ "./node_modules/@hapi/hoek/lib/ignore.js"),
    intersect: __webpack_require__(/*! ./intersect */ "./node_modules/@hapi/hoek/lib/intersect.js"),
    merge: __webpack_require__(/*! ./merge */ "./node_modules/@hapi/hoek/lib/merge.js"),
    once: __webpack_require__(/*! ./once */ "./node_modules/@hapi/hoek/lib/once.js"),
    reach: __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js"),
    reachTemplate: __webpack_require__(/*! ./reachTemplate */ "./node_modules/@hapi/hoek/lib/reachTemplate.js"),
    stringify: __webpack_require__(/*! ./stringify */ "./node_modules/@hapi/hoek/lib/stringify.js"),
    wait: __webpack_require__(/*! ./wait */ "./node_modules/@hapi/hoek/lib/wait.js")
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/intersect.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/intersect.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (array1, array2, options = {}) {

    if (!array1 ||
        !array2) {

        return (options.first ? null : []);
    }

    const common = [];
    const hash = (Array.isArray(array1) ? new Set(array1) : array1);
    const found = new Set();
    for (const value of array2) {
        if (internals.has(hash, value) &&
            !found.has(value)) {

            if (options.first) {
                return value;
            }

            common.push(value);
            found.add(value);
        }
    }

    return (options.first ? null : common);
};


internals.has = function (ref, key) {

    if (typeof ref.has === 'function') {
        return ref.has(key);
    }

    return ref[key] !== undefined;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/merge.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/merge.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = internals.merge = function (target, source, options) {

    Assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    Assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);

    if (Array.isArray(source)) {
        Assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (!options.mergeArrays) {
            target.length = 0;                                                          // Must not change target assignment
        }

        for (let i = 0; i < source.length; ++i) {
            target.push(Clone(source[i], { symbols: options.symbols }));
        }

        return target;
    }

    const keys = Utils.keys(source, options);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === '__proto__' ||
            !Object.prototype.propertyIsEnumerable.call(source, key)) {

            continue;
        }

        const value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) !== Array.isArray(value)) ||
                value instanceof Date ||
                (Buffer && Buffer.isBuffer(value)) ||               // $lab:coverage:ignore$
                value instanceof RegExp) {

                target[key] = Clone(value, { symbols: options.symbols });
            }
            else {
                internals.merge(target[key], value, options);
            }
        }
        else {
            if (value !== null &&
                value !== undefined) {                              // Explicit to preserve empty strings

                target[key] = value;
            }
            else if (options.nullOverride) {
                target[key] = value;
            }
        }
    }

    return target;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/once.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/once.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (method) {

    if (method._hoekOnce) {
        return method;
    }

    let once = false;
    const wrapped = function (...args) {

        if (!once) {
            once = true;
            method(...args);
        }
    };

    wrapped._hoekOnce = true;
    return wrapped;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/reach.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/reach.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = function (obj, chain, options) {

    if (chain === false ||
        chain === null ||
        chain === undefined) {

        return obj;
    }

    options = options || {};
    if (typeof options === 'string') {
        options = { separator: options };
    }

    const isChainArray = Array.isArray(chain);

    Assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');

    const path = isChainArray ? chain : chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);

        if (Array.isArray(ref) ||
            type === 'set') {

            const number = Number(key);
            if (Number.isInteger(number)) {
                key = number < 0 ? ref.length + number : number;
            }
        }

        if (!ref ||
            typeof ref === 'function' && options.functions === false ||         // Defaults to true
            !type && ref[key] === undefined) {

            Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
            Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        }

        if (!type) {
            ref = ref[key];
        }
        else if (type === 'set') {
            ref = [...ref][key];
        }
        else {  // type === 'map'
            ref = ref.get(key);
        }
    }

    return ref;
};


internals.iterables = function (ref) {

    if (ref instanceof Set) {
        return 'set';
    }

    if (ref instanceof Map) {
        return 'map';
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/reachTemplate.js":
/*!******************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/reachTemplate.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");


const internals = {};


module.exports = function (obj, template, options) {

    return template.replace(/{([^}]+)}/g, ($0, chain) => {

        const value = Reach(obj, chain, options);
        return (value === undefined || value === null ? '' : value);
    });
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/stringify.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/stringify.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (...args) {

    try {
        return JSON.stringify.apply(null, args);
    }
    catch (err) {
        return '[Cannot display object: ' + err.message + ']';
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/types.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/types.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,             // $lab:coverage:ignore$
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
};


internals.typeMap = new Map([
    ['[object Error]', exports.error],
    ['[object Map]', exports.map],
    ['[object Promise]', exports.promise],
    ['[object Set]', exports.set],
    ['[object WeakMap]', exports.weakMap],
    ['[object WeakSet]', exports.weakSet]
]);


exports.getInternalProto = function (obj) {

    if (Array.isArray(obj)) {
        return exports.array;
    }

    if (Buffer && obj instanceof Buffer) {          // $lab:coverage:ignore$
        return exports.buffer;
    }

    if (obj instanceof Date) {
        return exports.date;
    }

    if (obj instanceof RegExp) {
        return exports.regex;
    }

    if (obj instanceof Error) {
        return exports.error;
    }

    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");


const internals = {};


exports.keys = function (obj, options = {}) {

    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);  // Defaults to true
};


exports.store = function (source, keys) {

    const storage = new Map();
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = Reach(source, key);
        if (typeof value === 'object' ||
            typeof value === 'function') {

            storage.set(key, value);
            internals.reachSet(source, key, undefined);
        }
    }

    return storage;
};


exports.restore = function (copy, source, storage) {

    for (const [key, value] of storage) {
        internals.reachSet(copy, key, value);
        internals.reachSet(source, key, value);
    }
};


internals.reachSet = function (obj, key, value) {

    const path = Array.isArray(key) ? key : key.split('.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        const segment = path[i];
        if (i + 1 === path.length) {
            ref[segment] = value;
        }

        ref = ref[segment];
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/wait.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/wait.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (timeout) {

    return new Promise((resolve) => setTimeout(resolve, timeout));
};


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/directory.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/inert/lib/directory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Path = __webpack_require__(/*! path */ "path");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const File = __webpack_require__(/*! ./file */ "./node_modules/@hapi/inert/lib/file.js");
const Fs = __webpack_require__(/*! ./fs */ "./node_modules/@hapi/inert/lib/fs.js");


const internals = {};


internals.schema = Joi.object({
    path: Joi.alternatives(Joi.array().items(Joi.string()).single(), Joi.func()).required(),
    index: Joi.alternatives(Joi.boolean(), Joi.array().items(Joi.string()).single()).default(true),
    listing: Joi.boolean(),
    showHidden: Joi.boolean(),
    redirectToSlash: Joi.boolean(),
    lookupCompressed: Joi.boolean(),
    lookupMap: Joi.object().min(1).pattern(/.+/, Joi.string()),
    etagMethod: Joi.string().valid('hash', 'simple').allow(false),
    defaultExtension: Joi.string().alphanum()
});


internals.resolvePathOption = function (result) {

    if (result instanceof Error) {
        throw result;
    }

    if (typeof result === 'string') {
        return [result];
    }

    if (Array.isArray(result)) {
        return result;
    }

    throw Boom.internal('Invalid path function');
};


exports.handler = function (route, options) {

    const settings = Joi.attempt(options, internals.schema, 'Invalid directory handler options (' + route.path + ')');
    Hoek.assert(route.path[route.path.length - 1] === '}', 'The route path for a directory handler must end with a parameter:', route.path);

    const paramName = /\w+/.exec(route.path.slice(route.path.lastIndexOf('{')))[0];
    const basePath = route.settings.files.relativeTo;

    const normalized = (Array.isArray(settings.path) ? settings.path : null);                            // Array or function
    const indexNames = (settings.index === true) ? ['index.html'] : (settings.index || []);

    // Declare handler

    const handler = async (request, reply) => {

        const paths = normalized || internals.resolvePathOption(settings.path.call(null, request));

        // Append parameter

        const selection = request.params[paramName];
        if (selection &&
            !settings.showHidden &&
            internals.isFileHidden(selection)) {

            throw Boom.notFound(null, {});
        }

        if (!selection &&
            (request.server.settings.router.stripTrailingSlash || !request.path.endsWith('/'))) {

            request.path += '/';
        }

        // Generate response

        const resource = request.path;
        const hasTrailingSlash = resource.endsWith('/');
        const fileOptions = {
            confine: null,
            lookupCompressed: settings.lookupCompressed,
            lookupMap: settings.lookupMap,
            etagMethod: settings.etagMethod
        };

        const each = async (baseDir) => {

            fileOptions.confine = baseDir;

            let path = selection || '';
            let error;

            try {
                return await File.load(path, request, fileOptions);
            }
            catch (err) {
                Bounce.ignore(err, 'boom');
                error = err;
            }

            // Handle Not found

            if (internals.isNotFound(error)) {
                if (!settings.defaultExtension) {
                    throw error;
                }

                if (hasTrailingSlash) {
                    path = path.slice(0, -1);
                }

                return await File.load(path + '.' + settings.defaultExtension, request, fileOptions);
            }

            // Handle Directory

            if (internals.isDirectory(error)) {
                if (settings.redirectToSlash !== false &&                       // Defaults to true
                    !request.server.settings.router.stripTrailingSlash &&
                    !hasTrailingSlash) {

                    return reply.redirect(resource + '/');
                }

                for (const indexName of indexNames) {
                    const indexFile = Path.join(path, indexName);
                    try {
                        return await File.load(indexFile, request, fileOptions);
                    }
                    catch (err) {
                        Bounce.ignore(err, 'boom');

                        if (!internals.isNotFound(err)) {
                            throw Boom.internal(indexName + ' is a directory', err);
                        }

                        // Not found - try next
                    }
                }

                // None of the index files were found

                if (settings.listing) {
                    return internals.generateListing(Path.join(basePath, baseDir, path), resource, selection, hasTrailingSlash, settings, request);
                }
            }

            throw error;
        };

        for (let i = 0; i < paths.length; ++i) {
            try {
                return await each(paths[i]);
            }
            catch (err) {
                Bounce.ignore(err, 'boom');

                // Propagate any non-404 errors

                if (!internals.isNotFound(err) ||
                    i === paths.length - 1) {
                    throw err;
                }
            }
        }

        throw Boom.notFound(null, {});
    };

    return handler;
};


internals.generateListing = async function (path, resource, selection, hasTrailingSlash, settings, request) {

    let files;
    try {
        files = await Fs.readdir(path);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        throw Boom.internal('Error accessing directory', err);
    }

    resource = decodeURIComponent(resource);
    const display = Hoek.escapeHtml(resource);
    let html = '<html><head><title>' + display + '</title></head><body><h1>Directory: ' + display + '</h1><ul>';

    if (selection) {
        const parent = resource.substring(0, resource.lastIndexOf('/', resource.length - (hasTrailingSlash ? 2 : 1))) + '/';
        html = html + '<li><a href="' + internals.pathEncode(parent) + '">Parent Directory</a></li>';
    }

    for (let i = 0; i < files.length; ++i) {
        if (settings.showHidden ||
            !internals.isFileHidden(files[i])) {

            html = html + '<li><a href="' + internals.pathEncode(resource + (!hasTrailingSlash ? '/' : '') + files[i]) + '">' + Hoek.escapeHtml(files[i]) + '</a></li>';
        }
    }

    html = html + '</ul></body></html>';

    return request.generateResponse(html);
};


internals.isFileHidden = function (path) {

    return /(^|[\\\/])\.([^.\\\/]|\.[^\\\/])/.test(path);           // Starts with a '.' or contains '/.' or '\.', which is not followed by a '/' or '\' or '.'
};


internals.pathEncode = function (path) {

    return encodeURIComponent(path).replace(/%2F/g, '/').replace(/%5C/g, '\\');
};


internals.isNotFound = function (boom) {

    return boom.output.statusCode === 404;
};


internals.isDirectory = function (boom) {

    return boom.output.statusCode === 403 && boom.data.code === 'EISDIR';
};


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/etag.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/etag.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const LruCache = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");


const internals = {
    pendings: Object.create(null)
};


internals.streamEnd = function (stream) {

    return new Promise((resolve, reject) => {

        stream.on('end', resolve);
        stream.on('error', reject);
    });
};


internals.computeHashed = async function (response, stat) {

    const etags = response.request.server.plugins.inert._etags;
    if (!etags) {
        return null;
    }

    // Use stat info for an LRU cache key.

    const path = response.source.path;
    const cachekey = [path, stat.ino, stat.size, stat.mtime.getTime()].join('-');

    // The etag hashes the file contents in order to be consistent across distributed deployments

    const cachedEtag = etags.get(cachekey);
    if (cachedEtag) {
        return cachedEtag;
    }

    let promise = internals.pendings[cachekey];
    if (promise) {
        return await promise;
    }

    // Start hashing

    const compute = async () => {

        try {
            const hash = await internals.hashFile(response);
            etags.set(cachekey, hash);

            return hash;
        }
        finally {
            delete internals.pendings[cachekey];
        }
    };

    internals.pendings[cachekey] = promise = compute();

    return await promise;
};


internals.hashFile = async function (response) {

    const hash = Crypto.createHash('sha1');
    hash.setEncoding('hex');

    const fileStream = response.source.file.createReadStream({ autoClose: false });
    fileStream.pipe(hash);

    try {
        await internals.streamEnd(fileStream);
        return hash.read();
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        throw Boom.boomify(err, { message: 'Failed to hash file', data: { path: response.source.path } });
    }
};


internals.computeSimple = function (response, stat) {

    const size = stat.size.toString(16);
    const mtime = stat.mtime.getTime().toString(16);

    return size + '-' + mtime;
};


exports.apply = async function (response, stat) {

    const etagMethod = response.source.settings.etagMethod;
    if (etagMethod === false) {
        return;
    }

    let etag;
    if (etagMethod === 'simple') {
        etag = internals.computeSimple(response, stat);
    }
    else {
        etag = await internals.computeHashed(response, stat);
    }

    if (etag !== null) {
        response.etag(etag, { vary: true });
    }
};


exports.Cache = LruCache;


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/file.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/file.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Path = __webpack_require__(/*! path */ "path");

const Ammo = __webpack_require__(/*! @hapi/ammo */ "./node_modules/@hapi/ammo/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const Etag = __webpack_require__(/*! ./etag */ "./node_modules/@hapi/inert/lib/etag.js");
const Fs = __webpack_require__(/*! ./fs */ "./node_modules/@hapi/inert/lib/fs.js");


const internals = {};


internals.defaultMap = {
    gzip: '.gz'
};


internals.schema = Joi.alternatives([
    Joi.string(),
    Joi.func(),
    Joi.object({
        path: Joi.alternatives(Joi.string(), Joi.func()).required(),
        confine: Joi.alternatives(Joi.string(), Joi.boolean()).default(true),
        filename: Joi.string(),
        mode: Joi.string().valid('attachment', 'inline').allow(false),
        lookupCompressed: Joi.boolean(),
        lookupMap: Joi.object().min(1).pattern(/.+/, Joi.string()),
        etagMethod: Joi.string().valid('hash', 'simple').allow(false),
        start: Joi.number().integer().min(0).default(0),
        end: Joi.number().integer().min(Joi.ref('start'))
    })
        .with('filename', 'mode')
]);


exports.handler = function (route, options) {

    let settings = Joi.attempt(options, internals.schema, 'Invalid file handler options (' + route.path + ')');
    settings = (typeof options !== 'object' ? { path: options, confine: '.' } : settings);
    settings.confine = settings.confine === true ? '.' : settings.confine;
    Hoek.assert(typeof settings.path !== 'string' || settings.path[settings.path.length - 1] !== '/', 'File path cannot end with a \'/\':', route.path);

    const handler = (request) => {

        const path = (typeof settings.path === 'function' ? settings.path(request) : settings.path);
        return exports.response(path, settings, request);
    };

    return handler;
};


exports.load = function (path, request, options) {

    const response = exports.response(path, options, request, true);
    return internals.prepare(response);
};


exports.response = function (path, options, request, _preloaded) {

    Hoek.assert(!options.mode || ['attachment', 'inline'].indexOf(options.mode) !== -1, 'options.mode must be either false, attachment, or inline');

    if (options.confine) {
        const confineDir = Path.resolve(request.route.settings.files.relativeTo, options.confine);
        path = Path.isAbsolute(path) ? Path.normalize(path) : Path.join(confineDir, path);

        // Verify that resolved path is within confineDir
        if (path.lastIndexOf(confineDir, 0) !== 0) {
            path = null;
        }
    }
    else {
        path = Path.isAbsolute(path) ? Path.normalize(path) : Path.join(request.route.settings.files.relativeTo, path);
    }

    const source = {
        path,
        settings: options,
        stat: null,
        file: null
    };

    const prepare = _preloaded ? null : internals.prepare;

    return request.generateResponse(source, { variety: 'file', marshal: internals.marshal, prepare, close: internals.close });
};


internals.prepare = async function (response) {

    const path = response.source.path;

    if (path === null) {
        throw Boom.forbidden(null, { code: 'EACCES' });
    }

    const file = response.source.file = new Fs.File(path);

    try {
        const stat = await file.openStat('r');

        const start = response.source.settings.start || 0;
        if (response.source.settings.end !== undefined) {
            response.bytes(response.source.settings.end - start + 1);
        }
        else {
            response.bytes(stat.size - start);
        }

        if (!response.headers['content-type']) {
            response.type(response.request.server.mime.path(path).type || 'application/octet-stream');
        }

        response.header('last-modified', stat.mtime.toUTCString());

        if (response.source.settings.mode) {
            const fileName = response.source.settings.filename || Path.basename(path);
            response.header('content-disposition', response.source.settings.mode + '; filename=' + encodeURIComponent(fileName));
        }

        await Etag.apply(response, stat);

        return response;
    }
    catch (err) {
        internals.close(response);
        throw err;
    }
};


internals.marshal = async function (response) {

    if (response.source.settings.lookupCompressed &&
        !response.source.settings.start &&
        response.source.settings.end === undefined &&
        response.request.server.settings.compression !== false) {

        const lookupMap = response.source.settings.lookupMap || internals.defaultMap;
        const encoding = response.request.info.acceptEncoding;
        const extension = lookupMap.hasOwnProperty(encoding) ? lookupMap[encoding] : null;
        if (extension) {
            const precompressed = new Fs.File(`${response.source.path}${extension}`);
            let stat;
            try {
                stat = await precompressed.openStat('r');
            }
            catch (err) {
                precompressed.close();
                Bounce.ignore(err, 'boom');
            }

            if (stat) {
                response.source.file.close();
                response.source.file = precompressed;

                response.bytes(stat.size);
                response.header('content-encoding', encoding);
                response.vary('accept-encoding');
            }
        }
    }

    return internals.createStream(response);
};


internals.addContentRange = function (response) {

    const request = response.request;
    const length = response.headers['content-length'];
    let range = null;

    if (request.route.settings.response.ranges) {
        if (request.headers.range && length) {

            // Check If-Range

            if (!request.headers['if-range'] ||
                request.headers['if-range'] === response.headers.etag) {            // Ignoring last-modified date (weak)

                // Check that response is not encoded once transmitted

                const mime = request.server.mime.type(response.headers['content-type'] || 'application/octet-stream');
                const encoding = (request.server.settings.compression && mime.compressible && !response.headers['content-encoding'] ? request.info.acceptEncoding : null);

                if (encoding === 'identity' || !encoding) {

                    // Parse header

                    const ranges = Ammo.header(request.headers.range, length);
                    if (!ranges) {
                        const error = Boom.rangeNotSatisfiable();
                        error.output.headers['content-range'] = 'bytes */' + length;
                        throw error;
                    }

                    // Prepare transform

                    if (ranges.length === 1) {                                          // Ignore requests for multiple ranges
                        range = ranges[0];
                        response.code(206);
                        response.bytes(range.to - range.from + 1);
                        response.header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);
                    }
                }
            }
        }

        response.header('accept-ranges', 'bytes');
    }

    return range;
};


internals.createStream = function (response) {

    const source = response.source;

    Hoek.assert(source.file !== null);

    const range = internals.addContentRange(response);

    const options = {
        start: source.settings.start || 0,
        end: source.settings.end
    };

    if (range) {
        options.end = range.to + options.start;
        options.start = range.from + options.start;
    }

    return source.file.createReadStream(options);
};


internals.close = function (response) {

    if (response.source.file !== null) {
        response.source.file.close();
        response.source.file = null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/fs.js":
/*!********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/fs.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Fs = __webpack_require__(/*! fs */ "fs");
const Util = __webpack_require__(/*! util */ "util");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    methods: {
        promised: ['open', 'close', 'fstat', 'readdir'],
        raw: ['createReadStream']
    }
};


exports.File = function (path) {

    this.path = path;
    this.fd = null;
};


exports.File.prototype.open = async function (mode) {

    Hoek.assert(this.fd === null);

    try {
        this.fd = await exports.open(this.path, mode);
    }
    catch (err) {
        const data = { path: this.path };

        if (this.path.indexOf('\u0000') !== -1 || err.code === 'ENOENT') {
            throw Boom.notFound(null, data);
        }

        if (err.code === 'EACCES' || err.code === 'EPERM') {
            data.code = err.code;
            throw Boom.forbidden(null, data);
        }

        throw Boom.boomify(err, { message: 'Failed to open file', data });
    }
};


exports.File.prototype.close = function () {

    if (this.fd !== null) {
        Bounce.background(exports.close(this.fd));
        this.fd = null;
    }
};


exports.File.prototype.stat = async function () {

    Hoek.assert(this.fd !== null);

    try {
        const stat = await exports.fstat(this.fd);

        if (stat.isDirectory()) {
            throw Boom.forbidden(null, { code: 'EISDIR', path: this.path });
        }

        return stat;
    }
    catch (err) {
        this.close(this.fd);

        Bounce.rethrow(err, ['boom', 'system']);
        throw Boom.boomify(err, { message: 'Failed to stat file', data: { path: this.path } });
    }
};


exports.File.prototype.openStat = async function (mode) {

    await this.open(mode);
    return this.stat();
};


exports.File.prototype.createReadStream = function (options) {

    Hoek.assert(this.fd !== null);

    options = Object.assign({ fd: this.fd, start: 0 }, options);

    const stream = exports.createReadStream(this.path, options);

    if (options.autoClose !== false) {
        this.fd = null;           // The stream now owns the fd
    }

    return stream;
};


// Export Fs methods

for (let i = 0; i < internals.methods.raw.length; ++i) {
    const method = internals.methods.raw[i];
    exports[method] = Fs[method].bind(Fs);
}

for (let i = 0; i < internals.methods.promised.length; ++i) {
    const method = internals.methods.promised[i];
    exports[method] = Util.promisify(Fs[method]);
}


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const Directory = __webpack_require__(/*! ./directory */ "./node_modules/@hapi/inert/lib/directory.js");
const Etag = __webpack_require__(/*! ./etag */ "./node_modules/@hapi/inert/lib/etag.js");
const File = __webpack_require__(/*! ./file */ "./node_modules/@hapi/inert/lib/file.js");


const internals = {
    schema: Joi.object({
        etagsCacheMaxSize: Joi.number().integer().min(0).default(1000)
    }).required()
};


internals.fileMethod = function (path, responseOptions) {

    // Set correct confine value

    responseOptions = responseOptions || {};

    if (typeof responseOptions.confine === 'undefined' || responseOptions.confine === true) {
        responseOptions.confine = '.';
    }

    Hoek.assert(responseOptions.end === undefined || +responseOptions.start <= +responseOptions.end, 'options.start must be less than or equal to options.end');

    return this.response(File.response(path, responseOptions, this.request));
};


exports.plugin = {
    name: 'inert',
    pkg: __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/inert/package.json"),
    once: true,
    requirements: {
        hapi: '>=17.7.0'
    },

    register(server, options) {

        Hoek.assert(Object.keys(options).length === 0, 'Inert does not support registration options');
        const settings = Joi.attempt(Hoek.reach(server.settings.plugins, 'inert') || {}, internals.schema, 'Invalid "inert" server options');

        server.expose('_etags', settings.etagsCacheMaxSize > 0 ? new Etag.Cache(settings.etagsCacheMaxSize) : null);

        server.decorate('handler', 'file', File.handler);
        server.decorate('handler', 'directory', Directory.handler);
        server.decorate('toolkit', 'file', internals.fileMethod);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/inert/package.json":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/inert/package.json ***!
  \***********************************************/
/*! exports provided: name, description, version, repository, main, keywords, dependencies, devDependencies, scripts, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/inert\",\"description\":\"Static file and directory handlers plugin for hapi.js\",\"version\":\"5.2.2\",\"repository\":\"https://github.com/hapijs/inert.git\",\"main\":\"lib/index.js\",\"keywords\":[\"file\",\"directory\",\"handler\",\"hapi\",\"plugin\"],\"dependencies\":{\"@hapi/ammo\":\"3.x.x\",\"@hapi/boom\":\"7.x.x\",\"@hapi/bounce\":\"1.x.x\",\"@hapi/hoek\":\"8.x.x\",\"@hapi/joi\":\"16.x.x\",\"lru-cache\":\"4.1.x\"},\"devDependencies\":{\"@hapi/code\":\"6.x.x\",\"@hapi/file\":\"1.x.x\",\"@hapi/hapi\":\"18.x.x\",\"@hapi/lab\":\"20.x.x\"},\"scripts\":{\"test\":\"lab -f -a @hapi/code -t 100 -L\",\"test-cov-html\":\"lab -f -a @hapi/code -r html -o coverage.html\"},\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/iron/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/iron/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");

const B64 = __webpack_require__(/*! @hapi/b64 */ "./node_modules/@hapi/b64/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Cryptiles = __webpack_require__(/*! @hapi/cryptiles */ "./node_modules/@hapi/cryptiles/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports.defaults = {
    encryption: {
        saltBits: 256,
        algorithm: 'aes-256-cbc',
        iterations: 1,
        minPasswordlength: 32
    },

    integrity: {
        saltBits: 256,
        algorithm: 'sha256',
        iterations: 1,
        minPasswordlength: 32
    },

    ttl: 0,                                             // Milliseconds, 0 means forever
    timestampSkewSec: 60,                               // Seconds of permitted clock skew for incoming expirations
    localtimeOffsetMsec: 0                              // Local clock time offset express in a number of milliseconds (positive or negative)
};


// Algorithm configuration

exports.algorithms = {
    'aes-128-ctr': { keyBits: 128, ivBits: 128 },
    'aes-256-cbc': { keyBits: 256, ivBits: 128 },
    'sha256': { keyBits: 256 }
};


// MAC normalization format version

exports.macFormatVersion = '2';                         // Prevent comparison of mac values generated with different normalized string formats

exports.macPrefix = 'Fe26.' + exports.macFormatVersion;


// Generate a unique encryption key

/*
    const options =  {
        saltBits: 256,                                  // Ignored if salt is set
        salt: '4d8nr9q384nr9q384nr93q8nruq9348run',
        algorithm: 'aes-128-ctr',
        iterations: 10000,
        iv: 'sdfsdfsdfsdfscdrgercgesrcgsercg',          // Optional
        minPasswordlength: 32
    };
*/

exports.generateKey = async function (password, options) {

    if (!password) {
        throw new Boom('Empty password');
    }

    if (!options ||
        typeof options !== 'object') {

        throw new Boom('Bad options');
    }

    const algorithm = exports.algorithms[options.algorithm];
    if (!algorithm) {
        throw new Boom('Unknown algorithm: ' + options.algorithm);
    }

    const result = {};

    if (Buffer.isBuffer(password)) {
        if (password.length < algorithm.keyBits / 8) {
            throw new Boom('Key buffer (password) too small');
        }

        result.key = password;
        result.salt = '';
    }
    else {
        if (password.length < options.minPasswordlength) {
            throw new Boom('Password string too short (min ' + options.minPasswordlength + ' characters required)');
        }

        let salt = options.salt;
        if (!salt) {
            if (!options.saltBits) {
                throw new Boom('Missing salt and saltBits options');
            }

            const randomSalt = Cryptiles.randomBits(options.saltBits);
            salt = randomSalt.toString('hex');
        }

        const derivedKey = await internals.pbkdf2(password, salt, options.iterations, algorithm.keyBits / 8, 'sha1');

        result.key = derivedKey;
        result.salt = salt;
    }

    if (options.iv) {
        result.iv = options.iv;
    }
    else if (algorithm.ivBits) {
        result.iv = Cryptiles.randomBits(algorithm.ivBits);
    }

    return result;
};


// Encrypt data
// options: see exports.generateKey()

exports.encrypt = async function (password, options, data) {

    const key = await exports.generateKey(password, options);
    const cipher = Crypto.createCipheriv(options.algorithm, key.key, key.iv);
    const encrypted = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);

    return { encrypted, key };
};


// Decrypt data
// options: see exports.generateKey()

exports.decrypt = async function (password, options, data) {

    const key = await exports.generateKey(password, options);
    const decipher = Crypto.createDecipheriv(options.algorithm, key.key, key.iv);
    let dec = decipher.update(data, null, 'utf8');
    dec = dec + decipher.final('utf8');

    return dec;
};


// HMAC using a password
// options: see exports.generateKey()

exports.hmacWithPassword = async function (password, options, data) {

    const key = await exports.generateKey(password, options);
    const hmac = Crypto.createHmac(options.algorithm, key.key).update(data);
    const digest = hmac.digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');

    return {
        digest,
        salt: key.salt
    };
};


// Normalizes a password parameter into a { id, encryption, integrity } object
// password: string, buffer or object with { id, secret } or { id, encryption, integrity }

internals.normalizePassword = function (password) {

    if (password &&
        typeof password === 'object' &&
        !Buffer.isBuffer(password)) {

        return {
            id: password.id,
            encryption: password.secret || password.encryption,
            integrity: password.secret || password.integrity
        };
    }

    return {
        encryption: password,
        integrity: password
    };
};


// Encrypt and HMAC an object
// password: string, buffer or object with { id, secret } or { id, encryption, integrity }
// options: see exports.defaults

exports.seal = async function (object, password, options) {

    options = Object.assign({}, options);       // Shallow cloned to prevent changes during async operations

    const now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    // Serialize object

    const objectString = internals.stringify(object);

    // Obtain password

    let passwordId = '';
    password = internals.normalizePassword(password);
    if (password.id) {
        if (!/^\w+$/.test(password.id)) {
            throw new Boom('Invalid password id');
        }

        passwordId = password.id;
    }

    // Encrypt object string

    const { encrypted, key } = await exports.encrypt(password.encryption, options.encryption, objectString);

    // Base64url the encrypted value

    const encryptedB64 = B64.base64urlEncode(encrypted);
    const iv = B64.base64urlEncode(key.iv);
    const expiration = (options.ttl ? now + options.ttl : '');
    const macBaseString = exports.macPrefix + '*' + passwordId + '*' + key.salt + '*' + iv + '*' + encryptedB64 + '*' + expiration;

    // Mac the combined values

    const mac = await exports.hmacWithPassword(password.integrity, options.integrity, macBaseString);

    // Put it all together

    // prefix*[password-id]*encryption-salt*encryption-iv*encrypted*[expiration]*hmac-salt*hmac
    // Allowed URI query name/value characters: *-. \d \w

    const sealed = macBaseString + '*' + mac.salt + '*' + mac.digest;
    return sealed;
};


// Decrypt and validate sealed string
// password: string, buffer or object with { id: secret } or { id: { encryption, integrity } }
// options: see exports.defaults

exports.unseal = async function (sealed, password, options) {

    options = Object.assign({}, options);                                       // Shallow cloned to prevent changes during async operations

    const now = Date.now() + (options.localtimeOffsetMsec || 0);                // Measure now before any other processing

    // Break string into components

    const parts = sealed.split('*');
    if (parts.length !== 8) {
        throw new Boom('Incorrect number of sealed components');
    }

    const macPrefix = parts[0];
    const passwordId = parts[1];
    const encryptionSalt = parts[2];
    const encryptionIv = parts[3];
    const encryptedB64 = parts[4];
    const expiration = parts[5];
    const hmacSalt = parts[6];
    const hmac = parts[7];
    const macBaseString = macPrefix + '*' + passwordId + '*' + encryptionSalt + '*' + encryptionIv + '*' + encryptedB64 + '*' + expiration;

    // Check prefix

    if (macPrefix !== exports.macPrefix) {
        throw new Boom('Wrong mac prefix');
    }

    // Check expiration

    if (expiration) {
        if (!expiration.match(/^\d+$/)) {
            throw new Boom('Invalid expiration');
        }

        const exp = parseInt(expiration, 10);
        if (exp <= (now - (options.timestampSkewSec * 1000))) {
            throw new Boom('Expired seal');
        }
    }

    // Obtain password

    if (!password) {
        throw new Boom('Empty password');
    }

    if (typeof password === 'object' &&
        !Buffer.isBuffer(password)) {

        password = password[passwordId || 'default'];
        if (!password) {
            throw new Boom('Cannot find password: ' + passwordId);
        }
    }

    password = internals.normalizePassword(password);

    // Check hmac

    const macOptions = Hoek.clone(options.integrity);
    macOptions.salt = hmacSalt;
    const mac = await exports.hmacWithPassword(password.integrity, macOptions, macBaseString);

    if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw new Boom('Bad hmac value');
    }

    // Decrypt

    try {
        var encrypted = B64.base64urlDecode(encryptedB64, 'buffer');
    }
    catch (err) {
        throw Boom.boomify(err);
    }

    const decryptOptions = Hoek.clone(options.encryption);
    decryptOptions.salt = encryptionSalt;

    try {
        decryptOptions.iv = B64.base64urlDecode(encryptionIv, 'buffer');
    }
    catch (err) {
        throw Boom.boomify(err);
    }

    const decrypted = await exports.decrypt(password.encryption, decryptOptions, encrypted);

    // Parse JSON

    try {
        return Bourne.parse(decrypted);
    }
    catch (err) {
        throw new Boom('Failed parsing sealed object JSON: ' + err.message);
    }
};


internals.stringify = function (object) {

    try {
        return JSON.stringify(object);
    }
    catch (err) {
        throw new Boom('Failed to stringify object: ' + err.message);
    }
};


internals.pbkdf2 = function (...args) {

    return new Promise((resolve, reject) => {

        const next = (err, result) => {

            if (err) {
                return reject(Boom.boomify(err));
            }

            resolve(result);
        };

        args.push(next);
        Crypto.pbkdf2(...args);
    });
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/base.js":
/*!********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/base.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ "./node_modules/@hapi/hoek/lib/merge.js");

const Cache = __webpack_require__(/*! ./cache */ "./node_modules/@hapi/joi/lib/cache.js");
const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ./compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Extend = __webpack_require__(/*! ./extend */ "./node_modules/@hapi/joi/lib/extend.js");
const Manifest = __webpack_require__(/*! ./manifest */ "./node_modules/@hapi/joi/lib/manifest.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");
const Modify = __webpack_require__(/*! ./modify */ "./node_modules/@hapi/joi/lib/modify.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Trace = __webpack_require__(/*! ./trace */ "./node_modules/@hapi/joi/lib/trace.js");
const Validator = __webpack_require__(/*! ./validator */ "./node_modules/@hapi/joi/lib/validator.js");
const Values = __webpack_require__(/*! ./values */ "./node_modules/@hapi/joi/lib/values.js");


const internals = {};


internals.Base = class {

    constructor(type) {

        // Naming: public, _private, $_extension, $_mutate{action}

        this.type = type;

        this.$_root = null;
        this._definition = {};
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;

        this._valids = null;
        this._invalids = null;

        this._flags = {};
        this._rules = [];
        this._singleRules = new Map();              // The rule options passed for non-multi rules

        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)

        this.$_temp = {                             // Runtime state (not cloned)
            ruleset: null,                          // null: use last, false: error, number: start position
            whens: {}                               // Runtime cache of generated whens
        };
    }

    // Manifest

    describe() {

        Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');
        return Manifest.describe(this);
    }

    // Rules

    allow(...values) {

        return this._values(values, '_valids');
    }

    alter(targets) {

        Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');
        Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');

        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
            const adjuster = targets[target];
            Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');
            obj.$_terms.alterations.push({ target, adjuster });
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    cast(to) {

        Assert(to === false || typeof to === 'string', 'Invalid to value');
        Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);

        return this.$_setFlag('cast', to === false ? undefined : to);
    }

    default(value, options) {

        return this._default('default', value, options);
    }

    description(desc) {

        Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

        return this.$_setFlag('description', desc);
    }

    empty(schema) {

        const obj = this.clone();

        if (schema !== undefined) {
            schema = obj.$_compile(schema, { override: false });
        }

        return obj.$_setFlag('empty', schema, { clone: false });
    }

    error(err) {

        Assert(err, 'Missing error');
        Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');

        return this.$_setFlag('error', err);
    }

    example(example, options = {}) {

        Assert(example !== undefined, 'Missing example');
        Common.assertOptions(options, ['override']);

        return this._inner('examples', example, { single: true, override: options.override });
    }

    external(method, description) {

        if (typeof method === 'object') {
            Assert(!description, 'Cannot combine options with description');
            description = method.description;
            method = method.method;
        }

        Assert(typeof method === 'function', 'Method must be a function');
        Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

        return this._inner('externals', { method, description }, { single: true });
    }

    failover(value, options) {

        return this._default('failover', value, options);
    }

    forbidden() {

        return this.presence('forbidden');
    }

    id(id) {

        if (!id) {
            return this.$_setFlag('id', undefined);
        }

        Assert(typeof id === 'string', 'id must be a non-empty string');
        Assert(/^[^\.]+$/.test(id), 'id cannot contain period character');

        return this.$_setFlag('id', id);
    }

    invalid(...values) {

        return this._values(values, '_invalids');
    }

    label(name) {

        Assert(name && typeof name === 'string', 'Label name must be a non-empty string');

        return this.$_setFlag('label', name);
    }

    meta(meta) {

        Assert(meta !== undefined, 'Meta cannot be undefined');

        return this._inner('metas', meta, { single: true });
    }

    note(...notes) {

        Assert(notes.length, 'Missing notes');
        for (const note of notes) {
            Assert(note && typeof note === 'string', 'Notes must be non-empty strings');
        }

        return this._inner('notes', notes);
    }

    only(mode = true) {

        Assert(typeof mode === 'boolean', 'Invalid mode:', mode);

        return this.$_setFlag('only', mode);
    }

    optional() {

        return this.presence('optional');
    }

    prefs(prefs) {

        Assert(prefs, 'Missing preferences');
        Assert(prefs.context === undefined, 'Cannot override context');
        Assert(prefs.externals === undefined, 'Cannot override externals');
        Assert(prefs.warnings === undefined, 'Cannot override warnings');
        Assert(prefs.debug === undefined, 'Cannot override debug');

        Common.checkPreferences(prefs);

        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
    }

    presence(mode) {

        Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);

        return this.$_setFlag('presence', mode);
    }

    raw(enabled = true) {

        return this.$_setFlag('result', enabled ? 'raw' : undefined);
    }

    result(mode) {

        Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);

        return this.$_setFlag('result', mode);
    }

    required() {

        return this.presence('required');
    }

    strict(enabled) {

        const obj = this.clone();

        const convert = enabled === undefined ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
    }

    strip(enabled = true) {

        return this.$_setFlag('result', enabled ? 'strip' : undefined);
    }

    tag(...tags) {

        Assert(tags.length, 'Missing tags');
        for (const tag of tags) {
            Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');
        }

        return this._inner('tags', tags);
    }

    unit(name) {

        Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

        return this.$_setFlag('unit', name);
    }

    valid(...values) {

        const obj = this.allow(...values);
        obj.$_setFlag('only', !!obj._valids, { clone: false });
        return obj;
    }

    when(condition, options) {

        const obj = this.clone();

        if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
        }

        const when = Compile.when(obj, condition, options);
        if (!['any', 'link'].includes(obj.type)) {
            const conditions = when.is ? [when] : when.switch;
            for (const item of conditions) {
                Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);
                Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);

            }
        }

        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
    }

    // Helpers

    cache(cache) {

        Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');
        Assert(!this._cache, 'Cannot override schema cache');

        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
    }

    clone() {

        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
    }

    concat(source) {

        Assert(Common.isSchema(source), 'Invalid schema object');
        Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);
        Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');
        Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');

        let obj = this.clone();

        if (this.type === 'any' &&
            source.type !== 'any') {

            // Change obj to match source type

            const tmpObj = source.clone();
            for (const key of Object.keys(obj)) {
                if (key !== 'type') {
                    tmpObj[key] = obj[key];
                }
            }

            obj = tmpObj;
        }

        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);

        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);

        // Remove unique rules present in source

        for (const name of source._singleRules.keys()) {
            if (obj._singleRules.has(name)) {
                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
                obj._singleRules.delete(name);
            }
        }

        // Rules

        for (const test of source._rules) {
            if (!source._definition.rules[test.method].multi) {
                obj._singleRules.set(test.name, test);
            }

            obj._rules.push(test);
        }

        // Flags

        if (obj._flags.empty &&
            source._flags.empty) {

            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            Merge(obj._flags, flags);
        }
        else if (source._flags.empty) {
            obj._flags.empty = source._flags.empty;
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            Merge(obj._flags, flags);
        }
        else {
            Merge(obj._flags, source._flags);
        }

        // Terms

        for (const key in source.$_terms) {
            const terms = source.$_terms[key];
            if (!terms) {
                if (!obj.$_terms[key]) {
                    obj.$_terms[key] = terms;
                }

                continue;
            }

            if (!obj.$_terms[key]) {
                obj.$_terms[key] = terms.slice();
                continue;
            }

            obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, source]);
        }

        // Rebuild

        return obj.$_mutateRebuild();
    }

    extend(options) {

        Assert(!options.base, 'Cannot extend type with another base');

        return Extend.type(this, options);
    }

    extract(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.reach(path);
    }

    fork(paths, adjuster) {

        Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');

        let obj = this;                                             // eslint-disable-line consistent-this
        for (let path of [].concat(paths)) {
            path = Array.isArray(path) ? path : path.split('.');
            obj = obj._ids.fork(path, adjuster, obj);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    rule(options) {

        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));

        Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');

        const obj = this.clone();

        for (let i = start; i < obj._rules.length; ++i) {
            const original = obj._rules[i];
            const rule = Clone(original);

            for (const name in options) {
                def.modifiers[name](rule, options[name]);
                Assert(rule.name === original.name, 'Cannot change rule name');
            }

            obj._rules[i] = rule;

            if (obj._singleRules.get(rule.name) === original) {
                obj._singleRules.set(rule.name, rule);
            }
        }

        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    get ruleset() {

        Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');

        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
    }

    get $() {

        return this.ruleset;
    }

    tailor(targets) {

        targets = [].concat(targets);

        Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');

        let obj = this;                                                     // eslint-disable-line consistent-this

        if (this.$_terms.alterations) {
            for (const { target, adjuster } of this.$_terms.alterations) {
                if (targets.includes(target)) {
                    obj = adjuster(obj);
                    Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');
                }
            }
        }

        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    tracer() {

        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$
    }

    validate(value, options) {

        return Validator.entry(value, this, options);
    }

    validateAsync(value, options) {

        return Validator.entryAsync(value, this, options);
    }

    // Extensions

    $_addRule(options) {

        // Normalize rule

        if (typeof options === 'string') {
            options = { name: options };
        }

        Assert(options && typeof options === 'object', 'Invalid options');
        Assert(options.name && typeof options.name === 'string', 'Invalid rule name');

        for (const key in options) {
            Assert(key[0] !== '_', 'Cannot set private rule properties');
        }

        const rule = Object.assign({}, options);        // Shallow cloned
        rule._resolve = [];
        rule.method = rule.method || rule.name;

        const definition = this._definition.rules[rule.method];
        const args = rule.args;

        Assert(definition, 'Unknown rule', rule.method);

        // Args

        const obj = this.clone();

        if (args) {
            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);

            for (const key in args) {
                let arg = args[key];
                if (arg === undefined) {
                    delete args[key];
                    continue;
                }

                if (definition.argsByName) {
                    const resolver = definition.argsByName.get(key);

                    if (resolver.ref &&
                        Common.isResolvable(arg)) {

                        rule._resolve.push(key);
                        obj.$_mutateRegister(arg);
                    }
                    else {
                        if (resolver.normalize) {
                            arg = resolver.normalize(arg);
                            args[key] = arg;
                        }

                        if (resolver.assert) {
                            const error = Common.validateArg(arg, key, resolver);
                            Assert(!error, error, 'or reference');
                        }
                    }
                }

                args[key] = arg;
            }
        }

        // Unique rules

        if (!definition.multi) {
            obj._ruleRemove(rule.name, { clone: false });
            obj._singleRules.set(rule.name, rule);
        }

        if (obj.$_temp.ruleset === false) {
            obj.$_temp.ruleset = null;
        }

        if (definition.priority) {
            obj._rules.unshift(rule);
        }
        else {
            obj._rules.push(rule);
        }

        return obj;
    }

    $_compile(schema, options) {

        return Compile.schema(this.$_root, schema, options);
    }

    $_createError(code, value, local, state, prefs, options = {}) {

        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }

    $_getFlag(name) {

        return this._flags[name];
    }

    $_getRule(name) {

        return this._singleRules.get(name);
    }

    $_mapLabels(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.labels(path);
    }

    $_match(value, state, prefs, overrides) {

        prefs = Object.assign({}, prefs);       // Shallow cloned
        prefs.abortEarly = true;
        prefs._externals = false;

        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();

        return result;
    }

    $_modify(options) {

        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);
        return Modify.schema(this, options) || this;
    }

    $_mutateRebuild() {

        Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');

        this._refs.reset();
        this._ids.reset();

        const each = (item, { source, name, path, key }) => {

            const family = this._definition[source][name] && this._definition[source][name].register;
            if (family !== false) {
                this.$_mutateRegister(item, { family, key });
            }
        };

        this.$_modify({ each });

        if (this._definition.rebuild) {
            this._definition.rebuild(this);
        }

        this.$_temp.ruleset = false;
        return this;
    }

    $_mutateRegister(schema, { family, key } = {}) {

        this._refs.register(schema, family);
        this._ids.register(schema, { key });
    }

    $_property(name) {

        return this._definition.properties[name];
    }

    $_reach(path) {

        return this._ids.reach(path);
    }

    $_rootReferences() {

        return this._refs.roots();
    }

    $_setFlag(name, value, options = {}) {

        Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');

        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
            value = undefined;
        }

        if (DeepEqual(value, this._flags[name])) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        if (value !== undefined) {
            obj._flags[name] = value;
            obj.$_mutateRegister(value);
        }
        else {
            delete obj._flags[name];
        }

        if (name[0] !== '_') {
            obj.$_temp.ruleset = false;
        }

        return obj;
    }

    $_validate(value, state, prefs) {

        return Validator.validate(value, this, state, prefs);
    }

    // Internals

    _assign(target) {

        target.type = this.type;

        target.$_root = this.$_root;

        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};

        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;

        target.$_terms = {};
        for (const key in this.$_terms) {
            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }

        target.$_super = {};
        for (const override in this.$_super) {
            target.$_super[override] = this._super[override].bind(target);
        }

        return target;
    }

    _default(flag, value, options = {}) {

        Common.assertOptions(options, 'literal');

        Assert(value !== undefined, 'Missing', flag, 'value');
        Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');

        if (typeof value === 'function' &&
            options.literal) {

            value = {
                [Common.symbols.literal]: true,
                literal: value
            };
        }

        const obj = this.$_setFlag(flag, value);
        return obj;
    }

    _generate(value, state, prefs) {

        if (!this.$_terms.whens) {
            return { schema: this };
        }

        // Collect matching whens

        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
            const when = this.$_terms.whens[i];

            if (when.concat) {
                whens.push(when.concat);
                ids.push(`${i}.concat`);
                continue;
            }

            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
            const tests = when.is ? [when] : when.switch;
            const before = ids.length;

            for (let j = 0; j < tests.length; ++j) {
                const { is, then, otherwise } = tests[j];

                const baseId = `${i}${when.switch ? '.' + j : ''}`;
                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
                    if (then) {
                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                        const { schema: generated, id } = then._generate(value, localState, prefs);
                        whens.push(generated);
                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);
                        break;
                    }
                }
                else if (otherwise) {
                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);
                    whens.push(generated);
                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);
                    break;
                }
            }

            if (when.break &&
                ids.length > before) {          // Something matched

                break;
            }
        }

        // Check cache

        const id = ids.join(', ');
        state.mainstay.tracer.debug(state, 'rule', 'when', id);

        if (!id) {
            return { schema: this };
        }

        if (!state.mainstay.tracer.active &&
            this.$_temp.whens[id]) {

            return { schema: this.$_temp.whens[id], id };
        }

        // Generate dynamic schema

        let obj = this;                                             // eslint-disable-line consistent-this
        if (this._definition.generate) {
            obj = this._definition.generate(this, value, state, prefs);
        }

        // Apply whens

        for (const when of whens) {
            obj = obj.concat(when);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, ...whens]);
        }

        // Cache result

        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
    }

    _inner(type, values, options = {}) {

        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);

        const obj = this.clone();
        if (!obj.$_terms[type] ||
            options.override) {

            obj.$_terms[type] = [];
        }

        if (options.single) {
            obj.$_terms[type].push(values);
        }
        else {
            obj.$_terms[type].push(...values);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    _inRuleset() {

        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }

    _ruleRemove(name, options = {}) {

        if (!this._singleRules.has(name)) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        obj._singleRules.delete(name);

        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
            const test = obj._rules[i];
            if (test.name === name &&
                !test.keep) {

                if (obj._inRuleset() &&
                    i < obj.$_temp.ruleset) {

                    --obj.$_temp.ruleset;
                }

                continue;
            }

            filtered.push(test);
        }

        obj._rules = filtered;
        return obj;
    }

    _values(values, key) {

        Common.verifyFlat(values, key.slice(1, -1));

        const obj = this.clone();

        const override = values[0] === Common.symbols.override;
        if (override) {
            values = values.slice(1);
        }

        if (!obj[key] &&
            values.length) {

            obj[key] = new Values();
        }
        else if (override) {
            obj[key] = values.length ? new Values() : null;
            obj.$_mutateRebuild();
        }

        if (!obj[key]) {
            return obj;
        }

        if (override) {
            obj[key].override();
        }

        for (const value of values) {
            Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            Assert(value !== Common.symbols.override, 'Override must be the first value');

            const other = key === '_invalids' ? '_valids' : '_invalids';
            if (obj[other]) {
                obj[other].remove(value);
                if (!obj[other].length) {
                    Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');
                    obj[other] = null;
                }
            }

            obj[key].add(value, obj._refs);
        }

        return obj;
    }
};


internals.Base.prototype.isImmutable = true;                        // Prevents Hoek from deep cloning schema objects


internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: '$_root'
};


// Aliases

internals.Base.prototype.deny = internals.Base.prototype.invalid;
internals.Base.prototype.disallow = internals.Base.prototype.invalid;
internals.Base.prototype.equal = internals.Base.prototype.valid;
internals.Base.prototype.exist = internals.Base.prototype.required;
internals.Base.prototype.not = internals.Base.prototype.invalid;
internals.Base.prototype.options = internals.Base.prototype.prefs;
internals.Base.prototype.preferences = internals.Base.prototype.prefs;


module.exports = new internals.Base();


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/cache.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/cache.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {
    max: 1000,
    supported: new Set(['undefined', 'boolean', 'number', 'string'])
};


exports.provider = {

    provision(options) {

        return new internals.Cache(options);
    }
};


// Least Recently Used (LRU) Cache

internals.Cache = class {

    constructor(options = {}) {

        Common.assertOptions(options, ['max']);
        Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');

        this._max = options.max || internals.max;

        this._map = new Map();                          // Map of nodes by key
        this._list = new internals.List();              // List of nodes (most recently used in head)
    }

    get length() {

        return this._map.size;
    }

    set(key, value) {

        if (key !== null &&
            !internals.supported.has(typeof key)) {

            return;
        }

        let node = this._map.get(key);
        if (node) {
            node.value = value;
            this._list.first(node);
            return;
        }

        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
    }

    get(key) {

        const node = this._map.get(key);
        if (node) {
            this._list.first(node);
            return Clone(node.value);
        }
    }

    _compact() {

        if (this._map.size > this._max) {
            const node = this._list.pop();
            this._map.delete(node.key);
        }
    }
};


internals.List = class {

    constructor() {

        this.tail = null;
        this.head = null;
    }

    unshift(node) {

        node.next = null;
        node.prev = this.head;

        if (this.head) {
            this.head.next = node;
        }

        this.head = node;

        if (!this.tail) {
            this.tail = node;
        }

        return node;
    }

    first(node) {

        if (node === this.head) {
            return;
        }

        this._remove(node);
        this.unshift(node);
    }

    pop() {

        return this._remove(this.tail);
    }

    _remove(node) {

        const { next, prev } = node;

        next.prev = prev;

        if (prev) {
            prev.next = next;
        }

        if (node === this.tail) {
            this.tail = next;
        }

        node.prev = null;
        node.next = null;

        return node;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/common.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/common.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const AssertError = __webpack_require__(/*! @hapi/hoek/lib/error */ "./node_modules/@hapi/hoek/lib/error.js");

const Pkg = __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/joi/package.json");

let Messages;
let Schemas;


const internals = {
    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
};


exports.version = Pkg.version;


exports.defaults = {
    abortEarly: true,
    allowUnknown: false,
    cache: true,
    context: null,
    convert: true,
    dateFormat: 'iso',
    errors: {
        escapeHtml: false,
        label: 'path',
        language: null,
        render: true,
        stack: false,
        wrapArrays: true
    },
    externals: true,
    messages: {},
    nonEnumerables: false,
    noDefaults: false,
    presence: 'optional',
    skipFunctions: false,
    stripUnknown: false,
    warnings: false
};


exports.symbols = {
    any: Symbol.for('@hapi/joi/schema'),            // Used to internally identify any-based types (shared with other joi versions)
    arraySingle: Symbol('arraySingle'),
    deepDefault: Symbol('deepDefault'),
    literal: Symbol('literal'),
    override: Symbol('override'),
    prefs: Symbol('prefs'),
    ref: Symbol('ref'),
    values: Symbol('values'),
    template: Symbol('template')
};


exports.assertOptions = function (options, keys, name = 'Options') {

    Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');
    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
};


exports.checkPreferences = function (prefs) {

    Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/@hapi/joi/lib/schemas.js");

    const result = Schemas.preferences.validate(prefs);

    if (result.error) {
        throw new AssertError([result.error.details[0].message]);
    }
};


exports.compare = function (a, b, operator) {

    switch (operator) {
        case '=': return a === b;
        case '>': return a > b;
        case '<': return a < b;
        case '>=': return a >= b;
        case '<=': return a <= b;
    }
};


exports.default = function (value, defaultValue) {

    return value === undefined ? defaultValue : value;
};


exports.isIsoDate = function (date) {

    return internals.isoDate.test(date);
};


exports.isNumber = function (value) {

    return typeof value === 'number' && !isNaN(value);
};


exports.isResolvable = function (obj) {

    if (!obj) {
        return false;
    }

    return obj[exports.symbols.ref] || obj[exports.symbols.template];
};


exports.isSchema = function (schema, options = {}) {

    const any = schema && schema[exports.symbols.any];
    if (!any) {
        return false;
    }

    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');
    return true;
};


exports.isValues = function (obj) {

    return obj[exports.symbols.values];
};


exports.limit = function (value) {

    return Number.isSafeInteger(value) && value >= 0;
};


exports.preferences = function (target, source) {

    Messages = Messages || __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");

    target = target || {};
    source = source || {};

    const merged = Object.assign({}, target, source);
    if (source.errors &&
        target.errors) {

        merged.errors = Object.assign({}, target.errors, source.errors);
    }

    if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
    }

    delete merged[exports.symbols.prefs];
    return merged;
};


exports.tryWithPath = function (fn, key, options = {}) {

    try {
        return fn();
    }
    catch (err) {
        if (err.path !== undefined) {
            err.path = key + '.' + err.path;
        }
        else {
            err.path = key;
        }

        if (options.append) {
            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


exports.validateArg = function (value, label, { assert, message }) {

    if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
            return;
        }

        return result.error.message;
    }
    else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
    }
};


exports.verifyFlat = function (args, method) {

    for (const arg of args) {
        Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/compile.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/compile.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {};


exports.schema = function (Joi, config, options = {}) {

    Common.assertOptions(options, ['appendPath', 'override']);

    try {
        return internals.schema(Joi, config, options);
    }
    catch (err) {
        if (options.appendPath &&
            err.path !== undefined) {

            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


internals.schema = function (Joi, config, options) {

    Assert(config !== undefined, 'Invalid undefined schema');

    if (Array.isArray(config)) {
        Assert(config.length, 'Invalid empty array schema');

        if (config.length === 1) {
            config = config[0];
        }
    }

    const valid = (base, ...values) => {

        if (options.override !== false) {
            return base.valid(Joi.override, ...values);
        }

        return base.valid(...values);
    };

    if (internals.simple(config)) {
        return valid(Joi, config);
    }

    if (typeof config === 'function') {
        return Joi.custom(config);
    }

    Assert(typeof config === 'object', 'Invalid schema content:', typeof config);

    if (Common.isResolvable(config)) {
        return valid(Joi, config);
    }

    if (Common.isSchema(config)) {
        return config;
    }

    if (Array.isArray(config)) {
        for (const item of config) {
            if (!internals.simple(item)) {
                return Joi.alternatives().try(...config);
            }
        }

        return valid(Joi, ...config);
    }

    if (config instanceof RegExp) {
        return Joi.string().regex(config);
    }

    if (config instanceof Date) {
        return valid(Joi.date(), config);
    }

    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    return Joi.object().keys(config);
};


exports.ref = function (id, options) {

    return Ref.isRef(id) ? id : Ref.create(id, options);
};


exports.compile = function (root, schema, options = {}) {

    Common.assertOptions(options, ['legacy']);

    // Compiled by any supported version

    const any = schema && schema[Common.symbols.any];
    if (any) {
        Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas');
        return schema;
    }

    // Uncompiled root

    if (typeof schema !== 'object' ||
        !options.legacy) {

        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions
    }

    // Scan schema for compiled parts

    const compiler = internals.walk(schema);
    if (!compiler) {
        return exports.schema(root, schema, { appendPath: true });
    }

    return compiler.compile(compiler.root, schema);
};


internals.walk = function (schema) {

    if (typeof schema !== 'object') {
        return null;
    }

    if (Array.isArray(schema)) {
        for (const item of schema) {
            const compiler = internals.walk(item);
            if (compiler) {
                return compiler;
            }
        }

        return null;
    }

    const any = schema[Common.symbols.any];
    if (any) {
        return { root: schema[any.root], compile: any.compile };
    }

    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
            return compiler;
        }
    }

    return null;
};


internals.simple = function (value) {

    return value === null || ['boolean', 'string', 'number'].includes(typeof value);
};


exports.when = function (schema, condition, options) {

    if (options === undefined) {
        Assert(condition && typeof condition === 'object', 'Missing options');

        options = condition;
        condition = Ref.create('.');
    }

    if (Array.isArray(options)) {
        options = { switch: options };
    }

    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);

    // Schema condition

    if (Common.isSchema(condition)) {
        Assert(options.is === undefined, '"is" can not be used with a schema condition');
        Assert(options.not === undefined, '"not" can not be used with a schema condition');
        Assert(options.switch === undefined, '"switch" can not be used with a schema condition');

        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
    }

    // Single condition

    Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);
    Assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');

    if (options.switch === undefined) {
        let rule = options;
        if (options.not !== undefined) {
            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }

        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();
        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');

        if (options.is !== undefined &&
            !Ref.isRef(options.is) &&
            !Common.isSchema(options.is)) {

            is = is.required();                     // Only apply required if this wasn't already a schema or a ref
        }

        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });
    }

    // Switch statement

    Assert(Array.isArray(options.switch), '"switch" must be an array');
    Assert(options.is === undefined, 'Cannot combine "switch" with "is"');
    Assert(options.not === undefined, 'Cannot combine "switch" with "not"');
    Assert(options.then === undefined, 'Cannot combine "switch" with "then"');

    const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
    };

    for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;

        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);

        Assert(test.is !== undefined, 'Switch statement missing "is"');
        Assert(test.then !== undefined, 'Switch statement missing "then"');

        const item = {
            is: schema.$_compile(test.is),
            then: schema.$_compile(test.then)
        };

        if (!Ref.isRef(test.is) &&
            !Common.isSchema(test.is)) {

            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref
        }

        if (last) {
            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;
            if (otherwise !== undefined) {
                Assert(rule.break === undefined, 'Cannot specify both otherwise and break');
                item.otherwise = schema.$_compile(otherwise);
            }
        }

        rule.switch.push(item);
    }

    return rule;
};


internals.condition = function (schema, condition) {

    for (const key of ['then', 'otherwise']) {
        if (condition[key] === undefined) {
            delete condition[key];
        }
        else {
            condition[key] = schema.$_compile(condition[key]);
        }
    }

    return condition;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/errors.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/errors.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {
    annotations: Symbol('annotations')
};


exports.Report = class {

    constructor(code, value, local, flags, messages, state, prefs) {

        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;

        this.message = null;
        this.template = null;

        this.local = local || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);

        if (this.value !== undefined &&
            !this.local.hasOwnProperty('value')) {

            this.local.value = this.value;
        }

        if (this.path.length) {
            const key = this.path[this.path.length - 1];
            if (typeof key !== 'object') {
                this.local.key = key;
            }
        }
    }

    _setTemplate(template) {

        this.template = template;

        if (!this.flags.label &&
            this.path.length === 0) {

            const localized = this._template(this.template, 'root');
            if (localized) {
                this.local.label = localized;
            }
        }
    }

    toString() {

        if (this.message) {
            return this.message;
        }

        const code = this.code;

        if (!this.prefs.errors.render) {
            return this.code;
        }

        const template = this._template(this.template) ||
            this._template(this.prefs.messages) ||
            this._template(this.messages);

        if (template === undefined) {
            return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }

        // Render and cache result

        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
            this.message = this.message.replace(/^"" /, '').trim();
        }

        return this.message;
    }

    _template(messages, code) {

        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
    }
};


exports.path = function (path) {

    let label = '';
    for (const segment of path) {
        if (typeof segment === 'object') {          // Exclude array single path segment
            continue;
        }

        if (typeof segment === 'string') {
            if (label) {
                label += '.';
            }

            label += segment;
        }
        else {
            label += `[${segment}]`;
        }
    }

    return label;
};


exports.template = function (value, messages, code, state, prefs) {

    if (!messages) {
        return;
    }

    if (Template.isTemplate(messages)) {
        return code !== 'root' ? messages : null;
    }

    let lang = prefs.errors.language;
    if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
    }

    if (lang &&
        messages[lang] &&
        messages[lang][code] !== undefined) {

        return messages[lang][code];
    }

    return messages[code];
};


exports.label = function (flags, state, prefs, messages) {

    if (flags.label) {
        return flags.label;
    }

    if (!prefs.errors.label) {
        return '';
    }

    let path = state.path;
    if (prefs.errors.label === 'key' &&
        state.path.length > 1) {

        path = state.path.slice(-1);
    }

    return exports.path(path) ||
        exports.template(null, prefs.messages, 'root', state, prefs) ||
        messages && exports.template(null, messages, 'root', state, prefs) ||
        'value';
};


exports.process = function (errors, original, prefs) {

    if (!errors) {
        return null;
    }

    const { override, message, details } = exports.details(errors);
    if (override) {
        return override;
    }

    if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
    }

    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const validationError = new exports.ValidationError(message, details, original);
    Error.stackTraceLimit = limit;
    return validationError;
};


exports.details = function (errors, options = {}) {

    let messages = [];
    const details = [];

    for (const item of errors) {

        // Override

        if (item instanceof Error) {
            if (options.override !== false) {
                return { override: item };
            }

            const message = item.toString();
            messages.push(message);

            details.push({
                message,
                type: 'override',
                context: { error: item }
            });

            continue;
        }

        // Report

        const message = item.toString();
        messages.push(message);

        details.push({
            message,
            path: item.path.filter((v) => typeof v !== 'object'),
            type: item.code,
            context: item.local
        });
    }

    if (messages.length > 1) {
        messages = [...new Set(messages)];
    }

    return { message: messages.join('. '), details };
};


exports.ValidationError = class extends Error {

    constructor(message, details, original) {

        super(message);
        this._original = original;
        this.details = details;
    }

    annotate(stripColorCodes) {

        if (!this._original ||
            typeof this._original !== 'object') {

            return this.details[0].message;
        }

        const redFgEscape = stripColorCodes ? '' : '\u001b[31m';
        const redBgEscape = stripColorCodes ? '' : '\u001b[41m';
        const endColor = stripColorCodes ? '' : '\u001b[0m';

        const obj = Clone(this._original);

        for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first
            const pos = i + 1;
            const error = this.details[i];
            const path = error.path;
            let node = obj;
            for (let j = 0; ; ++j) {
                const seg = path[j];

                if (Common.isSchema(node)) {
                    node = node.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step
                }

                if (j + 1 < path.length &&
                    typeof node[seg] !== 'string') {

                    node = node[seg];
                }
                else {
                    const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
                    node[internals.annotations] = refAnnotations;

                    const cacheKey = seg || error.context.key;

                    if (node[seg] !== undefined) {
                        refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                        refAnnotations.errors[cacheKey].push(pos);
                    }
                    else {
                        refAnnotations.missing[cacheKey] = pos;
                    }

                    break;
                }
            }
        }

        const replacers = {
            key: /_\$key\$_([, \d]+)_\$end\$_"/g,
            missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
            arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
            specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
        };

        let message = internals.safeStringify(obj, 2)
            .replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`)
            .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)
            .replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`)
            .replace(replacers.specials, ($0, $1) => $1);

        message = `${message}\n${redFgEscape}`;

        for (let i = 0; i < this.details.length; ++i) {
            const pos = i + 1;
            message = `${message}\n[${pos}] ${this.details[i].message}`;
        }

        message = message + endColor;

        return message;
    }
};


exports.ValidationError.prototype.isJoi = true;


exports.ValidationError.prototype.name = 'ValidationError';


// Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {

    return JSON.stringify(obj, internals.serializer(), spaces);
};


internals.serializer = function () {

    const keys = [];
    const stack = [];

    const cycleReplacer = (key, value) => {

        if (stack[0] === value) {
            return '[Circular ~]';
        }

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };

    return function (key, value) {

        if (stack.length > 0) {
            const thisPos = stack.indexOf(this);
            if (~thisPos) {
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            }
            else {
                stack.push(this);
                keys.push(key);
            }

            if (~stack.indexOf(value)) {
                value = cycleReplacer.call(this, key, value);
            }
        }
        else {
            stack.push(value);
        }

        if (value) {
            const annotations = value[internals.annotations];
            if (annotations) {
                if (Array.isArray(value)) {
                    const annotated = [];

                    for (let i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
                        }

                        annotated.push(value[i]);
                    }

                    value = annotated;
                }
                else {
                    for (const errorKey in annotations.errors) {
                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
                        value[errorKey] = undefined;
                    }

                    for (const missingKey in annotations.missing) {
                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
                    }
                }

                return value;
            }
        }

        if (value === Infinity ||
            value === -Infinity ||
            Number.isNaN(value) ||
            typeof value === 'function' ||
            typeof value === 'symbol') {

            return '[' + value.toString() + ']';
        }

        return value;
    };
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/extend.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/extend.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");


const internals = {};


exports.type = function (from, options) {

    const base = Object.getPrototypeOf(from);
    const prototype = Clone(base);
    const schema = from._assign(Object.create(prototype));
    const def = Object.assign({}, options);                                 // Shallow cloned
    delete def.base;

    prototype._definition = def;

    const parent = base._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);

    // Type

    schema.type = def.type;

    // Flags

    def.flags = Object.assign({}, parent.flags, def.flags);

    // Terms

    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
        for (const name in def.terms) {                                     // Only apply own terms
            const term = def.terms[name];
            Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);
            schema.$_terms[name] = term.init;
            terms[name] = term;
        }
    }

    def.terms = terms;

    // Constructor arguments

    if (!def.args) {
        def.args = parent.args;
    }

    // Prepare

    def.prepare = internals.prepare(def.prepare, parent.prepare);

    // Coerce

    if (def.coerce) {
        if (typeof def.coerce === 'function') {
            def.coerce = { method: def.coerce };
        }

        if (def.coerce.from &&
            !Array.isArray(def.coerce.from)) {

            def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
    }

    def.coerce = internals.coerce(def.coerce, parent.coerce);

    // Validate

    def.validate = internals.validate(def.validate, parent.validate);

    // Rules

    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
        for (const name in def.rules) {
            const rule = def.rules[name];
            Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);

            let method = rule.method;
            if (method === undefined) {
                method = function () {

                    return this.$_addRule(name);
                };
            }

            if (method) {
                Assert(!prototype[name], 'Rule conflict in', def.type, name);
                prototype[name] = method;
            }

            Assert(!rules[name], 'Rule conflict in', def.type, name);
            rules[name] = rule;

            if (rule.alias) {
                const aliases = [].concat(rule.alias);
                for (const alias of aliases) {
                    prototype[alias] = rule.method;
                }
            }

            if (rule.args) {
                rule.argsByName = new Map();
                rule.args = rule.args.map((arg) => {

                    if (typeof arg === 'string') {
                        arg = { name: arg };
                    }

                    Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);

                    if (Common.isSchema(arg.assert)) {
                        arg.assert = arg.assert.strict().label(arg.name);
                    }

                    rule.argsByName.set(arg.name, arg);
                    return arg;
                });
            }
        }
    }

    def.rules = rules;

    // Modifiers

    const modifiers = Object.assign({}, parent.modifiers);
    if (def.modifiers) {
        for (const name in def.modifiers) {
            Assert(!prototype[name], 'Rule conflict in', def.type, name);

            const modifier = def.modifiers[name];
            Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);

            const method = function (arg) {

                return this.rule({ [name]: arg });
            };

            prototype[name] = method;
            modifiers[name] = modifier;
        }
    }

    def.modifiers = modifiers;

    // Overrides

    if (def.overrides) {
        prototype._super = base;
        schema.$_super = {};
        for (const override in def.overrides) {
            Assert(base[override], 'Cannot override missing', override);
            schema.$_super[override] = base[override].bind(schema);
        }

        Object.assign(prototype, def.overrides);
    }

    // Casts

    def.cast = Object.assign({}, parent.cast, def.cast);

    // Manifest

    const manifest = Object.assign({}, parent.manifest, def.manifest);
    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
    def.manifest = manifest;

    // Rebuild

    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);

    return schema;
};


// Helpers

internals.build = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (obj, desc) {

        return parent(child(obj, desc), desc);
    };
};


internals.coerce = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return {
        from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {

            let coerced;
            if (!parent.from ||
                parent.from.includes(typeof value)) {

                coerced = parent.method(value, helpers);
                if (coerced) {
                    if (coerced.errors ||
                        coerced.value === undefined) {

                        return coerced;
                    }

                    value = coerced.value;
                }
            }

            if (!child.from ||
                child.from.includes(typeof value)) {

                const own = child.method(value, helpers);
                if (own) {
                    return own;
                }
            }

            return coerced;
        }
    };
};


internals.prepare = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const prepared = child(value, helpers);
        if (prepared) {
            if (prepared.errors ||
                prepared.value === undefined) {

                return prepared;
            }

            value = prepared.value;
        }

        return parent(value, helpers) || prepared;
    };
};


internals.rebuild = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (schema) {

        parent(schema);
        child(schema);
    };
};


internals.validate = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const result = parent(value, helpers);
        if (result) {
            if (result.errors &&
                (!Array.isArray(result.errors) || result.errors.length)) {

                return result;
            }

            value = result.value;
        }

        return child(value, helpers) || result;
    };
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Cache = __webpack_require__(/*! ./cache */ "./node_modules/@hapi/joi/lib/cache.js");
const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ./compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Extend = __webpack_require__(/*! ./extend */ "./node_modules/@hapi/joi/lib/extend.js");
const Manifest = __webpack_require__(/*! ./manifest */ "./node_modules/@hapi/joi/lib/manifest.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");
const Trace = __webpack_require__(/*! ./trace */ "./node_modules/@hapi/joi/lib/trace.js");

let Schemas;


const internals = {
    types: {
        alternatives: __webpack_require__(/*! ./types/alternatives */ "./node_modules/@hapi/joi/lib/types/alternatives.js"),
        any: __webpack_require__(/*! ./types/any */ "./node_modules/@hapi/joi/lib/types/any.js"),
        array: __webpack_require__(/*! ./types/array */ "./node_modules/@hapi/joi/lib/types/array.js"),
        boolean: __webpack_require__(/*! ./types/boolean */ "./node_modules/@hapi/joi/lib/types/boolean.js"),
        date: __webpack_require__(/*! ./types/date */ "./node_modules/@hapi/joi/lib/types/date.js"),
        function: __webpack_require__(/*! ./types/function */ "./node_modules/@hapi/joi/lib/types/function.js"),
        link: __webpack_require__(/*! ./types/link */ "./node_modules/@hapi/joi/lib/types/link.js"),
        number: __webpack_require__(/*! ./types/number */ "./node_modules/@hapi/joi/lib/types/number.js"),
        object: __webpack_require__(/*! ./types/object */ "./node_modules/@hapi/joi/lib/types/object.js"),
        string: __webpack_require__(/*! ./types/string */ "./node_modules/@hapi/joi/lib/types/string/index.js"),
        symbol: __webpack_require__(/*! ./types/symbol */ "./node_modules/@hapi/joi/lib/types/symbol.js")
    }
};


if (Buffer) {                                                           // $lab:coverage:ignore$
    internals.types.binary = __webpack_require__(/*! ./types/binary */ "./node_modules/@hapi/joi/lib/types/binary.js");
}


internals.root = function () {

    const root = {
        _types: new Set(Object.keys(internals.types))
    };

    // Types

    for (const type of root._types) {
        root[type] = function (...args) {

            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');
            return internals.generate(this, internals.types[type], args);
        };
    }

    // Shortcuts

    for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {
        root[method] = function (...args) {

            return this.any()[method](...args);
        };
    }

    // Methods

    Object.assign(root, internals.methods);

    // Aliases

    root.alt = root.alternatives;
    root.bool = root.boolean;
    root.func = root.function;
    root.x = root.expression;

    // Trace

    if (Trace.setup) {                                          // $lab:coverage:ignore$
        Trace.setup(root);
    }

    return root;
};


internals.methods = {

    ValidationError: Errors.ValidationError,
    version: Common.version,
    cache: Cache.provider,

    assert(value, schema, ...args /* [message], [options] */) {

        internals.assert(value, schema, true, args);
    },

    attempt(value, schema, ...args /* [message], [options] */) {

        return internals.assert(value, schema, false, args);
    },

    build(desc) {

        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');
        return Manifest.build(this, desc);
    },

    checkPreferences(prefs) {

        Common.checkPreferences(prefs);
    },

    compile(schema, options) {

        return Compile.compile(this, schema, options);
    },

    defaults(modifier) {

        Assert(typeof modifier === 'function', 'modifier must be a function');

        const joi = Object.assign({}, this);
        for (const type of joi._types) {
            const schema = modifier(joi[type]());
            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');

            joi[type] = function (...args) {

                return internals.generate(this, schema, args);
            };
        }

        return joi;
    },

    expression(...args) {

        return new Template(...args);
    },

    extend(...extensions) {

        Common.verifyFlat(extensions, 'extend');

        Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/@hapi/joi/lib/schemas.js");

        Assert(extensions.length, 'You need to provide at least one extension');
        this.assert(extensions, Schemas.extensions);

        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);

        for (let extension of extensions) {
            if (typeof extension === 'function') {
                extension = extension(joi);
            }

            this.assert(extension, Schemas.extension);

            Assert(joi[extension.type] === undefined || joi._types.has(extension.type), 'Cannot override name', extension.type);

            const base = extension.base || this.any();
            const schema = Extend.type(base, extension);

            joi._types.add(extension.type);
            joi[extension.type] = function (...args) {

                return internals.generate(this, schema, args);
            };
        }

        return joi;
    },

    isExpression: Template.isTemplate,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,

    in(...args) {

        return Ref.in(...args);
    },

    override: Common.symbols.override,

    ref(...args) {

        return Ref.create(...args);
    },

    types() {

        const types = {};
        for (const type of this._types) {
            types[type] = this[type]();
        }

        return types;
    }
};


// Helpers

internals.assert = function (value, schema, annotate, args /* [message], [options] */) {

    const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;
    const options = message ? args[1] : args[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));

    let error = result.error;
    if (!error) {
        return result.value;
    }

    if (message instanceof Error) {
        throw message;
    }

    annotate = annotate && typeof error.annotate === 'function';
    const display = annotate ? error.annotate() : error.message;

    if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
    }

    error.message = message ? `${message} ${display}` : display;
    throw error;
};


internals.generate = function (root, schema, args) {

    Assert(root, 'Must be invoked on a Joi instance.');

    schema.$_root = root;

    if (!schema._definition.args ||
        !args.length) {

        return schema;
    }

    return schema._definition.args(schema, ...args);
};


module.exports = internals.root();


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/manifest.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/manifest.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");

let Schemas;


const internals = {};


exports.describe = function (schema) {

    const def = schema._definition;

    // Type

    const desc = {
        type: schema.type,
        flags: {},
        rules: []
    };

    // Flags

    for (const flag in schema._flags) {
        if (flag[0] !== '_') {
            desc.flags[flag] = internals.describe(schema._flags[flag]);
        }
    }

    if (!Object.keys(desc.flags).length) {
        delete desc.flags;
    }

    // Preferences

    if (schema._preferences) {
        desc.preferences = Clone(schema._preferences, { shallow: ['messages'] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
            desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
    }

    // Allow / Invalid

    if (schema._valids) {
        desc.allow = schema._valids.describe();
    }

    if (schema._invalids) {
        desc.invalid = schema._invalids.describe();
    }

    // Rules

    for (const rule of schema._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {                           // Defaults to true
            continue;
        }

        const item = { name: rule.name };

        for (const custom in def.modifiers) {
            if (rule[custom] !== undefined) {
                item[custom] = internals.describe(rule[custom]);
            }
        }

        if (rule.args) {
            item.args = {};
            for (const key in rule.args) {
                const arg = rule.args[key];
                if (key === 'options' &&
                    !Object.keys(arg).length) {

                    continue;
                }

                item.args[key] = internals.describe(arg, { assign: key });
            }

            if (!Object.keys(item.args).length) {
                delete item.args;
            }
        }

        desc.rules.push(item);
    }

    if (!desc.rules.length) {
        delete desc.rules;
    }

    // Terms (must be last to verify no name conflicts)

    for (const term in schema.$_terms) {
        if (term[0] === '_') {
            continue;
        }

        Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);

        const items = schema.$_terms[term];
        if (!items) {
            continue;
        }

        if (items instanceof Map) {
            if (items.size) {
                desc[term] = [...items.entries()];
            }

            continue;
        }

        if (Common.isValues(items)) {
            desc[term] = items.describe();
            continue;
        }

        Assert(def.terms[term], 'Term', term, 'missing configuration');
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === 'object';
        if (!items.length &&
            !mapped) {

            continue;
        }

        const normalized = [];
        for (const item of items) {
            normalized.push(internals.describe(item));
        }

        // Mapped

        if (mapped) {
            const { from, to } = manifest.mapped;
            desc[term] = {};
            for (const item of normalized) {
                desc[term][item[to]] = item[from];
            }

            continue;
        }

        // Single

        if (manifest === 'single') {
            Assert(normalized.length === 1, 'Term', term, 'contains more than one item');
            desc[term] = normalized[0];
            continue;
        }

        // Array

        desc[term] = normalized;
    }

    internals.validate(schema.$_root, desc);
    return desc;
};


internals.describe = function (item, options = {}) {

    if (Array.isArray(item)) {
        return item.map(internals.describe);
    }

    if (item === Common.symbols.deepDefault) {
        return { special: 'deep' };
    }

    if (typeof item !== 'object') {
        return item;
    }

    if (options.assign === 'options') {
        return Clone(item);
    }

    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$
        return { buffer: item.toString('binary') };
    }

    if (item instanceof Date) {
        return item.toISOString();
    }

    if (item instanceof Error) {
        return item;
    }

    if (item instanceof RegExp) {
        if (options.assign === 'regex') {
            return item.toString();
        }

        return { regex: item.toString() };
    }

    if (item[Common.symbols.literal]) {
        return { function: item.literal };
    }

    if (typeof item.describe === 'function') {
        if (options.assign === 'ref') {
            return item.describe().ref;
        }

        return item.describe();
    }

    const normalized = {};
    for (const key in item) {
        const value = item[key];
        if (value === undefined) {
            continue;
        }

        normalized[key] = internals.describe(value, { assign: key });
    }

    return normalized;
};


exports.build = function (joi, desc) {

    const builder = new internals.Builder(joi);
    return builder.parse(desc);
};


internals.Builder = class {

    constructor(joi) {

        this.joi = joi;
    }

    parse(desc) {

        internals.validate(this.joi, desc);

        // Type

        let schema = this.joi[desc.type]();
        const def = schema._definition;

        // Flags

        if (desc.flags) {
            for (const flag in desc.flags) {
                const setter = def.flags[flag] && def.flags[flag].setter || flag;
                Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);
                schema = schema[setter](this.build(desc.flags[flag]));
            }
        }

        // Preferences

        if (desc.preferences) {
            schema = schema.preferences(this.build(desc.preferences));
        }

        // Allow / Invalid

        if (desc.allow) {
            schema = schema.allow(...this.build(desc.allow));
        }

        if (desc.invalid) {
            schema = schema.invalid(...this.build(desc.invalid));
        }

        // Rules

        if (desc.rules) {
            for (const rule of desc.rules) {
                Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);

                const args = [];
                if (rule.args) {
                    const built = {};
                    for (const key in rule.args) {
                        built[key] = this.build(rule.args[key], { assign: key });
                    }

                    const keys = Object.keys(built);
                    const definition = def.rules[rule.name].args;
                    if (definition) {
                        Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');
                        for (const { name } of definition) {
                            args.push(built[name]);
                        }
                    }
                    else {
                        Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');
                        args.push(built[keys[0]]);
                    }
                }

                // Apply

                schema = schema[rule.name](...args);

                // Ruleset

                const options = {};
                for (const custom in def.modifiers) {
                    if (rule[custom] !== undefined) {
                        options[custom] = this.build(rule[custom]);
                    }
                }

                if (Object.keys(options).length) {
                    schema = schema.rule(options);
                }
            }
        }

        // Terms

        const terms = {};
        for (const key in desc) {
            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {
                continue;
            }

            Assert(def.terms[key], 'Term', key, 'missing configuration');
            const manifest = def.terms[key].manifest;

            if (manifest === 'schema') {
                terms[key] = desc[key].map((item) => this.parse(item));
                continue;
            }

            if (manifest === 'values') {
                terms[key] = desc[key].map((item) => this.build(item));
                continue;
            }

            if (manifest === 'single') {
                terms[key] = this.build(desc[key]);
                continue;
            }

            if (typeof manifest === 'object') {
                terms[key] = {};
                for (const name in desc[key]) {
                    const value = desc[key][name];
                    terms[key][name] = this.parse(value);
                }

                continue;
            }

            terms[key] = this.build(desc[key]);
        }

        if (desc.whens) {
            terms.whens = desc.whens.map((when) => this.build(when));
        }

        schema = def.manifest.build(schema, terms);
        schema.$_temp.ruleset = false;
        return schema;
    }

    build(desc, options = {}) {

        if (desc === null) {
            return null;
        }

        if (Array.isArray(desc)) {
            return desc.map((item) => this.build(item));
        }

        if (desc instanceof Error) {
            return desc;
        }

        if (options.assign === 'options') {
            return Clone(desc);
        }

        if (options.assign === 'regex') {
            return internals.regex(desc);
        }

        if (options.assign === 'ref') {
            return Ref.build(desc);
        }

        if (typeof desc !== 'object') {
            return desc;
        }

        if (Object.keys(desc).length === 1) {
            if (desc.buffer) {
                Assert(Buffer, 'Buffers are not supported');
                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$
            }

            if (desc.function) {
                return { [Common.symbols.literal]: true, literal: desc.function };
            }

            if (desc.override) {
                return Common.symbols.override;
            }

            if (desc.ref) {
                return Ref.build(desc.ref);
            }

            if (desc.regex) {
                return internals.regex(desc.regex);
            }

            if (desc.special) {
                Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);
                return Common.symbols.deepDefault;
            }

            if (desc.value) {
                return Clone(desc.value);
            }
        }

        if (desc.type) {
            return this.parse(desc);
        }

        if (desc.template) {
            return Template.build(desc);
        }

        const normalized = {};
        for (const key in desc) {
            normalized[key] = this.build(desc[key], { assign: key });
        }

        return normalized;
    }
};


internals.regex = function (string) {

    const end = string.lastIndexOf('/');
    const exp = string.slice(1, end);
    const flags = string.slice(end + 1);
    return new RegExp(exp, flags);
};


internals.validate = function (joi, desc) {

    Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/@hapi/joi/lib/schemas.js");

    joi.assert(desc, Schemas.description);
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {};


exports.compile = function (messages, target) {

    // Single value string ('plain error message', 'template {error} message')

    if (typeof messages === 'string') {
        Assert(!target, 'Cannot set single message string');
        return new Template(messages);
    }

    // Single value template

    if (Template.isTemplate(messages)) {
        Assert(!target, 'Cannot set single message template');
        return messages;
    }

    // By error code { 'number.min': <string | template> }

    Assert(typeof messages === 'object' && !Array.isArray(messages), 'Invalid message options');

    target = target ? Clone(target) : {};

    for (let code in messages) {
        const message = messages[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


exports.decompile = function (messages) {

    // By error code { 'number.min': <string | template> }

    const target = {};
    for (let code in messages) {
        const message = messages[code];

        if (code === 'root') {
            target[code] = message;
            continue;
        }

        if (Template.isTemplate(message)) {
            target[code] = message.describe({ compact: true });
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        const language = code;
        target[language] = {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root') {
                target[language][code] = localized;
                continue;
            }

            target[language][code] = localized.describe({ compact: true });
        }
    }

    return target;
};


exports.merge = function (base, extended) {

    if (!base) {
        return exports.compile(extended);
    }

    if (!extended) {
        return base;
    }

    // Single value string

    if (typeof extended === 'string') {
        return new Template(extended);
    }

    // Single value template

    if (Template.isTemplate(extended)) {
        return extended;
    }

    // By error code { 'number.min': <string | template> }

    const target = Clone(base);

    for (let code in extended) {
        const message = extended[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/modify.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/modify.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {};



exports.Ids = internals.Ids = class {

    constructor() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    clone() {

        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
    }

    concat(source) {

        if (source._schemaChain) {
            this._schemaChain = true;
        }

        for (const [id, value] of source._byId.entries()) {
            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);
            this._byId.set(id, value);
        }

        for (const [key, value] of source._byKey.entries()) {
            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);
            this._byKey.set(key, value);
        }
    }

    fork(path, adjuster, root) {

        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };

        Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');

        for (const node of chain) {
            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }

        return adjusted.schema;
    }

    labels(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        if (!node) {
            return [...behind, ...path].join('.');
        }

        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
            return behind.join('.');
        }

        return node.schema._ids.labels(forward, behind);
    }

    reach(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        const forward = path.slice(1);
        if (!forward.length) {
            return node.schema;
        }

        return node.schema._ids.reach(forward, [...behind, current]);
    }

    register(schema, { key } = {}) {

        if (!schema ||
            !Common.isSchema(schema)) {

            return;
        }

        if (schema.$_property('schemaChain') ||
            schema._ids._schemaChain) {

            this._schemaChain = true;
        }

        const id = schema._flags.id;
        if (id) {
            const existing = this._byId.get(id);
            Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);
            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);

            this._byId.set(id, { schema, id });
        }

        if (key) {
            Assert(!this._byKey.has(key), 'Schema already contains key:', key);
            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);

            this._byKey.set(key, { schema, id: key });
        }
    }

    reset() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    _collect(path, behind = [], nodes = []) {

        const current = path[0];
        const node = this._get(current);
        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        nodes = [node, ...nodes];

        const forward = path.slice(1);
        if (!forward.length) {
            return nodes;
        }

        return node.schema._ids._collect(forward, [...behind, current], nodes);
    }

    _get(id) {

        return this._byId.get(id) || this._byKey.get(id);
    }
};


internals.fork = function (schema, id, replacement) {

    const each = (item, { key }) => {

        if (id === (item._flags.id || key)) {
            return replacement;
        }
    };

    const obj = exports.schema(schema, { each, ref: false });
    return obj.$_mutateRebuild();
};


exports.schema = function (schema, options) {

    let obj;

    for (const name in schema._flags) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj._flags[name] = result;
        }
    }

    for (let i = 0; i < schema._rules.length; ++i) {
        const rule = schema._rules[i];
        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            const clone = Object.assign({}, rule);
            clone.args = result;
            obj._rules[i] = clone;

            const existingUnique = obj._singleRules.get(rule.name);
            if (existingUnique === rule) {
                obj._singleRules.set(rule.name, clone);
            }
        }
    }

    for (const name in schema.$_terms) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj.$_terms[name] = result;
        }
    }

    return obj;
};


internals.scan = function (item, source, options, _path, _key) {

    const path = _path || [];

    if (item === null ||
        typeof item !== 'object') {

        return;
    }

    let clone;

    if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;
            const result = internals.scan(item[i], source, options, [i, ...path], key);
            if (result !== undefined) {
                clone = clone || item.slice();
                clone[i] = result;
            }
        }

        return clone;
    }

    if (options.schema !== false && Common.isSchema(item) ||
        options.ref !== false && Ref.isRef(item)) {

        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
            return;
        }

        return result;
    }

    for (const key in item) {
        if (key[0] === '_') {
            continue;
        }

        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== undefined) {
            clone = clone || Object.assign({}, item);
            clone[key] = result;
        }
    }

    return clone;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/ref.js":
/*!*******************************************!*\
  !*** ./node_modules/@hapi/joi/lib/ref.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");

let Template;


const internals = {
    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)
    defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: '.',
        type: 'value'
    }
};


exports.create = function (key, options = {}) {

    Assert(typeof key === 'string', 'Invalid reference key:', key);
    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'separator']);
    Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');

    const ref = Object.assign({}, internals.defaults, options);
    delete ref.prefix;

    const separator = ref.separator;
    const context = internals.context(key, separator, options.prefix);
    ref.type = context.type;
    key = context.key;

    if (ref.type === 'value') {
        if (context.root) {
            Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');
            ref.ancestor = 'root';
            if (!key) {
                key = null;
            }
        }

        if (separator &&
            separator === key) {

            key = null;
            ref.ancestor = 0;
        }
        else {
            if (ref.ancestor !== undefined) {
                Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');
            }
            else {
                const [ancestor, slice] = internals.ancestor(key, separator);
                if (slice) {
                    key = key.slice(slice);
                    if (key === '') {
                        key = null;
                    }
                }

                ref.ancestor = ancestor;
            }
        }
    }

    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];

    return new internals.Ref(ref);
};


exports.in = function (key, options = {}) {

    return exports.create(key, Object.assign({}, options, { in: true }));
};


exports.isRef = function (ref) {

    return ref ? !!ref[Common.symbols.ref] : false;
};


internals.Ref = class {

    constructor(options) {

        Assert(typeof options === 'object', 'Invalid reference construction');
        Common.assertOptions(options, [
            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'separator', 'type',    // Copied
            'depth', 'key', 'root', 'display'                                               // Overridden
        ]);

        Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');
        Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');
        Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');
        Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');

        Object.assign(this, internals.defaults, options);

        Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');

        if (Array.isArray(this.map)) {
            this.map = new Map(this.map);
        }

        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];

        this.updateDisplay();
    }

    resolve(value, state, prefs, local, options = {}) {

        Assert(!this.in || options.in, 'Invalid in() reference usage');

        if (this.type === 'global') {
            return this._resolve(prefs.context, state, options);
        }

        if (this.type === 'local') {
            return this._resolve(local, state, options);
        }

        if (!this.ancestor) {
            return this._resolve(value, state, options);
        }

        if (this.ancestor === 'root') {
            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }

        Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }

    _resolve(target, state, options) {

        let resolved;

        if (this.type === 'value' &&
            state.mainstay.shadow &&
            options.shadow !== false) {

            resolved = state.mainstay.shadow.get(this.absolute(state));
        }

        if (resolved === undefined) {
            resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }

        if (this.adjust) {
            resolved = this.adjust(resolved);
        }

        if (this.map) {
            const mapped = this.map.get(resolved);
            if (mapped !== undefined) {
                resolved = mapped;
            }
        }

        if (state.mainstay) {
            state.mainstay.tracer.resolve(state, this, resolved);
        }

        return resolved;
    }

    toString() {

        return this.display;
    }

    absolute(state) {

        return [...state.path.slice(0, -this.ancestor), ...this.path];
    }

    clone() {

        return new internals.Ref(this);
    }

    describe() {

        const ref = { path: this.path };

        if (this.type !== 'value') {
            ref.type = this.type;
        }

        if (this.separator !== '.') {
            ref.separator = this.separator;
        }

        if (this.type === 'value' &&
            this.ancestor !== 1) {

            ref.ancestor = this.ancestor;
        }

        if (this.map) {
            ref.map = [...this.map];
        }

        for (const key of ['adjust', 'iterables']) {
            if (this[key] !== null) {
                ref[key] = this[key];
            }
        }

        if (this.in !== false) {
            ref.in = true;
        }

        return { ref };
    }

    updateDisplay() {

        const key = this.key !== null ? this.key : '';
        if (this.type !== 'value') {
            this.display = `ref:${this.type}:${key}`;
            return;
        }

        if (!this.separator) {
            this.display = `ref:${key}`;
            return;
        }

        if (!this.ancestor) {
            this.display = `ref:${this.separator}${key}`;
            return;
        }

        if (this.ancestor === 'root') {
            this.display = `ref:root:${key}`;
            return;
        }

        if (this.ancestor === 1) {
            this.display = `ref:${key || '..'}`;
            return;
        }

        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');
        this.display = `ref:${lead}${key || ''}`;
    }
};


internals.Ref.prototype[Common.symbols.ref] = true;


exports.build = function (desc) {

    desc = Object.assign({}, internals.defaults, desc);
    if (desc.type === 'value' &&
        desc.ancestor === undefined) {

        desc.ancestor = 1;
    }

    return new internals.Ref(desc);
};


internals.context = function (key, separator, prefix = {}) {

    key = key.trim();

    const globalp = prefix.global === undefined ? '$' : prefix.global;
    if (globalp !== separator &&
        key.startsWith(globalp)) {

        return { key: key.slice(globalp.length), type: 'global' };
    }

    const local = prefix.local === undefined ? '#' : prefix.local;
    if (local !== separator &&
        key.startsWith(local)) {

        return { key: key.slice(local.length), type: 'local' };
    }

    const root = prefix.root === undefined ? '/' : prefix.root;
    if (root !== separator &&
        key.startsWith(root)) {

        return { key: key.slice(root.length), type: 'value', root: true };
    }

    return { key, type: 'value' };
};


internals.ancestor = function (key, separator) {

    if (!separator) {
        return [1, 0];              // 'a_b' -> 1 (parent)
    }

    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)
        return [1, 0];
    }

    if (key[1] !== separator) {     // '.a.b' -> 0 (self)
        return [0, 1];
    }

    let i = 2;
    while (key[i] === separator) {
        ++i;
    }

    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)
};


exports.toSibling = 0;

exports.toParent = 1;


exports.Manager = class {

    constructor() {

        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...
    }

    register(source, target) {

        if (!source) {
            return;
        }

        target = target === undefined ? exports.toParent : target;

        // Array

        if (Array.isArray(source)) {
            for (const ref of source) {
                this.register(ref, target);
            }

            return;
        }

        // Schema

        if (Common.isSchema(source)) {
            for (const item of source._refs.refs) {
                if (item.ancestor - target >= 0) {
                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });
                }
            }

            return;
        }

        // Reference

        if (exports.isRef(source) &&
            source.type === 'value' &&
            source.ancestor - target >= 0) {

            this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }

        // Template

        Template = Template || __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");

        if (Template.isTemplate(source)) {
            this.register(source.refs(), target);
        }
    }

    get length() {

        return this.refs.length;
    }

    clone() {

        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
    }

    reset() {

        this.refs = [];
    }

    roots() {

        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/schemas.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/schemas.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Joi = __webpack_require__(/*! ./index */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {};


// Preferences

exports.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    cache: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid('date', 'iso', 'string', 'time', 'utc'),
    debug: Joi.boolean(),
    errors: {
        escapeHtml: Joi.boolean(),
        label: Joi.valid('path', 'key', false),
        language: [
            Joi.string(),
            Joi.object().ref()
        ],
        render: Joi.boolean(),
        stack: Joi.boolean(),
        wrapArrays: Joi.boolean()
    },
    externals: Joi.boolean(),
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid('required', 'optional', 'forbidden'),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
    })
        .or('arrays', 'objects')
        .allow(true, false),
    warnings: Joi.boolean()
})
    .strict();


// Extensions

internals.nameRx = /^[a-zA-Z0-9]+$/;


internals.rule = Joi.object({
    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
    args: Joi.array().items(
        Joi.string(),
        Joi.object({
            name: Joi.string().pattern(internals.nameRx).required(),
            ref: Joi.boolean(),
            assert: Joi.alternatives([
                Joi.function(),
                Joi.object().schema()
            ])
                .conditional('ref', { is: true, then: Joi.required() }),
            normalize: Joi.function(),
            message: Joi.string().when('assert', { is: Joi.function(), then: Joi.required() })
        })
    ),
    convert: Joi.boolean(),
    manifest: Joi.boolean(),
    method: Joi.function().allow(false),
    multi: Joi.boolean(),
    validate: Joi.function()
});


exports.extension = Joi.object({
    type: Joi.string().required(),

    args: Joi.function(),
    base: Joi.object().schema(),
    coerce: [
        Joi.function().maxArity(3),
        Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })
    ],
    flags: Joi.object().pattern(internals.nameRx, Joi.object({
        setter: Joi.string(),
        default: Joi.any()
    })),
    manifest: {
        build: Joi.function().arity(2)
    },
    messages: [Joi.object(), Joi.string()],
    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
    prepare: Joi.function().maxArity(3),
    rebuild: Joi.function().arity(1),
    rules: Joi.object().pattern(internals.nameRx, internals.rule),
    terms: Joi.object().pattern(internals.nameRx, Joi.object({
        init: Joi.array().allow(null).required(),
        manifest: Joi.object().pattern(/.+/, [
            Joi.valid('schema', 'single'),
            Joi.object({
                mapped: Joi.object({
                    from: Joi.string().required(),
                    to: Joi.string().required()
                })
                    .required()
            })
        ])
    })),
    validate: Joi.function().maxArity(3)
})
    .strict();


exports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();


// Manifest

internals.desc = {

    buffer: Joi.object({
        buffer: Joi.string()
    }),

    func: Joi.object({
        function: Joi.function().required(),
        options: {
            literal: true
        }
    }),

    override: Joi.object({
        override: true
    }),

    ref: Joi.object({
        ref: Joi.object({
            type: Joi.valid('value', 'global', 'local'),
            path: Joi.array().required(),
            separator: Joi.string().length(1).allow(false),
            ancestor: Joi.number().min(0).integer().allow('root'),
            map: Joi.array().items(Joi.array().length(2)).min(1),
            adjust: Joi.function(),
            iterables: Joi.boolean(),
            in: Joi.boolean()
        })
            .required()
    }),

    regex: Joi.object({
        regex: Joi.string().min(3)
    }),

    special: Joi.object({
        special: Joi.valid('deep').required()
    }),

    template: Joi.object({
        template: Joi.string().required(),
        options: Joi.object()
    }),

    value: Joi.object({
        value: Joi.alternatives([Joi.object(), Joi.array()]).required()
    })
};


internals.desc.entity = Joi.alternatives([
    Joi.array().items(Joi.link('...')),
    Joi.boolean(),
    Joi.function(),
    Joi.number(),
    Joi.string(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.special,
    internals.desc.template,
    internals.desc.value,
    Joi.link('/')
]);


internals.desc.values = Joi.array()
    .items(
        null,
        Joi.boolean(),
        Joi.function(),
        Joi.number().allow(Infinity, -Infinity),
        Joi.string().allow(''),
        Joi.symbol(),
        internals.desc.buffer,
        internals.desc.func,
        internals.desc.override,
        internals.desc.ref,
        internals.desc.regex,
        internals.desc.template,
        internals.desc.value
    );


internals.desc.messages = Joi.object()
    .pattern(/.+/, [
        Joi.string(),
        internals.desc.template,
        Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])
    ]);


exports.description = Joi.object({
    type: Joi.string().required(),
    flags: Joi.object({
        cast: Joi.string(),
        default: Joi.any(),
        description: Joi.string(),
        empty: Joi.link('/'),
        failover: internals.desc.entity,
        id: Joi.string(),
        label: Joi.string(),
        only: true,
        presence: ['optional', 'required', 'forbidden'],
        result: ['raw', 'strip'],
        strip: Joi.boolean(),
        unit: Joi.string()
    })
        .unknown(),
    preferences: {
        allowUnknown: Joi.boolean(),
        abortEarly: Joi.boolean(),
        cache: Joi.boolean(),
        convert: Joi.boolean(),
        dateFormat: ['date', 'iso', 'string', 'time', 'utc'],
        errors: {
            escapeHtml: Joi.boolean(),
            label: ['path', 'key'],
            language: [
                Joi.string(),
                internals.desc.ref
            ],
            wrapArrays: Joi.boolean()
        },
        externals: Joi.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi.boolean(),
        nonEnumerables: Joi.boolean(),
        presence: ['required', 'optional', 'forbidden'],
        skipFunctions: Joi.boolean(),
        stripUnknown: Joi.object({
            arrays: Joi.boolean(),
            objects: Joi.boolean()
        })
            .or('arrays', 'objects')
            .allow(true, false),
        warnings: Joi.boolean()
    },
    allow: internals.desc.values,
    invalid: internals.desc.values,
    rules: Joi.array().min(1).items({
        name: Joi.string().required(),
        args: Joi.object().min(1),
        keep: Joi.boolean(),
        message: [
            Joi.string(),
            internals.desc.messages
        ],
        warn: Joi.boolean()
    }),

    // Terms

    keys: Joi.object().pattern(/.*/, Joi.link('/')),
    link: internals.desc.ref
})
    .pattern(/^[a-z]\w*$/, Joi.any());


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/state.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/state.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {
    value: Symbol('value')
};


module.exports = internals.State = class {

    constructor(path, ancestors, state) {

        this.path = path;
        this.ancestors = ancestors;                 // [parent, ..., root]

        this.mainstay = state.mainstay;
        this.schemas = state.schemas;               // [current, ..., root]
        this.debug = null;
    }

    localize(path, ancestors = null, schema = null) {

        const state = new internals.State(path, ancestors, this);

        if (schema &&
            state.schemas) {

            state.schemas = [internals.schemas(schema), ...state.schemas];
        }

        return state;
    }

    nest(schema, debug) {

        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        state.debug = debug;
        return state;
    }

    shadow(value, reason) {

        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
    }

    snapshot() {

        if (this.mainstay.shadow) {
            this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
    }

    restore() {

        if (this.mainstay.shadow) {
            this.mainstay.shadow.override(this.path, this._snapshot);
            this._snapshot = undefined;
        }
    }
};


internals.schemas = function (schema) {

    if (Common.isSchema(schema)) {
        return { schema };
    }

    return schema;
};


internals.Shadow = class {

    constructor() {

        this._values = null;
    }

    set(path, value, reason) {

        if (!path.length) {                                     // No need to store root value
            return;
        }

        if (reason === 'strip' &&
            typeof path[path.length - 1] === 'number') {        // Cannot store stripped array values (due to shift)

            return;
        }

        this._values = this._values || new Map();

        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
            const segment = path[i];
            let next = node.get(segment);
            if (!next) {
                next = new Map();
                node.set(segment, next);
            }

            node = next;
        }

        node[internals.value] = value;
    }

    get(path) {

        const node = this.node(path);
        if (node) {
            return node[internals.value];
        }
    }

    node(path) {

        if (!this._values) {
            return;
        }

        return Reach(this._values, path, { iterables: true });
    }

    override(path, node) {

        if (!this._values) {
            return;
        }

        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });

        if (node) {
            parent.set(own, node);
            return;
        }

        if (parent) {
            parent.delete(own);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/template.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/template.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const EscapeHtml = __webpack_require__(/*! @hapi/hoek/lib/escapeHtml */ "./node_modules/@hapi/hoek/lib/escapeHtml.js");
const Formula = __webpack_require__(/*! @hapi/formula */ "./node_modules/@hapi/formula/lib/index.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {
    symbol: Symbol('template'),

    opens: new Array(1000).join('\u0000'),
    closes: new Array(1000).join('\u0001'),

    dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
    }
};


module.exports = exports = internals.Template = class {

    constructor(source, options) {

        Assert(typeof source === 'string', 'Template source must be a string');
        Assert(!source.includes('\u0000') && !source.includes('\u0001'), 'Template source cannot contain reserved control characters');

        this.source = source;
        this.rendered = source;

        this._template = null;
        this._settings = Clone(options);

        this._parse();
    }

    _parse() {

        // 'text {raw} {{ref}} \\{{ignore}} {{ignore\\}} {{ignore {{ignore}'

        if (!this.source.includes('{')) {
            return;
        }

        // Encode escaped \\{{{{{

        const encoded = internals.encode(this.source);

        // Split on first { in each set

        const parts = internals.split(encoded);

        // Process parts

        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
            processed.push(head);
        }

        for (const part of parts) {
            const raw = part[0] !== '{';
            const ender = raw ? '}' : '}}';
            const end = part.indexOf(ender);
            if (end === -1 ||                               // Ignore non-matching closing
                part[1] === '{') {                          // Ignore more than two {

                processed.push(`{${internals.decode(part)}`);
                continue;
            }

            const variable = part.slice(raw ? 0 : 1, end);
            const dynamic = this._ref(internals.decode(variable), raw);
            processed.push(dynamic);
            if (typeof dynamic !== 'string') {
                refs = true;
            }

            const rest = part.slice(end + ender.length);
            if (rest) {
                processed.push(internals.decode(rest));
            }
        }

        if (!refs) {
            this.rendered = processed.join('');
            return;
        }

        this._template = processed;
    }

    static date(date, prefs) {

        return internals.dateFormat[prefs.dateFormat].call(date);
    }

    describe(options = {}) {

        if (!this._settings &&
            options.compact) {

            return this.source;
        }

        const desc = { template: this.source };
        if (this._settings) {
            desc.options = this._settings;
        }

        return desc;
    }

    static build(desc) {

        return new internals.Template(desc.template, desc.options);
    }

    isDynamic() {

        return !!this._template;
    }

    static isTemplate(template) {

        return template ? !!template[Common.symbols.template] : false;
    }

    refs() {

        if (!this._template) {
            return;
        }

        const refs = [];
        for (const part of this._template) {
            if (typeof part !== 'string') {
                refs.push(...part.refs);
            }
        }

        return refs;
    }

    resolve(value, state, prefs, local) {

        if (this._template &&
            this._template.length === 1) {

            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);
        }

        return this.render(value, state, prefs, local);
    }

    _part(part, ...args) {

        if (part.ref) {
            return part.ref.resolve(...args);
        }

        return part.formula.evaluate(args);
    }

    render(value, state, prefs, local, options = {}) {

        if (!this.isDynamic()) {
            return this.rendered;
        }

        const parts = [];
        for (const part of this._template) {
            if (typeof part === 'string') {
                parts.push(part);
            }
            else {
                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);
                const string = internals.stringify(rendered, prefs, options.errors);
                if (string !== undefined) {
                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
                    parts.push(result);
                }
            }
        }

        return parts.join('');
    }

    _ref(content, raw) {

        const refs = [];
        const reference = (variable) => {

            const ref = Ref.create(variable, this._settings);
            refs.push(ref);
            return (context) => ref.resolve(...context);
        };

        try {
            var formula = new Formula(content, { reference, functions: internals.functions, constants: internals.constants });
        }
        catch (err) {
            err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
            throw err;
        }

        if (formula.single) {
            if (formula.single.type === 'reference') {
                return { ref: refs[0], raw, refs };
            }

            return internals.stringify(formula.single.value);
        }

        return { formula, raw, refs };
    }

    toString() {

        return this.source;
    }
};


internals.Template.prototype[Common.symbols.template] = true;
internals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects


internals.encode = function (string) {

    return string
        .replace(/\\(\{+)/g, ($0, $1) => {

            return internals.opens.slice(0, $1.length);
        })
        .replace(/\\(\}+)/g, ($0, $1) => {

            return internals.closes.slice(0, $1.length);
        });
};


internals.decode = function (string) {

    return string
        .replace(/\u0000/g, '{')
        .replace(/\u0001/g, '}');
};


internals.split = function (string) {

    const parts = [];
    let current = '';

    for (let i = 0; i < string.length; ++i) {
        const char = string[i];

        if (char === '{') {
            let next = '';
            while (i + 1 < string.length &&
                string[i + 1] === '{') {

                next += '{';
                ++i;
            }

            parts.push(current);
            current = next;
        }
        else {
            current += char;
        }
    }

    parts.push(current);
    return parts;
};


internals.stringify = function (value, prefs, options) {

    const type = typeof value;

    if (value === null) {
        return 'null';
    }

    if (type === 'string') {
        return value;
    }

    if (type === 'number' ||
        type === 'function' ||
        type === 'symbol') {

        return value.toString();
    }

    if (type !== 'object') {
        return JSON.stringify(value);
    }

    if (value instanceof Date) {
        return internals.Template.date(value, prefs);
    }

    if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
            pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }

        value = pairs;
    }

    if (!Array.isArray(value)) {
        return value.toString();
    }

    let partial = '';
    for (const item of value) {
        partial = partial + (partial.length ? ', ' : '') + internals.stringify(item, prefs, options);
    }

    return options.wrapArrays ? '[' + partial + ']' : partial;
};


internals.constants = {

    true: true,
    false: false,
    null: null,

    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000
};


internals.functions = {

    if(condition, then, otherwise) {

        return condition ? then : otherwise;
    },

    msg(code) {

        const [value, state, prefs, local, options] = this;
        const messages = options.messages;
        if (!messages) {
            return '';
        }

        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
            return '';
        }

        return template.render(value, state, prefs, local, options);
    },

    number(value) {

        if (typeof value === 'number') {
            return value;
        }

        if (typeof value === 'string') {
            return parseFloat(value);
        }

        if (typeof value === 'boolean') {
            return value ? 1 : 0;
        }

        if (value instanceof Date) {
            return value.getTime();
        }

        return null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/trace.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/trace.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Pinpoint = __webpack_require__(/*! @hapi/pinpoint */ "./node_modules/@hapi/pinpoint/lib/index.js");

const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");


const internals = {
    codes: {
        error: 1,
        pass: 2,
        full: 3
    },
    labels: {
        0: 'never used',
        1: 'always error',
        2: 'always pass'
    }
};


exports.setup = function (root) {

    const trace = function () {

        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
    };

    root.trace = trace;
    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;

    root.untrace = () => {

        root._tracer = null;
    };
};


exports.location = function (schema) {

    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller
};


internals.Tracer = class {

    constructor() {

        this.name = 'Joi';
        this._schemas = new Map();
    }

    _register(schema) {

        const existing = this._schemas.get(schema);
        if (existing) {
            return existing.store;
        }

        const store = new internals.Store(schema);
        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller
        this._schemas.set(schema, { filename, line, store });
        return store;
    }

    _combine(merged, sources) {

        for (const { store } of this._schemas.values()) {
            store._combine(merged, sources);
        }
    }

    report(file) {

        const coverage = [];

        // Process each registered schema

        for (const { filename, line, store } of this._schemas.values()) {
            if (file &&
                file !== filename) {

                continue;
            }

            // Process sub schemas of the registered root

            const missing = [];
            const skipped = [];

            for (const [schema, log] of store._sources.entries()) {

                // Check if sub schema parent skipped

                if (internals.sub(log.paths, skipped)) {
                    continue;
                }

                // Check if sub schema reached

                if (!log.entry) {
                    missing.push({
                        status: 'never reached',
                        paths: [...log.paths]
                    });

                    skipped.push(...log.paths);
                    continue;
                }

                // Check values

                for (const type of ['valid', 'invalid']) {
                    const set = schema[`_${type}s`];
                    if (!set) {
                        continue;
                    }

                    const values = new Set(set._values);
                    const refs = new Set(set._refs);
                    for (const { value, ref } of log[type]) {
                        values.delete(value);
                        refs.delete(ref);
                    }

                    if (values.size ||
                        refs.size) {

                        missing.push({
                            status: [...values, ...[...refs].map((ref) => ref.display)],
                            rule: `${type}s`
                        });
                    }
                }

                // Check rules status

                const rules = schema._rules.map((rule) => rule.name);
                for (const type of ['default', 'failover']) {
                    if (schema._flags[type] !== undefined) {
                        rules.push(type);
                    }
                }

                for (const name of rules) {
                    const status = internals.labels[log.rule[name] || 0];
                    if (status) {
                        const report = { rule: name, status };
                        if (log.paths.size) {
                            report.paths = [...log.paths];
                        }

                        missing.push(report);
                    }
                }
            }

            if (missing.length) {
                coverage.push({
                    filename,
                    line,
                    missing,
                    severity: 'error',
                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`
                });
            }
        }

        return coverage.length ? coverage : null;
    }
};


internals.Store = class {

    constructor(schema) {

        this.active = true;
        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }
        this._combos = new Map();           // merged -> [sources]
        this._scan(schema);
    }

    debug(state, source, name, result) {

        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
    }

    entry(schema, state) {

        internals.debug(state, { type: 'entry' });

        this._record(schema, (log) => {

            log.entry = true;
        });
    }

    filter(schema, state, source, value) {

        internals.debug(state, { type: source, ...value });

        this._record(schema, (log) => {

            log[source].add(value);
        });
    }

    log(schema, state, source, name, result) {

        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });

        this._record(schema, (log) => {

            log[source][name] = log[source][name] || 0;
            log[source][name] |= internals.codes[result];
        });
    }

    resolve(state, ref, to) {

        if (!state.mainstay.debug) {
            return;
        }

        const log = { type: 'resolve', ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
    }

    value(state, by, from, to, name) {

        if (!state.mainstay.debug ||
            DeepEqual(from, to)) {

            return;
        }

        const log = { type: 'value', by, from, to, path: state.path };
        if (name) {
            log.name = name;
        }

        state.mainstay.debug.push(log);
    }

    _record(schema, each) {

        const log = this._sources.get(schema);
        if (log) {
            each(log);
            return;
        }

        const sources = this._combos.get(schema);
        for (const source of sources) {
            this._record(source, each);
        }
    }

    _scan(schema, _path) {

        const path = _path || [];

        let log = this._sources.get(schema);
        if (!log) {
            log = {
                paths: new Set(),
                entry: false,
                rule: {},
                valid: new Set(),
                invalid: new Set()
            };

            this._sources.set(schema, log);
        }

        if (path.length) {
            log.paths.add(path);
        }

        const each = (sub, source) => {

            const subId = internals.id(sub, source);
            this._scan(sub, path.concat(subId));
        };

        schema.$_modify({ each, ref: false });
    }

    _combine(merged, sources) {

        this._combos.set(merged, sources);
    }
};


internals.message = function (item) {

    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';
    return `${path}${item.rule || ''} (${item.status})`;
};


internals.id = function (schema, { source, name, path, key }) {

    if (schema._flags.id) {
        return schema._flags.id;
    }

    if (key) {
        return key;
    }

    name = `@${name}`;

    if (source === 'terms') {
        return [name, path[Math.min(path.length - 1, 1)]];
    }

    return name;
};


internals.sub = function (paths, skipped) {

    for (const path of paths) {
        for (const skip of skipped) {
            if (DeepEqual(path.slice(0, skip.length), skip)) {
                return true;
            }
        }
    }

    return false;
};


internals.debug = function (state, event) {

    if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/alternatives.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/alternatives.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ../ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {};


module.exports = Any.extend({

    type: 'alternatives',

    flags: {

        match: { default: 'any' }                 // 'any', 'one', 'all'
    },

    terms: {

        matches: { init: [], register: Ref.toSibling }
    },

    args(schema, ...schemas) {

        if (schemas.length === 1) {
            if (Array.isArray(schemas[0])) {
                return schema.try(...schemas[0]);
            }
        }

        return schema.try(...schemas);
    },

    validate(value, helpers) {

        const { schema, error, state, prefs } = helpers;

        // Match all or one

        if (schema._flags.match) {
            let hits = 0;
            let matched;

            for (let i = 0; i < schema.$_terms.matches.length; ++i) {
                const item = schema.$_terms.matches[i];
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    ++hits;
                    matched = result.value;
                }
                else {
                    localState.restore();
                }
            }

            if (!hits) {
                return { errors: error('alternatives.any') };
            }

            if (schema._flags.match === 'one') {
                return hits === 1 ? { value: matched } : { errors: error('alternatives.one') };
            }

            return hits === schema.$_terms.matches.length ? { value } : { errors: error('alternatives.all') };
        }

        // Match any

        const errors = [];
        for (let i = 0; i < schema.$_terms.matches.length; ++i) {
            const item = schema.$_terms.matches[i];

            // Try

            if (item.schema) {
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    return result;
                }

                localState.restore();
                errors.push({ schema: item.schema, reports: result.errors });
                continue;
            }

            // Conditional

            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
            const tests = item.is ? [item] : item.switch;

            for (let j = 0; j < tests.length; ++j) {
                const test = tests[j];
                const { is, then, otherwise } = test;

                const id = `match.${i}${item.switch ? '.' + j : ''}`;
                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
                    if (otherwise) {
                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
                    }
                }
                else if (then) {
                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
                }
            }
        }

        return internals.errors(errors, helpers);
    },

    rules: {

        conditional: {
            method(condition, options) {

                Assert(!this._flags._endedSwitch, 'Unreachable condition');
                Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');
                Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');

                const obj = this.clone();

                const match = Compile.when(obj, condition, options);
                const conditions = match.is ? [match] : match.switch;
                for (const item of conditions) {
                    if (item.then &&
                        item.otherwise) {

                        obj.$_setFlag('_endedSwitch', true, { clone: false });
                        break;
                    }
                }

                obj.$_terms.matches.push(match);
                return obj.$_mutateRebuild();
            }
        },

        match: {
            method(mode) {

                Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);

                if (mode !== 'any') {
                    for (const match of this.$_terms.matches) {
                        Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');
                    }
                }

                return this.$_setFlag('match', mode);
            }
        },

        try: {
            method(...schemas) {

                Assert(schemas.length, 'Missing alternative schemas');
                Common.verifyFlat(schemas, 'try');

                Assert(!this._flags._endedSwitch, 'Unreachable condition');

                const obj = this.clone();
                for (const schema of schemas) {
                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
                }

                return obj.$_mutateRebuild();
            }
        }
    },

    overrides: {

        label(name) {

            const obj = this.$_super.label(name);
            const each = (item, source) => (source.path[0] !== 'is' ? item.label(name) : undefined);
            return obj.$_modify({ each, ref: false });
        }
    },

    rebuild(schema) {

        // Flag when an alternative type is an array

        const each = (item) => {

            if (Common.isSchema(item) &&
                item.type === 'array') {

                schema.$_setFlag('_arrayItems', true, { clone: false });
            }
        };

        schema.$_modify({ each });
    },

    manifest: {

        build(obj, desc) {

            if (desc.matches) {
                for (const match of desc.matches) {
                    const { schema, ref, is, not, then, otherwise } = match;
                    if (schema) {
                        obj = obj.try(schema);
                    }
                    else if (ref) {
                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
                    }
                    else {
                        obj = obj.conditional(is, { then, otherwise });
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'alternatives.all': '"{{#label}}" does not match all of the required types',
        'alternatives.any': '"{{#label}}" does not match any of the allowed types',
        'alternatives.match': '"{{#label}}" does not match any of the allowed types',
        'alternatives.one': '"{{#label}}" matches more than one allowed type',
        'alternatives.types': '"{{#label}}" must be one of {{#types}}'
    }
});


// Helpers

internals.errors = function (failures, { error, state }) {

    // Nothing matched due to type criteria rules

    if (!failures.length) {
        return { errors: error('alternatives.any') };
    }

    // Single error

    if (failures.length === 1) {
        return { errors: failures[0].reports };
    }

    // Analyze reasons

    const valids = new Set();
    const complex = [];

    for (const { reports, schema } of failures) {

        // Multiple errors (!abortEarly)

        if (reports.length > 1) {
            return internals.unmatched(failures, error);
        }

        // Custom error

        const report = reports[0];
        if (report instanceof Errors.Report === false) {
            return internals.unmatched(failures, error);
        }

        // Internal object or array error

        if (report.state.path.length !== state.path.length) {
            complex.push({ type: schema.type, report });
            continue;
        }

        // Valids

        if (report.code === 'any.only') {
            for (const valid of report.local.valids) {
                valids.add(valid);
            }

            continue;
        }

        // Base type

        const [type, code] = report.code.split('.');
        if (code !== 'base') {
            complex.push({ type: schema.type, report });
            continue;
        }

        valids.add(type);
    }

    // All errors are base types or valids

    if (!complex.length) {
        return { errors: error('alternatives.types', { types: [...valids] }) };
    }

    // Single complex error

    if (complex.length === 1) {
        return { errors: complex[0].report };
    }

    return internals.unmatched(failures, error);
};


internals.unmatched = function (failures, error) {

    const errors = [];
    for (const failure of failures) {
        errors.push(...failure.reports);
    }

    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/any.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/any.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Base = __webpack_require__(/*! ../base */ "./node_modules/@hapi/joi/lib/base.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Messages = __webpack_require__(/*! ../messages */ "./node_modules/@hapi/joi/lib/messages.js");


const internals = {};


module.exports = Base.extend({

    type: 'any',

    flags: {

        only: { default: false }
    },

    terms: {

        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
    },

    rules: {

        custom: {
            method(method, description) {

                Assert(typeof method === 'function', 'Method must be a function');
                Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

                return this.$_addRule({ name: 'custom', args: { method, description } });
            },
            validate(value, helpers, { method }) {

                try {
                    return method(value, helpers);
                }
                catch (err) {
                    return helpers.error('any.custom', { error: err });
                }
            },
            args: ['method', 'description'],
            multi: true
        },

        messages: {
            method(messages) {

                return this.prefs({ messages });
            }
        },

        shared: {
            method(schema) {

                Assert(Common.isSchema(schema) && schema._flags.id, 'Schema must be a schema with an id');

                const obj = this.clone();
                obj.$_terms.shared = obj.$_terms.shared || [];
                obj.$_terms.shared.push(schema);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        warning: {
            method(code, local) {

                Assert(code && typeof code === 'string', 'Invalid warning code');

                return this.$_addRule({ name: 'warning', args: { code, local }, warn: true });
            },
            validate(value, helpers, { code, local }) {

                return helpers.error(code, local);
            },
            args: ['code', 'local'],
            multi: true
        }
    },

    modifiers: {

        keep(rule, enabled = true) {

            rule.keep = enabled;
        },

        message(rule, message) {

            rule.message = Messages.compile(message);
        },

        warn(rule, enabled = true) {

            rule.warn = enabled;
        }
    },

    manifest: {

        build(obj, desc) {

            for (const key in desc) {
                const values = desc[key];

                if (['examples', 'externals', 'metas', 'notes', 'tags'].includes(key)) {
                    for (const value of values) {
                        obj = obj[key.slice(0, -1)](value);
                    }

                    continue;
                }

                if (key === 'alterations') {
                    const alter = {};
                    for (const { target, adjuster } of values) {
                        alter[target] = adjuster;
                    }

                    obj = obj.alter(alter);
                    continue;
                }

                if (key === 'whens') {
                    for (const value of values) {
                        const { ref, is, not, then, otherwise, concat } = value;
                        if (concat) {
                            obj = obj.concat(concat);
                        }
                        else if (ref) {
                            obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                        }
                        else {
                            obj = obj.when(is, { then, otherwise, break: value.break });
                        }
                    }

                    continue;
                }

                if (key === 'shared') {
                    for (const value of values) {
                        obj = obj.shared(value);
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'any.custom': '"{{#label}}" failed custom validation because {{#error.message}}',
        'any.default': '"{{#label}}" threw an error when running default method',
        'any.failover': '"{{#label}}" threw an error when running failover method',
        'any.invalid': '"{{#label}}" contains an invalid value',
        'any.only': '"{{#label}}" must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        'any.ref': '"{{#label}}" {{#arg}} references "{{#ref}}" which {{#reason}}',
        'any.required': '"{{#label}}" is required',
        'any.unknown': '"{{#label}}" is not allowed'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/array.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");


const internals = {};


module.exports = Any.extend({

    type: 'array',

    flags: {

        single: { default: false },
        sparse: { default: false }
    },

    terms: {

        items: { init: [], manifest: 'schema' },
        ordered: { init: [], manifest: 'schema' },

        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
    },

    coerce: {
        from: 'object',
        method(value, { schema, state, prefs }) {

            if (!Array.isArray(value)) {
                return;
            }

            const sort = schema.$_getRule('sort');
            if (!sort) {
                return;
            }

            return internals.sort(schema, value, sort.args.options, state, prefs);
        }
    },

    validate(value, { schema, error }) {

        if (!Array.isArray(value)) {
            if (schema._flags.single) {
                const single = [value];
                single[Common.symbols.arraySingle] = true;
                return { value: single };
            }

            return { errors: error('array.base') };
        }

        if (!schema.$_getRule('items') &&
            !schema.$_terms.externals) {

            return;
        }

        return { value: value.slice() };        // Clone the array so that we don't modify the original
    },

    rules: {

        has: {
            method(schema) {

                schema = this.$_compile(schema, { appendPath: true });
                const obj = this.$_addRule({ name: 'has', args: { schema } });
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { state, prefs, error }, { schema: has }) {

                const ancestors = [value, ...state.ancestors];
                for (let i = 0; i < value.length; ++i) {
                    const localState = state.localize([...state.path, i], ancestors, has);
                    if (has.$_match(value[i], localState, prefs)) {
                        return value;
                    }
                }

                const patternLabel = has._flags.label;
                if (patternLabel) {
                    return error('array.hasKnown', { patternLabel });
                }

                return error('array.hasUnknown', null);
            },
            multi: true
        },

        items: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'items');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    obj.$_terms.items.push(type);
                }

                return obj.$_mutateRebuild();
            },
            validate(value, { schema, error, state, prefs }) {

                const requireds = schema.$_terms._requireds.slice();
                const ordereds = schema.$_terms.ordered.slice();
                const inclusions = [...schema.$_terms._inclusions, ...requireds];

                const wasArray = !value[Common.symbols.arraySingle];
                delete value[Common.symbols.arraySingle];

                const errors = [];
                let il = value.length;
                for (let i = 0; i < il; ++i) {
                    const item = value[i];

                    let errored = false;
                    let isValid = false;

                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers
                    const path = [...state.path, key];

                    // Sparse

                    if (!schema._flags.sparse &&
                        item === undefined) {

                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        ordereds.shift();
                        continue;
                    }

                    // Exclusions

                    const ancestors = [value, ...state.ancestors];

                    for (const exclusion of schema.$_terms._exclusions) {
                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {
                            continue;
                        }

                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        errored = true;
                        ordereds.shift();
                        break;
                    }

                    if (errored) {
                        continue;
                    }

                    // Ordered

                    if (schema.$_terms.ordered.length) {
                        if (ordereds.length) {
                            const ordered = ordereds.shift();
                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                            if (!res.errors) {
                                if (ordered._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse && res.value === undefined) {
                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    if (prefs.abortEarly) {
                                        return errors;
                                    }

                                    continue;
                                }
                                else {
                                    value[i] = res.value;
                                }
                            }
                            else {
                                errors.push(...res.errors);
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            continue;
                        }
                        else if (!schema.$_terms.items.length) {
                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength
                        }
                    }

                    // Requireds

                    const requiredChecks = [];
                    let jl = requireds.length;
                    for (let j = 0; j < jl; ++j) {
                        const localState = state.localize(path, ancestors, requireds[j]);
                        localState.snapshot();

                        const res = requireds[j].$_validate(item, localState, prefs);
                        requiredChecks[j] = res;

                        if (!res.errors) {
                            value[i] = res.value;
                            isValid = true;
                            internals.fastSplice(requireds, j);
                            --j;
                            --jl;

                            if (!schema._flags.sparse &&
                                res.value === undefined) {

                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            break;
                        }

                        localState.restore();
                    }

                    if (isValid) {
                        continue;
                    }

                    // Inclusions

                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;

                    jl = inclusions.length;
                    for (const inclusion of inclusions) {

                        // Avoid re-running requireds that already didn't match in the previous loop

                        let res;
                        const previousCheck = requireds.indexOf(inclusion);
                        if (previousCheck !== -1) {
                            res = requiredChecks[previousCheck];
                        }
                        else {
                            const localState = state.localize(path, ancestors, inclusion);
                            localState.snapshot();

                            res = inclusion.$_validate(item, localState, prefs);
                            if (!res.errors) {
                                if (inclusion._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse &&
                                    res.value === undefined) {

                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    errored = true;
                                }
                                else {
                                    value[i] = res.value;
                                }

                                isValid = true;
                                break;
                            }

                            localState.restore();
                        }

                        // Return the actual error if only one inclusion defined

                        if (jl === 1) {
                            if (stripUnknown) {
                                internals.fastSplice(value, i);
                                --i;
                                --il;
                                isValid = true;
                                break;
                            }

                            errors.push(...res.errors);
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            errored = true;
                            break;
                        }
                    }

                    if (errored) {
                        continue;
                    }

                    if (schema.$_terms._inclusions.length &&
                        !isValid) {

                        if (stripUnknown) {
                            internals.fastSplice(value, i);
                            --i;
                            --il;
                            continue;
                        }

                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }
                    }
                }

                if (requireds.length) {
                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
                }

                if (ordereds.length) {
                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
                }

                return errors.length ? errors : value;
            },

            priority: true,
            manifest: false
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('array.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        ordered: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'ordered');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    internals.validateSingle(type, obj);

                    obj.$_mutateRegister(type);
                    obj.$_terms.ordered.push(type);
                }

                return obj.$_mutateRebuild();
            }
        },

        single: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;
                Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');

                return this.$_setFlag('single', value);
            }
        },

        sort: {
            method(options = {}) {

                Common.assertOptions(options, ['by', 'order']);

                const settings = {
                    order: options.order || 'ascending'
                };

                if (options.by) {
                    settings.by = Compile.ref(options.by, { ancestor: 0 });
                    Assert(!settings.by.ancestor, 'Cannot sort by ancestor');
                }

                return this.$_addRule({ name: 'sort', args: { options: settings } });
            },
            validate(value, { error, state, prefs, schema }, { options }) {

                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
                if (errors) {
                    return errors;
                }

                for (let i = 0; i < value.length; ++i) {
                    if (value[i] !== sorted[i]) {
                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });
                    }
                }

                return value;
            },
            convert: true
        },

        sparse: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;

                if (this._flags.sparse === value) {
                    return this;
                }

                const obj = value ? this.clone() : this.$_addRule('items');
                return obj.$_setFlag('sparse', value, { clone: false });
            }
        },

        unique: {
            method(comparator, options = {}) {

                Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');
                Common.assertOptions(options, ['ignoreUndefined', 'separator']);

                const rule = { name: 'unique', args: { options, comparator } };

                if (comparator) {
                    if (typeof comparator === 'string') {
                        const separator = Common.default(options.separator, '.');
                        rule.path = separator ? comparator.split(separator) : [comparator];
                    }
                    else {
                        rule.comparator = comparator;
                    }
                }

                return this.$_addRule(rule);
            },
            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {

                const found = {
                    string: Object.create(null),
                    number: Object.create(null),
                    undefined: Object.create(null),
                    boolean: Object.create(null),
                    object: new Map(),
                    function: new Map(),
                    custom: new Map()
                };

                const compare = comparator || DeepEqual;
                const ignoreUndefined = options.ignoreUndefined;

                for (let i = 0; i < value.length; ++i) {
                    const item = path ? Reach(value[i], path) : value[i];
                    const records = comparator ? found.custom : found[typeof item];
                    Assert(records, 'Failed to find unique map container for type', typeof item);

                    if (records instanceof Map) {
                        const entries = records.entries();
                        let current;
                        while (!(current = entries.next()).done) {
                            if (compare(current.value[0], item)) {
                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                                const context = {
                                    pos: i,
                                    value: value[i],
                                    dupePos: current.value[1],
                                    dupeValue: value[current.value[1]]
                                };

                                if (path) {
                                    context.path = raw;
                                }

                                return error('array.unique', context, localState);
                            }
                        }

                        records.set(item, i);
                    }
                    else {
                        if ((!ignoreUndefined || item !== undefined) &&
                            records[item] !== undefined) {

                            const context = {
                                pos: i,
                                value: value[i],
                                dupePos: records[item],
                                dupeValue: value[records[item]]
                            };

                            if (path) {
                                context.path = raw;
                            }

                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                            return error('array.unique', context, localState);
                        }

                        records[item] = i;
                    }
                }

                return value;
            },
            args: ['comparator', 'options'],
            multi: true
        }
    },

    cast: {
        set: {
            from: Array.isArray,
            to(value, helpers) {

                return new Set(value);
            }
        }
    },

    rebuild(schema) {

        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];

        for (const type of schema.$_terms.items) {
            internals.validateSingle(type, schema);

            if (type._flags.presence === 'required') {
                schema.$_terms._requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                schema.$_terms._exclusions.push(type);
            }
            else {
                schema.$_terms._inclusions.push(type);
            }
        }

        for (const type of schema.$_terms.ordered) {
            internals.validateSingle(type, schema);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.items) {
                obj = obj.items(...desc.items);
            }

            if (desc.ordered) {
                obj = obj.ordered(...desc.ordered);
            }

            return obj;
        }
    },

    messages: {
        'array.base': '"{{#label}}" must be an array',
        'array.excludes': '"{{#label}}" contains an excluded value',
        'array.hasKnown': '"{{#label}}" does not contain at least one required match for type "{#patternLabel}"',
        'array.hasUnknown': '"{{#label}}" does not contain at least one required match',
        'array.includes': '"{{#label}}" does not match any of the allowed types',
        'array.includesRequiredBoth': '"{{#label}}" does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',
        'array.includesRequiredKnowns': '"{{#label}}" does not contain {{#knownMisses}}',
        'array.includesRequiredUnknowns': '"{{#label}}" does not contain {{#unknownMisses}} required value(s)',
        'array.length': '"{{#label}}" must contain {{#limit}} items',
        'array.max': '"{{#label}}" must contain less than or equal to {{#limit}} items',
        'array.min': '"{{#label}}" must contain at least {{#limit}} items',
        'array.orderedLength': '"{{#label}}" must contain at most {{#limit}} items',
        'array.sort': '"{{#label}}" must be sorted in {#order} order by {{#by}}',
        'array.sort.mismatching': '"{{#label}}" cannot be sorted due to mismatching types',
        'array.sort.unsupported': '"{{#label}}" cannot be sorted due to unsupported type {#type}',
        'array.sparse': '"{{#label}}" must not be a sparse array item',
        'array.unique': '"{{#label}}" contains a duplicate value'
    }
});


// Helpers

internals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {

    const knownMisses = [];
    let unknownMisses = 0;
    for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
            knownMisses.push(label);
        }
        else {
            ++unknownMisses;
        }
    }

    if (knownMisses.length) {
        if (unknownMisses) {
            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));
        }
        else {
            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));
        }
    }
    else {
        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));
    }
};


internals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {

    const requiredOrdereds = [];

    for (const ordered of ordereds) {
        if (ordered._flags.presence === 'required') {
            requiredOrdereds.push(ordered);
        }
    }

    if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
    }
};


internals.fastSplice = function (arr, i) {

    let pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];
    }

    --arr.length;
};


internals.validateSingle = function (type, obj) {

    if (type.type === 'array' ||
        type._flags._arrayItems) {

        Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');
        obj.$_setFlag('_arrayItems', true, { clone: false });
    }
};


internals.sort = function (schema, value, settings, state, prefs) {

    const order = settings.order === 'ascending' ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;

    const sort = (a, b) => {

        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        if (settings.by) {
            a = settings.by.resolve(a, state, prefs);
            b = settings.by.resolve(b, state, prefs);
        }

        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        const type = typeof a;
        if (type !== typeof b) {
            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);
        }

        if (type !== 'number' &&
            type !== 'string') {

            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);
        }

        if (type === 'number') {
            return (a - b) * order;
        }

        return a < b ? aFirst : bFirst;
    };

    try {
        return { value: value.slice().sort(sort) };
    }
    catch (err) {
        return { errors: err };
    }
};


internals.compare = function (a, b, aFirst, bFirst) {

    if (a === b) {
        return 0;
    }

    if (a === undefined) {
        return 1;           // Always last regardless of sort order
    }

    if (b === undefined) {
        return -1;           // Always last regardless of sort order
    }

    if (a === null) {
        return bFirst;
    }

    if (b === null) {
        return aFirst;
    }

    return null;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/binary.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/binary.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {};


module.exports = Any.extend({

    type: 'binary',

    coerce: {
        from: 'string',
        method(value, { schema }) {

            try {
                return { value: Buffer.from(value, schema._flags.encoding) };
            }
            catch (ignoreErr) { }
        }
    },

    validate(value, { error }) {

        if (!Buffer.isBuffer(value)) {
            return { value, errors: error('binary.base') };
        }
    },

    rules: {
        encoding: {
            method(encoding) {

                Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

                return this.$_setFlag('encoding', encoding);
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('binary.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        }
    },

    cast: {
        string: {
            from: (value) => Buffer.isBuffer(value),
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'binary.base': '"{{#label}}" must be a buffer or a string',
        'binary.length': '"{{#label}}" must be {{#limit}} bytes',
        'binary.max': '"{{#label}}" must be less than or equal to {{#limit}} bytes',
        'binary.min': '"{{#label}}" must be at least {{#limit}} bytes'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/boolean.js":
/*!*****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/boolean.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Values = __webpack_require__(/*! ../values */ "./node_modules/@hapi/joi/lib/values.js");


const internals = {};


internals.isBool = function (value) {

    return typeof value === 'boolean';
};


module.exports = Any.extend({

    type: 'boolean',

    flags: {

        sensitive: { default: false }
    },

    terms: {

        falsy: {
            init: null,
            manifest: 'values'
        },

        truthy: {
            init: null,
            manifest: 'values'
        }
    },

    coerce(value, { schema }) {

        if (typeof value === 'boolean') {
            return;
        }

        if (typeof value === 'string') {
            const normalized = schema._flags.sensitive ? value : value.toLowerCase();
            value = normalized === 'true' ? true : (normalized === 'false' ? false : value);
        }

        if (typeof value !== 'boolean') {
            value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) ||
                (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }

        return { value };
    },

    validate(value, { error }) {

        if (typeof value !== 'boolean') {
            return { value, errors: error('boolean.base') };
        }
    },

    rules: {
        truthy: {
            method(...values) {

                Common.verifyFlat(values, 'truthy');

                const obj = this.clone();
                obj.$_terms.truthy = obj.$_terms.truthy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    Assert(value !== undefined, 'Cannot call truthy with undefined');
                    obj.$_terms.truthy.add(value);
                }

                return obj;
            }
        },

        falsy: {
            method(...values) {

                Common.verifyFlat(values, 'falsy');

                const obj = this.clone();
                obj.$_terms.falsy = obj.$_terms.falsy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    Assert(value !== undefined, 'Cannot call falsy with undefined');
                    obj.$_terms.falsy.add(value);
                }

                return obj;
            }
        },

        sensitive: {
            method(enabled = true) {

                return this.$_setFlag('sensitive', enabled);
            }
        }
    },

    cast: {
        number: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 1 : 0;
            }
        },
        string: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 'true' : 'false';
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.truthy) {
                obj = obj.truthy(...desc.truthy);
            }

            if (desc.falsy) {
                obj = obj.falsy(...desc.falsy);
            }

            return obj;
        }
    },

    messages: {
        'boolean.base': '"{{#label}}" must be a boolean'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/date.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/date.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Template = __webpack_require__(/*! ../template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {};


internals.isDate = function (value) {

    return value instanceof Date;
};


module.exports = Any.extend({

    type: 'date',

    coerce: {
        from: ['number', 'string'],
        method(value, { schema }) {

            return { value: internals.parse(value, schema._flags.format) || value };
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value instanceof Date &&
            !isNaN(value.getTime())) {

            return;
        }

        const format = schema._flags.format;

        if (!prefs.convert ||
            !format ||
            typeof value !== 'string') {

            return { value, errors: error('date.base') };
        }

        return { value, errors: error('date.format', { format }) };
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { date }, { name, operator, args }) {

                const to = date === 'now' ? Date.now() : date.getTime();
                if (Common.compare(value.getTime(), to, operator)) {
                    return value;
                }

                return helpers.error('date.' + name, { limit: args.date, value });
            },
            args: [
                {
                    name: 'date',
                    ref: true,
                    normalize: (date) => {

                        return date === 'now' ? date : internals.parse(date);
                    },
                    assert: (date) => date !== null,
                    message: 'must have a valid date format'
                }
            ]
        },

        format: {
            method(format) {

                Assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);

                return this.$_setFlag('format', format);
            }
        },

        greater: {
            method(date) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { date }, operator: '>' });
            }
        },

        iso: {
            method() {

                return this.format('iso');
            }
        },

        less: {
            method(date) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { date }, operator: '<' });
            }
        },

        max: {
            method(date) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { date }, operator: '<=' });
            }
        },

        min: {
            method(date) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { date }, operator: '>=' });
            }
        },

        timestamp: {
            method(type = 'javascript') {

                Assert(['javascript', 'unix'].includes(type), '"type" must be one of "javascript, unix"');

                return this.format(type);
            }
        }
    },

    cast: {
        number: {
            from: internals.isDate,
            to(value, helpers) {

                return value.getTime();
            }
        },
        string: {
            from: internals.isDate,
            to(value, { prefs }) {

                return Template.date(value, prefs);
            }
        }
    },

    messages: {
        'date.base': '"{{#label}}" must be a valid date',
        'date.format': '"{{#label}}" must be in {msg("date.format." + #format) || #format} format',
        'date.greater': '"{{#label}}" must be greater than "{{#limit}}"',
        'date.less': '"{{#label}}" must be less than "{{#limit}}"',
        'date.max': '"{{#label}}" must be less than or equal to "{{#limit}}"',
        'date.min': '"{{#label}}" must be larger than or equal to "{{#limit}}"',

        // Messages used in date.format

        'date.format.iso': 'ISO 8601 date',
        'date.format.javascript': 'timestamp or number of milliseconds',
        'date.format.unix': 'timestamp or number of seconds'
    }
});


// Helpers

internals.parse = function (value, format) {

    if (value instanceof Date) {
        return value;
    }

    if (typeof value !== 'string' &&
        (isNaN(value) || !isFinite(value))) {

        return null;
    }

    if (/^\s*$/.test(value)) {
        return null;
    }

    // ISO

    if (format === 'iso') {
        if (!Common.isIsoDate(value)) {
            return null;
        }

        return internals.date(value.toString());
    }

    // Normalize number string

    const original = value;
    if (typeof value === 'string' &&
        /^[+-]?\d+(\.\d+)?$/.test(value)) {

        value = parseFloat(value);
    }

    // Timestamp

    if (format) {
        if (format === 'javascript') {
            return internals.date(1 * value);        // Casting to number
        }

        if (format === 'unix') {
            return internals.date(1000 * value);
        }

        if (typeof original === 'string') {
            return null;
        }
    }

    // Plain

    return internals.date(value);
};


internals.date = function (value) {

    const date = new Date(value);
    if (!isNaN(date.getTime())) {
        return date;
    }

    return null;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/function.js":
/*!******************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Keys = __webpack_require__(/*! ./keys */ "./node_modules/@hapi/joi/lib/types/keys.js");


const internals = {};


module.exports = Keys.extend({

    type: 'function',

    properties: {
        typeof: 'function'
    },

    rules: {
        arity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'arity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length === n) {
                    return value;
                }

                return helpers.error('function.arity', { n });
            }
        },

        class: {
            method() {

                return this.$_addRule('class');
            },
            validate(value, helpers) {

                if ((/^\s*class\s/).test(value.toString())) {
                    return value;
                }

                return helpers.error('function.class', { value });
            }
        },

        minArity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

                return this.$_addRule({ name: 'minArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length >= n) {
                    return value;
                }

                return helpers.error('function.minArity', { n });
            }
        },

        maxArity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'maxArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length <= n) {
                    return value;
                }

                return helpers.error('function.maxArity', { n });
            }
        }
    },

    messages: {
        'function.arity': '"{{#label}}" must have an arity of {{#n}}',
        'function.class': '"{{#label}}" must be a class',
        'function.maxArity': '"{{#label}}" must have an arity lesser or equal to {{#n}}',
        'function.minArity': '"{{#label}}" must have an arity greater or equal to {{#n}}'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/keys.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/keys.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ApplyToDefaults = __webpack_require__(/*! @hapi/hoek/lib/applyToDefaults */ "./node_modules/@hapi/hoek/lib/applyToDefaults.js");
const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./node_modules/@hapi/topo/lib/index.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ../ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Template = __webpack_require__(/*! ../template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {
    renameDefaults: {
        alias: false,                   // Keep old value in place
        multiple: false,                // Allow renaming multiple keys into the same target
        override: false                 // Overrides an existing key
    }
};


module.exports = Any.extend({

    type: '_keys',

    properties: {
        typeof: 'object'
    },

    flags: {

        unknown: { default: false }
    },

    terms: {

        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },
        patterns: { init: null },
        renames: { init: null }
    },

    args(schema, keys) {

        return schema.keys(keys);
    },

    validate(value, { schema, error, state, prefs }) {

        if (!value ||
            typeof value !== schema.$_property('typeof') ||
            Array.isArray(value)) {

            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };
        }

        // Skip if there are no other rules to test

        if (!schema.$_terms.renames &&
            !schema.$_terms.dependencies &&
            !schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.externals) {

            return;
        }

        // Shallow clone value

        value = internals.clone(value, prefs);
        const errors = [];

        // Rename keys

        if (schema.$_terms.renames &&
            !internals.rename(schema, value, state, prefs, errors)) {

            return { value, errors };
        }

        // Anything allowed

        if (!schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.dependencies) {

            return { value, errors };
        }

        // Defined keys

        const unprocessed = new Set(Object.keys(value));

        if (schema.$_terms.keys) {
            const ancestors = [value, ...state.ancestors];

            for (const child of schema.$_terms.keys) {
                const key = child.key;
                const item = value[key];

                unprocessed.delete(key);

                const localState = state.localize([...state.path, key], ancestors, child);
                const result = child.schema.$_validate(item, localState, prefs);

                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    errors.push(...result.errors);
                }
                else if (child.schema._flags.result === 'strip' ||
                    result.value === undefined && item !== undefined) {

                    delete value[key];
                }
                else if (result.value !== undefined) {
                    value[key] = result.value;
                }
            }
        }

        // Unknown keys

        if (unprocessed.size) {
            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
            if (early) {
                return early;
            }
        }

        // Validate dependencies

        if (schema.$_terms.dependencies) {
            for (const dep of schema.$_terms.dependencies) {
                if (dep.key &&
                    dep.key.resolve(value, state, prefs, null, { shadow: false }) === undefined) {

                    continue;
                }

                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
                if (failed) {
                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }

        return { value, errors };
    },

    rules: {

        and: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'and');

                return internals.dependency(this, 'and', null, peers);
            }
        },

        append: {
            method(schema) {

                if (schema === null ||
                    schema === undefined ||
                    Object.keys(schema).length === 0) {

                    return this;
                }

                return this.keys(schema);
            }
        },

        assert: {
            method(subject, schema, message) {

                if (!Template.isTemplate(subject)) {
                    subject = Compile.ref(subject);
                }

                Assert(message === undefined || typeof message === 'string', 'Message must be a string');

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });
                obj.$_mutateRegister(subject);
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { error, prefs, state }, { subject, schema, message }) {

                const about = subject.resolve(value, state, prefs);
                const path = Ref.isRef(subject) ? subject.absolute(state) : [];
                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
                    return value;
                }

                return error('object.assert', { subject, message });
            },
            args: ['subject', 'schema', 'message'],
            multi: true
        },

        instance: {
            method(constructor, name) {

                Assert(typeof constructor === 'function', 'constructor must be a function');

                name = name || constructor.name;

                return this.$_addRule({ name: 'instance', args: { constructor, name } });
            },
            validate(value, helpers, { constructor, name }) {

                if (value instanceof constructor) {
                    return value;
                }

                return helpers.error('object.instance', { type: name, value });
            },
            args: ['constructor', 'name']
        },

        keys: {
            method(schema) {

                Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
                Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');

                const obj = this.clone();

                if (!schema) {                                      // Allow all
                    obj.$_terms.keys = null;
                }
                else if (!Object.keys(schema).length) {             // Allow none
                    obj.$_terms.keys = [];
                }
                else {
                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : [];
                    for (const key in schema) {
                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
                    }
                }

                return obj.$_mutateRebuild();
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(Object.keys(value).length, limit, operator)) {
                    return value;
                }

                return helpers.error('object.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        nand: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'nand');

                return internals.dependency(this, 'nand', null, peers);
            }
        },

        or: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'or');

                return internals.dependency(this, 'or', null, peers);
            }
        },

        oxor: {
            method(...peers /*, [options] */) {

                return internals.dependency(this, 'oxor', null, peers);
            }
        },

        pattern: {
            method(pattern, schema, options = {}) {

                const isRegExp = pattern instanceof RegExp;
                if (!isRegExp) {
                    pattern = this.$_compile(pattern, { appendPath: true });
                }

                Assert(schema !== undefined, 'Invalid rule');
                Common.assertOptions(options, ['fallthrough', 'matches']);

                if (isRegExp) {
                    Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
                }

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.clone();
                obj.$_terms.patterns = obj.$_terms.patterns || [];
                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };
                if (options.matches) {
                    config.matches = this.$_compile(options.matches);
                    if (config.matches.type !== 'array') {
                        config.matches = config.matches.$_root.array().items(config.matches);
                    }

                    obj.$_mutateRegister(config.matches);
                }

                if (options.fallthrough) {
                    config.fallthrough = true;
                }

                obj.$_terms.patterns.push(config);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        ref: {
            method() {

                return this.$_addRule('ref');
            },
            validate(value, helpers) {

                if (Ref.isRef(value)) {
                    return value;
                }

                return helpers.error('object.refType', { value });
            }
        },

        rename: {
            method(from, to, options = {}) {

                Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
                Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');
                Assert(to !== from, 'Cannot rename key to same name:', from);

                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);

                const obj = this.clone();

                obj.$_terms.renames = obj.$_terms.renames || [];
                for (const rename of obj.$_terms.renames) {
                    Assert(rename.from !== from, 'Cannot rename the same key multiple times');
                }

                if (to instanceof Template) {
                    obj.$_mutateRegister(to);
                }

                obj.$_terms.renames.push({
                    from,
                    to,
                    options: ApplyToDefaults(internals.renameDefaults, options)
                });

                return obj;
            }
        },

        schema: {
            method(type = 'any') {

                return this.$_addRule({ name: 'schema', args: { type } });
            },
            validate(value, helpers, { type }) {

                if (Common.isSchema(value) &&
                    (type === 'any' || value.type === type)) {

                    return value;
                }

                return helpers.error('object.schema', { type });
            }
        },

        unknown: {
            method(allow) {

                return this.$_setFlag('unknown', allow !== false);
            }
        },

        with: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'with', key, peers, options);
            }
        },

        without: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'without', key, peers, options);
            }
        },

        xor: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'xor');

                return internals.dependency(this, 'xor', null, peers);
            }
        }
    },

    overrides: {

        default(value, options) {

            if (value === undefined) {
                value = Common.symbols.deepDefault;
            }

            return this.$_super.default(value, options);
        }
    },

    rebuild(schema) {

        if (schema.$_terms.keys) {
            const topo = new Topo();
            for (const child of schema.$_terms.keys) {
                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
            }

            schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.keys) {
                obj = obj.keys(desc.keys);
            }

            if (desc.dependencies) {
                for (const { rel, key = null, peers, options } of desc.dependencies) {
                    obj = internals.dependency(obj, rel, key, peers, options);
                }
            }

            if (desc.patterns) {
                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
                }
            }

            if (desc.renames) {
                for (const { from, to, options } of desc.renames) {
                    obj = obj.rename(from, to, options);
                }
            }

            return obj;
        }
    },

    messages: {
        'object.and': '"{{#label}}" contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',
        'object.assert': '"{{#label}}" is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        'object.base': '"{{#label}}" must be of type {{#type}}',
        'object.instance': '"{{#label}}" must be an instance of "{{#type}}"',
        'object.length': '"{{#label}}" must have {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.max': '"{{#label}}" must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.min': '"{{#label}}" must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.missing': '"{{#label}}" must contain at least one of {{#peersWithLabels}}',
        'object.nand': '"{{#mainWithLabel}}" must not exist simultaneously with {{#peersWithLabels}}',
        'object.oxor': '"{{#label}}" contains a conflict between optional exclusive peers {{#peersWithLabels}}',
        'object.pattern.match': '"{{#label}}" keys failed to match pattern requirements',
        'object.refType': '"{{#label}}" must be a Joi reference',
        'object.rename.multiple': '"{{#label}}" cannot rename "{{#from}}" because multiple renames are disabled and another key was already renamed to "{{#to}}"',
        'object.rename.override': '"{{#label}}" cannot rename "{{#from}}" because override is disabled and target "{{#to}}" exists',
        'object.schema': '"{{#label}}" must be a Joi schema of {{#type}} type',
        'object.unknown': '"{{#label}}" is not allowed',
        'object.with': '"{{#mainWithLabel}}" missing required peer "{{#peerWithLabel}}"',
        'object.without': '"{{#mainWithLabel}}" conflict with forbidden peer "{{#peerWithLabel}}"',
        'object.xor': '"{{#label}}" contains a conflict between exclusive peers {{#peersWithLabels}}'
    }
});


// Helpers

internals.clone = function (value, prefs) {

    // Object

    if (typeof value === 'object') {
        if (prefs.nonEnumerables) {
            return Clone(value, { shallow: true });
        }

        const clone = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone, value);
        return clone;
    }

    // Function

    const clone = function (...args) {

        return value.apply(this, args);
    };

    clone.prototype = Clone(value.prototype);
    Object.defineProperty(clone, 'name', { value: value.name, writable: false });
    Object.defineProperty(clone, 'length', { value: value.length, writable: false });
    Object.assign(clone, value);
    return clone;
};


internals.dependency = function (schema, rel, key, peers, options) {

    Assert(key === null || typeof key === 'string', rel, 'key must be a strings');

    // Extract options from peers array

    if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};
    }

    Common.assertOptions(options, ['separator']);

    peers = [].concat(peers);

    // Cast peer paths

    const separator = Common.default(options.separator, '.');
    const paths = [];
    for (const peer of peers) {
        Assert(typeof peer === 'string', rel, 'peers must be a string or a reference');
        paths.push(Compile.ref(peer, { separator, ancestor: 0 }));
    }

    // Cast key

    if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0 });
    }

    // Add rule

    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
    return obj;
};


internals.dependencies = {

    and(schema, dep, value, state, prefs) {

        const missing = [];
        const present = [];
        const count = dep.peers.length;
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
                missing.push(peer.key);
            }
            else {
                present.push(peer.key);
            }
        }

        if (missing.length !== count &&
            present.length !== count) {

            return {
                code: 'object.and',
                context: {
                    present,
                    presentWithLabels: internals.keysToLabels(schema, present),
                    missing,
                    missingWithLabels: internals.keysToLabels(schema, missing)
                }
            };
        }
    },

    nand(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (present.length !== dep.peers.length) {
            return;
        }

        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
            code: 'object.nand',
            context: {
                main,
                mainWithLabel: internals.keysToLabels(schema, main),
                peers: values,
                peersWithLabels: internals.keysToLabels(schema, values)
            }
        };
    },

    or(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                return;
            }
        }

        return {
            code: 'object.missing',
            context: {
                peers: dep.paths,
                peersWithLabels: internals.keysToLabels(schema, dep.paths)
            }
        };
    },

    oxor(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (!present.length ||
            present.length === 1) {

            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.oxor', context };
    },

    with(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
                return {
                    code: 'object.with',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    without(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                return {
                    code: 'object.without',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    xor(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (present.length === 1) {
            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        if (present.length === 0) {
            return { code: 'object.missing', context };
        }

        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.xor', context };
    }
};


internals.keysToLabels = function (schema, keys) {

    if (Array.isArray(keys)) {
        return keys.map((key) => schema.$_mapLabels(key));
    }

    return schema.$_mapLabels(keys);
};


internals.rename = function (schema, value, state, prefs, errors) {

    const renamed = {};
    for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== 'string';

        if (!pattern) {
            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&
                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {

                matches.push(rename);
            }
        }
        else {
            for (const from in value) {
                if (value[from] === undefined &&
                    rename.options.ignoreUndefined) {

                    continue;
                }

                if (from === rename.to) {
                    continue;
                }

                const match = rename.from.exec(from);
                if (!match) {
                    continue;
                }

                matches.push({ from, to: rename.to, match });
            }
        }

        for (const match of matches) {
            const from = match.from;
            let to = match.to;
            if (to instanceof Template) {
                to = to.render(value, state, prefs, match.match);
            }

            if (from === to) {
                continue;
            }

            if (!rename.options.multiple &&
                renamed[to]) {

                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (Object.prototype.hasOwnProperty.call(value, to) &&
                !rename.options.override &&
                !renamed[to]) {

                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (value[from] === undefined) {
                delete value[to];
            }
            else {
                value[to] = value[from];
            }

            renamed[to] = true;

            if (!rename.options.alias) {
                delete value[from];
            }
        }
    }

    return true;
};


internals.unknown = function (schema, value, unprocessed, errors, state, prefs) {

    if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {

            if (pattern.matches) {
                hasMatches = true;
                return [];
            }
        });

        const ancestors = [value, ...state.ancestors];

        for (const key of unprocessed) {
            const item = value[key];
            const path = [...state.path, key];

            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {
                const pattern = schema.$_terms.patterns[i];
                if (pattern.regex) {
                    const match = pattern.regex.test(key);
                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');
                    if (!match) {
                        continue;
                    }
                }
                else {
                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                        continue;
                    }
                }

                unprocessed.delete(key);

                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
                const result = pattern.rule.$_validate(item, localState, prefs);
                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    errors.push(...result.errors);
                }

                if (pattern.matches) {
                    matches[i].push(key);
                }

                value[key] = result.value;
                if (!pattern.fallthrough) {
                    break;
                }
            }
        }

        // Validate pattern matches rules

        if (hasMatches) {
            for (let i = 0; i < matches.length; ++i) {
                const match = matches[i];
                if (!match) {
                    continue;
                }

                const stpm = schema.$_terms.patterns[i].matches;
                const localState = state.localize(state.path, ancestors, stpm);
                const result = stpm.$_validate(match, localState, prefs);
                if (result.errors) {
                    const details = Errors.details(result.errors, { override: false });
                    details.matches = match;
                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }
    }

    if (!unprocessed.size ||
        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed

        return;
    }

    if (prefs.stripUnknown && !schema._flags.unknown ||
        prefs.skipFunctions) {

        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;

        for (const key of unprocessed) {
            if (stripUnknown) {
                delete value[key];
                unprocessed.delete(key);
            }
            else if (typeof value[key] === 'function') {
                unprocessed.delete(key);
            }
        }
    }

    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
            const localState = state.localize([...state.path, unprocessedKey], []);
            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
            if (prefs.abortEarly) {
                return { value, errors: report };
            }

            errors.push(report);
        }
    }
};


internals.Dependency = class {

    constructor(rel, key, peers, paths) {

        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
    }

    describe() {

        const desc = {
            rel: this.rel,
            peers: this.paths
        };

        if (this.key !== null) {
            desc.key = this.key.key;
        }

        if (this.peers[0].separator !== '.') {
            desc.options = { separator: this.peers[0].separator };
        }

        return desc;
    }
};


internals.Keys = class extends Array {

    concat(source) {

        const result = this.slice();

        const keys = new Map();
        for (let i = 0; i < result.length; ++i) {
            keys.set(result[i].key, i);
        }

        for (const item of source) {
            const key = item.key;
            const pos = keys.get(key);
            if (pos !== undefined) {
                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
            }
            else {
                result.push(item);
            }
        }

        return result;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/link.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/link.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/@hapi/joi/lib/errors.js");


const internals = {};


module.exports = Any.extend({

    type: 'link',

    properties: {
        schemaChain: true
    },

    terms: {

        link: { init: null, manifest: 'single', register: false }
    },

    args(schema, ref) {

        return schema.ref(ref);
    },

    validate(value, { schema, state, prefs }) {

        Assert(schema.$_terms.link, 'Uninitialized link schema');

        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
    },

    generate(schema, value, state, prefs) {

        return internals.generate(schema, value, state, prefs);
    },

    rules: {

        ref: {
            method(ref) {

                Assert(!this.$_terms.link, 'Cannot reinitialize schema');

                ref = Compile.ref(ref);

                Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);
                Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');

                const obj = this.clone();
                obj.$_terms.link = [{ ref }];
                return obj;
            }
        },

        relative: {
            method(enabled = true) {

                return this.$_setFlag('relative', enabled);
            }
        }
    },

    overrides: {

        concat(source) {

            Assert(this.$_terms.link, 'Uninitialized link schema');
            Assert(Common.isSchema(source), 'Invalid schema object');
            Assert(source.type !== 'link', 'Cannot merge type link with another link');

            const obj = this.clone();

            if (!obj.$_terms.whens) {
                obj.$_terms.whens = [];
            }

            obj.$_terms.whens.push({ concat: source });
            return obj.$_mutateRebuild();
        }
    },

    manifest: {

        build(obj, desc) {

            Assert(desc.link, 'Invalid link description missing link');
            return obj.ref(desc.link);
        }
    }
});


// Helpers

internals.generate = function (schema, value, state, prefs) {

    let linked = state.mainstay.links.get(schema);
    if (linked) {
        return linked._generate(value, state, prefs).schema;
    }

    const ref = schema.$_terms.link[0].ref;
    const { perspective, path } = internals.perspective(ref, state);
    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);

    try {
        linked = path.length ? perspective.$_reach(path) : perspective;
    }
    catch (ignoreErr) {
        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);
    }

    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);

    if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
    }

    return linked._generate(value, state, prefs).schema;
};


internals.perspective = function (ref, state) {

    if (ref.type === 'local') {
        for (const { schema, key } of state.schemas) {                              // From parent to root
            const id = schema._flags.id || key;
            if (id === ref.path[0]) {
                return { perspective: schema, path: ref.path.slice(1) };
            }

            if (schema.$_terms.shared) {
                for (const shared of schema.$_terms.shared) {
                    if (shared._flags.id === ref.path[0]) {
                        return { perspective: shared, path: ref.path.slice(1) };
                    }
                }
            }
        }

        return { perspective: null, path: null };
    }

    if (ref.ancestor === 'root') {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
    }

    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
};


internals.assert = function (condition, message, ref, schema, state, prefs) {

    if (condition) {                // Manual check to avoid generating error message on success
        return;
    }

    Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/number.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/number.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
};


module.exports = Any.extend({

    type: 'number',

    flags: {

        unsafe: { default: false }
    },

    coerce: {
        from: 'string',
        method(value, { schema, error }) {

            const matches = value.match(internals.numberRx);
            if (!matches) {
                return;
            }

            value = value.trim();
            const result = { value: parseFloat(value) };

            if (result.value === 0) {
                result.value = 0;           // -0
            }

            if (!schema._flags.unsafe) {
                if (value.match(/e/i)) {
                    const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
                    if (constructed !== internals.normalizeExponent(value)) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
                else {
                    const string = result.value.toString();
                    if (string.match(/e/i)) {
                        return result;
                    }

                    if (string !== internals.normalizeDecimal(value)) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
            }

            return result;
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value === Infinity ||
            value === -Infinity) {

            return { value, errors: error('number.infinity') };
        }

        if (!Common.isNumber(value)) {
            return { value, errors: error('number.base') };
        }

        const result = { value };

        if (result.value === 0) {
            result.value = 0;           // -0
        }

        if (prefs.convert) {
            const rule = schema.$_getRule('precision');
            if (rule) {
                const precision = Math.pow(10, rule.args.limit);                    // This is conceptually equivalent to using toFixed but it should be much faster
                result.value = Math.round(result.value * precision) / precision;
            }
        }

        if (!schema._flags.unsafe &&
            (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {

            result.errors = error('number.unsafe');
        }

        return result;
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value, limit, operator)) {
                    return value;
                }

                return helpers.error('number.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.isNumber,
                    message: 'must be a number'
                }
            ]
        },

        greater: {
            method(limit) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { limit }, operator: '>' });
            }
        },

        integer: {
            method() {

                return this.$_addRule('integer');
            },
            validate(value, helpers) {

                if (Math.trunc(value) - value === 0) {
                    return value;
                }

                return helpers.error('number.integer');
            }
        },

        less: {
            method(limit) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { limit }, operator: '<' });
            }
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { limit }, operator: '>=' });
            }
        },

        multiple: {
            method(base) {

                return this.$_addRule({ name: 'multiple', args: { base } });
            },
            validate(value, helpers, { base }, options) {

                if (value % base === 0) {
                    return value;
                }

                return helpers.error('number.multiple', { multiple: options.args.base, value });
            },
            args: [
                {
                    name: 'base',
                    ref: true,
                    assert: (value) => typeof value === 'number' && isFinite(value) && value > 0,
                    message: 'must be a positive number'
                }
            ],
            multi: true
        },

        negative: {
            method() {

                return this.sign('negative');
            }
        },

        port: {
            method() {

                return this.$_addRule('port');
            },
            validate(value, helpers) {

                if (Number.isSafeInteger(value) &&
                    value >= 0 &&
                    value <= 65535) {

                    return value;
                }

                return helpers.error('number.port');
            }
        },

        positive: {
            method() {

                return this.sign('positive');
            }
        },

        precision: {
            method(limit) {

                Assert(Number.isSafeInteger(limit), 'limit must be an integer');

                return this.$_addRule({ name: 'precision', args: { limit } });
            },
            validate(value, helpers, { limit }) {

                const places = value.toString().match(internals.precisionRx);
                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
                if (decimals <= limit) {
                    return value;
                }

                return helpers.error('number.precision', { limit, value });
            },
            convert: true
        },

        sign: {
            method(sign) {

                Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);

                return this.$_addRule({ name: 'sign', args: { sign } });
            },
            validate(value, helpers, { sign }) {

                if (sign === 'negative' && value < 0 ||
                    sign === 'positive' && value > 0) {

                    return value;
                }

                return helpers.error(`number.${sign}`);
            }
        },

        unsafe: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('unsafe', enabled);
            }
        }
    },

    cast: {
        string: {
            from: (value) => typeof value === 'number',
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'number.base': '"{{#label}}" must be a number',
        'number.greater': '"{{#label}}" must be greater than {{#limit}}',
        'number.infinity': '"{{#label}}" cannot be infinity',
        'number.integer': '"{{#label}}" must be an integer',
        'number.less': '"{{#label}}" must be less than {{#limit}}',
        'number.max': '"{{#label}}" must be less than or equal to {{#limit}}',
        'number.min': '"{{#label}}" must be larger than or equal to {{#limit}}',
        'number.multiple': '"{{#label}}" must be a multiple of {{#multiple}}',
        'number.negative': '"{{#label}}" must be a negative number',
        'number.port': '"{{#label}}" must be a valid port',
        'number.positive': '"{{#label}}" must be a positive number',
        'number.precision': '"{{#label}}" must have no more than {{#limit}} decimal places',
        'number.unsafe': '"{{#label}}" must be a safe number'
    }
});


// Helpers

internals.normalizeExponent = function (str) {

    return str
        .replace(/E/, 'e')
        .replace(/\.(\d*[1-9])?0+e/, '.$1e')
        .replace(/\.e/, 'e')
        .replace(/e\+/, 'e')
        .replace(/^\+/, '')
        .replace(/^(-?)0+([1-9])/, '$1$2');
};


internals.normalizeDecimal = function (str) {

    str = str
        .replace(/^\+/, '')
        .replace(/\.0+$/, '')
        .replace(/^(-?)\.([^\.]*)$/, '$10.$2')
        .replace(/^(-?)0+([1-9])/, '$1$2');

    if (str.includes('.') &&
        str.endsWith('0')) {

        str = str.replace(/0+$/, '');
    }

    if (str === '-0') {
        return '0';
    }

    return str;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/object.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Keys = __webpack_require__(/*! ./keys */ "./node_modules/@hapi/joi/lib/types/keys.js");


const internals = {};


module.exports = Keys.extend({

    type: 'object',

    cast: {
        map: {
            from: (value) => value && typeof value === 'object',
            to(value, helpers) {

                return new Map(Object.entries(value));
            }
        }
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/string/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/string/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Domain = __webpack_require__(/*! @hapi/address/lib/domain */ "./node_modules/@hapi/address/lib/domain.js");
const Email = __webpack_require__(/*! @hapi/address/lib/email */ "./node_modules/@hapi/address/lib/email.js");
const EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");
const Tlds = __webpack_require__(/*! @hapi/address/lib/tlds */ "./node_modules/@hapi/address/lib/tlds.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../../common */ "./node_modules/@hapi/joi/lib/common.js");

const Ip = __webpack_require__(/*! ./ip */ "./node_modules/@hapi/joi/lib/types/string/ip.js");
const Uri = __webpack_require__(/*! ./uri */ "./node_modules/@hapi/joi/lib/types/string/uri.js");


const internals = {
    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,              // $lab:coverage:ignore$
    base64Regex: {
        // paddingRequired
        true: {
            // urlSafe
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
    },
    dataUriRegex: {
        format: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
        base64: {
            // paddingRequired
            true: /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/,
            false: /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
    },
    hexRegex: /^[a-f0-9]+$/i,
    hostRegex: /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/,
    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,

    guidBrackets: {
        '{': '}', '[': ']', '(': ')', '': ''
    },
    guidVersions: {
        uuidv1: '1',
        uuidv2: '2',
        uuidv3: '3',
        uuidv4: '4',
        uuidv5: '5'
    },

    cidrPresences: ['required', 'optional', 'forbidden'],
    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};


module.exports = Any.extend({

    type: 'string',

    flags: {

        insensitive: { default: false },
        truncate: { default: false }
    },

    terms: {

        replacements: { init: null }
    },

    coerce: {
        from: 'string',
        method(value, { schema, state, prefs }) {

            const normalize = schema.$_getRule('normalize');
            if (normalize) {
                value = value.normalize(normalize.args.form);
            }

            const casing = schema.$_getRule('case');
            if (casing) {
                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
            }

            const trim = schema.$_getRule('trim');
            if (trim &&
                trim.args.enabled) {

                value = value.trim();
            }

            if (schema.$_terms.replacements) {
                for (const replacement of schema.$_terms.replacements) {
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }

            const hex = schema.$_getRule('hex');
            if (hex &&
                hex.args.options.byteAligned &&
                value.length % 2 !== 0) {

                value = `0${value}`;
            }

            if (schema.$_getRule('isoDate')) {
                const iso = internals.isoDate(value);
                if (iso) {
                    value = iso;
                }
            }

            if (schema._flags.truncate) {
                const rule = schema.$_getRule('max');
                if (rule) {
                    let limit = rule.args.limit;
                    if (Common.isResolvable(limit)) {
                        limit = limit.resolve(value, state, prefs);
                        if (!Common.limit(limit)) {
                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };
                        }
                    }

                    value = value.slice(0, limit);
                }
            }

            return { value };
        }
    },

    validate(value, { error }) {

        if (typeof value !== 'string') {
            return { value, errors: error('string.base') };
        }

        if (value === '') {
            return { value, errors: error('string.empty') };
        }
    },

    rules: {

        alphanum: {
            method() {

                return this.$_addRule('alphanum');
            },
            validate(value, helpers) {

                if (/^[a-zA-Z0-9]+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.alphanum');
            }
        },

        base64: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);

                options = { urlSafe: false, paddingRequired: true, ...options };
                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');
                Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');

                return this.$_addRule({ name: 'base64', args: { options } });
            },
            validate(value, helpers, { options }) {

                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
                if (regex.test(value)) {
                    return value;
                }

                return helpers.error('string.base64');
            }
        },

        case: {
            method(direction) {

                Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);

                return this.$_addRule({ name: 'case', args: { direction } });
            },
            validate(value, helpers, { direction }) {

                if (direction === 'lower' && value === value.toLocaleLowerCase() ||
                    direction === 'upper' && value === value.toLocaleUpperCase()) {

                    return value;
                }

                return helpers.error(`string.${direction}case`);
            },
            convert: true
        },

        creditCard: {
            method() {

                return this.$_addRule('creditCard');
            },
            validate(value, helpers) {

                let i = value.length;
                let sum = 0;
                let mul = 1;

                while (i--) {
                    const char = value.charAt(i) * mul;
                    sum = sum + (char - (char > 9) * 9);
                    mul = mul ^ 3;
                }

                if (sum > 0 &&
                    sum % 10 === 0) {

                    return value;
                }

                return helpers.error('string.creditCard');
            }
        },

        dataUri: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired']);

                options = { paddingRequired: true, ...options };
                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');

                return this.$_addRule({ name: 'dataUri', args: { options } });
            },
            validate(value, helpers, { options }) {

                const matches = value.match(internals.dataUriRegex.format);

                if (matches) {
                    if (!matches[2]) {
                        return value;
                    }

                    if (matches[2] !== 'base64') {
                        return value;
                    }

                    const base64regex = internals.dataUriRegex.base64[options.paddingRequired];
                    if (base64regex.test(matches[3])) {
                        return value;
                    }
                }

                return helpers.error('string.dataUri');
            }
        },

        domain: {
            method(options) {

                if (options) {
                    Common.assertOptions(options, ['allowUnicode', 'minDomainSegments', 'tlds']);
                }

                const address = internals.addressOptions(options);
                return this.$_addRule({ name: 'domain', args: { options }, address });
            },
            validate(value, helpers, args, { address }) {

                if (Domain.isValid(value, address)) {
                    return value;
                }

                return helpers.error('string.domain');
            }
        },

        email: {
            method(options = {}) {

                Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'minDomainSegments', 'multiple', 'separator', 'tlds']);
                Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');

                const address = internals.addressOptions(options);
                const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\s*`);

                return this.$_addRule({ name: 'email', args: { options }, regex, address });
            },
            validate(value, helpers, { options }, { regex, address }) {

                const emails = options.multiple ? value.split(regex) : [value];
                const invalids = [];
                for (const email of emails) {
                    if (!Email.isValid(email, address)) {
                        invalids.push(email);
                    }
                }

                if (!invalids.length) {
                    return value;
                }

                return helpers.error('string.email', { value, invalids });
            }
        },

        guid: {
            alias: 'uuid',
            method(options = {}) {

                Common.assertOptions(options, ['version']);

                let versionNumbers = '';

                if (options.version) {
                    const versions = [].concat(options.version);

                    Assert(versions.length >= 1, 'version must have at least 1 valid version specified');
                    const set = new Set();

                    for (let i = 0; i < versions.length; ++i) {
                        const version = versions[i];
                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                        const versionNumber = internals.guidVersions[version.toLowerCase()];
                        Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                        Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');

                        versionNumbers += versionNumber;
                        set.add(versionNumber);
                    }
                }

                const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, 'i');

                return this.$_addRule({ name: 'guid', args: { options }, regex });
            },
            validate(value, helpers, args, { regex }) {

                const results = regex.exec(value);

                if (!results) {
                    return helpers.error('string.guid');
                }

                // Matching braces

                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                    return helpers.error('string.guid');
                }

                return value;
            }
        },

        hex: {
            method(options = {}) {

                Common.assertOptions(options, ['byteAligned']);

                options = { byteAligned: false, ...options };
                Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');

                return this.$_addRule({ name: 'hex', args: { options } });
            },
            validate(value, helpers, { options }) {

                if (!internals.hexRegex.test(value)) {
                    return helpers.error('string.hex');
                }

                if (options.byteAligned &&
                    value.length % 2 !== 0) {

                    return helpers.error('string.hexAlign');
                }

                return value;
            }
        },

        hostname: {
            method() {

                return this.$_addRule('hostname');
            },
            validate(value, helpers) {

                if (value.length <= 255 && internals.hostRegex.test(value) ||
                    internals.ipRegex.test(value)) {

                    return value;
                }

                return helpers.error('string.hostname');
            }
        },

        insensitive: {
            method() {

                return this.$_setFlag('insensitive', true);
            }
        },

        ip: {
            method(options = {}) {

                Common.assertOptions(options, ['cidr', 'version']);

                options = Object.assign({}, options);       // Shallow cloned

                let regex = internals.ipRegex;
                if (options.cidr) {
                    Assert(typeof options.cidr === 'string', 'cidr must be a string');
                    options.cidr = options.cidr.toLowerCase();

                    Assert(internals.cidrPresences.includes(options.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));

                    if (!options.version &&
                        options.cidr !== 'optional') {

                        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], options.cidr);
                    }
                }
                else {
                    options.cidr = 'optional';
                }

                let versions;
                if (options.version) {
                    if (!Array.isArray(options.version)) {
                        options.version = [options.version];
                    }

                    Assert(options.version.length >= 1, 'version must have at least 1 version specified');

                    versions = [];
                    for (let i = 0; i < options.version.length; ++i) {
                        let version = options.version[i];
                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                        version = version.toLowerCase();
                        Assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
                        versions.push(version);
                    }

                    versions = Array.from(new Set(versions));
                    regex = Ip.createIpRegex(versions, options.cidr);
                }

                return this.$_addRule({ name: 'ip', args: { options }, versions, regex });
            },
            validate(value, helpers, { options }, { versions, regex }) {

                if (regex.test(value)) {
                    return value;
                }

                if (versions) {
                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: versions });
                }

                return helpers.error('string.ip', { value, cidr: options.cidr });
            }
        },

        isoDate: {
            method() {

                return this.$_addRule('isoDate');
            },
            validate(value, { error }) {

                if (internals.isoDate(value)) {
                    return value;
                }

                return error('string.isoDate');
            }
        },

        isoDuration: {
            method() {

                return this.$_addRule('isoDuration');
            },
            validate(value, helpers) {

                if (internals.isoDurationRegex.test(value)) {
                    return value;
                }

                return helpers.error('string.isoDuration');
            }
        },

        length: {
            method(limit, encoding) {

                return internals.length(this, 'length', limit, '=', encoding);
            },
            validate(value, helpers, { limit, encoding }, { name, operator, args }) {

                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$
                if (Common.compare(length, limit, operator)) {
                    return value;
                }

                return helpers.error('string.' + name, { limit: args.limit, value, encoding });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                },
                'encoding'
            ]
        },

        lowercase: {
            method() {

                return this.case('lower');
            }
        },

        max: {
            method(limit, encoding) {

                return internals.length(this, 'max', limit, '<=', encoding);
            },
            args: ['limit', 'encoding']
        },

        min: {
            method(limit, encoding) {

                return internals.length(this, 'min', limit, '>=', encoding);
            },
            args: ['limit', 'encoding']
        },

        normalize: {
            method(form = 'NFC') {

                Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

                return this.$_addRule({ name: 'normalize', args: { form } });
            },
            validate(value, { error }, { form }) {

                if (value === value.normalize(form)) {
                    return value;
                }

                return error('string.normalize', { value, form });
            },
            convert: true
        },

        pattern: {
            alias: 'regex',
            method(regex, options = {}) {

                Assert(regex instanceof RegExp, 'regex must be a RegExp');
                Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');

                if (typeof options === 'string') {
                    options = { name: options };
                }

                Common.assertOptions(options, ['invert', 'name']);

                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');
                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });
            },
            validate(value, helpers, { regex, options }, { errorCode }) {

                const patternMatch = regex.test(value);

                if (patternMatch ^ options.invert) {
                    return value;
                }

                return helpers.error(errorCode, { name: options.name, regex, value });
            },
            args: ['regex', 'options'],
            multi: true
        },

        replace: {
            method(pattern, replacement) {

                if (typeof pattern === 'string') {
                    pattern = new RegExp(EscapeRegex(pattern), 'g');
                }

                Assert(pattern instanceof RegExp, 'pattern must be a RegExp');
                Assert(typeof replacement === 'string', 'replacement must be a String');

                const obj = this.clone();

                if (!obj.$_terms.replacements) {
                    obj.$_terms.replacements = [];
                }

                obj.$_terms.replacements.push({ pattern, replacement });
                return obj;
            }
        },

        token: {
            method() {

                return this.$_addRule('token');
            },
            validate(value, helpers) {

                if (/^\w+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.token');
            }
        },

        trim: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_addRule({ name: 'trim', args: { enabled } });
            },
            validate(value, helpers, { enabled }) {

                if (!enabled ||
                    value === value.trim()) {

                    return value;
                }

                return helpers.error('string.trim');
            },
            convert: true
        },

        truncate: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('truncate', enabled);
            }
        },

        uppercase: {
            method() {

                return this.case('upper');
            }
        },

        uri: {
            method(options = {}) {

                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);

                const unknownOptions = Object.keys(options).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets', 'domain'].includes(key));
                Assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);

                if (options.domain) {
                    Common.assertOptions(options.domain, ['allowUnicode', 'minDomainSegments', 'tlds']);
                }

                const regex = Uri.createRegex(options);
                const domain = options.domain ? internals.addressOptions(options.domain) : null;
                return this.$_addRule({ name: 'uri', args: { options }, regex, domain });
            },
            validate(value, helpers, { options }, { regex, domain }) {

                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense
                    return helpers.error('string.uri');
                }

                const match = regex.exec(value);
                if (match) {
                    if (domain &&
                        !Domain.isValid(match[1], domain)) {

                        return helpers.error('string.domain', { value: match[1] });
                    }

                    return value;
                }

                if (options.relativeOnly) {
                    return helpers.error('string.uriRelativeOnly');
                }

                if (options.scheme) {
                    return helpers.error('string.uriCustomScheme', { scheme: regex.scheme, value });
                }

                return helpers.error('string.uri');
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.replacements) {
                for (const { pattern, replacement } of desc.replacements) {
                    obj = obj.replace(pattern, replacement);
                }
            }

            return obj;
        }
    },

    messages: {
        'string.alphanum': '"{{#label}}" must only contain alpha-numeric characters',
        'string.base': '"{{#label}}" must be a string',
        'string.base64': '"{{#label}}" must be a valid base64 string',
        'string.creditCard': '"{{#label}}" must be a credit card',
        'string.dataUri': '"{{#label}}" must be a valid dataUri string',
        'string.domain': '"{{#label}}" must contain a valid domain name',
        'string.email': '"{{#label}}" must be a valid email',
        'string.empty': '"{{#label}}" is not allowed to be empty',
        'string.guid': '"{{#label}}" must be a valid GUID',
        'string.hex': '"{{#label}}" must only contain hexadecimal characters',
        'string.hexAlign': '"{{#label}}" hex decoded representation must be byte aligned',
        'string.hostname': '"{{#label}}" must be a valid hostname',
        'string.ip': '"{{#label}}" must be a valid ip address with a {{#cidr}} CIDR',
        'string.ipVersion': '"{{#label}}" must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',
        'string.isoDate': '"{{#label}}" must be in iso format',
        'string.isoDuration': '"{{#label}}" must be a valid ISO 8601 duration',
        'string.length': '"{{#label}}" length must be {{#limit}} characters long',
        'string.lowercase': '"{{#label}}" must only contain lowercase characters',
        'string.max': '"{{#label}}" length must be less than or equal to {{#limit}} characters long',
        'string.min': '"{{#label}}" length must be at least {{#limit}} characters long',
        'string.normalize': '"{{#label}}" must be unicode normalized in the {{#form}} form',
        'string.token': '"{{#label}}" must only contain alpha-numeric and underscore characters',
        'string.pattern.base': '"{{#label}}" with value "{[.]}" fails to match the required pattern: {{#regex}}',
        'string.pattern.name': '"{{#label}}" with value "{[.]}" fails to match the {{#name}} pattern',
        'string.pattern.invert.base': '"{{#label}}" with value "{[.]}" matches the inverted pattern: {{#regex}}',
        'string.pattern.invert.name': '"{{#label}}" with value "{[.]}" matches the inverted {{#name}} pattern',
        'string.trim': '"{{#label}}" must not have leading or trailing whitespace',
        'string.uri': '"{{#label}}" must be a valid uri',
        'string.uriCustomScheme': '"{{#label}}" must be a valid uri with a scheme matching the {{#scheme}} pattern',
        'string.uriRelativeOnly': '"{{#label}}" must be a valid relative uri',
        'string.uppercase': '"{{#label}}" must only contain uppercase characters'
    }
});


// Helpers

internals.addressOptions = function (options) {

    if (!options) {
        return options;
    }

    // minDomainSegments

    Assert(options.minDomainSegments === undefined ||
        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');

    // tlds

    if (options.tlds === false) {
        return options;
    }

    if (options.tlds === true ||
        options.tlds === undefined) {

        Assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');

    const deny = options.tlds.deny;
    if (deny) {
        if (Array.isArray(deny)) {
            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }

        Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');
        Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');
        return options;
    }

    const allow = options.tlds.allow;
    if (!allow) {
        return options;
    }

    if (allow === true) {
        Assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
    }

    Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');
    return options;
};


internals.isoDate = function (value) {

    if (!Common.isIsoDate(value)) {
        return null;
    }

    const date = new Date(value);
    if (isNaN(date.getTime())) {
        return null;
    }

    return date.toISOString();
};


internals.length = function (schema, name, limit, operator, encoding) {

    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$

    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/string/ip.js":
/*!*******************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/string/ip.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Uri = __webpack_require__(/*! ./uri */ "./node_modules/@hapi/joi/lib/types/string/uri.js");


const internals = {};


exports.cidrs = {
    ipv4: {
        required: '\\/(?:' + Uri.ipv4Cidr + ')',
        optional: '(?:\\/(?:' + Uri.ipv4Cidr + '))?',
        forbidden: ''
    },
    ipv6: {
        required: '\\/' + Uri.ipv6Cidr,
        optional: '(?:\\/' + Uri.ipv6Cidr + ')?',
        forbidden: ''
    },
    ipvfuture: {
        required: '\\/' + Uri.ipv6Cidr,
        optional: '(?:\\/' + Uri.ipv6Cidr + ')?',
        forbidden: ''
    }
};


exports.versions = {
    ipv4: Uri.ipv4address,
    ipv6: Uri.ipv6address,
    ipvfuture: Uri.ipvFuture
};


exports.createIpRegex = function (versions, cidr) {

    const parts = versions.map((version) => exports.versions[version] + exports.cidrs[version][cidr]);
    return new RegExp('^(?:' + parts.join('|') + ')$');
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/string/uri.js":
/*!********************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/string/uri.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");


const internals = {};


internals.generate = function () {

    const rfc3986 = {};

    const hexDigit = '\\dA-Fa-f';                                               // HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
    const hexDigitOnly = '[' + hexDigit + ']';

    const unreserved = '\\w-\\.~';                                              // unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
    const subDelims = '!\\$&\'\\(\\)\\*\\+,;=';                                 // sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
    const pctEncoded = '%' + hexDigit;                                          // pct-encoded = "%" HEXDIG HEXDIG
    const pchar = unreserved + pctEncoded + subDelims + ':@';                   // pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
    const pcharOnly = '[' + pchar + ']';
    const decOctect = '(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])';     // dec-octet = DIGIT / %x31-39 DIGIT / "1" 2DIGIT / "2" %x30-34 DIGIT / "25" %x30-35  ; 0-9 / 10-99 / 100-199 / 200-249 / 250-255

    rfc3986.ipv4address = '(?:' + decOctect + '\\.){3}' + decOctect;            // IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet

    /*
        h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
        ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
        IPv6address =                            6( h16 ":" ) ls32
                    /                       "::" 5( h16 ":" ) ls32
                    / [               h16 ] "::" 4( h16 ":" ) ls32
                    / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                    / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                    / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                    / [ *4( h16 ":" ) h16 ] "::"              ls32
                    / [ *5( h16 ":" ) h16 ] "::"              h16
                    / [ *6( h16 ":" ) h16 ] "::"
    */

    const h16 = hexDigitOnly + '{1,4}';
    const ls32 = '(?:' + h16 + ':' + h16 + '|' + rfc3986.ipv4address + ')';
    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';

    rfc3986.ipv4Cidr = '\\d|[1-2]\\d|3[0-2]';                                               // IPv4 cidr = DIGIT / %x31-32 DIGIT / "3" %x30-32  ; 0-9 / 10-29 / 30-32
    rfc3986.ipv6Cidr = '(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])';                         // IPv6 cidr = DIGIT / %x31-39 DIGIT / "1" %x0-1 DIGIT / "12" %x0-8;   0-9 / 10-99 / 100-119 / 120-128
    rfc3986.ipv6address = '(?:' + IPv6SixHex + '|' + IPv6FiveHex + '|' + IPv6FourHex + '|' + IPv6ThreeHex + '|' + IPv6TwoHex + '|' + IPv6OneHex + '|' + IPv6NoneHex + '|' + IPv6NoneHex2 + '|' + IPv6NoneHex3 + ')';
    rfc3986.ipvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';      // IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

    rfc3986.scheme = '[a-zA-Z][a-zA-Z\\d+-\\.]*';                                           // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    rfc3986.schemeRegex = new RegExp(rfc3986.scheme);

    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';                     // userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
    const IPLiteral = '\\[(?:' + rfc3986.ipv6address + '|' + rfc3986.ipvFuture + ')\\]';    // IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
    const regName = '[' + unreserved + pctEncoded + subDelims + ']{1,255}';                 // reg-name = *( unreserved / pct-encoded / sub-delims )
    const host = '(?:' + IPLiteral + '|' + rfc3986.ipv4address + '|' + regName + ')';       // host = IP-literal / IPv4address / reg-name
    const port = '\\d*';                                                                    // port = *DIGIT
    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';               // authority   = [ userinfo "@" ] host [ ":" port ]
    const authorityCapture = '(?:' + userinfo + '@)?(' + host + ')(?::' + port + ')?';

    /*
        segment       = *pchar
        segment-nz    = 1*pchar
        path          = path-abempty    ; begins with "/" '|' is empty
                    / path-absolute   ; begins with "/" but not "//"
                    / path-noscheme   ; begins with a non-colon segment
                    / path-rootless   ; begins with a segment
                    / path-empty      ; zero characters
        path-abempty  = *( "/" segment )
        path-absolute = "/" [ segment-nz *( "/" segment ) ]
        path-rootless = segment-nz *( "/" segment )
    */

    const segment = pcharOnly + '*';
    const segmentNz = pcharOnly + '+';
    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
    const pathEmpty = '';
    const pathAbEmpty = '(?:\\/' + segment + ')*';
    const pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;
    const pathAbNoAuthority = '(?:\\/\\/\\/' + segment + pathAbEmpty + ')';     // Used by file:///

    // hier-part = "//" authority path

    rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathRootless + '|' + pathAbNoAuthority + ')';
    rfc3986.hierPartCapture = '(?:' + '(?:\\/\\/' + authorityCapture + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathRootless + ')';

    // relative-part = "//" authority path-abempty / path-absolute / path-noscheme / path-empty

    rfc3986.relativeRef = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathNoScheme + '|' + pathEmpty + ')';

    // query = *( pchar / "/" / "?" )
    // query = *( pchar / "[" / "]" / "/" / "?" )

    rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)';                            //Finish matching either at the fragment part '|' end of the line.
    rfc3986.queryWithSquareBrackets = '[' + pchar + '\\[\\]\\/\\?]*(?=#|$)';

    // fragment = *( pchar / "/" / "?" )

    rfc3986.fragment = '[' + pchar + '\\/\\?]*';

    return rfc3986;
};


module.exports = exports = internals.rfc3986 = internals.generate();


internals.createRegex = function (options) {

    const rfc = internals.rfc3986;

    // Construct expression

    const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
    const suffix = '(?:\\?' + query + ')?' + '(?:#' + rfc.fragment + ')?$';

    // relative-ref = relative-part [ "?" query ] [ "#" fragment ]

    if (options.relativeOnly) {
        return new RegExp('^' + rfc.relativeRef + suffix);
    }

    // Custom schemes

    let customScheme = '';
    if (options.scheme) {
        Assert(options.scheme instanceof RegExp || typeof options.scheme === 'string' || Array.isArray(options.scheme), 'scheme must be a RegExp, String, or Array');

        const schemes = [].concat(options.scheme);
        Assert(schemes.length >= 1, 'scheme must have at least 1 scheme specified');

        // Flatten the array into a string to be used to match the schemes

        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
            const scheme = schemes[i];
            Assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

            if (scheme instanceof RegExp) {
                selections.push(scheme.source.toString());
            }
            else {
                Assert(rfc.schemeRegex.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                selections.push(EscapeRegex(scheme));
            }
        }

        customScheme = selections.join('|');
    }

    // URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

    const scheme = customScheme ? '(?:' + customScheme + ')' : rfc.scheme;
    const absolute = '(?:' + scheme + ':' + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ')';
    const prefix = options.allowRelative ? '(?:' + absolute + '|' + rfc.relativeRef + ')' : absolute;
    const regex = new RegExp('^' + prefix + suffix);
    regex.scheme = customScheme;
    return regex;
};


internals.uriRegex = internals.createRegex({});


exports.createRegex = function (options = {}) {

    if (options.scheme ||
        options.allowRelative ||
        options.relativeOnly ||
        options.allowQuerySquareBrackets ||
        options.domain) {

        return internals.createRegex(options);
    }

    return internals.uriRegex;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");


const internals = {};


internals.Map = class extends Map {

    slice() {

        return new internals.Map(this);
    }
};


module.exports = Any.extend({

    type: 'symbol',

    terms: {

        map: { init: new internals.Map() }
    },

    coerce: {
        method(value, { schema, error }) {

            const lookup = schema.$_terms.map.get(value);
            if (lookup) {
                value = lookup;
            }

            if (!schema._flags.only ||
                typeof value === 'symbol') {

                return { value };
            }

            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };
        }
    },

    validate(value, { error }) {

        if (typeof value !== 'symbol') {
            return { value, errors: error('symbol.base') };
        }
    },

    rules: {
        map: {
            method(iterable) {

                if (iterable &&
                    !iterable[Symbol.iterator] &&
                    typeof iterable === 'object') {

                    iterable = Object.entries(iterable);
                }

                Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');

                const obj = this.clone();

                const symbols = [];
                for (const entry of iterable) {
                    Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');
                    const [key, value] = entry;

                    Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');
                    Assert(typeof value === 'symbol', 'Value must be a Symbol');

                    obj.$_terms.map.set(key, value);
                    symbols.push(value);
                }

                return obj.valid(...symbols);
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.map) {
                obj = obj.map(desc.map);
            }

            return obj;
        }
    },

    messages: {
        'symbol.base': '"{{#label}}" must be a symbol',
        'symbol.map': '"{{#label}}" must be one of {{#map}}'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/validator.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/validator.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Ignore = __webpack_require__(/*! @hapi/hoek/lib/ignore */ "./node_modules/@hapi/hoek/lib/ignore.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const State = __webpack_require__(/*! ./state */ "./node_modules/@hapi/joi/lib/state.js");


const internals = {
    result: Symbol('result')
};


exports.entry = function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');
    const outcome = { value: result.value };

    if (result.error) {
        outcome.error = result.error;
    }

    if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
    }

    if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
    }

    return outcome;
};


exports.entryAsync = async function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    const mainstay = result.mainstay;
    if (result.error) {
        if (mainstay.debug) {
            result.error.debug = mainstay.debug;
        }

        throw result.error;
    }

    if (mainstay.externals.length) {
        let root = result.value;
        for (const { method, path, label } of mainstay.externals) {
            let node = root;
            let key;
            let parent;

            if (path.length) {
                key = path[path.length - 1];
                parent = Reach(root, path.slice(0, -1));
                node = parent[key];
            }

            try {
                const output = await method(node);
                if (output === undefined ||
                    output === node) {

                    continue;
                }

                if (parent) {
                    parent[key] = output;
                }
                else {
                    root = output;
                }
            }
            catch (err) {
                err.message += ` (${label})`;       // Change message to include path
                throw err;
            }
        }

        result.value = root;
    }

    if (!settings.warnings &&
        !settings.debug) {

        return result.value;
    }

    const outcome = { value: result.value };
    if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
    }

    if (mainstay.debug) {
        outcome.debug = mainstay.debug;
    }

    return outcome;
};


internals.entry = function (value, schema, prefs) {

    // Prepare state

    const { tracer, cleanup } = internals.tracer(schema, prefs);
    const debug = prefs.debug ? [] : null;
    const links = schema._ids._schemaChain ? new Map() : null;
    const mainstay = { externals: [], warnings: [], tracer, debug, links };
    const schemas = schema._ids._schemaChain ? [{ schema }] : null;
    const state = new State([], [], { mainstay, schemas });

    // Validate value

    const result = exports.validate(value, schema, state, prefs);

    // Process value and errors

    if (cleanup) {
        schema.$_root.untrace();
    }

    const error = Errors.process(result.errors, value, prefs);
    return { value: result.value, error, mainstay };
};


internals.tracer = function (schema, prefs) {

    if (schema.$_root._tracer) {
        return { tracer: schema.$_root._tracer._register(schema) };
    }

    if (prefs.debug) {
        Assert(schema.$_root.trace, 'Debug mode not supported');
        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
    }

    return { tracer: internals.ignore };
};


exports.validate = function (value, schema, state, prefs, overrides = {}) {

    if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
    }

    // Setup state and settings

    if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
    }

    // Cache

    if (schema._cache &&
        prefs.cache) {

        const result = schema._cache.get(value);
        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);
        if (result) {
            return result;
        }
    }

    // Helpers

    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);
    const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })
    };

    // Prepare

    state.mainstay.tracer.entry(schema, state);

    const def = schema._definition;
    if (def.prepare &&
        value !== undefined &&
        prefs.convert) {

        const prepared = def.prepare(value, helpers);
        if (prepared) {
            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);
            if (prepared.errors) {
                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early
            }

            value = prepared.value;
        }
    }

    // Type coercion

    if (def.coerce &&
        value !== undefined &&
        prefs.convert &&
        (!def.coerce.from || def.coerce.from.includes(typeof value))) {

        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);
            if (coerced.errors) {
                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early
            }

            value = coerced.value;
        }
    }

    // Empty value

    const empty = schema._flags.empty;
    if (empty &&
        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {

        state.mainstay.tracer.value(state, 'empty', value, undefined);
        value = undefined;
    }

    // Presence requirements (required, optional, forbidden)

    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? 'ignore' : prefs.presence);
    if (value === undefined) {
        if (presence === 'forbidden') {
            return internals.finalize(value, null, helpers);
        }

        if (presence === 'required') {
            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);
        }

        if (presence === 'optional') {
            if (schema._flags.default !== Common.symbols.deepDefault) {
                return internals.finalize(value, null, helpers);
            }

            state.mainstay.tracer.value(state, 'default', value, {});
            value = {};
        }
    }
    else if (presence === 'forbidden') {
        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);
    }

    // Allowed values

    const errors = [];

    if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            if (prefs.convert) {
                state.mainstay.tracer.value(state, 'valids', value, match.value);
                value = match.value;
            }

            state.mainstay.tracer.filter(schema, state, 'valid', match);
            return internals.finalize(value, null, helpers);
        }

        if (schema._flags.only) {
            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Denied values

    if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            state.mainstay.tracer.filter(schema, state, 'invalid', match);
            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Base type

    if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
            state.mainstay.tracer.value(state, 'base', value, base.value);
            value = base.value;

            if (base.errors) {
                if (!Array.isArray(base.errors)) {
                    errors.push(base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }

                if (base.errors.length) {
                    errors.push(...base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }
            }
        }
    }

    // Validate tests

    if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
    }

    return internals.rules(value, errors, helpers);
};


internals.rules = function (value, errors, helpers) {

    const { schema, state, prefs } = helpers;

    for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];

        // Skip rules that are also applied in coerce step

        if (definition.convert &&
            prefs.convert) {

            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');
            continue;
        }

        // Resolve references

        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
            args = Object.assign({}, args);                                     // Shallow copy
            for (const key of rule._resolve) {
                const resolver = definition.argsByName.get(key);

                const resolved = args[key].resolve(value, state, prefs);
                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;

                const invalid = Common.validateArg(normalized, null, resolver);
                if (invalid) {
                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
                    break;
                }

                args[key] = normalized;
            }
        }

        // Test rule

        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error

        const result = internals.rule(ret, rule);
        if (result.errors) {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');

            if (rule.warn) {
                state.mainstay.warnings.push(...result.errors);
                continue;
            }

            if (prefs.abortEarly) {
                return internals.finalize(value, result.errors, helpers);
            }

            errors.push(...result.errors);
        }
        else {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');
            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);
            value = result.value;
        }
    }

    return internals.finalize(value, errors, helpers);
};


internals.rule = function (ret, rule) {

    if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
    }

    if (Array.isArray(ret) &&
        (ret[0] instanceof Errors.Report || ret[0] instanceof Error)) {

        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
    }

    return { errors: null, value: ret };
};


internals.error = function (report, rule) {

    if (rule.message) {
        report._setTemplate(rule.message);
    }

    return report;
};


internals.finalize = function (value, errors, helpers) {

    errors = errors || [];
    const { schema, state, prefs } = helpers;

    // Failover value

    if (errors.length) {
        const failover = internals.default('failover', undefined, errors, helpers);
        if (failover !== undefined) {
            state.mainstay.tracer.value(state, 'failover', value, failover);
            value = failover;
            errors = [];
        }
    }

    // Error override

    if (errors.length &&
        schema._flags.error) {

        if (typeof schema._flags.error === 'function') {
            errors = schema._flags.error(errors);
            if (!Array.isArray(errors)) {
                errors = [errors];
            }

            for (const error of errors) {
                Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');
            }
        }
        else {
            errors = [schema._flags.error];
        }
    }

    // Default

    if (value === undefined) {
        const defaulted = internals.default('default', value, errors, helpers);
        state.mainstay.tracer.value(state, 'default', value, defaulted);
        value = defaulted;
    }

    // Cast

    if (schema._flags.cast &&
        value !== undefined) {

        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
            const casted = caster.to(value, helpers);
            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);
            value = casted;
        }
    }

    // Externals

    if (schema.$_terms.externals &&
        prefs.externals &&
        prefs._externals !== false) {                       // Disabled for matching

        for (const { method } of schema.$_terms.externals) {
            state.mainstay.externals.push({ method, path: state.path, label: Errors.label(schema._flags, state, prefs) });
        }
    }

    // Result

    const result = { value, errors: errors.length ? errors : null };

    if (schema._flags.result) {
        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;
        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
        state.shadow(value, schema._flags.result);
    }

    // Cache

    if (schema._cache &&
        prefs.cache !== false &&
        !schema._refs.length) {

        schema._cache.set(helpers.original, result);
    }

    return result;
};


internals.prefs = function (schema, prefs) {

    const isDefaultOptions = prefs === Common.defaults;
    if (isDefaultOptions &&
        schema._preferences[Common.symbols.prefs]) {

        return schema._preferences[Common.symbols.prefs];
    }

    prefs = Common.preferences(prefs, schema._preferences);
    if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
    }

    return prefs;
};


internals.default = function (flag, value, errors, { schema, state, prefs }) {

    const source = schema._flags[flag];
    if (prefs.noDefaults ||
        source === undefined) {

        return value;
    }

    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');

    if (!source) {
        return source;
    }

    if (typeof source === 'function') {
        const args = source.length > 0 ? [Clone(state.ancestors[0]), prefs] : [];

        try {
            return source(...args);
        }
        catch (err) {
            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
            return;
        }
    }

    if (typeof source !== 'object') {
        return source;
    }

    if (source[Common.symbols.literal]) {
        return source.literal;
    }

    if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
    }

    return Clone(source);
};


internals.trim = function (value, schema) {

    if (typeof value !== 'string') {
        return value;
    }

    const trim = schema.$_getRule('trim');
    if (!trim ||
        !trim.args.enabled) {

        return value;
    }

    return value.trim();
};


internals.ignore = {
    active: false,
    debug: Ignore,
    entry: Ignore,
    filter: Ignore,
    log: Ignore,
    resolve: Ignore,
    value: Ignore
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/values.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/values.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {};


module.exports = internals.Values = class {

    constructor(values, refs) {

        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);

        this._override = false;
    }

    get length() {

        return this._values.size + this._refs.size;
    }

    add(value, refs) {

        // Reference

        if (Common.isResolvable(value)) {
            if (!this._refs.has(value)) {
                this._refs.add(value);

                if (refs) {                     // Skipped in a merge
                    refs.register(value);
                }
            }

            return;
        }

        // Value

        if (!this.has(value, null, null, false)) {
            this._values.add(value);

            if (typeof value === 'string') {
                this._lowercase.set(value.toLowerCase(), value);
            }
        }
    }

    static merge(target, source, remove) {

        target = target || new internals.Values();

        if (source) {
            if (source._override) {
                return source.clone();
            }

            for (const item of [...source._values, ...source._refs]) {
                target.add(item);
            }
        }

        if (remove) {
            for (const item of [...remove._values, ...remove._refs]) {
                target.remove(item);
            }
        }

        return target.length ? target : null;
    }

    remove(value) {

        // Reference

        if (Common.isResolvable(value)) {
            this._refs.delete(value);
            return;
        }

        // Value

        this._values.delete(value);

        if (typeof value === 'string') {
            this._lowercase.delete(value.toLowerCase());
        }
    }

    has(value, state, prefs, insensitive) {

        return !!this.get(value, state, prefs, insensitive);
    }

    get(value, state, prefs, insensitive) {

        if (!this.length) {
            return false;
        }

        // Simple match

        if (this._values.has(value)) {
            return { value };
        }

        // Case insensitive string match

        if (typeof value === 'string' &&
            value &&
            insensitive) {

            const found = this._lowercase.get(value.toLowerCase());
            if (found) {
                return { value: found };
            }
        }

        if (!this._refs.size &&
            typeof value !== 'object') {

            return false;
        }

        // Objects

        if (typeof value === 'object') {
            for (const item of this._values) {
                if (DeepEqual(item, value)) {
                    return { value: item };
                }
            }
        }

        // References

        if (state) {
            for (const ref of this._refs) {
                const resolved = ref.resolve(value, state, prefs, null, { in: true });
                if (resolved === undefined) {
                    continue;
                }

                const items = !ref.in || typeof resolved !== 'object'
                    ? [resolved]
                    : Array.isArray(resolved) ? resolved : Object.keys(resolved);

                for (const item of items) {
                    if (typeof item !== typeof value) {
                        continue;
                    }

                    if (insensitive &&
                        value &&
                        typeof value === 'string') {

                        if (item.toLowerCase() === value.toLowerCase()) {
                            return { value: item, ref };
                        }
                    }
                    else {
                        if (DeepEqual(item, value)) {
                            return { value: item, ref };
                        }
                    }
                }
            }
        }

        return false;
    }

    override() {

        this._override = true;
    }

    values(options) {

        if (options &&
            options.display) {

            const values = [];

            for (const item of [...this._values, ...this._refs]) {
                if (item !== undefined) {
                    values.push(item);
                }
            }

            return values;
        }

        return Array.from([...this._values, ...this._refs]);
    }

    clone() {

        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
    }

    concat(source) {

        Assert(!source._override, 'Cannot concat override set of values');

        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
    }

    describe() {

        const normalized = [];

        if (this._override) {
            normalized.push({ override: true });
        }

        for (const value of this._values.values()) {
            normalized.push(value && typeof value === 'object' ? { value } : value);
        }

        for (const value of this._refs.values()) {
            normalized.push(value.describe());
        }

        return normalized;
    }
};


internals.Values.prototype[Common.symbols.values] = true;


// Aliases

internals.Values.prototype.slice = internals.Values.prototype.clone;


// Helpers

internals.lowercases = function (from) {

    const map = new Map();

    if (from) {
        for (const value of from) {
            if (typeof value === 'string') {
                map.set(value.toLowerCase(), value);
            }
        }
    }

    return map;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/package.json":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/package.json ***!
  \*********************************************/
/*! exports provided: name, description, version, repository, main, browser, keywords, dependencies, devDependencies, scripts, files, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/joi\",\"description\":\"Object schema validation\",\"version\":\"16.1.7\",\"repository\":\"git://github.com/hapijs/joi\",\"main\":\"lib/index.js\",\"browser\":\"dist/joi-browser.min.js\",\"keywords\":[\"schema\",\"validation\"],\"dependencies\":{\"@hapi/address\":\"^2.1.2\",\"@hapi/formula\":\"^1.2.0\",\"@hapi/hoek\":\"^8.2.4\",\"@hapi/pinpoint\":\"^1.0.2\",\"@hapi/topo\":\"^3.1.3\"},\"devDependencies\":{\"@hapi/bourne\":\"1.x.x\",\"@hapi/code\":\"6.x.x\",\"@hapi/lab\":\"20.x.x\",\"@hapi/joi-legacy-test\":\"npm:@hapi/joi@15.x.x\"},\"scripts\":{\"prepublishOnly\":\"cd browser && npm install && npm run build\",\"test\":\"lab -t 100 -a @hapi/code -L\",\"test-cov-html\":\"lab -r html -o coverage.html -a @hapi/code\"},\"files\":[\"lib/**/*\",\"dist/*\"],\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/mimos/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/mimos/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Path = __webpack_require__(/*! path */ "path");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const MimeDb = __webpack_require__(/*! mime-db/db.json */ "./node_modules/mime-db/db.json");          // Load JSON file to prevent loading or executing code


const internals = {};


internals.compressibleRx = /^text\/|\+json$|\+text$|\+xml$/;


internals.compile = function (override) {

    const db = Hoek.clone(MimeDb);
    Hoek.merge(db, override, { nullOverride: true, mergeArrays: false });

    const result = {
        byType: db,
        byExtension: {}
    };

    const keys = Object.keys(result.byType);
    for (let i = 0; i < keys.length; ++i) {
        const type = keys[i];
        const mime = result.byType[type];
        mime.type = mime.type || type;
        mime.source = mime.source || 'mime-db';
        mime.extensions = mime.extensions || [];
        mime.compressible = (mime.compressible !== undefined ? mime.compressible : internals.compressibleRx.test(type));

        Hoek.assert(!mime.predicate || typeof mime.predicate === 'function', 'predicate option must be a function');

        for (let j = 0; j < mime.extensions.length; ++j) {
            const ext = mime.extensions[j];
            result.byExtension[ext] = mime;
        }
    }

    return result;
};


module.exports = class Mimos {
    constructor(options) {

        options = options || {};
        const result = options.override ? internals.compile(options.override) : internals.base;
        this._byType = result.byType;
        this._byExtension = result.byExtension;
    }

    path(path) {

        const extension = Path.extname(path).slice(1).toLowerCase();
        const mime = this._byExtension[extension] || {};

        if (mime.predicate) {
            return mime.predicate(Hoek.clone(mime));
        }

        return mime;
    }

    type(type) {

        type = type.split(';', 1)[0].trim().toLowerCase();
        let mime = this._byType[type];
        if (!mime) {
            mime = {
                type,
                source: 'mimos',
                extensions: [],
                compressible: internals.compressibleRx.test(type)
            };

            this._byType[type] = mime;
            return mime;
        }

        if (mime.predicate) {
            return mime.predicate(Hoek.clone(mime));
        }

        return mime;
    }
};


internals.base = internals.compile();       // Prevents an expensive copy on each constructor when no customization is needed


/***/ }),

/***/ "./node_modules/@hapi/nigel/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/nigel/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Vise = __webpack_require__(/*! @hapi/vise */ "./node_modules/@hapi/vise/lib/index.js");


const internals = {};


exports.compile = function (needle) {

    Hoek.assert(needle && needle.length, 'Missing needle');
    Hoek.assert(Buffer.isBuffer(needle), 'Needle must be a buffer');

    const profile = {
        value: needle,
        lastPos: needle.length - 1,
        last: needle[needle.length - 1],
        length: needle.length,
        badCharShift: Buffer.alloc(256)                  // Lookup table of how many characters can be skipped for each match
    };

    for (let i = 0; i < 256; ++i) {
        profile.badCharShift[i] = profile.length;       // Defaults to the full length of the needle
    }

    const last = profile.length - 1;
    for (let i = 0; i < last; ++i) {                    // For each character in the needle (skip last since its position is already the default)
        profile.badCharShift[profile.value[i]] = last - i;
    }

    return profile;
};


exports.horspool = function (haystack, needle, start) {

    Hoek.assert(haystack, 'Missing haystack');

    needle = (needle.badCharShift ? needle : exports.compile(needle));
    start = start || 0;

    for (let i = start; i <= haystack.length - needle.length;) {       // Has enough room to fit the entire needle
        const lastChar = haystack.readUInt8(i + needle.lastPos);
        if (lastChar === needle.last &&
            internals.startsWith(haystack, needle, i)) {

            return i;
        }

        i += needle.badCharShift[lastChar];           // Jump to the next possible position based on last character location in needle
    }

    return -1;
};


internals.startsWith = function (haystack, needle, pos) {

    if (haystack.startsWith) {
        return haystack.startsWith(needle.value, pos, needle.lastPos);
    }

    for (let i = 0; i < needle.lastPos; ++i) {
        if (needle.value[i] !== haystack.readUInt8(pos + i)) {
            return false;
        }
    }

    return true;
};


exports.all = function (haystack, needle, start) {

    needle = exports.compile(needle);
    start = start || 0;

    const matches = [];
    for (let i = start; i !== -1 && i < haystack.length;) {

        i = exports.horspool(haystack, needle, i);
        if (i !== -1) {
            matches.push(i);
            i += needle.length;
        }
    }

    return matches;
};


internals._indexOf = function (haystack, needle) {

    Hoek.assert(haystack, 'Missing haystack');

    for (let i = 0; i <= haystack.length - needle.length; ++i) {       // Has enough room to fit the entire needle
        if (haystack.startsWith(needle.value, i)) {
            return i;
        }
    }

    return -1;
};


exports.Stream = internals.Stream = class extends Stream.Writable {

    constructor(needle) {

        super();

        this.needle(needle);
        this._haystack = new Vise();
        this._indexOf = this._needle.length > 2 ? exports.horspool : internals._indexOf;

        this.on('finish', () => {

            // Flush out the remainder

            const chunks = this._haystack.chunks();
            for (let i = 0; i < chunks.length; ++i) {
                this.emit('haystack', chunks[i]);
            }

            setImmediate(() => this.emit('close'));     // Give pending events a chance to fire
        });
    }

    needle(needle) {

        this._needle = exports.compile(needle);
    }

    _write(chunk, encoding, next) {

        this._haystack.push(chunk);

        let match = this._indexOf(this._haystack, this._needle);
        if (match === -1 &&
            chunk.length >= this._needle.length) {

            this._flush(this._haystack.length - chunk.length);
        }

        while (match !== -1) {
            this._flush(match);
            this._haystack.shift(this._needle.length);
            this.emit('needle');

            match = this._indexOf(this._haystack, this._needle);
        }

        if (this._haystack.length) {
            const notChecked = this._haystack.length - this._needle.length + 1;       // Not enough space for Horspool
            let i = notChecked;
            for (; i < this._haystack.length; ++i) {
                if (this._haystack.startsWith(this._needle.value, i, this._haystack.length - i)) {
                    break;
                }
            }

            this._flush(i);
        }

        return next();
    }

    _flush(pos) {

        const chunks = this._haystack.shift(pos);
        for (let i = 0; i < chunks.length; ++i) {
            this.emit('haystack', chunks[i]);
        }
    }

    flush() {

        const chunks = this._haystack.shift(this._haystack.length);
        for (let i = 0; i < chunks.length; ++i) {
            this.emit('haystack', chunks[i]);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/pez/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/pez/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const B64 = __webpack_require__(/*! @hapi/b64 */ "./node_modules/@hapi/b64/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Content = __webpack_require__(/*! @hapi/content */ "./node_modules/@hapi/content/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Nigel = __webpack_require__(/*! @hapi/nigel */ "./node_modules/@hapi/nigel/lib/index.js");


const internals = {};


/*
    RFC 2046 (http://tools.ietf.org/html/rfc2046)

    multipart-body = [preamble CRLF]
                    dash-boundary *( SPACE / HTAB ) CRLF body-part
                    *( CRLF dash-boundary *( SPACE / HTAB ) CRLF body-part )
                    CRLF dash-boundary "--" *( SPACE / HTAB )
                    [CRLF epilogue]

    boundary       = 0*69<bchars> bcharsnospace
    bchars         = bcharsnospace / " "
    bcharsnospace  = DIGIT / ALPHA / "'" / "(" / ")" / "+" / "_" / "," / "-" / "." / "/" / ":" / "=" / "?"
    dash-boundary  = "--" boundary

    preamble       = discard-text
    epilogue       = discard-text
    discard-text   = *(*text CRLF) *text

    body-part      = MIME-part-headers [CRLF *OCTET]
    OCTET          = <any 0-255 octet value>

    SPACE          = 32
    HTAB           = 9
    CRLF           = 13 10
*/


internals.state = {
    preamble: 0,                // Until the first boundary is received
    boundary: 1,                // After a boundary, waiting for first line with optional linear-whitespace
    header: 2,                  // Receiving part headers
    payload: 3,                 // Receiving part payload
    epilogue: 4
};


internals.defaults = {
    maxBytes: Infinity
};


exports.Dispenser = internals.Dispenser = class extends Stream.Writable {

    constructor(options) {

        super();

        Hoek.assert(options !== null && typeof options === 'object', 'options must be an object');
        const settings = Hoek.applyToDefaults(internals.defaults, options);

        this._boundary = settings.boundary;
        this._state = internals.state.preamble;
        this._held = '';

        this._stream = null;
        this._headers = {};
        this._name = '';
        this._pendingHeader = '';
        this._error = null;
        this._bytes = 0;
        this._maxBytes = settings.maxBytes;

        this._parts = new Nigel.Stream(Buffer.from('--' + settings.boundary));
        this._lines = new Nigel.Stream(Buffer.from('\r\n'));

        this._parts.on('needle', () => this._onPartEnd());
        this._parts.on('haystack', (chunk) => this._onPart(chunk));
        this._lines.on('needle', () => this._onLineEnd());
        this._lines.on('haystack', (chunk) => this._onLine(chunk));
        this.once('finish', () => this._parts.end());
        this._parts.once('close', () => this._lines.end());

        let piper = null;
        let finish = (err) => {

            if (piper) {
                piper.removeListener('data', onReqData);
                piper.removeListener('error', finish);
                piper.removeListener('aborted', onReqAborted);
            }

            if (err) {
                return this._abort(err);
            }

            this._emit('close');
        };

        finish = Hoek.once(finish);

        this._lines.once('close', () => {

            if (this._state === internals.state.epilogue) {
                if (this._held) {
                    this._emit('epilogue', this._held);
                    this._held = '';
                }
            }
            else if (this._state === internals.state.boundary) {
                if (!this._held) {
                    this._abort(Boom.badRequest('Missing end boundary'));
                }
                else if (this._held !== '--') {
                    this._abort(Boom.badRequest('Only white space allowed after boundary at end'));
                }
            }
            else {
                this._abort(Boom.badRequest('Incomplete multipart payload'));
            }

            setImmediate(finish);                  // Give pending events a chance to fire
        });

        const onReqAborted = () => {

            finish(Boom.badRequest('Client request aborted'));
        };

        const onReqData = (data) => {

            this._bytes += Buffer.byteLength(data);

            if (this._bytes > this._maxBytes) {
                finish(Boom.entityTooLarge('Maximum size exceeded'));
            }
        };

        this.once('pipe', (req) => {

            piper = req;
            req.on('data', onReqData);
            req.once('error', finish);
            req.once('aborted', onReqAborted);
        });
    }
};


internals.Dispenser.prototype._write = function (buffer, encoding, next) {

    if (this._error) {
        return next();
    }

    this._parts.write(buffer);
    return next();
};


internals.Dispenser.prototype._emit = function (...args) {

    if (this._error) {
        return;
    }

    this.emit(...args);
};


internals.Dispenser.prototype._abort = function (err) {

    this._emit('error', err);
    this._error = err;
};


internals.Dispenser.prototype._onPartEnd = function () {

    this._lines.flush();

    if (this._state === internals.state.preamble) {
        if (this._held) {
            const last = this._held.length - 1;

            if (this._held[last] !== '\n' ||
                this._held[last - 1] !== '\r') {

                return this._abort(Boom.badRequest('Preamble missing CRLF terminator'));
            }

            this._emit('preamble', this._held.slice(0, -2));
            this._held = '';
        }

        this._parts.needle(Buffer.from('\r\n--' + this._boundary));                      // CRLF no longer optional
    }

    this._state = internals.state.boundary;

    if (this._stream) {
        this._stream.end();
        this._stream = null;
    }
    else if (this._name) {
        this._emit('field', this._name, this._held);
        this._name = '';
        this._held = '';
    }
};


internals.Dispenser.prototype._onPart = function (chunk) {

    if (this._state === internals.state.preamble) {
        this._held = this._held + chunk.toString();
    }
    else if (this._state === internals.state.payload) {
        if (this._stream) {
            this._stream.write(chunk);                                                 // Stream payload
        }
        else {
            this._held = this._held + chunk.toString();
        }
    }
    else {
        this._lines.write(chunk);                                                       // Look for boundary
    }
};


internals.Dispenser.prototype._onLineEnd = function () {

    // Boundary whitespace

    if (this._state === internals.state.boundary) {
        if (this._held) {
            this._held = this._held.replace(/[\t ]/g, '');                                // trim() removes new lines
            if (this._held) {
                if (this._held === '--') {
                    this._state = internals.state.epilogue;
                    this._held = '';

                    return;
                }

                return this._abort(Boom.badRequest('Only white space allowed after boundary'));
            }
        }

        this._state = internals.state.header;

        return;
    }

    // Part headers

    if (this._state === internals.state.header) {

        // Header

        if (this._held) {

            // Header continuation

            if (this._held[0] === ' ' ||
                this._held[0] === '\t') {

                if (!this._pendingHeader) {
                    return this._abort(Boom.badRequest('Invalid header continuation without valid declaration on previous line'));
                }

                this._pendingHeader = this._pendingHeader + ' ' + this._held.slice(1);                       // Drop tab
                this._held = '';
                return;
            }

            // Start of new header

            this._flushHeader();
            this._pendingHeader = this._held;
            this._held = '';

            return;
        }

        // End of headers

        this._flushHeader();

        this._state = internals.state.payload;

        let disposition;

        try {
            disposition = Content.disposition(this._headers['content-disposition']);
        }
        catch (err) {
            return this._abort(err);
        }

        if (disposition.filename !== undefined) {
            const stream = new Stream.PassThrough();
            const transferEncoding = this._headers['content-transfer-encoding'];

            if (transferEncoding &&
                transferEncoding.toLowerCase() === 'base64') {

                this._stream = new B64.Decoder();
                this._stream.pipe(stream);
            }
            else {
                this._stream = stream;
            }

            stream.name = disposition.name;
            stream.filename = disposition.filename;
            stream.headers = this._headers;
            this._headers = {};
            this._emit('part', stream);
        }
        else {
            this._name = disposition.name;
        }

        this._lines.flush();
        return;
    }

    // Epilogue

    this._held = this._held + '\r\n';                               // Put the new line back
};


internals.Dispenser.prototype._onLine = function (chunk) {

    if (this._stream) {
        this._stream.write(chunk);                      // Stream payload
    }
    else {
        this._held = this._held + chunk.toString();                 // Reading header or field
    }
};


internals.Dispenser.prototype._flushHeader = function () {

    if (!this._pendingHeader) {
        return;
    }

    const sep = this._pendingHeader.indexOf(':');

    if (sep === -1) {
        return this._abort(Boom.badRequest('Invalid header missing colon separator'));
    }

    if (!sep) {
        return this._abort(Boom.badRequest('Invalid header missing field name'));
    }

    this._headers[this._pendingHeader.slice(0, sep).toLowerCase()] = this._pendingHeader.slice(sep + 1).trim();
    this._pendingHeader = '';
};


/***/ }),

/***/ "./node_modules/@hapi/pinpoint/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/pinpoint/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.location = function (depth = 0) {

    const orig = Error.prepareStackTrace;
    Error.prepareStackTrace = (ignore, stack) => stack;

    const capture = {};
    Error.captureStackTrace(capture, this);
    const line = capture.stack[depth + 1];

    Error.prepareStackTrace = orig;

    return {
        filename: line.getFileName(),
        line: line.getLineNumber()
    };
};


/***/ }),

/***/ "./node_modules/@hapi/podium/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/podium/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {
    schema: {
        base: Joi.object({
            name: Joi.string().required(),
            clone: Joi.boolean(),
            tags: Joi.boolean(),
            spread: Joi.boolean(),
            channels: Joi.array().items(Joi.string()).single().unique().min(1)
        })
    }
};


internals.schema.event = internals.schema.base.keys({
    shared: Joi.boolean()
});


internals.schema.listener = internals.schema.event.keys({
    listener: Joi.func().required(),
    context: Joi.object(),
    count: Joi.number().integer().min(1),
    filter: {
        tags: Joi.array().items(Joi.string()).single().unique().min(1).required(),
        all: Joi.boolean()
    }
});


exports = module.exports = internals.Podium = function (events, options) {

    // Use descriptive names to avoid conflict when inherited

    this._eventListeners = Object.create(null);
    this._notificationsQueue = [];
    this._eventsProcessing = false;
    this._sourcePodiums = [];

    if (events) {
        this.registerEvent(events, options);
    }
};


internals.Podium.decorate = function (target, source) {

    internals.Podium.call(target, null);

    Object.keys(source._eventListeners).forEach((name) => {

        target._eventListeners[name] = {
            handlers: null,
            flags: source._eventListeners[name].flags
        };
    });
};


internals.Podium.validate = function (events) {

    const normalized = [];
    [].concat(events).forEach((event) => {

        if (typeof event === 'string') {
            event = { name: event };
        }

        normalized.push(Joi.attempt(event, internals.schema.event, 'Invalid event options'));
    });

    return normalized;
};


internals.Podium.prototype.registerEvent = function (events, options = {}) {

    events = Hoek.flatten([].concat(events));
    events.forEach((event) => {

        if (!event) {
            return;
        }

        if (event instanceof internals.Podium) {
            return this.registerPodium(event);
        }

        if (typeof event === 'string') {
            event = { name: event };
        }

        if (options.validate !== false) {                                                       // Defaults to true
            event = Joi.attempt(event, internals.schema.event, 'Invalid event options');
        }

        const name = event.name;
        if (this._eventListeners[name]) {
            Hoek.assert(event.shared, `Event ${name} exists`);
            return;
        }

        this._eventListeners[name] = { handlers: null, flags: event };
        this._sourcePodiums.forEach((podium) => {

            if (!podium._eventListeners[name]) {
                podium._eventListeners[name] = { handlers: null, flags: event };
            }
        });
    });
};


internals.Podium.prototype.registerPodium = function (podiums) {

    [].concat(podiums).forEach((podium) => {

        if (podium._sourcePodiums.indexOf(this) !== -1) {
            return;
        }

        podium._sourcePodiums.push(this);
        Object.keys(podium._eventListeners).forEach((name) => {

            if (!this._eventListeners[name]) {
                this._eventListeners[name] = { handlers: null, flags: podium._eventListeners[name].flags };
            }
        });
    });
};


internals.Podium.prototype.emit = async function (criteria, data, _generated) {

    criteria = internals.criteria(criteria);

    const name = criteria.name;
    Hoek.assert(name, 'Criteria missing event name');

    const event = this._eventListeners[name];
    Hoek.assert(event, `Unknown event ${name}`);
    Hoek.assert(!criteria.channel || typeof criteria.channel === 'string', 'Invalid channel name');
    Hoek.assert(!criteria.channel || !event.flags.channels || event.flags.channels.indexOf(criteria.channel) !== -1, `Unknown ${criteria.channel} channel`);
    Hoek.assert(!event.flags.spread || Array.isArray(data) || typeof data === 'function', 'Data must be an array for spread event');

    if (!event.handlers &&
        !this._sourcePodiums.length) {

        return;
    }

    if (typeof criteria.tags === 'string') {
        criteria.tags = [criteria.tags];
    }

    if (criteria.tags &&
        Array.isArray(criteria.tags)) {

        // Map array to object

        const tags = {};
        for (const tag of criteria.tags) {
            tags[tag] = true;
        }

        criteria.tags = tags;
    }

    if (event.handlers) {
        const processing = [];

        const handlers = event.handlers.slice();                // Clone in case handlers are changed by listeners
        for (let i = 0; i < handlers.length; ++i) {
            const handler = handlers[i];

            if (handler.channels &&
                (!criteria.channel || handler.channels.indexOf(criteria.channel) === -1)) {

                continue;
            }

            if (handler.filter) {
                if (!criteria.tags) {
                    continue;
                }

                const match = Hoek.intersect(criteria.tags, handler.filter.tags, { first: !handler.filter.all });
                if (!match ||
                    (handler.filter.all && match.length !== handler.filter.tags.length)) {

                    continue;
                }
            }

            if (handler.count) {
                --handler.count;
                if (handler.count < 1) {
                    internals.removeHandler(this, criteria.name, handler);
                }
            }

            if (!_generated &&
                typeof data === 'function') {

                data = data();
                _generated = true;
            }

            const update = (internals.flag('clone', handler, event) ? Hoek.clone(data) : data);
            const args = (internals.flag('spread', handler, event) && Array.isArray(update) ? update : [update]);

            if (internals.flag('tags', handler, event) &&
                criteria.tags) {

                args.push(criteria.tags);
            }

            try {
                const result = (handler.context ? handler.listener.apply(handler.context, args) : handler.listener(...args));
                if (result &&
                    typeof result.then === 'function') {

                    processing.push(result);
                }
            }
            catch (err) {
                processing.push(Promise.reject(err));
            }
        }

        if (processing.length) {
            await Promise.all(processing);
        }
    }

    if (this._sourcePodiums.length) {
        const podiums = this._sourcePodiums.slice();         // Clone in case modified while processing
        await Promise.all(podiums.map((podium) => podium.emit(criteria, data, _generated)));
    }
};


internals.Podium.prototype.on = internals.Podium.prototype.addListener = function (criteria, listener, context) {

    criteria = internals.criteria(criteria);
    criteria.listener = listener;
    criteria.context = context;

    if (criteria.filter &&
        (typeof criteria.filter === 'string' || Array.isArray(criteria.filter))) {

        criteria.filter = { tags: criteria.filter };
    }

    criteria = Joi.attempt(criteria, internals.schema.listener, 'Invalid event listener options');

    const name = criteria.name;
    const event = this._eventListeners[name];
    Hoek.assert(event, `Unknown event ${name}`);
    Hoek.assert(!criteria.channels || !event.flags.channels || Hoek.intersect(event.flags.channels, criteria.channels).length === criteria.channels.length, `Unknown event channels ${criteria.channels && criteria.channels.join(', ')}`);

    this._eventListeners[name].handlers = this._eventListeners[name].handlers || [];
    this._eventListeners[name].handlers.push(criteria);

    return this;
};


internals.Podium.prototype.once = function (criteria, listener, context) {

    criteria = Object.assign(internals.criteria(criteria), { count: 1 });

    if (listener) {
        return this.on(criteria, listener, context);
    }

    return new Promise((resolve) => this.on(criteria, (...args) => resolve(args), context));
};


internals.Podium.prototype.removeListener = function (name, listener) {

    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);
    Hoek.assert(typeof listener === 'function', 'Listener must be a function');

    const handlers = this._eventListeners[name].handlers;
    if (!handlers) {
        return this;
    }

    const filtered = handlers.filter((handler) => handler.listener !== listener);
    this._eventListeners[name].handlers = (filtered.length ? filtered : null);
    return this;
};


internals.Podium.prototype.removeAllListeners = function (name) {

    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);
    this._eventListeners[name].handlers = null;
    return this;
};


internals.Podium.prototype.hasListeners = function (name) {

    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);
    return !!this._eventListeners[name].handlers;
};


internals.removeHandler = function (emitter, name, handler) {

    const handlers = emitter._eventListeners[name].handlers;
    const filtered = handlers.filter((item) => item !== handler);
    emitter._eventListeners[name].handlers = (filtered.length ? filtered : null);
};


internals.criteria = function (criteria) {

    return (typeof criteria === 'string' ? { name: criteria } : Hoek.clone(criteria));
};


internals.flag = function (name, handler, event) {

    return (handler[name] !== undefined ? handler[name] : event.flags[name]) || false;
};


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/shot/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const Request = __webpack_require__(/*! ./request */ "./node_modules/@hapi/shot/lib/request.js");
const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/shot/lib/response.js");
const Symbols = __webpack_require__(/*! ./symbols */ "./node_modules/@hapi/shot/lib/symbols.js");


const internals = {};


internals.options = Joi.object().keys({
    url: Joi.alternatives([
        Joi.string(),
        Joi.object().keys({
            protocol: Joi.string(),
            hostname: Joi.string(),
            port: Joi.any(),
            pathname: Joi.string().required(),
            query: Joi.any()
        })
    ])
        .required(),
    headers: Joi.object(),
    payload: Joi.any(),
    simulate: {
        end: Joi.boolean(),
        split: Joi.boolean(),
        error: Joi.boolean(),
        close: Joi.boolean()
    },
    authority: Joi.string(),
    remoteAddress: Joi.string(),
    method: Joi.string(),
    validate: Joi.boolean()
});


exports.inject = function (dispatchFunc, options) {

    options = (typeof options === 'string' ? { url: options } : options);

    if (options.validate !== false) {                                                           // Defaults to true
        try {
            Hoek.assert(typeof dispatchFunc === 'function', 'Invalid dispatch function');
            Joi.assert(options, internals.options);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }

    return new Promise((resolve) => {

        const req = new Request(options);
        const res = new Response(req, resolve);

        req.prepare(() => dispatchFunc(req, res));
    });
};


exports.isInjection = function (obj) {

    return !!obj[Symbols.injection];
};


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/request.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/shot/lib/request.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");
const Url = __webpack_require__(/*! url */ "url");

const Symbols = __webpack_require__(/*! ./symbols */ "./node_modules/@hapi/shot/lib/symbols.js");


const internals = {};


exports = module.exports = internals.Request = class extends Stream.Readable {

    constructor(options) {

        super();

        // options: method, url, payload, headers, remoteAddress

        let url = options.url;
        if (typeof url === 'object') {
            url = Url.format(url);
        }

        const uri = Url.parse(url);
        this.url = uri.path;

        this.httpVersion = '1.1';
        this.method = (options.method ? options.method.toUpperCase() : 'GET');

        this.headers = {};
        const headers = options.headers || {};
        const fields = Object.keys(headers);
        fields.forEach((field) => {

            this.headers[field.toLowerCase()] = headers[field];
        });

        this.headers['user-agent'] = this.headers['user-agent'] || 'shot';

        const hostHeaderFromUri = function () {

            if (uri.port) {
                return uri.host;
            }

            if (uri.protocol) {
                return uri.hostname + (uri.protocol === 'https:' ? ':443' : ':80');
            }

            return null;
        };

        this.headers.host = this.headers.host || hostHeaderFromUri() || options.authority || 'localhost:80';

        this.connection = {
            remoteAddress: options.remoteAddress || '127.0.0.1'
        };

        let payload = options.payload || null;
        if (payload &&
            typeof payload !== 'string' &&
            !(payload instanceof Stream) &&
            !Buffer.isBuffer(payload)) {

            payload = JSON.stringify(payload);
            this.headers['content-type'] = this.headers['content-type'] || 'application/json';
        }

        // Set the content-length for the corresponding payload if none set

        if (payload &&
            !(payload instanceof Stream) &&
            !this.headers.hasOwnProperty('content-length')) {

            this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
        }

        // Use _shot namespace to avoid collision with Node

        this._shot = {
            payload,
            isDone: false,
            simulate: options.simulate || {}
        };

        return this;
    }

    prepare(next) {

        if (this._shot.payload instanceof Stream === false) {
            return next();
        }

        const chunks = [];

        this._shot.payload.on('data', (chunk) => chunks.push(Buffer.from(chunk)));

        this._shot.payload.on('end', () => {

            const payload = Buffer.concat(chunks);
            this.headers['content-length'] = this.headers['content-length'] || payload.length;
            this._shot.payload = payload;
            return next();
        });
    }

    _read(size) {

        setImmediate(() => {

            if (this._shot.isDone) {
                /* $lab:coverage:off$ */
                if (this._shot.simulate.end !== false) {        // 'end' defaults to true
                    this.push(null);
                }
                /* $lab:coverage:on$ */

                return;
            }

            this._shot.isDone = true;

            if (this._shot.payload) {
                if (this._shot.simulate.split) {
                    this.push(this._shot.payload.slice(0, 1));
                    this.push(this._shot.payload.slice(1));
                }
                else {
                    this.push(this._shot.payload);
                }
            }

            if (this._shot.simulate.error) {
                this.emit('error', new Error('Simulated'));
            }

            if (this._shot.simulate.close) {
                this.emit('close');
            }

            if (this._shot.simulate.end !== false) {        // 'end' defaults to true
                this.push(null);
            }
        });
    }

    destroy() {

    }
};


internals.Request.prototype[Symbols.injection] = true;


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/response.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/shot/lib/response.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Http = __webpack_require__(/*! http */ "http");
const Stream = __webpack_require__(/*! stream */ "stream");

const Symbols = __webpack_require__(/*! ./symbols */ "./node_modules/@hapi/shot/lib/symbols.js");


const internals = {};


exports = module.exports = internals.Response = class extends Http.ServerResponse {

    constructor(req, onEnd) {

        super({ method: req.method, httpVersionMajor: 1, httpVersionMinor: 1 });
        this._shot = { headers: null, trailers: {}, payloadChunks: [] };
        this.assignSocket(internals.nullSocket());

        this.once('finish', () => {

            const res = internals.payload(this);
            res.raw.req = req;
            process.nextTick(() => onEnd(res));
        });
    }

    writeHead(...args) {

        // Find the headers object if one was provided. If a headers object is present, call setHeader()
        // on the first valid header, and then break out of the loop and call writeHead(). By calling
        // setHeader(), Node will materialize a headers object.

        const headers = args[args.length - 1];

        if (typeof headers === 'object' && headers !== null) {
            const headerNames = Object.keys(headers);

            for (let i = 0; i < headerNames.length; ++i) {
                const name = headerNames[i];

                try {
                    this.setHeader(name, headers[name]);
                    break;
                }
                catch (ignoreErr) {} // Let the real writeHead() handle errors.
            }
        }

        const result = super.writeHead(...args);

        this._shot.headers = this.getHeaders();

        // Add raw headers

        ['Date', 'Connection', 'Transfer-Encoding'].forEach((name) => {

            const regex = new RegExp('\\r\\n' + name + ': ([^\\r]*)\\r\\n');
            const field = this._header.match(regex);
            if (field) {
                this._shot.headers[name.toLowerCase()] = field[1];
            }
        });

        return result;
    }

    write(data, encoding, callback) {

        super.write(data, encoding, callback);
        this._shot.payloadChunks.push(Buffer.from(data, encoding));
        return true;                                                    // Write always returns false when disconnected
    }

    end(data, encoding, callback) {

        if (data) {
            this.write(data, encoding);
        }

        super.end(callback);
        this.emit('finish');
    }

    destroy() {

    }

    addTrailers(trailers) {

        for (const key in trailers) {
            this._shot.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
        }
    }
};


internals.Response.prototype[Symbols.injection] = true;


internals.payload = function (response) {

    // Prepare response object

    const res = {
        raw: {
            res: response
        },
        headers: response._shot.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {}
    };

    // Prepare payload and trailers

    const rawBuffer = Buffer.concat(response._shot.payloadChunks);
    res.rawPayload = rawBuffer;
    res.payload = rawBuffer.toString();
    res.trailers = response._shot.trailers;

    return res;
};


// Throws away all written data to prevent response from buffering payload

internals.nullSocket = function () {

    return new Stream.Writable({
        write(chunk, encoding, callback) {

            setImmediate(callback);
        }
    });
};


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/symbols.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/shot/lib/symbols.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.injection = Symbol('injection');


/***/ }),

/***/ "./node_modules/@hapi/somever/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/somever/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    maxLength: 256,
    wildcards: ['x', 'X', '*'],
    any: Symbol('any')
};

//                              1:major         2:minor         3:patch          4:prerelease  5:build
//                              A         aB    C         cD    E         eF     G     gf H    I  ih d b
internals.versionRx = /^\s*[vV]?(\d+|[xX*])(?:\.(\d+|[xX*])(?:\.(\d+|[xX*])(?:\-?([^+]+))?(?:\+(.+))?)?)?\s*$/;

internals.strict = {
    tokenRx: /^[-\dA-Za-z]+(?:\.[-\dA-Za-z]+)*$/,
    numberRx: /^((?:0)|(?:[1-9]\d*))$/
};


exports.version = function (version, options) {

    return new internals.Version(version, options);
};


exports.range = function (range) {

    return new internals.Range(range);
};


exports.match = function (version, range) {

    try {
        return exports.range(range).match(version);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        return false;
    }
};


internals.Version = class {

    constructor(version, options = {}) {

        Hoek.assert(version, 'Missing version argument');

        if (version instanceof internals.Version) {
            return version;
        }

        if (typeof version === 'object') {
            this._copy(version);
        }
        else {
            this._parse(version, options);
        }

        this.format();
    }

    _copy(version) {

        this.major = version.major === undefined ? internals.any : version.major;
        this.minor = version.minor === undefined ? internals.any : version.minor;
        this.patch = version.patch === undefined ? internals.any : version.patch;
        this.prerelease = version.prerelease || [];
        this.build = version.build || [];
    }

    _parse(version, options) {

        Hoek.assert(typeof version === 'string', 'Version argument must be a string');
        Hoek.assert(version.length <= internals.maxLength, 'Version string too long');

        const match = version.match(internals.versionRx);
        if (!match) {
            throw new Error(`Invalid version string format: ${version}`);
        }

        this.major = internals.Version._number(match[1], 'major', options);
        this.minor = internals.Version._number(match[2] || 'x', 'minor', options);
        this.patch = internals.Version._number(match[3] || 'x', 'patch', options);

        this.prerelease = internals.Version._sub(match[4], 'prerelease', options);
        this.build = internals.Version._sub(match[5], 'build', options);
    }

    static _number(string, source, options) {

        if (internals.wildcards.includes(string)) {
            return internals.any;
        }

        if (options.strict) {
            Hoek.assert(string.match(internals.strict.numberRx), 'Value must be 0 or a number without a leading zero:', source);
        }

        const value = parseInt(string, 10);
        Hoek.assert(value <= Number.MAX_SAFE_INTEGER, 'Value must be positive and less than max safe integer:', source);
        return value;
    }

    static _sub(string, source, options) {

        if (!string) {
            return [];
        }

        if (options.strict) {
            Hoek.assert(string.match(internals.strict.tokenRx), 'Value can only contain dot-separated hyphens, digits, a-z or A-Z:', source);
        }

        const subs = [];
        const parts = string.split('.');
        for (const part of parts) {
            if (!part) {
                throw new Error(`Invalid empty ${source} segment`);
            }

            subs.push(part.match(/^\d+$/) ? internals.Version._number(part, source, { strict: options.strict }) : part);
        }

        return subs;
    }

    format() {

        this.version = `${internals.dot(this.major)}.${internals.dot(this.minor)}.${internals.dot(this.patch)}${internals.token(this.prerelease, '-')}${internals.token(this.build, '+')}`;
        this.dots = [this.major, this.minor, this.patch];
        this.wildcard = this.major === internals.any && this.minor === internals.any && this.patch === internals.any && !this.prerelease.length;
    }

    toString() {

        return this.version;
    }

    compare(to, options) {

        return internals.Version.compare(this, to, options);
    }

    static compare(a, b, options = {}) {

        let aFirst = -1;
        let bFirst = 1;

        a = exports.version(a, options);
        b = exports.version(b, options);

        // Mark incompatible prereleases

        if (options.range &&
            a.prerelease.length &&
            (a.major !== b.major || a.minor !== b.minor || a.patch !== b.patch || !b.prerelease.length)) {

            aFirst = -2;
            bFirst = 2;
        }

        // Compare versions

        for (let i = 0; i < 3; ++i) {
            const av = a.dots[i];
            const bv = b.dots[i];

            if (av === bv ||
                av === internals.any ||                             // Wildcard is equal to everything
                bv === internals.any) {

                continue;
            }

            return av - bv < 0 ? aFirst : bFirst;
        }

        // Compare prerelease

        if (!a.prerelease.length &&
            !b.prerelease.length) {

            return 0;
        }

        if (!!a.prerelease.length !== !!b.prerelease.length) {
            return (a.prerelease.length ? aFirst : bFirst);         // prerelease < none
        }

        for (let i = 0; ; ++i) {
            const ai = a.prerelease[i];
            const bi = b.prerelease[i];

            if (ai === undefined &&
                bi === undefined) {

                return 0;
            }

            if (ai === bi) {
                continue;
            }

            if (ai === undefined) {
                return aFirst;
            }

            if (bi === undefined) {
                return bFirst;
            }

            const an = Number.isFinite(ai);
            const bn = Number.isFinite(bi);

            if (an !== bn) {
                return an ? aFirst : bFirst;
            }

            return (a < b ? aFirst : bFirst);
        }
    }
};


internals.dot = (v) => {

    return (v === internals.any ? 'x' : v);
};


internals.token = (v, prefix) => {

    if (!v.length) {
        return '';
    }

    return `${prefix}${v.join('.')}`;
};


internals.Range = class {

    constructor(range, options) {

        this._settings = Object.assign({}, options);    // Shallow cloned
        this._anything = false;
        this._or = [];                                  // [and, and, ..., active]
        this._active = null;

        if (range !== undefined) {
            this.pattern(range);
        }

        this._another();
    }

    _another() {

        if (!this._active ||
            this._active.rules.length) {

            this._active = { rules: [] };
            this._or.push(this._active);
        }

        return this;
    }

    _rule(operator, version) {

        version = exports.version(version, this._settings);

        const compare = internals.operator(operator);
        this._active.rules.push({ compare, version, operator });

        return this;
    }

    get or() {

        return this._another();
    }

    equal(version) {

        return this._rule('=', version);
    }

    above(version) {

        return this._rule('>', version);
    }

    below(version) {

        return this._rule('<', version);
    }

    between(from, to) {

        this._rule('>=', from);
        this._rule('<=', to);
        return this;
    }

    minor(version) {        // ~1.2.3

        // minor(2.5.7)     ->      2.5.7 <= X < 2.6.0
        // minor(2.5.x)     ->      2.5.0 <= X < 2.6.0
        // minor(2.x.x)     ->      2.0.0 <= X < 3.0.0

        version = exports.version(version, this._settings);

        if (version.major === internals.any) {
            this._rule('=', version);
            return this;
        }

        this._rule('>=', version);

        if (version.minor === internals.any) {
            this._rule('<', { major: version.major + 1, minor: 0, patch: 0 });
        }
        else {
            this._rule('<', { major: version.major, minor: version.minor + 1, patch: 0 });
        }

        return this;
    }

    compatible(version) {       // ^1.2.3

        // compatible(2.5.7)     ->      2.5.7 <= X < 3.0.0
        // compatible(2.x.x)     ->      2.0.0 <= X < 3.0.0
        // compatible(0.1.x)     ->      0.1.0 <= X < 0.2.0

        version = exports.version(version, this._settings);

        if (version.major === internals.any) {
            this._rule('=', version);
            return this;
        }

        this._rule('>=', version);

        if (version.major === 0 &&
            version.minor !== internals.any) {

            if (version.minor === 0) {
                this._rule('<', { major: 0, minor: 0, patch: version.patch + 1 });
            }
            else {
                this._rule('<', { major: 0, minor: version.minor + 1, patch: 0 });
            }
        }
        else {
            this._rule('<', { major: version.major + 1, minor: 0, patch: 0 });
        }

        return this;
    }

    pattern(range) {

        try {
            this._pattern(range);
            return this;
        }
        catch (err) {
            throw new Error(`Invalid range: "${range}" because: ${err.message}`);
        }
    }

    _pattern(range) {

        if (range === '') {
            this._anything = true;
            return;
        }

        const normalized = internals.normalize(range);
        const ors = normalized.split(/\s*\|\|\s*/);
        for (const condition of ors) {
            if (!condition) {
                this._anything = true;
                return;
            }

            this._another();

            const ands = condition.split(/\s+/);
            for (const and of ands) {

                // Hyphen range

                const hyphen = and.indexOf('@');            // Originally " - "
                if (hyphen !== -1) {
                    const from = and.slice(0, hyphen);
                    const to = and.slice(hyphen + 1);
                    this.between(from, to);
                    continue;
                }

                // Prefix

                const parts = and.match(/^(\^|~|<\=|>\=|<|>|\=)?(.+)$/);
                const operator = parts[1];
                const version = exports.version(parts[2], this._settings);

                if (version.wildcard) {
                    this._anything = true;
                    return;
                }

                // Tilde

                if (operator === '~') {
                    this.minor(version);
                    continue;
                }

                // Caret

                if (operator === '^') {
                    this.compatible(version);
                    continue;
                }

                // One sided range

                if (operator) {
                    this._rule(operator, version);
                    continue;
                }

                // Version

                this.equal(version);
            }
        }
    }

    match(version) {

        version = exports.version(version, this._settings);       // Always parse to validate

        if (this._anything) {
            return !version.prerelease.length;
        }

        for (const { rules } of this._or) {
            if (!rules.length) {
                continue;
            }

            let matches = 0;
            let excludes = 0;

            for (const rule of rules) {
                const compare = version.compare(rule.version, Object.assign(this._settings, { range: true }));
                const exclude = Math.abs(compare) === 2;

                if (rule.compare.includes(compare / (exclude ? 2 : 1))) {
                    ++matches;
                    if (exclude) {
                        ++excludes;
                    }
                }
                else {
                    break;
                }
            }

            if (matches === rules.length &&
                excludes < matches) {

                return true;
            }
        }

        return false;
    }

    toString() {

        if (this._anything) {
            return '*';
        }

        let string = '';
        for (const { rules } of this._or) {
            if (!rules.length) {
                continue;
            }

            const conditions = [];
            for (const rule of rules) {
                conditions.push(`${rule.operator !== '=' ? rule.operator : ''}${rule.version.version}`);
            }

            string += (string ? '||' : '') + conditions.join(' ');
        }

        return string;
    }
};


internals.operator = function (compare) {

    switch (compare) {
        case '=': return [0];
        case '>': return [1];
        case '>=': return [0, 1];
        case '<': return [-1];
        case '<=': return [0, -1];
    }
};


internals.normalize = function (range) {

    return range
        .replace(/ \- /g, '@')                                                          // Range to excluded symbol
        .replace(/~>/g, '~')                                                            // Legacy npm operator
        .replace(/(\^|~|<\=|>\=|<|>|\=)\s*([^\s]+)/g, ($0, $1, $2) => `${$1}${$2}`);    // Space between operator and version
};


/***/ }),

/***/ "./node_modules/@hapi/statehood/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/statehood/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Querystring = __webpack_require__(/*! querystring */ "querystring");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Cryptiles = __webpack_require__(/*! @hapi/cryptiles */ "./node_modules/@hapi/cryptiles/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Iron = __webpack_require__(/*! @hapi/iron */ "./node_modules/@hapi/iron/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {};


internals.schema = Joi.object({
    strictHeader: Joi.boolean(),
    ignoreErrors: Joi.boolean(),
    isSecure: Joi.boolean(),
    isHttpOnly: Joi.boolean(),
    isSameSite: Joi.valid('Strict', 'Lax').allow(false),
    path: Joi.string().allow(null),
    domain: Joi.string().allow(null),
    ttl: Joi.number().allow(null),
    encoding: Joi.string().valid('base64json', 'base64', 'form', 'iron', 'none'),
    sign: Joi.object({
        password: [Joi.string(), Joi.binary(), Joi.object()],
        integrity: Joi.object()
    }),
    iron: Joi.object(),
    password: [Joi.string(), Joi.binary(), Joi.object()],

    // Used by hapi

    clearInvalid: Joi.boolean(),
    autoValue: Joi.any(),
    passThrough: Joi.boolean()
});


internals.defaults = {
    strictHeader: true,                             // Require an RFC 6265 compliant header format
    ignoreErrors: false,
    isSecure: true,
    isHttpOnly: true,
    isSameSite: 'Strict',
    path: null,
    domain: null,
    ttl: null,                                      // MSecs, 0 means remove
    encoding: 'none'                                // options: 'base64json', 'base64', 'form', 'iron', 'none'
};


exports.Definitions = internals.Definitions = function (options) {

    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
    Joi.assert(this.settings, internals.schema, 'Invalid state definition defaults');

    this.cookies = {};
    this.names = [];
};


internals.Definitions.prototype.add = function (name, options) {

    Hoek.assert(name && typeof name === 'string', 'Invalid name');
    Hoek.assert(!this.cookies[name], 'State already defined:', name);

    const settings = Hoek.applyToDefaults(this.settings, options || {}, { nullOverride: true });
    Joi.assert(settings, internals.schema, 'Invalid state definition: ' + name);

    this.cookies[name] = settings;
    this.names.push(name);
};


internals.empty = new internals.Definitions();


// Header format

//                      1: name                2: quoted  3: value
internals.parseRx = /\s*([^=\s]*)\s*=\s*(?:(?:"([^\"]*)")|([^\;]*))(?:(?:;\s*)|$)/g;

internals.validateRx = {
    nameRx: {
        strict: /^[^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+$/,
        loose: /^[^=\s]*$/
    },
    valueRx: {
        strict: /^[^\x00-\x20\"\,\;\\\x7F]*$/,
        loose: /^(?:"([^\"]*)")|(?:[^\;]*)$/
    },
    domainRx: /^\.?[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d]))(?:\.[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d])))*$/,
    domainLabelLenRx: /^\.?[a-z\d\-]{1,63}(?:\.[a-z\d\-]{1,63})*$/,
    pathRx: /^\/[^\x00-\x1F\;]*$/
};

//                      1: name         2: value
internals.pairsRx = /\s*([^=\s]*)\s*=\s*([^\;]*)(?:(?:;\s*)|$)/g;


internals.Definitions.prototype.parse = async function (cookies) {

    const state = {};
    const names = [];
    const verify = cookies.replace(internals.parseRx, ($0, $1, $2, $3) => {

        const name = $1;
        const value = $2 || $3 || '';

        if (state[name]) {
            if (!Array.isArray(state[name])) {
                state[name] = [state[name]];
            }

            state[name].push(value);
        }
        else {
            state[name] = value;
            names.push(name);
        }

        return '';
    });

    // Validate cookie header syntax

    const failed = [];                                                // All errors

    if (verify !== '') {
        if (!this.settings.ignoreErrors) {
            throw Boom.badRequest('Invalid cookie header');
        }

        failed.push({ settings: this.settings, reason: `Header contains unexpected syntax: ${verify}` });
    }

    // Collect errors

    const errored = [];                                               // Unignored errors
    const record = (reason, name, value, definition) => {

        const details = {
            name,
            value,
            settings: definition,
            reason: typeof reason === 'string' ? reason : reason.message
        };

        failed.push(details);
        if (!definition.ignoreErrors) {
            errored.push(details);
        }
    };

    // Parse cookies

    const parsed = {};
    for (let i = 0; i < names.length; ++i) {
        const name = names[i];
        const value = state[name];
        const definition = this.cookies[name] || this.settings;

        // Validate cookie

        if (definition.strictHeader) {
            const reason = internals.validate(name, state);
            if (reason) {
                record(reason, name, value, definition);
                continue;
            }
        }

        // Check cookie format

        if (definition.encoding === 'none') {
            parsed[name] = value;
            continue;
        }

        // Single value

        if (!Array.isArray(value)) {
            try {
                const unsigned = await internals.unsign(name, value, definition);
                const result = await internals.decode(unsigned, definition);
                parsed[name] = result;
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                record(err, name, value, definition);
            }

            continue;
        }

        // Array

        const arrayResult = [];
        for (let j = 0; j < value.length; ++j) {
            const arrayValue = value[j];

            try {
                const unsigned = await internals.unsign(name, arrayValue, definition);
                const result = await internals.decode(unsigned, definition);
                arrayResult.push(result);
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                record(err, name, value, definition);
            }
        }

        parsed[name] = arrayResult;
    }

    if (errored.length) {
        const error = Boom.badRequest('Invalid cookie value', errored);
        error.states = parsed;
        error.failed = failed;
        throw error;
    }

    return { states: parsed, failed };
};


internals.validate = function (name, state) {

    if (!name.match(internals.validateRx.nameRx.strict)) {
        return 'Invalid cookie name';
    }

    const values = [].concat(state[name]);
    for (let i = 0; i < values.length; ++i) {
        if (!values[i].match(internals.validateRx.valueRx.strict)) {
            return 'Invalid cookie value';
        }
    }

    return null;
};


internals.macPrefix = 'hapi.signed.cookie.1';


internals.unsign = async function (name, value, definition) {

    if (!definition.sign) {
        return value;
    }

    const pos = value.lastIndexOf('.');
    if (pos === -1) {
        throw Boom.badRequest('Missing signature separator');
    }

    const unsigned = value.slice(0, pos);
    const sig = value.slice(pos + 1);

    if (!sig) {
        throw Boom.badRequest('Missing signature');
    }

    const sigParts = sig.split('*');
    if (sigParts.length !== 2) {
        throw Boom.badRequest('Invalid signature format');
    }

    const hmacSalt = sigParts[0];
    const hmac = sigParts[1];

    const macOptions = Hoek.clone(definition.sign.integrity || Iron.defaults.integrity);
    macOptions.salt = hmacSalt;
    const mac = await Iron.hmacWithPassword(definition.sign.password, macOptions, [internals.macPrefix, name, unsigned].join('\n'));
    if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw Boom.badRequest('Invalid hmac value');
    }

    return unsigned;
};


internals.decode = async function (value, definition) {

    if (!value &&
        definition.encoding === 'form') {

        return {};
    }

    Hoek.assert(typeof value === 'string', 'Invalid string');

    // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'

    if (definition.encoding === 'iron') {
        return await Iron.unseal(value, definition.password, definition.iron || Iron.defaults);
    }

    if (definition.encoding === 'base64json') {
        const decoded = (Buffer.from(value, 'base64')).toString('binary');
        try {
            return Bourne.parse(decoded);
        }
        catch (err) {
            throw Boom.badRequest('Invalid JSON payload');
        }
    }

    if (definition.encoding === 'base64') {
        return (Buffer.from(value, 'base64')).toString('binary');
    }

    // encoding: 'form'

    return Querystring.parse(value);
};


internals.Definitions.prototype.format = async function (cookies) {

    if (!cookies ||
        (Array.isArray(cookies) && !cookies.length)) {

        return [];
    }

    if (!Array.isArray(cookies)) {
        cookies = [cookies];
    }

    const header = [];
    for (let i = 0; i < cookies.length; ++i) {
        const cookie = cookies[i];

        // Apply definition to local configuration

        const base = this.cookies[cookie.name] || this.settings;
        const definition = cookie.options ? Hoek.applyToDefaults(base, cookie.options, { nullOverride: true }) : base;

        // Validate name

        const nameRx = (definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose);
        if (!nameRx.test(cookie.name)) {
            throw Boom.badImplementation('Invalid cookie name: ' + cookie.name);
        }

        // Prepare value (encode, sign)

        const value = await exports.prepareValue(cookie.name, cookie.value, definition);

        // Validate prepared value

        const valueRx = (definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose);
        if (value &&
            (typeof value !== 'string' || !value.match(valueRx))) {

            throw Boom.badImplementation('Invalid cookie value: ' + cookie.value);
        }

        // Construct cookie

        let segment = cookie.name + '=' + (value || '');

        if (definition.ttl !== null &&
            definition.ttl !== undefined) {            // Can be zero

            const expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);
            segment = segment + '; Max-Age=' + Math.floor(definition.ttl / 1000) + '; Expires=' + expires.toUTCString();
        }

        if (definition.isSecure) {
            segment = segment + '; Secure';
        }

        if (definition.isHttpOnly) {
            segment = segment + '; HttpOnly';
        }

        if (definition.isSameSite) {
            segment = segment + `; SameSite=${definition.isSameSite}`;
        }

        if (definition.domain) {
            const domain = definition.domain.toLowerCase();
            if (!domain.match(internals.validateRx.domainLabelLenRx)) {
                throw Boom.badImplementation('Cookie domain too long: ' + definition.domain);
            }

            if (!domain.match(internals.validateRx.domainRx)) {
                throw Boom.badImplementation('Invalid cookie domain: ' + definition.domain);
            }

            segment = segment + '; Domain=' + domain;
        }

        if (definition.path) {
            if (!definition.path.match(internals.validateRx.pathRx)) {
                throw Boom.badImplementation('Invalid cookie path: ' + definition.path);
            }

            segment = segment + '; Path=' + definition.path;
        }

        header.push(segment);
    }

    return header;
};


exports.prepareValue = async function (name, value, options) {

    Hoek.assert(options && typeof options === 'object', 'Missing or invalid options');

    try {
        const encoded = await internals.encode(value, options);
        const signed = await internals.sign(name, encoded, options.sign);
        return signed;
    }
    catch (err) {
        throw Boom.badImplementation('Failed to encode cookie (' + name + ') value: ' + err.message);
    }
};


internals.encode = function (value, options) {

    // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'

    if (value === undefined ||
        options.encoding === 'none') {

        return value;
    }

    if (options.encoding === 'iron') {
        return Iron.seal(value, options.password, options.iron || Iron.defaults);
    }

    if (options.encoding === 'base64') {
        return (Buffer.from(value, 'binary')).toString('base64');
    }

    if (options.encoding === 'base64json') {
        const stringified = JSON.stringify(value);
        return (Buffer.from(stringified, 'binary')).toString('base64');
    }

    // encoding: 'form'

    return Querystring.stringify(value);
};


internals.sign = async function (name, value, options) {

    if (value === undefined ||
        !options) {

        return value;
    }

    const mac = await Iron.hmacWithPassword(options.password, options.integrity || Iron.defaults.integrity, [internals.macPrefix, name, value].join('\n'));
    const signed = value + '.' + mac.salt + '*' + mac.digest;
    return signed;
};


internals.Definitions.prototype.passThrough = function (header, fallback) {

    if (!this.names.length) {
        return header;
    }

    const exclude = [];
    for (let i = 0; i < this.names.length; ++i) {
        const name = this.names[i];
        const definition = this.cookies[name];
        const passCookie = definition.passThrough !== undefined ? definition.passThrough : fallback;
        if (!passCookie) {
            exclude.push(name);
        }
    }

    return exports.exclude(header, exclude);
};


exports.exclude = function (cookies, excludes) {

    let result = '';
    const verify = cookies.replace(internals.pairsRx, ($0, $1, $2) => {

        if (excludes.indexOf($1) === -1) {
            result = result + (result ? ';' : '') + $1 + '=' + $2;
        }

        return '';
    });

    return verify === '' ? result : Boom.badRequest('Invalid cookie header');
};


/***/ }),

/***/ "./node_modules/@hapi/subtext/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/subtext/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Fs = __webpack_require__(/*! fs */ "fs");
const Os = __webpack_require__(/*! os */ "os");
const Querystring = __webpack_require__(/*! querystring */ "querystring");
const Stream = __webpack_require__(/*! stream */ "stream");
const Zlib = __webpack_require__(/*! zlib */ "zlib");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Content = __webpack_require__(/*! @hapi/content */ "./node_modules/@hapi/content/lib/index.js");
const File = __webpack_require__(/*! @hapi/file */ "./node_modules/@hapi/file/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Pez = __webpack_require__(/*! @hapi/pez */ "./node_modules/@hapi/pez/lib/index.js");
const Wreck = __webpack_require__(/*! @hapi/wreck */ "./node_modules/@hapi/wreck/lib/index.js");


const internals = {
    decoders: {
        gzip: (options) => Zlib.createGunzip(options),
        deflate: (options) => Zlib.createInflate(options)
    }
};


exports.parse = async function (req, tap, options) {

    Hoek.assert(options, 'Missing options');
    Hoek.assert(options.parse !== undefined, 'Missing parse option setting');
    Hoek.assert(options.output !== undefined, 'Missing output option setting');

    // Content size

    const contentLength = req.headers['content-length'];
    if (options.maxBytes !== undefined &&
        contentLength &&
        parseInt(contentLength, 10) > options.maxBytes) {

        throw Boom.entityTooLarge('Payload content length greater than maximum allowed: ' + options.maxBytes);
    }

    // Content type

    const contentType = Content.type(options.override || req.headers['content-type'] || options.defaultContentType || 'application/octet-stream');
    try {
        if (options.allow &&
            options.allow.indexOf(contentType.mime) === -1) {

            throw Boom.unsupportedMediaType();
        }

        const parsed = { mime: contentType.mime };

        // Parse: true

        if (options.parse === true) {
            parsed.payload = await internals.parse(req, tap, options, contentType);
            return parsed;
        }

        // Parse: false, 'gunzip'

        parsed.payload = await internals.raw(req, tap, options);
        return parsed;
    }
    catch (err) {
        err.mime = contentType.mime;
        throw err;
    }
};


internals.parse = async function (req, tap, options, contentType) {

    const output = options.output;        // Output: 'data', 'stream', 'file'
    let source = internals.decoder(req, options);

    // Tap request

    if (tap) {
        source = internals.pipe(source, tap);
    }

    // Multipart

    if (contentType.mime === 'multipart/form-data') {
        if (options.multipart === false) {                            // Defaults to true
            throw Boom.unsupportedMediaType();
        }

        return await internals.multipart(req, options, source, contentType);
    }

    // Output: 'stream'

    if (output === 'stream') {
        return source;
    }

    // Output: 'file'

    if (output === 'file') {
        const file = await internals.writeFile(req, options, source);
        return file.item;
    }

    // Output: 'data'

    const payload = await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
    return internals.object(options, payload, contentType.mime);
};


internals.decoder = function (source, options) {

    const contentEncoding = source.headers['content-encoding'];
    const decoder = (options.decoders || internals.decoders)[contentEncoding];
    if (!decoder) {
        return source;
    }

    const decoderOptions = (options.compression && options.compression[contentEncoding]) || null;
    const stream = decoder(decoderOptions);

    const orig = stream.emit;
    stream.emit = (event, ...args) => {

        if (event === 'error') {
            args = [Boom.badRequest('Invalid compressed payload', args[0])];
        }

        return orig.call(stream, event, ...args);
    };

    return internals.pipe(source, stream);
};


internals.raw = async function (req, tap, options) {

    const output = options.output;      // Output: 'data', 'stream', 'file'
    let source = req;

    // Content-encoding (optional)

    if (options.parse === 'gunzip') {
        source = internals.decoder(source, options);
    }

    // Setup source

    if (tap) {
        source = internals.pipe(source, tap);
    }

    // Output: 'stream'

    if (output === 'stream') {
        return source;
    }

    // Output: 'file'

    if (output === 'file') {
        const file = await internals.writeFile(req, options, source);
        return file.item;
    }

    // Output: 'data'

    return await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
};


internals.object = function (options, payload, mime) {

    // Binary

    if (mime === 'application/octet-stream') {
        return (payload.length ? payload : null);
    }

    // Text

    if (mime.match(/^text\/.+$/)) {
        return payload.toString('utf8');
    }

    // JSON

    if (/^application\/(?:.+\+)?json$/.test(mime)) {
        if (!payload.length) {
            return null;
        }

        try {
            return Bourne.parse(payload.toString('utf8'), { protoAction: options.protoAction });
        }
        catch (err) {
            const error = Boom.badRequest('Invalid request payload JSON format', err);
            error.raw = payload;
            throw error;
        }
    }

    // Form-encoded

    if (mime === 'application/x-www-form-urlencoded') {
        const parse = (options.querystring || Querystring.parse);
        return (payload.length ? parse(payload.toString('utf8')) : {});
    }

    const error = Boom.unsupportedMediaType();
    error.raw = payload;
    throw error;
};


internals.multipart = function (req, options, source, contentType) {

    return new Promise((resolve, reject) => {

        // Set stream timeout

        const clientTimeout = options.timeout;
        const clientTimeoutId = (clientTimeout ? setTimeout(() => reject(Boom.clientTimeout()), clientTimeout) : null);

        // Create parser

        const dispenserOptions = Hoek.applyToDefaults(contentType, { maxBytes: options.maxBytes });
        const dispenser = new Pez.Dispenser(dispenserOptions);

        const onError = (err) => reject(Boom.badRequest('Invalid multipart payload format', err));
        dispenser.once('error', onError);

        const data = {};
        const pendingFiles = [];

        const set = (name, value) => {

            if (!data.hasOwnProperty(name)) {
                data[name] = value;
            }
            else if (Array.isArray(data[name])) {
                data[name].push(value);
            }
            else {
                data[name] = [data[name], value];
            }
        };

        const finalize = async () => {

            // Clean up

            clearTimeout(clientTimeoutId);
            dispenser.removeListener('error', onError);
            dispenser.removeListener('part', onPart);
            dispenser.removeListener('field', onField);
            dispenser.removeListener('close', onClose);

            // Wait for files

            try {
                const files = await Promise.all(pendingFiles);
                for (const { item, name } of files) {
                    set(name, item);
                }
            }
            catch (err) {
                reject(err);
                return;
            }

            resolve(data);
        };

        const output = (options.multipart ? options.multipart.output : options.output);

        const onPart = (part) => {

            if (output === 'file') {                                                                // Output: 'file'
                pendingFiles.push(internals.writeFile(req, options, part));
            }
            else {
                internals.part(part, output, set, options);                                         // Output: 'data' / 'stream'
            }
        };

        dispenser.on('part', onPart);

        const onField = (name, value) => set(name, value);
        dispenser.on('field', onField);

        const onClose = () => finalize();
        dispenser.once('close', onClose);

        source.pipe(dispenser);
    });
};


internals.writeFile = function (req, options, stream) {

    const promise = new Promise((resolve, reject) => {

        const path = File.uniqueFilename(options.uploads || Os.tmpdir());
        const file = Fs.createWriteStream(path, { flags: 'wx' });
        const counter = new internals.Counter(options);

        const finalize = (err) => {

            req.removeListener('aborted', onAbort);
            file.removeListener('close', finalize);
            file.removeListener('error', finalize);

            if (err) {
                stream.unpipe(counter);
                counter.unpipe(file);

                file.destroy();
                Fs.unlink(path, (/* fsErr */) => reject(err));      // Ignore unlink errors
                return;
            }

            const result = {
                item: {
                    path,
                    bytes: counter.bytes
                }
            };

            if (stream.name) {                                      // Multipart
                result.name = stream.name;
                result.item.filename = stream.filename;
                result.item.headers = stream.headers;
            }

            resolve(result);
        };

        file.once('close', finalize);
        file.once('error', finalize);

        const onAbort = () => finalize(Boom.badRequest('Client connection aborted'));
        req.once('aborted', onAbort);

        internals.pipe(stream, counter);
        internals.pipe(counter, file);
    });

    promise.catch(Hoek.ignore);     // Prevent triggering node's PromiseRejectionHandledWarning
    return promise;
};


internals.part = async function (part, output, set, options) {

    const payload = await Wreck.read(part);             // Error handled by dispenser.once('error')

    if (output === 'stream') {                          // Output: 'stream'
        const item = Wreck.toReadableStream(payload);
        item.hapi = {
            filename: part.filename,
            headers: part.headers
        };

        return set(part.name, item);
    }

    const ct = part.headers['content-type'] || '';      // Output: 'data'
    const mime = ct.split(';')[0].trim().toLowerCase();
    const annotate = (value) => set(part.name, output === 'annotated' ? { filename: part.filename, headers: part.headers, payload: value } : value);

    if (!mime) {
        return annotate(payload);
    }

    if (!payload.length) {
        return annotate({});
    }

    try {
        const object = internals.object(options, payload, mime);
        annotate(object);
    }
    catch (err) {
        annotate(payload);
    }
};


internals.pipe = function (from, to) {

    from.once('error', (err) => {

        from.unpipe(to);
        to.emit('error', err);
    });

    return from.pipe(to);
};


internals.Counter = class extends Stream.Transform {

    constructor(options) {

        super();
        this.bytes = 0;
        this._maxBytes = options.maxBytes;
    }

    _transform(chunk, encoding, next) {

        this.bytes = this.bytes + chunk.length;

        if (this._maxBytes !== undefined &&
            this.bytes > this._maxBytes) {

            return next(Boom.entityTooLarge('Payload content length greater than maximum allowed: ' + this._maxBytes));
        }

        return next(null, chunk);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/teamwork/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/teamwork/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = internals.Team = class {

    constructor(options) {

        this._init(options);
    }

    _init(options = {}) {

        this.work = new Promise((resolve, reject) => {

            this._resolve = resolve;
            this._reject = reject;
        });

        const meetings = options.meetings || 1;
        this._meetings = meetings;
        this._count = meetings;
        this._notes = [];
    }

    attend(note) {

        if (note instanceof Error) {
            return this._reject(note);
        }

        this._notes.push(note);

        if (--this._count) {
            return;
        }

        return this._resolve(this._meetings === 1 ? this._notes[0] : this._notes);
    }

    async regroup(options) {

        await this.work;

        this._init(options);
    }
};


Object.defineProperties(internals.Team, {
    __esModule: {
        value: true
    },
    default: {
        value: internals.Team
    },
    Teamwork: {
        value: internals.Team
    }
});


/***/ }),

/***/ "./node_modules/@hapi/topo/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/topo/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = class Topo {

    constructor() {

        this._items = [];
        this.nodes = [];
    }

    add(nodes, options) {

        options = options || {};

        // Validate rules

        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || '?';
        const sort = options.sort || 0;                   // Used for merging only

        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Assert(!before.includes('?'), 'Item cannot come before unassociated items');
        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Assert(!after.includes('?'), 'Item cannot come after unassociated items');

        if (!Array.isArray(nodes)) {
            nodes = [nodes];
        }

        for (const node of nodes) {
            const item = {
                seq: this._items.length,
                sort,
                before,
                after,
                group,
                node
            };

            this._items.push(item);
        }

        // Insert event

        const valid = this._sort();
        Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');

        return this.nodes;
    }

    merge(others) {

        if (!Array.isArray(others)) {
            others = [others];
        }

        for (const other of others) {
            if (other) {
                for (const item of other._items) {
                    this._items.push(Object.assign({}, item));      // Shallow cloned
                }
            }
        }

        // Sort items

        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
            this._items[i].seq = i;
        }

        const valid = this._sort();
        Assert(valid, 'merge created a dependencies error');

        return this.nodes;
    }

    _sort() {

        // Construct graph

        const graph = {};
        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives
        const groups = Object.create(null);

        for (const item of this._items) {
            const seq = item.seq;                           // Unique across all items
            const group = item.group;

            // Determine Groups

            groups[group] = groups[group] || [];
            groups[group].push(seq);

            // Build intermediary graph using 'before'

            graph[seq] = item.before;

            // Build second intermediary graph with 'after'

            for (const after of item.after) {
                graphAfters[after] = graphAfters[after] || [];
                graphAfters[after].push(seq);
            }
        }

        // Expand intermediary graph

        for (const node in graph) {
            const expandedGroups = [];

            for (const graphNodeItem in graph[node]) {
                const group = graph[node][graphNodeItem];
                groups[group] = groups[group] || [];
                expandedGroups.push(...groups[group]);
            }

            graph[node] = expandedGroups;
        }

        // Merge intermediary graph using graphAfters into final graph

        for (const group in graphAfters) {
            if (groups[group]) {
                for (const node of groups[group]) {
                    graph[node].push(...graphAfters[group]);
                }
            }
        }

        // Compile ancestors

        const ancestors = {};
        for (const node in graph) {
            const children = graph[node];
            for (const child of children) {
                ancestors[child] = ancestors[child] || [];
                ancestors[child].push(node);
            }
        }

        // Topo sort

        const visited = {};
        const sorted = [];

        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order
            let next = i;

            if (ancestors[i]) {
                next = null;
                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values
                    if (visited[j] === true) {
                        continue;
                    }

                    if (!ancestors[j]) {
                        ancestors[j] = [];
                    }

                    const shouldSeeCount = ancestors[j].length;
                    let seenCount = 0;
                    for (let k = 0; k < shouldSeeCount; ++k) {
                        if (visited[ancestors[j][k]]) {
                            ++seenCount;
                        }
                    }

                    if (seenCount === shouldSeeCount) {
                        next = j;
                        break;
                    }
                }
            }

            if (next !== null) {
                visited[next] = true;
                sorted.push(next);
            }
        }

        if (sorted.length !== this._items.length) {
            return false;
        }

        const seqIndex = {};
        for (const item of this._items) {
            seqIndex[item.seq] = item;
        }

        this._items = [];
        this.nodes = [];

        for (const value of sorted) {
            const sortedItem = seqIndex[value];
            this.nodes.push(sortedItem.node);
            this._items.push(sortedItem);
        }

        return true;
    }
};


internals.mergeSort = (a, b) => {

    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);
};


/***/ }),

/***/ "./node_modules/@hapi/vise/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/vise/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports = module.exports = internals.Vise = function (chunks) {

    this.length = 0;
    this._chunks = [];
    this._offset = 0;

    if (chunks) {
        chunks = [].concat(chunks);
        for (let i = 0; i < chunks.length; ++i) {
            this.push(chunks[i]);
        }
    }
};


internals.Vise.prototype.push = function (chunk) {

    Hoek.assert(Buffer.isBuffer(chunk), 'Chunk must be a buffer');

    const item = {
        data: chunk,
        length: chunk.length,
        offset: this.length + this._offset,
        index: this._chunks.length
    };

    this._chunks.push(item);
    this.length += chunk.length;
};


internals.Vise.prototype.shift = function (length) {

    if (!length) {
        return [];
    }

    const prevOffset = this._offset;
    const item = this._chunkAt(length);

    let dropTo = this._chunks.length;
    this._offset = 0;

    if (item) {
        dropTo = item.chunk.index;
        this._offset = item.offset;
    }

    // Drop lower chunks

    const chunks = [];
    for (let i = 0; i < dropTo; ++i) {
        const chunk = this._chunks.shift();
        if (i === 0 &&
            prevOffset) {

            chunks.push(chunk.data.slice(prevOffset));
        }
        else {
            chunks.push(chunk.data);
        }
    }

    if (this._offset) {
        chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));
    }

    // Recalculate existing chunks

    this.length = 0;
    for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        chunk.offset = this.length,
        chunk.index = i;

        this.length += chunk.length;
    }

    this.length -= this._offset;

    return chunks;
};


internals.Vise.prototype.at = internals.Vise.prototype.readUInt8 = function (pos) {

    const item = this._chunkAt(pos);
    return item ? item.chunk.data[item.offset] : undefined;
};


internals.Vise.prototype._chunkAt = function (pos) {

    if (pos < 0) {
        return null;
    }

    pos = pos + this._offset;

    for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        const offset = pos - chunk.offset;
        if (offset < chunk.length) {
            return { chunk, offset };
        }
    }

    return null;
};


internals.Vise.prototype.chunks = function () {

    const chunks = [];

    for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        if (i === 0 &&
            this._offset) {

            chunks.push(chunk.data.slice(this._offset));
        }
        else {
            chunks.push(chunk.data);
        }
    }

    return chunks;
};


internals.Vise.prototype.startsWith = function (value, pos, length) {

    pos = pos || 0;

    length = length ? Math.min(value.length, length) : value.length;
    if (pos + length > this.length) {                                   // Not enough length to fit value
        return false;
    }

    const start = this._chunkAt(pos);
    if (!start) {
        return false;
    }

    let j = start.chunk.index;
    for (let i = 0; j < this._chunks.length && i < length; ++j) {
        const chunk = this._chunks[j];

        let k = (j === start.chunk.index ? start.offset : 0);
        for (; k < chunk.length && i < length; ++k, ++i) {
            if (chunk.data[k] !== value[i]) {
                return false;
            }
        }
    }

    return true;
};


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Events = __webpack_require__(/*! events */ "events");
const Http = __webpack_require__(/*! http */ "http");
const Https = __webpack_require__(/*! https */ "https");
const Stream = __webpack_require__(/*! stream */ "stream");
const Url = __webpack_require__(/*! url */ "url");
const Zlib = __webpack_require__(/*! zlib */ "zlib");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Payload = __webpack_require__(/*! ./payload */ "./node_modules/@hapi/wreck/lib/payload.js");
const Recorder = __webpack_require__(/*! ./recorder */ "./node_modules/@hapi/wreck/lib/recorder.js");
const Tap = __webpack_require__(/*! ./tap */ "./node_modules/@hapi/wreck/lib/tap.js");


const internals = {
    jsonRegex: /^application\/([a-z0-9.]*[+-]json|json)$/,
    shallowOptions: ['agent', 'agents', 'beforeRedirect', 'downstreamRes', 'payload', 'redirected']
};


// New instance is exported as module.exports

internals.Client = function (options = {}) {

    Hoek.assert(!options.agents || (options.agents.https && options.agents.http && options.agents.httpsAllowUnauthorized), 'Option agents must include "http", "https", and "httpsAllowUnauthorized"');

    this._defaults = Hoek.clone(options, { shallow: internals.shallowOptions });

    this.agents = this._defaults.agents || {
        https: new Https.Agent({ maxSockets: Infinity }),
        http: new Http.Agent({ maxSockets: Infinity }),
        httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })
    };

    if (!options.events) {
        return;
    }

    this.events = new Events.EventEmitter();
    this._emit = function (...args) {

        this.events.emit(...args);
    };
};


internals.Client.prototype.defaults = function (options) {

    Hoek.assert(options && (typeof options === 'object'), 'options must be provided to defaults');

    options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
    return new internals.Client(options);
};


// baseUrl needs to end in a trailing / if it contains paths that need to be preserved
internals.resolveUrl = function (baseUrl, path) {

    if (!path) {
        return baseUrl;
    }

    // Will default to path if it's not a relative URL
    const url = new Url.URL(path, baseUrl);
    return Url.format(url);
};


internals.Client.prototype.request = function (method, url, options = {}) {

    try {
        options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });

        Hoek.assert(options.payload === undefined || typeof options.payload === 'string' || typeof options.payload === 'object', 'options.payload must be a string, a Buffer, a Stream, or an Object');
        Hoek.assert((options.agent === undefined || options.agent === null) || (typeof options.rejectUnauthorized !== 'boolean'), 'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');
        Hoek.assert(options.beforeRedirect === undefined || options.beforeRedirect === null || typeof options.beforeRedirect === 'function', 'options.beforeRedirect must be a function');
        Hoek.assert(options.redirected === undefined || options.redirected === null || typeof options.redirected === 'function', 'options.redirected must be a function');
        Hoek.assert(options.gunzip === undefined || typeof options.gunzip === 'boolean' || options.gunzip === 'force', 'options.gunzip must be a boolean or "force"');
    }
    catch (err) {
        return Promise.reject(err);
    }

    options.beforeRedirect = options.beforeRedirect || ((redirectMethod, statusCode, location, resHeaders, redirectOptions, next) => next());

    if (options.baseUrl) {
        url = internals.resolveUrl(options.baseUrl, url);
        delete options.baseUrl;
    }

    const relay = {};
    const req = this._request(method, url, options, relay);
    const promise = new Promise((resolve, reject) => {

        relay.callback = (err, res) => {

            if (err) {
                reject(err);
                return;
            }

            resolve(res);
            return;
        };
    });

    promise.req = req;
    return promise;
};


internals.Client.prototype._request = function (method, url, options, relay, _trace) {

    const uri = {};
    if (options.socketPath) {
        uri.socketPath = options.socketPath;

        const parsedUri = new Url.URL(url, `unix://${options.socketPath}`);
        internals.applyUrlToOptions(uri, {
            // The host must be empty according to https://tools.ietf.org/html/rfc2616#section-14.23
            host: '',
            protocol: 'http:',
            hash: parsedUri.hash,
            search: parsedUri.search,
            searchParams: parsedUri.searchParams,
            pathname: parsedUri.pathname,
            href: parsedUri.href
        });
    }
    else {
        uri.setHost = false;
        const parsedUri = new Url.URL(url);
        internals.applyUrlToOptions(uri, parsedUri);
    }

    uri.method = method.toUpperCase();
    uri.headers = options.headers || {};

    const hostHeader = internals.findHeader('host', uri.headers);

    if (!hostHeader) {
        uri.headers.host = uri.host;
    }

    const hasContentLength = internals.findHeader('content-length', uri.headers) !== undefined;

    if (options.payload && typeof options.payload === 'object' && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {
        options.payload = JSON.stringify(options.payload);
        if (!internals.findHeader('content-type', uri.headers)) {
            uri.headers['content-type'] = 'application/json';
        }
    }

    if (options.gunzip &&
        internals.findHeader('accept-encoding', uri.headers) === undefined) {

        uri.headers['accept-encoding'] = 'gzip';
    }

    const payloadSupported = (uri.method !== 'GET' && uri.method !== 'HEAD' && options.payload !== null && options.payload !== undefined);
    if (payloadSupported &&
        (typeof options.payload === 'string' || Buffer.isBuffer(options.payload)) &&
        (!hasContentLength)) {

        uri.headers = Hoek.clone(uri.headers);
        uri.headers['content-length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);
    }

    let redirects = (options.hasOwnProperty('redirects') ? options.redirects : false);      // Needed to allow 0 as valid value when passed recursively

    _trace = (_trace || []);
    _trace.push({ method: uri.method, url });

    const client = (uri.protocol === 'https:' ? Https : Http);

    if (options.rejectUnauthorized !== undefined && uri.protocol === 'https:') {
        uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
    }
    else if (options.agent || options.agent === false) {
        uri.agent = options.agent;
    }
    else {
        uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;
    }

    if (options.secureProtocol !== undefined) {
        uri.secureProtocol = options.secureProtocol;
    }

    if (options.ciphers !== undefined) {
        uri.ciphers = options.ciphers;
    }

    if (this._emit) {
        this._emit('preRequest', uri, options);
    }

    const start = Date.now();
    const req = client.request(uri);

    if (this._emit) {
        this._emit('request', req);
    }

    let shadow = null;                                                                      // A copy of the streamed request payload when redirects are enabled
    let timeoutId;

    const onError = (err) => {

        err.trace = _trace;
        return finishOnce(Boom.badGateway('Client request error', err));
    };

    req.once('error', onError);

    const onResponse = (res) => {

        // Pass-through response

        const statusCode = res.statusCode;
        const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);

        if (redirects === false ||
            !redirectMethod) {

            return finishOnce(null, res);
        }

        // Redirection

        res.destroy();

        if (redirects === 0) {
            return finishOnce(Boom.badGateway('Maximum redirections reached', _trace));
        }

        let location = res.headers.location;
        if (!location) {
            return finishOnce(Boom.badGateway('Received redirection without location', _trace));
        }

        if (!/^https?:/i.test(location)) {
            location = Url.resolve(uri.href, location);
        }

        const redirectOptions = Hoek.clone(options, { shallow: internals.shallowOptions });
        redirectOptions.payload = shadow || options.payload;                                    // shadow must be ready at this point if set
        redirectOptions.redirects = --redirects;

        return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, () => {

            const redirectReq = this._request(redirectMethod, location, redirectOptions, { callback: finishOnce }, _trace);

            if (options.redirected) {
                options.redirected(statusCode, location, redirectReq);
            }
        });
    };

    // Register handlers

    const finish = (err, res) => {

        if (err) {
            req.abort();
        }

        req.abort = _abort;                             // Restore original function to release memory
        req.removeListener('response', onResponse);
        req.removeListener('error', onError);
        req.on('error', Hoek.ignore);

        clearTimeout(timeoutId);

        if (this._emit) {
            this._emit('response', err, { req, res, start, uri });
        }

        return relay.callback(err, res);
    };

    const finishOnce = Hoek.once(finish);

    req.once('response', onResponse);

    if (options.timeout) {
        timeoutId = setTimeout(() => {

            return finishOnce(Boom.gatewayTimeout('Client request timeout'));
        }, options.timeout);
        delete options.timeout;
    }

    // Custom abort method to detect early aborts

    const _abort = req.abort;
    let aborted = false;
    req.abort = () => {

        if (!aborted && !req.res && !req.socket) {
            process.nextTick(() => {

                // Fake an ECONNRESET error

                const error = new Error('socket hang up');
                error.code = 'ECONNRESET';
                finishOnce(error);
            });
        }

        aborted = true;
        return _abort.call(req);
    };

    // Write payload

    if (payloadSupported) {
        if (options.payload instanceof Stream) {
            let stream = options.payload;

            if (redirects) {
                const collector = new Tap();
                collector.once('finish', () => {

                    shadow = collector.collect();
                });

                stream = options.payload.pipe(collector);
            }

            internals.deferPipeUntilSocketConnects(req, stream);
            return req;
        }

        req.write(options.payload);
    }

    // Finalize request

    req.end();
    return req;
};


internals.deferPipeUntilSocketConnects = function (req, stream) {

    const onSocket = (socket) => {

        if (!socket.connecting) {
            return onSocketConnect();
        }

        socket.once('connect', onSocketConnect);
    };

    const onSocketConnect = () => {

        stream.pipe(req);
        stream.removeListener('error', onStreamError);
    };

    const onStreamError = (err) => {

        req.emit('error', err);
    };

    req.once('socket', onSocket);
    stream.on('error', onStreamError);
};


internals.redirectMethod = function (code, method, options) {

    switch (code) {
        case 301:
        case 302:
            return options.redirectMethod || method;

        case 303:
            if (options.redirect303) {
                return 'GET';
            }

            break;

        case 307:
        case 308:
            return method;
    }

    return null;
};


internals.Client.prototype.read = function (res, options = {}) {

    return new Promise((resolve, reject) => {

        this._read(res, options, (err, payload) => {

            if (err) {
                reject(err);
                return;
            }

            resolve(payload);
            return;
        });
    });
};


internals.Client.prototype._read = function (res, options, callback) {

    options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });

    // Finish once

    let clientTimeoutId = null;

    const finish = (err, buffer) => {

        clearTimeout(clientTimeoutId);
        reader.removeListener('error', onReaderError);
        reader.removeListener('finish', onReaderFinish);
        res.removeListener('error', onResError);
        res.removeListener('close', onResAborted);
        res.removeListener('aborted', onResAborted);
        res.on('error', Hoek.ignore);

        if (err) {
            return callback(err);
        }

        if (!options.json) {
            return callback(null, buffer);
        }

        // Parse JSON

        if (options.json === 'force') {
            return internals.tryParseBuffer(buffer, callback);
        }

        // mode is "smart", "strict" or true

        const contentType = (res.headers && internals.findHeader('content-type', res.headers)) || '';
        const mime = contentType.split(';')[0].trim().toLowerCase();

        if (!internals.jsonRegex.test(mime)) {
            if (options.json === 'strict') {
                return callback(Boom.notAcceptable('The content-type is not JSON compatible'));
            }

            return callback(null, buffer);
        }

        return internals.tryParseBuffer(buffer, callback);
    };

    const finishOnce = Hoek.once(finish);

    const clientTimeout = options.timeout;
    if (clientTimeout &&
        clientTimeout > 0) {

        clientTimeoutId = setTimeout(() => {

            finishOnce(Boom.clientTimeout());
        }, clientTimeout);
    }

    // Hander errors

    const onResError = (err) => {

        return finishOnce(err.isBoom ? err : Boom.internal('Payload stream error', err));
    };

    const onResAborted = () => {

        // Workaround https://github.com/nodejs/node/pull/20611
        // This is covered in node 10
        /* $lab:coverage:off$ */
        if (res.complete) {
            return;
        }
        /* $lab:coverage:on$ */

        return finishOnce(Boom.internal('Payload stream closed prematurely'));
    };

    res.once('error', onResError);
    res.once('close', onResAborted);
    res.once('aborted', onResAborted);

    // Read payload

    const reader = new Recorder({ maxBytes: options.maxBytes });

    const onReaderError = (err) => {

        if (res.destroy) {                          // GZip stream has no destroy() method
            res.destroy();
        }

        return finishOnce(err);
    };

    reader.once('error', onReaderError);

    const onReaderFinish = () => {

        return finishOnce(null, reader.collect());
    };

    reader.once('finish', onReaderFinish);

    if (options.gunzip) {
        const contentEncoding = options.gunzip === 'force' ?
            'gzip' :
            (res.headers && internals.findHeader('content-encoding', res.headers)) || '';

        if (/^(x-)?gzip(\s*,\s*identity)?$/.test(contentEncoding)) {
            const gunzip = Zlib.createGunzip();

            gunzip.once('error', onReaderError);

            res.pipe(gunzip).pipe(reader);
            return;
        }
    }

    res.pipe(reader);
};


internals.Client.prototype.toReadableStream = function (payload, encoding) {

    return new Payload(payload, encoding);
};


internals.Client.prototype.parseCacheControl = function (field) {

    /*
        Cache-Control   = 1#cache-directive
        cache-directive = token [ "=" ( token / quoted-string ) ]
        token           = [^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+
        quoted-string   = "(?:[^"\\]|\\.)*"
    */

    //                             1: directive                                        =   2: token                                              3: quoted-string
    const regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;

    const header = {};
    const error = field.replace(regex, ($0, $1, $2, $3) => {

        const value = $2 || $3;
        header[$1] = value ? value.toLowerCase() : true;
        return '';
    });

    if (header['max-age']) {
        try {
            const maxAge = parseInt(header['max-age'], 10);
            if (isNaN(maxAge)) {
                return null;
            }

            header['max-age'] = maxAge;
        }
        catch (err) { }
    }

    return (error ? null : header);
};


// Shortcuts

internals.Client.prototype.get = function (uri, options) {

    return this._shortcut('GET', uri, options);
};


internals.Client.prototype.post = function (uri, options) {

    return this._shortcut('POST', uri, options);
};


internals.Client.prototype.patch = function (uri, options) {

    return this._shortcut('PATCH', uri, options);
};


internals.Client.prototype.put = function (uri, options) {

    return this._shortcut('PUT', uri, options);
};


internals.Client.prototype.delete = function (uri, options) {

    return this._shortcut('DELETE', uri, options);
};


internals.Client.prototype._shortcut = async function (method, uri, options = {}) {

    const res = await this.request(method, uri, options);

    let payload;
    try {
        payload = await this.read(res, options);
    }
    catch (err) {
        err.data = err.data || {};
        err.data.res = res;
        throw err;
    }

    if (res.statusCode < 400) {
        return { res, payload };
    }

    // Response error

    const data = {
        isResponseError: true,
        headers: res.headers,
        res,
        payload
    };

    throw new Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, { statusCode: res.statusCode, data });
};


internals.tryParseBuffer = function (buffer, next) {

    if (buffer.length === 0) {
        return next(null, null);
    }

    let payload;
    try {
        payload = Bourne.parse(buffer.toString());
    }
    catch (err) {
        return next(Boom.badGateway(err.message, { payload: buffer }));
    }

    return next(null, payload);
};


internals.findHeader = function (headerName, headers) {

    const foundKey = Object.keys(headers)
        .find((key) => key.toLowerCase() === headerName.toLowerCase());

    return foundKey && headers[foundKey];
};

internals.applyUrlToOptions = (options, url) => {

    options.host = url.host;
    options.origin = url.origin;
    options.searchParams = url.searchParams;
    options.protocol = url.protocol;
    options.hostname = url.hostname;
    options.hash = url.hash;
    options.search = url.search;
    options.pathname = url.pathname;
    options.path = `${url.pathname}${url.search || ''}`;
    options.href = url.href;
    if (url.port !== '') {
        options.port = Number(url.port);
    }

    if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
        options.username = url.username;
        options.password = url.password;
    }

    return options;
};


module.exports = new internals.Client();


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/payload.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/payload.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");


const internals = {};


module.exports = internals.Payload = class extends Stream.Readable {

    constructor(payload, encoding) {

        super();

        const data = [].concat(payload || '');
        let size = 0;
        for (let i = 0; i < data.length; ++i) {
            const chunk = data[i];
            size = size + chunk.length;
            data[i] = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }

        this._data = Buffer.concat(data, size);
        this._position = 0;
        this._encoding = encoding || 'utf8';
    }

    _read(size) {

        const chunk = this._data.slice(this._position, this._position + size);
        this.push(chunk, this._encoding);
        this._position = this._position + chunk.length;

        if (this._position >= this._data.length) {
            this.push(null);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/recorder.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/recorder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


module.exports = internals.Recorder = class extends Stream.Writable {

    constructor(options) {

        super();

        this.settings = options;                // No need to clone since called internally with new object
        this.buffers = [];
        this.length = 0;
    }

    _write(chunk, encoding, next) {

        if (this.settings.maxBytes &&
            this.length + chunk.length > this.settings.maxBytes) {

            return this.emit('error', Boom.entityTooLarge('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));
        }

        this.length = this.length + chunk.length;
        this.buffers.push(chunk);
        next();
    }

    collect() {

        const buffer = (this.buffers.length === 0 ? Buffer.alloc(0) : (this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length)));
        return buffer;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/tap.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/tap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Payload = __webpack_require__(/*! ./payload */ "./node_modules/@hapi/wreck/lib/payload.js");


const internals = {};


module.exports = internals.Tap = class extends Stream.Transform {

    constructor() {

        super();
        this.buffers = [];
    }

    _transform(chunk, encoding, next) {

        this.buffers.push(chunk);
        next(null, chunk);
    }

    collect() {

        return new Payload(this.buffers);
    }
};


/***/ }),

/***/ "./node_modules/gud/index.js":
/*!***********************************!*\
  !*** ./node_modules/gud/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow


var key = '__global_unique_id__';

module.exports = function() {
  return global[key] = (global[key] || 0) + 1;
};


/***/ }),

/***/ "./node_modules/history/esm/history.js":
/*!*********************************************!*\
  !*** ./node_modules/history/esm/history.js ***!
  \*********************************************/
/*! exports provided: createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBrowserHistory", function() { return createBrowserHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHashHistory", function() { return createHashHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMemoryHistory", function() { return createMemoryHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLocation", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locationsAreEqual", function() { return locationsAreEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePath", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPath", function() { return createPath; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var resolve_pathname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resolve-pathname */ "./node_modules/resolve-pathname/esm/resolve-pathname.js");
/* harmony import */ var value_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! value-equal */ "./node_modules/value-equal/esm/value-equal.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-invariant */ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");






function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
}
function hasBasename(path, prefix) {
  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
}
function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';
  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
  return path;
}

function createLocation(path, state, key, currentLocation) {
  var location;

  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, path);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(resolve_pathname__WEBPACK_IMPORTED_MODULE_1__["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}
function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal__WEBPACK_IMPORTED_MODULE_2__["default"])(a.state, b.state);
}

function createTransitionManager() {
  var prompt = null;

  function setPrompt(nextPrompt) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(prompt == null, 'A history supports only one prompt at a time') : undefined;
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  }

  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
           true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : undefined;
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }

  var listeners = [];

  function appendListener(fn) {
    var isActive = true;

    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  }

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message)); // eslint-disable-line no-alert
}
/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
  return window.history && 'pushState' in window.history;
}
/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */

function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
}
/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
}
/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
}
/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */


function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_4__["default"])(false, 'Browser history needs a DOM') : undefined : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props,
      _props$forceRefresh = _props.forceRefresh,
      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = pathname + search + hash;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : undefined;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path, state, key);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }

  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }

  var forceNextPop = false;

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key]; // Public interface

  function createHref(location) {
    return basename + createPath(location);
  }

  function push(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : undefined;
        window.location.href = href;
      }
    });
  }

  function replace(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : undefined;
        window.location.replace(href);
      }
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

function stripHash(url) {
  var hashIndex = url.indexOf('#');
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
}

function pushHashPath(path) {
  window.location.hash = path;
}

function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + '#' + path);
}

function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_4__["default"])(false, 'Hash history needs a DOM') : undefined : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = _props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  function getDOMLocation() {
    var path = decodePath(getHashPath());
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : undefined;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  var forceNextPop = false;
  var ignorePath = null;

  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }

  function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  }

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  } // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  function createHref(location) {
    var baseTag = document.querySelector('base');
    var href = '';

    if (baseTag && baseTag.getAttribute('href')) {
      href = stripHash(window.location.href);
    }

    return href + '#' + encodePath(basename + createPath(location));
  }

  function push(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Hash history cannot push state; it is ignored') : undefined;
    var action = 'PUSH';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path);
        allPaths = nextPaths;
        setState({
          action: action,
          location: location
        });
      } else {
         true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : undefined;
        setState();
      }
    });
  }

  function replace(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Hash history cannot replace state; it is ignored') : undefined;
    var action = 'REPLACE';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
/**
 * Creates a history object that stores locations in memory.
 */


function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      getUserConfirmation = _props.getUserConfirmation,
      _props$initialEntries = _props.initialEntries,
      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
      _props$initialIndex = _props.initialIndex,
      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();

  function setState(nextState) {
    Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])(history, nextState);

    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
  }); // Public interface

  var createHref = createPath;

  function push(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);

      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }

  function replace(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
    var action = 'POP';
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    return transitionManager.setPrompt(prompt);
  }

  function listen(listener) {
    return transitionManager.appendListener(listener);
  }

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
  return history;
}




/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(/*! pseudomap */ "./node_modules/pseudomap/map.js")
var util = __webpack_require__(/*! util */ "util")

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(/*! yallist */ "./node_modules/lru-cache/node_modules/yallist/yallist.js")

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

/* istanbul ignore next */
LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}


/***/ }),

/***/ "./node_modules/lru-cache/node_modules/yallist/yallist.js":
/*!****************************************************************!*\
  !*** ./node_modules/lru-cache/node_modules/yallist/yallist.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/*! exports provided: application/1d-interleaved-parityfec, application/3gpdash-qoe-report+xml, application/3gpp-ims+xml, application/a2l, application/activemessage, application/activity+json, application/alto-costmap+json, application/alto-costmapfilter+json, application/alto-directory+json, application/alto-endpointcost+json, application/alto-endpointcostparams+json, application/alto-endpointprop+json, application/alto-endpointpropparams+json, application/alto-error+json, application/alto-networkmap+json, application/alto-networkmapfilter+json, application/aml, application/andrew-inset, application/applefile, application/applixware, application/atf, application/atfx, application/atom+xml, application/atomcat+xml, application/atomdeleted+xml, application/atomicmail, application/atomsvc+xml, application/atsc-dwd+xml, application/atsc-held+xml, application/atsc-rsat+xml, application/atxml, application/auth-policy+xml, application/bacnet-xdd+zip, application/batch-smtp, application/bdoc, application/beep+xml, application/calendar+json, application/calendar+xml, application/call-completion, application/cals-1840, application/cbor, application/cccex, application/ccmp+xml, application/ccxml+xml, application/cdfx+xml, application/cdmi-capability, application/cdmi-container, application/cdmi-domain, application/cdmi-object, application/cdmi-queue, application/cdni, application/cea, application/cea-2018+xml, application/cellml+xml, application/cfw, application/clue_info+xml, application/cms, application/cnrp+xml, application/coap-group+json, application/coap-payload, application/commonground, application/conference-info+xml, application/cose, application/cose-key, application/cose-key-set, application/cpl+xml, application/csrattrs, application/csta+xml, application/cstadata+xml, application/csvm+json, application/cu-seeme, application/cwt, application/cybercash, application/dart, application/dash+xml, application/dashdelta, application/davmount+xml, application/dca-rft, application/dcd, application/dec-dx, application/dialog-info+xml, application/dicom, application/dicom+json, application/dicom+xml, application/dii, application/dit, application/dns, application/dns+json, application/dns-message, application/docbook+xml, application/dskpp+xml, application/dssc+der, application/dssc+xml, application/dvcs, application/ecmascript, application/edi-consent, application/edi-x12, application/edifact, application/efi, application/emergencycalldata.comment+xml, application/emergencycalldata.control+xml, application/emergencycalldata.deviceinfo+xml, application/emergencycalldata.ecall.msd, application/emergencycalldata.providerinfo+xml, application/emergencycalldata.serviceinfo+xml, application/emergencycalldata.subscriberinfo+xml, application/emergencycalldata.veds+xml, application/emma+xml, application/emotionml+xml, application/encaprtp, application/epp+xml, application/epub+zip, application/eshop, application/exi, application/expect-ct-report+json, application/fastinfoset, application/fastsoap, application/fdt+xml, application/fhir+json, application/fhir+xml, application/fido.trusted-apps+json, application/fits, application/flexfec, application/font-sfnt, application/font-tdpfr, application/font-woff, application/framework-attributes+xml, application/geo+json, application/geo+json-seq, application/geopackage+sqlite3, application/geoxacml+xml, application/gltf-buffer, application/gml+xml, application/gpx+xml, application/gxf, application/gzip, application/h224, application/held+xml, application/hjson, application/http, application/hyperstudio, application/ibe-key-request+xml, application/ibe-pkg-reply+xml, application/ibe-pp-data, application/iges, application/im-iscomposing+xml, application/index, application/index.cmd, application/index.obj, application/index.response, application/index.vnd, application/inkml+xml, application/iotp, application/ipfix, application/ipp, application/isup, application/its+xml, application/java-archive, application/java-serialized-object, application/java-vm, application/javascript, application/jf2feed+json, application/jose, application/jose+json, application/jrd+json, application/json, application/json-patch+json, application/json-seq, application/json5, application/jsonml+json, application/jwk+json, application/jwk-set+json, application/jwt, application/kpml-request+xml, application/kpml-response+xml, application/ld+json, application/lgr+xml, application/link-format, application/load-control+xml, application/lost+xml, application/lostsync+xml, application/lxf, application/mac-binhex40, application/mac-compactpro, application/macwriteii, application/mads+xml, application/manifest+json, application/marc, application/marcxml+xml, application/mathematica, application/mathml+xml, application/mathml-content+xml, application/mathml-presentation+xml, application/mbms-associated-procedure-description+xml, application/mbms-deregister+xml, application/mbms-envelope+xml, application/mbms-msk+xml, application/mbms-msk-response+xml, application/mbms-protection-description+xml, application/mbms-reception-report+xml, application/mbms-register+xml, application/mbms-register-response+xml, application/mbms-schedule+xml, application/mbms-user-service-description+xml, application/mbox, application/media-policy-dataset+xml, application/media_control+xml, application/mediaservercontrol+xml, application/merge-patch+json, application/metalink+xml, application/metalink4+xml, application/mets+xml, application/mf4, application/mikey, application/mipc, application/mmt-aei+xml, application/mmt-usd+xml, application/mods+xml, application/moss-keys, application/moss-signature, application/mosskey-data, application/mosskey-request, application/mp21, application/mp4, application/mpeg4-generic, application/mpeg4-iod, application/mpeg4-iod-xmt, application/mrb-consumer+xml, application/mrb-publish+xml, application/msc-ivr+xml, application/msc-mixer+xml, application/msword, application/mud+json, application/mxf, application/n-quads, application/n-triples, application/nasdata, application/news-checkgroups, application/news-groupinfo, application/news-transmission, application/nlsml+xml, application/node, application/nss, application/ocsp-request, application/ocsp-response, application/octet-stream, application/oda, application/odm+xml, application/odx, application/oebps-package+xml, application/ogg, application/omdoc+xml, application/onenote, application/oscore, application/oxps, application/p2p-overlay+xml, application/parityfec, application/passport, application/patch-ops-error+xml, application/pdf, application/pdx, application/pem-certificate-chain, application/pgp-encrypted, application/pgp-keys, application/pgp-signature, application/pics-rules, application/pidf+xml, application/pidf-diff+xml, application/pkcs10, application/pkcs12, application/pkcs7-mime, application/pkcs7-signature, application/pkcs8, application/pkcs8-encrypted, application/pkix-attr-cert, application/pkix-cert, application/pkix-crl, application/pkix-pkipath, application/pkixcmp, application/pls+xml, application/poc-settings+xml, application/postscript, application/ppsp-tracker+json, application/problem+json, application/problem+xml, application/provenance+xml, application/prs.alvestrand.titrax-sheet, application/prs.cww, application/prs.hpub+zip, application/prs.nprend, application/prs.plucker, application/prs.rdf-xml-crypt, application/prs.xsf+xml, application/pskc+xml, application/qsig, application/raml+yaml, application/raptorfec, application/rdap+json, application/rdf+xml, application/reginfo+xml, application/relax-ng-compact-syntax, application/remote-printing, application/reputon+json, application/resource-lists+xml, application/resource-lists-diff+xml, application/rfc+xml, application/riscos, application/rlmi+xml, application/rls-services+xml, application/route-apd+xml, application/route-s-tsid+xml, application/route-usd+xml, application/rpki-ghostbusters, application/rpki-manifest, application/rpki-publication, application/rpki-roa, application/rpki-updown, application/rsd+xml, application/rss+xml, application/rtf, application/rtploopback, application/rtx, application/samlassertion+xml, application/samlmetadata+xml, application/sbml+xml, application/scaip+xml, application/scim+json, application/scvp-cv-request, application/scvp-cv-response, application/scvp-vp-request, application/scvp-vp-response, application/sdp, application/secevent+jwt, application/senml+cbor, application/senml+json, application/senml+xml, application/senml-exi, application/sensml+cbor, application/sensml+json, application/sensml+xml, application/sensml-exi, application/sep+xml, application/sep-exi, application/session-info, application/set-payment, application/set-payment-initiation, application/set-registration, application/set-registration-initiation, application/sgml, application/sgml-open-catalog, application/shf+xml, application/sieve, application/simple-filter+xml, application/simple-message-summary, application/simplesymbolcontainer, application/sipc, application/slate, application/smil, application/smil+xml, application/smpte336m, application/soap+fastinfoset, application/soap+xml, application/sparql-query, application/sparql-results+xml, application/spirits-event+xml, application/sql, application/srgs, application/srgs+xml, application/sru+xml, application/ssdl+xml, application/ssml+xml, application/stix+json, application/swid+xml, application/tamp-apex-update, application/tamp-apex-update-confirm, application/tamp-community-update, application/tamp-community-update-confirm, application/tamp-error, application/tamp-sequence-adjust, application/tamp-sequence-adjust-confirm, application/tamp-status-query, application/tamp-status-response, application/tamp-update, application/tamp-update-confirm, application/tar, application/taxii+json, application/tei+xml, application/tetra_isi, application/thraud+xml, application/timestamp-query, application/timestamp-reply, application/timestamped-data, application/tlsrpt+gzip, application/tlsrpt+json, application/tnauthlist, application/toml, application/trickle-ice-sdpfrag, application/trig, application/ttml+xml, application/tve-trigger, application/tzif, application/tzif-leap, application/ulpfec, application/urc-grpsheet+xml, application/urc-ressheet+xml, application/urc-targetdesc+xml, application/urc-uisocketdesc+xml, application/vcard+json, application/vcard+xml, application/vemmi, application/vividence.scriptfile, application/vnd.1000minds.decision-model+xml, application/vnd.3gpp-prose+xml, application/vnd.3gpp-prose-pc3ch+xml, application/vnd.3gpp-v2x-local-service-information, application/vnd.3gpp.access-transfer-events+xml, application/vnd.3gpp.bsf+xml, application/vnd.3gpp.gmop+xml, application/vnd.3gpp.mc-signalling-ear, application/vnd.3gpp.mcdata-affiliation-command+xml, application/vnd.3gpp.mcdata-info+xml, application/vnd.3gpp.mcdata-payload, application/vnd.3gpp.mcdata-service-config+xml, application/vnd.3gpp.mcdata-signalling, application/vnd.3gpp.mcdata-ue-config+xml, application/vnd.3gpp.mcdata-user-profile+xml, application/vnd.3gpp.mcptt-affiliation-command+xml, application/vnd.3gpp.mcptt-floor-request+xml, application/vnd.3gpp.mcptt-info+xml, application/vnd.3gpp.mcptt-location-info+xml, application/vnd.3gpp.mcptt-mbms-usage-info+xml, application/vnd.3gpp.mcptt-service-config+xml, application/vnd.3gpp.mcptt-signed+xml, application/vnd.3gpp.mcptt-ue-config+xml, application/vnd.3gpp.mcptt-ue-init-config+xml, application/vnd.3gpp.mcptt-user-profile+xml, application/vnd.3gpp.mcvideo-affiliation-command+xml, application/vnd.3gpp.mcvideo-affiliation-info+xml, application/vnd.3gpp.mcvideo-info+xml, application/vnd.3gpp.mcvideo-location-info+xml, application/vnd.3gpp.mcvideo-mbms-usage-info+xml, application/vnd.3gpp.mcvideo-service-config+xml, application/vnd.3gpp.mcvideo-transmission-request+xml, application/vnd.3gpp.mcvideo-ue-config+xml, application/vnd.3gpp.mcvideo-user-profile+xml, application/vnd.3gpp.mid-call+xml, application/vnd.3gpp.pic-bw-large, application/vnd.3gpp.pic-bw-small, application/vnd.3gpp.pic-bw-var, application/vnd.3gpp.sms, application/vnd.3gpp.sms+xml, application/vnd.3gpp.srvcc-ext+xml, application/vnd.3gpp.srvcc-info+xml, application/vnd.3gpp.state-and-event-info+xml, application/vnd.3gpp.ussd+xml, application/vnd.3gpp2.bcmcsinfo+xml, application/vnd.3gpp2.sms, application/vnd.3gpp2.tcap, application/vnd.3lightssoftware.imagescal, application/vnd.3m.post-it-notes, application/vnd.accpac.simply.aso, application/vnd.accpac.simply.imp, application/vnd.acucobol, application/vnd.acucorp, application/vnd.adobe.air-application-installer-package+zip, application/vnd.adobe.flash.movie, application/vnd.adobe.formscentral.fcdt, application/vnd.adobe.fxp, application/vnd.adobe.partial-upload, application/vnd.adobe.xdp+xml, application/vnd.adobe.xfdf, application/vnd.aether.imp, application/vnd.afpc.afplinedata, application/vnd.afpc.modca, application/vnd.ah-barcode, application/vnd.ahead.space, application/vnd.airzip.filesecure.azf, application/vnd.airzip.filesecure.azs, application/vnd.amadeus+json, application/vnd.amazon.ebook, application/vnd.amazon.mobi8-ebook, application/vnd.americandynamics.acc, application/vnd.amiga.ami, application/vnd.amundsen.maze+xml, application/vnd.android.ota, application/vnd.android.package-archive, application/vnd.anki, application/vnd.anser-web-certificate-issue-initiation, application/vnd.anser-web-funds-transfer-initiation, application/vnd.antix.game-component, application/vnd.apache.thrift.binary, application/vnd.apache.thrift.compact, application/vnd.apache.thrift.json, application/vnd.api+json, application/vnd.apothekende.reservation+json, application/vnd.apple.installer+xml, application/vnd.apple.keynote, application/vnd.apple.mpegurl, application/vnd.apple.numbers, application/vnd.apple.pages, application/vnd.apple.pkpass, application/vnd.arastra.swi, application/vnd.aristanetworks.swi, application/vnd.artisan+json, application/vnd.artsquare, application/vnd.astraea-software.iota, application/vnd.audiograph, application/vnd.autopackage, application/vnd.avalon+json, application/vnd.avistar+xml, application/vnd.balsamiq.bmml+xml, application/vnd.balsamiq.bmpr, application/vnd.banana-accounting, application/vnd.bbf.usp.error, application/vnd.bbf.usp.msg, application/vnd.bbf.usp.msg+json, application/vnd.bekitzur-stech+json, application/vnd.bint.med-content, application/vnd.biopax.rdf+xml, application/vnd.blink-idb-value-wrapper, application/vnd.blueice.multipass, application/vnd.bluetooth.ep.oob, application/vnd.bluetooth.le.oob, application/vnd.bmi, application/vnd.bpf, application/vnd.bpf3, application/vnd.businessobjects, application/vnd.byu.uapi+json, application/vnd.cab-jscript, application/vnd.canon-cpdl, application/vnd.canon-lips, application/vnd.capasystems-pg+json, application/vnd.cendio.thinlinc.clientconf, application/vnd.century-systems.tcp_stream, application/vnd.chemdraw+xml, application/vnd.chess-pgn, application/vnd.chipnuts.karaoke-mmd, application/vnd.ciedi, application/vnd.cinderella, application/vnd.cirpack.isdn-ext, application/vnd.citationstyles.style+xml, application/vnd.claymore, application/vnd.cloanto.rp9, application/vnd.clonk.c4group, application/vnd.cluetrust.cartomobile-config, application/vnd.cluetrust.cartomobile-config-pkg, application/vnd.coffeescript, application/vnd.collabio.xodocuments.document, application/vnd.collabio.xodocuments.document-template, application/vnd.collabio.xodocuments.presentation, application/vnd.collabio.xodocuments.presentation-template, application/vnd.collabio.xodocuments.spreadsheet, application/vnd.collabio.xodocuments.spreadsheet-template, application/vnd.collection+json, application/vnd.collection.doc+json, application/vnd.collection.next+json, application/vnd.comicbook+zip, application/vnd.comicbook-rar, application/vnd.commerce-battelle, application/vnd.commonspace, application/vnd.contact.cmsg, application/vnd.coreos.ignition+json, application/vnd.cosmocaller, application/vnd.crick.clicker, application/vnd.crick.clicker.keyboard, application/vnd.crick.clicker.palette, application/vnd.crick.clicker.template, application/vnd.crick.clicker.wordbank, application/vnd.criticaltools.wbs+xml, application/vnd.cryptii.pipe+json, application/vnd.crypto-shade-file, application/vnd.ctc-posml, application/vnd.ctct.ws+xml, application/vnd.cups-pdf, application/vnd.cups-postscript, application/vnd.cups-ppd, application/vnd.cups-raster, application/vnd.cups-raw, application/vnd.curl, application/vnd.curl.car, application/vnd.curl.pcurl, application/vnd.cyan.dean.root+xml, application/vnd.cybank, application/vnd.d2l.coursepackage1p0+zip, application/vnd.dart, application/vnd.data-vision.rdz, application/vnd.datapackage+json, application/vnd.dataresource+json, application/vnd.debian.binary-package, application/vnd.dece.data, application/vnd.dece.ttml+xml, application/vnd.dece.unspecified, application/vnd.dece.zip, application/vnd.denovo.fcselayout-link, application/vnd.desmume.movie, application/vnd.dir-bi.plate-dl-nosuffix, application/vnd.dm.delegation+xml, application/vnd.dna, application/vnd.document+json, application/vnd.dolby.mlp, application/vnd.dolby.mobile.1, application/vnd.dolby.mobile.2, application/vnd.doremir.scorecloud-binary-document, application/vnd.dpgraph, application/vnd.dreamfactory, application/vnd.drive+json, application/vnd.ds-keypoint, application/vnd.dtg.local, application/vnd.dtg.local.flash, application/vnd.dtg.local.html, application/vnd.dvb.ait, application/vnd.dvb.dvbj, application/vnd.dvb.esgcontainer, application/vnd.dvb.ipdcdftnotifaccess, application/vnd.dvb.ipdcesgaccess, application/vnd.dvb.ipdcesgaccess2, application/vnd.dvb.ipdcesgpdd, application/vnd.dvb.ipdcroaming, application/vnd.dvb.iptv.alfec-base, application/vnd.dvb.iptv.alfec-enhancement, application/vnd.dvb.notif-aggregate-root+xml, application/vnd.dvb.notif-container+xml, application/vnd.dvb.notif-generic+xml, application/vnd.dvb.notif-ia-msglist+xml, application/vnd.dvb.notif-ia-registration-request+xml, application/vnd.dvb.notif-ia-registration-response+xml, application/vnd.dvb.notif-init+xml, application/vnd.dvb.pfr, application/vnd.dvb.service, application/vnd.dxr, application/vnd.dynageo, application/vnd.dzr, application/vnd.easykaraoke.cdgdownload, application/vnd.ecdis-update, application/vnd.ecip.rlp, application/vnd.ecowin.chart, application/vnd.ecowin.filerequest, application/vnd.ecowin.fileupdate, application/vnd.ecowin.series, application/vnd.ecowin.seriesrequest, application/vnd.ecowin.seriesupdate, application/vnd.efi.img, application/vnd.efi.iso, application/vnd.emclient.accessrequest+xml, application/vnd.enliven, application/vnd.enphase.envoy, application/vnd.eprints.data+xml, application/vnd.epson.esf, application/vnd.epson.msf, application/vnd.epson.quickanime, application/vnd.epson.salt, application/vnd.epson.ssf, application/vnd.ericsson.quickcall, application/vnd.espass-espass+zip, application/vnd.eszigno3+xml, application/vnd.etsi.aoc+xml, application/vnd.etsi.asic-e+zip, application/vnd.etsi.asic-s+zip, application/vnd.etsi.cug+xml, application/vnd.etsi.iptvcommand+xml, application/vnd.etsi.iptvdiscovery+xml, application/vnd.etsi.iptvprofile+xml, application/vnd.etsi.iptvsad-bc+xml, application/vnd.etsi.iptvsad-cod+xml, application/vnd.etsi.iptvsad-npvr+xml, application/vnd.etsi.iptvservice+xml, application/vnd.etsi.iptvsync+xml, application/vnd.etsi.iptvueprofile+xml, application/vnd.etsi.mcid+xml, application/vnd.etsi.mheg5, application/vnd.etsi.overload-control-policy-dataset+xml, application/vnd.etsi.pstn+xml, application/vnd.etsi.sci+xml, application/vnd.etsi.simservs+xml, application/vnd.etsi.timestamp-token, application/vnd.etsi.tsl+xml, application/vnd.etsi.tsl.der, application/vnd.eudora.data, application/vnd.evolv.ecig.profile, application/vnd.evolv.ecig.settings, application/vnd.evolv.ecig.theme, application/vnd.exstream-empower+zip, application/vnd.exstream-package, application/vnd.ezpix-album, application/vnd.ezpix-package, application/vnd.f-secure.mobile, application/vnd.fastcopy-disk-image, application/vnd.fdf, application/vnd.fdsn.mseed, application/vnd.fdsn.seed, application/vnd.ffsns, application/vnd.ficlab.flb+zip, application/vnd.filmit.zfc, application/vnd.fints, application/vnd.firemonkeys.cloudcell, application/vnd.flographit, application/vnd.fluxtime.clip, application/vnd.font-fontforge-sfd, application/vnd.framemaker, application/vnd.frogans.fnc, application/vnd.frogans.ltf, application/vnd.fsc.weblaunch, application/vnd.fujitsu.oasys, application/vnd.fujitsu.oasys2, application/vnd.fujitsu.oasys3, application/vnd.fujitsu.oasysgp, application/vnd.fujitsu.oasysprs, application/vnd.fujixerox.art-ex, application/vnd.fujixerox.art4, application/vnd.fujixerox.ddd, application/vnd.fujixerox.docuworks, application/vnd.fujixerox.docuworks.binder, application/vnd.fujixerox.docuworks.container, application/vnd.fujixerox.hbpl, application/vnd.fut-misnet, application/vnd.futoin+cbor, application/vnd.futoin+json, application/vnd.fuzzysheet, application/vnd.genomatix.tuxedo, application/vnd.geo+json, application/vnd.geocube+xml, application/vnd.geogebra.file, application/vnd.geogebra.tool, application/vnd.geometry-explorer, application/vnd.geonext, application/vnd.geoplan, application/vnd.geospace, application/vnd.gerber, application/vnd.globalplatform.card-content-mgt, application/vnd.globalplatform.card-content-mgt-response, application/vnd.gmx, application/vnd.google-apps.document, application/vnd.google-apps.presentation, application/vnd.google-apps.spreadsheet, application/vnd.google-earth.kml+xml, application/vnd.google-earth.kmz, application/vnd.gov.sk.e-form+xml, application/vnd.gov.sk.e-form+zip, application/vnd.gov.sk.xmldatacontainer+xml, application/vnd.grafeq, application/vnd.gridmp, application/vnd.groove-account, application/vnd.groove-help, application/vnd.groove-identity-message, application/vnd.groove-injector, application/vnd.groove-tool-message, application/vnd.groove-tool-template, application/vnd.groove-vcard, application/vnd.hal+json, application/vnd.hal+xml, application/vnd.handheld-entertainment+xml, application/vnd.hbci, application/vnd.hc+json, application/vnd.hcl-bireports, application/vnd.hdt, application/vnd.heroku+json, application/vnd.hhe.lesson-player, application/vnd.hp-hpgl, application/vnd.hp-hpid, application/vnd.hp-hps, application/vnd.hp-jlyt, application/vnd.hp-pcl, application/vnd.hp-pclxl, application/vnd.httphone, application/vnd.hydrostatix.sof-data, application/vnd.hyper+json, application/vnd.hyper-item+json, application/vnd.hyperdrive+json, application/vnd.hzn-3d-crossword, application/vnd.ibm.afplinedata, application/vnd.ibm.electronic-media, application/vnd.ibm.minipay, application/vnd.ibm.modcap, application/vnd.ibm.rights-management, application/vnd.ibm.secure-container, application/vnd.iccprofile, application/vnd.ieee.1905, application/vnd.igloader, application/vnd.imagemeter.folder+zip, application/vnd.imagemeter.image+zip, application/vnd.immervision-ivp, application/vnd.immervision-ivu, application/vnd.ims.imsccv1p1, application/vnd.ims.imsccv1p2, application/vnd.ims.imsccv1p3, application/vnd.ims.lis.v2.result+json, application/vnd.ims.lti.v2.toolconsumerprofile+json, application/vnd.ims.lti.v2.toolproxy+json, application/vnd.ims.lti.v2.toolproxy.id+json, application/vnd.ims.lti.v2.toolsettings+json, application/vnd.ims.lti.v2.toolsettings.simple+json, application/vnd.informedcontrol.rms+xml, application/vnd.informix-visionary, application/vnd.infotech.project, application/vnd.infotech.project+xml, application/vnd.innopath.wamp.notification, application/vnd.insors.igm, application/vnd.intercon.formnet, application/vnd.intergeo, application/vnd.intertrust.digibox, application/vnd.intertrust.nncp, application/vnd.intu.qbo, application/vnd.intu.qfx, application/vnd.iptc.g2.catalogitem+xml, application/vnd.iptc.g2.conceptitem+xml, application/vnd.iptc.g2.knowledgeitem+xml, application/vnd.iptc.g2.newsitem+xml, application/vnd.iptc.g2.newsmessage+xml, application/vnd.iptc.g2.packageitem+xml, application/vnd.iptc.g2.planningitem+xml, application/vnd.ipunplugged.rcprofile, application/vnd.irepository.package+xml, application/vnd.is-xpr, application/vnd.isac.fcs, application/vnd.iso11783-10+zip, application/vnd.jam, application/vnd.japannet-directory-service, application/vnd.japannet-jpnstore-wakeup, application/vnd.japannet-payment-wakeup, application/vnd.japannet-registration, application/vnd.japannet-registration-wakeup, application/vnd.japannet-setstore-wakeup, application/vnd.japannet-verification, application/vnd.japannet-verification-wakeup, application/vnd.jcp.javame.midlet-rms, application/vnd.jisp, application/vnd.joost.joda-archive, application/vnd.jsk.isdn-ngn, application/vnd.kahootz, application/vnd.kde.karbon, application/vnd.kde.kchart, application/vnd.kde.kformula, application/vnd.kde.kivio, application/vnd.kde.kontour, application/vnd.kde.kpresenter, application/vnd.kde.kspread, application/vnd.kde.kword, application/vnd.kenameaapp, application/vnd.kidspiration, application/vnd.kinar, application/vnd.koan, application/vnd.kodak-descriptor, application/vnd.las, application/vnd.las.las+json, application/vnd.las.las+xml, application/vnd.laszip, application/vnd.leap+json, application/vnd.liberty-request+xml, application/vnd.llamagraphics.life-balance.desktop, application/vnd.llamagraphics.life-balance.exchange+xml, application/vnd.logipipe.circuit+zip, application/vnd.loom, application/vnd.lotus-1-2-3, application/vnd.lotus-approach, application/vnd.lotus-freelance, application/vnd.lotus-notes, application/vnd.lotus-organizer, application/vnd.lotus-screencam, application/vnd.lotus-wordpro, application/vnd.macports.portpkg, application/vnd.mapbox-vector-tile, application/vnd.marlin.drm.actiontoken+xml, application/vnd.marlin.drm.conftoken+xml, application/vnd.marlin.drm.license+xml, application/vnd.marlin.drm.mdcf, application/vnd.mason+json, application/vnd.maxmind.maxmind-db, application/vnd.mcd, application/vnd.medcalcdata, application/vnd.mediastation.cdkey, application/vnd.meridian-slingshot, application/vnd.mfer, application/vnd.mfmp, application/vnd.micro+json, application/vnd.micrografx.flo, application/vnd.micrografx.igx, application/vnd.microsoft.portable-executable, application/vnd.microsoft.windows.thumbnail-cache, application/vnd.miele+json, application/vnd.mif, application/vnd.minisoft-hp3000-save, application/vnd.mitsubishi.misty-guard.trustweb, application/vnd.mobius.daf, application/vnd.mobius.dis, application/vnd.mobius.mbk, application/vnd.mobius.mqy, application/vnd.mobius.msl, application/vnd.mobius.plc, application/vnd.mobius.txf, application/vnd.mophun.application, application/vnd.mophun.certificate, application/vnd.motorola.flexsuite, application/vnd.motorola.flexsuite.adsi, application/vnd.motorola.flexsuite.fis, application/vnd.motorola.flexsuite.gotap, application/vnd.motorola.flexsuite.kmr, application/vnd.motorola.flexsuite.ttc, application/vnd.motorola.flexsuite.wem, application/vnd.motorola.iprm, application/vnd.mozilla.xul+xml, application/vnd.ms-3mfdocument, application/vnd.ms-artgalry, application/vnd.ms-asf, application/vnd.ms-cab-compressed, application/vnd.ms-color.iccprofile, application/vnd.ms-excel, application/vnd.ms-excel.addin.macroenabled.12, application/vnd.ms-excel.sheet.binary.macroenabled.12, application/vnd.ms-excel.sheet.macroenabled.12, application/vnd.ms-excel.template.macroenabled.12, application/vnd.ms-fontobject, application/vnd.ms-htmlhelp, application/vnd.ms-ims, application/vnd.ms-lrm, application/vnd.ms-office.activex+xml, application/vnd.ms-officetheme, application/vnd.ms-opentype, application/vnd.ms-outlook, application/vnd.ms-package.obfuscated-opentype, application/vnd.ms-pki.seccat, application/vnd.ms-pki.stl, application/vnd.ms-playready.initiator+xml, application/vnd.ms-powerpoint, application/vnd.ms-powerpoint.addin.macroenabled.12, application/vnd.ms-powerpoint.presentation.macroenabled.12, application/vnd.ms-powerpoint.slide.macroenabled.12, application/vnd.ms-powerpoint.slideshow.macroenabled.12, application/vnd.ms-powerpoint.template.macroenabled.12, application/vnd.ms-printdevicecapabilities+xml, application/vnd.ms-printing.printticket+xml, application/vnd.ms-printschematicket+xml, application/vnd.ms-project, application/vnd.ms-tnef, application/vnd.ms-windows.devicepairing, application/vnd.ms-windows.nwprinting.oob, application/vnd.ms-windows.printerpairing, application/vnd.ms-windows.wsd.oob, application/vnd.ms-wmdrm.lic-chlg-req, application/vnd.ms-wmdrm.lic-resp, application/vnd.ms-wmdrm.meter-chlg-req, application/vnd.ms-wmdrm.meter-resp, application/vnd.ms-word.document.macroenabled.12, application/vnd.ms-word.template.macroenabled.12, application/vnd.ms-works, application/vnd.ms-wpl, application/vnd.ms-xpsdocument, application/vnd.msa-disk-image, application/vnd.mseq, application/vnd.msign, application/vnd.multiad.creator, application/vnd.multiad.creator.cif, application/vnd.music-niff, application/vnd.musician, application/vnd.muvee.style, application/vnd.mynfc, application/vnd.ncd.control, application/vnd.ncd.reference, application/vnd.nearst.inv+json, application/vnd.nervana, application/vnd.netfpx, application/vnd.neurolanguage.nlu, application/vnd.nimn, application/vnd.nintendo.nitro.rom, application/vnd.nintendo.snes.rom, application/vnd.nitf, application/vnd.noblenet-directory, application/vnd.noblenet-sealer, application/vnd.noblenet-web, application/vnd.nokia.catalogs, application/vnd.nokia.conml+wbxml, application/vnd.nokia.conml+xml, application/vnd.nokia.iptv.config+xml, application/vnd.nokia.isds-radio-presets, application/vnd.nokia.landmark+wbxml, application/vnd.nokia.landmark+xml, application/vnd.nokia.landmarkcollection+xml, application/vnd.nokia.n-gage.ac+xml, application/vnd.nokia.n-gage.data, application/vnd.nokia.n-gage.symbian.install, application/vnd.nokia.ncd, application/vnd.nokia.pcd+wbxml, application/vnd.nokia.pcd+xml, application/vnd.nokia.radio-preset, application/vnd.nokia.radio-presets, application/vnd.novadigm.edm, application/vnd.novadigm.edx, application/vnd.novadigm.ext, application/vnd.ntt-local.content-share, application/vnd.ntt-local.file-transfer, application/vnd.ntt-local.ogw_remote-access, application/vnd.ntt-local.sip-ta_remote, application/vnd.ntt-local.sip-ta_tcp_stream, application/vnd.oasis.opendocument.chart, application/vnd.oasis.opendocument.chart-template, application/vnd.oasis.opendocument.database, application/vnd.oasis.opendocument.formula, application/vnd.oasis.opendocument.formula-template, application/vnd.oasis.opendocument.graphics, application/vnd.oasis.opendocument.graphics-template, application/vnd.oasis.opendocument.image, application/vnd.oasis.opendocument.image-template, application/vnd.oasis.opendocument.presentation, application/vnd.oasis.opendocument.presentation-template, application/vnd.oasis.opendocument.spreadsheet, application/vnd.oasis.opendocument.spreadsheet-template, application/vnd.oasis.opendocument.text, application/vnd.oasis.opendocument.text-master, application/vnd.oasis.opendocument.text-template, application/vnd.oasis.opendocument.text-web, application/vnd.obn, application/vnd.ocf+cbor, application/vnd.oftn.l10n+json, application/vnd.oipf.contentaccessdownload+xml, application/vnd.oipf.contentaccessstreaming+xml, application/vnd.oipf.cspg-hexbinary, application/vnd.oipf.dae.svg+xml, application/vnd.oipf.dae.xhtml+xml, application/vnd.oipf.mippvcontrolmessage+xml, application/vnd.oipf.pae.gem, application/vnd.oipf.spdiscovery+xml, application/vnd.oipf.spdlist+xml, application/vnd.oipf.ueprofile+xml, application/vnd.oipf.userprofile+xml, application/vnd.olpc-sugar, application/vnd.oma-scws-config, application/vnd.oma-scws-http-request, application/vnd.oma-scws-http-response, application/vnd.oma.bcast.associated-procedure-parameter+xml, application/vnd.oma.bcast.drm-trigger+xml, application/vnd.oma.bcast.imd+xml, application/vnd.oma.bcast.ltkm, application/vnd.oma.bcast.notification+xml, application/vnd.oma.bcast.provisioningtrigger, application/vnd.oma.bcast.sgboot, application/vnd.oma.bcast.sgdd+xml, application/vnd.oma.bcast.sgdu, application/vnd.oma.bcast.simple-symbol-container, application/vnd.oma.bcast.smartcard-trigger+xml, application/vnd.oma.bcast.sprov+xml, application/vnd.oma.bcast.stkm, application/vnd.oma.cab-address-book+xml, application/vnd.oma.cab-feature-handler+xml, application/vnd.oma.cab-pcc+xml, application/vnd.oma.cab-subs-invite+xml, application/vnd.oma.cab-user-prefs+xml, application/vnd.oma.dcd, application/vnd.oma.dcdc, application/vnd.oma.dd2+xml, application/vnd.oma.drm.risd+xml, application/vnd.oma.group-usage-list+xml, application/vnd.oma.lwm2m+json, application/vnd.oma.lwm2m+tlv, application/vnd.oma.pal+xml, application/vnd.oma.poc.detailed-progress-report+xml, application/vnd.oma.poc.final-report+xml, application/vnd.oma.poc.groups+xml, application/vnd.oma.poc.invocation-descriptor+xml, application/vnd.oma.poc.optimized-progress-report+xml, application/vnd.oma.push, application/vnd.oma.scidm.messages+xml, application/vnd.oma.xcap-directory+xml, application/vnd.omads-email+xml, application/vnd.omads-file+xml, application/vnd.omads-folder+xml, application/vnd.omaloc-supl-init, application/vnd.onepager, application/vnd.onepagertamp, application/vnd.onepagertamx, application/vnd.onepagertat, application/vnd.onepagertatp, application/vnd.onepagertatx, application/vnd.openblox.game+xml, application/vnd.openblox.game-binary, application/vnd.openeye.oeb, application/vnd.openofficeorg.extension, application/vnd.openstreetmap.data+xml, application/vnd.openxmlformats-officedocument.custom-properties+xml, application/vnd.openxmlformats-officedocument.customxmlproperties+xml, application/vnd.openxmlformats-officedocument.drawing+xml, application/vnd.openxmlformats-officedocument.drawingml.chart+xml, application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml, application/vnd.openxmlformats-officedocument.extended-properties+xml, application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml, application/vnd.openxmlformats-officedocument.presentationml.comments+xml, application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml, application/vnd.openxmlformats-officedocument.presentationml.presprops+xml, application/vnd.openxmlformats-officedocument.presentationml.slide, application/vnd.openxmlformats-officedocument.presentationml.slide+xml, application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml, application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml, application/vnd.openxmlformats-officedocument.presentationml.slideshow, application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml, application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml, application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml, application/vnd.openxmlformats-officedocument.presentationml.tags+xml, application/vnd.openxmlformats-officedocument.presentationml.template, application/vnd.openxmlformats-officedocument.presentationml.template.main+xml, application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.template, application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml, application/vnd.openxmlformats-officedocument.theme+xml, application/vnd.openxmlformats-officedocument.themeoverride+xml, application/vnd.openxmlformats-officedocument.vmldrawing, application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.template, application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml, application/vnd.openxmlformats-package.core-properties+xml, application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml, application/vnd.openxmlformats-package.relationships+xml, application/vnd.oracle.resource+json, application/vnd.orange.indata, application/vnd.osa.netdeploy, application/vnd.osgeo.mapguide.package, application/vnd.osgi.bundle, application/vnd.osgi.dp, application/vnd.osgi.subsystem, application/vnd.otps.ct-kip+xml, application/vnd.oxli.countgraph, application/vnd.pagerduty+json, application/vnd.palm, application/vnd.panoply, application/vnd.paos.xml, application/vnd.patentdive, application/vnd.patientecommsdoc, application/vnd.pawaafile, application/vnd.pcos, application/vnd.pg.format, application/vnd.pg.osasli, application/vnd.piaccess.application-licence, application/vnd.picsel, application/vnd.pmi.widget, application/vnd.poc.group-advertisement+xml, application/vnd.pocketlearn, application/vnd.powerbuilder6, application/vnd.powerbuilder6-s, application/vnd.powerbuilder7, application/vnd.powerbuilder7-s, application/vnd.powerbuilder75, application/vnd.powerbuilder75-s, application/vnd.preminet, application/vnd.previewsystems.box, application/vnd.proteus.magazine, application/vnd.psfs, application/vnd.publishare-delta-tree, application/vnd.pvi.ptid1, application/vnd.pwg-multiplexed, application/vnd.pwg-xhtml-print+xml, application/vnd.qualcomm.brew-app-res, application/vnd.quarantainenet, application/vnd.quark.quarkxpress, application/vnd.quobject-quoxdocument, application/vnd.radisys.moml+xml, application/vnd.radisys.msml+xml, application/vnd.radisys.msml-audit+xml, application/vnd.radisys.msml-audit-conf+xml, application/vnd.radisys.msml-audit-conn+xml, application/vnd.radisys.msml-audit-dialog+xml, application/vnd.radisys.msml-audit-stream+xml, application/vnd.radisys.msml-conf+xml, application/vnd.radisys.msml-dialog+xml, application/vnd.radisys.msml-dialog-base+xml, application/vnd.radisys.msml-dialog-fax-detect+xml, application/vnd.radisys.msml-dialog-fax-sendrecv+xml, application/vnd.radisys.msml-dialog-group+xml, application/vnd.radisys.msml-dialog-speech+xml, application/vnd.radisys.msml-dialog-transform+xml, application/vnd.rainstor.data, application/vnd.rapid, application/vnd.rar, application/vnd.realvnc.bed, application/vnd.recordare.musicxml, application/vnd.recordare.musicxml+xml, application/vnd.renlearn.rlprint, application/vnd.restful+json, application/vnd.rig.cryptonote, application/vnd.rim.cod, application/vnd.rn-realmedia, application/vnd.rn-realmedia-vbr, application/vnd.route66.link66+xml, application/vnd.rs-274x, application/vnd.ruckus.download, application/vnd.s3sms, application/vnd.sailingtracker.track, application/vnd.sbm.cid, application/vnd.sbm.mid2, application/vnd.scribus, application/vnd.sealed.3df, application/vnd.sealed.csf, application/vnd.sealed.doc, application/vnd.sealed.eml, application/vnd.sealed.mht, application/vnd.sealed.net, application/vnd.sealed.ppt, application/vnd.sealed.tiff, application/vnd.sealed.xls, application/vnd.sealedmedia.softseal.html, application/vnd.sealedmedia.softseal.pdf, application/vnd.seemail, application/vnd.sema, application/vnd.semd, application/vnd.semf, application/vnd.shade-save-file, application/vnd.shana.informed.formdata, application/vnd.shana.informed.formtemplate, application/vnd.shana.informed.interchange, application/vnd.shana.informed.package, application/vnd.shootproof+json, application/vnd.shopkick+json, application/vnd.sigrok.session, application/vnd.simtech-mindmapper, application/vnd.siren+json, application/vnd.smaf, application/vnd.smart.notebook, application/vnd.smart.teacher, application/vnd.software602.filler.form+xml, application/vnd.software602.filler.form-xml-zip, application/vnd.solent.sdkm+xml, application/vnd.spotfire.dxp, application/vnd.spotfire.sfs, application/vnd.sqlite3, application/vnd.sss-cod, application/vnd.sss-dtf, application/vnd.sss-ntf, application/vnd.stardivision.calc, application/vnd.stardivision.draw, application/vnd.stardivision.impress, application/vnd.stardivision.math, application/vnd.stardivision.writer, application/vnd.stardivision.writer-global, application/vnd.stepmania.package, application/vnd.stepmania.stepchart, application/vnd.street-stream, application/vnd.sun.wadl+xml, application/vnd.sun.xml.calc, application/vnd.sun.xml.calc.template, application/vnd.sun.xml.draw, application/vnd.sun.xml.draw.template, application/vnd.sun.xml.impress, application/vnd.sun.xml.impress.template, application/vnd.sun.xml.math, application/vnd.sun.xml.writer, application/vnd.sun.xml.writer.global, application/vnd.sun.xml.writer.template, application/vnd.sus-calendar, application/vnd.svd, application/vnd.swiftview-ics, application/vnd.symbian.install, application/vnd.syncml+xml, application/vnd.syncml.dm+wbxml, application/vnd.syncml.dm+xml, application/vnd.syncml.dm.notification, application/vnd.syncml.dmddf+wbxml, application/vnd.syncml.dmddf+xml, application/vnd.syncml.dmtnds+wbxml, application/vnd.syncml.dmtnds+xml, application/vnd.syncml.ds.notification, application/vnd.tableschema+json, application/vnd.tao.intent-module-archive, application/vnd.tcpdump.pcap, application/vnd.think-cell.ppttc+json, application/vnd.tmd.mediaflex.api+xml, application/vnd.tml, application/vnd.tmobile-livetv, application/vnd.tri.onesource, application/vnd.trid.tpt, application/vnd.triscape.mxs, application/vnd.trueapp, application/vnd.truedoc, application/vnd.ubisoft.webplayer, application/vnd.ufdl, application/vnd.uiq.theme, application/vnd.umajin, application/vnd.unity, application/vnd.uoml+xml, application/vnd.uplanet.alert, application/vnd.uplanet.alert-wbxml, application/vnd.uplanet.bearer-choice, application/vnd.uplanet.bearer-choice-wbxml, application/vnd.uplanet.cacheop, application/vnd.uplanet.cacheop-wbxml, application/vnd.uplanet.channel, application/vnd.uplanet.channel-wbxml, application/vnd.uplanet.list, application/vnd.uplanet.list-wbxml, application/vnd.uplanet.listcmd, application/vnd.uplanet.listcmd-wbxml, application/vnd.uplanet.signal, application/vnd.uri-map, application/vnd.valve.source.material, application/vnd.vcx, application/vnd.vd-study, application/vnd.vectorworks, application/vnd.vel+json, application/vnd.verimatrix.vcas, application/vnd.veryant.thin, application/vnd.ves.encrypted, application/vnd.vidsoft.vidconference, application/vnd.visio, application/vnd.visionary, application/vnd.vividence.scriptfile, application/vnd.vsf, application/vnd.wap.sic, application/vnd.wap.slc, application/vnd.wap.wbxml, application/vnd.wap.wmlc, application/vnd.wap.wmlscriptc, application/vnd.webturbo, application/vnd.wfa.p2p, application/vnd.wfa.wsc, application/vnd.windows.devicepairing, application/vnd.wmc, application/vnd.wmf.bootstrap, application/vnd.wolfram.mathematica, application/vnd.wolfram.mathematica.package, application/vnd.wolfram.player, application/vnd.wordperfect, application/vnd.wqd, application/vnd.wrq-hp3000-labelled, application/vnd.wt.stf, application/vnd.wv.csp+wbxml, application/vnd.wv.csp+xml, application/vnd.wv.ssp+xml, application/vnd.xacml+json, application/vnd.xara, application/vnd.xfdl, application/vnd.xfdl.webform, application/vnd.xmi+xml, application/vnd.xmpie.cpkg, application/vnd.xmpie.dpkg, application/vnd.xmpie.plan, application/vnd.xmpie.ppkg, application/vnd.xmpie.xlim, application/vnd.yamaha.hv-dic, application/vnd.yamaha.hv-script, application/vnd.yamaha.hv-voice, application/vnd.yamaha.openscoreformat, application/vnd.yamaha.openscoreformat.osfpvg+xml, application/vnd.yamaha.remote-setup, application/vnd.yamaha.smaf-audio, application/vnd.yamaha.smaf-phrase, application/vnd.yamaha.through-ngn, application/vnd.yamaha.tunnel-udpencap, application/vnd.yaoweme, application/vnd.yellowriver-custom-menu, application/vnd.youtube.yt, application/vnd.zul, application/vnd.zzazz.deck+xml, application/voicexml+xml, application/voucher-cms+json, application/vq-rtcpxr, application/wasm, application/watcherinfo+xml, application/webpush-options+json, application/whoispp-query, application/whoispp-response, application/widget, application/winhlp, application/wita, application/wordperfect5.1, application/wsdl+xml, application/wspolicy+xml, application/x-7z-compressed, application/x-abiword, application/x-ace-compressed, application/x-amf, application/x-apple-diskimage, application/x-arj, application/x-authorware-bin, application/x-authorware-map, application/x-authorware-seg, application/x-bcpio, application/x-bdoc, application/x-bittorrent, application/x-blorb, application/x-bzip, application/x-bzip2, application/x-cbr, application/x-cdlink, application/x-cfs-compressed, application/x-chat, application/x-chess-pgn, application/x-chrome-extension, application/x-cocoa, application/x-compress, application/x-conference, application/x-cpio, application/x-csh, application/x-deb, application/x-debian-package, application/x-dgc-compressed, application/x-director, application/x-doom, application/x-dtbncx+xml, application/x-dtbook+xml, application/x-dtbresource+xml, application/x-dvi, application/x-envoy, application/x-eva, application/x-font-bdf, application/x-font-dos, application/x-font-framemaker, application/x-font-ghostscript, application/x-font-libgrx, application/x-font-linux-psf, application/x-font-pcf, application/x-font-snf, application/x-font-speedo, application/x-font-sunos-news, application/x-font-type1, application/x-font-vfont, application/x-freearc, application/x-futuresplash, application/x-gca-compressed, application/x-glulx, application/x-gnumeric, application/x-gramps-xml, application/x-gtar, application/x-gzip, application/x-hdf, application/x-httpd-php, application/x-install-instructions, application/x-iso9660-image, application/x-java-archive-diff, application/x-java-jnlp-file, application/x-javascript, application/x-latex, application/x-lua-bytecode, application/x-lzh-compressed, application/x-makeself, application/x-mie, application/x-mobipocket-ebook, application/x-mpegurl, application/x-ms-application, application/x-ms-shortcut, application/x-ms-wmd, application/x-ms-wmz, application/x-ms-xbap, application/x-msaccess, application/x-msbinder, application/x-mscardfile, application/x-msclip, application/x-msdos-program, application/x-msdownload, application/x-msmediaview, application/x-msmetafile, application/x-msmoney, application/x-mspublisher, application/x-msschedule, application/x-msterminal, application/x-mswrite, application/x-netcdf, application/x-ns-proxy-autoconfig, application/x-nzb, application/x-perl, application/x-pilot, application/x-pkcs12, application/x-pkcs7-certificates, application/x-pkcs7-certreqresp, application/x-rar-compressed, application/x-redhat-package-manager, application/x-research-info-systems, application/x-sea, application/x-sh, application/x-shar, application/x-shockwave-flash, application/x-silverlight-app, application/x-sql, application/x-stuffit, application/x-stuffitx, application/x-subrip, application/x-sv4cpio, application/x-sv4crc, application/x-t3vm-image, application/x-tads, application/x-tar, application/x-tcl, application/x-tex, application/x-tex-tfm, application/x-texinfo, application/x-tgif, application/x-ustar, application/x-virtualbox-hdd, application/x-virtualbox-ova, application/x-virtualbox-ovf, application/x-virtualbox-vbox, application/x-virtualbox-vbox-extpack, application/x-virtualbox-vdi, application/x-virtualbox-vhd, application/x-virtualbox-vmdk, application/x-wais-source, application/x-web-app-manifest+json, application/x-www-form-urlencoded, application/x-x509-ca-cert, application/x-xfig, application/x-xliff+xml, application/x-xpinstall, application/x-xz, application/x-zmachine, application/x400-bp, application/xacml+xml, application/xaml+xml, application/xcap-att+xml, application/xcap-caps+xml, application/xcap-diff+xml, application/xcap-el+xml, application/xcap-error+xml, application/xcap-ns+xml, application/xcon-conference-info+xml, application/xcon-conference-info-diff+xml, application/xenc+xml, application/xhtml+xml, application/xhtml-voice+xml, application/xliff+xml, application/xml, application/xml-dtd, application/xml-external-parsed-entity, application/xml-patch+xml, application/xmpp+xml, application/xop+xml, application/xproc+xml, application/xslt+xml, application/xspf+xml, application/xv+xml, application/yang, application/yang-data+json, application/yang-data+xml, application/yang-patch+json, application/yang-patch+xml, application/yin+xml, application/zip, application/zlib, application/zstd, audio/1d-interleaved-parityfec, audio/32kadpcm, audio/3gpp, audio/3gpp2, audio/aac, audio/ac3, audio/adpcm, audio/amr, audio/amr-wb, audio/amr-wb+, audio/aptx, audio/asc, audio/atrac-advanced-lossless, audio/atrac-x, audio/atrac3, audio/basic, audio/bv16, audio/bv32, audio/clearmode, audio/cn, audio/dat12, audio/dls, audio/dsr-es201108, audio/dsr-es202050, audio/dsr-es202211, audio/dsr-es202212, audio/dv, audio/dvi4, audio/eac3, audio/encaprtp, audio/evrc, audio/evrc-qcp, audio/evrc0, audio/evrc1, audio/evrcb, audio/evrcb0, audio/evrcb1, audio/evrcnw, audio/evrcnw0, audio/evrcnw1, audio/evrcwb, audio/evrcwb0, audio/evrcwb1, audio/evs, audio/flexfec, audio/fwdred, audio/g711-0, audio/g719, audio/g722, audio/g7221, audio/g723, audio/g726-16, audio/g726-24, audio/g726-32, audio/g726-40, audio/g728, audio/g729, audio/g7291, audio/g729d, audio/g729e, audio/gsm, audio/gsm-efr, audio/gsm-hr-08, audio/ilbc, audio/ip-mr_v2.5, audio/isac, audio/l16, audio/l20, audio/l24, audio/l8, audio/lpc, audio/melp, audio/melp1200, audio/melp2400, audio/melp600, audio/midi, audio/mobile-xmf, audio/mp3, audio/mp4, audio/mp4a-latm, audio/mpa, audio/mpa-robust, audio/mpeg, audio/mpeg4-generic, audio/musepack, audio/ogg, audio/opus, audio/parityfec, audio/pcma, audio/pcma-wb, audio/pcmu, audio/pcmu-wb, audio/prs.sid, audio/qcelp, audio/raptorfec, audio/red, audio/rtp-enc-aescm128, audio/rtp-midi, audio/rtploopback, audio/rtx, audio/s3m, audio/silk, audio/smv, audio/smv-qcp, audio/smv0, audio/sp-midi, audio/speex, audio/t140c, audio/t38, audio/telephone-event, audio/tetra_acelp, audio/tone, audio/uemclip, audio/ulpfec, audio/usac, audio/vdvi, audio/vmr-wb, audio/vnd.3gpp.iufp, audio/vnd.4sb, audio/vnd.audiokoz, audio/vnd.celp, audio/vnd.cisco.nse, audio/vnd.cmles.radio-events, audio/vnd.cns.anp1, audio/vnd.cns.inf1, audio/vnd.dece.audio, audio/vnd.digital-winds, audio/vnd.dlna.adts, audio/vnd.dolby.heaac.1, audio/vnd.dolby.heaac.2, audio/vnd.dolby.mlp, audio/vnd.dolby.mps, audio/vnd.dolby.pl2, audio/vnd.dolby.pl2x, audio/vnd.dolby.pl2z, audio/vnd.dolby.pulse.1, audio/vnd.dra, audio/vnd.dts, audio/vnd.dts.hd, audio/vnd.dts.uhd, audio/vnd.dvb.file, audio/vnd.everad.plj, audio/vnd.hns.audio, audio/vnd.lucent.voice, audio/vnd.ms-playready.media.pya, audio/vnd.nokia.mobile-xmf, audio/vnd.nortel.vbk, audio/vnd.nuera.ecelp4800, audio/vnd.nuera.ecelp7470, audio/vnd.nuera.ecelp9600, audio/vnd.octel.sbc, audio/vnd.presonus.multitrack, audio/vnd.qcelp, audio/vnd.rhetorex.32kadpcm, audio/vnd.rip, audio/vnd.rn-realaudio, audio/vnd.sealedmedia.softseal.mpeg, audio/vnd.vmx.cvsd, audio/vnd.wave, audio/vorbis, audio/vorbis-config, audio/wav, audio/wave, audio/webm, audio/x-aac, audio/x-aiff, audio/x-caf, audio/x-flac, audio/x-m4a, audio/x-matroska, audio/x-mpegurl, audio/x-ms-wax, audio/x-ms-wma, audio/x-pn-realaudio, audio/x-pn-realaudio-plugin, audio/x-realaudio, audio/x-tta, audio/x-wav, audio/xm, chemical/x-cdx, chemical/x-cif, chemical/x-cmdf, chemical/x-cml, chemical/x-csml, chemical/x-pdb, chemical/x-xyz, font/collection, font/otf, font/sfnt, font/ttf, font/woff, font/woff2, image/aces, image/apng, image/avci, image/avcs, image/bmp, image/cgm, image/dicom-rle, image/emf, image/fits, image/g3fax, image/gif, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/hej2k, image/hsj2, image/ief, image/jls, image/jp2, image/jpeg, image/jph, image/jphc, image/jpm, image/jpx, image/jxr, image/jxra, image/jxrs, image/jxs, image/jxsc, image/jxsi, image/jxss, image/ktx, image/naplps, image/pjpeg, image/png, image/prs.btif, image/prs.pti, image/pwg-raster, image/sgi, image/svg+xml, image/t38, image/tiff, image/tiff-fx, image/vnd.adobe.photoshop, image/vnd.airzip.accelerator.azv, image/vnd.cns.inf2, image/vnd.dece.graphic, image/vnd.djvu, image/vnd.dvb.subtitle, image/vnd.dwg, image/vnd.dxf, image/vnd.fastbidsheet, image/vnd.fpx, image/vnd.fst, image/vnd.fujixerox.edmics-mmr, image/vnd.fujixerox.edmics-rlc, image/vnd.globalgraphics.pgb, image/vnd.microsoft.icon, image/vnd.mix, image/vnd.mozilla.apng, image/vnd.ms-dds, image/vnd.ms-modi, image/vnd.ms-photo, image/vnd.net-fpx, image/vnd.radiance, image/vnd.sealed.png, image/vnd.sealedmedia.softseal.gif, image/vnd.sealedmedia.softseal.jpg, image/vnd.svf, image/vnd.tencent.tap, image/vnd.valve.source.texture, image/vnd.wap.wbmp, image/vnd.xiff, image/vnd.zbrush.pcx, image/webp, image/wmf, image/x-3ds, image/x-cmu-raster, image/x-cmx, image/x-freehand, image/x-icon, image/x-jng, image/x-mrsid-image, image/x-ms-bmp, image/x-pcx, image/x-pict, image/x-portable-anymap, image/x-portable-bitmap, image/x-portable-graymap, image/x-portable-pixmap, image/x-rgb, image/x-tga, image/x-xbitmap, image/x-xcf, image/x-xpixmap, image/x-xwindowdump, message/cpim, message/delivery-status, message/disposition-notification, message/external-body, message/feedback-report, message/global, message/global-delivery-status, message/global-disposition-notification, message/global-headers, message/http, message/imdn+xml, message/news, message/partial, message/rfc822, message/s-http, message/sip, message/sipfrag, message/tracking-status, message/vnd.si.simp, message/vnd.wfa.wsc, model/3mf, model/gltf+json, model/gltf-binary, model/iges, model/mesh, model/stl, model/vnd.collada+xml, model/vnd.dwf, model/vnd.flatland.3dml, model/vnd.gdl, model/vnd.gs-gdl, model/vnd.gs.gdl, model/vnd.gtw, model/vnd.moml+xml, model/vnd.mts, model/vnd.opengex, model/vnd.parasolid.transmit.binary, model/vnd.parasolid.transmit.text, model/vnd.rosette.annotated-data-model, model/vnd.usdz+zip, model/vnd.valve.source.compiled-map, model/vnd.vtu, model/vrml, model/x3d+binary, model/x3d+fastinfoset, model/x3d+vrml, model/x3d+xml, model/x3d-vrml, multipart/alternative, multipart/appledouble, multipart/byteranges, multipart/digest, multipart/encrypted, multipart/form-data, multipart/header-set, multipart/mixed, multipart/multilingual, multipart/parallel, multipart/related, multipart/report, multipart/signed, multipart/vnd.bint.med-plus, multipart/voice-message, multipart/x-mixed-replace, text/1d-interleaved-parityfec, text/cache-manifest, text/calendar, text/calender, text/cmd, text/coffeescript, text/css, text/csv, text/csv-schema, text/directory, text/dns, text/ecmascript, text/encaprtp, text/enriched, text/flexfec, text/fwdred, text/grammar-ref-list, text/html, text/jade, text/javascript, text/jcr-cnd, text/jsx, text/less, text/markdown, text/mathml, text/mdx, text/mizar, text/n3, text/parameters, text/parityfec, text/plain, text/provenance-notation, text/prs.fallenstein.rst, text/prs.lines.tag, text/prs.prop.logic, text/raptorfec, text/red, text/rfc822-headers, text/richtext, text/rtf, text/rtp-enc-aescm128, text/rtploopback, text/rtx, text/sgml, text/shex, text/slim, text/strings, text/stylus, text/t140, text/tab-separated-values, text/troff, text/turtle, text/ulpfec, text/uri-list, text/vcard, text/vnd.a, text/vnd.abc, text/vnd.ascii-art, text/vnd.curl, text/vnd.curl.dcurl, text/vnd.curl.mcurl, text/vnd.curl.scurl, text/vnd.debian.copyright, text/vnd.dmclientscript, text/vnd.dvb.subtitle, text/vnd.esmertec.theme-descriptor, text/vnd.ficlab.flt, text/vnd.fly, text/vnd.fmi.flexstor, text/vnd.gml, text/vnd.graphviz, text/vnd.hgl, text/vnd.in3d.3dml, text/vnd.in3d.spot, text/vnd.iptc.newsml, text/vnd.iptc.nitf, text/vnd.latex-z, text/vnd.motorola.reflex, text/vnd.ms-mediapackage, text/vnd.net2phone.commcenter.command, text/vnd.radisys.msml-basic-layout, text/vnd.senx.warpscript, text/vnd.si.uricatalogue, text/vnd.sosi, text/vnd.sun.j2me.app-descriptor, text/vnd.trolltech.linguist, text/vnd.wap.si, text/vnd.wap.sl, text/vnd.wap.wml, text/vnd.wap.wmlscript, text/vtt, text/x-asm, text/x-c, text/x-component, text/x-fortran, text/x-gwt-rpc, text/x-handlebars-template, text/x-java-source, text/x-jquery-tmpl, text/x-lua, text/x-markdown, text/x-nfo, text/x-opml, text/x-org, text/x-pascal, text/x-processing, text/x-sass, text/x-scss, text/x-setext, text/x-sfv, text/x-suse-ymp, text/x-uuencode, text/x-vcalendar, text/x-vcard, text/xml, text/xml-external-parsed-entity, text/yaml, video/1d-interleaved-parityfec, video/3gpp, video/3gpp-tt, video/3gpp2, video/bmpeg, video/bt656, video/celb, video/dv, video/encaprtp, video/flexfec, video/h261, video/h263, video/h263-1998, video/h263-2000, video/h264, video/h264-rcdo, video/h264-svc, video/h265, video/iso.segment, video/jpeg, video/jpeg2000, video/jpm, video/mj2, video/mp1s, video/mp2p, video/mp2t, video/mp4, video/mp4v-es, video/mpeg, video/mpeg4-generic, video/mpv, video/nv, video/ogg, video/parityfec, video/pointer, video/quicktime, video/raptorfec, video/raw, video/rtp-enc-aescm128, video/rtploopback, video/rtx, video/smpte291, video/smpte292m, video/ulpfec, video/vc1, video/vc2, video/vnd.cctv, video/vnd.dece.hd, video/vnd.dece.mobile, video/vnd.dece.mp4, video/vnd.dece.pd, video/vnd.dece.sd, video/vnd.dece.video, video/vnd.directv.mpeg, video/vnd.directv.mpeg-tts, video/vnd.dlna.mpeg-tts, video/vnd.dvb.file, video/vnd.fvt, video/vnd.hns.video, video/vnd.iptvforum.1dparityfec-1010, video/vnd.iptvforum.1dparityfec-2005, video/vnd.iptvforum.2dparityfec-1010, video/vnd.iptvforum.2dparityfec-2005, video/vnd.iptvforum.ttsavc, video/vnd.iptvforum.ttsmpeg2, video/vnd.motorola.video, video/vnd.motorola.videop, video/vnd.mpegurl, video/vnd.ms-playready.media.pyv, video/vnd.nokia.interleaved-multimedia, video/vnd.nokia.mp4vr, video/vnd.nokia.videovoip, video/vnd.objectvideo, video/vnd.radgamettools.bink, video/vnd.radgamettools.smacker, video/vnd.sealed.mpeg1, video/vnd.sealed.mpeg4, video/vnd.sealed.swf, video/vnd.sealedmedia.softseal.mov, video/vnd.uvvu.mp4, video/vnd.vivo, video/vnd.youtube.yt, video/vp8, video/webm, video/x-f4v, video/x-fli, video/x-flv, video/x-m4v, video/x-matroska, video/x-mng, video/x-ms-asf, video/x-ms-vob, video/x-ms-wm, video/x-ms-wmv, video/x-ms-wmx, video/x-ms-wvx, video/x-msvideo, video/x-sgi-movie, video/x-smv, x-conference/x-cooltalk, x-shader/x-fragment, x-shader/x-vertex, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"application/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"application/3gpdash-qoe-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/3gpp-ims+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/a2l\":{\"source\":\"iana\"},\"application/activemessage\":{\"source\":\"iana\"},\"application/activity+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-directory+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcost+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcostparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointprop+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointpropparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-error+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/aml\":{\"source\":\"iana\"},\"application/andrew-inset\":{\"source\":\"iana\",\"extensions\":[\"ez\"]},\"application/applefile\":{\"source\":\"iana\"},\"application/applixware\":{\"source\":\"apache\",\"extensions\":[\"aw\"]},\"application/atf\":{\"source\":\"iana\"},\"application/atfx\":{\"source\":\"iana\"},\"application/atom+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atom\"]},\"application/atomcat+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomcat\"]},\"application/atomdeleted+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atomicmail\":{\"source\":\"iana\"},\"application/atomsvc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomsvc\"]},\"application/atsc-dwd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atsc-held+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atsc-rsat+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atxml\":{\"source\":\"iana\"},\"application/auth-policy+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/bacnet-xdd+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/batch-smtp\":{\"source\":\"iana\"},\"application/bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/beep+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/calendar+json\":{\"source\":\"iana\",\"compressible\":true},\"application/calendar+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/call-completion\":{\"source\":\"iana\"},\"application/cals-1840\":{\"source\":\"iana\"},\"application/cbor\":{\"source\":\"iana\"},\"application/cccex\":{\"source\":\"iana\"},\"application/ccmp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ccxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ccxml\"]},\"application/cdfx+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cdmi-capability\":{\"source\":\"iana\",\"extensions\":[\"cdmia\"]},\"application/cdmi-container\":{\"source\":\"iana\",\"extensions\":[\"cdmic\"]},\"application/cdmi-domain\":{\"source\":\"iana\",\"extensions\":[\"cdmid\"]},\"application/cdmi-object\":{\"source\":\"iana\",\"extensions\":[\"cdmio\"]},\"application/cdmi-queue\":{\"source\":\"iana\",\"extensions\":[\"cdmiq\"]},\"application/cdni\":{\"source\":\"iana\"},\"application/cea\":{\"source\":\"iana\"},\"application/cea-2018+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cellml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cfw\":{\"source\":\"iana\"},\"application/clue_info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cms\":{\"source\":\"iana\"},\"application/cnrp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-group+json\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-payload\":{\"source\":\"iana\"},\"application/commonground\":{\"source\":\"iana\"},\"application/conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cose\":{\"source\":\"iana\"},\"application/cose-key\":{\"source\":\"iana\"},\"application/cose-key-set\":{\"source\":\"iana\"},\"application/cpl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/csrattrs\":{\"source\":\"iana\"},\"application/csta+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cstadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/csvm+json\":{\"source\":\"iana\",\"compressible\":true},\"application/cu-seeme\":{\"source\":\"apache\",\"extensions\":[\"cu\"]},\"application/cwt\":{\"source\":\"iana\"},\"application/cybercash\":{\"source\":\"iana\"},\"application/dart\":{\"compressible\":true},\"application/dash+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpd\"]},\"application/dashdelta\":{\"source\":\"iana\"},\"application/davmount+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"davmount\"]},\"application/dca-rft\":{\"source\":\"iana\"},\"application/dcd\":{\"source\":\"iana\"},\"application/dec-dx\":{\"source\":\"iana\"},\"application/dialog-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom\":{\"source\":\"iana\"},\"application/dicom+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dii\":{\"source\":\"iana\"},\"application/dit\":{\"source\":\"iana\"},\"application/dns\":{\"source\":\"iana\"},\"application/dns+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dns-message\":{\"source\":\"iana\"},\"application/docbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dbk\"]},\"application/dskpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dssc+der\":{\"source\":\"iana\",\"extensions\":[\"dssc\"]},\"application/dssc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdssc\"]},\"application/dvcs\":{\"source\":\"iana\"},\"application/ecmascript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ecma\",\"es\"]},\"application/edi-consent\":{\"source\":\"iana\"},\"application/edi-x12\":{\"source\":\"iana\",\"compressible\":false},\"application/edifact\":{\"source\":\"iana\",\"compressible\":false},\"application/efi\":{\"source\":\"iana\"},\"application/emergencycalldata.comment+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.deviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.ecall.msd\":{\"source\":\"iana\"},\"application/emergencycalldata.providerinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.serviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.subscriberinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.veds+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emma+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"emma\"]},\"application/emotionml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/encaprtp\":{\"source\":\"iana\"},\"application/epp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/epub+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"epub\"]},\"application/eshop\":{\"source\":\"iana\"},\"application/exi\":{\"source\":\"iana\",\"extensions\":[\"exi\"]},\"application/expect-ct-report+json\":{\"source\":\"iana\",\"compressible\":true},\"application/fastinfoset\":{\"source\":\"iana\"},\"application/fastsoap\":{\"source\":\"iana\"},\"application/fdt+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/fhir+json\":{\"source\":\"iana\",\"compressible\":true},\"application/fhir+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/fido.trusted-apps+json\":{\"compressible\":true},\"application/fits\":{\"source\":\"iana\"},\"application/flexfec\":{\"source\":\"iana\"},\"application/font-sfnt\":{\"source\":\"iana\"},\"application/font-tdpfr\":{\"source\":\"iana\",\"extensions\":[\"pfr\"]},\"application/font-woff\":{\"source\":\"iana\",\"compressible\":false},\"application/framework-attributes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/geo+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"geojson\"]},\"application/geo+json-seq\":{\"source\":\"iana\"},\"application/geopackage+sqlite3\":{\"source\":\"iana\"},\"application/geoxacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/gltf-buffer\":{\"source\":\"iana\"},\"application/gml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gml\"]},\"application/gpx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"gpx\"]},\"application/gxf\":{\"source\":\"apache\",\"extensions\":[\"gxf\"]},\"application/gzip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gz\"]},\"application/h224\":{\"source\":\"iana\"},\"application/held+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/hjson\":{\"extensions\":[\"hjson\"]},\"application/http\":{\"source\":\"iana\"},\"application/hyperstudio\":{\"source\":\"iana\",\"extensions\":[\"stk\"]},\"application/ibe-key-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pkg-reply+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pp-data\":{\"source\":\"iana\"},\"application/iges\":{\"source\":\"iana\"},\"application/im-iscomposing+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/index\":{\"source\":\"iana\"},\"application/index.cmd\":{\"source\":\"iana\"},\"application/index.obj\":{\"source\":\"iana\"},\"application/index.response\":{\"source\":\"iana\"},\"application/index.vnd\":{\"source\":\"iana\"},\"application/inkml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ink\",\"inkml\"]},\"application/iotp\":{\"source\":\"iana\"},\"application/ipfix\":{\"source\":\"iana\",\"extensions\":[\"ipfix\"]},\"application/ipp\":{\"source\":\"iana\"},\"application/isup\":{\"source\":\"iana\"},\"application/its+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/java-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jar\",\"war\",\"ear\"]},\"application/java-serialized-object\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"ser\"]},\"application/java-vm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"class\"]},\"application/javascript\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"js\",\"mjs\"]},\"application/jf2feed+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jose\":{\"source\":\"iana\"},\"application/jose+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jrd+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"json\",\"map\"]},\"application/json-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json-seq\":{\"source\":\"iana\"},\"application/json5\":{\"extensions\":[\"json5\"]},\"application/jsonml+json\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"jsonml\"]},\"application/jwk+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwk-set+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwt\":{\"source\":\"iana\"},\"application/kpml-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/kpml-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ld+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"jsonld\"]},\"application/lgr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/link-format\":{\"source\":\"iana\"},\"application/load-control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lost+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lostxml\"]},\"application/lostsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lxf\":{\"source\":\"iana\"},\"application/mac-binhex40\":{\"source\":\"iana\",\"extensions\":[\"hqx\"]},\"application/mac-compactpro\":{\"source\":\"apache\",\"extensions\":[\"cpt\"]},\"application/macwriteii\":{\"source\":\"iana\"},\"application/mads+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mads\"]},\"application/manifest+json\":{\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"webmanifest\"]},\"application/marc\":{\"source\":\"iana\",\"extensions\":[\"mrc\"]},\"application/marcxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mrcx\"]},\"application/mathematica\":{\"source\":\"iana\",\"extensions\":[\"ma\",\"nb\",\"mb\"]},\"application/mathml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mathml\"]},\"application/mathml-content+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mathml-presentation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-associated-procedure-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-deregister+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-envelope+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-protection-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-reception-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-schedule+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-user-service-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbox\":{\"source\":\"iana\",\"extensions\":[\"mbox\"]},\"application/media-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/media_control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mediaservercontrol+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mscml\"]},\"application/merge-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/metalink+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"metalink\"]},\"application/metalink4+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"meta4\"]},\"application/mets+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mets\"]},\"application/mf4\":{\"source\":\"iana\"},\"application/mikey\":{\"source\":\"iana\"},\"application/mipc\":{\"source\":\"iana\"},\"application/mmt-aei+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mmt-usd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mods+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mods\"]},\"application/moss-keys\":{\"source\":\"iana\"},\"application/moss-signature\":{\"source\":\"iana\"},\"application/mosskey-data\":{\"source\":\"iana\"},\"application/mosskey-request\":{\"source\":\"iana\"},\"application/mp21\":{\"source\":\"iana\",\"extensions\":[\"m21\",\"mp21\"]},\"application/mp4\":{\"source\":\"iana\",\"extensions\":[\"mp4s\",\"m4p\"]},\"application/mpeg4-generic\":{\"source\":\"iana\"},\"application/mpeg4-iod\":{\"source\":\"iana\"},\"application/mpeg4-iod-xmt\":{\"source\":\"iana\"},\"application/mrb-consumer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mrb-publish+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msc-ivr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msc-mixer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msword\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"doc\",\"dot\"]},\"application/mud+json\":{\"source\":\"iana\",\"compressible\":true},\"application/mxf\":{\"source\":\"iana\",\"extensions\":[\"mxf\"]},\"application/n-quads\":{\"source\":\"iana\",\"extensions\":[\"nq\"]},\"application/n-triples\":{\"source\":\"iana\",\"extensions\":[\"nt\"]},\"application/nasdata\":{\"source\":\"iana\"},\"application/news-checkgroups\":{\"source\":\"iana\"},\"application/news-groupinfo\":{\"source\":\"iana\"},\"application/news-transmission\":{\"source\":\"iana\"},\"application/nlsml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/node\":{\"source\":\"iana\"},\"application/nss\":{\"source\":\"iana\"},\"application/ocsp-request\":{\"source\":\"iana\"},\"application/ocsp-response\":{\"source\":\"iana\"},\"application/octet-stream\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"bin\",\"dms\",\"lrf\",\"mar\",\"so\",\"dist\",\"distz\",\"pkg\",\"bpk\",\"dump\",\"elc\",\"deploy\",\"exe\",\"dll\",\"deb\",\"dmg\",\"iso\",\"img\",\"msi\",\"msp\",\"msm\",\"buffer\"]},\"application/oda\":{\"source\":\"iana\",\"extensions\":[\"oda\"]},\"application/odm+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/odx\":{\"source\":\"iana\"},\"application/oebps-package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"opf\"]},\"application/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogx\"]},\"application/omdoc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"omdoc\"]},\"application/onenote\":{\"source\":\"apache\",\"extensions\":[\"onetoc\",\"onetoc2\",\"onetmp\",\"onepkg\"]},\"application/oscore\":{\"source\":\"iana\"},\"application/oxps\":{\"source\":\"iana\",\"extensions\":[\"oxps\"]},\"application/p2p-overlay+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/parityfec\":{\"source\":\"iana\"},\"application/passport\":{\"source\":\"iana\"},\"application/patch-ops-error+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xer\"]},\"application/pdf\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pdf\"]},\"application/pdx\":{\"source\":\"iana\"},\"application/pem-certificate-chain\":{\"source\":\"iana\"},\"application/pgp-encrypted\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pgp\"]},\"application/pgp-keys\":{\"source\":\"iana\"},\"application/pgp-signature\":{\"source\":\"iana\",\"extensions\":[\"asc\",\"sig\"]},\"application/pics-rules\":{\"source\":\"apache\",\"extensions\":[\"prf\"]},\"application/pidf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pidf-diff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pkcs10\":{\"source\":\"iana\",\"extensions\":[\"p10\"]},\"application/pkcs12\":{\"source\":\"iana\"},\"application/pkcs7-mime\":{\"source\":\"iana\",\"extensions\":[\"p7m\",\"p7c\"]},\"application/pkcs7-signature\":{\"source\":\"iana\",\"extensions\":[\"p7s\"]},\"application/pkcs8\":{\"source\":\"iana\",\"extensions\":[\"p8\"]},\"application/pkcs8-encrypted\":{\"source\":\"iana\"},\"application/pkix-attr-cert\":{\"source\":\"iana\",\"extensions\":[\"ac\"]},\"application/pkix-cert\":{\"source\":\"iana\",\"extensions\":[\"cer\"]},\"application/pkix-crl\":{\"source\":\"iana\",\"extensions\":[\"crl\"]},\"application/pkix-pkipath\":{\"source\":\"iana\",\"extensions\":[\"pkipath\"]},\"application/pkixcmp\":{\"source\":\"iana\",\"extensions\":[\"pki\"]},\"application/pls+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pls\"]},\"application/poc-settings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/postscript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ai\",\"eps\",\"ps\"]},\"application/ppsp-tracker+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/provenance+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/prs.alvestrand.titrax-sheet\":{\"source\":\"iana\"},\"application/prs.cww\":{\"source\":\"iana\",\"extensions\":[\"cww\"]},\"application/prs.hpub+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/prs.nprend\":{\"source\":\"iana\"},\"application/prs.plucker\":{\"source\":\"iana\"},\"application/prs.rdf-xml-crypt\":{\"source\":\"iana\"},\"application/prs.xsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pskc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pskcxml\"]},\"application/qsig\":{\"source\":\"iana\"},\"application/raml+yaml\":{\"compressible\":true,\"extensions\":[\"raml\"]},\"application/raptorfec\":{\"source\":\"iana\"},\"application/rdap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/rdf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rdf\",\"owl\"]},\"application/reginfo+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rif\"]},\"application/relax-ng-compact-syntax\":{\"source\":\"iana\",\"extensions\":[\"rnc\"]},\"application/remote-printing\":{\"source\":\"iana\"},\"application/reputon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/resource-lists+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rl\"]},\"application/resource-lists-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rld\"]},\"application/rfc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/riscos\":{\"source\":\"iana\"},\"application/rlmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/rls-services+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rs\"]},\"application/route-apd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/route-s-tsid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/route-usd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/rpki-ghostbusters\":{\"source\":\"iana\",\"extensions\":[\"gbr\"]},\"application/rpki-manifest\":{\"source\":\"iana\",\"extensions\":[\"mft\"]},\"application/rpki-publication\":{\"source\":\"iana\"},\"application/rpki-roa\":{\"source\":\"iana\",\"extensions\":[\"roa\"]},\"application/rpki-updown\":{\"source\":\"iana\"},\"application/rsd+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rsd\"]},\"application/rss+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rss\"]},\"application/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"application/rtploopback\":{\"source\":\"iana\"},\"application/rtx\":{\"source\":\"iana\"},\"application/samlassertion+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/samlmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sbml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sbml\"]},\"application/scaip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/scim+json\":{\"source\":\"iana\",\"compressible\":true},\"application/scvp-cv-request\":{\"source\":\"iana\",\"extensions\":[\"scq\"]},\"application/scvp-cv-response\":{\"source\":\"iana\",\"extensions\":[\"scs\"]},\"application/scvp-vp-request\":{\"source\":\"iana\",\"extensions\":[\"spq\"]},\"application/scvp-vp-response\":{\"source\":\"iana\",\"extensions\":[\"spp\"]},\"application/sdp\":{\"source\":\"iana\",\"extensions\":[\"sdp\"]},\"application/secevent+jwt\":{\"source\":\"iana\"},\"application/senml+cbor\":{\"source\":\"iana\"},\"application/senml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/senml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/senml-exi\":{\"source\":\"iana\"},\"application/sensml+cbor\":{\"source\":\"iana\"},\"application/sensml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/sensml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sensml-exi\":{\"source\":\"iana\"},\"application/sep+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sep-exi\":{\"source\":\"iana\"},\"application/session-info\":{\"source\":\"iana\"},\"application/set-payment\":{\"source\":\"iana\"},\"application/set-payment-initiation\":{\"source\":\"iana\",\"extensions\":[\"setpay\"]},\"application/set-registration\":{\"source\":\"iana\"},\"application/set-registration-initiation\":{\"source\":\"iana\",\"extensions\":[\"setreg\"]},\"application/sgml\":{\"source\":\"iana\"},\"application/sgml-open-catalog\":{\"source\":\"iana\"},\"application/shf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"shf\"]},\"application/sieve\":{\"source\":\"iana\",\"extensions\":[\"siv\",\"sieve\"]},\"application/simple-filter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/simple-message-summary\":{\"source\":\"iana\"},\"application/simplesymbolcontainer\":{\"source\":\"iana\"},\"application/sipc\":{\"source\":\"iana\"},\"application/slate\":{\"source\":\"iana\"},\"application/smil\":{\"source\":\"iana\"},\"application/smil+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"smi\",\"smil\"]},\"application/smpte336m\":{\"source\":\"iana\"},\"application/soap+fastinfoset\":{\"source\":\"iana\"},\"application/soap+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sparql-query\":{\"source\":\"iana\",\"extensions\":[\"rq\"]},\"application/sparql-results+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"srx\"]},\"application/spirits-event+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sql\":{\"source\":\"iana\"},\"application/srgs\":{\"source\":\"iana\",\"extensions\":[\"gram\"]},\"application/srgs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"grxml\"]},\"application/sru+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sru\"]},\"application/ssdl+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ssdl\"]},\"application/ssml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ssml\"]},\"application/stix+json\":{\"source\":\"iana\",\"compressible\":true},\"application/swid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/tamp-apex-update\":{\"source\":\"iana\"},\"application/tamp-apex-update-confirm\":{\"source\":\"iana\"},\"application/tamp-community-update\":{\"source\":\"iana\"},\"application/tamp-community-update-confirm\":{\"source\":\"iana\"},\"application/tamp-error\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust-confirm\":{\"source\":\"iana\"},\"application/tamp-status-query\":{\"source\":\"iana\"},\"application/tamp-status-response\":{\"source\":\"iana\"},\"application/tamp-update\":{\"source\":\"iana\"},\"application/tamp-update-confirm\":{\"source\":\"iana\"},\"application/tar\":{\"compressible\":true},\"application/taxii+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tei+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tei\",\"teicorpus\"]},\"application/tetra_isi\":{\"source\":\"iana\"},\"application/thraud+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tfi\"]},\"application/timestamp-query\":{\"source\":\"iana\"},\"application/timestamp-reply\":{\"source\":\"iana\"},\"application/timestamped-data\":{\"source\":\"iana\",\"extensions\":[\"tsd\"]},\"application/tlsrpt+gzip\":{\"source\":\"iana\"},\"application/tlsrpt+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tnauthlist\":{\"source\":\"iana\"},\"application/toml\":{\"compressible\":true,\"extensions\":[\"toml\"]},\"application/trickle-ice-sdpfrag\":{\"source\":\"iana\"},\"application/trig\":{\"source\":\"iana\"},\"application/ttml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/tve-trigger\":{\"source\":\"iana\"},\"application/tzif\":{\"source\":\"iana\"},\"application/tzif-leap\":{\"source\":\"iana\"},\"application/ulpfec\":{\"source\":\"iana\"},\"application/urc-grpsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-ressheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-targetdesc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-uisocketdesc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vemmi\":{\"source\":\"iana\"},\"application/vividence.scriptfile\":{\"source\":\"apache\"},\"application/vnd.1000minds.decision-model+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-prose+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-prose-pc3ch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-v2x-local-service-information\":{\"source\":\"iana\"},\"application/vnd.3gpp.access-transfer-events+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.bsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.gmop+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mc-signalling-ear\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-payload\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-signalling\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-floor-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-signed+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-init-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-transmission-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mid-call+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.pic-bw-large\":{\"source\":\"iana\",\"extensions\":[\"plb\"]},\"application/vnd.3gpp.pic-bw-small\":{\"source\":\"iana\",\"extensions\":[\"psb\"]},\"application/vnd.3gpp.pic-bw-var\":{\"source\":\"iana\",\"extensions\":[\"pvb\"]},\"application/vnd.3gpp.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp.sms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-ext+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.state-and-event-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.ussd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.bcmcsinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp2.tcap\":{\"source\":\"iana\",\"extensions\":[\"tcap\"]},\"application/vnd.3lightssoftware.imagescal\":{\"source\":\"iana\"},\"application/vnd.3m.post-it-notes\":{\"source\":\"iana\",\"extensions\":[\"pwn\"]},\"application/vnd.accpac.simply.aso\":{\"source\":\"iana\",\"extensions\":[\"aso\"]},\"application/vnd.accpac.simply.imp\":{\"source\":\"iana\",\"extensions\":[\"imp\"]},\"application/vnd.acucobol\":{\"source\":\"iana\",\"extensions\":[\"acu\"]},\"application/vnd.acucorp\":{\"source\":\"iana\",\"extensions\":[\"atc\",\"acutc\"]},\"application/vnd.adobe.air-application-installer-package+zip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"air\"]},\"application/vnd.adobe.flash.movie\":{\"source\":\"iana\"},\"application/vnd.adobe.formscentral.fcdt\":{\"source\":\"iana\",\"extensions\":[\"fcdt\"]},\"application/vnd.adobe.fxp\":{\"source\":\"iana\",\"extensions\":[\"fxp\",\"fxpl\"]},\"application/vnd.adobe.partial-upload\":{\"source\":\"iana\"},\"application/vnd.adobe.xdp+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdp\"]},\"application/vnd.adobe.xfdf\":{\"source\":\"iana\",\"extensions\":[\"xfdf\"]},\"application/vnd.aether.imp\":{\"source\":\"iana\"},\"application/vnd.afpc.afplinedata\":{\"source\":\"iana\"},\"application/vnd.afpc.modca\":{\"source\":\"iana\"},\"application/vnd.ah-barcode\":{\"source\":\"iana\"},\"application/vnd.ahead.space\":{\"source\":\"iana\",\"extensions\":[\"ahead\"]},\"application/vnd.airzip.filesecure.azf\":{\"source\":\"iana\",\"extensions\":[\"azf\"]},\"application/vnd.airzip.filesecure.azs\":{\"source\":\"iana\",\"extensions\":[\"azs\"]},\"application/vnd.amadeus+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.amazon.ebook\":{\"source\":\"apache\",\"extensions\":[\"azw\"]},\"application/vnd.amazon.mobi8-ebook\":{\"source\":\"iana\"},\"application/vnd.americandynamics.acc\":{\"source\":\"iana\",\"extensions\":[\"acc\"]},\"application/vnd.amiga.ami\":{\"source\":\"iana\",\"extensions\":[\"ami\"]},\"application/vnd.amundsen.maze+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.android.ota\":{\"source\":\"iana\"},\"application/vnd.android.package-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"apk\"]},\"application/vnd.anki\":{\"source\":\"iana\"},\"application/vnd.anser-web-certificate-issue-initiation\":{\"source\":\"iana\",\"extensions\":[\"cii\"]},\"application/vnd.anser-web-funds-transfer-initiation\":{\"source\":\"apache\",\"extensions\":[\"fti\"]},\"application/vnd.antix.game-component\":{\"source\":\"iana\",\"extensions\":[\"atx\"]},\"application/vnd.apache.thrift.binary\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.compact\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.json\":{\"source\":\"iana\"},\"application/vnd.api+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apothekende.reservation+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apple.installer+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpkg\"]},\"application/vnd.apple.keynote\":{\"source\":\"iana\",\"extensions\":[\"keynote\"]},\"application/vnd.apple.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"m3u8\"]},\"application/vnd.apple.numbers\":{\"source\":\"iana\",\"extensions\":[\"numbers\"]},\"application/vnd.apple.pages\":{\"source\":\"iana\",\"extensions\":[\"pages\"]},\"application/vnd.apple.pkpass\":{\"compressible\":false,\"extensions\":[\"pkpass\"]},\"application/vnd.arastra.swi\":{\"source\":\"iana\"},\"application/vnd.aristanetworks.swi\":{\"source\":\"iana\",\"extensions\":[\"swi\"]},\"application/vnd.artisan+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.artsquare\":{\"source\":\"iana\"},\"application/vnd.astraea-software.iota\":{\"source\":\"iana\",\"extensions\":[\"iota\"]},\"application/vnd.audiograph\":{\"source\":\"iana\",\"extensions\":[\"aep\"]},\"application/vnd.autopackage\":{\"source\":\"iana\"},\"application/vnd.avalon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.avistar+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.balsamiq.bmml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.balsamiq.bmpr\":{\"source\":\"iana\"},\"application/vnd.banana-accounting\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.error\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bekitzur-stech+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bint.med-content\":{\"source\":\"iana\"},\"application/vnd.biopax.rdf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.blink-idb-value-wrapper\":{\"source\":\"iana\"},\"application/vnd.blueice.multipass\":{\"source\":\"iana\",\"extensions\":[\"mpm\"]},\"application/vnd.bluetooth.ep.oob\":{\"source\":\"iana\"},\"application/vnd.bluetooth.le.oob\":{\"source\":\"iana\"},\"application/vnd.bmi\":{\"source\":\"iana\",\"extensions\":[\"bmi\"]},\"application/vnd.bpf\":{\"source\":\"iana\"},\"application/vnd.bpf3\":{\"source\":\"iana\"},\"application/vnd.businessobjects\":{\"source\":\"iana\",\"extensions\":[\"rep\"]},\"application/vnd.byu.uapi+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cab-jscript\":{\"source\":\"iana\"},\"application/vnd.canon-cpdl\":{\"source\":\"iana\"},\"application/vnd.canon-lips\":{\"source\":\"iana\"},\"application/vnd.capasystems-pg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cendio.thinlinc.clientconf\":{\"source\":\"iana\"},\"application/vnd.century-systems.tcp_stream\":{\"source\":\"iana\"},\"application/vnd.chemdraw+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"cdxml\"]},\"application/vnd.chess-pgn\":{\"source\":\"iana\"},\"application/vnd.chipnuts.karaoke-mmd\":{\"source\":\"iana\",\"extensions\":[\"mmd\"]},\"application/vnd.ciedi\":{\"source\":\"iana\"},\"application/vnd.cinderella\":{\"source\":\"iana\",\"extensions\":[\"cdy\"]},\"application/vnd.cirpack.isdn-ext\":{\"source\":\"iana\"},\"application/vnd.citationstyles.style+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csl\"]},\"application/vnd.claymore\":{\"source\":\"iana\",\"extensions\":[\"cla\"]},\"application/vnd.cloanto.rp9\":{\"source\":\"iana\",\"extensions\":[\"rp9\"]},\"application/vnd.clonk.c4group\":{\"source\":\"iana\",\"extensions\":[\"c4g\",\"c4d\",\"c4f\",\"c4p\",\"c4u\"]},\"application/vnd.cluetrust.cartomobile-config\":{\"source\":\"iana\",\"extensions\":[\"c11amc\"]},\"application/vnd.cluetrust.cartomobile-config-pkg\":{\"source\":\"iana\",\"extensions\":[\"c11amz\"]},\"application/vnd.coffeescript\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet-template\":{\"source\":\"iana\"},\"application/vnd.collection+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.doc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.next+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.comicbook+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.comicbook-rar\":{\"source\":\"iana\"},\"application/vnd.commerce-battelle\":{\"source\":\"iana\"},\"application/vnd.commonspace\":{\"source\":\"iana\",\"extensions\":[\"csp\"]},\"application/vnd.contact.cmsg\":{\"source\":\"iana\",\"extensions\":[\"cdbcmsg\"]},\"application/vnd.coreos.ignition+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cosmocaller\":{\"source\":\"iana\",\"extensions\":[\"cmc\"]},\"application/vnd.crick.clicker\":{\"source\":\"iana\",\"extensions\":[\"clkx\"]},\"application/vnd.crick.clicker.keyboard\":{\"source\":\"iana\",\"extensions\":[\"clkk\"]},\"application/vnd.crick.clicker.palette\":{\"source\":\"iana\",\"extensions\":[\"clkp\"]},\"application/vnd.crick.clicker.template\":{\"source\":\"iana\",\"extensions\":[\"clkt\"]},\"application/vnd.crick.clicker.wordbank\":{\"source\":\"iana\",\"extensions\":[\"clkw\"]},\"application/vnd.criticaltools.wbs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wbs\"]},\"application/vnd.cryptii.pipe+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.crypto-shade-file\":{\"source\":\"iana\"},\"application/vnd.ctc-posml\":{\"source\":\"iana\",\"extensions\":[\"pml\"]},\"application/vnd.ctct.ws+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cups-pdf\":{\"source\":\"iana\"},\"application/vnd.cups-postscript\":{\"source\":\"iana\"},\"application/vnd.cups-ppd\":{\"source\":\"iana\",\"extensions\":[\"ppd\"]},\"application/vnd.cups-raster\":{\"source\":\"iana\"},\"application/vnd.cups-raw\":{\"source\":\"iana\"},\"application/vnd.curl\":{\"source\":\"iana\"},\"application/vnd.curl.car\":{\"source\":\"apache\",\"extensions\":[\"car\"]},\"application/vnd.curl.pcurl\":{\"source\":\"apache\",\"extensions\":[\"pcurl\"]},\"application/vnd.cyan.dean.root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cybank\":{\"source\":\"iana\"},\"application/vnd.d2l.coursepackage1p0+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.dart\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dart\"]},\"application/vnd.data-vision.rdz\":{\"source\":\"iana\",\"extensions\":[\"rdz\"]},\"application/vnd.datapackage+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dataresource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.debian.binary-package\":{\"source\":\"iana\"},\"application/vnd.dece.data\":{\"source\":\"iana\",\"extensions\":[\"uvf\",\"uvvf\",\"uvd\",\"uvvd\"]},\"application/vnd.dece.ttml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uvt\",\"uvvt\"]},\"application/vnd.dece.unspecified\":{\"source\":\"iana\",\"extensions\":[\"uvx\",\"uvvx\"]},\"application/vnd.dece.zip\":{\"source\":\"iana\",\"extensions\":[\"uvz\",\"uvvz\"]},\"application/vnd.denovo.fcselayout-link\":{\"source\":\"iana\",\"extensions\":[\"fe_launch\"]},\"application/vnd.desmume.movie\":{\"source\":\"iana\"},\"application/vnd.dir-bi.plate-dl-nosuffix\":{\"source\":\"iana\"},\"application/vnd.dm.delegation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dna\":{\"source\":\"iana\",\"extensions\":[\"dna\"]},\"application/vnd.document+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dolby.mlp\":{\"source\":\"apache\",\"extensions\":[\"mlp\"]},\"application/vnd.dolby.mobile.1\":{\"source\":\"iana\"},\"application/vnd.dolby.mobile.2\":{\"source\":\"iana\"},\"application/vnd.doremir.scorecloud-binary-document\":{\"source\":\"iana\"},\"application/vnd.dpgraph\":{\"source\":\"iana\",\"extensions\":[\"dpg\"]},\"application/vnd.dreamfactory\":{\"source\":\"iana\",\"extensions\":[\"dfac\"]},\"application/vnd.drive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ds-keypoint\":{\"source\":\"apache\",\"extensions\":[\"kpxx\"]},\"application/vnd.dtg.local\":{\"source\":\"iana\"},\"application/vnd.dtg.local.flash\":{\"source\":\"iana\"},\"application/vnd.dtg.local.html\":{\"source\":\"iana\"},\"application/vnd.dvb.ait\":{\"source\":\"iana\",\"extensions\":[\"ait\"]},\"application/vnd.dvb.dvbj\":{\"source\":\"iana\"},\"application/vnd.dvb.esgcontainer\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcdftnotifaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess2\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgpdd\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcroaming\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-base\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-enhancement\":{\"source\":\"iana\"},\"application/vnd.dvb.notif-aggregate-root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-container+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-generic+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-msglist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-init+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.pfr\":{\"source\":\"iana\"},\"application/vnd.dvb.service\":{\"source\":\"iana\",\"extensions\":[\"svc\"]},\"application/vnd.dxr\":{\"source\":\"iana\"},\"application/vnd.dynageo\":{\"source\":\"iana\",\"extensions\":[\"geo\"]},\"application/vnd.dzr\":{\"source\":\"iana\"},\"application/vnd.easykaraoke.cdgdownload\":{\"source\":\"iana\"},\"application/vnd.ecdis-update\":{\"source\":\"iana\"},\"application/vnd.ecip.rlp\":{\"source\":\"iana\"},\"application/vnd.ecowin.chart\":{\"source\":\"iana\",\"extensions\":[\"mag\"]},\"application/vnd.ecowin.filerequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.fileupdate\":{\"source\":\"iana\"},\"application/vnd.ecowin.series\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesrequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesupdate\":{\"source\":\"iana\"},\"application/vnd.efi.img\":{\"source\":\"iana\"},\"application/vnd.efi.iso\":{\"source\":\"iana\"},\"application/vnd.emclient.accessrequest+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.enliven\":{\"source\":\"iana\",\"extensions\":[\"nml\"]},\"application/vnd.enphase.envoy\":{\"source\":\"iana\"},\"application/vnd.eprints.data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.epson.esf\":{\"source\":\"iana\",\"extensions\":[\"esf\"]},\"application/vnd.epson.msf\":{\"source\":\"iana\",\"extensions\":[\"msf\"]},\"application/vnd.epson.quickanime\":{\"source\":\"iana\",\"extensions\":[\"qam\"]},\"application/vnd.epson.salt\":{\"source\":\"iana\",\"extensions\":[\"slt\"]},\"application/vnd.epson.ssf\":{\"source\":\"iana\",\"extensions\":[\"ssf\"]},\"application/vnd.ericsson.quickcall\":{\"source\":\"iana\"},\"application/vnd.espass-espass+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.eszigno3+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"es3\",\"et3\"]},\"application/vnd.etsi.aoc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.asic-e+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.asic-s+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.cug+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvcommand+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-bc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-cod+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-npvr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvservice+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mcid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mheg5\":{\"source\":\"iana\"},\"application/vnd.etsi.overload-control-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.pstn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.sci+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.simservs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.timestamp-token\":{\"source\":\"iana\"},\"application/vnd.etsi.tsl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.tsl.der\":{\"source\":\"iana\"},\"application/vnd.eudora.data\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.profile\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.settings\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.theme\":{\"source\":\"iana\"},\"application/vnd.exstream-empower+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.exstream-package\":{\"source\":\"iana\"},\"application/vnd.ezpix-album\":{\"source\":\"iana\",\"extensions\":[\"ez2\"]},\"application/vnd.ezpix-package\":{\"source\":\"iana\",\"extensions\":[\"ez3\"]},\"application/vnd.f-secure.mobile\":{\"source\":\"iana\"},\"application/vnd.fastcopy-disk-image\":{\"source\":\"iana\"},\"application/vnd.fdf\":{\"source\":\"iana\",\"extensions\":[\"fdf\"]},\"application/vnd.fdsn.mseed\":{\"source\":\"iana\",\"extensions\":[\"mseed\"]},\"application/vnd.fdsn.seed\":{\"source\":\"iana\",\"extensions\":[\"seed\",\"dataless\"]},\"application/vnd.ffsns\":{\"source\":\"iana\"},\"application/vnd.ficlab.flb+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.filmit.zfc\":{\"source\":\"iana\"},\"application/vnd.fints\":{\"source\":\"iana\"},\"application/vnd.firemonkeys.cloudcell\":{\"source\":\"iana\"},\"application/vnd.flographit\":{\"source\":\"iana\",\"extensions\":[\"gph\"]},\"application/vnd.fluxtime.clip\":{\"source\":\"iana\",\"extensions\":[\"ftc\"]},\"application/vnd.font-fontforge-sfd\":{\"source\":\"iana\"},\"application/vnd.framemaker\":{\"source\":\"iana\",\"extensions\":[\"fm\",\"frame\",\"maker\",\"book\"]},\"application/vnd.frogans.fnc\":{\"source\":\"iana\",\"extensions\":[\"fnc\"]},\"application/vnd.frogans.ltf\":{\"source\":\"iana\",\"extensions\":[\"ltf\"]},\"application/vnd.fsc.weblaunch\":{\"source\":\"iana\",\"extensions\":[\"fsc\"]},\"application/vnd.fujitsu.oasys\":{\"source\":\"iana\",\"extensions\":[\"oas\"]},\"application/vnd.fujitsu.oasys2\":{\"source\":\"iana\",\"extensions\":[\"oa2\"]},\"application/vnd.fujitsu.oasys3\":{\"source\":\"iana\",\"extensions\":[\"oa3\"]},\"application/vnd.fujitsu.oasysgp\":{\"source\":\"iana\",\"extensions\":[\"fg5\"]},\"application/vnd.fujitsu.oasysprs\":{\"source\":\"iana\",\"extensions\":[\"bh2\"]},\"application/vnd.fujixerox.art-ex\":{\"source\":\"iana\"},\"application/vnd.fujixerox.art4\":{\"source\":\"iana\"},\"application/vnd.fujixerox.ddd\":{\"source\":\"iana\",\"extensions\":[\"ddd\"]},\"application/vnd.fujixerox.docuworks\":{\"source\":\"iana\",\"extensions\":[\"xdw\"]},\"application/vnd.fujixerox.docuworks.binder\":{\"source\":\"iana\",\"extensions\":[\"xbd\"]},\"application/vnd.fujixerox.docuworks.container\":{\"source\":\"iana\"},\"application/vnd.fujixerox.hbpl\":{\"source\":\"iana\"},\"application/vnd.fut-misnet\":{\"source\":\"iana\"},\"application/vnd.futoin+cbor\":{\"source\":\"iana\"},\"application/vnd.futoin+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.fuzzysheet\":{\"source\":\"iana\",\"extensions\":[\"fzs\"]},\"application/vnd.genomatix.tuxedo\":{\"source\":\"iana\",\"extensions\":[\"txd\"]},\"application/vnd.geo+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geocube+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geogebra.file\":{\"source\":\"iana\",\"extensions\":[\"ggb\"]},\"application/vnd.geogebra.tool\":{\"source\":\"iana\",\"extensions\":[\"ggt\"]},\"application/vnd.geometry-explorer\":{\"source\":\"iana\",\"extensions\":[\"gex\",\"gre\"]},\"application/vnd.geonext\":{\"source\":\"iana\",\"extensions\":[\"gxt\"]},\"application/vnd.geoplan\":{\"source\":\"iana\",\"extensions\":[\"g2w\"]},\"application/vnd.geospace\":{\"source\":\"iana\",\"extensions\":[\"g3w\"]},\"application/vnd.gerber\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt-response\":{\"source\":\"iana\"},\"application/vnd.gmx\":{\"source\":\"iana\",\"extensions\":[\"gmx\"]},\"application/vnd.google-apps.document\":{\"compressible\":false,\"extensions\":[\"gdoc\"]},\"application/vnd.google-apps.presentation\":{\"compressible\":false,\"extensions\":[\"gslides\"]},\"application/vnd.google-apps.spreadsheet\":{\"compressible\":false,\"extensions\":[\"gsheet\"]},\"application/vnd.google-earth.kml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"kml\"]},\"application/vnd.google-earth.kmz\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"kmz\"]},\"application/vnd.gov.sk.e-form+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.gov.sk.e-form+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.gov.sk.xmldatacontainer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.grafeq\":{\"source\":\"iana\",\"extensions\":[\"gqf\",\"gqs\"]},\"application/vnd.gridmp\":{\"source\":\"iana\"},\"application/vnd.groove-account\":{\"source\":\"iana\",\"extensions\":[\"gac\"]},\"application/vnd.groove-help\":{\"source\":\"iana\",\"extensions\":[\"ghf\"]},\"application/vnd.groove-identity-message\":{\"source\":\"iana\",\"extensions\":[\"gim\"]},\"application/vnd.groove-injector\":{\"source\":\"iana\",\"extensions\":[\"grv\"]},\"application/vnd.groove-tool-message\":{\"source\":\"iana\",\"extensions\":[\"gtm\"]},\"application/vnd.groove-tool-template\":{\"source\":\"iana\",\"extensions\":[\"tpl\"]},\"application/vnd.groove-vcard\":{\"source\":\"iana\",\"extensions\":[\"vcg\"]},\"application/vnd.hal+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hal+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"hal\"]},\"application/vnd.handheld-entertainment+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zmm\"]},\"application/vnd.hbci\":{\"source\":\"iana\",\"extensions\":[\"hbci\"]},\"application/vnd.hc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hcl-bireports\":{\"source\":\"iana\"},\"application/vnd.hdt\":{\"source\":\"iana\"},\"application/vnd.heroku+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hhe.lesson-player\":{\"source\":\"iana\",\"extensions\":[\"les\"]},\"application/vnd.hp-hpgl\":{\"source\":\"iana\",\"extensions\":[\"hpgl\"]},\"application/vnd.hp-hpid\":{\"source\":\"iana\",\"extensions\":[\"hpid\"]},\"application/vnd.hp-hps\":{\"source\":\"iana\",\"extensions\":[\"hps\"]},\"application/vnd.hp-jlyt\":{\"source\":\"iana\",\"extensions\":[\"jlt\"]},\"application/vnd.hp-pcl\":{\"source\":\"iana\",\"extensions\":[\"pcl\"]},\"application/vnd.hp-pclxl\":{\"source\":\"iana\",\"extensions\":[\"pclxl\"]},\"application/vnd.httphone\":{\"source\":\"iana\"},\"application/vnd.hydrostatix.sof-data\":{\"source\":\"iana\",\"extensions\":[\"sfd-hdstx\"]},\"application/vnd.hyper+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyper-item+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyperdrive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hzn-3d-crossword\":{\"source\":\"iana\"},\"application/vnd.ibm.afplinedata\":{\"source\":\"iana\"},\"application/vnd.ibm.electronic-media\":{\"source\":\"iana\"},\"application/vnd.ibm.minipay\":{\"source\":\"iana\",\"extensions\":[\"mpy\"]},\"application/vnd.ibm.modcap\":{\"source\":\"iana\",\"extensions\":[\"afp\",\"listafp\",\"list3820\"]},\"application/vnd.ibm.rights-management\":{\"source\":\"iana\",\"extensions\":[\"irm\"]},\"application/vnd.ibm.secure-container\":{\"source\":\"iana\",\"extensions\":[\"sc\"]},\"application/vnd.iccprofile\":{\"source\":\"iana\",\"extensions\":[\"icc\",\"icm\"]},\"application/vnd.ieee.1905\":{\"source\":\"iana\"},\"application/vnd.igloader\":{\"source\":\"iana\",\"extensions\":[\"igl\"]},\"application/vnd.imagemeter.folder+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.imagemeter.image+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.immervision-ivp\":{\"source\":\"iana\",\"extensions\":[\"ivp\"]},\"application/vnd.immervision-ivu\":{\"source\":\"iana\",\"extensions\":[\"ivu\"]},\"application/vnd.ims.imsccv1p1\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p2\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p3\":{\"source\":\"iana\"},\"application/vnd.ims.lis.v2.result+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolconsumerprofile+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy.id+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings.simple+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informedcontrol.rms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informix-visionary\":{\"source\":\"iana\"},\"application/vnd.infotech.project\":{\"source\":\"iana\"},\"application/vnd.infotech.project+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.innopath.wamp.notification\":{\"source\":\"iana\"},\"application/vnd.insors.igm\":{\"source\":\"iana\",\"extensions\":[\"igm\"]},\"application/vnd.intercon.formnet\":{\"source\":\"iana\",\"extensions\":[\"xpw\",\"xpx\"]},\"application/vnd.intergeo\":{\"source\":\"iana\",\"extensions\":[\"i2g\"]},\"application/vnd.intertrust.digibox\":{\"source\":\"iana\"},\"application/vnd.intertrust.nncp\":{\"source\":\"iana\"},\"application/vnd.intu.qbo\":{\"source\":\"iana\",\"extensions\":[\"qbo\"]},\"application/vnd.intu.qfx\":{\"source\":\"iana\",\"extensions\":[\"qfx\"]},\"application/vnd.iptc.g2.catalogitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.conceptitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.knowledgeitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.packageitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.planningitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ipunplugged.rcprofile\":{\"source\":\"iana\",\"extensions\":[\"rcprofile\"]},\"application/vnd.irepository.package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"irp\"]},\"application/vnd.is-xpr\":{\"source\":\"iana\",\"extensions\":[\"xpr\"]},\"application/vnd.isac.fcs\":{\"source\":\"iana\",\"extensions\":[\"fcs\"]},\"application/vnd.iso11783-10+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.jam\":{\"source\":\"iana\",\"extensions\":[\"jam\"]},\"application/vnd.japannet-directory-service\":{\"source\":\"iana\"},\"application/vnd.japannet-jpnstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-payment-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-registration\":{\"source\":\"iana\"},\"application/vnd.japannet-registration-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-setstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-verification\":{\"source\":\"iana\"},\"application/vnd.japannet-verification-wakeup\":{\"source\":\"iana\"},\"application/vnd.jcp.javame.midlet-rms\":{\"source\":\"iana\",\"extensions\":[\"rms\"]},\"application/vnd.jisp\":{\"source\":\"iana\",\"extensions\":[\"jisp\"]},\"application/vnd.joost.joda-archive\":{\"source\":\"iana\",\"extensions\":[\"joda\"]},\"application/vnd.jsk.isdn-ngn\":{\"source\":\"iana\"},\"application/vnd.kahootz\":{\"source\":\"iana\",\"extensions\":[\"ktz\",\"ktr\"]},\"application/vnd.kde.karbon\":{\"source\":\"iana\",\"extensions\":[\"karbon\"]},\"application/vnd.kde.kchart\":{\"source\":\"iana\",\"extensions\":[\"chrt\"]},\"application/vnd.kde.kformula\":{\"source\":\"iana\",\"extensions\":[\"kfo\"]},\"application/vnd.kde.kivio\":{\"source\":\"iana\",\"extensions\":[\"flw\"]},\"application/vnd.kde.kontour\":{\"source\":\"iana\",\"extensions\":[\"kon\"]},\"application/vnd.kde.kpresenter\":{\"source\":\"iana\",\"extensions\":[\"kpr\",\"kpt\"]},\"application/vnd.kde.kspread\":{\"source\":\"iana\",\"extensions\":[\"ksp\"]},\"application/vnd.kde.kword\":{\"source\":\"iana\",\"extensions\":[\"kwd\",\"kwt\"]},\"application/vnd.kenameaapp\":{\"source\":\"iana\",\"extensions\":[\"htke\"]},\"application/vnd.kidspiration\":{\"source\":\"iana\",\"extensions\":[\"kia\"]},\"application/vnd.kinar\":{\"source\":\"iana\",\"extensions\":[\"kne\",\"knp\"]},\"application/vnd.koan\":{\"source\":\"iana\",\"extensions\":[\"skp\",\"skd\",\"skt\",\"skm\"]},\"application/vnd.kodak-descriptor\":{\"source\":\"iana\",\"extensions\":[\"sse\"]},\"application/vnd.las\":{\"source\":\"iana\"},\"application/vnd.las.las+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.las.las+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lasxml\"]},\"application/vnd.laszip\":{\"source\":\"iana\"},\"application/vnd.leap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.liberty-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.llamagraphics.life-balance.desktop\":{\"source\":\"iana\",\"extensions\":[\"lbd\"]},\"application/vnd.llamagraphics.life-balance.exchange+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lbe\"]},\"application/vnd.logipipe.circuit+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.loom\":{\"source\":\"iana\"},\"application/vnd.lotus-1-2-3\":{\"source\":\"iana\",\"extensions\":[\"123\"]},\"application/vnd.lotus-approach\":{\"source\":\"iana\",\"extensions\":[\"apr\"]},\"application/vnd.lotus-freelance\":{\"source\":\"iana\",\"extensions\":[\"pre\"]},\"application/vnd.lotus-notes\":{\"source\":\"iana\",\"extensions\":[\"nsf\"]},\"application/vnd.lotus-organizer\":{\"source\":\"iana\",\"extensions\":[\"org\"]},\"application/vnd.lotus-screencam\":{\"source\":\"iana\",\"extensions\":[\"scm\"]},\"application/vnd.lotus-wordpro\":{\"source\":\"iana\",\"extensions\":[\"lwp\"]},\"application/vnd.macports.portpkg\":{\"source\":\"iana\",\"extensions\":[\"portpkg\"]},\"application/vnd.mapbox-vector-tile\":{\"source\":\"iana\"},\"application/vnd.marlin.drm.actiontoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.conftoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.license+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.mdcf\":{\"source\":\"iana\"},\"application/vnd.mason+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.maxmind.maxmind-db\":{\"source\":\"iana\"},\"application/vnd.mcd\":{\"source\":\"iana\",\"extensions\":[\"mcd\"]},\"application/vnd.medcalcdata\":{\"source\":\"iana\",\"extensions\":[\"mc1\"]},\"application/vnd.mediastation.cdkey\":{\"source\":\"iana\",\"extensions\":[\"cdkey\"]},\"application/vnd.meridian-slingshot\":{\"source\":\"iana\"},\"application/vnd.mfer\":{\"source\":\"iana\",\"extensions\":[\"mwf\"]},\"application/vnd.mfmp\":{\"source\":\"iana\",\"extensions\":[\"mfm\"]},\"application/vnd.micro+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.micrografx.flo\":{\"source\":\"iana\",\"extensions\":[\"flo\"]},\"application/vnd.micrografx.igx\":{\"source\":\"iana\",\"extensions\":[\"igx\"]},\"application/vnd.microsoft.portable-executable\":{\"source\":\"iana\"},\"application/vnd.microsoft.windows.thumbnail-cache\":{\"source\":\"iana\"},\"application/vnd.miele+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.mif\":{\"source\":\"iana\",\"extensions\":[\"mif\"]},\"application/vnd.minisoft-hp3000-save\":{\"source\":\"iana\"},\"application/vnd.mitsubishi.misty-guard.trustweb\":{\"source\":\"iana\"},\"application/vnd.mobius.daf\":{\"source\":\"iana\",\"extensions\":[\"daf\"]},\"application/vnd.mobius.dis\":{\"source\":\"iana\",\"extensions\":[\"dis\"]},\"application/vnd.mobius.mbk\":{\"source\":\"iana\",\"extensions\":[\"mbk\"]},\"application/vnd.mobius.mqy\":{\"source\":\"iana\",\"extensions\":[\"mqy\"]},\"application/vnd.mobius.msl\":{\"source\":\"iana\",\"extensions\":[\"msl\"]},\"application/vnd.mobius.plc\":{\"source\":\"iana\",\"extensions\":[\"plc\"]},\"application/vnd.mobius.txf\":{\"source\":\"iana\",\"extensions\":[\"txf\"]},\"application/vnd.mophun.application\":{\"source\":\"iana\",\"extensions\":[\"mpn\"]},\"application/vnd.mophun.certificate\":{\"source\":\"iana\",\"extensions\":[\"mpc\"]},\"application/vnd.motorola.flexsuite\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.adsi\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.fis\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.gotap\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.kmr\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.ttc\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.wem\":{\"source\":\"iana\"},\"application/vnd.motorola.iprm\":{\"source\":\"iana\"},\"application/vnd.mozilla.xul+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xul\"]},\"application/vnd.ms-3mfdocument\":{\"source\":\"iana\"},\"application/vnd.ms-artgalry\":{\"source\":\"iana\",\"extensions\":[\"cil\"]},\"application/vnd.ms-asf\":{\"source\":\"iana\"},\"application/vnd.ms-cab-compressed\":{\"source\":\"iana\",\"extensions\":[\"cab\"]},\"application/vnd.ms-color.iccprofile\":{\"source\":\"apache\"},\"application/vnd.ms-excel\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xls\",\"xlm\",\"xla\",\"xlc\",\"xlt\",\"xlw\"]},\"application/vnd.ms-excel.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlam\"]},\"application/vnd.ms-excel.sheet.binary.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsb\"]},\"application/vnd.ms-excel.sheet.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsm\"]},\"application/vnd.ms-excel.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xltm\"]},\"application/vnd.ms-fontobject\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eot\"]},\"application/vnd.ms-htmlhelp\":{\"source\":\"iana\",\"extensions\":[\"chm\"]},\"application/vnd.ms-ims\":{\"source\":\"iana\",\"extensions\":[\"ims\"]},\"application/vnd.ms-lrm\":{\"source\":\"iana\",\"extensions\":[\"lrm\"]},\"application/vnd.ms-office.activex+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-officetheme\":{\"source\":\"iana\",\"extensions\":[\"thmx\"]},\"application/vnd.ms-opentype\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-outlook\":{\"compressible\":false,\"extensions\":[\"msg\"]},\"application/vnd.ms-package.obfuscated-opentype\":{\"source\":\"apache\"},\"application/vnd.ms-pki.seccat\":{\"source\":\"apache\",\"extensions\":[\"cat\"]},\"application/vnd.ms-pki.stl\":{\"source\":\"apache\",\"extensions\":[\"stl\"]},\"application/vnd.ms-playready.initiator+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-powerpoint\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ppt\",\"pps\",\"pot\"]},\"application/vnd.ms-powerpoint.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppam\"]},\"application/vnd.ms-powerpoint.presentation.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"pptm\"]},\"application/vnd.ms-powerpoint.slide.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"sldm\"]},\"application/vnd.ms-powerpoint.slideshow.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppsm\"]},\"application/vnd.ms-powerpoint.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"potm\"]},\"application/vnd.ms-printdevicecapabilities+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-printing.printticket+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-printschematicket+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-project\":{\"source\":\"iana\",\"extensions\":[\"mpp\",\"mpt\"]},\"application/vnd.ms-tnef\":{\"source\":\"iana\"},\"application/vnd.ms-windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.nwprinting.oob\":{\"source\":\"iana\"},\"application/vnd.ms-windows.printerpairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.wsd.oob\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-resp\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-resp\":{\"source\":\"iana\"},\"application/vnd.ms-word.document.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"docm\"]},\"application/vnd.ms-word.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"dotm\"]},\"application/vnd.ms-works\":{\"source\":\"iana\",\"extensions\":[\"wps\",\"wks\",\"wcm\",\"wdb\"]},\"application/vnd.ms-wpl\":{\"source\":\"iana\",\"extensions\":[\"wpl\"]},\"application/vnd.ms-xpsdocument\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xps\"]},\"application/vnd.msa-disk-image\":{\"source\":\"iana\"},\"application/vnd.mseq\":{\"source\":\"iana\",\"extensions\":[\"mseq\"]},\"application/vnd.msign\":{\"source\":\"iana\"},\"application/vnd.multiad.creator\":{\"source\":\"iana\"},\"application/vnd.multiad.creator.cif\":{\"source\":\"iana\"},\"application/vnd.music-niff\":{\"source\":\"iana\"},\"application/vnd.musician\":{\"source\":\"iana\",\"extensions\":[\"mus\"]},\"application/vnd.muvee.style\":{\"source\":\"iana\",\"extensions\":[\"msty\"]},\"application/vnd.mynfc\":{\"source\":\"iana\",\"extensions\":[\"taglet\"]},\"application/vnd.ncd.control\":{\"source\":\"iana\"},\"application/vnd.ncd.reference\":{\"source\":\"iana\"},\"application/vnd.nearst.inv+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nervana\":{\"source\":\"iana\"},\"application/vnd.netfpx\":{\"source\":\"iana\"},\"application/vnd.neurolanguage.nlu\":{\"source\":\"iana\",\"extensions\":[\"nlu\"]},\"application/vnd.nimn\":{\"source\":\"iana\"},\"application/vnd.nintendo.nitro.rom\":{\"source\":\"iana\"},\"application/vnd.nintendo.snes.rom\":{\"source\":\"iana\"},\"application/vnd.nitf\":{\"source\":\"iana\",\"extensions\":[\"ntf\",\"nitf\"]},\"application/vnd.noblenet-directory\":{\"source\":\"iana\",\"extensions\":[\"nnd\"]},\"application/vnd.noblenet-sealer\":{\"source\":\"iana\",\"extensions\":[\"nns\"]},\"application/vnd.noblenet-web\":{\"source\":\"iana\",\"extensions\":[\"nnw\"]},\"application/vnd.nokia.catalogs\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.iptv.config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.isds-radio-presets\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.landmarkcollection+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.n-gage.ac+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.n-gage.data\":{\"source\":\"iana\",\"extensions\":[\"ngdat\"]},\"application/vnd.nokia.n-gage.symbian.install\":{\"source\":\"iana\",\"extensions\":[\"n-gage\"]},\"application/vnd.nokia.ncd\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.radio-preset\":{\"source\":\"iana\",\"extensions\":[\"rpst\"]},\"application/vnd.nokia.radio-presets\":{\"source\":\"iana\",\"extensions\":[\"rpss\"]},\"application/vnd.novadigm.edm\":{\"source\":\"iana\",\"extensions\":[\"edm\"]},\"application/vnd.novadigm.edx\":{\"source\":\"iana\",\"extensions\":[\"edx\"]},\"application/vnd.novadigm.ext\":{\"source\":\"iana\",\"extensions\":[\"ext\"]},\"application/vnd.ntt-local.content-share\":{\"source\":\"iana\"},\"application/vnd.ntt-local.file-transfer\":{\"source\":\"iana\"},\"application/vnd.ntt-local.ogw_remote-access\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_remote\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_tcp_stream\":{\"source\":\"iana\"},\"application/vnd.oasis.opendocument.chart\":{\"source\":\"iana\",\"extensions\":[\"odc\"]},\"application/vnd.oasis.opendocument.chart-template\":{\"source\":\"iana\",\"extensions\":[\"otc\"]},\"application/vnd.oasis.opendocument.database\":{\"source\":\"iana\",\"extensions\":[\"odb\"]},\"application/vnd.oasis.opendocument.formula\":{\"source\":\"iana\",\"extensions\":[\"odf\"]},\"application/vnd.oasis.opendocument.formula-template\":{\"source\":\"iana\",\"extensions\":[\"odft\"]},\"application/vnd.oasis.opendocument.graphics\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odg\"]},\"application/vnd.oasis.opendocument.graphics-template\":{\"source\":\"iana\",\"extensions\":[\"otg\"]},\"application/vnd.oasis.opendocument.image\":{\"source\":\"iana\",\"extensions\":[\"odi\"]},\"application/vnd.oasis.opendocument.image-template\":{\"source\":\"iana\",\"extensions\":[\"oti\"]},\"application/vnd.oasis.opendocument.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odp\"]},\"application/vnd.oasis.opendocument.presentation-template\":{\"source\":\"iana\",\"extensions\":[\"otp\"]},\"application/vnd.oasis.opendocument.spreadsheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ods\"]},\"application/vnd.oasis.opendocument.spreadsheet-template\":{\"source\":\"iana\",\"extensions\":[\"ots\"]},\"application/vnd.oasis.opendocument.text\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odt\"]},\"application/vnd.oasis.opendocument.text-master\":{\"source\":\"iana\",\"extensions\":[\"odm\"]},\"application/vnd.oasis.opendocument.text-template\":{\"source\":\"iana\",\"extensions\":[\"ott\"]},\"application/vnd.oasis.opendocument.text-web\":{\"source\":\"iana\",\"extensions\":[\"oth\"]},\"application/vnd.obn\":{\"source\":\"iana\"},\"application/vnd.ocf+cbor\":{\"source\":\"iana\"},\"application/vnd.oftn.l10n+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessdownload+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessstreaming+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.cspg-hexbinary\":{\"source\":\"iana\"},\"application/vnd.oipf.dae.svg+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.dae.xhtml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.mippvcontrolmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.pae.gem\":{\"source\":\"iana\"},\"application/vnd.oipf.spdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.spdlist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.ueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.userprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.olpc-sugar\":{\"source\":\"iana\",\"extensions\":[\"xo\"]},\"application/vnd.oma-scws-config\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-request\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-response\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.associated-procedure-parameter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.drm-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.imd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.ltkm\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.notification+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.provisioningtrigger\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgboot\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgdd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sgdu\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.simple-symbol-container\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.smartcard-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sprov+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.stkm\":{\"source\":\"iana\"},\"application/vnd.oma.cab-address-book+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-feature-handler+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-pcc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-subs-invite+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-user-prefs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.dcd\":{\"source\":\"iana\"},\"application/vnd.oma.dcdc\":{\"source\":\"iana\"},\"application/vnd.oma.dd2+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dd2\"]},\"application/vnd.oma.drm.risd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.group-usage-list+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+tlv\":{\"source\":\"iana\"},\"application/vnd.oma.pal+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.detailed-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.final-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.groups+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.invocation-descriptor+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.optimized-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.push\":{\"source\":\"iana\"},\"application/vnd.oma.scidm.messages+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.xcap-directory+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-email+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-file+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-folder+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omaloc-supl-init\":{\"source\":\"iana\"},\"application/vnd.onepager\":{\"source\":\"iana\"},\"application/vnd.onepagertamp\":{\"source\":\"iana\"},\"application/vnd.onepagertamx\":{\"source\":\"iana\"},\"application/vnd.onepagertat\":{\"source\":\"iana\"},\"application/vnd.onepagertatp\":{\"source\":\"iana\"},\"application/vnd.onepagertatx\":{\"source\":\"iana\"},\"application/vnd.openblox.game+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openblox.game-binary\":{\"source\":\"iana\"},\"application/vnd.openeye.oeb\":{\"source\":\"iana\"},\"application/vnd.openofficeorg.extension\":{\"source\":\"apache\",\"extensions\":[\"oxt\"]},\"application/vnd.openstreetmap.data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.custom-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.customxmlproperties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawing+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.extended-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pptx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slide\":{\"source\":\"iana\",\"extensions\":[\"sldx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow\":{\"source\":\"iana\",\"extensions\":[\"ppsx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tags+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.template\":{\"source\":\"iana\",\"extensions\":[\"potx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xlsx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\":{\"source\":\"iana\",\"extensions\":[\"xltx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.theme+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.themeoverride+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.vmldrawing\":{\"source\":\"iana\"},\"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"docx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template\":{\"source\":\"iana\",\"extensions\":[\"dotx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.core-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.relationships+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oracle.resource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.orange.indata\":{\"source\":\"iana\"},\"application/vnd.osa.netdeploy\":{\"source\":\"iana\"},\"application/vnd.osgeo.mapguide.package\":{\"source\":\"iana\",\"extensions\":[\"mgp\"]},\"application/vnd.osgi.bundle\":{\"source\":\"iana\"},\"application/vnd.osgi.dp\":{\"source\":\"iana\",\"extensions\":[\"dp\"]},\"application/vnd.osgi.subsystem\":{\"source\":\"iana\",\"extensions\":[\"esa\"]},\"application/vnd.otps.ct-kip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oxli.countgraph\":{\"source\":\"iana\"},\"application/vnd.pagerduty+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.palm\":{\"source\":\"iana\",\"extensions\":[\"pdb\",\"pqa\",\"oprc\"]},\"application/vnd.panoply\":{\"source\":\"iana\"},\"application/vnd.paos.xml\":{\"source\":\"iana\"},\"application/vnd.patentdive\":{\"source\":\"iana\"},\"application/vnd.patientecommsdoc\":{\"source\":\"iana\"},\"application/vnd.pawaafile\":{\"source\":\"iana\",\"extensions\":[\"paw\"]},\"application/vnd.pcos\":{\"source\":\"iana\"},\"application/vnd.pg.format\":{\"source\":\"iana\",\"extensions\":[\"str\"]},\"application/vnd.pg.osasli\":{\"source\":\"iana\",\"extensions\":[\"ei6\"]},\"application/vnd.piaccess.application-licence\":{\"source\":\"iana\"},\"application/vnd.picsel\":{\"source\":\"iana\",\"extensions\":[\"efif\"]},\"application/vnd.pmi.widget\":{\"source\":\"iana\",\"extensions\":[\"wg\"]},\"application/vnd.poc.group-advertisement+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.pocketlearn\":{\"source\":\"iana\",\"extensions\":[\"plf\"]},\"application/vnd.powerbuilder6\":{\"source\":\"iana\",\"extensions\":[\"pbd\"]},\"application/vnd.powerbuilder6-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75-s\":{\"source\":\"iana\"},\"application/vnd.preminet\":{\"source\":\"iana\"},\"application/vnd.previewsystems.box\":{\"source\":\"iana\",\"extensions\":[\"box\"]},\"application/vnd.proteus.magazine\":{\"source\":\"iana\",\"extensions\":[\"mgz\"]},\"application/vnd.psfs\":{\"source\":\"iana\"},\"application/vnd.publishare-delta-tree\":{\"source\":\"iana\",\"extensions\":[\"qps\"]},\"application/vnd.pvi.ptid1\":{\"source\":\"iana\",\"extensions\":[\"ptid\"]},\"application/vnd.pwg-multiplexed\":{\"source\":\"iana\"},\"application/vnd.pwg-xhtml-print+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.qualcomm.brew-app-res\":{\"source\":\"iana\"},\"application/vnd.quarantainenet\":{\"source\":\"iana\"},\"application/vnd.quark.quarkxpress\":{\"source\":\"iana\",\"extensions\":[\"qxd\",\"qxt\",\"qwd\",\"qwt\",\"qxl\",\"qxb\"]},\"application/vnd.quobject-quoxdocument\":{\"source\":\"iana\"},\"application/vnd.radisys.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-stream+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-base+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-detect+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-sendrecv+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-group+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-speech+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-transform+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rainstor.data\":{\"source\":\"iana\"},\"application/vnd.rapid\":{\"source\":\"iana\"},\"application/vnd.rar\":{\"source\":\"iana\"},\"application/vnd.realvnc.bed\":{\"source\":\"iana\",\"extensions\":[\"bed\"]},\"application/vnd.recordare.musicxml\":{\"source\":\"iana\",\"extensions\":[\"mxl\"]},\"application/vnd.recordare.musicxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"musicxml\"]},\"application/vnd.renlearn.rlprint\":{\"source\":\"iana\"},\"application/vnd.restful+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rig.cryptonote\":{\"source\":\"iana\",\"extensions\":[\"cryptonote\"]},\"application/vnd.rim.cod\":{\"source\":\"apache\",\"extensions\":[\"cod\"]},\"application/vnd.rn-realmedia\":{\"source\":\"apache\",\"extensions\":[\"rm\"]},\"application/vnd.rn-realmedia-vbr\":{\"source\":\"apache\",\"extensions\":[\"rmvb\"]},\"application/vnd.route66.link66+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"link66\"]},\"application/vnd.rs-274x\":{\"source\":\"iana\"},\"application/vnd.ruckus.download\":{\"source\":\"iana\"},\"application/vnd.s3sms\":{\"source\":\"iana\"},\"application/vnd.sailingtracker.track\":{\"source\":\"iana\",\"extensions\":[\"st\"]},\"application/vnd.sbm.cid\":{\"source\":\"iana\"},\"application/vnd.sbm.mid2\":{\"source\":\"iana\"},\"application/vnd.scribus\":{\"source\":\"iana\"},\"application/vnd.sealed.3df\":{\"source\":\"iana\"},\"application/vnd.sealed.csf\":{\"source\":\"iana\"},\"application/vnd.sealed.doc\":{\"source\":\"iana\"},\"application/vnd.sealed.eml\":{\"source\":\"iana\"},\"application/vnd.sealed.mht\":{\"source\":\"iana\"},\"application/vnd.sealed.net\":{\"source\":\"iana\"},\"application/vnd.sealed.ppt\":{\"source\":\"iana\"},\"application/vnd.sealed.tiff\":{\"source\":\"iana\"},\"application/vnd.sealed.xls\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.html\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.pdf\":{\"source\":\"iana\"},\"application/vnd.seemail\":{\"source\":\"iana\",\"extensions\":[\"see\"]},\"application/vnd.sema\":{\"source\":\"iana\",\"extensions\":[\"sema\"]},\"application/vnd.semd\":{\"source\":\"iana\",\"extensions\":[\"semd\"]},\"application/vnd.semf\":{\"source\":\"iana\",\"extensions\":[\"semf\"]},\"application/vnd.shade-save-file\":{\"source\":\"iana\"},\"application/vnd.shana.informed.formdata\":{\"source\":\"iana\",\"extensions\":[\"ifm\"]},\"application/vnd.shana.informed.formtemplate\":{\"source\":\"iana\",\"extensions\":[\"itp\"]},\"application/vnd.shana.informed.interchange\":{\"source\":\"iana\",\"extensions\":[\"iif\"]},\"application/vnd.shana.informed.package\":{\"source\":\"iana\",\"extensions\":[\"ipk\"]},\"application/vnd.shootproof+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.shopkick+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.sigrok.session\":{\"source\":\"iana\"},\"application/vnd.simtech-mindmapper\":{\"source\":\"iana\",\"extensions\":[\"twd\",\"twds\"]},\"application/vnd.siren+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.smaf\":{\"source\":\"iana\",\"extensions\":[\"mmf\"]},\"application/vnd.smart.notebook\":{\"source\":\"iana\"},\"application/vnd.smart.teacher\":{\"source\":\"iana\",\"extensions\":[\"teacher\"]},\"application/vnd.software602.filler.form+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.software602.filler.form-xml-zip\":{\"source\":\"iana\"},\"application/vnd.solent.sdkm+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sdkm\",\"sdkd\"]},\"application/vnd.spotfire.dxp\":{\"source\":\"iana\",\"extensions\":[\"dxp\"]},\"application/vnd.spotfire.sfs\":{\"source\":\"iana\",\"extensions\":[\"sfs\"]},\"application/vnd.sqlite3\":{\"source\":\"iana\"},\"application/vnd.sss-cod\":{\"source\":\"iana\"},\"application/vnd.sss-dtf\":{\"source\":\"iana\"},\"application/vnd.sss-ntf\":{\"source\":\"iana\"},\"application/vnd.stardivision.calc\":{\"source\":\"apache\",\"extensions\":[\"sdc\"]},\"application/vnd.stardivision.draw\":{\"source\":\"apache\",\"extensions\":[\"sda\"]},\"application/vnd.stardivision.impress\":{\"source\":\"apache\",\"extensions\":[\"sdd\"]},\"application/vnd.stardivision.math\":{\"source\":\"apache\",\"extensions\":[\"smf\"]},\"application/vnd.stardivision.writer\":{\"source\":\"apache\",\"extensions\":[\"sdw\",\"vor\"]},\"application/vnd.stardivision.writer-global\":{\"source\":\"apache\",\"extensions\":[\"sgl\"]},\"application/vnd.stepmania.package\":{\"source\":\"iana\",\"extensions\":[\"smzip\"]},\"application/vnd.stepmania.stepchart\":{\"source\":\"iana\",\"extensions\":[\"sm\"]},\"application/vnd.street-stream\":{\"source\":\"iana\"},\"application/vnd.sun.wadl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wadl\"]},\"application/vnd.sun.xml.calc\":{\"source\":\"apache\",\"extensions\":[\"sxc\"]},\"application/vnd.sun.xml.calc.template\":{\"source\":\"apache\",\"extensions\":[\"stc\"]},\"application/vnd.sun.xml.draw\":{\"source\":\"apache\",\"extensions\":[\"sxd\"]},\"application/vnd.sun.xml.draw.template\":{\"source\":\"apache\",\"extensions\":[\"std\"]},\"application/vnd.sun.xml.impress\":{\"source\":\"apache\",\"extensions\":[\"sxi\"]},\"application/vnd.sun.xml.impress.template\":{\"source\":\"apache\",\"extensions\":[\"sti\"]},\"application/vnd.sun.xml.math\":{\"source\":\"apache\",\"extensions\":[\"sxm\"]},\"application/vnd.sun.xml.writer\":{\"source\":\"apache\",\"extensions\":[\"sxw\"]},\"application/vnd.sun.xml.writer.global\":{\"source\":\"apache\",\"extensions\":[\"sxg\"]},\"application/vnd.sun.xml.writer.template\":{\"source\":\"apache\",\"extensions\":[\"stw\"]},\"application/vnd.sus-calendar\":{\"source\":\"iana\",\"extensions\":[\"sus\",\"susp\"]},\"application/vnd.svd\":{\"source\":\"iana\",\"extensions\":[\"svd\"]},\"application/vnd.swiftview-ics\":{\"source\":\"iana\"},\"application/vnd.symbian.install\":{\"source\":\"apache\",\"extensions\":[\"sis\",\"sisx\"]},\"application/vnd.syncml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xsm\"]},\"application/vnd.syncml.dm+wbxml\":{\"source\":\"iana\",\"extensions\":[\"bdm\"]},\"application/vnd.syncml.dm+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdm\"]},\"application/vnd.syncml.dm.notification\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.syncml.dmtnds+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmtnds+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.syncml.ds.notification\":{\"source\":\"iana\"},\"application/vnd.tableschema+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tao.intent-module-archive\":{\"source\":\"iana\",\"extensions\":[\"tao\"]},\"application/vnd.tcpdump.pcap\":{\"source\":\"iana\",\"extensions\":[\"pcap\",\"cap\",\"dmp\"]},\"application/vnd.think-cell.ppttc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tmd.mediaflex.api+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tml\":{\"source\":\"iana\"},\"application/vnd.tmobile-livetv\":{\"source\":\"iana\",\"extensions\":[\"tmo\"]},\"application/vnd.tri.onesource\":{\"source\":\"iana\"},\"application/vnd.trid.tpt\":{\"source\":\"iana\",\"extensions\":[\"tpt\"]},\"application/vnd.triscape.mxs\":{\"source\":\"iana\",\"extensions\":[\"mxs\"]},\"application/vnd.trueapp\":{\"source\":\"iana\",\"extensions\":[\"tra\"]},\"application/vnd.truedoc\":{\"source\":\"iana\"},\"application/vnd.ubisoft.webplayer\":{\"source\":\"iana\"},\"application/vnd.ufdl\":{\"source\":\"iana\",\"extensions\":[\"ufd\",\"ufdl\"]},\"application/vnd.uiq.theme\":{\"source\":\"iana\",\"extensions\":[\"utz\"]},\"application/vnd.umajin\":{\"source\":\"iana\",\"extensions\":[\"umj\"]},\"application/vnd.unity\":{\"source\":\"iana\",\"extensions\":[\"unityweb\"]},\"application/vnd.uoml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uoml\"]},\"application/vnd.uplanet.alert\":{\"source\":\"iana\"},\"application/vnd.uplanet.alert-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.list\":{\"source\":\"iana\"},\"application/vnd.uplanet.list-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.signal\":{\"source\":\"iana\"},\"application/vnd.uri-map\":{\"source\":\"iana\"},\"application/vnd.valve.source.material\":{\"source\":\"iana\"},\"application/vnd.vcx\":{\"source\":\"iana\",\"extensions\":[\"vcx\"]},\"application/vnd.vd-study\":{\"source\":\"iana\"},\"application/vnd.vectorworks\":{\"source\":\"iana\"},\"application/vnd.vel+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.verimatrix.vcas\":{\"source\":\"iana\"},\"application/vnd.veryant.thin\":{\"source\":\"iana\"},\"application/vnd.ves.encrypted\":{\"source\":\"iana\"},\"application/vnd.vidsoft.vidconference\":{\"source\":\"iana\"},\"application/vnd.visio\":{\"source\":\"iana\",\"extensions\":[\"vsd\",\"vst\",\"vss\",\"vsw\"]},\"application/vnd.visionary\":{\"source\":\"iana\",\"extensions\":[\"vis\"]},\"application/vnd.vividence.scriptfile\":{\"source\":\"iana\"},\"application/vnd.vsf\":{\"source\":\"iana\",\"extensions\":[\"vsf\"]},\"application/vnd.wap.sic\":{\"source\":\"iana\"},\"application/vnd.wap.slc\":{\"source\":\"iana\"},\"application/vnd.wap.wbxml\":{\"source\":\"iana\",\"extensions\":[\"wbxml\"]},\"application/vnd.wap.wmlc\":{\"source\":\"iana\",\"extensions\":[\"wmlc\"]},\"application/vnd.wap.wmlscriptc\":{\"source\":\"iana\",\"extensions\":[\"wmlsc\"]},\"application/vnd.webturbo\":{\"source\":\"iana\",\"extensions\":[\"wtb\"]},\"application/vnd.wfa.p2p\":{\"source\":\"iana\"},\"application/vnd.wfa.wsc\":{\"source\":\"iana\"},\"application/vnd.windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.wmc\":{\"source\":\"iana\"},\"application/vnd.wmf.bootstrap\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica.package\":{\"source\":\"iana\"},\"application/vnd.wolfram.player\":{\"source\":\"iana\",\"extensions\":[\"nbp\"]},\"application/vnd.wordperfect\":{\"source\":\"iana\",\"extensions\":[\"wpd\"]},\"application/vnd.wqd\":{\"source\":\"iana\",\"extensions\":[\"wqd\"]},\"application/vnd.wrq-hp3000-labelled\":{\"source\":\"iana\"},\"application/vnd.wt.stf\":{\"source\":\"iana\",\"extensions\":[\"stf\"]},\"application/vnd.wv.csp+wbxml\":{\"source\":\"iana\"},\"application/vnd.wv.csp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.wv.ssp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xacml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xara\":{\"source\":\"iana\",\"extensions\":[\"xar\"]},\"application/vnd.xfdl\":{\"source\":\"iana\",\"extensions\":[\"xfdl\"]},\"application/vnd.xfdl.webform\":{\"source\":\"iana\"},\"application/vnd.xmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xmpie.cpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.dpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.plan\":{\"source\":\"iana\"},\"application/vnd.xmpie.ppkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.xlim\":{\"source\":\"iana\"},\"application/vnd.yamaha.hv-dic\":{\"source\":\"iana\",\"extensions\":[\"hvd\"]},\"application/vnd.yamaha.hv-script\":{\"source\":\"iana\",\"extensions\":[\"hvs\"]},\"application/vnd.yamaha.hv-voice\":{\"source\":\"iana\",\"extensions\":[\"hvp\"]},\"application/vnd.yamaha.openscoreformat\":{\"source\":\"iana\",\"extensions\":[\"osf\"]},\"application/vnd.yamaha.openscoreformat.osfpvg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"osfpvg\"]},\"application/vnd.yamaha.remote-setup\":{\"source\":\"iana\"},\"application/vnd.yamaha.smaf-audio\":{\"source\":\"iana\",\"extensions\":[\"saf\"]},\"application/vnd.yamaha.smaf-phrase\":{\"source\":\"iana\",\"extensions\":[\"spf\"]},\"application/vnd.yamaha.through-ngn\":{\"source\":\"iana\"},\"application/vnd.yamaha.tunnel-udpencap\":{\"source\":\"iana\"},\"application/vnd.yaoweme\":{\"source\":\"iana\"},\"application/vnd.yellowriver-custom-menu\":{\"source\":\"iana\",\"extensions\":[\"cmp\"]},\"application/vnd.youtube.yt\":{\"source\":\"iana\"},\"application/vnd.zul\":{\"source\":\"iana\",\"extensions\":[\"zir\",\"zirz\"]},\"application/vnd.zzazz.deck+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zaz\"]},\"application/voicexml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vxml\"]},\"application/voucher-cms+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vq-rtcpxr\":{\"source\":\"iana\"},\"application/wasm\":{\"compressible\":true,\"extensions\":[\"wasm\"]},\"application/watcherinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/webpush-options+json\":{\"source\":\"iana\",\"compressible\":true},\"application/whoispp-query\":{\"source\":\"iana\"},\"application/whoispp-response\":{\"source\":\"iana\"},\"application/widget\":{\"source\":\"iana\",\"extensions\":[\"wgt\"]},\"application/winhlp\":{\"source\":\"apache\",\"extensions\":[\"hlp\"]},\"application/wita\":{\"source\":\"iana\"},\"application/wordperfect5.1\":{\"source\":\"iana\"},\"application/wsdl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wsdl\"]},\"application/wspolicy+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wspolicy\"]},\"application/x-7z-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"7z\"]},\"application/x-abiword\":{\"source\":\"apache\",\"extensions\":[\"abw\"]},\"application/x-ace-compressed\":{\"source\":\"apache\",\"extensions\":[\"ace\"]},\"application/x-amf\":{\"source\":\"apache\"},\"application/x-apple-diskimage\":{\"source\":\"apache\",\"extensions\":[\"dmg\"]},\"application/x-arj\":{\"compressible\":false,\"extensions\":[\"arj\"]},\"application/x-authorware-bin\":{\"source\":\"apache\",\"extensions\":[\"aab\",\"x32\",\"u32\",\"vox\"]},\"application/x-authorware-map\":{\"source\":\"apache\",\"extensions\":[\"aam\"]},\"application/x-authorware-seg\":{\"source\":\"apache\",\"extensions\":[\"aas\"]},\"application/x-bcpio\":{\"source\":\"apache\",\"extensions\":[\"bcpio\"]},\"application/x-bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/x-bittorrent\":{\"source\":\"apache\",\"extensions\":[\"torrent\"]},\"application/x-blorb\":{\"source\":\"apache\",\"extensions\":[\"blb\",\"blorb\"]},\"application/x-bzip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz\"]},\"application/x-bzip2\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz2\",\"boz\"]},\"application/x-cbr\":{\"source\":\"apache\",\"extensions\":[\"cbr\",\"cba\",\"cbt\",\"cbz\",\"cb7\"]},\"application/x-cdlink\":{\"source\":\"apache\",\"extensions\":[\"vcd\"]},\"application/x-cfs-compressed\":{\"source\":\"apache\",\"extensions\":[\"cfs\"]},\"application/x-chat\":{\"source\":\"apache\",\"extensions\":[\"chat\"]},\"application/x-chess-pgn\":{\"source\":\"apache\",\"extensions\":[\"pgn\"]},\"application/x-chrome-extension\":{\"extensions\":[\"crx\"]},\"application/x-cocoa\":{\"source\":\"nginx\",\"extensions\":[\"cco\"]},\"application/x-compress\":{\"source\":\"apache\"},\"application/x-conference\":{\"source\":\"apache\",\"extensions\":[\"nsc\"]},\"application/x-cpio\":{\"source\":\"apache\",\"extensions\":[\"cpio\"]},\"application/x-csh\":{\"source\":\"apache\",\"extensions\":[\"csh\"]},\"application/x-deb\":{\"compressible\":false},\"application/x-debian-package\":{\"source\":\"apache\",\"extensions\":[\"deb\",\"udeb\"]},\"application/x-dgc-compressed\":{\"source\":\"apache\",\"extensions\":[\"dgc\"]},\"application/x-director\":{\"source\":\"apache\",\"extensions\":[\"dir\",\"dcr\",\"dxr\",\"cst\",\"cct\",\"cxt\",\"w3d\",\"fgd\",\"swa\"]},\"application/x-doom\":{\"source\":\"apache\",\"extensions\":[\"wad\"]},\"application/x-dtbncx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ncx\"]},\"application/x-dtbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dtb\"]},\"application/x-dtbresource+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"res\"]},\"application/x-dvi\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"dvi\"]},\"application/x-envoy\":{\"source\":\"apache\",\"extensions\":[\"evy\"]},\"application/x-eva\":{\"source\":\"apache\",\"extensions\":[\"eva\"]},\"application/x-font-bdf\":{\"source\":\"apache\",\"extensions\":[\"bdf\"]},\"application/x-font-dos\":{\"source\":\"apache\"},\"application/x-font-framemaker\":{\"source\":\"apache\"},\"application/x-font-ghostscript\":{\"source\":\"apache\",\"extensions\":[\"gsf\"]},\"application/x-font-libgrx\":{\"source\":\"apache\"},\"application/x-font-linux-psf\":{\"source\":\"apache\",\"extensions\":[\"psf\"]},\"application/x-font-pcf\":{\"source\":\"apache\",\"extensions\":[\"pcf\"]},\"application/x-font-snf\":{\"source\":\"apache\",\"extensions\":[\"snf\"]},\"application/x-font-speedo\":{\"source\":\"apache\"},\"application/x-font-sunos-news\":{\"source\":\"apache\"},\"application/x-font-type1\":{\"source\":\"apache\",\"extensions\":[\"pfa\",\"pfb\",\"pfm\",\"afm\"]},\"application/x-font-vfont\":{\"source\":\"apache\"},\"application/x-freearc\":{\"source\":\"apache\",\"extensions\":[\"arc\"]},\"application/x-futuresplash\":{\"source\":\"apache\",\"extensions\":[\"spl\"]},\"application/x-gca-compressed\":{\"source\":\"apache\",\"extensions\":[\"gca\"]},\"application/x-glulx\":{\"source\":\"apache\",\"extensions\":[\"ulx\"]},\"application/x-gnumeric\":{\"source\":\"apache\",\"extensions\":[\"gnumeric\"]},\"application/x-gramps-xml\":{\"source\":\"apache\",\"extensions\":[\"gramps\"]},\"application/x-gtar\":{\"source\":\"apache\",\"extensions\":[\"gtar\"]},\"application/x-gzip\":{\"source\":\"apache\"},\"application/x-hdf\":{\"source\":\"apache\",\"extensions\":[\"hdf\"]},\"application/x-httpd-php\":{\"compressible\":true,\"extensions\":[\"php\"]},\"application/x-install-instructions\":{\"source\":\"apache\",\"extensions\":[\"install\"]},\"application/x-iso9660-image\":{\"source\":\"apache\",\"extensions\":[\"iso\"]},\"application/x-java-archive-diff\":{\"source\":\"nginx\",\"extensions\":[\"jardiff\"]},\"application/x-java-jnlp-file\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jnlp\"]},\"application/x-javascript\":{\"compressible\":true},\"application/x-latex\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"latex\"]},\"application/x-lua-bytecode\":{\"extensions\":[\"luac\"]},\"application/x-lzh-compressed\":{\"source\":\"apache\",\"extensions\":[\"lzh\",\"lha\"]},\"application/x-makeself\":{\"source\":\"nginx\",\"extensions\":[\"run\"]},\"application/x-mie\":{\"source\":\"apache\",\"extensions\":[\"mie\"]},\"application/x-mobipocket-ebook\":{\"source\":\"apache\",\"extensions\":[\"prc\",\"mobi\"]},\"application/x-mpegurl\":{\"compressible\":false},\"application/x-ms-application\":{\"source\":\"apache\",\"extensions\":[\"application\"]},\"application/x-ms-shortcut\":{\"source\":\"apache\",\"extensions\":[\"lnk\"]},\"application/x-ms-wmd\":{\"source\":\"apache\",\"extensions\":[\"wmd\"]},\"application/x-ms-wmz\":{\"source\":\"apache\",\"extensions\":[\"wmz\"]},\"application/x-ms-xbap\":{\"source\":\"apache\",\"extensions\":[\"xbap\"]},\"application/x-msaccess\":{\"source\":\"apache\",\"extensions\":[\"mdb\"]},\"application/x-msbinder\":{\"source\":\"apache\",\"extensions\":[\"obd\"]},\"application/x-mscardfile\":{\"source\":\"apache\",\"extensions\":[\"crd\"]},\"application/x-msclip\":{\"source\":\"apache\",\"extensions\":[\"clp\"]},\"application/x-msdos-program\":{\"extensions\":[\"exe\"]},\"application/x-msdownload\":{\"source\":\"apache\",\"extensions\":[\"exe\",\"dll\",\"com\",\"bat\",\"msi\"]},\"application/x-msmediaview\":{\"source\":\"apache\",\"extensions\":[\"mvb\",\"m13\",\"m14\"]},\"application/x-msmetafile\":{\"source\":\"apache\",\"extensions\":[\"wmf\",\"wmz\",\"emf\",\"emz\"]},\"application/x-msmoney\":{\"source\":\"apache\",\"extensions\":[\"mny\"]},\"application/x-mspublisher\":{\"source\":\"apache\",\"extensions\":[\"pub\"]},\"application/x-msschedule\":{\"source\":\"apache\",\"extensions\":[\"scd\"]},\"application/x-msterminal\":{\"source\":\"apache\",\"extensions\":[\"trm\"]},\"application/x-mswrite\":{\"source\":\"apache\",\"extensions\":[\"wri\"]},\"application/x-netcdf\":{\"source\":\"apache\",\"extensions\":[\"nc\",\"cdf\"]},\"application/x-ns-proxy-autoconfig\":{\"compressible\":true,\"extensions\":[\"pac\"]},\"application/x-nzb\":{\"source\":\"apache\",\"extensions\":[\"nzb\"]},\"application/x-perl\":{\"source\":\"nginx\",\"extensions\":[\"pl\",\"pm\"]},\"application/x-pilot\":{\"source\":\"nginx\",\"extensions\":[\"prc\",\"pdb\"]},\"application/x-pkcs12\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"p12\",\"pfx\"]},\"application/x-pkcs7-certificates\":{\"source\":\"apache\",\"extensions\":[\"p7b\",\"spc\"]},\"application/x-pkcs7-certreqresp\":{\"source\":\"apache\",\"extensions\":[\"p7r\"]},\"application/x-rar-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"rar\"]},\"application/x-redhat-package-manager\":{\"source\":\"nginx\",\"extensions\":[\"rpm\"]},\"application/x-research-info-systems\":{\"source\":\"apache\",\"extensions\":[\"ris\"]},\"application/x-sea\":{\"source\":\"nginx\",\"extensions\":[\"sea\"]},\"application/x-sh\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"sh\"]},\"application/x-shar\":{\"source\":\"apache\",\"extensions\":[\"shar\"]},\"application/x-shockwave-flash\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"swf\"]},\"application/x-silverlight-app\":{\"source\":\"apache\",\"extensions\":[\"xap\"]},\"application/x-sql\":{\"source\":\"apache\",\"extensions\":[\"sql\"]},\"application/x-stuffit\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"sit\"]},\"application/x-stuffitx\":{\"source\":\"apache\",\"extensions\":[\"sitx\"]},\"application/x-subrip\":{\"source\":\"apache\",\"extensions\":[\"srt\"]},\"application/x-sv4cpio\":{\"source\":\"apache\",\"extensions\":[\"sv4cpio\"]},\"application/x-sv4crc\":{\"source\":\"apache\",\"extensions\":[\"sv4crc\"]},\"application/x-t3vm-image\":{\"source\":\"apache\",\"extensions\":[\"t3\"]},\"application/x-tads\":{\"source\":\"apache\",\"extensions\":[\"gam\"]},\"application/x-tar\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"tar\"]},\"application/x-tcl\":{\"source\":\"apache\",\"extensions\":[\"tcl\",\"tk\"]},\"application/x-tex\":{\"source\":\"apache\",\"extensions\":[\"tex\"]},\"application/x-tex-tfm\":{\"source\":\"apache\",\"extensions\":[\"tfm\"]},\"application/x-texinfo\":{\"source\":\"apache\",\"extensions\":[\"texinfo\",\"texi\"]},\"application/x-tgif\":{\"source\":\"apache\",\"extensions\":[\"obj\"]},\"application/x-ustar\":{\"source\":\"apache\",\"extensions\":[\"ustar\"]},\"application/x-virtualbox-hdd\":{\"compressible\":true,\"extensions\":[\"hdd\"]},\"application/x-virtualbox-ova\":{\"compressible\":true,\"extensions\":[\"ova\"]},\"application/x-virtualbox-ovf\":{\"compressible\":true,\"extensions\":[\"ovf\"]},\"application/x-virtualbox-vbox\":{\"compressible\":true,\"extensions\":[\"vbox\"]},\"application/x-virtualbox-vbox-extpack\":{\"compressible\":false,\"extensions\":[\"vbox-extpack\"]},\"application/x-virtualbox-vdi\":{\"compressible\":true,\"extensions\":[\"vdi\"]},\"application/x-virtualbox-vhd\":{\"compressible\":true,\"extensions\":[\"vhd\"]},\"application/x-virtualbox-vmdk\":{\"compressible\":true,\"extensions\":[\"vmdk\"]},\"application/x-wais-source\":{\"source\":\"apache\",\"extensions\":[\"src\"]},\"application/x-web-app-manifest+json\":{\"compressible\":true,\"extensions\":[\"webapp\"]},\"application/x-www-form-urlencoded\":{\"source\":\"iana\",\"compressible\":true},\"application/x-x509-ca-cert\":{\"source\":\"apache\",\"extensions\":[\"der\",\"crt\",\"pem\"]},\"application/x-xfig\":{\"source\":\"apache\",\"extensions\":[\"fig\"]},\"application/x-xliff+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xlf\"]},\"application/x-xpinstall\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"xpi\"]},\"application/x-xz\":{\"source\":\"apache\",\"extensions\":[\"xz\"]},\"application/x-zmachine\":{\"source\":\"apache\",\"extensions\":[\"z1\",\"z2\",\"z3\",\"z4\",\"z5\",\"z6\",\"z7\",\"z8\"]},\"application/x400-bp\":{\"source\":\"iana\"},\"application/xacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xaml+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xaml\"]},\"application/xcap-att+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-caps+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdf\"]},\"application/xcap-el+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-error+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-ns+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcon-conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcon-conference-info-diff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xenc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xenc\"]},\"application/xhtml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xhtml\",\"xht\"]},\"application/xhtml-voice+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/xliff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\",\"xsl\",\"xsd\",\"rng\"]},\"application/xml-dtd\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dtd\"]},\"application/xml-external-parsed-entity\":{\"source\":\"iana\"},\"application/xml-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xmpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xop+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xop\"]},\"application/xproc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xpl\"]},\"application/xslt+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xslt\"]},\"application/xspf+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xspf\"]},\"application/xv+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mxml\",\"xhvml\",\"xvml\",\"xvm\"]},\"application/yang\":{\"source\":\"iana\",\"extensions\":[\"yang\"]},\"application/yang-data+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yin+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"yin\"]},\"application/zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"zip\"]},\"application/zlib\":{\"source\":\"iana\"},\"application/zstd\":{\"source\":\"iana\"},\"audio/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"audio/32kadpcm\":{\"source\":\"iana\"},\"audio/3gpp\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"3gpp\"]},\"audio/3gpp2\":{\"source\":\"iana\"},\"audio/aac\":{\"source\":\"iana\"},\"audio/ac3\":{\"source\":\"iana\"},\"audio/adpcm\":{\"source\":\"apache\",\"extensions\":[\"adp\"]},\"audio/amr\":{\"source\":\"iana\"},\"audio/amr-wb\":{\"source\":\"iana\"},\"audio/amr-wb+\":{\"source\":\"iana\"},\"audio/aptx\":{\"source\":\"iana\"},\"audio/asc\":{\"source\":\"iana\"},\"audio/atrac-advanced-lossless\":{\"source\":\"iana\"},\"audio/atrac-x\":{\"source\":\"iana\"},\"audio/atrac3\":{\"source\":\"iana\"},\"audio/basic\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"au\",\"snd\"]},\"audio/bv16\":{\"source\":\"iana\"},\"audio/bv32\":{\"source\":\"iana\"},\"audio/clearmode\":{\"source\":\"iana\"},\"audio/cn\":{\"source\":\"iana\"},\"audio/dat12\":{\"source\":\"iana\"},\"audio/dls\":{\"source\":\"iana\"},\"audio/dsr-es201108\":{\"source\":\"iana\"},\"audio/dsr-es202050\":{\"source\":\"iana\"},\"audio/dsr-es202211\":{\"source\":\"iana\"},\"audio/dsr-es202212\":{\"source\":\"iana\"},\"audio/dv\":{\"source\":\"iana\"},\"audio/dvi4\":{\"source\":\"iana\"},\"audio/eac3\":{\"source\":\"iana\"},\"audio/encaprtp\":{\"source\":\"iana\"},\"audio/evrc\":{\"source\":\"iana\"},\"audio/evrc-qcp\":{\"source\":\"iana\"},\"audio/evrc0\":{\"source\":\"iana\"},\"audio/evrc1\":{\"source\":\"iana\"},\"audio/evrcb\":{\"source\":\"iana\"},\"audio/evrcb0\":{\"source\":\"iana\"},\"audio/evrcb1\":{\"source\":\"iana\"},\"audio/evrcnw\":{\"source\":\"iana\"},\"audio/evrcnw0\":{\"source\":\"iana\"},\"audio/evrcnw1\":{\"source\":\"iana\"},\"audio/evrcwb\":{\"source\":\"iana\"},\"audio/evrcwb0\":{\"source\":\"iana\"},\"audio/evrcwb1\":{\"source\":\"iana\"},\"audio/evs\":{\"source\":\"iana\"},\"audio/flexfec\":{\"source\":\"iana\"},\"audio/fwdred\":{\"source\":\"iana\"},\"audio/g711-0\":{\"source\":\"iana\"},\"audio/g719\":{\"source\":\"iana\"},\"audio/g722\":{\"source\":\"iana\"},\"audio/g7221\":{\"source\":\"iana\"},\"audio/g723\":{\"source\":\"iana\"},\"audio/g726-16\":{\"source\":\"iana\"},\"audio/g726-24\":{\"source\":\"iana\"},\"audio/g726-32\":{\"source\":\"iana\"},\"audio/g726-40\":{\"source\":\"iana\"},\"audio/g728\":{\"source\":\"iana\"},\"audio/g729\":{\"source\":\"iana\"},\"audio/g7291\":{\"source\":\"iana\"},\"audio/g729d\":{\"source\":\"iana\"},\"audio/g729e\":{\"source\":\"iana\"},\"audio/gsm\":{\"source\":\"iana\"},\"audio/gsm-efr\":{\"source\":\"iana\"},\"audio/gsm-hr-08\":{\"source\":\"iana\"},\"audio/ilbc\":{\"source\":\"iana\"},\"audio/ip-mr_v2.5\":{\"source\":\"iana\"},\"audio/isac\":{\"source\":\"apache\"},\"audio/l16\":{\"source\":\"iana\"},\"audio/l20\":{\"source\":\"iana\"},\"audio/l24\":{\"source\":\"iana\",\"compressible\":false},\"audio/l8\":{\"source\":\"iana\"},\"audio/lpc\":{\"source\":\"iana\"},\"audio/melp\":{\"source\":\"iana\"},\"audio/melp1200\":{\"source\":\"iana\"},\"audio/melp2400\":{\"source\":\"iana\"},\"audio/melp600\":{\"source\":\"iana\"},\"audio/midi\":{\"source\":\"apache\",\"extensions\":[\"mid\",\"midi\",\"kar\",\"rmi\"]},\"audio/mobile-xmf\":{\"source\":\"iana\"},\"audio/mp3\":{\"compressible\":false,\"extensions\":[\"mp3\"]},\"audio/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"m4a\",\"mp4a\"]},\"audio/mp4a-latm\":{\"source\":\"iana\"},\"audio/mpa\":{\"source\":\"iana\"},\"audio/mpa-robust\":{\"source\":\"iana\"},\"audio/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpga\",\"mp2\",\"mp2a\",\"mp3\",\"m2a\",\"m3a\"]},\"audio/mpeg4-generic\":{\"source\":\"iana\"},\"audio/musepack\":{\"source\":\"apache\"},\"audio/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"oga\",\"ogg\",\"spx\"]},\"audio/opus\":{\"source\":\"iana\"},\"audio/parityfec\":{\"source\":\"iana\"},\"audio/pcma\":{\"source\":\"iana\"},\"audio/pcma-wb\":{\"source\":\"iana\"},\"audio/pcmu\":{\"source\":\"iana\"},\"audio/pcmu-wb\":{\"source\":\"iana\"},\"audio/prs.sid\":{\"source\":\"iana\"},\"audio/qcelp\":{\"source\":\"iana\"},\"audio/raptorfec\":{\"source\":\"iana\"},\"audio/red\":{\"source\":\"iana\"},\"audio/rtp-enc-aescm128\":{\"source\":\"iana\"},\"audio/rtp-midi\":{\"source\":\"iana\"},\"audio/rtploopback\":{\"source\":\"iana\"},\"audio/rtx\":{\"source\":\"iana\"},\"audio/s3m\":{\"source\":\"apache\",\"extensions\":[\"s3m\"]},\"audio/silk\":{\"source\":\"apache\",\"extensions\":[\"sil\"]},\"audio/smv\":{\"source\":\"iana\"},\"audio/smv-qcp\":{\"source\":\"iana\"},\"audio/smv0\":{\"source\":\"iana\"},\"audio/sp-midi\":{\"source\":\"iana\"},\"audio/speex\":{\"source\":\"iana\"},\"audio/t140c\":{\"source\":\"iana\"},\"audio/t38\":{\"source\":\"iana\"},\"audio/telephone-event\":{\"source\":\"iana\"},\"audio/tetra_acelp\":{\"source\":\"iana\"},\"audio/tone\":{\"source\":\"iana\"},\"audio/uemclip\":{\"source\":\"iana\"},\"audio/ulpfec\":{\"source\":\"iana\"},\"audio/usac\":{\"source\":\"iana\"},\"audio/vdvi\":{\"source\":\"iana\"},\"audio/vmr-wb\":{\"source\":\"iana\"},\"audio/vnd.3gpp.iufp\":{\"source\":\"iana\"},\"audio/vnd.4sb\":{\"source\":\"iana\"},\"audio/vnd.audiokoz\":{\"source\":\"iana\"},\"audio/vnd.celp\":{\"source\":\"iana\"},\"audio/vnd.cisco.nse\":{\"source\":\"iana\"},\"audio/vnd.cmles.radio-events\":{\"source\":\"iana\"},\"audio/vnd.cns.anp1\":{\"source\":\"iana\"},\"audio/vnd.cns.inf1\":{\"source\":\"iana\"},\"audio/vnd.dece.audio\":{\"source\":\"iana\",\"extensions\":[\"uva\",\"uvva\"]},\"audio/vnd.digital-winds\":{\"source\":\"iana\",\"extensions\":[\"eol\"]},\"audio/vnd.dlna.adts\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.1\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.2\":{\"source\":\"iana\"},\"audio/vnd.dolby.mlp\":{\"source\":\"iana\"},\"audio/vnd.dolby.mps\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2x\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2z\":{\"source\":\"iana\"},\"audio/vnd.dolby.pulse.1\":{\"source\":\"iana\"},\"audio/vnd.dra\":{\"source\":\"iana\",\"extensions\":[\"dra\"]},\"audio/vnd.dts\":{\"source\":\"iana\",\"extensions\":[\"dts\"]},\"audio/vnd.dts.hd\":{\"source\":\"iana\",\"extensions\":[\"dtshd\"]},\"audio/vnd.dts.uhd\":{\"source\":\"iana\"},\"audio/vnd.dvb.file\":{\"source\":\"iana\"},\"audio/vnd.everad.plj\":{\"source\":\"iana\"},\"audio/vnd.hns.audio\":{\"source\":\"iana\"},\"audio/vnd.lucent.voice\":{\"source\":\"iana\",\"extensions\":[\"lvp\"]},\"audio/vnd.ms-playready.media.pya\":{\"source\":\"iana\",\"extensions\":[\"pya\"]},\"audio/vnd.nokia.mobile-xmf\":{\"source\":\"iana\"},\"audio/vnd.nortel.vbk\":{\"source\":\"iana\"},\"audio/vnd.nuera.ecelp4800\":{\"source\":\"iana\",\"extensions\":[\"ecelp4800\"]},\"audio/vnd.nuera.ecelp7470\":{\"source\":\"iana\",\"extensions\":[\"ecelp7470\"]},\"audio/vnd.nuera.ecelp9600\":{\"source\":\"iana\",\"extensions\":[\"ecelp9600\"]},\"audio/vnd.octel.sbc\":{\"source\":\"iana\"},\"audio/vnd.presonus.multitrack\":{\"source\":\"iana\"},\"audio/vnd.qcelp\":{\"source\":\"iana\"},\"audio/vnd.rhetorex.32kadpcm\":{\"source\":\"iana\"},\"audio/vnd.rip\":{\"source\":\"iana\",\"extensions\":[\"rip\"]},\"audio/vnd.rn-realaudio\":{\"compressible\":false},\"audio/vnd.sealedmedia.softseal.mpeg\":{\"source\":\"iana\"},\"audio/vnd.vmx.cvsd\":{\"source\":\"iana\"},\"audio/vnd.wave\":{\"compressible\":false},\"audio/vorbis\":{\"source\":\"iana\",\"compressible\":false},\"audio/vorbis-config\":{\"source\":\"iana\"},\"audio/wav\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/wave\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"weba\"]},\"audio/x-aac\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"aac\"]},\"audio/x-aiff\":{\"source\":\"apache\",\"extensions\":[\"aif\",\"aiff\",\"aifc\"]},\"audio/x-caf\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"caf\"]},\"audio/x-flac\":{\"source\":\"apache\",\"extensions\":[\"flac\"]},\"audio/x-m4a\":{\"source\":\"nginx\",\"extensions\":[\"m4a\"]},\"audio/x-matroska\":{\"source\":\"apache\",\"extensions\":[\"mka\"]},\"audio/x-mpegurl\":{\"source\":\"apache\",\"extensions\":[\"m3u\"]},\"audio/x-ms-wax\":{\"source\":\"apache\",\"extensions\":[\"wax\"]},\"audio/x-ms-wma\":{\"source\":\"apache\",\"extensions\":[\"wma\"]},\"audio/x-pn-realaudio\":{\"source\":\"apache\",\"extensions\":[\"ram\",\"ra\"]},\"audio/x-pn-realaudio-plugin\":{\"source\":\"apache\",\"extensions\":[\"rmp\"]},\"audio/x-realaudio\":{\"source\":\"nginx\",\"extensions\":[\"ra\"]},\"audio/x-tta\":{\"source\":\"apache\"},\"audio/x-wav\":{\"source\":\"apache\",\"extensions\":[\"wav\"]},\"audio/xm\":{\"source\":\"apache\",\"extensions\":[\"xm\"]},\"chemical/x-cdx\":{\"source\":\"apache\",\"extensions\":[\"cdx\"]},\"chemical/x-cif\":{\"source\":\"apache\",\"extensions\":[\"cif\"]},\"chemical/x-cmdf\":{\"source\":\"apache\",\"extensions\":[\"cmdf\"]},\"chemical/x-cml\":{\"source\":\"apache\",\"extensions\":[\"cml\"]},\"chemical/x-csml\":{\"source\":\"apache\",\"extensions\":[\"csml\"]},\"chemical/x-pdb\":{\"source\":\"apache\"},\"chemical/x-xyz\":{\"source\":\"apache\",\"extensions\":[\"xyz\"]},\"font/collection\":{\"source\":\"iana\",\"extensions\":[\"ttc\"]},\"font/otf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"otf\"]},\"font/sfnt\":{\"source\":\"iana\"},\"font/ttf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ttf\"]},\"font/woff\":{\"source\":\"iana\",\"extensions\":[\"woff\"]},\"font/woff2\":{\"source\":\"iana\",\"extensions\":[\"woff2\"]},\"image/aces\":{\"source\":\"iana\",\"extensions\":[\"exr\"]},\"image/apng\":{\"compressible\":false,\"extensions\":[\"apng\"]},\"image/avci\":{\"source\":\"iana\"},\"image/avcs\":{\"source\":\"iana\"},\"image/bmp\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/cgm\":{\"source\":\"iana\",\"extensions\":[\"cgm\"]},\"image/dicom-rle\":{\"source\":\"iana\",\"extensions\":[\"drle\"]},\"image/emf\":{\"source\":\"iana\",\"extensions\":[\"emf\"]},\"image/fits\":{\"source\":\"iana\",\"extensions\":[\"fits\"]},\"image/g3fax\":{\"source\":\"iana\",\"extensions\":[\"g3\"]},\"image/gif\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gif\"]},\"image/heic\":{\"source\":\"iana\",\"extensions\":[\"heic\"]},\"image/heic-sequence\":{\"source\":\"iana\",\"extensions\":[\"heics\"]},\"image/heif\":{\"source\":\"iana\",\"extensions\":[\"heif\"]},\"image/heif-sequence\":{\"source\":\"iana\",\"extensions\":[\"heifs\"]},\"image/hej2k\":{\"source\":\"iana\",\"extensions\":[\"hej2\"]},\"image/hsj2\":{\"source\":\"iana\",\"extensions\":[\"hsj2\"]},\"image/ief\":{\"source\":\"iana\",\"extensions\":[\"ief\"]},\"image/jls\":{\"source\":\"iana\",\"extensions\":[\"jls\"]},\"image/jp2\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jp2\",\"jpg2\"]},\"image/jpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpeg\",\"jpg\",\"jpe\"]},\"image/jph\":{\"source\":\"iana\",\"extensions\":[\"jph\"]},\"image/jphc\":{\"source\":\"iana\",\"extensions\":[\"jhc\"]},\"image/jpm\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpm\"]},\"image/jpx\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpx\",\"jpf\"]},\"image/jxr\":{\"source\":\"iana\",\"extensions\":[\"jxr\"]},\"image/jxra\":{\"source\":\"iana\",\"extensions\":[\"jxra\"]},\"image/jxrs\":{\"source\":\"iana\",\"extensions\":[\"jxrs\"]},\"image/jxs\":{\"source\":\"iana\",\"extensions\":[\"jxs\"]},\"image/jxsc\":{\"source\":\"iana\",\"extensions\":[\"jxsc\"]},\"image/jxsi\":{\"source\":\"iana\",\"extensions\":[\"jxsi\"]},\"image/jxss\":{\"source\":\"iana\",\"extensions\":[\"jxss\"]},\"image/ktx\":{\"source\":\"iana\",\"extensions\":[\"ktx\"]},\"image/naplps\":{\"source\":\"iana\"},\"image/pjpeg\":{\"compressible\":false},\"image/png\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"png\"]},\"image/prs.btif\":{\"source\":\"iana\",\"extensions\":[\"btif\"]},\"image/prs.pti\":{\"source\":\"iana\",\"extensions\":[\"pti\"]},\"image/pwg-raster\":{\"source\":\"iana\"},\"image/sgi\":{\"source\":\"apache\",\"extensions\":[\"sgi\"]},\"image/svg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"svg\",\"svgz\"]},\"image/t38\":{\"source\":\"iana\",\"extensions\":[\"t38\"]},\"image/tiff\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"tif\",\"tiff\"]},\"image/tiff-fx\":{\"source\":\"iana\",\"extensions\":[\"tfx\"]},\"image/vnd.adobe.photoshop\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"psd\"]},\"image/vnd.airzip.accelerator.azv\":{\"source\":\"iana\",\"extensions\":[\"azv\"]},\"image/vnd.cns.inf2\":{\"source\":\"iana\"},\"image/vnd.dece.graphic\":{\"source\":\"iana\",\"extensions\":[\"uvi\",\"uvvi\",\"uvg\",\"uvvg\"]},\"image/vnd.djvu\":{\"source\":\"iana\",\"extensions\":[\"djvu\",\"djv\"]},\"image/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"image/vnd.dwg\":{\"source\":\"iana\",\"extensions\":[\"dwg\"]},\"image/vnd.dxf\":{\"source\":\"iana\",\"extensions\":[\"dxf\"]},\"image/vnd.fastbidsheet\":{\"source\":\"iana\",\"extensions\":[\"fbs\"]},\"image/vnd.fpx\":{\"source\":\"iana\",\"extensions\":[\"fpx\"]},\"image/vnd.fst\":{\"source\":\"iana\",\"extensions\":[\"fst\"]},\"image/vnd.fujixerox.edmics-mmr\":{\"source\":\"iana\",\"extensions\":[\"mmr\"]},\"image/vnd.fujixerox.edmics-rlc\":{\"source\":\"iana\",\"extensions\":[\"rlc\"]},\"image/vnd.globalgraphics.pgb\":{\"source\":\"iana\"},\"image/vnd.microsoft.icon\":{\"source\":\"iana\",\"extensions\":[\"ico\"]},\"image/vnd.mix\":{\"source\":\"iana\"},\"image/vnd.mozilla.apng\":{\"source\":\"iana\"},\"image/vnd.ms-dds\":{\"extensions\":[\"dds\"]},\"image/vnd.ms-modi\":{\"source\":\"iana\",\"extensions\":[\"mdi\"]},\"image/vnd.ms-photo\":{\"source\":\"apache\",\"extensions\":[\"wdp\"]},\"image/vnd.net-fpx\":{\"source\":\"iana\",\"extensions\":[\"npx\"]},\"image/vnd.radiance\":{\"source\":\"iana\"},\"image/vnd.sealed.png\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.gif\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.jpg\":{\"source\":\"iana\"},\"image/vnd.svf\":{\"source\":\"iana\"},\"image/vnd.tencent.tap\":{\"source\":\"iana\",\"extensions\":[\"tap\"]},\"image/vnd.valve.source.texture\":{\"source\":\"iana\",\"extensions\":[\"vtf\"]},\"image/vnd.wap.wbmp\":{\"source\":\"iana\",\"extensions\":[\"wbmp\"]},\"image/vnd.xiff\":{\"source\":\"iana\",\"extensions\":[\"xif\"]},\"image/vnd.zbrush.pcx\":{\"source\":\"iana\",\"extensions\":[\"pcx\"]},\"image/webp\":{\"source\":\"apache\",\"extensions\":[\"webp\"]},\"image/wmf\":{\"source\":\"iana\",\"extensions\":[\"wmf\"]},\"image/x-3ds\":{\"source\":\"apache\",\"extensions\":[\"3ds\"]},\"image/x-cmu-raster\":{\"source\":\"apache\",\"extensions\":[\"ras\"]},\"image/x-cmx\":{\"source\":\"apache\",\"extensions\":[\"cmx\"]},\"image/x-freehand\":{\"source\":\"apache\",\"extensions\":[\"fh\",\"fhc\",\"fh4\",\"fh5\",\"fh7\"]},\"image/x-icon\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ico\"]},\"image/x-jng\":{\"source\":\"nginx\",\"extensions\":[\"jng\"]},\"image/x-mrsid-image\":{\"source\":\"apache\",\"extensions\":[\"sid\"]},\"image/x-ms-bmp\":{\"source\":\"nginx\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/x-pcx\":{\"source\":\"apache\",\"extensions\":[\"pcx\"]},\"image/x-pict\":{\"source\":\"apache\",\"extensions\":[\"pic\",\"pct\"]},\"image/x-portable-anymap\":{\"source\":\"apache\",\"extensions\":[\"pnm\"]},\"image/x-portable-bitmap\":{\"source\":\"apache\",\"extensions\":[\"pbm\"]},\"image/x-portable-graymap\":{\"source\":\"apache\",\"extensions\":[\"pgm\"]},\"image/x-portable-pixmap\":{\"source\":\"apache\",\"extensions\":[\"ppm\"]},\"image/x-rgb\":{\"source\":\"apache\",\"extensions\":[\"rgb\"]},\"image/x-tga\":{\"source\":\"apache\",\"extensions\":[\"tga\"]},\"image/x-xbitmap\":{\"source\":\"apache\",\"extensions\":[\"xbm\"]},\"image/x-xcf\":{\"compressible\":false},\"image/x-xpixmap\":{\"source\":\"apache\",\"extensions\":[\"xpm\"]},\"image/x-xwindowdump\":{\"source\":\"apache\",\"extensions\":[\"xwd\"]},\"message/cpim\":{\"source\":\"iana\"},\"message/delivery-status\":{\"source\":\"iana\"},\"message/disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"disposition-notification\"]},\"message/external-body\":{\"source\":\"iana\"},\"message/feedback-report\":{\"source\":\"iana\"},\"message/global\":{\"source\":\"iana\",\"extensions\":[\"u8msg\"]},\"message/global-delivery-status\":{\"source\":\"iana\",\"extensions\":[\"u8dsn\"]},\"message/global-disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"u8mdn\"]},\"message/global-headers\":{\"source\":\"iana\",\"extensions\":[\"u8hdr\"]},\"message/http\":{\"source\":\"iana\",\"compressible\":false},\"message/imdn+xml\":{\"source\":\"iana\",\"compressible\":true},\"message/news\":{\"source\":\"iana\"},\"message/partial\":{\"source\":\"iana\",\"compressible\":false},\"message/rfc822\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eml\",\"mime\"]},\"message/s-http\":{\"source\":\"iana\"},\"message/sip\":{\"source\":\"iana\"},\"message/sipfrag\":{\"source\":\"iana\"},\"message/tracking-status\":{\"source\":\"iana\"},\"message/vnd.si.simp\":{\"source\":\"iana\"},\"message/vnd.wfa.wsc\":{\"source\":\"iana\",\"extensions\":[\"wsc\"]},\"model/3mf\":{\"source\":\"iana\",\"extensions\":[\"3mf\"]},\"model/gltf+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gltf\"]},\"model/gltf-binary\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"glb\"]},\"model/iges\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"igs\",\"iges\"]},\"model/mesh\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"msh\",\"mesh\",\"silo\"]},\"model/stl\":{\"source\":\"iana\",\"extensions\":[\"stl\"]},\"model/vnd.collada+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dae\"]},\"model/vnd.dwf\":{\"source\":\"iana\",\"extensions\":[\"dwf\"]},\"model/vnd.flatland.3dml\":{\"source\":\"iana\"},\"model/vnd.gdl\":{\"source\":\"iana\",\"extensions\":[\"gdl\"]},\"model/vnd.gs-gdl\":{\"source\":\"apache\"},\"model/vnd.gs.gdl\":{\"source\":\"iana\"},\"model/vnd.gtw\":{\"source\":\"iana\",\"extensions\":[\"gtw\"]},\"model/vnd.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"model/vnd.mts\":{\"source\":\"iana\",\"extensions\":[\"mts\"]},\"model/vnd.opengex\":{\"source\":\"iana\",\"extensions\":[\"ogex\"]},\"model/vnd.parasolid.transmit.binary\":{\"source\":\"iana\",\"extensions\":[\"x_b\"]},\"model/vnd.parasolid.transmit.text\":{\"source\":\"iana\",\"extensions\":[\"x_t\"]},\"model/vnd.rosette.annotated-data-model\":{\"source\":\"iana\"},\"model/vnd.usdz+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"usdz\"]},\"model/vnd.valve.source.compiled-map\":{\"source\":\"iana\",\"extensions\":[\"bsp\"]},\"model/vnd.vtu\":{\"source\":\"iana\",\"extensions\":[\"vtu\"]},\"model/vrml\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"wrl\",\"vrml\"]},\"model/x3d+binary\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3db\",\"x3dbz\"]},\"model/x3d+fastinfoset\":{\"source\":\"iana\",\"extensions\":[\"x3db\"]},\"model/x3d+vrml\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3dv\",\"x3dvz\"]},\"model/x3d+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"x3d\",\"x3dz\"]},\"model/x3d-vrml\":{\"source\":\"iana\",\"extensions\":[\"x3dv\"]},\"multipart/alternative\":{\"source\":\"iana\",\"compressible\":false},\"multipart/appledouble\":{\"source\":\"iana\"},\"multipart/byteranges\":{\"source\":\"iana\"},\"multipart/digest\":{\"source\":\"iana\"},\"multipart/encrypted\":{\"source\":\"iana\",\"compressible\":false},\"multipart/form-data\":{\"source\":\"iana\",\"compressible\":false},\"multipart/header-set\":{\"source\":\"iana\"},\"multipart/mixed\":{\"source\":\"iana\"},\"multipart/multilingual\":{\"source\":\"iana\"},\"multipart/parallel\":{\"source\":\"iana\"},\"multipart/related\":{\"source\":\"iana\",\"compressible\":false},\"multipart/report\":{\"source\":\"iana\"},\"multipart/signed\":{\"source\":\"iana\",\"compressible\":false},\"multipart/vnd.bint.med-plus\":{\"source\":\"iana\"},\"multipart/voice-message\":{\"source\":\"iana\"},\"multipart/x-mixed-replace\":{\"source\":\"iana\"},\"text/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"text/cache-manifest\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"appcache\",\"manifest\"]},\"text/calendar\":{\"source\":\"iana\",\"extensions\":[\"ics\",\"ifb\"]},\"text/calender\":{\"compressible\":true},\"text/cmd\":{\"compressible\":true},\"text/coffeescript\":{\"extensions\":[\"coffee\",\"litcoffee\"]},\"text/css\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"css\"]},\"text/csv\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csv\"]},\"text/csv-schema\":{\"source\":\"iana\"},\"text/directory\":{\"source\":\"iana\"},\"text/dns\":{\"source\":\"iana\"},\"text/ecmascript\":{\"source\":\"iana\"},\"text/encaprtp\":{\"source\":\"iana\"},\"text/enriched\":{\"source\":\"iana\"},\"text/flexfec\":{\"source\":\"iana\"},\"text/fwdred\":{\"source\":\"iana\"},\"text/grammar-ref-list\":{\"source\":\"iana\"},\"text/html\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"html\",\"htm\",\"shtml\"]},\"text/jade\":{\"extensions\":[\"jade\"]},\"text/javascript\":{\"source\":\"iana\",\"compressible\":true},\"text/jcr-cnd\":{\"source\":\"iana\"},\"text/jsx\":{\"compressible\":true,\"extensions\":[\"jsx\"]},\"text/less\":{\"compressible\":true,\"extensions\":[\"less\"]},\"text/markdown\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"markdown\",\"md\"]},\"text/mathml\":{\"source\":\"nginx\",\"extensions\":[\"mml\"]},\"text/mdx\":{\"compressible\":true,\"extensions\":[\"mdx\"]},\"text/mizar\":{\"source\":\"iana\"},\"text/n3\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"n3\"]},\"text/parameters\":{\"source\":\"iana\"},\"text/parityfec\":{\"source\":\"iana\"},\"text/plain\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"txt\",\"text\",\"conf\",\"def\",\"list\",\"log\",\"in\",\"ini\"]},\"text/provenance-notation\":{\"source\":\"iana\"},\"text/prs.fallenstein.rst\":{\"source\":\"iana\"},\"text/prs.lines.tag\":{\"source\":\"iana\",\"extensions\":[\"dsc\"]},\"text/prs.prop.logic\":{\"source\":\"iana\"},\"text/raptorfec\":{\"source\":\"iana\"},\"text/red\":{\"source\":\"iana\"},\"text/rfc822-headers\":{\"source\":\"iana\"},\"text/richtext\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtx\"]},\"text/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"text/rtp-enc-aescm128\":{\"source\":\"iana\"},\"text/rtploopback\":{\"source\":\"iana\"},\"text/rtx\":{\"source\":\"iana\"},\"text/sgml\":{\"source\":\"iana\",\"extensions\":[\"sgml\",\"sgm\"]},\"text/shex\":{\"extensions\":[\"shex\"]},\"text/slim\":{\"extensions\":[\"slim\",\"slm\"]},\"text/strings\":{\"source\":\"iana\"},\"text/stylus\":{\"extensions\":[\"stylus\",\"styl\"]},\"text/t140\":{\"source\":\"iana\"},\"text/tab-separated-values\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tsv\"]},\"text/troff\":{\"source\":\"iana\",\"extensions\":[\"t\",\"tr\",\"roff\",\"man\",\"me\",\"ms\"]},\"text/turtle\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"extensions\":[\"ttl\"]},\"text/ulpfec\":{\"source\":\"iana\"},\"text/uri-list\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uri\",\"uris\",\"urls\"]},\"text/vcard\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vcard\"]},\"text/vnd.a\":{\"source\":\"iana\"},\"text/vnd.abc\":{\"source\":\"iana\"},\"text/vnd.ascii-art\":{\"source\":\"iana\"},\"text/vnd.curl\":{\"source\":\"iana\",\"extensions\":[\"curl\"]},\"text/vnd.curl.dcurl\":{\"source\":\"apache\",\"extensions\":[\"dcurl\"]},\"text/vnd.curl.mcurl\":{\"source\":\"apache\",\"extensions\":[\"mcurl\"]},\"text/vnd.curl.scurl\":{\"source\":\"apache\",\"extensions\":[\"scurl\"]},\"text/vnd.debian.copyright\":{\"source\":\"iana\"},\"text/vnd.dmclientscript\":{\"source\":\"iana\"},\"text/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"text/vnd.esmertec.theme-descriptor\":{\"source\":\"iana\"},\"text/vnd.ficlab.flt\":{\"source\":\"iana\"},\"text/vnd.fly\":{\"source\":\"iana\",\"extensions\":[\"fly\"]},\"text/vnd.fmi.flexstor\":{\"source\":\"iana\",\"extensions\":[\"flx\"]},\"text/vnd.gml\":{\"source\":\"iana\"},\"text/vnd.graphviz\":{\"source\":\"iana\",\"extensions\":[\"gv\"]},\"text/vnd.hgl\":{\"source\":\"iana\"},\"text/vnd.in3d.3dml\":{\"source\":\"iana\",\"extensions\":[\"3dml\"]},\"text/vnd.in3d.spot\":{\"source\":\"iana\",\"extensions\":[\"spot\"]},\"text/vnd.iptc.newsml\":{\"source\":\"iana\"},\"text/vnd.iptc.nitf\":{\"source\":\"iana\"},\"text/vnd.latex-z\":{\"source\":\"iana\"},\"text/vnd.motorola.reflex\":{\"source\":\"iana\"},\"text/vnd.ms-mediapackage\":{\"source\":\"iana\"},\"text/vnd.net2phone.commcenter.command\":{\"source\":\"iana\"},\"text/vnd.radisys.msml-basic-layout\":{\"source\":\"iana\"},\"text/vnd.senx.warpscript\":{\"source\":\"iana\"},\"text/vnd.si.uricatalogue\":{\"source\":\"iana\"},\"text/vnd.sosi\":{\"source\":\"iana\"},\"text/vnd.sun.j2me.app-descriptor\":{\"source\":\"iana\",\"extensions\":[\"jad\"]},\"text/vnd.trolltech.linguist\":{\"source\":\"iana\"},\"text/vnd.wap.si\":{\"source\":\"iana\"},\"text/vnd.wap.sl\":{\"source\":\"iana\"},\"text/vnd.wap.wml\":{\"source\":\"iana\",\"extensions\":[\"wml\"]},\"text/vnd.wap.wmlscript\":{\"source\":\"iana\",\"extensions\":[\"wmls\"]},\"text/vtt\":{\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"vtt\"]},\"text/x-asm\":{\"source\":\"apache\",\"extensions\":[\"s\",\"asm\"]},\"text/x-c\":{\"source\":\"apache\",\"extensions\":[\"c\",\"cc\",\"cxx\",\"cpp\",\"h\",\"hh\",\"dic\"]},\"text/x-component\":{\"source\":\"nginx\",\"extensions\":[\"htc\"]},\"text/x-fortran\":{\"source\":\"apache\",\"extensions\":[\"f\",\"for\",\"f77\",\"f90\"]},\"text/x-gwt-rpc\":{\"compressible\":true},\"text/x-handlebars-template\":{\"extensions\":[\"hbs\"]},\"text/x-java-source\":{\"source\":\"apache\",\"extensions\":[\"java\"]},\"text/x-jquery-tmpl\":{\"compressible\":true},\"text/x-lua\":{\"extensions\":[\"lua\"]},\"text/x-markdown\":{\"compressible\":true,\"extensions\":[\"mkd\"]},\"text/x-nfo\":{\"source\":\"apache\",\"extensions\":[\"nfo\"]},\"text/x-opml\":{\"source\":\"apache\",\"extensions\":[\"opml\"]},\"text/x-org\":{\"compressible\":true,\"extensions\":[\"org\"]},\"text/x-pascal\":{\"source\":\"apache\",\"extensions\":[\"p\",\"pas\"]},\"text/x-processing\":{\"compressible\":true,\"extensions\":[\"pde\"]},\"text/x-sass\":{\"extensions\":[\"sass\"]},\"text/x-scss\":{\"extensions\":[\"scss\"]},\"text/x-setext\":{\"source\":\"apache\",\"extensions\":[\"etx\"]},\"text/x-sfv\":{\"source\":\"apache\",\"extensions\":[\"sfv\"]},\"text/x-suse-ymp\":{\"compressible\":true,\"extensions\":[\"ymp\"]},\"text/x-uuencode\":{\"source\":\"apache\",\"extensions\":[\"uu\"]},\"text/x-vcalendar\":{\"source\":\"apache\",\"extensions\":[\"vcs\"]},\"text/x-vcard\":{\"source\":\"apache\",\"extensions\":[\"vcf\"]},\"text/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\"]},\"text/xml-external-parsed-entity\":{\"source\":\"iana\"},\"text/yaml\":{\"extensions\":[\"yaml\",\"yml\"]},\"video/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"video/3gpp\":{\"source\":\"iana\",\"extensions\":[\"3gp\",\"3gpp\"]},\"video/3gpp-tt\":{\"source\":\"iana\"},\"video/3gpp2\":{\"source\":\"iana\",\"extensions\":[\"3g2\"]},\"video/bmpeg\":{\"source\":\"iana\"},\"video/bt656\":{\"source\":\"iana\"},\"video/celb\":{\"source\":\"iana\"},\"video/dv\":{\"source\":\"iana\"},\"video/encaprtp\":{\"source\":\"iana\"},\"video/flexfec\":{\"source\":\"iana\"},\"video/h261\":{\"source\":\"iana\",\"extensions\":[\"h261\"]},\"video/h263\":{\"source\":\"iana\",\"extensions\":[\"h263\"]},\"video/h263-1998\":{\"source\":\"iana\"},\"video/h263-2000\":{\"source\":\"iana\"},\"video/h264\":{\"source\":\"iana\",\"extensions\":[\"h264\"]},\"video/h264-rcdo\":{\"source\":\"iana\"},\"video/h264-svc\":{\"source\":\"iana\"},\"video/h265\":{\"source\":\"iana\"},\"video/iso.segment\":{\"source\":\"iana\"},\"video/jpeg\":{\"source\":\"iana\",\"extensions\":[\"jpgv\"]},\"video/jpeg2000\":{\"source\":\"iana\"},\"video/jpm\":{\"source\":\"apache\",\"extensions\":[\"jpm\",\"jpgm\"]},\"video/mj2\":{\"source\":\"iana\",\"extensions\":[\"mj2\",\"mjp2\"]},\"video/mp1s\":{\"source\":\"iana\"},\"video/mp2p\":{\"source\":\"iana\"},\"video/mp2t\":{\"source\":\"iana\",\"extensions\":[\"ts\"]},\"video/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mp4\",\"mp4v\",\"mpg4\"]},\"video/mp4v-es\":{\"source\":\"iana\"},\"video/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpeg\",\"mpg\",\"mpe\",\"m1v\",\"m2v\"]},\"video/mpeg4-generic\":{\"source\":\"iana\"},\"video/mpv\":{\"source\":\"iana\"},\"video/nv\":{\"source\":\"iana\"},\"video/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogv\"]},\"video/parityfec\":{\"source\":\"iana\"},\"video/pointer\":{\"source\":\"iana\"},\"video/quicktime\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"qt\",\"mov\"]},\"video/raptorfec\":{\"source\":\"iana\"},\"video/raw\":{\"source\":\"iana\"},\"video/rtp-enc-aescm128\":{\"source\":\"iana\"},\"video/rtploopback\":{\"source\":\"iana\"},\"video/rtx\":{\"source\":\"iana\"},\"video/smpte291\":{\"source\":\"iana\"},\"video/smpte292m\":{\"source\":\"iana\"},\"video/ulpfec\":{\"source\":\"iana\"},\"video/vc1\":{\"source\":\"iana\"},\"video/vc2\":{\"source\":\"iana\"},\"video/vnd.cctv\":{\"source\":\"iana\"},\"video/vnd.dece.hd\":{\"source\":\"iana\",\"extensions\":[\"uvh\",\"uvvh\"]},\"video/vnd.dece.mobile\":{\"source\":\"iana\",\"extensions\":[\"uvm\",\"uvvm\"]},\"video/vnd.dece.mp4\":{\"source\":\"iana\"},\"video/vnd.dece.pd\":{\"source\":\"iana\",\"extensions\":[\"uvp\",\"uvvp\"]},\"video/vnd.dece.sd\":{\"source\":\"iana\",\"extensions\":[\"uvs\",\"uvvs\"]},\"video/vnd.dece.video\":{\"source\":\"iana\",\"extensions\":[\"uvv\",\"uvvv\"]},\"video/vnd.directv.mpeg\":{\"source\":\"iana\"},\"video/vnd.directv.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dlna.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dvb.file\":{\"source\":\"iana\",\"extensions\":[\"dvb\"]},\"video/vnd.fvt\":{\"source\":\"iana\",\"extensions\":[\"fvt\"]},\"video/vnd.hns.video\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsavc\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsmpeg2\":{\"source\":\"iana\"},\"video/vnd.motorola.video\":{\"source\":\"iana\"},\"video/vnd.motorola.videop\":{\"source\":\"iana\"},\"video/vnd.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"mxu\",\"m4u\"]},\"video/vnd.ms-playready.media.pyv\":{\"source\":\"iana\",\"extensions\":[\"pyv\"]},\"video/vnd.nokia.interleaved-multimedia\":{\"source\":\"iana\"},\"video/vnd.nokia.mp4vr\":{\"source\":\"iana\"},\"video/vnd.nokia.videovoip\":{\"source\":\"iana\"},\"video/vnd.objectvideo\":{\"source\":\"iana\"},\"video/vnd.radgamettools.bink\":{\"source\":\"iana\"},\"video/vnd.radgamettools.smacker\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg1\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg4\":{\"source\":\"iana\"},\"video/vnd.sealed.swf\":{\"source\":\"iana\"},\"video/vnd.sealedmedia.softseal.mov\":{\"source\":\"iana\"},\"video/vnd.uvvu.mp4\":{\"source\":\"iana\",\"extensions\":[\"uvu\",\"uvvu\"]},\"video/vnd.vivo\":{\"source\":\"iana\",\"extensions\":[\"viv\"]},\"video/vnd.youtube.yt\":{\"source\":\"iana\"},\"video/vp8\":{\"source\":\"iana\"},\"video/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"webm\"]},\"video/x-f4v\":{\"source\":\"apache\",\"extensions\":[\"f4v\"]},\"video/x-fli\":{\"source\":\"apache\",\"extensions\":[\"fli\"]},\"video/x-flv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"flv\"]},\"video/x-m4v\":{\"source\":\"apache\",\"extensions\":[\"m4v\"]},\"video/x-matroska\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"mkv\",\"mk3d\",\"mks\"]},\"video/x-mng\":{\"source\":\"apache\",\"extensions\":[\"mng\"]},\"video/x-ms-asf\":{\"source\":\"apache\",\"extensions\":[\"asf\",\"asx\"]},\"video/x-ms-vob\":{\"source\":\"apache\",\"extensions\":[\"vob\"]},\"video/x-ms-wm\":{\"source\":\"apache\",\"extensions\":[\"wm\"]},\"video/x-ms-wmv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"wmv\"]},\"video/x-ms-wmx\":{\"source\":\"apache\",\"extensions\":[\"wmx\"]},\"video/x-ms-wvx\":{\"source\":\"apache\",\"extensions\":[\"wvx\"]},\"video/x-msvideo\":{\"source\":\"apache\",\"extensions\":[\"avi\"]},\"video/x-sgi-movie\":{\"source\":\"apache\",\"extensions\":[\"movie\"]},\"video/x-smv\":{\"source\":\"apache\",\"extensions\":[\"smv\"]},\"x-conference/x-cooltalk\":{\"source\":\"apache\",\"extensions\":[\"ice\"]},\"x-shader/x-fragment\":{\"compressible\":true},\"x-shader/x-vertex\":{\"compressible\":true}}");

/***/ }),

/***/ "./node_modules/mini-create-react-context/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/mini-create-react-context/dist/esm/index.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var gud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gud */ "./node_modules/gud/index.js");
/* harmony import */ var gud__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gud__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");






var MAX_SIGNED_31_BIT_INT = 1073741823;

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + gud__WEBPACK_IMPORTED_MODULE_3___default()() + '__';

  var Provider =
  /*#__PURE__*/
  function (_Component) {
    _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if (true) {
            Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired, _Provider$childContex);

  var Consumer =
  /*#__PURE__*/
  function (_Component2) {
    _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

var index = react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext || createReactContext;

/* harmony default export */ __webpack_exports__["default"] = (index);


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/path-to-regexp/index.js":
/*!**********************************************!*\
  !*** ./node_modules/path-to-regexp/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__(/*! isarray */ "./node_modules/path-to-regexp/node_modules/isarray/index.js")

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),

/***/ "./node_modules/path-to-regexp/node_modules/isarray/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/path-to-regexp/node_modules/isarray/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(/*! ./pseudomap */ "./node_modules/pseudomap/pseudomap.js")
}


/***/ }),

/***/ "./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-server.node.development.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-server.node.development.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.11.0
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");
var stream = __webpack_require__(/*! stream */ "stream");

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.11.0';

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be replaced with error codes
// during build.

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var warningWithoutStack = function () {};

{
  warningWithoutStack = function (condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (args.length > 8) {
      // Check before the condition to catch violations early.
      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
    }

    if (condition) {
      return;
    }

    if (typeof console !== 'undefined') {
      var argsWithFormat = args.map(function (item) {
        return '' + item;
      });
      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610

      Function.prototype.apply.call(console.error, console, argsWithFormat);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  };
}

var warningWithoutStack$1 = warningWithoutStack;

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?


var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;

var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.
// Current owner and dispatcher used to share the same ref,
// but PR #14548 split them out to better support the react-debug-tools package.

if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {
  ReactSharedInternals.ReactCurrentDispatcher = {
    current: null
  };
}

if (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {
  ReactSharedInternals.ReactCurrentBatchConfig = {
    suspense: null
  };
}

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = warningWithoutStack$1;

{
  warning = function (condition, format) {
    if (condition) {
      return;
    }

    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum(); // eslint-disable-next-line react-internal/warning-and-invariant-args

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    warningWithoutStack$1.apply(void 0, [false, format + '%s'].concat(args, [stack]));
  };
}

var warning$1 = warning;

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;
function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}
function initializeLazyComponentType(lazyComponent) {
  if (lazyComponent._status === Uninitialized) {
    lazyComponent._status = Pending;
    var ctor = lazyComponent._ctor;
    var thenable = ctor();
    lazyComponent._result = thenable;
    thenable.then(function (moduleObject) {
      if (lazyComponent._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            warning$1(false, 'lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
          }
        }

        lazyComponent._status = Resolved;
        lazyComponent._result = defaultExport;
      }
    }, function (error) {
      if (lazyComponent._status === Pending) {
        lazyComponent._status = Rejected;
        lazyComponent._result = error;
      }
    });
  }
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return "Profiler";

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';

      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = refineResolvedLazyComponent(thenable);

          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }

          break;
        }
    }
  }

  return null;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var lowPriorityWarningWithoutStack = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.warn(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarningWithoutStack = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  };
}

var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
var describeComponentFrame = function (name, source, ownerName) {
  var sourceInfo = '';

  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');

    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);

        if (match) {
          var pathBeforeSlash = match[1];

          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }

    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }

  return '\n    in ' + (name || 'Unknown') + sourceInfo;
};

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:

 // In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:

 // To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.

 // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:

var warnAboutDeprecatedLifecycles = true; // Gather advanced timing metrics for Profiler subtrees.

 // Trace which interactions trigger each commit.

 // SSR experiments

var enableSuspenseServerRenderer = false;
 // Only used in www builds.

 // Only used in www builds.

 // Disable javascript: URL strings in href for XSS protection.

var disableJavaScriptURLs = false; // React Fire: prevent the value and checked attributes from syncing
// with their related DOM properties

 // These APIs will no longer be "unstable" in the upcoming 16.7 release,
// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.


 // Experimental React Flare event system and event components support.

var enableFlareAPI = false; // Experimental Host Component support.

var enableFundamentalAPI = false; // Experimental Scope support.

var enableScopeAPI = false; // New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107

 // We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)
// Till then, we warn about the missing mock, but still fallback to a sync mode compatible version

 // For tests, we flush suspense fallbacks in an act scope;
// *except* in some of our own tests, where we test incremental loading states.

 // Add a callback property to suspense to notify which promises are currently
// in the update queue. This allows reporting and tracing of what is causing
// the user to see a loading state.
// Also allows hydration callbacks to fire when a dehydrated boundary gets
// hydrated or deleted.

 // Part of the simplification of React.createElement so we can eventually move
// from React.createElement to React.jsx
// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md



var disableLegacyContext = false;

var ReactDebugCurrentFrame$1;
var didWarnAboutInvalidateContextType;

{
  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
  didWarnAboutInvalidateContextType = new Set();
}

var emptyObject = {};

{
  Object.freeze(emptyObject);
}

function maskContext(type, context) {
  var contextTypes = type.contextTypes;

  if (!contextTypes) {
    return emptyObject;
  }

  var maskedContext = {};

  for (var contextName in contextTypes) {
    maskedContext[contextName] = context[contextName];
  }

  return maskedContext;
}

function checkContextTypes(typeSpecs, values, location) {
  {
    checkPropTypes(typeSpecs, values, location, 'Component', ReactDebugCurrentFrame$1.getCurrentStack);
  }
}

function validateContextBounds(context, threadID) {
  // If we don't have enough slots in this context to store this threadID,
  // fill it in without leaving any holes to ensure that the VM optimizes
  // this as non-holey index properties.
  // (Note: If `react` package is < 16.6, _threadCount is undefined.)
  for (var i = context._threadCount | 0; i <= threadID; i++) {
    // We assume that this is the same as the defaultValue which might not be
    // true if we're rendering inside a secondary renderer but they are
    // secondary because these use cases are very rare.
    context[i] = context._currentValue2;
    context._threadCount = i + 1;
  }
}
function processContext(type, context, threadID, isClass) {
  if (isClass) {
    var contextType = type.contextType;

    {
      if ('contextType' in type) {
        var isValid = // Allow null for conditional declaration
        contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

        if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
          didWarnAboutInvalidateContextType.add(type);
          var addendum = '';

          if (contextType === undefined) {
            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
          } else if (typeof contextType !== 'object') {
            addendum = ' However, it is set to a ' + typeof contextType + '.';
          } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
            addendum = ' Did you accidentally pass the Context.Provider instead?';
          } else if (contextType._context !== undefined) {
            // <Context.Consumer>
            addendum = ' Did you accidentally pass the Context.Consumer instead?';
          } else {
            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
          }

          warningWithoutStack$1(false, '%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(type) || 'Component', addendum);
        }
      }
    }

    if (typeof contextType === 'object' && contextType !== null) {
      validateContextBounds(contextType, threadID);
      return contextType[threadID];
    }

    if (disableLegacyContext) {
      {
        if (type.contextTypes) {
          warningWithoutStack$1(false, '%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with static contextType instead.', getComponentName(type) || 'Unknown');
        }
      }

      return emptyObject;
    } else {
      var maskedContext = maskContext(type, context);

      {
        if (type.contextTypes) {
          checkContextTypes(type.contextTypes, maskedContext, 'context');
        }
      }

      return maskedContext;
    }
  } else {
    if (disableLegacyContext) {
      {
        if (type.contextTypes) {
          warningWithoutStack$1(false, '%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with React.useContext() instead.', getComponentName(type) || 'Unknown');
        }
      }

      return undefined;
    } else {
      var _maskedContext = maskContext(type, context);

      {
        if (type.contextTypes) {
          checkContextTypes(type.contextTypes, _maskedContext, 'context');
        }
      }

      return _maskedContext;
    }
  }
}

// Allocates a new index for each request. Tries to stay as compact as possible so that these
// indices can be used to reference a tightly packed array. As opposed to being used in a Map.
// The first allocated index is 1.
var nextAvailableThreadIDs = new Uint16Array(16);

for (var i = 0; i < 15; i++) {
  nextAvailableThreadIDs[i] = i + 1;
}

nextAvailableThreadIDs[15] = 0;

function growThreadCountAndReturnNextAvailable() {
  var oldArray = nextAvailableThreadIDs;
  var oldSize = oldArray.length;
  var newSize = oldSize * 2;

  if (!(newSize <= 0x10000)) {
    {
      throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
    }
  }

  var newArray = new Uint16Array(newSize);
  newArray.set(oldArray);
  nextAvailableThreadIDs = newArray;
  nextAvailableThreadIDs[0] = oldSize + 1;

  for (var _i = oldSize; _i < newSize - 1; _i++) {
    nextAvailableThreadIDs[_i] = _i + 1;
  }

  nextAvailableThreadIDs[newSize - 1] = 0;
  return oldSize;
}

function allocThreadID() {
  var nextID = nextAvailableThreadIDs[0];

  if (nextID === 0) {
    return growThreadCountAndReturnNextAvailable();
  }

  nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
  return nextID;
}
function freeThreadID(id) {
  nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
  nextAvailableThreadIDs[0] = id;
}

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the whitelist are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */

var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";

var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty$1.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }

  if (hasOwnProperty$1.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;

  {
    warning$1(false, 'Invalid attribute name: `%s`', attributeName);
  }

  return false;
}
function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }

  return false;
}
function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  switch (typeof value) {
    case 'function': // $FlowIssue symbol is perfectly valid here

    case 'symbol':
      // eslint-disable-line
      return true;

    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }

        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }

    default:
      return false;
  }
}
function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {
    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;

      case OVERLOADED_BOOLEAN:
        return value === false;

      case NUMERIC:
        return isNaN(value);

      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }

  return false;
}
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function (token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML whitelist.
// Some of these attributes can be hard to find. This list was created by
// scrapping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true);
});

var ReactDebugCurrentFrame$2 = null;

{
  ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;
} // A javascript: URL can contain leading C0 control or \u0020 SPACE,
// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space

/* eslint-disable max-len */


var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
var didWarn = false;

function sanitizeURL(url) {
  if (disableJavaScriptURLs) {
    if (!!isJavaScriptProtocol.test(url)) {
      {
        throw Error("React has blocked a javascript: URL as a security precaution." + (ReactDebugCurrentFrame$2.getStackAddendum()));
      }
    }
  } else if ( true && !didWarn && isJavaScriptProtocol.test(url)) {
    didWarn = true;
    warning$1(false, 'A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
  }
}

// code copied and modified from escape-html

/**
 * Module variables.
 * @private
 */
var matchHtmlRegExp = /["'&<>]/;
/**
 * Escapes special characters and HTML entities in a given html string.
 *
 * @param  {string} string HTML string to escape for later insertion
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;

      case 38:
        // &
        escape = '&amp;';
        break;

      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'

        break;

      case 60:
        // <
        escape = '&lt;';
        break;

      case 62:
        // >
        escape = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
} // end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */


function escapeTextForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }

  return escapeHtml(text);
}

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */

function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextForBrowser(value) + '"';
}

/**
 * Operations for dealing with DOM properties.
 */

/**
 * Creates markup for the ID property.
 *
 * @param {string} id Unescaped ID.
 * @return {string} Markup string.
 */


function createMarkupForRoot() {
  return ROOT_ATTRIBUTE_NAME + '=""';
}
/**
 * Creates markup for a property.
 *
 * @param {string} name
 * @param {*} value
 * @return {?string} Markup string, or null if the property was invalid.
 */

function createMarkupForProperty(name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (name !== 'style' && shouldIgnoreAttribute(name, propertyInfo, false)) {
    return '';
  }

  if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
    return '';
  }

  if (propertyInfo !== null) {
    var attributeName = propertyInfo.attributeName;
    var type = propertyInfo.type;

    if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
      return attributeName + '=""';
    } else {
      if (propertyInfo.sanitizeURL) {
        value = '' + value;
        sanitizeURL(value);
      }

      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    }
  } else if (isAttributeNameSafe(name)) {
    return name + '=' + quoteAttributeValueForBrowser(value);
  }

  return '';
}
/**
 * Creates markup for a custom property.
 *
 * @param {string} name
 * @param {*} value
 * @return {string} Markup string, or empty string if the property was invalid.
 */

function createMarkupForCustomAttribute(name, value) {
  if (!isAttributeNameSafe(name) || value == null) {
    return '';
  }

  return name + '=' + quoteAttributeValueForBrowser(value);
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var is$1 = typeof Object.is === 'function' ? Object.is : is;

var currentlyRenderingComponent = null;
var firstWorkInProgressHook = null;
var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook

var isReRender = false; // Whether an update was scheduled during the currently executing render pass.

var didScheduleRenderPhaseUpdate = false; // Lazily created map of render-phase updates

var renderPhaseUpdates = null; // Counter to prevent infinite loops.

var numberOfReRenders = 0;
var RE_RENDER_LIMIT = 25;
var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook

var currentHookNameInDev;

function resolveCurrentlyRenderingComponent() {
  if (!(currentlyRenderingComponent !== null)) {
    {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
    }
  }

  {
    !!isInHookUserCodeInDev ? warning$1(false, 'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://fb.me/rules-of-hooks') : void 0;
  }

  return currentlyRenderingComponent;
}

function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) {
    {
      warning$1(false, '%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }

    return false;
  }

  {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      warning$1(false, 'The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + nextDeps.join(', ') + "]", "[" + prevDeps.join(', ') + "]");
    }
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (is$1(nextDeps[i], prevDeps[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function createHook() {
  if (numberOfReRenders > 0) {
    {
      {
        throw Error("Rendered more hooks than during the previous render");
      }
    }
  }

  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}

function createWorkInProgressHook() {
  if (workInProgressHook === null) {
    // This is the first hook in the list
    if (firstWorkInProgressHook === null) {
      isReRender = false;
      firstWorkInProgressHook = workInProgressHook = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = firstWorkInProgressHook;
    }
  } else {
    if (workInProgressHook.next === null) {
      isReRender = false; // Append to the end of the list

      workInProgressHook = workInProgressHook.next = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = workInProgressHook.next;
    }
  }

  return workInProgressHook;
}

function prepareToUseHooks(componentIdentity) {
  currentlyRenderingComponent = componentIdentity;

  {
    isInHookUserCodeInDev = false;
  } // The following should have already been reset
  // didScheduleRenderPhaseUpdate = false;
  // firstWorkInProgressHook = null;
  // numberOfReRenders = 0;
  // renderPhaseUpdates = null;
  // workInProgressHook = null;

}
function finishHooks(Component, props, children, refOrContext) {
  // This must be called after every function component to prevent hooks from
  // being used in classes.
  while (didScheduleRenderPhaseUpdate) {
    // Updates were scheduled during the render phase. They are stored in
    // the `renderPhaseUpdates` map. Call the component again, reusing the
    // work-in-progress hooks and applying the additional updates on top. Keep
    // restarting until no more updates are scheduled.
    didScheduleRenderPhaseUpdate = false;
    numberOfReRenders += 1; // Start over from the beginning of the list

    workInProgressHook = null;
    children = Component(props, refOrContext);
  }

  currentlyRenderingComponent = null;
  firstWorkInProgressHook = null;
  numberOfReRenders = 0;
  renderPhaseUpdates = null;
  workInProgressHook = null;

  {
    isInHookUserCodeInDev = false;
  } // These were reset above
  // currentlyRenderingComponent = null;
  // didScheduleRenderPhaseUpdate = false;
  // firstWorkInProgressHook = null;
  // numberOfReRenders = 0;
  // renderPhaseUpdates = null;
  // workInProgressHook = null;


  return children;
}

function readContext(context, observedBits) {
  var threadID = currentThreadID;
  validateContextBounds(context, threadID);

  {
    !!isInHookUserCodeInDev ? warning$1(false, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().') : void 0;
  }

  return context[threadID];
}

function useContext(context, observedBits) {
  {
    currentHookNameInDev = 'useContext';
  }

  resolveCurrentlyRenderingComponent();
  var threadID = currentThreadID;
  validateContextBounds(context, threadID);
  return context[threadID];
}

function basicStateReducer(state, action) {
  return typeof action === 'function' ? action(state) : action;
}

function useState(initialState) {
  {
    currentHookNameInDev = 'useState';
  }

  return useReducer(basicStateReducer, // useReducer has a special case to support lazy useState initializers
  initialState);
}
function useReducer(reducer, initialArg, init) {
  {
    if (reducer !== basicStateReducer) {
      currentHookNameInDev = 'useReducer';
    }
  }

  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();

  if (isReRender) {
    // This is a re-render. Apply the new render phase updates to the previous
    // current hook.
    var queue = workInProgressHook.queue;
    var dispatch = queue.dispatch;

    if (renderPhaseUpdates !== null) {
      // Render phase updates are stored in a map of queue -> linked list
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

      if (firstRenderPhaseUpdate !== undefined) {
        renderPhaseUpdates.delete(queue);
        var newState = workInProgressHook.memoizedState;
        var update = firstRenderPhaseUpdate;

        do {
          // Process this render phase update. We don't have to check the
          // priority because it will always be the same as the current
          // render's.
          var action = update.action;

          {
            isInHookUserCodeInDev = true;
          }

          newState = reducer(newState, action);

          {
            isInHookUserCodeInDev = false;
          }

          update = update.next;
        } while (update !== null);

        workInProgressHook.memoizedState = newState;
        return [newState, dispatch];
      }
    }

    return [workInProgressHook.memoizedState, dispatch];
  } else {
    {
      isInHookUserCodeInDev = true;
    }

    var initialState;

    if (reducer === basicStateReducer) {
      // Special case for `useState`.
      initialState = typeof initialArg === 'function' ? initialArg() : initialArg;
    } else {
      initialState = init !== undefined ? init(initialArg) : initialArg;
    }

    {
      isInHookUserCodeInDev = false;
    }

    workInProgressHook.memoizedState = initialState;

    var _queue = workInProgressHook.queue = {
      last: null,
      dispatch: null
    };

    var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);

    return [workInProgressHook.memoizedState, _dispatch];
  }
}

function useMemo(nextCreate, deps) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;

  if (workInProgressHook !== null) {
    var prevState = workInProgressHook.memoizedState;

    if (prevState !== null) {
      if (nextDeps !== null) {
        var prevDeps = prevState[1];

        if (areHookInputsEqual(nextDeps, prevDeps)) {
          return prevState[0];
        }
      }
    }
  }

  {
    isInHookUserCodeInDev = true;
  }

  var nextValue = nextCreate();

  {
    isInHookUserCodeInDev = false;
  }

  workInProgressHook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function useRef(initialValue) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  var previousRef = workInProgressHook.memoizedState;

  if (previousRef === null) {
    var ref = {
      current: initialValue
    };

    {
      Object.seal(ref);
    }

    workInProgressHook.memoizedState = ref;
    return ref;
  } else {
    return previousRef;
  }
}

function useLayoutEffect(create, inputs) {
  {
    currentHookNameInDev = 'useLayoutEffect';
  }

  warning$1(false, 'useLayoutEffect does nothing on the server, because its effect cannot ' + "be encoded into the server renderer's output format. This will lead " + 'to a mismatch between the initial, non-hydrated UI and the intended ' + 'UI. To avoid this, useLayoutEffect should only be used in ' + 'components that render exclusively on the client. ' + 'See https://fb.me/react-uselayouteffect-ssr for common fixes.');
}

function dispatchAction(componentIdentity, queue, action) {
  if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
    {
      throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
    }
  }

  if (componentIdentity === currentlyRenderingComponent) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdate = true;
    var update = {
      action: action,
      next: null
    };

    if (renderPhaseUpdates === null) {
      renderPhaseUpdates = new Map();
    }

    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

    if (firstRenderPhaseUpdate === undefined) {
      renderPhaseUpdates.set(queue, update);
    } else {
      // Append the update to the end of the list.
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

      while (lastRenderPhaseUpdate.next !== null) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }

      lastRenderPhaseUpdate.next = update;
    }
  } else {// This means an update has happened after the function component has
    // returned. On the server this is a no-op. In React Fiber, the update
    // would be scheduled for a future render.
  }
}

function useCallback(callback, deps) {
  // Callbacks are passed as they are in the server environment.
  return callback;
}

function useResponder(responder, props) {
  return {
    props: props,
    responder: responder
  };
}

function useDeferredValue(value, config) {
  resolveCurrentlyRenderingComponent();
  return value;
}

function useTransition(config) {
  resolveCurrentlyRenderingComponent();

  var startTransition = function (callback) {
    callback();
  };

  return [startTransition, false];
}

function noop() {}

var currentThreadID = 0;
function setCurrentThreadID(threadID) {
  currentThreadID = threadID;
}
var Dispatcher = {
  readContext: readContext,
  useContext: useContext,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  useLayoutEffect: useLayoutEffect,
  useCallback: useCallback,
  // useImperativeHandle is not run in the server environment
  useImperativeHandle: noop,
  // Effects are not run in the server environment.
  useEffect: noop,
  // Debugging effect
  useDebugValue: noop,
  useResponder: useResponder,
  useDeferredValue: useDeferredValue,
  useTransition: useTransition
};

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
var Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
}; // Assumes there is no parent namespace.

function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;

    case 'math':
      return MATH_NAMESPACE;

    default:
      return HTML_NAMESPACE;
  }
}
function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }

  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  } // By default, pass namespace below.


  return parentNamespace;
}

var ReactDebugCurrentFrame$3 = null;
var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  ReactDebugCurrentFrame$3 = ReactSharedInternals.ReactDebugCurrentFrame;
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };
  var propTypes = {
    value: function (props, propName, componentName) {
      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null || enableFlareAPI && props.listeners) {
        return null;
      }

      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (props.onChange || props.readOnly || props.disabled || props[propName] == null || enableFlareAPI && props.listeners) {
        return null;
      }

      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };
  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */

  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {
    checkPropTypes(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame$3.getStackAddendum);
  };
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

};

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

// or add stack by default to invariants where possible.

var HTML = '__html';
var ReactDebugCurrentFrame$4 = null;

{
  ReactDebugCurrentFrame$4 = ReactSharedInternals.ReactDebugCurrentFrame;
}

function assertValidProps(tag, props) {
  if (!props) {
    return;
  } // Note the use of `==` which checks for null or undefined.


  if (voidElementTags[tag]) {
    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
      {
        throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." + (ReactDebugCurrentFrame$4.getStackAddendum()));
      }
    }
  }

  if (props.dangerouslySetInnerHTML != null) {
    if (!(props.children == null)) {
      {
        throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
      }
    }

    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
      {
        throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.");
      }
    }
  }

  {
    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning$1(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
  }

  if (!(props.style == null || typeof props.style === 'object')) {
    {
      throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." + (ReactDebugCurrentFrame$4.getStackAddendum()));
    }
  }
}

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon

  var badStyleValueWithSemicolonPattern = /;\s*$/;
  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$1(false, 'Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$1(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning$1(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning$1(false, '`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning$1(false, '`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

var ariaProperties = {
  'aria-current': 0,
  // state
  'aria-details': 0,
  'aria-disabled': 0,
  // state
  'aria-hidden': 0,
  // state
  'aria-invalid': 0,
  // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.

    if (correctName == null) {
      warning$1(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
      warnedProperties[name] = true;
      return true;
    } // aria-* attributes should be lowercase; suggest the lowercase version.


    if (name !== correctName) {
      warning$1(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.

    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    } // aria-* attributes should be lowercase; suggest the lowercase version.


    if (name !== standardName) {
      warning$1(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);

    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning$1(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  } else if (invalidProps.length > 1) {
    warning$1(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;
function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;

    if (type === 'select' && props.multiple) {
      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
    } else {
      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */



/**
 * Mapping from event name to dispatch config
 */


/**
 * Mapping from registration name to plugin module
 */

var registrationNameModules = {};
/**
 * Mapping from registration name to event name
 */


/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */

var possibleRegistrationNames = {}; // Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */


/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  disablepictureinpicture: 'disablePictureInPicture',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',
  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning$1(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    } // We can't rely on the event system being injected on the server.


    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }

      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

      if (registrationName != null) {
        warning$1(false, 'Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
        warnedProperties$1[name] = true;
        return true;
      }

      if (EVENT_NAME_REGEX.test(name)) {
        warning$1(false, 'Unknown event handler property `%s`. It will be ignored.', name);
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning$1(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Let the ARIA attribute hook validate ARIA attributes


    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning$1(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning$1(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning$1(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning$1(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.

    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];

      if (standardName !== name) {
        warning$1(false, 'Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning$1(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Now that we've validated casing, do not validate
    // data types for reserved props


    if (isReserved) {
      return true;
    } // Warn when a known attribute is a bad type


    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    } // Warn when passing the strings 'false' or 'true' into a boolean prop


    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      warning$1(false, 'Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];

  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);

    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    warning$1(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  } else if (unknownProps.length > 1) {
    warning$1(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnUnknownProperties(type, props, canUseEventSystem);
}

var toArray = React.Children.toArray; // This is only used in DEV.
// Each entry is `this.stack` from a currently executing renderer instance.
// (There may be more than one because ReactDOMServer is reentrant).
// Each stack is an array of frames which may contain nested stacks of elements.

var currentDebugStacks = [];
var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var ReactDebugCurrentFrame;
var prevGetCurrentStackImpl = null;

var getCurrentServerStackImpl = function () {
  return '';
};

var describeStackFrame = function (element) {
  return '';
};

var validatePropertiesInDevelopment = function (type, props) {};

var pushCurrentDebugStack = function (stack) {};

var pushElementToDebugStack = function (element) {};

var popCurrentDebugStack = function () {};

var hasWarnedAboutUsingContextAsConsumer = false;

{
  ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props,
    /* canUseEventSystem */
    false);
  };

  describeStackFrame = function (element) {
    var source = element._source;
    var type = element.type;
    var name = getComponentName(type);
    var ownerName = null;
    return describeComponentFrame(name, source, ownerName);
  };

  pushCurrentDebugStack = function (stack) {
    currentDebugStacks.push(stack);

    if (currentDebugStacks.length === 1) {
      // We are entering a server renderer.
      // Remember the previous (e.g. client) global stack implementation.
      prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;
      ReactDebugCurrentFrame.getCurrentStack = getCurrentServerStackImpl;
    }
  };

  pushElementToDebugStack = function (element) {
    // For the innermost executing ReactDOMServer call,
    var stack = currentDebugStacks[currentDebugStacks.length - 1]; // Take the innermost executing frame (e.g. <Foo>),

    var frame = stack[stack.length - 1]; // and record that it has one more element associated with it.

    frame.debugElementStack.push(element); // We only need this because we tail-optimize single-element
    // children and directly handle them in an inner loop instead of
    // creating separate frames for them.
  };

  popCurrentDebugStack = function () {
    currentDebugStacks.pop();

    if (currentDebugStacks.length === 0) {
      // We are exiting the server renderer.
      // Restore the previous (e.g. client) global stack implementation.
      ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;
      prevGetCurrentStackImpl = null;
    }
  };

  getCurrentServerStackImpl = function () {
    if (currentDebugStacks.length === 0) {
      // Nothing is currently rendering.
      return '';
    } // ReactDOMServer is reentrant so there may be multiple calls at the same time.
    // Take the frames from the innermost call which is the last in the array.


    var frames = currentDebugStacks[currentDebugStacks.length - 1];
    var stack = ''; // Go through every frame in the stack from the innermost one.

    for (var i = frames.length - 1; i >= 0; i--) {
      var frame = frames[i]; // Every frame might have more than one debug element stack entry associated with it.
      // This is because single-child nesting doesn't create materialized frames.
      // Instead it would push them through `pushElementToDebugStack()`.

      var debugElementStack = frame.debugElementStack;

      for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
        stack += describeStackFrame(debugElementStack[ii]);
      }
    }

    return stack;
  };
}

var didWarnDefaultInputValue = false;
var didWarnDefaultChecked = false;
var didWarnDefaultSelectValue = false;
var didWarnDefaultTextareaValue = false;
var didWarnInvalidOptionChildren = false;
var didWarnAboutNoopUpdateForComponent = {};
var didWarnAboutBadClass = {};
var didWarnAboutModulePatternComponent = {};
var didWarnAboutDeprecatedWillMount = {};
var didWarnAboutUndefinedDerivedState = {};
var didWarnAboutUninitializedState = {};
var valuePropNames = ['value', 'defaultValue'];
var newlineEatingTags = {
  listing: true,
  pre: true,
  textarea: true
}; // We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset

var validatedTagCache = {};

function validateDangerousTag(tag) {
  if (!validatedTagCache.hasOwnProperty(tag)) {
    if (!VALID_TAG_REGEX.test(tag)) {
      {
        throw Error("Invalid tag: " + tag);
      }
    }

    validatedTagCache[tag] = true;
  }
}

var styleNameCache = {};

var processStyleName = function (styleName) {
  if (styleNameCache.hasOwnProperty(styleName)) {
    return styleNameCache[styleName];
  }

  var result = hyphenateStyleName(styleName);
  styleNameCache[styleName] = result;
  return result;
};

function createMarkupForStyles(styles) {
  var serialized = '';
  var delimiter = '';

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;
    var styleValue = styles[styleName];

    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styleValue);
      }
    }

    if (styleValue != null) {
      serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ':';
      serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
      delimiter = ';';
    }
  }

  return serialized || null;
}

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && getComponentName(_constructor) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;

    if (didWarnAboutNoopUpdateForComponent[warningKey]) {
      return;
    }

    warningWithoutStack$1(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnAboutNoopUpdateForComponent[warningKey] = true;
  }
}

function shouldConstruct(Component) {
  return Component.prototype && Component.prototype.isReactComponent;
}

function getNonChildrenInnerMarkup(props) {
  var innerHTML = props.dangerouslySetInnerHTML;

  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      return innerHTML.__html;
    }
  } else {
    var content = props.children;

    if (typeof content === 'string' || typeof content === 'number') {
      return escapeTextForBrowser(content);
    }
  }

  return null;
}

function flattenTopLevelChildren(children) {
  if (!React.isValidElement(children)) {
    return toArray(children);
  }

  var element = children;

  if (element.type !== REACT_FRAGMENT_TYPE) {
    return [element];
  }

  var fragmentChildren = element.props.children;

  if (!React.isValidElement(fragmentChildren)) {
    return toArray(fragmentChildren);
  }

  var fragmentChildElement = fragmentChildren;
  return [fragmentChildElement];
}

function flattenOptionChildren(children) {
  if (children === undefined || children === null) {
    return children;
  }

  var content = ''; // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.

  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }

    content += child;

    {
      if (!didWarnInvalidOptionChildren && typeof child !== 'string' && typeof child !== 'number') {
        didWarnInvalidOptionChildren = true;
        warning$1(false, 'Only strings and numbers are supported as <option> children.');
      }
    }
  });
  return content;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var STYLE = 'style';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null,
  suppressHydrationWarning: null
};

function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
  var ret = '<' + tagVerbatim;

  for (var propKey in props) {
    if (!hasOwnProperty.call(props, propKey)) {
      continue;
    }

    if (enableFlareAPI && propKey === 'listeners') {
      continue;
    }

    var propValue = props[propKey];

    if (propValue == null) {
      continue;
    }

    if (propKey === STYLE) {
      propValue = createMarkupForStyles(propValue);
    }

    var markup = null;

    if (isCustomComponent(tagLowercase, props)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        markup = createMarkupForCustomAttribute(propKey, propValue);
      }
    } else {
      markup = createMarkupForProperty(propKey, propValue);
    }

    if (markup) {
      ret += ' ' + markup;
    }
  } // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.


  if (makeStaticMarkup) {
    return ret;
  }

  if (isRootElement) {
    ret += ' ' + createMarkupForRoot();
  }

  return ret;
}

function validateRenderResult(child, type) {
  if (child === undefined) {
    {
      {
        throw Error((getComponentName(type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
      }
    }
  }
}

function resolve(child, context, threadID) {
  while (React.isValidElement(child)) {
    // Safe because we just checked it's an element.
    var element = child;
    var Component = element.type;

    {
      pushElementToDebugStack(element);
    }

    if (typeof Component !== 'function') {
      break;
    }

    processChild(element, Component);
  } // Extra closure so queue and replace can be captured properly


  function processChild(element, Component) {
    var isClass = shouldConstruct(Component);
    var publicContext = processContext(Component, context, threadID, isClass);
    var queue = [];
    var replace = false;
    var updater = {
      isMounted: function (publicInstance) {
        return false;
      },
      enqueueForceUpdate: function (publicInstance) {
        if (queue === null) {
          warnNoop(publicInstance, 'forceUpdate');
          return null;
        }
      },
      enqueueReplaceState: function (publicInstance, completeState) {
        replace = true;
        queue = [completeState];
      },
      enqueueSetState: function (publicInstance, currentPartialState) {
        if (queue === null) {
          warnNoop(publicInstance, 'setState');
          return null;
        }

        queue.push(currentPartialState);
      }
    };
    var inst;

    if (isClass) {
      inst = new Component(element.props, publicContext, updater);

      if (typeof Component.getDerivedStateFromProps === 'function') {
        {
          if (inst.state === null || inst.state === undefined) {
            var componentName = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutUninitializedState[componentName]) {
              warningWithoutStack$1(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, inst.state === null ? 'null' : 'undefined', componentName);
              didWarnAboutUninitializedState[componentName] = true;
            }
          }
        }

        var partialState = Component.getDerivedStateFromProps.call(null, element.props, inst.state);

        {
          if (partialState === undefined) {
            var _componentName = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutUndefinedDerivedState[_componentName]) {
              warningWithoutStack$1(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', _componentName);
              didWarnAboutUndefinedDerivedState[_componentName] = true;
            }
          }
        }

        if (partialState != null) {
          inst.state = _assign({}, inst.state, partialState);
        }
      }
    } else {
      {
        if (Component.prototype && typeof Component.prototype.render === 'function') {
          var _componentName2 = getComponentName(Component) || 'Unknown';

          if (!didWarnAboutBadClass[_componentName2]) {
            warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', _componentName2, _componentName2);
            didWarnAboutBadClass[_componentName2] = true;
          }
        }
      }

      var componentIdentity = {};
      prepareToUseHooks(componentIdentity);
      inst = Component(element.props, publicContext, updater);
      inst = finishHooks(Component, element.props, inst, publicContext);

      if (inst == null || inst.render == null) {
        child = inst;
        validateRenderResult(child, Component);
        return;
      }

      {
        var _componentName3 = getComponentName(Component) || 'Unknown';

        if (!didWarnAboutModulePatternComponent[_componentName3]) {
          warningWithoutStack$1(false, 'The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName3, _componentName3, _componentName3);
          didWarnAboutModulePatternComponent[_componentName3] = true;
        }
      }
    }

    inst.props = element.props;
    inst.context = publicContext;
    inst.updater = updater;
    var initialState = inst.state;

    if (initialState === undefined) {
      inst.state = initialState = null;
    }

    if (typeof inst.UNSAFE_componentWillMount === 'function' || typeof inst.componentWillMount === 'function') {
      if (typeof inst.componentWillMount === 'function') {
        {
          if (warnAboutDeprecatedLifecycles && inst.componentWillMount.__suppressDeprecationWarning !== true) {
            var _componentName4 = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
              lowPriorityWarningWithoutStack$1(false, // keep this warning in sync with ReactStrictModeWarning.js
              'componentWillMount has been renamed, and is not recommended for use. ' + 'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n' + '* Move code from componentWillMount to componentDidMount (preferred in most cases) ' + 'or the constructor.\n' + '\nPlease update the following components: %s', _componentName4);
              didWarnAboutDeprecatedWillMount[_componentName4] = true;
            }
          }
        } // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for any component with the new gDSFP.


        if (typeof Component.getDerivedStateFromProps !== 'function') {
          inst.componentWillMount();
        }
      }

      if (typeof inst.UNSAFE_componentWillMount === 'function' && typeof Component.getDerivedStateFromProps !== 'function') {
        // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for any component with the new gDSFP.
        inst.UNSAFE_componentWillMount();
      }

      if (queue.length) {
        var oldQueue = queue;
        var oldReplace = replace;
        queue = null;
        replace = false;

        if (oldReplace && oldQueue.length === 1) {
          inst.state = oldQueue[0];
        } else {
          var nextState = oldReplace ? oldQueue[0] : inst.state;
          var dontMutate = true;

          for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
            var partial = oldQueue[i];

            var _partialState = typeof partial === 'function' ? partial.call(inst, nextState, element.props, publicContext) : partial;

            if (_partialState != null) {
              if (dontMutate) {
                dontMutate = false;
                nextState = _assign({}, nextState, _partialState);
              } else {
                _assign(nextState, _partialState);
              }
            }
          }

          inst.state = nextState;
        }
      } else {
        queue = null;
      }
    }

    child = inst.render();

    {
      if (child === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        child = null;
      }
    }

    validateRenderResult(child, Component);
    var childContext;

    if (disableLegacyContext) {
      {
        var childContextTypes = Component.childContextTypes;

        if (childContextTypes !== undefined) {
          warningWithoutStack$1(false, '%s uses the legacy childContextTypes API which is no longer supported. ' + 'Use React.createContext() instead.', getComponentName(Component) || 'Unknown');
        }
      }
    } else {
      if (typeof inst.getChildContext === 'function') {
        var _childContextTypes = Component.childContextTypes;

        if (typeof _childContextTypes === 'object') {
          childContext = inst.getChildContext();

          for (var contextKey in childContext) {
            if (!(contextKey in _childContextTypes)) {
              {
                throw Error((getComponentName(Component) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
              }
            }
          }
        } else {
          warningWithoutStack$1(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(Component) || 'Unknown');
        }
      }

      if (childContext) {
        context = _assign({}, context, childContext);
      }
    }
  }

  return {
    child: child,
    context: context
  };
}

var ReactDOMServerRenderer =
/*#__PURE__*/
function () {
  // TODO: type this more strictly:
  // DEV-only
  function ReactDOMServerRenderer(children, makeStaticMarkup) {
    var flatChildren = flattenTopLevelChildren(children);
    var topFrame = {
      type: null,
      // Assume all trees start in the HTML namespace (not totally true, but
      // this is what we did historically)
      domNamespace: Namespaces.html,
      children: flatChildren,
      childIndex: 0,
      context: emptyObject,
      footer: ''
    };

    {
      topFrame.debugElementStack = [];
    }

    this.threadID = allocThreadID();
    this.stack = [topFrame];
    this.exhausted = false;
    this.currentSelectValue = null;
    this.previousWasTextNode = false;
    this.makeStaticMarkup = makeStaticMarkup;
    this.suspenseDepth = 0; // Context (new API)

    this.contextIndex = -1;
    this.contextStack = [];
    this.contextValueStack = [];

    {
      this.contextProviderStack = [];
    }
  }

  var _proto = ReactDOMServerRenderer.prototype;

  _proto.destroy = function destroy() {
    if (!this.exhausted) {
      this.exhausted = true;
      this.clearProviders();
      freeThreadID(this.threadID);
    }
  }
  /**
   * Note: We use just two stacks regardless of how many context providers you have.
   * Providers are always popped in the reverse order to how they were pushed
   * so we always know on the way down which provider you'll encounter next on the way up.
   * On the way down, we push the current provider, and its context value *before*
   * we mutated it, onto the stacks. Therefore, on the way up, we always know which
   * provider needs to be "restored" to which value.
   * https://github.com/facebook/react/pull/12985#issuecomment-396301248
   */
  ;

  _proto.pushProvider = function pushProvider(provider) {
    var index = ++this.contextIndex;
    var context = provider.type._context;
    var threadID = this.threadID;
    validateContextBounds(context, threadID);
    var previousValue = context[threadID]; // Remember which value to restore this context to on our way up.

    this.contextStack[index] = context;
    this.contextValueStack[index] = previousValue;

    {
      // Only used for push/pop mismatch warnings.
      this.contextProviderStack[index] = provider;
    } // Mutate the current value.


    context[threadID] = provider.props.value;
  };

  _proto.popProvider = function popProvider(provider) {
    var index = this.contextIndex;

    {
      !(index > -1 && provider === this.contextProviderStack[index]) ? warningWithoutStack$1(false, 'Unexpected pop.') : void 0;
    }

    var context = this.contextStack[index];
    var previousValue = this.contextValueStack[index]; // "Hide" these null assignments from Flow by using `any`
    // because conceptually they are deletions--as long as we
    // promise to never access values beyond `this.contextIndex`.

    this.contextStack[index] = null;
    this.contextValueStack[index] = null;

    {
      this.contextProviderStack[index] = null;
    }

    this.contextIndex--; // Restore to the previous value we stored as we were walking down.
    // We've already verified that this context has been expanded to accommodate
    // this thread id, so we don't need to do it again.

    context[this.threadID] = previousValue;
  };

  _proto.clearProviders = function clearProviders() {
    // Restore any remaining providers on the stack to previous values
    for (var index = this.contextIndex; index >= 0; index--) {
      var context = this.contextStack[index];
      var previousValue = this.contextValueStack[index];
      context[this.threadID] = previousValue;
    }
  };

  _proto.read = function read(bytes) {
    if (this.exhausted) {
      return null;
    }

    var prevThreadID = currentThreadID;
    setCurrentThreadID(this.threadID);
    var prevDispatcher = ReactCurrentDispatcher.current;
    ReactCurrentDispatcher.current = Dispatcher;

    try {
      // Markup generated within <Suspense> ends up buffered until we know
      // nothing in that boundary suspended
      var out = [''];
      var suspended = false;

      while (out[0].length < bytes) {
        if (this.stack.length === 0) {
          this.exhausted = true;
          freeThreadID(this.threadID);
          break;
        }

        var frame = this.stack[this.stack.length - 1];

        if (suspended || frame.childIndex >= frame.children.length) {
          var footer = frame.footer;

          if (footer !== '') {
            this.previousWasTextNode = false;
          }

          this.stack.pop();

          if (frame.type === 'select') {
            this.currentSelectValue = null;
          } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
            var provider = frame.type;
            this.popProvider(provider);
          } else if (frame.type === REACT_SUSPENSE_TYPE) {
            this.suspenseDepth--;
            var buffered = out.pop();

            if (suspended) {
              suspended = false; // If rendering was suspended at this boundary, render the fallbackFrame

              var fallbackFrame = frame.fallbackFrame;

              if (!fallbackFrame) {
                {
                  throw Error("ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue.");
                }
              }

              this.stack.push(fallbackFrame);
              out[this.suspenseDepth] += '<!--$!-->'; // Skip flushing output since we're switching to the fallback

              continue;
            } else {
              out[this.suspenseDepth] += buffered;
            }
          } // Flush output


          out[this.suspenseDepth] += footer;
          continue;
        }

        var child = frame.children[frame.childIndex++];
        var outBuffer = '';

        {
          pushCurrentDebugStack(this.stack); // We're starting work on this frame, so reset its inner stack.

          frame.debugElementStack.length = 0;
        }

        try {
          outBuffer += this.render(child, frame.context, frame.domNamespace);
        } catch (err) {
          if (err != null && typeof err.then === 'function') {
            if (enableSuspenseServerRenderer) {
              if (!(this.suspenseDepth > 0)) {
                {
                  throw Error("A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
                }
              }

              suspended = true;
            } else {
              {
                {
                  throw Error("ReactDOMServer does not yet support Suspense.");
                }
              }
            }
          } else {
            throw err;
          }
        } finally {
          {
            popCurrentDebugStack();
          }
        }

        if (out.length <= this.suspenseDepth) {
          out.push('');
        }

        out[this.suspenseDepth] += outBuffer;
      }

      return out[0];
    } finally {
      ReactCurrentDispatcher.current = prevDispatcher;
      setCurrentThreadID(prevThreadID);
    }
  };

  _proto.render = function render(child, context, parentNamespace) {
    if (typeof child === 'string' || typeof child === 'number') {
      var text = '' + child;

      if (text === '') {
        return '';
      }

      if (this.makeStaticMarkup) {
        return escapeTextForBrowser(text);
      }

      if (this.previousWasTextNode) {
        return '<!-- -->' + escapeTextForBrowser(text);
      }

      this.previousWasTextNode = true;
      return escapeTextForBrowser(text);
    } else {
      var nextChild;

      var _resolve = resolve(child, context, this.threadID);

      nextChild = _resolve.child;
      context = _resolve.context;

      if (nextChild === null || nextChild === false) {
        return '';
      } else if (!React.isValidElement(nextChild)) {
        if (nextChild != null && nextChild.$$typeof != null) {
          // Catch unexpected special types early.
          var $$typeof = nextChild.$$typeof;

          if (!($$typeof !== REACT_PORTAL_TYPE)) {
            {
              throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            }
          } // Catch-all to prevent an infinite loop if React.Children.toArray() supports some new type.


          {
            {
              throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
            }
          }
        }

        var nextChildren = toArray(nextChild);
        var frame = {
          type: null,
          domNamespace: parentNamespace,
          children: nextChildren,
          childIndex: 0,
          context: context,
          footer: ''
        };

        {
          frame.debugElementStack = [];
        }

        this.stack.push(frame);
        return '';
      } // Safe because we just checked it's an element.


      var nextElement = nextChild;
      var elementType = nextElement.type;

      if (typeof elementType === 'string') {
        return this.renderDOM(nextElement, context, parentNamespace);
      }

      switch (elementType) {
        case REACT_STRICT_MODE_TYPE:
        case REACT_CONCURRENT_MODE_TYPE:
        case REACT_PROFILER_TYPE:
        case REACT_SUSPENSE_LIST_TYPE:
        case REACT_FRAGMENT_TYPE:
          {
            var _nextChildren = toArray(nextChild.props.children);

            var _frame = {
              type: null,
              domNamespace: parentNamespace,
              children: _nextChildren,
              childIndex: 0,
              context: context,
              footer: ''
            };

            {
              _frame.debugElementStack = [];
            }

            this.stack.push(_frame);
            return '';
          }

        case REACT_SUSPENSE_TYPE:
          {
            if (enableSuspenseServerRenderer) {
              var fallback = nextChild.props.fallback;

              if (fallback === undefined) {
                // If there is no fallback, then this just behaves as a fragment.
                var _nextChildren3 = toArray(nextChild.props.children);

                var _frame3 = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: _nextChildren3,
                  childIndex: 0,
                  context: context,
                  footer: ''
                };

                {
                  _frame3.debugElementStack = [];
                }

                this.stack.push(_frame3);
                return '';
              }

              var fallbackChildren = toArray(fallback);

              var _nextChildren2 = toArray(nextChild.props.children);

              var fallbackFrame = {
                type: null,
                domNamespace: parentNamespace,
                children: fallbackChildren,
                childIndex: 0,
                context: context,
                footer: '<!--/$-->'
              };
              var _frame2 = {
                fallbackFrame: fallbackFrame,
                type: REACT_SUSPENSE_TYPE,
                domNamespace: parentNamespace,
                children: _nextChildren2,
                childIndex: 0,
                context: context,
                footer: '<!--/$-->'
              };

              {
                _frame2.debugElementStack = [];
                fallbackFrame.debugElementStack = [];
              }

              this.stack.push(_frame2);
              this.suspenseDepth++;
              return '<!--$-->';
            } else {
              {
                {
                  throw Error("ReactDOMServer does not yet support Suspense.");
                }
              }
            }
          }
        // eslint-disable-next-line-no-fallthrough

        default:
          break;
      }

      if (typeof elementType === 'object' && elementType !== null) {
        switch (elementType.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            {
              var element = nextChild;

              var _nextChildren4;

              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              _nextChildren4 = elementType.render(element.props, element.ref);
              _nextChildren4 = finishHooks(elementType.render, element.props, _nextChildren4, element.ref);
              _nextChildren4 = toArray(_nextChildren4);
              var _frame4 = {
                type: null,
                domNamespace: parentNamespace,
                children: _nextChildren4,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame4.debugElementStack = [];
              }

              this.stack.push(_frame4);
              return '';
            }

          case REACT_MEMO_TYPE:
            {
              var _element = nextChild;
              var _nextChildren5 = [React.createElement(elementType.type, _assign({
                ref: _element.ref
              }, _element.props))];
              var _frame5 = {
                type: null,
                domNamespace: parentNamespace,
                children: _nextChildren5,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame5.debugElementStack = [];
              }

              this.stack.push(_frame5);
              return '';
            }

          case REACT_PROVIDER_TYPE:
            {
              var provider = nextChild;
              var nextProps = provider.props;

              var _nextChildren6 = toArray(nextProps.children);

              var _frame6 = {
                type: provider,
                domNamespace: parentNamespace,
                children: _nextChildren6,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame6.debugElementStack = [];
              }

              this.pushProvider(provider);
              this.stack.push(_frame6);
              return '';
            }

          case REACT_CONTEXT_TYPE:
            {
              var reactContext = nextChild.type; // The logic below for Context differs depending on PROD or DEV mode. In
              // DEV mode, we create a separate object for Context.Consumer that acts
              // like a proxy to Context. This proxy object adds unnecessary code in PROD
              // so we use the old behaviour (Context.Consumer references Context) to
              // reduce size and overhead. The separate object references context via
              // a property called "_context", which also gives us the ability to check
              // in DEV mode if this property exists or not and warn if it does not.

              {
                if (reactContext._context === undefined) {
                  // This may be because it's a Context (rather than a Consumer).
                  // Or it may be because it's older React where they're the same thing.
                  // We only want to warn if we're sure it's a new React.
                  if (reactContext !== reactContext.Consumer) {
                    if (!hasWarnedAboutUsingContextAsConsumer) {
                      hasWarnedAboutUsingContextAsConsumer = true;
                      warning$1(false, 'Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                    }
                  }
                } else {
                  reactContext = reactContext._context;
                }
              }

              var _nextProps = nextChild.props;
              var threadID = this.threadID;
              validateContextBounds(reactContext, threadID);
              var nextValue = reactContext[threadID];

              var _nextChildren7 = toArray(_nextProps.children(nextValue));

              var _frame7 = {
                type: nextChild,
                domNamespace: parentNamespace,
                children: _nextChildren7,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame7.debugElementStack = [];
              }

              this.stack.push(_frame7);
              return '';
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_FUNDAMENTAL_TYPE:
            {
              if (enableFundamentalAPI) {
                var fundamentalImpl = elementType.impl;
                var open = fundamentalImpl.getServerSideString(null, nextElement.props);
                var getServerSideStringClose = fundamentalImpl.getServerSideStringClose;
                var close = getServerSideStringClose !== undefined ? getServerSideStringClose(null, nextElement.props) : '';

                var _nextChildren8 = fundamentalImpl.reconcileChildren !== false ? toArray(nextChild.props.children) : [];

                var _frame8 = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: _nextChildren8,
                  childIndex: 0,
                  context: context,
                  footer: close
                };

                {
                  _frame8.debugElementStack = [];
                }

                this.stack.push(_frame8);
                return open;
              }

              {
                {
                  throw Error("ReactDOMServer does not yet support the fundamental API.");
                }
              }
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_LAZY_TYPE:
            {
              var _element2 = nextChild;
              var lazyComponent = nextChild.type; // Attempt to initialize lazy component regardless of whether the
              // suspense server-side renderer is enabled so synchronously
              // resolved constructors are supported.

              initializeLazyComponentType(lazyComponent);

              switch (lazyComponent._status) {
                case Resolved:
                  {
                    var _nextChildren9 = [React.createElement(lazyComponent._result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame9 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren9,
                      childIndex: 0,
                      context: context,
                      footer: ''
                    };

                    {
                      _frame9.debugElementStack = [];
                    }

                    this.stack.push(_frame9);
                    return '';
                  }

                case Rejected:
                  throw lazyComponent._result;

                case Pending:
                default:
                  {
                    {
                      throw Error("ReactDOMServer does not yet support lazy-loaded components.");
                    }
                  }

              }
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_SCOPE_TYPE:
            {
              if (enableScopeAPI) {
                var _nextChildren10 = toArray(nextChild.props.children);

                var _frame10 = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: _nextChildren10,
                  childIndex: 0,
                  context: context,
                  footer: ''
                };

                {
                  _frame10.debugElementStack = [];
                }

                this.stack.push(_frame10);
                return '';
              }

              {
                {
                  throw Error("ReactDOMServer does not yet support scope components.");
                }
              }
            }
        }
      }

      var info = '';

      {
        var owner = nextElement._owner;

        if (elementType === undefined || typeof elementType === 'object' && elementType !== null && Object.keys(elementType).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
        }

        var ownerName = owner ? getComponentName(owner) : null;

        if (ownerName) {
          info += '\n\nCheck the render method of `' + ownerName + '`.';
        }
      }

      {
        {
          throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
        }
      }
    }
  };

  _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
    var tag = element.type.toLowerCase();
    var namespace = parentNamespace;

    if (parentNamespace === Namespaces.html) {
      namespace = getIntrinsicNamespace(tag);
    }

    {
      if (namespace === Namespaces.html) {
        // Should this check be gated by parent namespace? Not sure we want to
        // allow <SVG> or <mATH>.
        !(tag === element.type) ? warning$1(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', element.type) : void 0;
      }
    }

    validateDangerousTag(tag);
    var props = element.props;

    if (tag === 'input') {
      {
        ReactControlledValuePropTypes.checkPropTypes('input', props);

        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
          warning$1(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', 'A component', props.type);
          didWarnDefaultChecked = true;
        }

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
          warning$1(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', 'A component', props.type);
          didWarnDefaultInputValue = true;
        }
      }

      props = _assign({
        type: undefined
      }, props, {
        defaultChecked: undefined,
        defaultValue: undefined,
        value: props.value != null ? props.value : props.defaultValue,
        checked: props.checked != null ? props.checked : props.defaultChecked
      });
    } else if (tag === 'textarea') {
      {
        ReactControlledValuePropTypes.checkPropTypes('textarea', props);

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
          warning$1(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
          didWarnDefaultTextareaValue = true;
        }
      }

      var initialValue = props.value;

      if (initialValue == null) {
        var defaultValue = props.defaultValue; // TODO (yungsters): Remove support for children content in <textarea>.

        var textareaChildren = props.children;

        if (textareaChildren != null) {
          {
            warning$1(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
          }

          if (!(defaultValue == null)) {
            {
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
          }

          if (Array.isArray(textareaChildren)) {
            if (!(textareaChildren.length <= 1)) {
              {
                throw Error("<textarea> can only have at most one child.");
              }
            }

            textareaChildren = textareaChildren[0];
          }

          defaultValue = '' + textareaChildren;
        }

        if (defaultValue == null) {
          defaultValue = '';
        }

        initialValue = defaultValue;
      }

      props = _assign({}, props, {
        value: undefined,
        children: '' + initialValue
      });
    } else if (tag === 'select') {
      {
        ReactControlledValuePropTypes.checkPropTypes('select', props);

        for (var i = 0; i < valuePropNames.length; i++) {
          var propName = valuePropNames[i];

          if (props[propName] == null) {
            continue;
          }

          var isArray = Array.isArray(props[propName]);

          if (props.multiple && !isArray) {
            warning$1(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.', propName);
          } else if (!props.multiple && isArray) {
            warning$1(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.', propName);
          }
        }

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
          warning$1(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
          didWarnDefaultSelectValue = true;
        }
      }

      this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
      props = _assign({}, props, {
        value: undefined
      });
    } else if (tag === 'option') {
      var selected = null;
      var selectValue = this.currentSelectValue;
      var optionChildren = flattenOptionChildren(props.children);

      if (selectValue != null) {
        var value;

        if (props.value != null) {
          value = props.value + '';
        } else {
          value = optionChildren;
        }

        selected = false;

        if (Array.isArray(selectValue)) {
          // multiple
          for (var j = 0; j < selectValue.length; j++) {
            if ('' + selectValue[j] === value) {
              selected = true;
              break;
            }
          }
        } else {
          selected = '' + selectValue === value;
        }

        props = _assign({
          selected: undefined,
          children: undefined
        }, props, {
          selected: selected,
          children: optionChildren
        });
      }
    }

    {
      validatePropertiesInDevelopment(tag, props);
    }

    assertValidProps(tag, props);
    var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
    var footer = '';

    if (omittedCloseTags.hasOwnProperty(tag)) {
      out += '/>';
    } else {
      out += '>';
      footer = '</' + element.type + '>';
    }

    var children;
    var innerMarkup = getNonChildrenInnerMarkup(props);

    if (innerMarkup != null) {
      children = [];

      if (newlineEatingTags[tag] && innerMarkup.charAt(0) === '\n') {
        // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        out += '\n';
      }

      out += innerMarkup;
    } else {
      children = toArray(props.children);
    }

    var frame = {
      domNamespace: getChildNamespace(parentNamespace, element.type),
      type: tag,
      children: children,
      childIndex: 0,
      context: context,
      footer: footer
    };

    {
      frame.debugElementStack = [];
    }

    this.stack.push(frame);
    this.previousWasTextNode = false;
    return out;
  };

  return ReactDOMServerRenderer;
}();

/**
 * Render a ReactElement to its initial HTML. This should only be used on the
 * server.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostring
 */

function renderToString(element) {
  var renderer = new ReactDOMServerRenderer(element, false);

  try {
    var markup = renderer.read(Infinity);
    return markup;
  } finally {
    renderer.destroy();
  }
}
/**
 * Similar to renderToString, except this doesn't create extra DOM attributes
 * such as data-react-id that React uses internally.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup
 */

function renderToStaticMarkup(element) {
  var renderer = new ReactDOMServerRenderer(element, true);

  try {
    var markup = renderer.read(Infinity);
    return markup;
  } finally {
    renderer.destroy();
  }
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var ReactMarkupReadableStream =
/*#__PURE__*/
function (_Readable) {
  _inheritsLoose(ReactMarkupReadableStream, _Readable);

  function ReactMarkupReadableStream(element, makeStaticMarkup) {
    var _this;

    // Calls the stream.Readable(options) constructor. Consider exposing built-in
    // features like highWaterMark in the future.
    _this = _Readable.call(this, {}) || this;
    _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup);
    return _this;
  }

  var _proto = ReactMarkupReadableStream.prototype;

  _proto._destroy = function _destroy(err, callback) {
    this.partialRenderer.destroy();
    callback(err);
  };

  _proto._read = function _read(size) {
    try {
      this.push(this.partialRenderer.read(size));
    } catch (err) {
      this.destroy(err);
    }
  };

  return ReactMarkupReadableStream;
}(stream.Readable);
/**
 * Render a ReactElement to its initial HTML. This should only be used on the
 * server.
 * See https://reactjs.org/docs/react-dom-server.html#rendertonodestream
 */


function renderToNodeStream(element) {
  return new ReactMarkupReadableStream(element, false);
}
/**
 * Similar to renderToNodeStream, except this doesn't create extra DOM attributes
 * such as data-react-id that React uses internally.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostaticnodestream
 */

function renderToStaticNodeStream(element) {
  return new ReactMarkupReadableStream(element, true);
}

var ReactDOMServerNode = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup,
  renderToNodeStream: renderToNodeStream,
  renderToStaticNodeStream: renderToStaticNodeStream,
  version: ReactVersion
};

var ReactDOMServerNode$1 = Object.freeze({
	default: ReactDOMServerNode
});

var ReactDOMServer = ( ReactDOMServerNode$1 && ReactDOMServerNode ) || ReactDOMServerNode$1;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest


var server_node = ReactDOMServer.default || ReactDOMServer;

module.exports = server_node;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/server.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/server.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./server.node */ "./node_modules/react-dom/server.node.js");


/***/ }),

/***/ "./node_modules/react-dom/server.node.js":
/*!***********************************************!*\
  !*** ./node_modules/react-dom/server.node.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom-server.node.development.js */ "./node_modules/react-dom/cjs/react-dom-server.node.development.js");
}


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.11.0
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var lowPriorityWarningWithoutStack = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.warn(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarningWithoutStack = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  };
}

var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarningWithoutStack$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-router-dom/esm/react-router-dom.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-router-dom/esm/react-router-dom.js ***!
  \***************************************************************/
/*! exports provided: BrowserRouter, HashRouter, Link, NavLink, MemoryRouter, Prompt, Redirect, Route, Router, StaticRouter, Switch, __RouterContext, generatePath, matchPath, useHistory, useLocation, useParams, useRouteMatch, withRouter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserRouter", function() { return BrowserRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashRouter", function() { return HashRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return Link; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavLink", function() { return NavLink; });
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router */ "./node_modules/react-router/esm/react-router.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["MemoryRouter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Prompt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Redirect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Route"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Router"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["StaticRouter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Switch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__RouterContext", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["__RouterContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generatePath", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["generatePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["matchPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useHistory", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useHistory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useLocation", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useLocation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useParams", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useParams"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRouteMatch", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useRouteMatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["withRouter"]; });

/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history */ "./node_modules/history/esm/history.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tiny-invariant */ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");











/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = Object(history__WEBPACK_IMPORTED_MODULE_3__["createBrowserHistory"])(_this.props);
    return _this;
  }

  var _proto = BrowserRouter.prototype;

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["Router"], {
      history: this.history,
      children: this.props.children
    });
  };

  return BrowserRouter;
}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);

if (true) {
  BrowserRouter.propTypes = {
    basename: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node,
    forceRefresh: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    keyLength: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number
  };

  BrowserRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_5__["default"])(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.") : undefined;
  };
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(HashRouter, _React$Component);

  function HashRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = Object(history__WEBPACK_IMPORTED_MODULE_3__["createHashHistory"])(_this.props);
    return _this;
  }

  var _proto = HashRouter.prototype;

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["Router"], {
      history: this.history,
      children: this.props.children
    });
  };

  return HashRouter;
}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);

if (true) {
  HashRouter.propTypes = {
    basename: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node,
    getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    hashType: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(["hashbang", "noslash", "slash"])
  };

  HashRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_5__["default"])(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.") : undefined;
  };
}

var resolveToLocation = function resolveToLocation(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation(to, currentLocation) {
  return typeof to === "string" ? Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(to, null, null, currentLocation) : to;
};

var forwardRefShim = function forwardRefShim(C) {
  return C;
};

var forwardRef = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

var LinkAnchor = forwardRef(function (_ref, forwardedRef) {
  var innerRef = _ref.innerRef,
      navigate = _ref.navigate,
      _onClick = _ref.onClick,
      rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__["default"])(_ref, ["innerRef", "navigate", "onClick"]);

  var target = rest.target;

  var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick) _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && ( // ignore everything but left clicks
      !target || target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();
          navigate();
        }
    }
  }); // React 15 compat


  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }

  return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("a", props);
});

if (true) {
  LinkAnchor.displayName = "LinkAnchor";
}
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = forwardRef(function (_ref2, forwardedRef) {
  var _ref2$component = _ref2.component,
      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,
      replace = _ref2.replace,
      to = _ref2.to,
      innerRef = _ref2.innerRef,
      rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__["default"])(_ref2, ["component", "replace", "to", "innerRef"]);

  return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["__RouterContext"].Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_8__["default"])(false, "You should not use <Link> outside a <Router>") : undefined : void 0;
    var history = context.history;
    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);
    var href = location ? history.createHref(location) : "";

    var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, rest, {
      href: href,
      navigate: function navigate() {
        var location = resolveToLocation(to, context.location);
        var method = replace ? history.replace : history.push;
        method(location);
      }
    }); // React 15 compat


    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(component, props);
  });
});

if (true) {
  var toType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func]);
  var refType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.shape({
    current: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.any
  })]);
  Link.displayName = "Link";
  Link.propTypes = {
    innerRef: refType,
    onClick: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    replace: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    target: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    to: toType.isRequired
  };
}

var forwardRefShim$1 = function forwardRefShim(C) {
  return C;
};

var forwardRef$1 = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef;

if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}

function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }

  return classnames.filter(function (i) {
    return i;
  }).join(" ");
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


var NavLink = forwardRef$1(function (_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"],
      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,
      _ref$activeClassName = _ref.activeClassName,
      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,
      activeStyle = _ref.activeStyle,
      classNameProp = _ref.className,
      exact = _ref.exact,
      isActiveProp = _ref.isActive,
      locationProp = _ref.location,
      strict = _ref.strict,
      styleProp = _ref.style,
      to = _ref.to,
      innerRef = _ref.innerRef,
      rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__["default"])(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "strict", "style", "to", "innerRef"]);

  return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["__RouterContext"].Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_8__["default"])(false, "You should not use <NavLink> outside a <Router>") : undefined : void 0;
    var currentLocation = locationProp || context.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202

    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? Object(react_router__WEBPACK_IMPORTED_MODULE_0__["matchPath"])(currentLocation.pathname, {
      path: escapedPath,
      exact: exact,
      strict: strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
    var style = isActive ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, styleProp, {}, activeStyle) : styleProp;

    var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({
      "aria-current": isActive && ariaCurrent || null,
      className: className,
      style: style,
      to: toLocation
    }, rest); // React 15 compat


    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Link, props);
  });
});

if (true) {
  NavLink.displayName = "NavLink";
  var ariaCurrentType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(["page", "step", "location", "date", "time", "true"]);
  NavLink.propTypes = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, Link.propTypes, {
    "aria-current": ariaCurrentType,
    activeClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    activeStyle: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
    className: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    exact: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    isActive: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    location: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
    strict: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    style: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object
  });
}


//# sourceMappingURL=react-router-dom.js.map


/***/ }),

/***/ "./node_modules/react-router/esm/react-router.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-router/esm/react-router.js ***!
  \*******************************************************/
/*! exports provided: MemoryRouter, Prompt, Redirect, Route, Router, StaticRouter, Switch, __RouterContext, generatePath, matchPath, useHistory, useLocation, useParams, useRouteMatch, withRouter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return MemoryRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return Prompt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return Redirect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return Route; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return Router; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return StaticRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return Switch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__RouterContext", function() { return context; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generatePath", function() { return generatePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return matchPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useHistory", function() { return useHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useLocation", function() { return useLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useParams", function() { return useParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRouteMatch", function() { return useRouteMatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return withRouter; });
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history */ "./node_modules/history/esm/history.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var mini_create_react_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mini-create-react-context */ "./node_modules/mini-create-react-context/dist/esm/index.js");
/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tiny-invariant */ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! path-to-regexp */ "./node_modules/path-to-regexp/index.js");
/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(path_to_regexp__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! hoist-non-react-statics */ "./node_modules/react-router/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11__);













// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext = function createNamedContext(name) {
  var context = Object(mini_create_react_context__WEBPACK_IMPORTED_MODULE_5__["default"])();
  context.displayName = name;
  return context;
};

var context =
/*#__PURE__*/
createNamedContext("Router");

/**
 * The public API for putting history on context.
 */

var Router =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  function Router(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    }; // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.

    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        if (_this._isMounted) {
          _this.setState({
            location: location
          });
        } else {
          _this._pendingLocation = location;
        }
      });
    }

    return _this;
  }

  var _proto = Router.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;

    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) this.unlisten();
  };

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Provider, {
      children: this.props.children || null,
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    });
  };

  return Router;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  Router.propTypes = {
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
    history: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired,
    staticContext: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object
  };

  Router.prototype.componentDidUpdate = function (prevProps) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(prevProps.history === this.props.history, "You cannot change <Router history>") : undefined;
  };
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = Object(history__WEBPACK_IMPORTED_MODULE_3__["createMemoryHistory"])(_this.props);
    return _this;
  }

  var _proto = MemoryRouter.prototype;

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return MemoryRouter;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  MemoryRouter.propTypes = {
    initialEntries: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,
    initialIndex: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,
    getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
    keyLength: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node
  };

  MemoryRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.") : undefined;
  };
}

var Lifecycle =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Lifecycle, _React$Component);

  function Lifecycle() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

/**
 * The public API for prompting the user before navigating away from a screen.
 */

function Prompt(_ref) {
  var message = _ref.message,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Prompt> outside a <Router>") : undefined : void 0;
    if (!when || context.staticContext) return null;
    var method = context.history.block;
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Lifecycle, {
      onMount: function onMount(self) {
        self.release = method(message);
      },
      onUpdate: function onUpdate(self, prevProps) {
        if (prevProps.message !== message) {
          self.release();
          self.release = method(message);
        }
      },
      onUnmount: function onUnmount(self) {
        self.release();
      },
      message: message
    });
  });
}

if (true) {
  var messageType = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string]);
  Prompt.propTypes = {
    when: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    message: messageType.isRequired
  };
}

var cache = {};
var cacheLimit = 10000;
var cacheCount = 0;

function compilePath(path) {
  if (cache[path]) return cache[path];
  var generator = path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default.a.compile(path);

  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }

  return generator;
}
/**
 * Public API for generating a URL pathname from a path and parameters.
 */


function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }

  if (params === void 0) {
    params = {};
  }

  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}

/**
 * The public API for navigating programmatically with a component.
 */

function Redirect(_ref) {
  var computedMatch = _ref.computedMatch,
      to = _ref.to,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? false : _ref$push;
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Redirect> outside a <Router>") : undefined : void 0;
    var history = context.history,
        staticContext = context.staticContext;
    var method = push ? history.push : history.replace;
    var location = Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to); // When rendering in a static context,
    // set the new location immediately.

    if (staticContext) {
      method(location);
      return null;
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self, prevProps) {
        var prevLocation = Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(prevProps.to);

        if (!Object(history__WEBPACK_IMPORTED_MODULE_3__["locationsAreEqual"])(prevLocation, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to: to
    });
  });
}

if (true) {
  Redirect.propTypes = {
    push: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    from: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
    to: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object]).isRequired
  };
}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path]) return pathCache[path];
  var keys = [];
  var regexp = path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default()(path, keys, options);
  var result = {
    regexp: regexp,
    keys: keys
  };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */


function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }

  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === void 0 ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function (matched, path) {
    if (!path && path !== "") return null;
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);
    if (!match) return null;
    var url = match[0],
        values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path,
      // the path used to match
      url: path === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact: isExact,
      // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}

function isEmptyChildren(children) {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.count(children) === 0;
}

function evalChildrenDev(children, props, path) {
  var value = children(props);
   true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(value !== undefined, "You returned `undefined` from the `children` function of " + ("<Route" + (path ? " path=\"" + path + "\"" : "") + ">, but you ") + "should have returned a React element or `null`") : undefined;
  return value || null;
}
/**
 * The public API for matching a single path and rendering.
 */


var Route =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Route, _React$Component);

  function Route() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Route.prototype;

  _proto.render = function render() {
    var _this = this;

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context$1) {
      !context$1 ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Route> outside a <Router>") : undefined : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;

      var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, context$1, {
        location: location,
        match: match
      });

      var _this$props = _this.props,
          children = _this$props.children,
          component = _this$props.component,
          render = _this$props.render; // Preact uses an empty array as children by
      // default, so use null if that's the case.

      if (Array.isArray(children) && children.length === 0) {
        children = null;
      }

      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ?  true ? evalChildrenDev(children, props, _this.props.path) : undefined : children : component ? react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  true ? evalChildrenDev(children, props, _this.props.path) : undefined : null);
    });
  };

  return Route;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  Route.propTypes = {
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node]),
    component: function component(props, propName) {
      if (props[propName] && !Object(react_is__WEBPACK_IMPORTED_MODULE_9__["isValidElementType"])(props[propName])) {
        return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
      }
    },
    exact: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
    path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string)]),
    render: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
    sensitive: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    strict: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool
  };

  Route.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : undefined;
  };

  Route.prototype.componentDidUpdate = function (prevProps) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : undefined;
  };
}

function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;
  return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}

function stripBasename(basename, location) {
  if (!basename) return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : Object(history__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
}

function staticHandler(methodName) {
  return function () {
      true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You cannot %s with <StaticRouter>", methodName) : undefined ;
  };
}

function noop() {}
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


var StaticRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(StaticRouter, _React$Component);

  function StaticRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.handlePush = function (location) {
      return _this.navigateTo(location, "PUSH");
    };

    _this.handleReplace = function (location) {
      return _this.navigateTo(location, "REPLACE");
    };

    _this.handleListen = function () {
      return noop;
    };

    _this.handleBlock = function () {
      return noop;
    };

    return _this;
  }

  var _proto = StaticRouter.prototype;

  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props,
        _this$props$basename = _this$props.basename,
        basename = _this$props$basename === void 0 ? "" : _this$props$basename,
        _this$props$context = _this$props.context,
        context = _this$props$context === void 0 ? {} : _this$props$context;
    context.action = action;
    context.location = addBasename(basename, Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(location));
    context.url = createURL(context.location);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        _this$props2$basename = _this$props2.basename,
        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
        _this$props2$context = _this$props2.context,
        context = _this$props2$context === void 0 ? {} : _this$props2$context,
        _this$props2$location = _this$props2.location,
        location = _this$props2$location === void 0 ? "/" : _this$props2$location,
        rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__["default"])(_this$props2, ["basename", "context", "location"]);

    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Router, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, rest, {
      history: history,
      staticContext: context
    }));
  };

  return StaticRouter;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  StaticRouter.propTypes = {
    basename: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
    context: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
    location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object])
  };

  StaticRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.") : undefined;
  };
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Switch, _React$Component);

  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Switch.prototype;

  _proto.render = function render() {
    var _this = this;

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
      !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Switch> outside a <Router>") : undefined : void 0;
      var location = _this.props.location || context.location;
      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
      // here because toArray adds keys to all child elements and we do not want
      // to trigger an unmount/remount for two <Route>s that render the same
      // component at different URLs.

      react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.forEach(_this.props.children, function (child) {
        if (match == null && react__WEBPACK_IMPORTED_MODULE_1___default.a.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, child.props, {
            path: path
          })) : context.match;
        }
      });
      return match ? react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(element, {
        location: location,
        computedMatch: match
      }) : null;
    });
  };

  return Switch;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  Switch.propTypes = {
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
    location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object
  };

  Switch.prototype.componentDidUpdate = function (prevProps) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : undefined;
  };
}

/**
 * A public higher-order component to access the imperative API
 */

function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";

  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__["default"])(props, ["wrappedComponentRef"]);

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
      !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <" + displayName + " /> outside a <Router>") : undefined : void 0;
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, remainingProps, context, {
        ref: wrappedComponentRef
      }));
    });
  };

  C.displayName = displayName;
  C.WrappedComponent = Component;

  if (true) {
    C.propTypes = {
      wrappedComponentRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object])
    };
  }

  return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11___default()(C, Component);
}

var useContext = react__WEBPACK_IMPORTED_MODULE_1___default.a.useContext;
function useHistory() {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useHistory()") : undefined : void 0;
  }

  return useContext(context).history;
}
function useLocation() {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useLocation()") : undefined : void 0;
  }

  return useContext(context).location;
}
function useParams() {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useParams()") : undefined : void 0;
  }

  var match = useContext(context).match;
  return match ? match.params : {};
}
function useRouteMatch(path) {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useRouteMatch()") : undefined : void 0;
  }

  return path ? matchPath(useLocation().pathname, path) : useContext(context).match;
}

if (true) {
  if (typeof window !== "undefined") {
    var global = window;
    var key = "__react_router_build__";
    var buildNames = {
      cjs: "CommonJS",
      esm: "ES modules",
      umd: "UMD"
    };

    if (global[key] && global[key] !== "esm") {
      var initialBuildName = buildNames[global[key]];
      var secondaryBuildName = buildNames["esm"]; // TODO: Add link to article that explains in detail how to avoid
      // loading 2 different builds.

      throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
    }

    global[key] = "esm";
  }
}


//# sourceMappingURL=react-router.js.map


/***/ }),

/***/ "./node_modules/react-router/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/react-router/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};

var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};

var TYPE_STATICS = {};
TYPE_STATICS[ReactIs.ForwardRef] = FORWARD_REF_STATICS;

function getStatics(component) {
    if (ReactIs.isMemo(component)) {
        return MEMO_STATICS;
    }
    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.11.0
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.11.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?


var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be replaced with error codes
// during build.

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var lowPriorityWarningWithoutStack = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.warn(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarningWithoutStack = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  };
}

var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var warningWithoutStack = function () {};

{
  warningWithoutStack = function (condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (args.length > 8) {
      // Check before the condition to catch violations early.
      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
    }

    if (condition) {
      return;
    }

    if (typeof console !== 'undefined') {
      var argsWithFormat = args.map(function (item) {
        return '' + item;
      });
      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610

      Function.prototype.apply.call(console.error, console, argsWithFormat);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  };
}

var warningWithoutStack$1 = warningWithoutStack;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarningWithoutStack$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  suspense: null
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
var describeComponentFrame = function (name, source, ownerName) {
  var sourceInfo = '';

  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');

    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);

        if (match) {
          var pathBeforeSlash = match[1];

          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }

    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }

  return '\n    in ' + (name || 'Unknown') + sourceInfo;
};

var Resolved = 1;

function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return "Profiler";

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';

      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = refineResolvedLazyComponent(thenable);

          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }

          break;
        }
    }
  }

  return null;
}

var ReactDebugCurrentFrame = {};
var currentlyValidatingElement = null;
function setCurrentlyValidatingElement(element) {
  {
    currentlyValidatingElement = element;
  }
}

{
  // Stack implementation injected by the current renderer.
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentlyValidatingElement) {
      var name = getComponentName(currentlyValidatingElement.type);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  _assign(ReactSharedInternals, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = warningWithoutStack$1;

{
  warning = function (condition, format) {
    if (condition) {
      return;
    }

    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum(); // eslint-disable-next-line react-internal/warning-and-invariant-args

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    warningWithoutStack$1.apply(void 0, [false, format + '%s'].concat(args, [stack]));
  };
}

var warning$1 = warning;

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */



/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null; // Currently, key can be spread in as a prop. This causes a potential
  // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
  // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
  // but as an intermediary step, we will use jsxDEV for everything except
  // <div {...props} key="Hi" />, because we aren't currently able to tell if
  // key is explicitly declared to be undefined or not.

  if (maybeKey !== undefined) {
    key = '' + maybeKey;
  }

  if (hasValidKey(config)) {
    key = '' + config.key;
  }

  if (hasValidRef(config)) {
    ref = config.ref;
  } // Remaining properties are added to a new props object


  for (propName in config) {
    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
      props[propName] = config[propName];
    }
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  if (key || ref) {
    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

    if (key) {
      defineKeyPropWarningGetter(props, displayName);
    }

    if (ref) {
      defineRefPropWarningGetter(props, displayName);
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];

function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;

  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}
/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */


function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';

      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }

      var childrenString = '' + children;

      {
        {
          throw Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + ")." + addendum);
        }
      }
    }
  }

  return subtreeCount;
}
/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */


function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}
/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;
  func.call(context, child, bookKeeping.count++);
}
/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */


function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;
  var mappedChild = func.call(context, child, bookKeeping.count++);

  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
      return c;
    });
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }

    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';

  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }

  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}
/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */


function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  return traverseAllChildren(children, function () {
    return null;
  }, null);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
    return child;
  });
  return result;
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error("React.Children.only expected to receive a single React element child.");
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;
            warning$1(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;
            warning$1(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

function lazy(ctor) {
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _ctor: ctor,
    // React uses these fields to store the result.
    _status: -1,
    _result: null
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes;
    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          warning$1(false, 'React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
          defaultProps = newDefaultProps; // Match production behavior more closely:

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          warning$1(false, 'React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
          propTypes = newPropTypes; // Match production behavior more closely:

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      warningWithoutStack$1(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      !( // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object
      render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;
    }

    if (render != null) {
      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
    }
  }

  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
}

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE);
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      warningWithoutStack$1(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    !(unstable_observedBits === undefined) ? warning$1(false, 'useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '') : void 0; // TODO: add a more generic warning for invalid values.

    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        warning$1(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        warning$1(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, inputs);
}
function useLayoutEffect(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, inputs);
}
function useCallback(callback, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, inputs);
}
function useMemo(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, inputs);
}
function useImperativeHandle(ref, create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, inputs);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}
var emptyObject$1 = {};
function useResponder(responder, listenerProps) {
  var dispatcher = resolveDispatcher();

  {
    if (responder == null || responder.$$typeof !== REACT_RESPONDER_TYPE) {
      warning$1(false, 'useResponder: invalid first argument. Expected an event responder, but instead got %s', responder);
      return;
    }
  }

  return dispatcher.useResponder(responder, listenerProps || emptyObject$1);
}
function useTransition(config) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useTransition(config);
}
function useDeferredValue(value, config) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useDeferredValue(value, config);
}

function withSuspenseConfig(scope, config) {
  var previousConfig = ReactCurrentBatchConfig.suspense;
  ReactCurrentBatchConfig.suspense = config === undefined ? null : config;

  try {
    scope();
  } finally {
    ReactCurrentBatchConfig.suspense = previousConfig;
  }
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */
var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  setCurrentlyValidatingElement(element);

  {
    warning$1(false, 'Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
  }

  setCurrentlyValidatingElement(null);
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  var type = element.type;

  if (type === null || type === undefined || typeof type === 'string') {
    return;
  }

  var name = getComponentName(type);
  var propTypes;

  if (typeof type === 'function') {
    propTypes = type.propTypes;
  } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
  // Inner props are checked in the reconciler.
  type.$$typeof === REACT_MEMO_TYPE)) {
    propTypes = type.propTypes;
  } else {
    return;
  }

  if (propTypes) {
    setCurrentlyValidatingElement(element);
    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
    setCurrentlyValidatingElement(null);
  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }

  if (typeof type.getDefaultProps === 'function') {
    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  setCurrentlyValidatingElement(fragment);
  var keys = Object.keys(fragment.props);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (key !== 'children' && key !== 'key') {
      warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
      break;
    }
  }

  if (fragment.ref !== null) {
    warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
  }

  setCurrentlyValidatingElement(null);
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(source);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    warning$1(false, 'React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    var children = props.children;

    if (children !== undefined) {
      if (isStaticChildren) {
        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            validateChildKeys(children[i], type);
          }

          if (Object.freeze) {
            Object.freeze(children);
          }
        } else {
          warning$1(false, 'React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
        }
      } else {
        validateChildKeys(children, type);
      }
    }
  }

  if (hasOwnProperty$1.call(props, 'key')) {
    warning$1(false, 'React.jsx: Spreading a key to JSX is a deprecated pattern. ' + 'Explicitly pass a key after spreading props in your JSX call. ' + 'E.g. <ComponentName {...props} key={key} />');
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  return jsxWithValidation(type, props, key, true);
}
function jsxWithValidationDynamic(type, props, key) {
  return jsxWithValidation(type, props, key, false);
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type; // Legacy hook: remove it

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarningWithoutStack$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

var hasBadMapPolyfill;

{
  hasBadMapPolyfill = false;

  try {
    var frozenObject = Object.freeze({});
    var testMap = new Map([[frozenObject, null]]);
    var testSet = new Set([frozenObject]); // This is necessary for Rollup to not consider these unused.
    // https://github.com/rollup/rollup/issues/1771
    // TODO: we can remove these if Rollup fixes the bug.

    testMap.set(0, 0);
    testSet.add(0);
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

function createFundamentalComponent(impl) {
  // We use responder as a Map key later on. When we have a bad
  // polyfill, then we can't use it as a key as the polyfill tries
  // to add a property to the object.
  if ( true && !hasBadMapPolyfill) {
    Object.freeze(impl);
  }

  var fundamantalComponent = {
    $$typeof: REACT_FUNDAMENTAL_TYPE,
    impl: impl
  };

  {
    Object.freeze(fundamantalComponent);
  }

  return fundamantalComponent;
}

function createEventResponder(displayName, responderConfig) {
  var getInitialState = responderConfig.getInitialState,
      onEvent = responderConfig.onEvent,
      onMount = responderConfig.onMount,
      onUnmount = responderConfig.onUnmount,
      onRootEvent = responderConfig.onRootEvent,
      rootEventTypes = responderConfig.rootEventTypes,
      targetEventTypes = responderConfig.targetEventTypes,
      targetPortalPropagation = responderConfig.targetPortalPropagation;
  var eventResponder = {
    $$typeof: REACT_RESPONDER_TYPE,
    displayName: displayName,
    getInitialState: getInitialState || null,
    onEvent: onEvent || null,
    onMount: onMount || null,
    onRootEvent: onRootEvent || null,
    onUnmount: onUnmount || null,
    rootEventTypes: rootEventTypes || null,
    targetEventTypes: targetEventTypes || null,
    targetPortalPropagation: targetPortalPropagation || false
  }; // We use responder as a Map key later on. When we have a bad
  // polyfill, then we can't use it as a key as the polyfill tries
  // to add a property to the object.

  if ( true && !hasBadMapPolyfill) {
    Object.freeze(eventResponder);
  }

  return eventResponder;
}

function createScope() {
  var scopeComponent = {
    $$typeof: REACT_SCOPE_TYPE
  };

  {
    Object.freeze(scopeComponent);
  }

  return scopeComponent;
}

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:

 // In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:

 // To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.

 // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:

 // Gather advanced timing metrics for Profiler subtrees.

 // Trace which interactions trigger each commit.

 // SSR experiments


 // Only used in www builds.

 // Only used in www builds.

 // Disable javascript: URL strings in href for XSS protection.

 // React Fire: prevent the value and checked attributes from syncing
// with their related DOM properties

 // These APIs will no longer be "unstable" in the upcoming 16.7 release,
// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.

var exposeConcurrentModeAPIs = false;
 // Experimental React Flare event system and event components support.

var enableFlareAPI = false; // Experimental Host Component support.

var enableFundamentalAPI = false; // Experimental Scope support.

var enableScopeAPI = false; // New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107

var enableJSXTransformAPI = false; // We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)
// Till then, we warn about the missing mock, but still fallback to a sync mode compatible version

 // For tests, we flush suspense fallbacks in an act scope;
// *except* in some of our own tests, where we test incremental loading states.

 // Add a callback property to suspense to notify which promises are currently
// in the update queue. This allows reporting and tracing of what is causing
// the user to see a loading state.
// Also allows hydration callbacks to fire when a dehydrated boundary gets
// hydrated or deleted.

 // Part of the simplification of React.createElement so we can eventually move
// from React.createElement to React.jsx
// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },
  createRef: createRef,
  Component: Component,
  PureComponent: PureComponent,
  createContext: createContext,
  forwardRef: forwardRef,
  lazy: lazy,
  memo: memo,
  useCallback: useCallback,
  useContext: useContext,
  useEffect: useEffect,
  useImperativeHandle: useImperativeHandle,
  useDebugValue: useDebugValue,
  useLayoutEffect: useLayoutEffect,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  Fragment: REACT_FRAGMENT_TYPE,
  Profiler: REACT_PROFILER_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  Suspense: REACT_SUSPENSE_TYPE,
  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,
  version: ReactVersion,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
};

if (exposeConcurrentModeAPIs) {
  React.useTransition = useTransition;
  React.useDeferredValue = useDeferredValue;
  React.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  React.unstable_withSuspenseConfig = withSuspenseConfig;
}

if (enableFlareAPI) {
  React.unstable_useResponder = useResponder;
  React.unstable_createResponder = createEventResponder;
}

if (enableFundamentalAPI) {
  React.unstable_createFundamental = createFundamentalComponent;
}

if (enableScopeAPI) {
  React.unstable_createScope = createScope;
} // Note: some APIs are added with feature flags.
// Make sure that stable builds for open source
// don't modify the React object to avoid deopts.
// Also let's not expose their names in stable builds.


if (enableJSXTransformAPI) {
  {
    React.jsxDEV = jsxWithValidation;
    React.jsx = jsxWithValidationDynamic;
    React.jsxs = jsxWithValidationStatic;
  }
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.


var react = React$3.default || React$3;

module.exports = react;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/resolve-pathname/esm/resolve-pathname.js":
/*!***************************************************************!*\
  !*** ./node_modules/resolve-pathname/esm/resolve-pathname.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to, from) {
  if (from === undefined) from = '';

  var toParts = (to && to.split('/')) || [];
  var fromParts = (from && from.split('/')) || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');

  if (
    mustEndAbs &&
    fromParts[0] !== '' &&
    (!fromParts[0] || !isAbsolute(fromParts[0]))
  )
    fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);


/***/ }),

/***/ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isProduction = "development" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
  if (condition) {
    return;
  }

  if (isProduction) {
    throw new Error(prefix);
  } else {
    throw new Error(prefix + ": " + (message || ''));
  }
}

/* harmony default export */ __webpack_exports__["default"] = (invariant);


/***/ }),

/***/ "./node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isProduction = "development" === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ __webpack_exports__["default"] = (warning);


/***/ }),

/***/ "./node_modules/value-equal/esm/value-equal.js":
/*!*****************************************************!*\
  !*** ./node_modules/value-equal/esm/value-equal.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function valueOf(obj) {
  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
}

function valueEqual(a, b) {
  // Test for strict equality first.
  if (a === b) return true;

  // Otherwise, if either of them == null they are not equal.
  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return (
      Array.isArray(b) &&
      a.length === b.length &&
      a.every(function(item, index) {
        return valueEqual(item, b[index]);
      })
    );
  }

  if (typeof a === 'object' || typeof b === 'object') {
    var aValue = valueOf(a);
    var bValue = valueOf(b);

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    return Object.keys(Object.assign({}, a, b)).every(function(key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);


/***/ }),

/***/ "./src/client/pages/Home.jsx":
/*!***********************************!*\
  !*** ./src/client/pages/Home.jsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var Home = function Home() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h1", null, "React-SSR Boilerplate"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "This is a minimal SSR boilerplate with ReactJS, NodeJS, HapiJS, Webpack."), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
    onClick: function onClick() {
      return console.log("Click Works === Hydrate Works");
    }
  }, "Click !"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "Use console to validate Events / Hydrate is working... "), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h2", null, "Features & Examples: "), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "Example routing: ", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", {
    href: "/test"
  }, "Test")));
};

/* harmony default export */ __webpack_exports__["default"] = (Home);

/***/ }),

/***/ "./src/client/pages/Test.jsx":
/*!***********************************!*\
  !*** ./src/client/pages/Test.jsx ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var Test = function Test() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h1", null, "React-SSR Boilerplate"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "This is a test route."), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
    onClick: function onClick() {
      return console.log("Click Works === Hydrate Works");
    }
  }, "Click !"));
};

/* harmony default export */ __webpack_exports__["default"] = (Test);

/***/ }),

/***/ "./src/client/routes.jsx":
/*!*******************************!*\
  !*** ./src/client/routes.jsx ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pages_Home__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pages/Home */ "./src/client/pages/Home.jsx");
/* harmony import */ var _pages_Test__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pages/Test */ "./src/client/pages/Test.jsx");


var routesList = [{
  path: "/test",
  component: _pages_Test__WEBPACK_IMPORTED_MODULE_1__["default"]
}, {
  path: "/",
  exact: true,
  component: _pages_Home__WEBPACK_IMPORTED_MODULE_0__["default"]
}];
/* harmony default export */ __webpack_exports__["default"] = (routesList);

/***/ }),

/***/ "./src/server/htmlTemplate.jsx":
/*!*************************************!*\
  !*** ./src/server/htmlTemplate.jsx ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/esm/react-router-dom.js");
/* harmony import */ var _client_routes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../client/routes */ "./src/client/routes.jsx");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./src/server/utils.js");





/* harmony default export */ __webpack_exports__["default"] = (function (req) {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("html", {
    lang: "en"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("head", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("meta", {
    charSet: "UTF-8"
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("title", null, "Boilerplate - SSR with HapiJS, React")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("body", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    id: "app"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_2__["StaticRouter"], {
    location: req.path,
    context: {}
  }, _client_routes__WEBPACK_IMPORTED_MODULE_3__["default"].map(function (route) {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
      key: route.path
    }, route));
  }))), _utils__WEBPACK_IMPORTED_MODULE_4__["vendorScripts"].map(function (scriptPath) {
    return scriptPath && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("script", {
      key: scriptPath,
      src: scriptPath
    });
  }), _utils__WEBPACK_IMPORTED_MODULE_4__["clientScripts"].map(function (scriptPath) {
    return scriptPath && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("script", {
      key: scriptPath,
      src: scriptPath
    });
  })));
});

/***/ }),

/***/ "./src/server/index.js":
/*!*****************************!*\
  !*** ./src/server/index.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _hapi_hapi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hapi/hapi */ "./node_modules/@hapi/hapi/lib/index.js");
/* harmony import */ var _hapi_hapi__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_hapi_hapi__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _hapi_inert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @hapi/inert */ "./node_modules/@hapi/inert/lib/index.js");
/* harmony import */ var _hapi_inert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_hapi_inert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _routes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./routes */ "./src/server/routes.js");






var init =
/*#__PURE__*/
function () {
  var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(
  /*#__PURE__*/
  _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
    var server;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            server = _hapi_hapi__WEBPACK_IMPORTED_MODULE_2___default.a.server({
              port: 3000
            });
            _context.next = 3;
            return server.register(_hapi_inert__WEBPACK_IMPORTED_MODULE_3___default.a);

          case 3:
            _context.next = 5;
            return server.route(_routes__WEBPACK_IMPORTED_MODULE_4__["default"]);

          case 5:
            _context.next = 7;
            return server.start();

          case 7:
            console.log("\n------------------------------");
            console.log("  SERVER up and running...");
            console.log("------------------------------");
            console.dir(server.info);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function init() {
    return _ref.apply(this, arguments);
  };
}();

process.on("unhandledRejection", function (err) {
  console.log(err);
  process.exit(1);
});
init();

/***/ }),

/***/ "./src/server/reactHandler.js":
/*!************************************!*\
  !*** ./src/server/reactHandler.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom/server */ "./node_modules/react-dom/server.js");
/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom_server__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _htmlTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./htmlTemplate */ "./src/server/htmlTemplate.jsx");



var reactHandler = function reactHandler(request, h) {
  return "<!DOCTYPE html>" + Object(react_dom_server__WEBPACK_IMPORTED_MODULE_0__["renderToString"])(Object(_htmlTemplate__WEBPACK_IMPORTED_MODULE_1__["default"])(request));
};

/* harmony default export */ __webpack_exports__["default"] = (reactHandler);

/***/ }),

/***/ "./src/server/routes.js":
/*!******************************!*\
  !*** ./src/server/routes.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reactHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reactHandler */ "./src/server/reactHandler.js");

/* harmony default export */ __webpack_exports__["default"] = ([// Static Files
{
  path: "/{param*}",
  method: "GET",
  config: {
    handler: {
      directory: {
        path: 'dist'
      }
    }
  }
}, // Default Route
{
  method: "GET",
  path: "/",
  handler: _reactHandler__WEBPACK_IMPORTED_MODULE_0__["default"]
}, {
  method: "GET",
  path: "/test",
  handler: _reactHandler__WEBPACK_IMPORTED_MODULE_0__["default"]
}]);

/***/ }),

/***/ "./src/server/utils.js":
/*!*****************************!*\
  !*** ./src/server/utils.js ***!
  \*****************************/
/*! exports provided: clientScripts, vendorScripts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clientScripts", function() { return clientScripts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vendorScripts", function() { return vendorScripts; });
var fs = __webpack_require__(/*! fs */ "fs");

var clientScripts = fs.readdirSync('dist', {
  withFileTypes: true
}).filter(function (item) {
  return item && /client/.test(item);
});
var vendorScripts = fs.readdirSync('dist', {
  withFileTypes: true
}).filter(function (item) {
  return item && /vendor/.test(item);
});


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmVyL2luZGV4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvYWNjZXB0L2xpYi9oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FjY2VwdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FjY2VwdC9saWIvbWVkaWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FkZHJlc3MvbGliL2RvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvYWRkcmVzcy9saWIvZW1haWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FkZHJlc3MvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9hZGRyZXNzL2xpYi90bGRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9hbW1vL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvYjY0L2xpYi9kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9iNjQvbGliL2VuY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2I2NC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2Jvb20vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ib3VuY2UvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ib3VybmUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9jYWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY2FsbC9saWIvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2NhbGwvbGliL3NlZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2NhdGJveC1tZW1vcnkvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9jYXRib3gvbGliL2NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY2F0Ym94L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY2F0Ym94L2xpYi9wZW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9jYXRib3gvbGliL3BvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY29udGVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2NyeXB0aWxlcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2ZpbGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9mb3JtdWxhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvYXV0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvY29tcHJlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvY29ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9oZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbGliL3JvdXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9zZWN1cml0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvc2VydmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9zdHJlYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi90b29sa2l0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi90cmFuc21pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9jYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9sYW5ndWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9yZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvc2NoZW1hcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYWx0ZXJuYXRpdmVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2FueS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9hbnkvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYmluYXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2Jvb2xlYW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvZGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9mdW5jL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2xhenkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvbnVtYmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9zdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3RyaW5nL2lwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy9yZmMzOTg2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy91cmkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hlYXZ5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvYXBwbHlUb0RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2JlbmNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9ibG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2NvbnRhaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZUhlYWRlckF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlSHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlSnNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2lnbm9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2ludGVyc2VjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL29uY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3JlYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9yZWFjaFRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3R5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvd2FpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaW5lcnQvbGliL2RpcmVjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaW5lcnQvbGliL2V0YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2luZXJ0L2xpYi9maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9pbmVydC9saWIvZnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2luZXJ0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaXJvbi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvZXh0ZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL21hbmlmZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL21lc3NhZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL21vZGlmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9yZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvc2NoZW1hcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90cmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYW55LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9ib29sZWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9saW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy9pcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9zdHJpbmcvdXJpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi92YWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9taW1vcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL25pZ2VsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvcGV6L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvcGlucG9pbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9wb2RpdW0vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9zaG90L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvc2hvdC9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvc2hvdC9saWIvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3Nob3QvbGliL3N5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3NvbWV2ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9zdGF0ZWhvb2QvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9zdWJ0ZXh0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvdGVhbXdvcmsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS90b3BvL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvdmlzZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3dyZWNrL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvd3JlY2svbGliL3BheWxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3dyZWNrL2xpYi9yZWNvcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvd3JlY2svbGliL3RhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3VkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzbS9oaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9taW5pLWNyZWF0ZS1yZWFjdC1jb250ZXh0L2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wc2V1ZG9tYXAvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wc2V1ZG9tYXAvcHNldWRvbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5ub2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzbS9yZWFjdC1yb3V0ZXItZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXNtL3JlYWN0LXJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2VzbS9yZXNvbHZlLXBhdGhuYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW55LWludmFyaWFudC9kaXN0L3RpbnktaW52YXJpYW50LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlueS13YXJuaW5nL2Rpc3QvdGlueS13YXJuaW5nLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvZXNtL3ZhbHVlLWVxdWFsLmpzIiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvcGFnZXMvSG9tZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9wYWdlcy9UZXN0LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L3JvdXRlcy5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlci9odG1sVGVtcGxhdGUuanN4Iiwid2VicGFjazovLy8uL3NyYy9zZXJ2ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlci9yZWFjdEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlci9yb3V0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlci91dGlscy5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjcnlwdG9cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwc1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm5ldFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIm9zXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicGF0aFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInF1ZXJ5c3RyaW5nXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwic3RyZWFtXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidXJsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwidXRpbFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInpsaWJcIiJdLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvc2VydmVyL2luZGV4LmpzXCIpO1xuIiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzOyIsImZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHNMb29zZTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uIChoZWFkZXIsIHByZWZlcmVuY2VzLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBzZWxlY3Rpb25zID0gZXhwb3J0cy5zZWxlY3Rpb25zKGhlYWRlciwgcHJlZmVyZW5jZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IHNlbGVjdGlvbnNbMF0gOiAnJztcbn07XG5cblxuZXhwb3J0cy5zZWxlY3Rpb25zID0gZnVuY3Rpb24gKGhlYWRlciwgcHJlZmVyZW5jZXMsIG9wdGlvbnMpIHtcblxuICAgIEhvZWsuYXNzZXJ0KCFwcmVmZXJlbmNlcyB8fCBBcnJheS5pc0FycmF5KHByZWZlcmVuY2VzKSwgJ1ByZWZlcmVuY2VzIG11c3QgYmUgYW4gYXJyYXknKTtcblxuICAgIHJldHVybiBpbnRlcm5hbHMucGFyc2UoaGVhZGVyIHx8ICcnLCBwcmVmZXJlbmNlcywgb3B0aW9ucyk7XG59O1xuXG5cbi8vICAgICAgUkZDIDcyMzEgU2VjdGlvbiA1LjMuMyAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi01LjMuMylcbi8vXG4vLyAgICAgIEFjY2VwdC1DaGFyc2V0ICA9ICooIFwiLFwiIE9XUyApICggKCBjaGFyc2V0IC8gXCIqXCIgKSBbIHdlaWdodCBdICkgKiggT1dTIFwiLFwiIFsgT1dTICggKCBjaGFyc2V0IC8gXCIqXCIgKSBbIHdlaWdodCBdICkgXSApXG4vLyAgICAgIGNoYXJzZXQgICAgICAgICA9IHRva2VuXG4vL1xuLy8gICAgICBBY2NlcHQtQ2hhcnNldDogaXNvLTg4NTktNSwgdW5pY29kZS0xLTE7cT0wLjhcblxuXG4vLyAgICAgIFJGQyA3MjMxIFNlY3Rpb24gNS4zLjQgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNS4zLjQpXG4vL1xuLy8gICAgICBBY2NlcHQtRW5jb2RpbmcgPSBbICggXCIsXCIgLyAoIGNvZGluZ3MgWyB3ZWlnaHQgXSApICkgKiggT1dTIFwiLFwiIFsgT1dTICggY29kaW5ncyBbIHdlaWdodCBdICkgXSApIF1cbi8vICAgICAgY29kaW5ncyAgICAgICAgID0gY29udGVudC1jb2RpbmcgLyBcImlkZW50aXR5XCIgLyBcIipcIlxuLy8gICAgICBjb250ZW50LWNvZGluZyAgPSB0b2tlblxuLy9cbi8vICAgICAgQWNjZXB0LUVuY29kaW5nOiBjb21wcmVzcywgZ3ppcFxuLy8gICAgICBBY2NlcHQtRW5jb2Rpbmc6XG4vLyAgICAgIEFjY2VwdC1FbmNvZGluZzogKlxuLy8gICAgICBBY2NlcHQtRW5jb2Rpbmc6IGNvbXByZXNzO3E9MC41LCBnemlwO3E9MS4wXG4vLyAgICAgIEFjY2VwdC1FbmNvZGluZzogZ3ppcDtxPTEuMCwgaWRlbnRpdHk7IHE9MC41LCAqO3E9MFxuXG5cbi8vICAgICAgUkZDIDcyMzEgU2VjdGlvbiA1LjMuNSAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi01LjMuNSlcbi8vXG4vLyAgICAgIEFjY2VwdC1MYW5ndWFnZSA9ICooIFwiLFwiIE9XUyApICggbGFuZ3VhZ2UtcmFuZ2UgWyB3ZWlnaHQgXSApICooIE9XUyBcIixcIiBbIE9XUyAoIGxhbmd1YWdlLXJhbmdlIFsgd2VpZ2h0IF0gKSBdIClcbi8vICAgICAgbGFuZ3VhZ2UtcmFuZ2UgID0gKCAxKjhBTFBIQSAqKCBcIi1cIiAxKjhhbHBoYW51bSApICkgLyBcIipcIiAgIDsgW1JGQzQ2NDddLCBTZWN0aW9uIDIuMVxuLy8gICAgICBhbHBoYW51bSAgICAgICAgPSBBTFBIQSAvIERJR0lUXG4vL1xuLy8gICAgICAgQWNjZXB0LUxhbmd1YWdlOiBkYSwgZW4tZ2I7cT0wLjgsIGVuO3E9MC43XG5cblxuLy8gICAgICB0b2tlbiAgICAgICAgICAgPSAxKnRjaGFyXG4vLyAgICAgIHRjaGFyICAgICAgICAgICA9IFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAvIERJR0lUIC8gQUxQSEFcbi8vICAgICAgICAgICAgICAgICAgICAgICAgOyBhbnkgVkNIQVIsIGV4Y2VwdCBkZWxpbWl0ZXJzXG4vLyAgICAgIE9XUyAgICAgICAgICAgICA9ICooIFNQIC8gSFRBQiApXG5cblxuLy8gICAgICBSRkMgNzIzMSBTZWN0aW9uIDUuMy4xIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTUuMy4xKVxuLy9cbi8vICAgICAgVGhlIHdlaWdodCBpcyBub3JtYWxpemVkIHRvIGEgcmVhbCBudW1iZXIgaW4gdGhlIHJhbmdlIDAgdGhyb3VnaCAxLFxuLy8gICAgICB3aGVyZSAwLjAwMSBpcyB0aGUgbGVhc3QgcHJlZmVycmVkIGFuZCAxIGlzIHRoZSBtb3N0IHByZWZlcnJlZDsgYVxuLy8gICAgICB2YWx1ZSBvZiAwIG1lYW5zIFwibm90IGFjY2VwdGFibGVcIi4gIElmIG5vIFwicVwiIHBhcmFtZXRlciBpcyBwcmVzZW50LFxuLy8gICAgICB0aGUgZGVmYXVsdCB3ZWlnaHQgaXMgMS5cbi8vXG4vLyAgICAgICB3ZWlnaHQgPSBPV1MgXCI7XCIgT1dTIFwicT1cIiBxdmFsdWVcbi8vICAgICAgIHF2YWx1ZSA9ICggXCIwXCIgWyBcIi5cIiAwKjNESUdJVCBdICkgLyAoIFwiMVwiIFsgXCIuXCIgMCozKFwiMFwiKSBdIClcblxuXG5pbnRlcm5hbHMucGFyc2UgPSBmdW5jdGlvbiAocmF3LCBwcmVmZXJlbmNlcywgb3B0aW9ucykge1xuXG4gICAgLy8gTm9ybWFsaXplIGhlYWRlciAocmVtb3ZlIHNwYWNlcyBhbmQgdGFicylcblxuICAgIGNvbnN0IGhlYWRlciA9IHJhdy5yZXBsYWNlKC9bIFxcdF0vZywgJycpO1xuXG4gICAgLy8gTm9ybWFsaXplIHByZWZlcmVuY2VzXG5cbiAgICBjb25zdCBsb3dlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChwcmVmZXJlbmNlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZlcmVuY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmZXJlbmNlID0gcHJlZmVyZW5jZXNbaV07XG4gICAgICAgICAgICBsb3dlcnNbcHJlZmVyZW5jZS50b0xvd2VyQ2FzZSgpXSA9IHsgb3JpZzogcHJlZmVyZW5jZSwgcG9zOiBpIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJzZSBzZWxlY3Rpb25zXG5cbiAgICBjb25zdCBwYXJ0cyA9IGhlYWRlci5zcGxpdCgnLCcpO1xuICAgIGNvbnN0IHNlbGVjdGlvbnMgPSBbXTtcbiAgICBjb25zdCBtYXAgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5IHBhcnRzIG9yIGxlYWRpbmcgY29tbWFzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIHBhcmFtZXRlcnNcblxuICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJ0LnNwbGl0KCc7Jyk7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KGBJbnZhbGlkICR7b3B0aW9ucy50eXBlfSBoZWFkZXJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b2tlbiA9IHBhcmFtc1swXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoYEludmFsaWQgJHtvcHRpb25zLnR5cGV9IGhlYWRlcmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZXF1aXZhbGVudHMgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuZXF1aXZhbGVudHNbdG9rZW5dKSB7XG5cbiAgICAgICAgICAgIHRva2VuID0gb3B0aW9ucy5lcXVpdmFsZW50c1t0b2tlbl07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgIHE6IDEsXG4gICAgICAgICAgICBzcGVjaWZpY2l0eTogb3B0aW9ucy5zcGVjaWZpY2l0eSA/IHRva2VuLnNwbGl0KCctJykgOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByZWZlcmVuY2VzICYmXG4gICAgICAgICAgICBsb3dlcnNbdG9rZW5dKSB7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5wcmVmID0gbG93ZXJzW3Rva2VuXS5wb3M7XG4gICAgICAgIH1cblxuICAgICAgICBtYXBbc2VsZWN0aW9uLnRva2VuXSA9IHNlbGVjdGlvbjtcblxuICAgICAgICAvLyBQYXJzZSBxPXZhbHVlXG5cbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSBwYXJhbXNbMV07XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBxLnNwbGl0KCc9Jyk7XG5cbiAgICAgICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgICAgICAoa2V5ICE9PSAncScgJiYga2V5ICE9PSAnUScpKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoYEludmFsaWQgJHtvcHRpb25zLnR5cGV9IGhlYWRlcmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzY29yZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHNjb3JlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUoc2NvcmUpICYmXG4gICAgICAgICAgICAgICAgc2NvcmUgPD0gMSAmJlxuICAgICAgICAgICAgICAgIHNjb3JlID49IDAuMDAxKSB7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucSA9IHNjb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHNlbGVjdGlvbik7ICAgICAgICAgICAgIC8vIE9ubHkgYWRkIGFsbG93ZWQgc2VsZWN0aW9ucyAocSAhPT0gMClcbiAgICB9XG5cbiAgICAvLyBTb3J0IHNlbGVjdGlvbiBiYXNlZCBvbiBxIGFuZCB0aGVuIHBvc2l0aW9uIGluIGhlYWRlclxuXG4gICAgc2VsZWN0aW9ucy5zb3J0KGludGVybmFscy5zb3J0KTtcblxuICAgIC8vIEV4dHJhY3QgdG9rZW5zXG5cbiAgICBjb25zdCB2YWx1ZXMgPSBzZWxlY3Rpb25zLm1hcCgoc2VsZWN0aW9uKSA9PiBzZWxlY3Rpb24udG9rZW4pO1xuXG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdCAmJlxuICAgICAgICAhbWFwW29wdGlvbnMuZGVmYXVsdF0pIHtcblxuICAgICAgICB2YWx1ZXMucHVzaChvcHRpb25zLmRlZmF1bHQpO1xuICAgIH1cblxuICAgIGlmICghcHJlZmVyZW5jZXMgfHxcbiAgICAgICAgIXByZWZlcmVuY2VzLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgY29uc3QgcHJlZmVycmVkID0gW107XG4gICAgZm9yIChjb25zdCBzZWxlY3Rpb24gb2YgdmFsdWVzKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24gPT09ICcqJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVmZXJlbmNlIG9mIE9iamVjdC5rZXlzKGxvd2VycykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcFtwcmVmZXJlbmNlXSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmZXJyZWQucHVzaChsb3dlcnNbcHJlZmVyZW5jZV0ub3JpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbG93ZXIgPSBzZWxlY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChsb3dlcnNbbG93ZXJdKSB7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkLnB1c2gobG93ZXJzW2xvd2VyXS5vcmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcmVmZXJyZWQ7XG59O1xuXG5cbmludGVybmFscy5zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIGNvbnN0IGFGaXJzdCA9IC0xO1xuICAgIGNvbnN0IGJGaXJzdCA9IDE7XG5cbiAgICBpZiAoYi5xICE9PSBhLnEpIHtcbiAgICAgICAgcmV0dXJuIGIucSAtIGEucTtcbiAgICB9XG5cbiAgICBpZiAoYi5wcmVmICE9PSBhLnByZWYpIHtcbiAgICAgICAgaWYgKGEucHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGIucHJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYUZpcnN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEucHJlZiAtIGIucHJlZjtcbiAgICB9XG5cbiAgICBpZiAoYS5zcGVjaWZpY2l0eSAmJlxuICAgICAgICBhLnNwZWNpZmljaXR5WzBdID09PSBiLnNwZWNpZmljaXR5WzBdICYmXG4gICAgICAgIGEuc3BlY2lmaWNpdHkubGVuZ3RoICE9PSBiLnNwZWNpZmljaXR5Lmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBiLnNwZWNpZmljaXR5Lmxlbmd0aCAtIGEuc3BlY2lmaWNpdHkubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBhLnBvcyAtIGIucG9zO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXInKTtcbmNvbnN0IE1lZGlhID0gcmVxdWlyZSgnLi9tZWRpYScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIGNoYXJzZXQ6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhY2NlcHQtY2hhcnNldCdcbiAgICAgICAgfSxcbiAgICAgICAgZW5jb2Rpbmc6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhY2NlcHQtZW5jb2RpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2lkZW50aXR5JyxcbiAgICAgICAgICAgIGVxdWl2YWxlbnRzOiB7XG4gICAgICAgICAgICAgICAgJ3gtY29tcHJlc3MnOiAnY29tcHJlc3MnLFxuICAgICAgICAgICAgICAgICd4LWd6aXAnOiAnZ3ppcCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgIHR5cGU6ICdhY2NlcHQtbGFuZ3VhZ2UnLFxuICAgICAgICAgICAgc3BlY2lmaWNpdHk6IHRydWVcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuZm9yIChjb25zdCB0eXBlIGluIGludGVybmFscy5vcHRpb25zKSB7XG4gICAgZXhwb3J0c1t0eXBlXSA9IChoZWFkZXIsIHByZWZlcmVuY2VzKSA9PiBIZWFkZXIuc2VsZWN0aW9uKGhlYWRlciwgcHJlZmVyZW5jZXMsIGludGVybmFscy5vcHRpb25zW3R5cGVdKTtcblxuICAgIGV4cG9ydHNbYCR7dHlwZX1zYF0gPSAoaGVhZGVyLCBwcmVmZXJlbmNlcykgPT4gSGVhZGVyLnNlbGVjdGlvbnMoaGVhZGVyLCBwcmVmZXJlbmNlcywgaW50ZXJuYWxzLm9wdGlvbnNbdHlwZV0pO1xufVxuXG5cbmV4cG9ydHMubWVkaWFUeXBlID0gKGhlYWRlciwgcHJlZmVyZW5jZXMpID0+IE1lZGlhLnNlbGVjdGlvbihoZWFkZXIsIHByZWZlcmVuY2VzKTtcblxuZXhwb3J0cy5tZWRpYVR5cGVzID0gKGhlYWRlciwgcHJlZmVyZW5jZXMpID0+IE1lZGlhLnNlbGVjdGlvbnMoaGVhZGVyLCBwcmVmZXJlbmNlcyk7XG5cblxuZXhwb3J0cy5wYXJzZUFsbCA9IGZ1bmN0aW9uIChyZXF1ZXN0SGVhZGVycykge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhcnNldHM6IGV4cG9ydHMuY2hhcnNldHMocmVxdWVzdEhlYWRlcnNbJ2FjY2VwdC1jaGFyc2V0J10pLFxuICAgICAgICBlbmNvZGluZ3M6IGV4cG9ydHMuZW5jb2RpbmdzKHJlcXVlc3RIZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXSksXG4gICAgICAgIGxhbmd1YWdlczogZXhwb3J0cy5sYW5ndWFnZXMocmVxdWVzdEhlYWRlcnNbJ2FjY2VwdC1sYW5ndWFnZSddKSxcbiAgICAgICAgbWVkaWFUeXBlczogZXhwb3J0cy5tZWRpYVR5cGVzKHJlcXVlc3RIZWFkZXJzLmFjY2VwdClcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uIChoZWFkZXIsIHByZWZlcmVuY2VzKSB7XG5cbiAgICBjb25zdCBzZWxlY3Rpb25zID0gZXhwb3J0cy5zZWxlY3Rpb25zKGhlYWRlciwgcHJlZmVyZW5jZXMpO1xuICAgIHJldHVybiBzZWxlY3Rpb25zLmxlbmd0aCA/IHNlbGVjdGlvbnNbMF0gOiAnJztcbn07XG5cblxuZXhwb3J0cy5zZWxlY3Rpb25zID0gZnVuY3Rpb24gKGhlYWRlciwgcHJlZmVyZW5jZXMpIHtcblxuICAgIEhvZWsuYXNzZXJ0KCFwcmVmZXJlbmNlcyB8fCBBcnJheS5pc0FycmF5KHByZWZlcmVuY2VzKSwgJ1ByZWZlcmVuY2VzIG11c3QgYmUgYW4gYXJyYXknKTtcblxuICAgIHJldHVybiBpbnRlcm5hbHMucGFyc2UoaGVhZGVyLCBwcmVmZXJlbmNlcyk7XG59O1xuXG5cbi8vICAgICAgUkZDIDcyMzEgU2VjdGlvbiA1LjMuMiAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi01LjMuMilcbi8vXG4vLyAgICAgIEFjY2VwdCAgICAgICAgICA9IFsgKCBcIixcIiAvICggbWVkaWEtcmFuZ2UgWyBhY2NlcHQtcGFyYW1zIF0gKSApICooIE9XUyBcIixcIiBbIE9XUyAoIG1lZGlhLXJhbmdlIFsgYWNjZXB0LXBhcmFtcyBdICkgXSApIF1cbi8vICAgICAgbWVkaWEtcmFuZ2UgICAgID0gKCBcIiovKlwiIC8gKCB0eXBlIFwiLypcIiApIC8gKCB0eXBlIFwiL1wiIHN1YnR5cGUgKSApICooIE9XUyBcIjtcIiBPV1MgcGFyYW1ldGVyIClcbi8vICAgICAgYWNjZXB0LXBhcmFtcyAgID0gd2VpZ2h0ICphY2NlcHQtZXh0XG4vLyAgICAgIGFjY2VwdC1leHQgICAgICA9IE9XUyBcIjtcIiBPV1MgdG9rZW4gWyBcIj1cIiAoIHRva2VuIC8gcXVvdGVkLXN0cmluZyApIF1cbi8vICAgICAgdHlwZSAgICAgICAgICAgID0gdG9rZW5cbi8vICAgICAgc3VidHlwZSAgICAgICAgID0gdG9rZW5cbi8vICAgICAgcGFyYW1ldGVyICAgICAgID0gdG9rZW4gXCI9XCIgKCB0b2tlbiAvIHF1b3RlZC1zdHJpbmcgKVxuLy9cbi8vICAgICAgcXVvdGVkLXN0cmluZyAgID0gRFFVT1RFICooIHFkdGV4dCAvIHF1b3RlZC1wYWlyICkgRFFVT1RFXG4vLyAgICAgIHFkdGV4dCAgICAgICAgICA9IEhUQUIgLyBTUCAvJXgyMSAvICV4MjMtNUIgLyAleDVELTdFIC8gb2JzLXRleHRcbi8vICAgICAgb2JzLXRleHQgICAgICAgID0gJXg4MC1GRlxuLy8gICAgICBxdW90ZWQtcGFpciAgICAgPSBcIlxcXCIgKCBIVEFCIC8gU1AgLyBWQ0hBUiAvIG9icy10ZXh0IClcbi8vICAgICAgVkNIQVIgICAgICAgICAgID0gJXgyMS03RSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyB2aXNpYmxlIChwcmludGluZykgY2hhcmFjdGVyc1xuLy8gICAgICB0b2tlbiAgICAgICAgICAgPSAxKnRjaGFyXG4vLyAgICAgIHRjaGFyICAgICAgICAgICA9IFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIiAvIERJR0lUIC8gQUxQSEFcbi8vICAgICAgT1dTICAgICAgICAgICAgID0gKiggU1AgLyBIVEFCIClcbi8vXG4vLyAgICAgIEFjY2VwdDogYXVkaW8vKjsgcT0wLjIsIGF1ZGlvL2Jhc2ljXG4vLyAgICAgIEFjY2VwdDogdGV4dC9wbGFpbjsgcT0wLjUsIHRleHQvaHRtbCwgdGV4dC94LWR2aTsgcT0wLjgsIHRleHQveC1jXG4vLyAgICAgIEFjY2VwdDogdGV4dC9wbGFpbiwgYXBwbGljYXRpb24vanNvbjtxPTAuNSwgdGV4dC9odG1sLCAqLyo7IHEgPSAwLjFcbi8vICAgICAgQWNjZXB0OiB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qc29uO3E9MC41LCB0ZXh0L2h0bWwsIHRleHQvZHJvcDtxPTBcbi8vICAgICAgQWNjZXB0OiB0ZXh0LyosIHRleHQvcGxhaW4sIHRleHQvcGxhaW47Zm9ybWF0PWZsb3dlZCwgKi8qXG4vLyAgICAgIEFjY2VwdDogdGV4dC8qO3E9MC4zLCB0ZXh0L2h0bWw7cT0wLjcsIHRleHQvaHRtbDtsZXZlbD0xLCB0ZXh0L2h0bWw7bGV2ZWw9MjtxPTAuNCwgKi8qO3E9MC41XG5cblxuLy8gICAgICBSRkMgNzIzMSBTZWN0aW9uIDUuMy4xIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTUuMy4xKVxuLy9cbi8vICAgICAgVGhlIHdlaWdodCBpcyBub3JtYWxpemVkIHRvIGEgcmVhbCBudW1iZXIgaW4gdGhlIHJhbmdlIDAgdGhyb3VnaCAxLFxuLy8gICAgICB3aGVyZSAwLjAwMSBpcyB0aGUgbGVhc3QgcHJlZmVycmVkIGFuZCAxIGlzIHRoZSBtb3N0IHByZWZlcnJlZDsgYVxuLy8gICAgICB2YWx1ZSBvZiAwIG1lYW5zIFwibm90IGFjY2VwdGFibGVcIi4gIElmIG5vIFwicVwiIHBhcmFtZXRlciBpcyBwcmVzZW50LFxuLy8gICAgICB0aGUgZGVmYXVsdCB3ZWlnaHQgaXMgMS5cbi8vXG4vLyAgICAgICB3ZWlnaHQgPSBPV1MgXCI7XCIgT1dTIFwicT1cIiBxdmFsdWVcbi8vICAgICAgIHF2YWx1ZSA9ICggXCIwXCIgWyBcIi5cIiAwKjNESUdJVCBdICkgLyAoIFwiMVwiIFsgXCIuXCIgMCozKFwiMFwiKSBdIClcblxuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAqLyogICAgICAgIHR5cGUvKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUvc3VidHlwZVxuaW50ZXJuYWxzLnZhbGlkTWVkaWFSeCA9IC9eKD86XFwqXFwvXFwqKXwoPzpbXFx3XFwhI1xcJCUmJ1xcKlxcK1xcLVxcLlxcXmBcXHx+XStcXC9cXCopfCg/OltcXHdcXCEjXFwkJSYnXFwqXFwrXFwtXFwuXFxeYFxcfH5dK1xcL1tcXHdcXCEjXFwkJSYnXFwqXFwrXFwtXFwuXFxeYFxcfH5dKykkLztcblxuXG5pbnRlcm5hbHMucGFyc2UgPSBmdW5jdGlvbiAocmF3LCBwcmVmZXJlbmNlcykge1xuXG4gICAgLy8gTm9ybWFsaXplIGhlYWRlciAocmVtb3ZlIHNwYWNlcyBhbmQgdGVtcG9yYXJ5IHJlbW92ZSBxdW90ZWQgc3RyaW5ncylcblxuICAgIGNvbnN0IHsgaGVhZGVyLCBxdW90ZWQgfSA9IGludGVybmFscy5ub3JtYWxpemUocmF3KTtcblxuICAgIC8vIFBhcnNlIHNlbGVjdGlvbnNcblxuICAgIGNvbnN0IHBhcnRzID0gaGVhZGVyLnNwbGl0KCcsJyk7XG4gICAgY29uc3Qgc2VsZWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlbXB0eSBwYXJ0cyBvciBsZWFkaW5nIGNvbW1hc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSBwYXJhbWV0ZXJzXG5cbiAgICAgICAgY29uc3QgcGFpcnMgPSBwYXJ0LnNwbGl0KCc7Jyk7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFpcnMuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmICghaW50ZXJuYWxzLnZhbGlkTWVkaWFSeC50ZXN0KHRva2VuKSkgeyAgICAgICAvLyBJZ25vcmUgaW52YWxpZCB0eXBlc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHBhcmFtczoge30sXG4gICAgICAgICAgICBleHRzOiB7fSxcbiAgICAgICAgICAgIHBvczogaVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFBhcnNlIGtleT12YWx1ZVxuXG4gICAgICAgIGxldCB0YXJnZXQgPSAncGFyYW1zJztcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBrdiA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGlmIChrdi5sZW5ndGggIT09IDIgfHxcbiAgICAgICAgICAgICAgICAha3ZbMV0pIHtcblxuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdChgSW52YWxpZCBhY2NlcHQgaGVhZGVyYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGt2WzBdO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0ga3ZbMV07XG5cbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdxJyB8fFxuICAgICAgICAgICAgICAgIGtleSA9PT0gJ1EnKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSAnZXh0cyc7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA+IDEgfHxcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlIDwgMC4wMDEgJiYgdmFsdWUgIT09IDApKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5xID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBgXCIke3F1b3RlZFt2YWx1ZV19XCJgO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblt0YXJnZXRdW2t2WzBdXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoc2VsZWN0aW9uLnBhcmFtcyk7XG4gICAgICAgIHNlbGVjdGlvbi5vcmlnaW5hbCA9IFsnJ10uY29uY2F0KHBhcmFtcy5tYXAoKGtleSkgPT4gYCR7a2V5fT0ke3NlbGVjdGlvbi5wYXJhbXNba2V5XX1gKSkuam9pbignOycpO1xuICAgICAgICBzZWxlY3Rpb24uc3BlY2lmaWNpdHkgPSBwYXJhbXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24ucSA9PT0gdW5kZWZpbmVkKSB7ICAgICAvLyBEZWZhdWx0IG5vIHByZWZlcmVuY2UgdG8gcT0xICh0b3AgcHJlZmVyZW5jZSlcbiAgICAgICAgICAgIHNlbGVjdGlvbi5xID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRwYXJ0cyA9IHNlbGVjdGlvbi50b2tlbi5zcGxpdCgnLycpO1xuICAgICAgICBzZWxlY3Rpb24udHlwZSA9IHRwYXJ0c1swXTtcbiAgICAgICAgc2VsZWN0aW9uLnN1YnR5cGUgPSB0cGFydHNbMV07XG5cbiAgICAgICAgbWFwW3NlbGVjdGlvbi50b2tlbl0gPSBzZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5xKSB7ICAgICAgICAgICAgICAgICAgIC8vIFNraXAgZGVuaWVkIHNlbGVjdGlvbnMgKHE9MClcbiAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCBzZWxlY3Rpb24gYmFzZWQgb24gcSBhbmQgdGhlbiBwb3NpdGlvbiBpbiBoZWFkZXJcblxuICAgIHNlbGVjdGlvbnMuc29ydChpbnRlcm5hbHMuc29ydCk7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnByZWZlcmVuY2VzKG1hcCwgc2VsZWN0aW9ucywgcHJlZmVyZW5jZXMpO1xufTtcblxuXG5pbnRlcm5hbHMubm9ybWFsaXplID0gZnVuY3Rpb24gKHJhdykge1xuXG4gICAgcmF3ID0gcmF3IHx8ICcqLyonO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICAgICAgaGVhZGVyOiByYXcsXG4gICAgICAgIHF1b3RlZDoge31cbiAgICB9O1xuXG4gICAgaWYgKHJhdy5pbmNsdWRlcygnXCInKSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIG5vcm1hbGl6ZWQuaGVhZGVyID0gcmF3LnJlcGxhY2UoLz1cIihbXlwiXSopXCIvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBrZXkgPSAnXCInICsgKytpO1xuICAgICAgICAgICAgbm9ybWFsaXplZC5xdW90ZWRba2V5XSA9ICQxO1xuICAgICAgICAgICAgcmV0dXJuICc9JyArIGtleTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplZC5oZWFkZXIgPSBub3JtYWxpemVkLmhlYWRlci5yZXBsYWNlKC9bIFxcdF0vZywgJycpO1xuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuXG5pbnRlcm5hbHMuc29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICAvLyBTb3J0IGJ5IHF1YWxpdHkgc2NvcmVcblxuICAgIGlmIChiLnEgIT09IGEucSkge1xuICAgICAgICByZXR1cm4gYi5xIC0gYS5xO1xuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgdHlwZVxuXG4gICAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuaW5uZXJTb3J0KGEsIGIsICd0eXBlJyk7XG4gICAgfVxuXG4gICAgLy8gU29ydCBieSBzdWJ0eXBlXG5cbiAgICBpZiAoYS5zdWJ0eXBlICE9PSBiLnN1YnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5pbm5lclNvcnQoYSwgYiwgJ3N1YnR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBTb3J0IGJ5IHNwZWNpZmljaXR5XG5cbiAgICBpZiAoYS5zcGVjaWZpY2l0eSAhPT0gYi5zcGVjaWZpY2l0eSkge1xuICAgICAgICByZXR1cm4gYi5zcGVjaWZpY2l0eSAtIGEuc3BlY2lmaWNpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEucG9zIC0gYi5wb3M7XG59O1xuXG5cbmludGVybmFscy5pbm5lclNvcnQgPSBmdW5jdGlvbiAoYSwgYiwga2V5KSB7XG5cbiAgICBjb25zdCBhRmlyc3QgPSAtMTtcbiAgICBjb25zdCBiRmlyc3QgPSAxO1xuXG4gICAgaWYgKGFba2V5XSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBiRmlyc3Q7XG4gICAgfVxuXG4gICAgaWYgKGJba2V5XSA9PT0gJyonKSB7XG4gICAgICAgIHJldHVybiBhRmlyc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFba2V5XSA8IGJba2V5XSA/IGFGaXJzdCA6IGJGaXJzdDsgICAgICAgLy8gR3JvdXAgYWxwaGFiZXRpY2FsbHlcbn07XG5cblxuaW50ZXJuYWxzLnByZWZlcmVuY2VzID0gZnVuY3Rpb24gKG1hcCwgc2VsZWN0aW9ucywgcHJlZmVyZW5jZXMpIHtcblxuICAgIC8vIFJldHVybiBzZWxlY3Rpb25zIGlmIG5vIHByZWZlcmVuY2VzXG5cbiAgICBpZiAoIXByZWZlcmVuY2VzIHx8XG4gICAgICAgICFwcmVmZXJlbmNlcy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gc2VsZWN0aW9ucy5tYXAoKHNlbGVjdGlvbikgPT4gc2VsZWN0aW9uLnRva2VuICsgc2VsZWN0aW9uLm9yaWdpbmFsKTtcbiAgICB9XG5cbiAgICAvLyBNYXAgd2lsZGNhcmRzIGFuZCBmaWx0ZXIgc2VsZWN0aW9ucyB0byBwcmVmZXJlbmNlc1xuXG4gICAgY29uc3QgbG93ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBmbGF0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgYW55ID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IHByZWZlcmVuY2Ugb2YgcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgY29uc3QgbG93ZXIgPSBwcmVmZXJlbmNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZsYXRbbG93ZXJdID0gcHJlZmVyZW5jZTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsb3dlci5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCB0eXBlID0gcGFydHNbMF07XG4gICAgICAgIGNvbnN0IHN1YnR5cGUgPSBwYXJ0c1sxXTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJyonKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChzdWJ0eXBlID09PSAnKicsICdJbnZhbGlkIG1lZGlhIHR5cGUgcHJlZmVyZW5jZSBjb250YWlucyB3aWxkY2FyZCB0eXBlIHdpdGggYSBzdWJ0eXBlJyk7XG4gICAgICAgICAgICBhbnkgPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsb3dlcnNbdHlwZV0gPSBsb3dlcnNbdHlwZV0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbG93ZXJzW3R5cGVdW3N1YnR5cGVdID0gcHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmVmZXJyZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gc2VsZWN0aW9uLnRva2VuO1xuICAgICAgICBjb25zdCB7IHR5cGUsIHN1YnR5cGUgfSA9IG1hcFt0b2tlbl07XG4gICAgICAgIGNvbnN0IHN1YnR5cGVzID0gbG93ZXJzW3R5cGVdO1xuXG4gICAgICAgIC8vICovKlxuXG4gICAgICAgIGlmICh0eXBlID09PSAnKicpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJlZmVyZW5jZSBvZiBPYmplY3Qua2V5cyhmbGF0KSkge1xuICAgICAgICAgICAgICAgIGlmICghbWFwW3ByZWZlcmVuY2VdKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZC5wdXNoKGZsYXRbcHJlZmVyZW5jZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFueSkge1xuICAgICAgICAgICAgICAgIHByZWZlcnJlZC5wdXNoKCcqLyonKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbnlcblxuICAgICAgICBpZiAoYW55KSB7XG4gICAgICAgICAgICBwcmVmZXJyZWQucHVzaCgoZmxhdFt0b2tlbl0gfHwgdG9rZW4pICsgc2VsZWN0aW9uLm9yaWdpbmFsKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHlwZS9zdWJ0eXBlXG5cbiAgICAgICAgaWYgKHN1YnR5cGUgIT09ICcqJykge1xuICAgICAgICAgICAgY29uc3QgcHJlZiA9IGZsYXRbdG9rZW5dO1xuICAgICAgICAgICAgaWYgKHByZWYgfHxcbiAgICAgICAgICAgICAgICAoc3VidHlwZXMgJiYgc3VidHlwZXNbJyonXSkpIHtcblxuICAgICAgICAgICAgICAgIHByZWZlcnJlZC5wdXNoKChwcmVmIHx8IHRva2VuKSArIHNlbGVjdGlvbi5vcmlnaW5hbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHlwZS8qXG5cbiAgICAgICAgaWYgKHN1YnR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBzdWIgb2YgT2JqZWN0LmtleXMoc3VidHlwZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXBbYCR7dHlwZX0vJHtwc3VifWBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZC5wdXNoKHN1YnR5cGVzW3BzdWJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZmVycmVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXJsID0gcmVxdWlyZSgndXJsJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1pbkRvbWFpblNlZ21lbnRzOiAyLFxuICAgIG5vbkFzY2lpUng6IC9bXlxceDAwLVxceDdmXS8sXG4gICAgZG9tYWluQ29udHJvbFJ4OiAvW1xceDAwLVxceDIwXS8sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cm9sICsgc3BhY2VcbiAgICB0bGRTZWdtZW50Ung6IC9eW2EtekEtWl0oPzpbYS16QS1aMC05XFwtXSpbYS16QS1aMC05XSk/JC8sXG4gICAgZG9tYWluU2VnbWVudFJ4OiAvXlthLXpBLVowLTldKD86W2EtekEtWjAtOVxcLV0qW2EtekEtWjAtOV0pPyQvLFxuICAgIFVSTDogVXJsLlVSTCB8fCBVUkwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxufTtcblxuXG5leHBvcnRzLmFuYWx5emUgPSBmdW5jdGlvbiAoZG9tYWluLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICh0eXBlb2YgZG9tYWluICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQ6IGRvbWFpbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdEb21haW4gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnIH07XG4gICAgfVxuXG4gICAgaWYgKGRvbWFpbi5sZW5ndGggPiAyNTYpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdEb21haW4gdG9vIGxvbmcnIH07XG4gICAgfVxuXG4gICAgY29uc3QgYXNjaWkgPSAhaW50ZXJuYWxzLm5vbkFzY2lpUngudGVzdChkb21haW4pO1xuICAgIGlmICghYXNjaWkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmljb2RlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ0RvbWFpbiBjb250YWlucyBmb3JiaWRkZW4gVW5pY29kZSBjaGFyYWN0ZXJzJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tYWluID0gZG9tYWluLm5vcm1hbGl6ZSgnTkZDJyk7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFscy5kb21haW5Db250cm9sUngudGVzdChkb21haW4pKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiAnRG9tYWluIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyJyB9O1xuICAgIH1cblxuICAgIGRvbWFpbiA9IGludGVybmFscy5wdW55Y29kZShkb21haW4pO1xuXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzEwMzUgc2VjdGlvbiAyLjMuMVxuXG4gICAgY29uc3QgbWluRG9tYWluU2VnbWVudHMgPSBvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzIHx8IGludGVybmFscy5taW5Eb21haW5TZWdtZW50cztcblxuICAgIGNvbnN0IHNlZ21lbnRzID0gZG9tYWluLnNwbGl0KCcuJyk7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA8IG1pbkRvbWFpblNlZ21lbnRzKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiAnRG9tYWluIGxhY2tzIHRoZSBtaW5pbXVtIHJlcXVpcmVkIG51bWJlciBvZiBzZWdtZW50cycgfTtcbiAgICB9XG5cbiAgICBjb25zdCB0bGRzID0gb3B0aW9ucy50bGRzO1xuICAgIGlmICh0bGRzKSB7XG4gICAgICAgIGNvbnN0IHRsZCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICh0bGRzLmRlbnkgJiYgdGxkcy5kZW55Lmhhcyh0bGQpIHx8XG4gICAgICAgICAgICB0bGRzLmFsbG93ICYmICF0bGRzLmFsbG93Lmhhcyh0bGQpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnRG9tYWluIHVzZXMgZm9yYmlkZGVuIFRMRCcgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICAgIGlmICghc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnRG9tYWluIGNvbnRhaW5zIGVtcHR5IGRvdC1zZXBhcmF0ZWQgc2VnbWVudCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ0RvbWFpbiBjb250YWlucyBkb3Qtc2VwYXJhdGVkIHNlZ21lbnQgdGhhdCBpcyB0b28gbG9uZycgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpIDwgc2VnbWVudHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuZG9tYWluU2VnbWVudFJ4LnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ0RvbWFpbiBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcicgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnRsZFNlZ21lbnRSeC50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdEb21haW4gY29udGFpbnMgaW52YWxpZCB0bGQgY2hhcmFjdGVyJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmlzVmFsaWQgPSBmdW5jdGlvbiAoZG9tYWluLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gIWV4cG9ydHMuYW5hbHl6ZShkb21haW4sIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMucHVueWNvZGUgPSBmdW5jdGlvbiAoZG9tYWluKSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5VUkwoYGh0dHA6Ly8ke2RvbWFpbn1gKS5ob3N0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBkb21haW47XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgRG9tYWluID0gcmVxdWlyZSgnLi9kb21haW4nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbm9uQXNjaWlSeDogL1teXFx4MDAtXFx4N2ZdLyxcbiAgICBlbmNvZGVyOiBuZXcgKFV0aWwuVGV4dEVuY29kZXIgfHwgVGV4dEVuY29kZXIpKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxufTtcblxuXG5leHBvcnRzLmFuYWx5emUgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuZW1haWwoZW1haWwsIG9wdGlvbnMpO1xufTtcblxuXG5leHBvcnRzLmlzVmFsaWQgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiAhaW50ZXJuYWxzLmVtYWlsKGVtYWlsLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLmVtYWlsID0gZnVuY3Rpb24gKGVtYWlsLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dDogZW1haWwgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghZW1haWwpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdBZGRyZXNzIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyB9O1xuICAgIH1cblxuICAgIC8vIFVuaWNvZGVcblxuICAgIGNvbnN0IGFzY2lpID0gIWludGVybmFscy5ub25Bc2NpaVJ4LnRlc3QoZW1haWwpO1xuICAgIGlmICghYXNjaWkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dVbmljb2RlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnQWRkcmVzcyBjb250YWlucyBmb3JiaWRkZW4gVW5pY29kZSBjaGFyYWN0ZXJzJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZW1haWwgPSBlbWFpbC5ub3JtYWxpemUoJ05GQycpO1xuICAgIH1cblxuICAgIC8vIEJhc2ljIHN0cnVjdHVyZVxuXG4gICAgY29uc3QgcGFydHMgPSBlbWFpbC5zcGxpdCgnQCcpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IHBhcnRzLmxlbmd0aCA+IDIgPyAnQWRkcmVzcyBjYW5ub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIEAgY2hhcmFjdGVyJyA6ICdBZGRyZXNzIG11c3QgY29udGFpbiBvbmUgQCBjaGFyYWN0ZXInIH07XG4gICAgfVxuXG4gICAgY29uc3QgW2xvY2FsLCBkb21haW5dID0gcGFydHM7XG5cbiAgICBpZiAoIWxvY2FsKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IGNhbm5vdCBiZSBlbXB0eScgfTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuaWdub3JlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChlbWFpbC5sZW5ndGggPiAyNTQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTMyMSNzZWN0aW9uLTQuNS4zLjEuM1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdBZGRyZXNzIHRvbyBsb25nJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVybmFscy5lbmNvZGVyLmVuY29kZShsb2NhbCkubGVuZ3RoID4gNjQpIHsgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4xXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ0FkZHJlc3MgbG9jYWwgcGFydCB0b28gbG9uZycgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHBhcnRzXG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmxvY2FsKGxvY2FsLCBhc2NpaSkgfHwgRG9tYWluLmFuYWx5emUoZG9tYWluLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLmxvY2FsID0gZnVuY3Rpb24gKGxvY2FsLCBhc2NpaSkge1xuXG4gICAgY29uc3Qgc2VnbWVudHMgPSBsb2NhbC5zcGxpdCgnLicpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICBpZiAoIXNlZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ0FkZHJlc3MgbG9jYWwgcGFydCBjb250YWlucyBlbXB0eSBkb3Qtc2VwYXJhdGVkIHNlZ21lbnQnIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXNjaWkpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmF0ZXh0UngudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyJyB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgY2hhciBvZiBzZWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmF0ZXh0UngudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBiaW5hcnkgPSBpbnRlcm5hbHMuYmluYXJ5KGNoYXIpO1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuYXRvbVJ4LnRlc3QoYmluYXJ5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuYmluYXJ5ID0gZnVuY3Rpb24gKGNoYXIpIHtcblxuICAgIHJldHVybiBBcnJheS5mcm9tKGludGVybmFscy5lbmNvZGVyLmVuY29kZShjaGFyKSkubWFwKCh2KSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpKS5qb2luKCcnKTtcbn07XG5cblxuLypcbiAgICBGcm9tIFJGQyA1MzIxOlxuXG4gICAgICAgIE1haWxib3ggICAgICAgICA9ICAgTG9jYWwtcGFydCBcIkBcIiAoIERvbWFpbiAvIGFkZHJlc3MtbGl0ZXJhbCApXG5cbiAgICAgICAgTG9jYWwtcGFydCAgICAgID0gICBEb3Qtc3RyaW5nIC8gUXVvdGVkLXN0cmluZ1xuICAgICAgICBEb3Qtc3RyaW5nICAgICAgPSAgIEF0b20gKihcIi5cIiAgQXRvbSlcbiAgICAgICAgQXRvbSAgICAgICAgICAgID0gICAxKmF0ZXh0XG4gICAgICAgIGF0ZXh0ICAgICAgICAgICA9ICAgQUxQSEEgLyBESUdJVCAvIFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIi1cIiAvIFwiL1wiIC8gXCI9XCIgLyBcIj9cIiAvIFwiXlwiIC8gXCJfXCIgLyBcImBcIiAvIFwie1wiIC8gXCJ8XCIgLyBcIn1cIiAvIFwiflwiXG5cbiAgICAgICAgRG9tYWluICAgICAgICAgID0gICBzdWItZG9tYWluICooXCIuXCIgc3ViLWRvbWFpbilcbiAgICAgICAgc3ViLWRvbWFpbiAgICAgID0gICBMZXQtZGlnIFtMZGgtc3RyXVxuICAgICAgICBMZXQtZGlnICAgICAgICAgPSAgIEFMUEhBIC8gRElHSVRcbiAgICAgICAgTGRoLXN0ciAgICAgICAgID0gICAqKCBBTFBIQSAvIERJR0lUIC8gXCItXCIgKSBMZXQtZGlnXG5cbiAgICAgICAgQUxQSEEgICAgICAgICAgID0gICAleDQxLTVBIC8gJXg2MS03QSAgICAgICAgOyBhLXosIEEtWlxuICAgICAgICBESUdJVCAgICAgICAgICAgPSAgICV4MzAtMzkgICAgICAgICAgICAgICAgICA7IDAtOVxuXG4gICAgRnJvbSBSRkMgNjUzMTpcblxuICAgICAgICBzdWItZG9tYWluICAgICAgPS8gIFUtbGFiZWxcbiAgICAgICAgYXRleHQgICAgICAgICAgID0vICBVVEY4LW5vbi1hc2NpaVxuXG4gICAgICAgIFVURjgtbm9uLWFzY2lpICA9ICAgVVRGOC0yIC8gVVRGOC0zIC8gVVRGOC00XG5cbiAgICAgICAgVVRGOC0yICAgICAgICAgID0gICAleEMyLURGIFVURjgtdGFpbFxuICAgICAgICBVVEY4LTMgICAgICAgICAgPSAgICV4RTAgJXhBMC1CRiBVVEY4LXRhaWwgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RTEtRUMgMiggVVRGOC10YWlsICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RUQgJXg4MC05RiBVVEY4LXRhaWwgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RUUtRUYgMiggVVRGOC10YWlsIClcbiAgICAgICAgVVRGOC00ICAgICAgICAgID0gICAleEYwICV4OTAtQkYgMiggVVRGOC10YWlsICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RjEtRjMgMyggVVRGOC10YWlsICkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICV4RjQgJXg4MC04RiAyKCBVVEY4LXRhaWwgKVxuXG4gICAgICAgIFVURjgtdGFpbCAgICAgICA9ICAgJXg4MC1CRlxuXG4gICAgTm90ZTogVGhlIGZvbGxvd2luZyBhcmUgbm90IHN1cHBvcnRlZDpcblxuICAgICAgICBSRkMgNTMyMTogYWRkcmVzcy1saXRlcmFsLCBRdW90ZWQtc3RyaW5nXG4gICAgICAgIFJGQyA1MzIyOiBvYnMtKiwgQ0ZXU1xuKi9cblxuXG5pbnRlcm5hbHMuYXRleHRSeCA9IC9eW1xcdyEjXFwkJSYnXFwqXFwrXFwtLz1cXD9cXF5gXFx7XFx8XFx9fl0rJC87ICAgICAgICAgICAgICAgLy8gXyBpbmNsdWRlZCBpbiBcXHdcblxuXG5pbnRlcm5hbHMuYXRvbVJ4ID0gbmV3IFJlZ0V4cChbXG5cbiAgICAvLyAgJXhDMi1ERiBVVEY4LXRhaWxcbiAgICAnKD86W1xcXFx4YzItXFxcXHhkZl1bXFxcXHg4MC1cXFxceGJmXSknLFxuXG4gICAgLy8gICV4RTAgJXhBMC1CRiBVVEY4LXRhaWwgICAgICAgICAgICAgICV4RTEtRUMgMiggVVRGOC10YWlsICkgICAgICAgICAgICAleEVEICV4ODAtOUYgVVRGOC10YWlsICAgICAgICAgICAgICAleEVFLUVGIDIoIFVURjgtdGFpbCApXG4gICAgJyg/OlxcXFx4ZTBbXFxcXHhhMC1cXFxceGJmXVtcXFxceDgwLVxcXFx4YmZdKXwoPzpbXFxcXHhlMS1cXFxceGVjXVtcXFxceDgwLVxcXFx4YmZdezJ9KXwoPzpcXFxceGVkW1xcXFx4ODAtXFxcXHg5Zl1bXFxcXHg4MC1cXFxceGJmXSl8KD86W1xcXFx4ZWUtXFxcXHhlZl1bXFxcXHg4MC1cXFxceGJmXXsyfSknLFxuXG4gICAgLy8gICV4RjAgJXg5MC1CRiAyKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RjEtRjMgMyggVVRGOC10YWlsICkgICAgICAgICAgICAleEY0ICV4ODAtOEYgMiggVVRGOC10YWlsIClcbiAgICAnKD86XFxcXHhmMFtcXFxceDkwLVxcXFx4YmZdW1xcXFx4ODAtXFxcXHhiZl17Mn0pfCg/OltcXFxceGYxLVxcXFx4ZjNdW1xcXFx4ODAtXFxcXHhiZl17M30pfCg/OlxcXFx4ZjRbXFxcXHg4MC1cXFxceDhmXVtcXFxceDgwLVxcXFx4YmZdezJ9KSdcblxuXS5qb2luKCd8JykpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBEb21haW4gPSByZXF1aXJlKCcuL2RvbWFpbicpO1xuY29uc3QgRW1haWwgPSByZXF1aXJlKCcuL2VtYWlsJyk7XG5jb25zdCBUbGRzID0gcmVxdWlyZSgnLi90bGRzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGRlZmF1bHRUbGRzOiB7IGFsbG93OiBUbGRzLCBkZW55OiBudWxsIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZG9tYWluOiB7XG4gICAgICAgIGFuYWx5emUoZG9tYWluLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnRlcm5hbHMub3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBEb21haW4uYW5hbHl6ZShkb21haW4sIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzVmFsaWQoZG9tYWluLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnRlcm5hbHMub3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBEb21haW4uaXNWYWxpZChkb21haW4sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbWFpbDoge1xuICAgICAgICBhbmFseXplKGVtYWlsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnRlcm5hbHMub3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBFbWFpbC5hbmFseXplKGVtYWlsLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc1ZhbGlkKGVtYWlsLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnRlcm5hbHMub3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBFbWFpbC5pc1ZhbGlkKGVtYWlsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLm9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IHRsZHM6IGludGVybmFscy5kZWZhdWx0VGxkcyB9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnRsZHMgfHxcbiAgICAgICAgb3B0aW9ucy50bGRzID09PSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogaW50ZXJuYWxzLmRlZmF1bHRUbGRzIH0pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50bGRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uczogdGxkcyBtdXN0IGJlIGEgYm9vbGVhbiBvciBhbiBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRzLmRlbnkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbnM6IHRsZHMuZGVueSBtdXN0IGJlIGEgU2V0IG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudGxkcy5hbGxvdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbnM6IGNhbm5vdCBzcGVjaWZ5IGJvdGggdGxkcy5hbGxvdyBhbmQgdGxkcy5kZW55IGxpc3RzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRzLmFsbG93ID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IGludGVybmFscy5kZWZhdWx0VGxkcyB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bGRzLmFsbG93IGluc3RhbmNlb2YgU2V0ID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uczogdGxkcy5hbGxvdyBtdXN0IGJlIGEgU2V0IG9iamVjdCBvciB0cnVlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBodHRwOi8vZGF0YS5pYW5hLm9yZy9UTEQvdGxkcy1hbHBoYS1ieS1kb21haW4udHh0XG4vLyAjIFZlcnNpb24gMjAxOTA5MTkwMiwgTGFzdCBVcGRhdGVkIEZyaSBTZXAgMjAgMDc6IDA3OiAwMiAyMDE5IFVUQ1xuXG5cbmludGVybmFscy50bGRzID0gW1xuICAgICdBQUEnLFxuICAgICdBQVJQJyxcbiAgICAnQUJBUlRIJyxcbiAgICAnQUJCJyxcbiAgICAnQUJCT1RUJyxcbiAgICAnQUJCVklFJyxcbiAgICAnQUJDJyxcbiAgICAnQUJMRScsXG4gICAgJ0FCT0dBRE8nLFxuICAgICdBQlVESEFCSScsXG4gICAgJ0FDJyxcbiAgICAnQUNBREVNWScsXG4gICAgJ0FDQ0VOVFVSRScsXG4gICAgJ0FDQ09VTlRBTlQnLFxuICAgICdBQ0NPVU5UQU5UUycsXG4gICAgJ0FDTycsXG4gICAgJ0FDVE9SJyxcbiAgICAnQUQnLFxuICAgICdBREFDJyxcbiAgICAnQURTJyxcbiAgICAnQURVTFQnLFxuICAgICdBRScsXG4gICAgJ0FFRycsXG4gICAgJ0FFUk8nLFxuICAgICdBRVROQScsXG4gICAgJ0FGJyxcbiAgICAnQUZBTUlMWUNPTVBBTlknLFxuICAgICdBRkwnLFxuICAgICdBRlJJQ0EnLFxuICAgICdBRycsXG4gICAgJ0FHQUtIQU4nLFxuICAgICdBR0VOQ1knLFxuICAgICdBSScsXG4gICAgJ0FJRycsXG4gICAgJ0FJR08nLFxuICAgICdBSVJCVVMnLFxuICAgICdBSVJGT1JDRScsXG4gICAgJ0FJUlRFTCcsXG4gICAgJ0FLRE4nLFxuICAgICdBTCcsXG4gICAgJ0FMRkFST01FTycsXG4gICAgJ0FMSUJBQkEnLFxuICAgICdBTElQQVknLFxuICAgICdBTExGSU5BTlonLFxuICAgICdBTExTVEFURScsXG4gICAgJ0FMTFknLFxuICAgICdBTFNBQ0UnLFxuICAgICdBTFNUT00nLFxuICAgICdBTScsXG4gICAgJ0FNRVJJQ0FORVhQUkVTUycsXG4gICAgJ0FNRVJJQ0FORkFNSUxZJyxcbiAgICAnQU1FWCcsXG4gICAgJ0FNRkFNJyxcbiAgICAnQU1JQ0EnLFxuICAgICdBTVNURVJEQU0nLFxuICAgICdBTkFMWVRJQ1MnLFxuICAgICdBTkRST0lEJyxcbiAgICAnQU5RVUFOJyxcbiAgICAnQU5aJyxcbiAgICAnQU8nLFxuICAgICdBT0wnLFxuICAgICdBUEFSVE1FTlRTJyxcbiAgICAnQVBQJyxcbiAgICAnQVBQTEUnLFxuICAgICdBUScsXG4gICAgJ0FRVUFSRUxMRScsXG4gICAgJ0FSJyxcbiAgICAnQVJBQicsXG4gICAgJ0FSQU1DTycsXG4gICAgJ0FSQ0hJJyxcbiAgICAnQVJNWScsXG4gICAgJ0FSUEEnLFxuICAgICdBUlQnLFxuICAgICdBUlRFJyxcbiAgICAnQVMnLFxuICAgICdBU0RBJyxcbiAgICAnQVNJQScsXG4gICAgJ0FTU09DSUFURVMnLFxuICAgICdBVCcsXG4gICAgJ0FUSExFVEEnLFxuICAgICdBVFRPUk5FWScsXG4gICAgJ0FVJyxcbiAgICAnQVVDVElPTicsXG4gICAgJ0FVREknLFxuICAgICdBVURJQkxFJyxcbiAgICAnQVVESU8nLFxuICAgICdBVVNQT1NUJyxcbiAgICAnQVVUSE9SJyxcbiAgICAnQVVUTycsXG4gICAgJ0FVVE9TJyxcbiAgICAnQVZJQU5DQScsXG4gICAgJ0FXJyxcbiAgICAnQVdTJyxcbiAgICAnQVgnLFxuICAgICdBWEEnLFxuICAgICdBWicsXG4gICAgJ0FaVVJFJyxcbiAgICAnQkEnLFxuICAgICdCQUJZJyxcbiAgICAnQkFJRFUnLFxuICAgICdCQU5BTUVYJyxcbiAgICAnQkFOQU5BUkVQVUJMSUMnLFxuICAgICdCQU5EJyxcbiAgICAnQkFOSycsXG4gICAgJ0JBUicsXG4gICAgJ0JBUkNFTE9OQScsXG4gICAgJ0JBUkNMQVlDQVJEJyxcbiAgICAnQkFSQ0xBWVMnLFxuICAgICdCQVJFRk9PVCcsXG4gICAgJ0JBUkdBSU5TJyxcbiAgICAnQkFTRUJBTEwnLFxuICAgICdCQVNLRVRCQUxMJyxcbiAgICAnQkFVSEFVUycsXG4gICAgJ0JBWUVSTicsXG4gICAgJ0JCJyxcbiAgICAnQkJDJyxcbiAgICAnQkJUJyxcbiAgICAnQkJWQScsXG4gICAgJ0JDRycsXG4gICAgJ0JDTicsXG4gICAgJ0JEJyxcbiAgICAnQkUnLFxuICAgICdCRUFUUycsXG4gICAgJ0JFQVVUWScsXG4gICAgJ0JFRVInLFxuICAgICdCRU5UTEVZJyxcbiAgICAnQkVSTElOJyxcbiAgICAnQkVTVCcsXG4gICAgJ0JFU1RCVVknLFxuICAgICdCRVQnLFxuICAgICdCRicsXG4gICAgJ0JHJyxcbiAgICAnQkgnLFxuICAgICdCSEFSVEknLFxuICAgICdCSScsXG4gICAgJ0JJQkxFJyxcbiAgICAnQklEJyxcbiAgICAnQklLRScsXG4gICAgJ0JJTkcnLFxuICAgICdCSU5HTycsXG4gICAgJ0JJTycsXG4gICAgJ0JJWicsXG4gICAgJ0JKJyxcbiAgICAnQkxBQ0snLFxuICAgICdCTEFDS0ZSSURBWScsXG4gICAgJ0JMT0NLQlVTVEVSJyxcbiAgICAnQkxPRycsXG4gICAgJ0JMT09NQkVSRycsXG4gICAgJ0JMVUUnLFxuICAgICdCTScsXG4gICAgJ0JNUycsXG4gICAgJ0JNVycsXG4gICAgJ0JOJyxcbiAgICAnQk5QUEFSSUJBUycsXG4gICAgJ0JPJyxcbiAgICAnQk9BVFMnLFxuICAgICdCT0VIUklOR0VSJyxcbiAgICAnQk9GQScsXG4gICAgJ0JPTScsXG4gICAgJ0JPTkQnLFxuICAgICdCT08nLFxuICAgICdCT09LJyxcbiAgICAnQk9PS0lORycsXG4gICAgJ0JPU0NIJyxcbiAgICAnQk9TVElLJyxcbiAgICAnQk9TVE9OJyxcbiAgICAnQk9UJyxcbiAgICAnQk9VVElRVUUnLFxuICAgICdCT1gnLFxuICAgICdCUicsXG4gICAgJ0JSQURFU0NPJyxcbiAgICAnQlJJREdFU1RPTkUnLFxuICAgICdCUk9BRFdBWScsXG4gICAgJ0JST0tFUicsXG4gICAgJ0JST1RIRVInLFxuICAgICdCUlVTU0VMUycsXG4gICAgJ0JTJyxcbiAgICAnQlQnLFxuICAgICdCVURBUEVTVCcsXG4gICAgJ0JVR0FUVEknLFxuICAgICdCVUlMRCcsXG4gICAgJ0JVSUxERVJTJyxcbiAgICAnQlVTSU5FU1MnLFxuICAgICdCVVknLFxuICAgICdCVVpaJyxcbiAgICAnQlYnLFxuICAgICdCVycsXG4gICAgJ0JZJyxcbiAgICAnQlonLFxuICAgICdCWkgnLFxuICAgICdDQScsXG4gICAgJ0NBQicsXG4gICAgJ0NBRkUnLFxuICAgICdDQUwnLFxuICAgICdDQUxMJyxcbiAgICAnQ0FMVklOS0xFSU4nLFxuICAgICdDQU0nLFxuICAgICdDQU1FUkEnLFxuICAgICdDQU1QJyxcbiAgICAnQ0FOQ0VSUkVTRUFSQ0gnLFxuICAgICdDQU5PTicsXG4gICAgJ0NBUEVUT1dOJyxcbiAgICAnQ0FQSVRBTCcsXG4gICAgJ0NBUElUQUxPTkUnLFxuICAgICdDQVInLFxuICAgICdDQVJBVkFOJyxcbiAgICAnQ0FSRFMnLFxuICAgICdDQVJFJyxcbiAgICAnQ0FSRUVSJyxcbiAgICAnQ0FSRUVSUycsXG4gICAgJ0NBUlMnLFxuICAgICdDQVJUSUVSJyxcbiAgICAnQ0FTQScsXG4gICAgJ0NBU0UnLFxuICAgICdDQVNFSUgnLFxuICAgICdDQVNIJyxcbiAgICAnQ0FTSU5PJyxcbiAgICAnQ0FUJyxcbiAgICAnQ0FURVJJTkcnLFxuICAgICdDQVRIT0xJQycsXG4gICAgJ0NCQScsXG4gICAgJ0NCTicsXG4gICAgJ0NCUkUnLFxuICAgICdDQlMnLFxuICAgICdDQycsXG4gICAgJ0NEJyxcbiAgICAnQ0VCJyxcbiAgICAnQ0VOVEVSJyxcbiAgICAnQ0VPJyxcbiAgICAnQ0VSTicsXG4gICAgJ0NGJyxcbiAgICAnQ0ZBJyxcbiAgICAnQ0ZEJyxcbiAgICAnQ0cnLFxuICAgICdDSCcsXG4gICAgJ0NIQU5FTCcsXG4gICAgJ0NIQU5ORUwnLFxuICAgICdDSEFSSVRZJyxcbiAgICAnQ0hBU0UnLFxuICAgICdDSEFUJyxcbiAgICAnQ0hFQVAnLFxuICAgICdDSElOVEFJJyxcbiAgICAnQ0hSSVNUTUFTJyxcbiAgICAnQ0hST01FJyxcbiAgICAnQ0hSWVNMRVInLFxuICAgICdDSFVSQ0gnLFxuICAgICdDSScsXG4gICAgJ0NJUFJJQU5JJyxcbiAgICAnQ0lSQ0xFJyxcbiAgICAnQ0lTQ08nLFxuICAgICdDSVRBREVMJyxcbiAgICAnQ0lUSScsXG4gICAgJ0NJVElDJyxcbiAgICAnQ0lUWScsXG4gICAgJ0NJVFlFQVRTJyxcbiAgICAnQ0snLFxuICAgICdDTCcsXG4gICAgJ0NMQUlNUycsXG4gICAgJ0NMRUFOSU5HJyxcbiAgICAnQ0xJQ0snLFxuICAgICdDTElOSUMnLFxuICAgICdDTElOSVFVRScsXG4gICAgJ0NMT1RISU5HJyxcbiAgICAnQ0xPVUQnLFxuICAgICdDTFVCJyxcbiAgICAnQ0xVQk1FRCcsXG4gICAgJ0NNJyxcbiAgICAnQ04nLFxuICAgICdDTycsXG4gICAgJ0NPQUNIJyxcbiAgICAnQ09ERVMnLFxuICAgICdDT0ZGRUUnLFxuICAgICdDT0xMRUdFJyxcbiAgICAnQ09MT0dORScsXG4gICAgJ0NPTScsXG4gICAgJ0NPTUNBU1QnLFxuICAgICdDT01NQkFOSycsXG4gICAgJ0NPTU1VTklUWScsXG4gICAgJ0NPTVBBTlknLFxuICAgICdDT01QQVJFJyxcbiAgICAnQ09NUFVURVInLFxuICAgICdDT01TRUMnLFxuICAgICdDT05ET1MnLFxuICAgICdDT05TVFJVQ1RJT04nLFxuICAgICdDT05TVUxUSU5HJyxcbiAgICAnQ09OVEFDVCcsXG4gICAgJ0NPTlRSQUNUT1JTJyxcbiAgICAnQ09PS0lORycsXG4gICAgJ0NPT0tJTkdDSEFOTkVMJyxcbiAgICAnQ09PTCcsXG4gICAgJ0NPT1AnLFxuICAgICdDT1JTSUNBJyxcbiAgICAnQ09VTlRSWScsXG4gICAgJ0NPVVBPTicsXG4gICAgJ0NPVVBPTlMnLFxuICAgICdDT1VSU0VTJyxcbiAgICAnQ1InLFxuICAgICdDUkVESVQnLFxuICAgICdDUkVESVRDQVJEJyxcbiAgICAnQ1JFRElUVU5JT04nLFxuICAgICdDUklDS0VUJyxcbiAgICAnQ1JPV04nLFxuICAgICdDUlMnLFxuICAgICdDUlVJU0UnLFxuICAgICdDUlVJU0VTJyxcbiAgICAnQ1NDJyxcbiAgICAnQ1UnLFxuICAgICdDVUlTSU5FTExBJyxcbiAgICAnQ1YnLFxuICAgICdDVycsXG4gICAgJ0NYJyxcbiAgICAnQ1knLFxuICAgICdDWU1SVScsXG4gICAgJ0NZT1UnLFxuICAgICdDWicsXG4gICAgJ0RBQlVSJyxcbiAgICAnREFEJyxcbiAgICAnREFOQ0UnLFxuICAgICdEQVRBJyxcbiAgICAnREFURScsXG4gICAgJ0RBVElORycsXG4gICAgJ0RBVFNVTicsXG4gICAgJ0RBWScsXG4gICAgJ0RDTEsnLFxuICAgICdERFMnLFxuICAgICdERScsXG4gICAgJ0RFQUwnLFxuICAgICdERUFMRVInLFxuICAgICdERUFMUycsXG4gICAgJ0RFR1JFRScsXG4gICAgJ0RFTElWRVJZJyxcbiAgICAnREVMTCcsXG4gICAgJ0RFTE9JVFRFJyxcbiAgICAnREVMVEEnLFxuICAgICdERU1PQ1JBVCcsXG4gICAgJ0RFTlRBTCcsXG4gICAgJ0RFTlRJU1QnLFxuICAgICdERVNJJyxcbiAgICAnREVTSUdOJyxcbiAgICAnREVWJyxcbiAgICAnREhMJyxcbiAgICAnRElBTU9ORFMnLFxuICAgICdESUVUJyxcbiAgICAnRElHSVRBTCcsXG4gICAgJ0RJUkVDVCcsXG4gICAgJ0RJUkVDVE9SWScsXG4gICAgJ0RJU0NPVU5UJyxcbiAgICAnRElTQ09WRVInLFxuICAgICdESVNIJyxcbiAgICAnRElZJyxcbiAgICAnREonLFxuICAgICdESycsXG4gICAgJ0RNJyxcbiAgICAnRE5QJyxcbiAgICAnRE8nLFxuICAgICdET0NTJyxcbiAgICAnRE9DVE9SJyxcbiAgICAnRE9ER0UnLFxuICAgICdET0cnLFxuICAgICdET01BSU5TJyxcbiAgICAnRE9UJyxcbiAgICAnRE9XTkxPQUQnLFxuICAgICdEUklWRScsXG4gICAgJ0RUVicsXG4gICAgJ0RVQkFJJyxcbiAgICAnRFVDSycsXG4gICAgJ0RVTkxPUCcsXG4gICAgJ0RVUE9OVCcsXG4gICAgJ0RVUkJBTicsXG4gICAgJ0RWQUcnLFxuICAgICdEVlInLFxuICAgICdEWicsXG4gICAgJ0VBUlRIJyxcbiAgICAnRUFUJyxcbiAgICAnRUMnLFxuICAgICdFQ08nLFxuICAgICdFREVLQScsXG4gICAgJ0VEVScsXG4gICAgJ0VEVUNBVElPTicsXG4gICAgJ0VFJyxcbiAgICAnRUcnLFxuICAgICdFTUFJTCcsXG4gICAgJ0VNRVJDSycsXG4gICAgJ0VORVJHWScsXG4gICAgJ0VOR0lORUVSJyxcbiAgICAnRU5HSU5FRVJJTkcnLFxuICAgICdFTlRFUlBSSVNFUycsXG4gICAgJ0VQU09OJyxcbiAgICAnRVFVSVBNRU5UJyxcbiAgICAnRVInLFxuICAgICdFUklDU1NPTicsXG4gICAgJ0VSTkknLFxuICAgICdFUycsXG4gICAgJ0VTUScsXG4gICAgJ0VTVEFURScsXG4gICAgJ0VTVVJBTkNFJyxcbiAgICAnRVQnLFxuICAgICdFVElTQUxBVCcsXG4gICAgJ0VVJyxcbiAgICAnRVVST1ZJU0lPTicsXG4gICAgJ0VVUycsXG4gICAgJ0VWRU5UUycsXG4gICAgJ0VWRVJCQU5LJyxcbiAgICAnRVhDSEFOR0UnLFxuICAgICdFWFBFUlQnLFxuICAgICdFWFBPU0VEJyxcbiAgICAnRVhQUkVTUycsXG4gICAgJ0VYVFJBU1BBQ0UnLFxuICAgICdGQUdFJyxcbiAgICAnRkFJTCcsXG4gICAgJ0ZBSVJXSU5EUycsXG4gICAgJ0ZBSVRIJyxcbiAgICAnRkFNSUxZJyxcbiAgICAnRkFOJyxcbiAgICAnRkFOUycsXG4gICAgJ0ZBUk0nLFxuICAgICdGQVJNRVJTJyxcbiAgICAnRkFTSElPTicsXG4gICAgJ0ZBU1QnLFxuICAgICdGRURFWCcsXG4gICAgJ0ZFRURCQUNLJyxcbiAgICAnRkVSUkFSSScsXG4gICAgJ0ZFUlJFUk8nLFxuICAgICdGSScsXG4gICAgJ0ZJQVQnLFxuICAgICdGSURFTElUWScsXG4gICAgJ0ZJRE8nLFxuICAgICdGSUxNJyxcbiAgICAnRklOQUwnLFxuICAgICdGSU5BTkNFJyxcbiAgICAnRklOQU5DSUFMJyxcbiAgICAnRklSRScsXG4gICAgJ0ZJUkVTVE9ORScsXG4gICAgJ0ZJUk1EQUxFJyxcbiAgICAnRklTSCcsXG4gICAgJ0ZJU0hJTkcnLFxuICAgICdGSVQnLFxuICAgICdGSVRORVNTJyxcbiAgICAnRkonLFxuICAgICdGSycsXG4gICAgJ0ZMSUNLUicsXG4gICAgJ0ZMSUdIVFMnLFxuICAgICdGTElSJyxcbiAgICAnRkxPUklTVCcsXG4gICAgJ0ZMT1dFUlMnLFxuICAgICdGTFknLFxuICAgICdGTScsXG4gICAgJ0ZPJyxcbiAgICAnRk9PJyxcbiAgICAnRk9PRCcsXG4gICAgJ0ZPT0RORVRXT1JLJyxcbiAgICAnRk9PVEJBTEwnLFxuICAgICdGT1JEJyxcbiAgICAnRk9SRVgnLFxuICAgICdGT1JTQUxFJyxcbiAgICAnRk9SVU0nLFxuICAgICdGT1VOREFUSU9OJyxcbiAgICAnRk9YJyxcbiAgICAnRlInLFxuICAgICdGUkVFJyxcbiAgICAnRlJFU0VOSVVTJyxcbiAgICAnRlJMJyxcbiAgICAnRlJPR0FOUycsXG4gICAgJ0ZST05URE9PUicsXG4gICAgJ0ZST05USUVSJyxcbiAgICAnRlRSJyxcbiAgICAnRlVKSVRTVScsXG4gICAgJ0ZVSklYRVJPWCcsXG4gICAgJ0ZVTicsXG4gICAgJ0ZVTkQnLFxuICAgICdGVVJOSVRVUkUnLFxuICAgICdGVVRCT0wnLFxuICAgICdGWUknLFxuICAgICdHQScsXG4gICAgJ0dBTCcsXG4gICAgJ0dBTExFUlknLFxuICAgICdHQUxMTycsXG4gICAgJ0dBTExVUCcsXG4gICAgJ0dBTUUnLFxuICAgICdHQU1FUycsXG4gICAgJ0dBUCcsXG4gICAgJ0dBUkRFTicsXG4gICAgJ0dBWScsXG4gICAgJ0dCJyxcbiAgICAnR0JJWicsXG4gICAgJ0dEJyxcbiAgICAnR0ROJyxcbiAgICAnR0UnLFxuICAgICdHRUEnLFxuICAgICdHRU5UJyxcbiAgICAnR0VOVElORycsXG4gICAgJ0dFT1JHRScsXG4gICAgJ0dGJyxcbiAgICAnR0cnLFxuICAgICdHR0VFJyxcbiAgICAnR0gnLFxuICAgICdHSScsXG4gICAgJ0dJRlQnLFxuICAgICdHSUZUUycsXG4gICAgJ0dJVkVTJyxcbiAgICAnR0lWSU5HJyxcbiAgICAnR0wnLFxuICAgICdHTEFERScsXG4gICAgJ0dMQVNTJyxcbiAgICAnR0xFJyxcbiAgICAnR0xPQkFMJyxcbiAgICAnR0xPQk8nLFxuICAgICdHTScsXG4gICAgJ0dNQUlMJyxcbiAgICAnR01CSCcsXG4gICAgJ0dNTycsXG4gICAgJ0dNWCcsXG4gICAgJ0dOJyxcbiAgICAnR09EQUREWScsXG4gICAgJ0dPTEQnLFxuICAgICdHT0xEUE9JTlQnLFxuICAgICdHT0xGJyxcbiAgICAnR09PJyxcbiAgICAnR09PRFlFQVInLFxuICAgICdHT09HJyxcbiAgICAnR09PR0xFJyxcbiAgICAnR09QJyxcbiAgICAnR09UJyxcbiAgICAnR09WJyxcbiAgICAnR1AnLFxuICAgICdHUScsXG4gICAgJ0dSJyxcbiAgICAnR1JBSU5HRVInLFxuICAgICdHUkFQSElDUycsXG4gICAgJ0dSQVRJUycsXG4gICAgJ0dSRUVOJyxcbiAgICAnR1JJUEUnLFxuICAgICdHUk9DRVJZJyxcbiAgICAnR1JPVVAnLFxuICAgICdHUycsXG4gICAgJ0dUJyxcbiAgICAnR1UnLFxuICAgICdHVUFSRElBTicsXG4gICAgJ0dVQ0NJJyxcbiAgICAnR1VHRScsXG4gICAgJ0dVSURFJyxcbiAgICAnR1VJVEFSUycsXG4gICAgJ0dVUlUnLFxuICAgICdHVycsXG4gICAgJ0dZJyxcbiAgICAnSEFJUicsXG4gICAgJ0hBTUJVUkcnLFxuICAgICdIQU5HT1VUJyxcbiAgICAnSEFVUycsXG4gICAgJ0hCTycsXG4gICAgJ0hERkMnLFxuICAgICdIREZDQkFOSycsXG4gICAgJ0hFQUxUSCcsXG4gICAgJ0hFQUxUSENBUkUnLFxuICAgICdIRUxQJyxcbiAgICAnSEVMU0lOS0knLFxuICAgICdIRVJFJyxcbiAgICAnSEVSTUVTJyxcbiAgICAnSEdUVicsXG4gICAgJ0hJUEhPUCcsXG4gICAgJ0hJU0FNSVRTVScsXG4gICAgJ0hJVEFDSEknLFxuICAgICdISVYnLFxuICAgICdISycsXG4gICAgJ0hLVCcsXG4gICAgJ0hNJyxcbiAgICAnSE4nLFxuICAgICdIT0NLRVknLFxuICAgICdIT0xESU5HUycsXG4gICAgJ0hPTElEQVknLFxuICAgICdIT01FREVQT1QnLFxuICAgICdIT01FR09PRFMnLFxuICAgICdIT01FUycsXG4gICAgJ0hPTUVTRU5TRScsXG4gICAgJ0hPTkRBJyxcbiAgICAnSE9SU0UnLFxuICAgICdIT1NQSVRBTCcsXG4gICAgJ0hPU1QnLFxuICAgICdIT1NUSU5HJyxcbiAgICAnSE9UJyxcbiAgICAnSE9URUxFUycsXG4gICAgJ0hPVEVMUycsXG4gICAgJ0hPVE1BSUwnLFxuICAgICdIT1VTRScsXG4gICAgJ0hPVycsXG4gICAgJ0hSJyxcbiAgICAnSFNCQycsXG4gICAgJ0hUJyxcbiAgICAnSFUnLFxuICAgICdIVUdIRVMnLFxuICAgICdIWUFUVCcsXG4gICAgJ0hZVU5EQUknLFxuICAgICdJQk0nLFxuICAgICdJQ0JDJyxcbiAgICAnSUNFJyxcbiAgICAnSUNVJyxcbiAgICAnSUQnLFxuICAgICdJRScsXG4gICAgJ0lFRUUnLFxuICAgICdJRk0nLFxuICAgICdJS0FOTycsXG4gICAgJ0lMJyxcbiAgICAnSU0nLFxuICAgICdJTUFNQVQnLFxuICAgICdJTURCJyxcbiAgICAnSU1NTycsXG4gICAgJ0lNTU9CSUxJRU4nLFxuICAgICdJTicsXG4gICAgJ0lOQycsXG4gICAgJ0lORFVTVFJJRVMnLFxuICAgICdJTkZJTklUSScsXG4gICAgJ0lORk8nLFxuICAgICdJTkcnLFxuICAgICdJTksnLFxuICAgICdJTlNUSVRVVEUnLFxuICAgICdJTlNVUkFOQ0UnLFxuICAgICdJTlNVUkUnLFxuICAgICdJTlQnLFxuICAgICdJTlRFTCcsXG4gICAgJ0lOVEVSTkFUSU9OQUwnLFxuICAgICdJTlRVSVQnLFxuICAgICdJTlZFU1RNRU5UUycsXG4gICAgJ0lPJyxcbiAgICAnSVBJUkFOR0EnLFxuICAgICdJUScsXG4gICAgJ0lSJyxcbiAgICAnSVJJU0gnLFxuICAgICdJUycsXG4gICAgJ0lTTUFJTEknLFxuICAgICdJU1QnLFxuICAgICdJU1RBTkJVTCcsXG4gICAgJ0lUJyxcbiAgICAnSVRBVScsXG4gICAgJ0lUVicsXG4gICAgJ0lWRUNPJyxcbiAgICAnSkFHVUFSJyxcbiAgICAnSkFWQScsXG4gICAgJ0pDQicsXG4gICAgJ0pDUCcsXG4gICAgJ0pFJyxcbiAgICAnSkVFUCcsXG4gICAgJ0pFVFpUJyxcbiAgICAnSkVXRUxSWScsXG4gICAgJ0pJTycsXG4gICAgJ0pMTCcsXG4gICAgJ0pNJyxcbiAgICAnSk1QJyxcbiAgICAnSk5KJyxcbiAgICAnSk8nLFxuICAgICdKT0JTJyxcbiAgICAnSk9CVVJHJyxcbiAgICAnSk9UJyxcbiAgICAnSk9ZJyxcbiAgICAnSlAnLFxuICAgICdKUE1PUkdBTicsXG4gICAgJ0pQUlMnLFxuICAgICdKVUVHT1MnLFxuICAgICdKVU5JUEVSJyxcbiAgICAnS0FVRkVOJyxcbiAgICAnS0RESScsXG4gICAgJ0tFJyxcbiAgICAnS0VSUllIT1RFTFMnLFxuICAgICdLRVJSWUxPR0lTVElDUycsXG4gICAgJ0tFUlJZUFJPUEVSVElFUycsXG4gICAgJ0tGSCcsXG4gICAgJ0tHJyxcbiAgICAnS0gnLFxuICAgICdLSScsXG4gICAgJ0tJQScsXG4gICAgJ0tJTScsXG4gICAgJ0tJTkRFUicsXG4gICAgJ0tJTkRMRScsXG4gICAgJ0tJVENIRU4nLFxuICAgICdLSVdJJyxcbiAgICAnS00nLFxuICAgICdLTicsXG4gICAgJ0tPRUxOJyxcbiAgICAnS09NQVRTVScsXG4gICAgJ0tPU0hFUicsXG4gICAgJ0tQJyxcbiAgICAnS1BNRycsXG4gICAgJ0tQTicsXG4gICAgJ0tSJyxcbiAgICAnS1JEJyxcbiAgICAnS1JFRCcsXG4gICAgJ0tVT0tHUk9VUCcsXG4gICAgJ0tXJyxcbiAgICAnS1knLFxuICAgICdLWU9UTycsXG4gICAgJ0taJyxcbiAgICAnTEEnLFxuICAgICdMQUNBSVhBJyxcbiAgICAnTEFEQlJPS0VTJyxcbiAgICAnTEFNQk9SR0hJTkknLFxuICAgICdMQU1FUicsXG4gICAgJ0xBTkNBU1RFUicsXG4gICAgJ0xBTkNJQScsXG4gICAgJ0xBTkNPTUUnLFxuICAgICdMQU5EJyxcbiAgICAnTEFORFJPVkVSJyxcbiAgICAnTEFOWEVTUycsXG4gICAgJ0xBU0FMTEUnLFxuICAgICdMQVQnLFxuICAgICdMQVRJTk8nLFxuICAgICdMQVRST0JFJyxcbiAgICAnTEFXJyxcbiAgICAnTEFXWUVSJyxcbiAgICAnTEInLFxuICAgICdMQycsXG4gICAgJ0xEUycsXG4gICAgJ0xFQVNFJyxcbiAgICAnTEVDTEVSQycsXG4gICAgJ0xFRlJBSycsXG4gICAgJ0xFR0FMJyxcbiAgICAnTEVHTycsXG4gICAgJ0xFWFVTJyxcbiAgICAnTEdCVCcsXG4gICAgJ0xJJyxcbiAgICAnTElBSVNPTicsXG4gICAgJ0xJREwnLFxuICAgICdMSUZFJyxcbiAgICAnTElGRUlOU1VSQU5DRScsXG4gICAgJ0xJRkVTVFlMRScsXG4gICAgJ0xJR0hUSU5HJyxcbiAgICAnTElLRScsXG4gICAgJ0xJTExZJyxcbiAgICAnTElNSVRFRCcsXG4gICAgJ0xJTU8nLFxuICAgICdMSU5DT0xOJyxcbiAgICAnTElOREUnLFxuICAgICdMSU5LJyxcbiAgICAnTElQU1knLFxuICAgICdMSVZFJyxcbiAgICAnTElWSU5HJyxcbiAgICAnTElYSUwnLFxuICAgICdMSycsXG4gICAgJ0xMQycsXG4gICAgJ0xPQU4nLFxuICAgICdMT0FOUycsXG4gICAgJ0xPQ0tFUicsXG4gICAgJ0xPQ1VTJyxcbiAgICAnTE9GVCcsXG4gICAgJ0xPTCcsXG4gICAgJ0xPTkRPTicsXG4gICAgJ0xPVFRFJyxcbiAgICAnTE9UVE8nLFxuICAgICdMT1ZFJyxcbiAgICAnTFBMJyxcbiAgICAnTFBMRklOQU5DSUFMJyxcbiAgICAnTFInLFxuICAgICdMUycsXG4gICAgJ0xUJyxcbiAgICAnTFREJyxcbiAgICAnTFREQScsXG4gICAgJ0xVJyxcbiAgICAnTFVOREJFQ0snLFxuICAgICdMVVBJTicsXG4gICAgJ0xVWEUnLFxuICAgICdMVVhVUlknLFxuICAgICdMVicsXG4gICAgJ0xZJyxcbiAgICAnTUEnLFxuICAgICdNQUNZUycsXG4gICAgJ01BRFJJRCcsXG4gICAgJ01BSUYnLFxuICAgICdNQUlTT04nLFxuICAgICdNQUtFVVAnLFxuICAgICdNQU4nLFxuICAgICdNQU5BR0VNRU5UJyxcbiAgICAnTUFOR08nLFxuICAgICdNQVAnLFxuICAgICdNQVJLRVQnLFxuICAgICdNQVJLRVRJTkcnLFxuICAgICdNQVJLRVRTJyxcbiAgICAnTUFSUklPVFQnLFxuICAgICdNQVJTSEFMTFMnLFxuICAgICdNQVNFUkFUSScsXG4gICAgJ01BVFRFTCcsXG4gICAgJ01CQScsXG4gICAgJ01DJyxcbiAgICAnTUNLSU5TRVknLFxuICAgICdNRCcsXG4gICAgJ01FJyxcbiAgICAnTUVEJyxcbiAgICAnTUVESUEnLFxuICAgICdNRUVUJyxcbiAgICAnTUVMQk9VUk5FJyxcbiAgICAnTUVNRScsXG4gICAgJ01FTU9SSUFMJyxcbiAgICAnTUVOJyxcbiAgICAnTUVOVScsXG4gICAgJ01FUkNLTVNEJyxcbiAgICAnTUVUTElGRScsXG4gICAgJ01HJyxcbiAgICAnTUgnLFxuICAgICdNSUFNSScsXG4gICAgJ01JQ1JPU09GVCcsXG4gICAgJ01JTCcsXG4gICAgJ01JTkknLFxuICAgICdNSU5UJyxcbiAgICAnTUlUJyxcbiAgICAnTUlUU1VCSVNISScsXG4gICAgJ01LJyxcbiAgICAnTUwnLFxuICAgICdNTEInLFxuICAgICdNTFMnLFxuICAgICdNTScsXG4gICAgJ01NQScsXG4gICAgJ01OJyxcbiAgICAnTU8nLFxuICAgICdNT0JJJyxcbiAgICAnTU9CSUxFJyxcbiAgICAnTU9EQScsXG4gICAgJ01PRScsXG4gICAgJ01PSScsXG4gICAgJ01PTScsXG4gICAgJ01PTkFTSCcsXG4gICAgJ01PTkVZJyxcbiAgICAnTU9OU1RFUicsXG4gICAgJ01PUEFSJyxcbiAgICAnTU9STU9OJyxcbiAgICAnTU9SVEdBR0UnLFxuICAgICdNT1NDT1cnLFxuICAgICdNT1RPJyxcbiAgICAnTU9UT1JDWUNMRVMnLFxuICAgICdNT1YnLFxuICAgICdNT1ZJRScsXG4gICAgJ01PVklTVEFSJyxcbiAgICAnTVAnLFxuICAgICdNUScsXG4gICAgJ01SJyxcbiAgICAnTVMnLFxuICAgICdNU0QnLFxuICAgICdNVCcsXG4gICAgJ01UTicsXG4gICAgJ01UUicsXG4gICAgJ01VJyxcbiAgICAnTVVTRVVNJyxcbiAgICAnTVVUVUFMJyxcbiAgICAnTVYnLFxuICAgICdNVycsXG4gICAgJ01YJyxcbiAgICAnTVknLFxuICAgICdNWicsXG4gICAgJ05BJyxcbiAgICAnTkFCJyxcbiAgICAnTkFERVgnLFxuICAgICdOQUdPWUEnLFxuICAgICdOQU1FJyxcbiAgICAnTkFUSU9OV0lERScsXG4gICAgJ05BVFVSQScsXG4gICAgJ05BVlknLFxuICAgICdOQkEnLFxuICAgICdOQycsXG4gICAgJ05FJyxcbiAgICAnTkVDJyxcbiAgICAnTkVUJyxcbiAgICAnTkVUQkFOSycsXG4gICAgJ05FVEZMSVgnLFxuICAgICdORVRXT1JLJyxcbiAgICAnTkVVU1RBUicsXG4gICAgJ05FVycsXG4gICAgJ05FV0hPTExBTkQnLFxuICAgICdORVdTJyxcbiAgICAnTkVYVCcsXG4gICAgJ05FWFRESVJFQ1QnLFxuICAgICdORVhVUycsXG4gICAgJ05GJyxcbiAgICAnTkZMJyxcbiAgICAnTkcnLFxuICAgICdOR08nLFxuICAgICdOSEsnLFxuICAgICdOSScsXG4gICAgJ05JQ08nLFxuICAgICdOSUtFJyxcbiAgICAnTklLT04nLFxuICAgICdOSU5KQScsXG4gICAgJ05JU1NBTicsXG4gICAgJ05JU1NBWScsXG4gICAgJ05MJyxcbiAgICAnTk8nLFxuICAgICdOT0tJQScsXG4gICAgJ05PUlRIV0VTVEVSTk1VVFVBTCcsXG4gICAgJ05PUlRPTicsXG4gICAgJ05PVycsXG4gICAgJ05PV1JVWicsXG4gICAgJ05PV1RWJyxcbiAgICAnTlAnLFxuICAgICdOUicsXG4gICAgJ05SQScsXG4gICAgJ05SVycsXG4gICAgJ05UVCcsXG4gICAgJ05VJyxcbiAgICAnTllDJyxcbiAgICAnTlonLFxuICAgICdPQkknLFxuICAgICdPQlNFUlZFUicsXG4gICAgJ09GRicsXG4gICAgJ09GRklDRScsXG4gICAgJ09LSU5BV0EnLFxuICAgICdPTEFZQU4nLFxuICAgICdPTEFZQU5HUk9VUCcsXG4gICAgJ09MRE5BVlknLFxuICAgICdPTExPJyxcbiAgICAnT00nLFxuICAgICdPTUVHQScsXG4gICAgJ09ORScsXG4gICAgJ09ORycsXG4gICAgJ09OTCcsXG4gICAgJ09OTElORScsXG4gICAgJ09OWU9VUlNJREUnLFxuICAgICdPT08nLFxuICAgICdPUEVOJyxcbiAgICAnT1JBQ0xFJyxcbiAgICAnT1JBTkdFJyxcbiAgICAnT1JHJyxcbiAgICAnT1JHQU5JQycsXG4gICAgJ09SSUdJTlMnLFxuICAgICdPU0FLQScsXG4gICAgJ09UU1VLQScsXG4gICAgJ09UVCcsXG4gICAgJ09WSCcsXG4gICAgJ1BBJyxcbiAgICAnUEFHRScsXG4gICAgJ1BBTkFTT05JQycsXG4gICAgJ1BBUklTJyxcbiAgICAnUEFSUycsXG4gICAgJ1BBUlRORVJTJyxcbiAgICAnUEFSVFMnLFxuICAgICdQQVJUWScsXG4gICAgJ1BBU1NBR0VOUycsXG4gICAgJ1BBWScsXG4gICAgJ1BDQ1cnLFxuICAgICdQRScsXG4gICAgJ1BFVCcsXG4gICAgJ1BGJyxcbiAgICAnUEZJWkVSJyxcbiAgICAnUEcnLFxuICAgICdQSCcsXG4gICAgJ1BIQVJNQUNZJyxcbiAgICAnUEhEJyxcbiAgICAnUEhJTElQUycsXG4gICAgJ1BIT05FJyxcbiAgICAnUEhPVE8nLFxuICAgICdQSE9UT0dSQVBIWScsXG4gICAgJ1BIT1RPUycsXG4gICAgJ1BIWVNJTycsXG4gICAgJ1BJQUdFVCcsXG4gICAgJ1BJQ1MnLFxuICAgICdQSUNURVQnLFxuICAgICdQSUNUVVJFUycsXG4gICAgJ1BJRCcsXG4gICAgJ1BJTicsXG4gICAgJ1BJTkcnLFxuICAgICdQSU5LJyxcbiAgICAnUElPTkVFUicsXG4gICAgJ1BJWlpBJyxcbiAgICAnUEsnLFxuICAgICdQTCcsXG4gICAgJ1BMQUNFJyxcbiAgICAnUExBWScsXG4gICAgJ1BMQVlTVEFUSU9OJyxcbiAgICAnUExVTUJJTkcnLFxuICAgICdQTFVTJyxcbiAgICAnUE0nLFxuICAgICdQTicsXG4gICAgJ1BOQycsXG4gICAgJ1BPSEwnLFxuICAgICdQT0tFUicsXG4gICAgJ1BPTElUSUUnLFxuICAgICdQT1JOJyxcbiAgICAnUE9TVCcsXG4gICAgJ1BSJyxcbiAgICAnUFJBTUVSSUNBJyxcbiAgICAnUFJBWEknLFxuICAgICdQUkVTUycsXG4gICAgJ1BSSU1FJyxcbiAgICAnUFJPJyxcbiAgICAnUFJPRCcsXG4gICAgJ1BST0RVQ1RJT05TJyxcbiAgICAnUFJPRicsXG4gICAgJ1BST0dSRVNTSVZFJyxcbiAgICAnUFJPTU8nLFxuICAgICdQUk9QRVJUSUVTJyxcbiAgICAnUFJPUEVSVFknLFxuICAgICdQUk9URUNUSU9OJyxcbiAgICAnUFJVJyxcbiAgICAnUFJVREVOVElBTCcsXG4gICAgJ1BTJyxcbiAgICAnUFQnLFxuICAgICdQVUInLFxuICAgICdQVycsXG4gICAgJ1BXQycsXG4gICAgJ1BZJyxcbiAgICAnUUEnLFxuICAgICdRUE9OJyxcbiAgICAnUVVFQkVDJyxcbiAgICAnUVVFU1QnLFxuICAgICdRVkMnLFxuICAgICdSQUNJTkcnLFxuICAgICdSQURJTycsXG4gICAgJ1JBSUQnLFxuICAgICdSRScsXG4gICAgJ1JFQUQnLFxuICAgICdSRUFMRVNUQVRFJyxcbiAgICAnUkVBTFRPUicsXG4gICAgJ1JFQUxUWScsXG4gICAgJ1JFQ0lQRVMnLFxuICAgICdSRUQnLFxuICAgICdSRURTVE9ORScsXG4gICAgJ1JFRFVNQlJFTExBJyxcbiAgICAnUkVIQUInLFxuICAgICdSRUlTRScsXG4gICAgJ1JFSVNFTicsXG4gICAgJ1JFSVQnLFxuICAgICdSRUxJQU5DRScsXG4gICAgJ1JFTicsXG4gICAgJ1JFTlQnLFxuICAgICdSRU5UQUxTJyxcbiAgICAnUkVQQUlSJyxcbiAgICAnUkVQT1JUJyxcbiAgICAnUkVQVUJMSUNBTicsXG4gICAgJ1JFU1QnLFxuICAgICdSRVNUQVVSQU5UJyxcbiAgICAnUkVWSUVXJyxcbiAgICAnUkVWSUVXUycsXG4gICAgJ1JFWFJPVEgnLFxuICAgICdSSUNIJyxcbiAgICAnUklDSEFSRExJJyxcbiAgICAnUklDT0gnLFxuICAgICdSSUdIVEFUSE9NRScsXG4gICAgJ1JJTCcsXG4gICAgJ1JJTycsXG4gICAgJ1JJUCcsXG4gICAgJ1JNSVQnLFxuICAgICdSTycsXG4gICAgJ1JPQ0hFUicsXG4gICAgJ1JPQ0tTJyxcbiAgICAnUk9ERU8nLFxuICAgICdST0dFUlMnLFxuICAgICdST09NJyxcbiAgICAnUlMnLFxuICAgICdSU1ZQJyxcbiAgICAnUlUnLFxuICAgICdSVUdCWScsXG4gICAgJ1JVSFInLFxuICAgICdSVU4nLFxuICAgICdSVycsXG4gICAgJ1JXRScsXG4gICAgJ1JZVUtZVScsXG4gICAgJ1NBJyxcbiAgICAnU0FBUkxBTkQnLFxuICAgICdTQUZFJyxcbiAgICAnU0FGRVRZJyxcbiAgICAnU0FLVVJBJyxcbiAgICAnU0FMRScsXG4gICAgJ1NBTE9OJyxcbiAgICAnU0FNU0NMVUInLFxuICAgICdTQU1TVU5HJyxcbiAgICAnU0FORFZJSycsXG4gICAgJ1NBTkRWSUtDT1JPTUFOVCcsXG4gICAgJ1NBTk9GSScsXG4gICAgJ1NBUCcsXG4gICAgJ1NBUkwnLFxuICAgICdTQVMnLFxuICAgICdTQVZFJyxcbiAgICAnU0FYTycsXG4gICAgJ1NCJyxcbiAgICAnU0JJJyxcbiAgICAnU0JTJyxcbiAgICAnU0MnLFxuICAgICdTQ0EnLFxuICAgICdTQ0InLFxuICAgICdTQ0hBRUZGTEVSJyxcbiAgICAnU0NITUlEVCcsXG4gICAgJ1NDSE9MQVJTSElQUycsXG4gICAgJ1NDSE9PTCcsXG4gICAgJ1NDSFVMRScsXG4gICAgJ1NDSFdBUlonLFxuICAgICdTQ0lFTkNFJyxcbiAgICAnU0NKT0hOU09OJyxcbiAgICAnU0NPUicsXG4gICAgJ1NDT1QnLFxuICAgICdTRCcsXG4gICAgJ1NFJyxcbiAgICAnU0VBUkNIJyxcbiAgICAnU0VBVCcsXG4gICAgJ1NFQ1VSRScsXG4gICAgJ1NFQ1VSSVRZJyxcbiAgICAnU0VFSycsXG4gICAgJ1NFTEVDVCcsXG4gICAgJ1NFTkVSJyxcbiAgICAnU0VSVklDRVMnLFxuICAgICdTRVMnLFxuICAgICdTRVZFTicsXG4gICAgJ1NFVycsXG4gICAgJ1NFWCcsXG4gICAgJ1NFWFknLFxuICAgICdTRlInLFxuICAgICdTRycsXG4gICAgJ1NIJyxcbiAgICAnU0hBTkdSSUxBJyxcbiAgICAnU0hBUlAnLFxuICAgICdTSEFXJyxcbiAgICAnU0hFTEwnLFxuICAgICdTSElBJyxcbiAgICAnU0hJS1NIQScsXG4gICAgJ1NIT0VTJyxcbiAgICAnU0hPUCcsXG4gICAgJ1NIT1BQSU5HJyxcbiAgICAnU0hPVUpJJyxcbiAgICAnU0hPVycsXG4gICAgJ1NIT1dUSU1FJyxcbiAgICAnU0hSSVJBTScsXG4gICAgJ1NJJyxcbiAgICAnU0lMSycsXG4gICAgJ1NJTkEnLFxuICAgICdTSU5HTEVTJyxcbiAgICAnU0lURScsXG4gICAgJ1NKJyxcbiAgICAnU0snLFxuICAgICdTS0knLFxuICAgICdTS0lOJyxcbiAgICAnU0tZJyxcbiAgICAnU0tZUEUnLFxuICAgICdTTCcsXG4gICAgJ1NMSU5HJyxcbiAgICAnU00nLFxuICAgICdTTUFSVCcsXG4gICAgJ1NNSUxFJyxcbiAgICAnU04nLFxuICAgICdTTkNGJyxcbiAgICAnU08nLFxuICAgICdTT0NDRVInLFxuICAgICdTT0NJQUwnLFxuICAgICdTT0ZUQkFOSycsXG4gICAgJ1NPRlRXQVJFJyxcbiAgICAnU09IVScsXG4gICAgJ1NPTEFSJyxcbiAgICAnU09MVVRJT05TJyxcbiAgICAnU09ORycsXG4gICAgJ1NPTlknLFxuICAgICdTT1knLFxuICAgICdTUEFDRScsXG4gICAgJ1NQT1JUJyxcbiAgICAnU1BPVCcsXG4gICAgJ1NQUkVBREJFVFRJTkcnLFxuICAgICdTUicsXG4gICAgJ1NSTCcsXG4gICAgJ1NSVCcsXG4gICAgJ1NTJyxcbiAgICAnU1QnLFxuICAgICdTVEFEQScsXG4gICAgJ1NUQVBMRVMnLFxuICAgICdTVEFSJyxcbiAgICAnU1RBVEVCQU5LJyxcbiAgICAnU1RBVEVGQVJNJyxcbiAgICAnU1RDJyxcbiAgICAnU1RDR1JPVVAnLFxuICAgICdTVE9DS0hPTE0nLFxuICAgICdTVE9SQUdFJyxcbiAgICAnU1RPUkUnLFxuICAgICdTVFJFQU0nLFxuICAgICdTVFVESU8nLFxuICAgICdTVFVEWScsXG4gICAgJ1NUWUxFJyxcbiAgICAnU1UnLFxuICAgICdTVUNLUycsXG4gICAgJ1NVUFBMSUVTJyxcbiAgICAnU1VQUExZJyxcbiAgICAnU1VQUE9SVCcsXG4gICAgJ1NVUkYnLFxuICAgICdTVVJHRVJZJyxcbiAgICAnU1VaVUtJJyxcbiAgICAnU1YnLFxuICAgICdTV0FUQ0gnLFxuICAgICdTV0lGVENPVkVSJyxcbiAgICAnU1dJU1MnLFxuICAgICdTWCcsXG4gICAgJ1NZJyxcbiAgICAnU1lETkVZJyxcbiAgICAnU1lNQU5URUMnLFxuICAgICdTWVNURU1TJyxcbiAgICAnU1onLFxuICAgICdUQUInLFxuICAgICdUQUlQRUknLFxuICAgICdUQUxLJyxcbiAgICAnVEFPQkFPJyxcbiAgICAnVEFSR0VUJyxcbiAgICAnVEFUQU1PVE9SUycsXG4gICAgJ1RBVEFSJyxcbiAgICAnVEFUVE9PJyxcbiAgICAnVEFYJyxcbiAgICAnVEFYSScsXG4gICAgJ1RDJyxcbiAgICAnVENJJyxcbiAgICAnVEQnLFxuICAgICdUREsnLFxuICAgICdURUFNJyxcbiAgICAnVEVDSCcsXG4gICAgJ1RFQ0hOT0xPR1knLFxuICAgICdURUwnLFxuICAgICdURUxFRk9OSUNBJyxcbiAgICAnVEVNQVNFSycsXG4gICAgJ1RFTk5JUycsXG4gICAgJ1RFVkEnLFxuICAgICdURicsXG4gICAgJ1RHJyxcbiAgICAnVEgnLFxuICAgICdUSEQnLFxuICAgICdUSEVBVEVSJyxcbiAgICAnVEhFQVRSRScsXG4gICAgJ1RJQUEnLFxuICAgICdUSUNLRVRTJyxcbiAgICAnVElFTkRBJyxcbiAgICAnVElGRkFOWScsXG4gICAgJ1RJUFMnLFxuICAgICdUSVJFUycsXG4gICAgJ1RJUk9MJyxcbiAgICAnVEonLFxuICAgICdUSk1BWFgnLFxuICAgICdUSlgnLFxuICAgICdUSycsXG4gICAgJ1RLTUFYWCcsXG4gICAgJ1RMJyxcbiAgICAnVE0nLFxuICAgICdUTUFMTCcsXG4gICAgJ1ROJyxcbiAgICAnVE8nLFxuICAgICdUT0RBWScsXG4gICAgJ1RPS1lPJyxcbiAgICAnVE9PTFMnLFxuICAgICdUT1AnLFxuICAgICdUT1JBWScsXG4gICAgJ1RPU0hJQkEnLFxuICAgICdUT1RBTCcsXG4gICAgJ1RPVVJTJyxcbiAgICAnVE9XTicsXG4gICAgJ1RPWU9UQScsXG4gICAgJ1RPWVMnLFxuICAgICdUUicsXG4gICAgJ1RSQURFJyxcbiAgICAnVFJBRElORycsXG4gICAgJ1RSQUlOSU5HJyxcbiAgICAnVFJBVkVMJyxcbiAgICAnVFJBVkVMQ0hBTk5FTCcsXG4gICAgJ1RSQVZFTEVSUycsXG4gICAgJ1RSQVZFTEVSU0lOU1VSQU5DRScsXG4gICAgJ1RSVVNUJyxcbiAgICAnVFJWJyxcbiAgICAnVFQnLFxuICAgICdUVUJFJyxcbiAgICAnVFVJJyxcbiAgICAnVFVORVMnLFxuICAgICdUVVNIVScsXG4gICAgJ1RWJyxcbiAgICAnVFZTJyxcbiAgICAnVFcnLFxuICAgICdUWicsXG4gICAgJ1VBJyxcbiAgICAnVUJBTksnLFxuICAgICdVQlMnLFxuICAgICdVQ09OTkVDVCcsXG4gICAgJ1VHJyxcbiAgICAnVUsnLFxuICAgICdVTklDT00nLFxuICAgICdVTklWRVJTSVRZJyxcbiAgICAnVU5PJyxcbiAgICAnVU9MJyxcbiAgICAnVVBTJyxcbiAgICAnVVMnLFxuICAgICdVWScsXG4gICAgJ1VaJyxcbiAgICAnVkEnLFxuICAgICdWQUNBVElPTlMnLFxuICAgICdWQU5BJyxcbiAgICAnVkFOR1VBUkQnLFxuICAgICdWQycsXG4gICAgJ1ZFJyxcbiAgICAnVkVHQVMnLFxuICAgICdWRU5UVVJFUycsXG4gICAgJ1ZFUklTSUdOJyxcbiAgICAnVkVSU0lDSEVSVU5HJyxcbiAgICAnVkVUJyxcbiAgICAnVkcnLFxuICAgICdWSScsXG4gICAgJ1ZJQUpFUycsXG4gICAgJ1ZJREVPJyxcbiAgICAnVklHJyxcbiAgICAnVklLSU5HJyxcbiAgICAnVklMTEFTJyxcbiAgICAnVklOJyxcbiAgICAnVklQJyxcbiAgICAnVklSR0lOJyxcbiAgICAnVklTQScsXG4gICAgJ1ZJU0lPTicsXG4gICAgJ1ZJU1RBUFJJTlQnLFxuICAgICdWSVZBJyxcbiAgICAnVklWTycsXG4gICAgJ1ZMQUFOREVSRU4nLFxuICAgICdWTicsXG4gICAgJ1ZPREtBJyxcbiAgICAnVk9MS1NXQUdFTicsXG4gICAgJ1ZPTFZPJyxcbiAgICAnVk9URScsXG4gICAgJ1ZPVElORycsXG4gICAgJ1ZPVE8nLFxuICAgICdWT1lBR0UnLFxuICAgICdWVScsXG4gICAgJ1ZVRUxPUycsXG4gICAgJ1dBTEVTJyxcbiAgICAnV0FMTUFSVCcsXG4gICAgJ1dBTFRFUicsXG4gICAgJ1dBTkcnLFxuICAgICdXQU5HR09VJyxcbiAgICAnV0FSTUFOJyxcbiAgICAnV0FUQ0gnLFxuICAgICdXQVRDSEVTJyxcbiAgICAnV0VBVEhFUicsXG4gICAgJ1dFQVRIRVJDSEFOTkVMJyxcbiAgICAnV0VCQ0FNJyxcbiAgICAnV0VCRVInLFxuICAgICdXRUJTSVRFJyxcbiAgICAnV0VEJyxcbiAgICAnV0VERElORycsXG4gICAgJ1dFSUJPJyxcbiAgICAnV0VJUicsXG4gICAgJ1dGJyxcbiAgICAnV0hPU1dITycsXG4gICAgJ1dJRU4nLFxuICAgICdXSUtJJyxcbiAgICAnV0lMTElBTUhJTEwnLFxuICAgICdXSU4nLFxuICAgICdXSU5ET1dTJyxcbiAgICAnV0lORScsXG4gICAgJ1dJTk5FUlMnLFxuICAgICdXTUUnLFxuICAgICdXT0xURVJTS0xVV0VSJyxcbiAgICAnV09PRFNJREUnLFxuICAgICdXT1JLJyxcbiAgICAnV09SS1MnLFxuICAgICdXT1JMRCcsXG4gICAgJ1dPVycsXG4gICAgJ1dTJyxcbiAgICAnV1RDJyxcbiAgICAnV1RGJyxcbiAgICAnWEJPWCcsXG4gICAgJ1hFUk9YJyxcbiAgICAnWEZJTklUWScsXG4gICAgJ1hJSFVBTicsXG4gICAgJ1hJTicsXG4gICAgJ1hOLS0xMUI0QzNEJyxcbiAgICAnWE4tLTFDSzJFMUInLFxuICAgICdYTi0tMVFRVzIzQScsXG4gICAgJ1hOLS0yU0NSSjlDJyxcbiAgICAnWE4tLTMwUlI3WScsXG4gICAgJ1hOLS0zQlNUMDBNJyxcbiAgICAnWE4tLTNEUzQ0M0cnLFxuICAgICdYTi0tM0UwQjcwN0UnLFxuICAgICdYTi0tM0hDUko5QycsXG4gICAgJ1hOLS0zT1ExOFZMOFBOMzZBJyxcbiAgICAnWE4tLTNQWFU4SycsXG4gICAgJ1hOLS00MkMyRDlBJyxcbiAgICAnWE4tLTQ1QlI1Q1lMJyxcbiAgICAnWE4tLTQ1QlJKOUMnLFxuICAgICdYTi0tNDVRMTFDJyxcbiAgICAnWE4tLTRHQlJJTScsXG4gICAgJ1hOLS01NEI3RlRBMENDJyxcbiAgICAnWE4tLTU1UVc0MkcnLFxuICAgICdYTi0tNTVRWDVEJyxcbiAgICAnWE4tLTVTVTM0SjkzNkJHU0cnLFxuICAgICdYTi0tNVRaTTVHJyxcbiAgICAnWE4tLTZGUlo4MkcnLFxuICAgICdYTi0tNlFROTg2QjNYTCcsXG4gICAgJ1hOLS04MEFEWEhLUycsXG4gICAgJ1hOLS04MEFPMjFBJyxcbiAgICAnWE4tLTgwQVFFQ0RSMUEnLFxuICAgICdYTi0tODBBU0VIREInLFxuICAgICdYTi0tODBBU1dHJyxcbiAgICAnWE4tLThZMEEwNjNBJyxcbiAgICAnWE4tLTkwQTNBQycsXG4gICAgJ1hOLS05MEFFJyxcbiAgICAnWE4tLTkwQUlTJyxcbiAgICAnWE4tLTlEQlEyQScsXG4gICAgJ1hOLS05RVQ1MlUnLFxuICAgICdYTi0tOUtSVDAwQScsXG4gICAgJ1hOLS1CNFc2MDVGRVJEJyxcbiAgICAnWE4tLUJDSzFCOUE1RFJFNEMnLFxuICAgICdYTi0tQzFBVkcnLFxuICAgICdYTi0tQzJCUjdHJyxcbiAgICAnWE4tLUNDSzJCM0InLFxuICAgICdYTi0tQ0c0QktJJyxcbiAgICAnWE4tLUNMQ0hDMEVBMEIyRzJBOUdDRCcsXG4gICAgJ1hOLS1DWlI2OTRCJyxcbiAgICAnWE4tLUNaUlMwVCcsXG4gICAgJ1hOLS1DWlJVMkQnLFxuICAgICdYTi0tRDFBQ0ozQicsXG4gICAgJ1hOLS1EMUFMRicsXG4gICAgJ1hOLS1FMUE0QycsXG4gICAgJ1hOLS1FQ0tWRFRDOUQnLFxuICAgICdYTi0tRUZWWTg4SCcsXG4gICAgJ1hOLS1FU1RWNzVHJyxcbiAgICAnWE4tLUZDVDQyOUsnLFxuICAgICdYTi0tRkhCRUknLFxuICAgICdYTi0tRklRMjI4QzVIUycsXG4gICAgJ1hOLS1GSVE2NEInLFxuICAgICdYTi0tRklRUzhTJyxcbiAgICAnWE4tLUZJUVo5UycsXG4gICAgJ1hOLS1GSlE3MjBBJyxcbiAgICAnWE4tLUZMVzM1MUUnLFxuICAgICdYTi0tRlBDUko5QzNEJyxcbiAgICAnWE4tLUZaQzJDOUUyQycsXG4gICAgJ1hOLS1GWllTOEQ2OVVWR00nLFxuICAgICdYTi0tRzJYWDQ4QycsXG4gICAgJ1hOLS1HQ0tSM0YwRicsXG4gICAgJ1hOLS1HRUNSSjlDJyxcbiAgICAnWE4tLUdLM0FUMUUnLFxuICAgICdYTi0tSDJCUkVHM0VWRScsXG4gICAgJ1hOLS1IMkJSSjlDJyxcbiAgICAnWE4tLUgyQlJKOUM4QycsXG4gICAgJ1hOLS1IWFQ4MTRFJyxcbiAgICAnWE4tLUkxQjZCMUE2QTJFJyxcbiAgICAnWE4tLUlNUjUxM04nLFxuICAgICdYTi0tSU8wQTdJJyxcbiAgICAnWE4tLUoxQUVGJyxcbiAgICAnWE4tLUoxQU1IJyxcbiAgICAnWE4tLUo2VzE5M0cnLFxuICAgICdYTi0tSkxRNjFVOVc3QicsXG4gICAgJ1hOLS1KVlIxODlNJyxcbiAgICAnWE4tLUtDUlg3N0QxWDRBJyxcbiAgICAnWE4tLUtQUlcxM0QnLFxuICAgICdYTi0tS1BSWTU3RCcsXG4gICAgJ1hOLS1LUFU3MTZGJyxcbiAgICAnWE4tLUtQVVQzSScsXG4gICAgJ1hOLS1MMUFDQycsXG4gICAgJ1hOLS1MR0JCQVQxQUQ4SicsXG4gICAgJ1hOLS1NR0I5QVdCRicsXG4gICAgJ1hOLS1NR0JBM0EzRUpUJyxcbiAgICAnWE4tLU1HQkEzQTRGMTZBJyxcbiAgICAnWE4tLU1HQkE3QzBCQk4wQScsXG4gICAgJ1hOLS1NR0JBQUtDN0RWRicsXG4gICAgJ1hOLS1NR0JBQU03QThIJyxcbiAgICAnWE4tLU1HQkFCMkJEJyxcbiAgICAnWE4tLU1HQkFIMUEzSEpLUkQnLFxuICAgICdYTi0tTUdCQUk5QVpHUVA2SicsXG4gICAgJ1hOLS1NR0JBWUg3R1BBJyxcbiAgICAnWE4tLU1HQkJIMUEnLFxuICAgICdYTi0tTUdCQkgxQTcxRScsXG4gICAgJ1hOLS1NR0JDMEE5QVpDRycsXG4gICAgJ1hOLS1NR0JDQTdEWkRPJyxcbiAgICAnWE4tLU1HQkVSUDRBNUQ0QVInLFxuICAgICdYTi0tTUdCR1U4MkEnLFxuICAgICdYTi0tTUdCSTRFQ0VYUCcsXG4gICAgJ1hOLS1NR0JQTDJGSCcsXG4gICAgJ1hOLS1NR0JUM0RIRCcsXG4gICAgJ1hOLS1NR0JUWDJCJyxcbiAgICAnWE4tLU1HQlg0Q0QwQUInLFxuICAgICdYTi0tTUlYODkxRicsXG4gICAgJ1hOLS1NSzFCVTQ0QycsXG4gICAgJ1hOLS1NWFRRMU0nLFxuICAgICdYTi0tTkdCQzVBWkQnLFxuICAgICdYTi0tTkdCRTlFMEEnLFxuICAgICdYTi0tTkdCUlgnLFxuICAgICdYTi0tTk9ERScsXG4gICAgJ1hOLS1OUVY3RicsXG4gICAgJ1hOLS1OUVY3RlMwMEVNQScsXG4gICAgJ1hOLS1OWVFZMjZBJyxcbiAgICAnWE4tLU8zQ1c0SCcsXG4gICAgJ1hOLS1PR0JQRjhGTCcsXG4gICAgJ1hOLS1PVFU3OTZEJyxcbiAgICAnWE4tLVAxQUNGJyxcbiAgICAnWE4tLVAxQUknLFxuICAgICdYTi0tUEJUOTc3QycsXG4gICAgJ1hOLS1QR0JTMERIJyxcbiAgICAnWE4tLVBTU1kyVScsXG4gICAgJ1hOLS1ROUpZQjRDJyxcbiAgICAnWE4tLVFDS0ExUE1DJyxcbiAgICAnWE4tLVFYQTZBJyxcbiAgICAnWE4tLVFYQU0nLFxuICAgICdYTi0tUkhRVjk2RycsXG4gICAgJ1hOLS1ST1ZVODhCJyxcbiAgICAnWE4tLVJWQzFFMEFNM0UnLFxuICAgICdYTi0tUzlCUko5QycsXG4gICAgJ1hOLS1TRVM1NTRHJyxcbiAgICAnWE4tLVQ2MEI1NkEnLFxuICAgICdYTi0tVENLV0UnLFxuICAgICdYTi0tVElRNDlYUVlKJyxcbiAgICAnWE4tLVVOVVA0WScsXG4gICAgJ1hOLS1WRVJNR0VOU0JFUkFURVItQ1RCJyxcbiAgICAnWE4tLVZFUk1HRU5TQkVSQVRVTkctUFdCJyxcbiAgICAnWE4tLVZIUVVWJyxcbiAgICAnWE4tLVZVUTg2MUInLFxuICAgICdYTi0tVzRSODVFTDhGSFU1RE5SQScsXG4gICAgJ1hOLS1XNFJTNDBMJyxcbiAgICAnWE4tLVdHQkgxQycsXG4gICAgJ1hOLS1XR0JMNkEnLFxuICAgICdYTi0tWEhRNTIxQicsXG4gICAgJ1hOLS1YS0MyQUwzSFlFMkEnLFxuICAgICdYTi0tWEtDMkRMM0E1RUUwSCcsXG4gICAgJ1hOLS1ZOUEzQVEnLFxuICAgICdYTi0tWUZSTzRJNjdPJyxcbiAgICAnWE4tLVlHQkkyQU1NWCcsXG4gICAgJ1hOLS1aRlIxNjRCJyxcbiAgICAnWFhYJyxcbiAgICAnWFlaJyxcbiAgICAnWUFDSFRTJyxcbiAgICAnWUFIT08nLFxuICAgICdZQU1BWFVOJyxcbiAgICAnWUFOREVYJyxcbiAgICAnWUUnLFxuICAgICdZT0RPQkFTSEknLFxuICAgICdZT0dBJyxcbiAgICAnWU9LT0hBTUEnLFxuICAgICdZT1UnLFxuICAgICdZT1VUVUJFJyxcbiAgICAnWVQnLFxuICAgICdZVU4nLFxuICAgICdaQScsXG4gICAgJ1pBUFBPUycsXG4gICAgJ1pBUkEnLFxuICAgICdaRVJPJyxcbiAgICAnWklQJyxcbiAgICAnWk0nLFxuICAgICdaT05FJyxcbiAgICAnWlVFUklDSCcsXG4gICAgJ1pXJ1xuXTtcblxuXG4vLyBLZWVwIGFzIHVwcGVyLWNhc2UgdG8gbWFrZSB1cGRhdGluZyBmcm9tIHNvdXJjZSBlYXNpZXJcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2V0KGludGVybmFscy50bGRzLm1hcCgodGxkKSA9PiB0bGQudG9Mb3dlckNhc2UoKSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuUmFuZ2UgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0bykge1xuXG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuaGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlciwgbGVuZ3RoKSB7XG5cbiAgICAvLyBQYXJzZSBoZWFkZXJcblxuICAgIGNvbnN0IHBhcnRzID0gaGVhZGVyLnNwbGl0KCc9Jyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMiB8fFxuICAgICAgICBwYXJ0c1swXSAhPT0gJ2J5dGVzJykge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3RQb3MgPSBsZW5ndGggLSAxO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgcmFuZ2VzID0gcGFydHNbMV0ubWF0Y2goL1xcZCpcXC1cXGQqL2cpO1xuXG4gICAgLy8gSGFuZGxlIGhlYWRlcnMgd2l0aCBtdWx0aXBsZSByYW5nZXNcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMSkgeyAgICAgICAgICAgICAgIC8vICctJ1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZnJvbTtcbiAgICAgICAgbGV0IHRvO1xuICAgICAgICByYW5nZSA9IHJhbmdlLnNwbGl0KCctJyk7XG4gICAgICAgIGlmIChyYW5nZVswXSkge1xuICAgICAgICAgICAgZnJvbSA9IHBhcnNlSW50KHJhbmdlWzBdLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmFuZ2VbMV0pIHtcbiAgICAgICAgICAgIHRvID0gcGFyc2VJbnQocmFuZ2VbMV0sIDEwKTtcbiAgICAgICAgICAgIGlmIChmcm9tICE9PSB1bmRlZmluZWQpIHsgICAgICAvLyBDYW4gYmUgMFxuICAgICAgICAgICAgICAgIC8vIEZyb20tVG9cbiAgICAgICAgICAgICAgICBpZiAodG8gPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvID0gbGFzdFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAtVG9cbiAgICAgICAgICAgICAgICBmcm9tID0gbGVuZ3RoIC0gdG87XG4gICAgICAgICAgICAgICAgdG8gPSBsYXN0UG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRnJvbS1cbiAgICAgICAgICAgIHRvID0gbGFzdFBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tID4gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IGludGVybmFscy5SYW5nZShmcm9tLCB0bykpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gU29ydCBhbmQgY29uc29saWRhdGUgcmFuZ2VzXG5cbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gYS5mcm9tIC0gYi5mcm9tKTtcblxuICAgIGNvbnN0IGNvbnNvbGlkYXRlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+IDA7IC0taSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcmVzdWx0W2ldO1xuICAgICAgICBjb25zdCBiZWZvcmUgPSByZXN1bHRbaSAtIDFdO1xuICAgICAgICBpZiAoY3VycmVudC5mcm9tIDw9IGJlZm9yZS50byArIDEpIHtcbiAgICAgICAgICAgIGJlZm9yZS50byA9IGN1cnJlbnQudG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xpZGF0ZWQudW5zaGlmdChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGlkYXRlZC51bnNoaWZ0KHJlc3VsdFswXSk7XG5cbiAgICByZXR1cm4gY29uc29saWRhdGVkO1xufTtcblxuXG5leHBvcnRzLlN0cmVhbSA9IGludGVybmFscy5TdHJlYW0gPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5UcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IocmFuZ2UpIHtcblxuICAgICAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIGludGVybmFscy5SYW5nZSkpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiByYW5nZSA9PT0gJ29iamVjdCcsICdFeHBlY3RlZCBcInJhbmdlXCIgb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS5mcm9tIHx8IDA7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZnJvbSA9PT0gJ251bWJlcicsICdcInJhbmdlLmZyb21cIiBtdXN0IGJlIGZhbHN5LCBvciBhIG51bWJlcicpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoZnJvbSA9PT0gcGFyc2VJbnQoZnJvbSwgMTApICYmIGZyb20gPj0gMCwgJ1wicmFuZ2UuZnJvbVwiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRvID0gcmFuZ2UudG8gfHwgMDtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB0byA9PT0gJ251bWJlcicsICdcInJhbmdlLnRvXCIgbXVzdCBiZSBmYWxzeSwgb3IgYSBudW1iZXInKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHRvID09PSBwYXJzZUludCh0bywgMTApICYmIHRvID49IDAsICdcInJhbmdlLnRvXCIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodG8gPj0gZnJvbSwgJ1wicmFuZ2UudG9cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBcInJhbmdlLmZyb21cIicpO1xuXG4gICAgICAgICAgICByYW5nZSA9IG5ldyBpbnRlcm5hbHMuUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLl9uZXh0ID0gMDtcbiAgICB9XG5cbiAgICBwcm9jZXNzQ2h1bmsoY2h1bmspIHtcblxuICAgICAgICAvLyBSZWFkIGRlc2lyZWQgcmFuZ2UgZnJvbSBhIHN0cmVhbVxuXG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX25leHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSB0aGlzLl9uZXh0ICsgY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9uZXh0IDw9IHRoaXMuX3JhbmdlLmZyb20gfHwgICAgICAgLy8gQmVmb3JlIHJhbmdlXG4gICAgICAgICAgICBwb3MgPiB0aGlzLl9yYW5nZS50bykgeyAgICAgICAgICAgICAgICAgLy8gQWZ0ZXIgcmFuZ2VcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsYyBib3VuZHMgb2YgY2h1bmsgdG8gcmVhZFxuXG4gICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1heCgwLCB0aGlzLl9yYW5nZS5mcm9tIC0gcG9zKTtcbiAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1pbihjaHVuay5sZW5ndGgsIHRoaXMuX3JhbmdlLnRvIC0gcG9zICsgMSk7XG5cbiAgICAgICAgdGhpcy5wdXNoKGNodW5rLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gICAgRGVjb2RlIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb206XG4gICAgVmVyc2lvbiAxLjAgMTIvMjUvOTkgQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAgICBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvYmFzZTY0LnR4dFxuKi9cblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGRlY29kZUNoYXJzOiBbXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAgICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCA2MiwgLTEsIC0xLCAtMSwgNjMsXG4gICAgICAgIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSwgNjAsIDYxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LFxuICAgICAgICAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIC0xLCAtMSwgLTEsIC0xLCAtMSxcbiAgICAgICAgLTEsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsXG4gICAgICAgIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLCA1MSwgLTEsIC0xLCAtMSwgLTEsIC0xXG4gICAgXVxufTtcblxuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcblxuICAgIGNvbnN0IGRlY29kZUNoYXJzID0gaW50ZXJuYWxzLmRlY29kZUNoYXJzO1xuICAgIGNvbnN0IGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY29uc3QgYWxsb2NhdGVkID0gTWF0aC5jZWlsKGxlbiAvIDQpICogMztcbiAgICBjb25zdCByZXN1bHQgPSBCdWZmZXIuYWxsb2MoYWxsb2NhdGVkKTtcblxuICAgIGxldCBjMTtcbiAgICBsZXQgYzI7XG4gICAgbGV0IGMzO1xuICAgIGxldCBjNDtcbiAgICBsZXQgaiA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGMxID0gZGVjb2RlQ2hhcnNbYnVmZmVyW2krK10gJiAweGZmXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBjMSA9PT0gLTEpO1xuXG4gICAgICAgIGlmIChjMSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYzIgPSBkZWNvZGVDaGFyc1tidWZmZXJbaSsrXSAmIDB4ZmZdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgbGVuICYmIGMyID09PSAtMSk7XG5cbiAgICAgICAgaWYgKGMyID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHRbaisrXSA9IChjMSA8PCAyKSB8ICgoYzIgJiAweDMwKSA+PiA0KTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjMyA9IGJ1ZmZlcltpKytdICYgMHhmZjtcbiAgICAgICAgICAgIGlmIChjMyA9PT0gNjEpIHsgICAgICAgICAgICAgICAgICAgICAgICAvLyA9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zbGljZSgwLCBqKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYzMgPSBkZWNvZGVDaGFyc1tjM107XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgYzMgPT09IC0xKTtcblxuICAgICAgICBpZiAoYzMgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtqKytdID0gKChjMiAmIDB4MGYpIDw8IDQpIHwgKChjMyAmIDB4M2MpID4+IDIpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGM0ID0gYnVmZmVyW2krK10gJiAweGZmO1xuICAgICAgICAgICAgaWYgKGM0ID09PSA2MSkgeyAgICAgICAgICAgICAgICAgICAgICAgIC8vID1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDAsIGopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjNCA9IGRlY29kZUNoYXJzW2M0XTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBjNCA9PT0gLTEpO1xuXG4gICAgICAgIGlmIChjNCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdFtqKytdID0gKChjMyAmIDB4MDMpIDw8IDYpIHwgYzQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGogPT09IGFsbG9jYXRlZCA/IHJlc3VsdCA6IHJlc3VsdC5zbGljZSgwLCBqKSk7XG59O1xuXG5cbmV4cG9ydHMuRGVjb2RlciA9IGNsYXNzIERlY29kZXIgZXh0ZW5kcyBTdHJlYW0uVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9yZW1pbmRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgbGV0IHBhcnQgPSB0aGlzLl9yZW1pbmRlciA/IEJ1ZmZlci5jb25jYXQoW3RoaXMuX3JlbWluZGVyLCBjaHVua10pIDogY2h1bms7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHBhcnQubGVuZ3RoICUgNDtcbiAgICAgICAgaWYgKHJlbWFpbmluZykge1xuICAgICAgICAgICAgdGhpcy5fcmVtaW5kZXIgPSBwYXJ0LnNsaWNlKHBhcnQubGVuZ3RoIC0gcmVtYWluaW5nKTtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnNsaWNlKDAsIHBhcnQubGVuZ3RoIC0gcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbWluZGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHVzaChleHBvcnRzLmRlY29kZShwYXJ0KSk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIF9mbHVzaChjYWxsYmFjaykge1xuXG4gICAgICAgIGlmICh0aGlzLl9yZW1pbmRlcikge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGV4cG9ydHMuZGVjb2RlKHRoaXMuX3JlbWluZGVyKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuICAgIEVuY29kZSBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tOlxuICAgIFZlcnNpb24gMS4wIDEyLzI1Lzk5IENvcHlyaWdodCAoQykgMTk5OSBNYXNhbmFvIEl6dW1vIDxpekBvbmljb3MuY28uanA+XG4gICAgaHR0cDovL3d3dy5vbmljb3MuY29tL3N0YWZmL2l6L2FtdXNlL2phdmFzY3JpcHQvZXhwZXJ0L2Jhc2U2NC50eHRcbiovXG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlci50b1N0cmluZygnYmFzZTY0JykpO1xufTtcblxuXG5leHBvcnRzLkVuY29kZXIgPSBjbGFzcyBFbmNvZGVyIGV4dGVuZHMgU3RyZWFtLlRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcmVtaW5kZXIgPSBudWxsO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXG4gICAgICAgIGxldCBwYXJ0ID0gdGhpcy5fcmVtaW5kZXIgPyBCdWZmZXIuY29uY2F0KFt0aGlzLl9yZW1pbmRlciwgY2h1bmtdKSA6IGNodW5rO1xuICAgICAgICBjb25zdCByZW1haW5pbmcgPSBwYXJ0Lmxlbmd0aCAlIDM7XG4gICAgICAgIGlmIChyZW1haW5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbWluZGVyID0gcGFydC5zbGljZShwYXJ0Lmxlbmd0aCAtIHJlbWFpbmluZyk7XG4gICAgICAgICAgICBwYXJ0ID0gcGFydC5zbGljZSgwLCBwYXJ0Lmxlbmd0aCAtIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1pbmRlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnB1c2goZXhwb3J0cy5lbmNvZGUocGFydCkpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBfZmx1c2goY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAodGhpcy5fcmVtaW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChleHBvcnRzLmVuY29kZSh0aGlzLl9yZW1pbmRlcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgRGVjb2RlciA9IHJlcXVpcmUoJy4vZGVjb2RlcicpO1xuY29uc3QgRW5jb2RlciA9IHJlcXVpcmUoJy4vZW5jb2RlcicpO1xuXG5cbmV4cG9ydHMuZGVjb2RlID0gRGVjb2Rlci5kZWNvZGU7XG5cbmV4cG9ydHMuZW5jb2RlID0gRW5jb2Rlci5lbmNvZGU7XG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXIuRGVjb2RlcjtcblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2Rlci5FbmNvZGVyO1xuXG5cbi8vIEJhc2U2NHVybCAoUkZDIDQ2NDgpIGVuY29kZVxuXG5leHBvcnRzLmJhc2U2NHVybEVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmcpIHtcblxuICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSwgJ3ZhbHVlIG11c3QgYmUgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuICAgIGNvbnN0IGJ1ZiA9IChCdWZmZXIuaXNCdWZmZXIodmFsdWUpID8gdmFsdWUgOiBCdWZmZXIuZnJvbSh2YWx1ZSwgZW5jb2RpbmcgfHwgJ2JpbmFyeScpKTtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXD0vZywgJycpO1xufTtcblxuXG4vLyBCYXNlNjR1cmwgKFJGQyA0NjQ4KSBkZWNvZGVcblxuZXhwb3J0cy5iYXNlNjR1cmxEZWNvZGUgPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nKSB7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgbm90IGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCEvXltcXHdcXC1dKiQvLnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIChlbmNvZGluZyA9PT0gJ2J1ZmZlcicgPyBidWYgOiBidWYudG9TdHJpbmcoZW5jb2RpbmcgfHwgJ2JpbmFyeScpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGNvZGVzOiBuZXcgTWFwKFtcbiAgICAgICAgWzEwMCwgJ0NvbnRpbnVlJ10sXG4gICAgICAgIFsxMDEsICdTd2l0Y2hpbmcgUHJvdG9jb2xzJ10sXG4gICAgICAgIFsxMDIsICdQcm9jZXNzaW5nJ10sXG4gICAgICAgIFsyMDAsICdPSyddLFxuICAgICAgICBbMjAxLCAnQ3JlYXRlZCddLFxuICAgICAgICBbMjAyLCAnQWNjZXB0ZWQnXSxcbiAgICAgICAgWzIwMywgJ05vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uJ10sXG4gICAgICAgIFsyMDQsICdObyBDb250ZW50J10sXG4gICAgICAgIFsyMDUsICdSZXNldCBDb250ZW50J10sXG4gICAgICAgIFsyMDYsICdQYXJ0aWFsIENvbnRlbnQnXSxcbiAgICAgICAgWzIwNywgJ011bHRpLVN0YXR1cyddLFxuICAgICAgICBbMzAwLCAnTXVsdGlwbGUgQ2hvaWNlcyddLFxuICAgICAgICBbMzAxLCAnTW92ZWQgUGVybWFuZW50bHknXSxcbiAgICAgICAgWzMwMiwgJ01vdmVkIFRlbXBvcmFyaWx5J10sXG4gICAgICAgIFszMDMsICdTZWUgT3RoZXInXSxcbiAgICAgICAgWzMwNCwgJ05vdCBNb2RpZmllZCddLFxuICAgICAgICBbMzA1LCAnVXNlIFByb3h5J10sXG4gICAgICAgIFszMDcsICdUZW1wb3JhcnkgUmVkaXJlY3QnXSxcbiAgICAgICAgWzQwMCwgJ0JhZCBSZXF1ZXN0J10sXG4gICAgICAgIFs0MDEsICdVbmF1dGhvcml6ZWQnXSxcbiAgICAgICAgWzQwMiwgJ1BheW1lbnQgUmVxdWlyZWQnXSxcbiAgICAgICAgWzQwMywgJ0ZvcmJpZGRlbiddLFxuICAgICAgICBbNDA0LCAnTm90IEZvdW5kJ10sXG4gICAgICAgIFs0MDUsICdNZXRob2QgTm90IEFsbG93ZWQnXSxcbiAgICAgICAgWzQwNiwgJ05vdCBBY2NlcHRhYmxlJ10sXG4gICAgICAgIFs0MDcsICdQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCddLFxuICAgICAgICBbNDA4LCAnUmVxdWVzdCBUaW1lLW91dCddLFxuICAgICAgICBbNDA5LCAnQ29uZmxpY3QnXSxcbiAgICAgICAgWzQxMCwgJ0dvbmUnXSxcbiAgICAgICAgWzQxMSwgJ0xlbmd0aCBSZXF1aXJlZCddLFxuICAgICAgICBbNDEyLCAnUHJlY29uZGl0aW9uIEZhaWxlZCddLFxuICAgICAgICBbNDEzLCAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJ10sXG4gICAgICAgIFs0MTQsICdSZXF1ZXN0LVVSSSBUb28gTGFyZ2UnXSxcbiAgICAgICAgWzQxNSwgJ1Vuc3VwcG9ydGVkIE1lZGlhIFR5cGUnXSxcbiAgICAgICAgWzQxNiwgJ1JlcXVlc3RlZCBSYW5nZSBOb3QgU2F0aXNmaWFibGUnXSxcbiAgICAgICAgWzQxNywgJ0V4cGVjdGF0aW9uIEZhaWxlZCddLFxuICAgICAgICBbNDE4LCAnSVxcJ20gYSB0ZWFwb3QnXSxcbiAgICAgICAgWzQyMiwgJ1VucHJvY2Vzc2FibGUgRW50aXR5J10sXG4gICAgICAgIFs0MjMsICdMb2NrZWQnXSxcbiAgICAgICAgWzQyNCwgJ0ZhaWxlZCBEZXBlbmRlbmN5J10sXG4gICAgICAgIFs0MjUsICdVbm9yZGVyZWQgQ29sbGVjdGlvbiddLFxuICAgICAgICBbNDI2LCAnVXBncmFkZSBSZXF1aXJlZCddLFxuICAgICAgICBbNDI4LCAnUHJlY29uZGl0aW9uIFJlcXVpcmVkJ10sXG4gICAgICAgIFs0MjksICdUb28gTWFueSBSZXF1ZXN0cyddLFxuICAgICAgICBbNDMxLCAnUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZSddLFxuICAgICAgICBbNDUxLCAnVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnMnXSxcbiAgICAgICAgWzUwMCwgJ0ludGVybmFsIFNlcnZlciBFcnJvciddLFxuICAgICAgICBbNTAxLCAnTm90IEltcGxlbWVudGVkJ10sXG4gICAgICAgIFs1MDIsICdCYWQgR2F0ZXdheSddLFxuICAgICAgICBbNTAzLCAnU2VydmljZSBVbmF2YWlsYWJsZSddLFxuICAgICAgICBbNTA0LCAnR2F0ZXdheSBUaW1lLW91dCddLFxuICAgICAgICBbNTA1LCAnSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnXSxcbiAgICAgICAgWzUwNiwgJ1ZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzJ10sXG4gICAgICAgIFs1MDcsICdJbnN1ZmZpY2llbnQgU3RvcmFnZSddLFxuICAgICAgICBbNTA5LCAnQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkJ10sXG4gICAgICAgIFs1MTAsICdOb3QgRXh0ZW5kZWQnXSxcbiAgICAgICAgWzUxMSwgJ05ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnXVxuICAgIF0pXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkJvb20gPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuQm9vbS5ib29taWZ5KEhvZWsuY2xvbmUobWVzc2FnZSksIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBzdGF0dXNDb2RlID0gNTAwLCBkYXRhID0gbnVsbCwgY3RvciA9IGludGVybmFscy5Cb29tIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlID8gbWVzc2FnZSA6IHVuZGVmaW5lZCk7ICAgICAgICAgLy8gQXZvaWRzIHNldHRpbmdzIG51bGwgbWVzc2FnZVxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgY3Rvcik7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIHRoZSBzdGFjayB0byBvdXIgZXh0ZXJuYWwgQVBJXG4gICAgICAgIGVycm9yLmRhdGEgPSBkYXRhO1xuICAgICAgICBjb25zdCBib29tID0gaW50ZXJuYWxzLmluaXRpYWxpemUoZXJyb3IsIHN0YXR1c0NvZGUpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShib29tLCAndHlwZW9mJywgeyB2YWx1ZTogY3RvciB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kZWNvcmF0ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihib29tLCBvcHRpb25zLmRlY29yYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib29tO1xuICAgIH1cblxuICAgIHN0YXRpYyBbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0YW5jZSkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuQm9vbS5pc0Jvb20oaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0Jvb20oZXJyKSB7XG5cbiAgICAgICAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIEVycm9yICYmICEhZXJyLmlzQm9vbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYm9vbWlmeShlcnIsIG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChlcnIgaW5zdGFuY2VvZiBFcnJvciwgJ0Nhbm5vdCB3cmFwIG5vbi1FcnJvciBvYmplY3QnKTtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5kYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGVjb3JhdGUpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZXJyLCBvcHRpb25zLmRlY29yYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXJyLmlzQm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5pbml0aWFsaXplKGVyciwgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IDUwMCwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlID09PSBmYWxzZSB8fCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICFvcHRpb25zLnN0YXR1c0NvZGUgJiYgIW9wdGlvbnMubWVzc2FnZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5pbml0aWFsaXplKGVyciwgb3B0aW9ucy5zdGF0dXNDb2RlIHx8IGVyci5vdXRwdXQuc3RhdHVzQ29kZSwgb3B0aW9ucy5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvLyA0eHggQ2xpZW50IEVycm9yc1xuXG4gICAgc3RhdGljIGJhZFJlcXVlc3QobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDAsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmJhZFJlcXVlc3QgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHVuYXV0aG9yaXplZChtZXNzYWdlLCBzY2hlbWUsIGF0dHJpYnV0ZXMpIHsgICAgICAgICAgLy8gT3IgKG1lc3NhZ2UsIHd3d0F1dGhlbnRpY2F0ZVtdKVxuXG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwMSwgY3RvcjogaW50ZXJuYWxzLkJvb20udW5hdXRob3JpemVkIH0pO1xuXG4gICAgICAgIC8vIGZ1bmN0aW9uIChtZXNzYWdlKVxuXG4gICAgICAgIGlmICghc2NoZW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gKG1lc3NhZ2UsIHd3d0F1dGhlbnRpY2F0ZVtdKVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyLm91dHB1dC5oZWFkZXJzWydXV1ctQXV0aGVudGljYXRlJ10gPSBzY2hlbWUuam9pbignLCAnKTtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmdW5jdGlvbiAobWVzc2FnZSwgc2NoZW1lLCBhdHRyaWJ1dGVzKVxuXG4gICAgICAgIGxldCB3d3dBdXRoZW50aWNhdGUgPSBgJHtzY2hlbWV9IGA7XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMgfHxcbiAgICAgICAgICAgIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgZXJyLm91dHB1dC5wYXlsb2FkLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9IEhvZWsuZXNjYXBlSGVhZGVyQXR0cmlidXRlKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIGVyci5vdXRwdXQucGF5bG9hZC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHd3d0F1dGhlbnRpY2F0ZSArPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKG5hbWUpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVyci5vdXRwdXQucGF5bG9hZC5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfT1cIiR7SG9lay5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUodmFsdWUudG9TdHJpbmcoKSl9XCJgO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9ICcsICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHd3d0F1dGhlbnRpY2F0ZSArPSBgZXJyb3I9XCIke0hvZWsuZXNjYXBlSGVhZGVyQXR0cmlidXRlKG1lc3NhZ2UpfVwiYDtcbiAgICAgICAgICAgIGVyci5vdXRwdXQucGF5bG9hZC5hdHRyaWJ1dGVzLmVycm9yID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVyci5pc01pc3NpbmcgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyLm91dHB1dC5oZWFkZXJzWydXV1ctQXV0aGVudGljYXRlJ10gPSB3d3dBdXRoZW50aWNhdGU7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgc3RhdGljIHBheW1lbnRSZXF1aXJlZChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwMiwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20ucGF5bWVudFJlcXVpcmVkIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBmb3JiaWRkZW4obWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDMsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmZvcmJpZGRlbiB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbm90Rm91bmQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDQsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLm5vdEZvdW5kIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBtZXRob2ROb3RBbGxvd2VkKG1lc3NhZ2UsIGRhdGEsIGFsbG93KSB7XG5cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDA1LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5tZXRob2ROb3RBbGxvd2VkIH0pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgYWxsb3cgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhbGxvdyA9IFthbGxvd107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvdykpIHtcbiAgICAgICAgICAgIGVyci5vdXRwdXQuaGVhZGVycy5BbGxvdyA9IGFsbG93LmpvaW4oJywgJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIHN0YXRpYyBub3RBY2NlcHRhYmxlKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDA2LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5ub3RBY2NlcHRhYmxlIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcm94eUF1dGhSZXF1aXJlZChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwNywgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20ucHJveHlBdXRoUmVxdWlyZWQgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsaWVudFRpbWVvdXQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDgsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmNsaWVudFRpbWVvdXQgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbmZsaWN0KG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDA5LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5jb25mbGljdCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcmVzb3VyY2VHb25lKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDEwLCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5yZXNvdXJjZUdvbmUgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxlbmd0aFJlcXVpcmVkKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDExLCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5sZW5ndGhSZXF1aXJlZCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJlY29uZGl0aW9uRmFpbGVkKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDEyLCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5wcmVjb25kaXRpb25GYWlsZWQgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGVudGl0eVRvb0xhcmdlKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDEzLCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5lbnRpdHlUb29MYXJnZSB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdXJpVG9vTG9uZyhtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQxNCwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20udXJpVG9vTG9uZyB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdW5zdXBwb3J0ZWRNZWRpYVR5cGUobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTUsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLnVuc3VwcG9ydGVkTWVkaWFUeXBlIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyByYW5nZU5vdFNhdGlzZmlhYmxlKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE2LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5yYW5nZU5vdFNhdGlzZmlhYmxlIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBleHBlY3RhdGlvbkZhaWxlZChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQxNywgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20uZXhwZWN0YXRpb25GYWlsZWQgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHRlYXBvdChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQxOCwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20udGVhcG90IH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBiYWREYXRhKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDIyLCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5iYWREYXRhIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBsb2NrZWQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MjMsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmxvY2tlZCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZmFpbGVkRGVwZW5kZW5jeShtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQyNCwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20uZmFpbGVkRGVwZW5kZW5jeSB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcHJlY29uZGl0aW9uUmVxdWlyZWQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MjgsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLnByZWNvbmRpdGlvblJlcXVpcmVkIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB0b29NYW55UmVxdWVzdHMobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MjksIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLnRvb01hbnlSZXF1ZXN0cyB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaWxsZWdhbChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQ1MSwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20uaWxsZWdhbCB9KTtcbiAgICB9XG5cbiAgICAvLyA1eHggU2VydmVyIEVycm9yc1xuXG4gICAgc3RhdGljIGludGVybmFsKG1lc3NhZ2UsIGRhdGEsIHN0YXR1c0NvZGUgPSA1MDApIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNlcnZlckVycm9yKG1lc3NhZ2UsIGRhdGEsIHN0YXR1c0NvZGUsIGludGVybmFscy5Cb29tLmludGVybmFsKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbm90SW1wbGVtZW50ZWQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgNTAxLCBpbnRlcm5hbHMuQm9vbS5ub3RJbXBsZW1lbnRlZCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGJhZEdhdGV3YXkobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgNTAyLCBpbnRlcm5hbHMuQm9vbS5iYWRHYXRld2F5KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2VydmVyVW5hdmFpbGFibGUobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgNTAzLCBpbnRlcm5hbHMuQm9vbS5zZXJ2ZXJVbmF2YWlsYWJsZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdhdGV3YXlUaW1lb3V0KG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNlcnZlckVycm9yKG1lc3NhZ2UsIGRhdGEsIDUwNCwgaW50ZXJuYWxzLkJvb20uZ2F0ZXdheVRpbWVvdXQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBiYWRJbXBsZW1lbnRhdGlvbihtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgY29uc3QgZXJyID0gaW50ZXJuYWxzLnNlcnZlckVycm9yKG1lc3NhZ2UsIGRhdGEsIDUwMCwgaW50ZXJuYWxzLkJvb20uYmFkSW1wbGVtZW50YXRpb24pO1xuICAgICAgICBlcnIuaXNEZXZlbG9wZXJFcnJvciA9IHRydWU7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuQm9vbS5kZWZhdWx0ID0gaW50ZXJuYWxzLkJvb207ICAgICAgICAvLyBTdXBwb3J0IEVTNiBtb2R1bGUgaW1wb3J0XG5cblxuaW50ZXJuYWxzLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoZXJyLCBzdGF0dXNDb2RlLCBtZXNzYWdlKSB7XG5cbiAgICBjb25zdCBudW1iZXJDb2RlID0gcGFyc2VJbnQoc3RhdHVzQ29kZSwgMTApO1xuICAgIEhvZWsuYXNzZXJ0KCFpc05hTihudW1iZXJDb2RlKSAmJiBudW1iZXJDb2RlID49IDQwMCwgJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXIgKDQwMCspOicsIHN0YXR1c0NvZGUpO1xuXG4gICAgZXJyLmlzQm9vbSA9IHRydWU7XG4gICAgZXJyLmlzU2VydmVyID0gbnVtYmVyQ29kZSA+PSA1MDA7XG5cbiAgICBpZiAoIWVyci5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSB7XG4gICAgICAgIGVyci5kYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICBlcnIub3V0cHV0ID0ge1xuICAgICAgICBzdGF0dXNDb2RlOiBudW1iZXJDb2RlLFxuICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgaGVhZGVyczoge31cbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ3JlZm9ybWF0JywgeyB2YWx1ZTogaW50ZXJuYWxzLnJlZm9ybWF0IH0pO1xuXG4gICAgaWYgKCFtZXNzYWdlICYmXG4gICAgICAgICFlcnIubWVzc2FnZSkge1xuXG4gICAgICAgIGVyci5yZWZvcm1hdCgpO1xuICAgICAgICBtZXNzYWdlID0gZXJyLm91dHB1dC5wYXlsb2FkLmVycm9yO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlcnIsICdtZXNzYWdlJykgfHwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXJyKSwgJ21lc3NhZ2UnKTtcbiAgICAgICAgSG9lay5hc3NlcnQocHJvcHMuY29uZmlndXJhYmxlICYmICFwcm9wcy5nZXQsICdUaGUgZXJyb3IgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBib29tJyk7XG5cbiAgICAgICAgZXJyLm1lc3NhZ2UgPSBtZXNzYWdlICsgKGVyci5tZXNzYWdlID8gJzogJyArIGVyci5tZXNzYWdlIDogJycpO1xuICAgICAgICBlcnIub3V0cHV0LnBheWxvYWQubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cblxuICAgIGVyci5yZWZvcm1hdCgpO1xuICAgIHJldHVybiBlcnI7XG59O1xuXG5cbmludGVybmFscy5yZWZvcm1hdCA9IGZ1bmN0aW9uIChkZWJ1ZyA9IGZhbHNlKSB7XG5cbiAgICB0aGlzLm91dHB1dC5wYXlsb2FkLnN0YXR1c0NvZGUgPSB0aGlzLm91dHB1dC5zdGF0dXNDb2RlO1xuICAgIHRoaXMub3V0cHV0LnBheWxvYWQuZXJyb3IgPSBpbnRlcm5hbHMuY29kZXMuZ2V0KHRoaXMub3V0cHV0LnN0YXR1c0NvZGUpIHx8ICdVbmtub3duJztcblxuICAgIGlmICh0aGlzLm91dHB1dC5zdGF0dXNDb2RlID09PSA1MDAgJiYgZGVidWcgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQucGF5bG9hZC5tZXNzYWdlID0gJ0FuIGludGVybmFsIHNlcnZlciBlcnJvciBvY2N1cnJlZCc7ICAgICAgICAgICAgICAvLyBIaWRlIGFjdHVhbCBlcnJvciBmcm9tIHVzZXJcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMub3V0cHV0LnBheWxvYWQubWVzc2FnZSA9IHRoaXMubWVzc2FnZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zZXJ2ZXJFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkYXRhLCBzdGF0dXNDb2RlLCBjdG9yKSB7XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICFkYXRhLmlzQm9vbSkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuQm9vbS5ib29taWZ5KGRhdGEsIHsgc3RhdHVzQ29kZSwgbWVzc2FnZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZSwgZGF0YSwgY3RvciB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc3lzdGVtOiBbXG5cbiAgICAgICAgLy8gSmF2YVNjcmlwdFxuXG4gICAgICAgIEV2YWxFcnJvcixcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgUmVmZXJlbmNlRXJyb3IsXG4gICAgICAgIFN5bnRheEVycm9yLFxuICAgICAgICBUeXBlRXJyb3IsXG4gICAgICAgIFVSSUVycm9yLFxuXG4gICAgICAgIC8vIE5vZGVcblxuICAgICAgICBBc3NlcnQuQXNzZXJ0aW9uRXJyb3IsXG5cbiAgICAgICAgLy8gSG9la1xuXG4gICAgICAgIEhvZWsuRXJyb3JcbiAgICBdXG59O1xuXG5cbmV4cG9ydHMucmV0aHJvdyA9IGZ1bmN0aW9uIChlcnIsIHR5cGVzLCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuY2F0Y2goZXJyLCB0eXBlcywgb3B0aW9ucywgdHJ1ZSk7XG59O1xuXG5cbmV4cG9ydHMuaWdub3JlID0gZnVuY3Rpb24gKGVyciwgdHlwZXMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5jYXRjaChlcnIsIHR5cGVzLCBvcHRpb25zLCBmYWxzZSk7XG59O1xuXG5cbmludGVybmFscy5jYXRjaCA9IGZ1bmN0aW9uIChlcnIsIHR5cGVzLCBvcHRpb25zLCBtYXRjaCkge1xuXG4gICAgaWYgKGludGVybmFscy5tYXRjaChlcnIsIHR5cGVzKSAhPT0gbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEVycm9yIHJlcGxhY2VtZW50XG5cbiAgICBpZiAob3B0aW9ucy5vdmVycmlkZSkge1xuICAgICAgICBlcnIgPSBvcHRpb25zLm92ZXJyaWRlO1xuICAgIH1cblxuICAgIC8vIEVycm9yIGRlY29yYXRpb25zXG5cbiAgICBpZiAob3B0aW9ucy5kZWNvcmF0ZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVyciwgb3B0aW9ucy5kZWNvcmF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucmV0dXJuKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyO1xufTtcblxuXG5leHBvcnRzLmJhY2tncm91bmQgPSBhc3luYyBmdW5jdGlvbiAob3BlcmF0aW9uLCBhY3Rpb24gPSAncmV0aHJvdycsIHR5cGVzID0gJ3N5c3RlbScsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGF3YWl0IG9wZXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgb3BlcmF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXhwb3J0c1thY3Rpb25dKGVyciwgdHlwZXMsIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5pc0Jvb20gPSBmdW5jdGlvbiAoZXJyKSB7XG5cbiAgICByZXR1cm4gQm9vbS5pc0Jvb20oZXJyKTtcbn07XG5cblxuZXhwb3J0cy5pc0Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuXG4gICAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIEVycm9yO1xufTtcblxuXG5leHBvcnRzLmlzU3lzdGVtID0gZnVuY3Rpb24gKGVycikge1xuXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChlcnIuaXNCb29tKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiBpbnRlcm5hbHMuc3lzdGVtKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBzeXN0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSB7XG4gICAgc3lzdGVtOiBleHBvcnRzLmlzU3lzdGVtLFxuICAgIGJvb206IGV4cG9ydHMuaXNCb29tXG59O1xuXG5cbmludGVybmFscy5tYXRjaCA9IGZ1bmN0aW9uIChlcnIsIHR5cGVzKSB7XG5cbiAgICBpZiAoIXR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHR5cGVzID0gQXJyYXkuaXNBcnJheSh0eXBlcykgPyB0eXBlcyA6IFt0eXBlc107XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMucnVsZXNbdHlwZV0oZXJyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKEhvZWsuY29udGFpbihlcnIsIHR5cGUsIHsgZGVlcDogdHJ1ZSwgcGFydDogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcblxyXG5jb25zdCBpbnRlcm5hbHMgPSB7XHJcbiAgICBzdXNwZWN0Ung6IC9cIig/Ol98XFxcXHUwMDVbRmZdKSg/Ol98XFxcXHUwMDVbRmZdKSg/OnB8XFxcXHUwMDcwKSg/OnJ8XFxcXHUwMDcyKSg/Om98XFxcXHUwMDZbRmZdKSg/OnR8XFxcXHUwMDc0KSg/Om98XFxcXHUwMDZbRmZdKSg/Ol98XFxcXHUwMDVbRmZdKSg/Ol98XFxcXHUwMDVbRmZdKVwiXFxzKlxcOi9cclxufTtcclxuXHJcblxyXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAvLyBOb3JtYWxpemUgYXJndW1lbnRzXHJcblxyXG4gICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHJldml2ZXIgJiZcclxuICAgICAgICAgICAgdHlwZW9mIHJldml2ZXIgPT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICBvcHRpb25zID0gcmV2aXZlcjtcclxuICAgICAgICAgICAgcmV2aXZlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGFyc2Ugbm9ybWFsbHksIGFsbG93aW5nIGV4Y2VwdGlvbnNcclxuXHJcbiAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHRleHQsIHJldml2ZXIpO1xyXG5cclxuICAgIC8vIG9wdGlvbnMucHJvdG9BY3Rpb246ICdlcnJvcicgKGRlZmF1bHQpIC8gJ3JlbW92ZScgLyAnaWdub3JlJ1xyXG5cclxuICAgIGlmIChvcHRpb25zLnByb3RvQWN0aW9uID09PSAnaWdub3JlJykge1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWdub3JlIG51bGwgYW5kIG5vbi1vYmplY3RzXHJcblxyXG4gICAgaWYgKCFvYmogfHxcclxuICAgICAgICB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIG9yaWdpbmFsIHN0cmluZyBmb3IgcG90ZW50aWFsIGV4cGxvaXRcclxuXHJcbiAgICBpZiAoIXRleHQubWF0Y2goaW50ZXJuYWxzLnN1c3BlY3RSeCkpIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNjYW4gcmVzdWx0IGZvciBwcm90byBrZXlzXHJcblxyXG4gICAgZXhwb3J0cy5zY2FuKG9iaiwgb3B0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIG9iajtcclxufTtcclxuXHJcblxyXG5leHBvcnRzLnNjYW4gPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zKSB7XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgbGV0IG5leHQgPSBbb2JqXTtcclxuXHJcbiAgICB3aGlsZSAobmV4dC5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBub2RlcyA9IG5leHQ7XHJcbiAgICAgICAgbmV4dCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCAnX19wcm90b19fJykpIHsgICAgICAvLyBBdm9pZCBjYWxsaW5nIG5vZGUuaGFzT3duUHJvcGVydHkgZGlyZWN0bHlcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByb3RvQWN0aW9uICE9PSAncmVtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignT2JqZWN0IGNvbnRhaW5zIGZvcmJpZGRlbiBwcm90b3R5cGUgcHJvcGVydHknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5fX3Byb3RvX187XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBuZXh0LnB1c2gobm9kZVtrZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblxyXG5leHBvcnRzLnNhZmVQYXJzZSA9IGZ1bmN0aW9uICh0ZXh0LCByZXZpdmVyKSB7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5wYXJzZSh0ZXh0LCByZXZpdmVyKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChpZ25vcmVFcnJvcikge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59O1xyXG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuXG5jb25zdCBSZWdleCA9IHJlcXVpcmUoJy4vcmVnZXgnKTtcbmNvbnN0IFNlZ21lbnQgPSByZXF1aXJlKCcuL3NlZ21lbnQnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcGF0aFJlZ2V4OiBSZWdleC5nZW5lcmF0ZSgpLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGlzQ2FzZVNlbnNpdGl2ZTogdHJ1ZVxuICAgIH1cbn07XG5cblxuZXhwb3J0cy5Sb3V0ZXIgPSBpbnRlcm5hbHMuUm91dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIHRoaXMuc2V0dGluZ3MgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5yb3V0ZXMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2V5OiBIVFRQIG1ldGhvZCBvciAqIGZvciBjYXRjaC1hbGwsIHZhbHVlOiBzb3J0ZWQgYXJyYXkgb2Ygcm91dGVzXG4gICAgdGhpcy5pZHMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2V5OiByb3V0ZSBpZCwgdmFsdWU6IHJlY29yZFxuICAgIHRoaXMudmhvc3RzID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHt9IHdoZXJlIEtleTogaG9zdG5hbWUsIHZhbHVlOiBzZWUgdGhpcy5yb3V0ZXNcblxuICAgIHRoaXMuc3BlY2lhbHMgPSB7XG4gICAgICAgIGJhZFJlcXVlc3Q6IG51bGwsXG4gICAgICAgIG5vdEZvdW5kOiBudWxsLFxuICAgICAgICBvcHRpb25zOiBudWxsXG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLlJvdXRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNvbmZpZywgcm91dGUpIHtcblxuICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAgIGNvbnN0IHZob3N0ID0gY29uZmlnLnZob3N0IHx8ICcqJztcbiAgICBpZiAodmhvc3QgIT09ICcqJykge1xuICAgICAgICB0aGlzLnZob3N0cyA9IHRoaXMudmhvc3RzIHx8IHt9O1xuICAgICAgICB0aGlzLnZob3N0c1t2aG9zdF0gPSB0aGlzLnZob3N0c1t2aG9zdF0gfHwge307XG4gICAgfVxuXG4gICAgY29uc3QgdGFibGUgPSAodmhvc3QgPT09ICcqJyA/IHRoaXMucm91dGVzIDogdGhpcy52aG9zdHNbdmhvc3RdKTtcbiAgICB0YWJsZVttZXRob2RdID0gdGFibGVbbWV0aG9kXSB8fCB7IHJvdXRlczogW10sIHJvdXRlcjogbmV3IFNlZ21lbnQoKSB9O1xuXG4gICAgY29uc3QgYW5hbHlzaXMgPSBjb25maWcuYW5hbHlzaXMgfHwgdGhpcy5hbmFseXplKGNvbmZpZy5wYXRoKTtcbiAgICBjb25zdCByZWNvcmQgPSB7XG4gICAgICAgIHBhdGg6IGNvbmZpZy5wYXRoLFxuICAgICAgICByb3V0ZTogcm91dGUgfHwgY29uZmlnLnBhdGgsXG4gICAgICAgIHNlZ21lbnRzOiBhbmFseXNpcy5zZWdtZW50cyxcbiAgICAgICAgcGFyYW1zOiBhbmFseXNpcy5wYXJhbXMsXG4gICAgICAgIGZpbmdlcnByaW50OiBhbmFseXNpcy5maW5nZXJwcmludCxcbiAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3NcbiAgICB9O1xuXG4gICAgLy8gQWRkIHJvdXRlXG5cbiAgICB0YWJsZVttZXRob2RdLnJvdXRlci5hZGQoYW5hbHlzaXMuc2VnbWVudHMsIHJlY29yZCk7XG4gICAgdGFibGVbbWV0aG9kXS5yb3V0ZXMucHVzaChyZWNvcmQpO1xuICAgIHRhYmxlW21ldGhvZF0ucm91dGVzLnNvcnQoaW50ZXJuYWxzLnNvcnQpO1xuXG4gICAgY29uc3QgbGFzdCA9IHJlY29yZC5zZWdtZW50c1tyZWNvcmQuc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3QuZW1wdHkpIHtcbiAgICAgICAgdGFibGVbbWV0aG9kXS5yb3V0ZXIuYWRkKGFuYWx5c2lzLnNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgcmVjb3JkKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmlkKSB7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCF0aGlzLmlkc1tjb25maWcuaWRdLCAnUm91dGUgaWQnLCBjb25maWcuaWQsICdmb3IgcGF0aCcsIGNvbmZpZy5wYXRoLCAnY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgcGF0aCcsIHRoaXMuaWRzW2NvbmZpZy5pZF0gJiYgdGhpcy5pZHNbY29uZmlnLmlkXS5wYXRoKTtcbiAgICAgICAgdGhpcy5pZHNbY29uZmlnLmlkXSA9IHJlY29yZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVjb3JkO1xufTtcblxuXG5pbnRlcm5hbHMuUm91dGVyLnByb3RvdHlwZS5zcGVjaWFsID0gZnVuY3Rpb24gKHR5cGUsIHJvdXRlKSB7XG5cbiAgICBIb2VrLmFzc2VydChPYmplY3Qua2V5cyh0aGlzLnNwZWNpYWxzKS5pbmRleE9mKHR5cGUpICE9PSAtMSwgJ1Vua25vd24gc3BlY2lhbCByb3V0ZSB0eXBlOicsIHR5cGUpO1xuXG4gICAgdGhpcy5zcGVjaWFsc1t0eXBlXSA9IHsgcm91dGUgfTtcbn07XG5cblxuaW50ZXJuYWxzLlJvdXRlci5wcm90b3R5cGUucm91dGUgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXRoLCBob3N0bmFtZSkge1xuXG4gICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcvJykuc2xpY2UoMSk7XG5cbiAgICBjb25zdCB2aG9zdCA9ICh0aGlzLnZob3N0cyAmJiBob3N0bmFtZSAmJiB0aGlzLnZob3N0c1tob3N0bmFtZV0pO1xuICAgIGNvbnN0IHJvdXRlID0gKHZob3N0ICYmIHRoaXMuX2xvb2t1cChwYXRoLCBzZWdtZW50cywgdmhvc3QsIG1ldGhvZCkpIHx8XG4gICAgICAgIHRoaXMuX2xvb2t1cChwYXRoLCBzZWdtZW50cywgdGhpcy5yb3V0ZXMsIG1ldGhvZCkgfHxcbiAgICAgICAgKG1ldGhvZCA9PT0gJ2hlYWQnICYmIHZob3N0ICYmIHRoaXMuX2xvb2t1cChwYXRoLCBzZWdtZW50cywgdmhvc3QsICdnZXQnKSkgfHxcbiAgICAgICAgKG1ldGhvZCA9PT0gJ2hlYWQnICYmIHRoaXMuX2xvb2t1cChwYXRoLCBzZWdtZW50cywgdGhpcy5yb3V0ZXMsICdnZXQnKSkgfHxcbiAgICAgICAgKG1ldGhvZCA9PT0gJ29wdGlvbnMnICYmIHRoaXMuc3BlY2lhbHMub3B0aW9ucykgfHxcbiAgICAgICAgKHZob3N0ICYmIHRoaXMuX2xvb2t1cChwYXRoLCBzZWdtZW50cywgdmhvc3QsICcqJykpIHx8XG4gICAgICAgIHRoaXMuX2xvb2t1cChwYXRoLCBzZWdtZW50cywgdGhpcy5yb3V0ZXMsICcqJykgfHxcbiAgICAgICAgdGhpcy5zcGVjaWFscy5ub3RGb3VuZCB8fCBCb29tLm5vdEZvdW5kKCk7XG5cbiAgICByZXR1cm4gcm91dGU7XG59O1xuXG5cbmludGVybmFscy5Sb3V0ZXIucHJvdG90eXBlLl9sb29rdXAgPSBmdW5jdGlvbiAocGF0aCwgc2VnbWVudHMsIHRhYmxlLCBtZXRob2QpIHtcblxuICAgIGNvbnN0IHNldCA9IHRhYmxlW21ldGhvZF07XG4gICAgaWYgKCFzZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBzZXQucm91dGVyLmxvb2t1cChwYXRoLCBzZWdtZW50cywgdGhpcy5zZXR0aW5ncyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBhc3NpZ25tZW50cyA9IHt9O1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5hcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBuYW1lID0gbWF0Y2gucmVjb3JkLnBhcmFtc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbnRlcm5hbHMuZGVjb2RlKG1hdGNoLmFycmF5W2ldKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzQm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BlY2lhbHMuYmFkUmVxdWVzdCB8fCB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc3NpZ25tZW50c1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NpZ25tZW50c1tuYW1lXSA9IGFzc2lnbm1lbnRzW25hbWVdICsgJy8nICsgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NpZ25tZW50c1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBtYXRjaC5hcnJheS5sZW5ndGggfHwgICAgICAgICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0aGUgbGFzdCBzZWdtZW50IG9mIGEgbXVsdGktc2VnbWVudCBwYXJhbVxuICAgICAgICAgICAgbmFtZSAhPT0gbWF0Y2gucmVjb3JkLnBhcmFtc1tpICsgMV0pIHtcblxuICAgICAgICAgICAgYXJyYXkucHVzaChhc3NpZ25tZW50c1tuYW1lXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBwYXJhbXM6IGFzc2lnbm1lbnRzLCBwYXJhbXNBcnJheTogYXJyYXksIHJvdXRlOiBtYXRjaC5yZWNvcmQucm91dGUgfTtcbn07XG5cblxuaW50ZXJuYWxzLmRlY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCByZXF1ZXN0IHBhdGgnKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5Sb3V0ZXIucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBpZiAocGF0aCAmJlxuICAgICAgICBwYXRoLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcblxuICAgICAgICAvLyBVcHBlcmNhc2UgJWVuY29kZWQgdmFsdWVzXG5cbiAgICAgICAgY29uc3QgdXBwZXJjYXNlID0gcGF0aC5yZXBsYWNlKC8lWzAtOWEtZkEtRl1bMC05YS1mQS1GXS9nLCAoZW5jb2RlZCkgPT4gZW5jb2RlZC50b1VwcGVyQ2FzZSgpKTtcblxuICAgICAgICAvLyBEZWNvZGUgbm9uLXJlc2VydmVkIHBhdGggY2hhcmFjdGVyczogYS16IEEtWiAwLTkgXyEkJicoKSorLDs9OkAtLn5cbiAgICAgICAgLy8gISAoJTIxKSAkICglMjQpICYgKCUyNikgJyAoJTI3KSAoICglMjgpICkgKCUyOSkgKiAoJTJBKSArICglMkIpICwgKCUyQykgLSAoJTJEKSAuICglMkUpXG4gICAgICAgIC8vIDAtOSAoJTMwLTM5KSA6ICglM0EpIDsgKCUzQikgPSAoJTNEKVxuICAgICAgICAvLyBAICglNDApIEEtWiAoJTQxLTVBKSBfICglNUYpIGEteiAoJTYxLTdBKSB+ICglN0UpXG5cbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHVwcGVyY2FzZS5yZXBsYWNlKC8lKD86MlsxNDYtOUEtRV18M1tcXGRBQkRdfDRbXFxkQS1GXXw1W1xcZEFGXXw2WzEtOUEtRl18N1tcXGRBRV0pL2csIChlbmNvZGVkKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGVuY29kZWQuc3Vic3RyaW5nKDEpLCAxNikpKTtcblxuICAgICAgICBwYXRoID0gZGVjb2RlZDtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgcGF0aCBzZWdtZW50c1xuXG4gICAgaWYgKHBhdGggJiZcbiAgICAgICAgKHBhdGguaW5kZXhPZignLy4nKSAhPT0gLTEgfHwgcGF0aFswXSA9PT0gJy4nKSkge1xuXG4gICAgICAgIGNvbnN0IGhhc0xlYWRpbmdEYXNoID0gcGF0aFswXSA9PT0gJy8nO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBsZXQgc2VnbWVudDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VnbWVudCA9PT0gJy4nIHx8XG4gICAgICAgICAgICBzZWdtZW50ID09PSAnLi4nKSB7ICAgICAgICAgLy8gQWRkIHRyYWlsaW5nIHNsYXNoIHdoZW4gbmVlZGVkXG5cbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gbm9ybWFsaXplZC5qb2luKCcvJyk7XG5cbiAgICAgICAgaWYgKHBhdGhbMF0gIT09ICcvJyAmJlxuICAgICAgICAgICAgaGFzTGVhZGluZ0Rhc2gpIHtcblxuICAgICAgICAgICAgcGF0aCA9ICcvJyArIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbn07XG5cblxuaW50ZXJuYWxzLlJvdXRlci5wcm90b3R5cGUuYW5hbHl6ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBIb2VrLmFzc2VydChpbnRlcm5hbHMucGF0aFJlZ2V4LnZhbGlkYXRlUGF0aC50ZXN0KHBhdGgpLCAnSW52YWxpZCBwYXRoOicsIHBhdGgpO1xuICAgIEhvZWsuYXNzZXJ0KCFpbnRlcm5hbHMucGF0aFJlZ2V4LnZhbGlkYXRlUGF0aEVuY29kZWQudGVzdChwYXRoKSwgJ1BhdGggY2Fubm90IGNvbnRhaW4gZW5jb2RlZCBub24tcmVzZXJ2ZWQgcGF0aCBjaGFyYWN0ZXJzOicsIHBhdGgpO1xuXG4gICAgY29uc3QgcGF0aFBhcnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gW107XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgY29uc3QgZmluZ2VycyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXRoUGFydHMubGVuZ3RoOyArK2kpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBmaXJzdCBlbXB0eSBzZWdtZW50XG4gICAgICAgIGxldCBzZWdtZW50ID0gcGF0aFBhcnRzW2ldO1xuXG4gICAgICAgIC8vIExpdGVyYWxcblxuICAgICAgICBpZiAoc2VnbWVudC5pbmRleE9mKCd7JykgPT09IC0xKSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gdGhpcy5zZXR0aW5ncy5pc0Nhc2VTZW5zaXRpdmUgPyBzZWdtZW50IDogc2VnbWVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgZmluZ2Vycy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7IGxpdGVyYWw6IHNlZ21lbnQgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcmFtZXRlclxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gaW50ZXJuYWxzLnBhcnNlUGFyYW1zKHNlZ21lbnQpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJhbWV0ZXJcblxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQocGFyYW1zLmluZGV4T2YoaXRlbS5uYW1lKSA9PT0gLTEsICdDYW5ub3QgcmVwZWF0IHRoZSBzYW1lIHBhcmFtZXRlciBuYW1lOicsIGl0ZW0ubmFtZSwgJ2luOicsIHBhdGgpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goaXRlbS5uYW1lKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0ud2lsY2FyZCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaXRlbS5jb3VudDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXJzLnB1c2goJz8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChpdGVtLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5nZXJzLnB1c2goJyMnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7IHdpbGRjYXJkOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbmdlcnMucHVzaCgnPycpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goeyBlbXB0eTogaXRlbS5lbXB0eSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gTWl4ZWQgcGFyYW1ldGVyXG5cbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHBhcnRzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBmaXJzdDogdHlwZW9mIHBhcnRzWzBdICE9PSAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBzZWdtZW50czogW11cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxldCBmaW5nZXIgPSAnJztcbiAgICAgICAgICAgIGxldCByZWdleCA9ICdeJztcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbal07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBmaW5nZXIgPSBmaW5nZXIgKyBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICByZWdleCA9IHJlZ2V4ICsgSG9lay5lc2NhcGVSZWdleChwYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgc2VnLnNlZ21lbnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBIb2VrLmFzc2VydChwYXJhbXMuaW5kZXhPZihwYXJ0Lm5hbWUpID09PSAtMSwgJ0Nhbm5vdCByZXBlYXQgdGhlIHNhbWUgcGFyYW1ldGVyIG5hbWU6JywgcGFydC5uYW1lLCAnaW46JywgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcnQubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZmluZ2VyID0gZmluZ2VyICsgJz8nO1xuICAgICAgICAgICAgICAgICAgICByZWdleCA9IHJlZ2V4ICsgJyguJyArIChwYXJ0LmVtcHR5ID8gJyonIDogJysnKSArICcpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZy5taXhlZCA9IG5ldyBSZWdFeHAocmVnZXggKyAnJCcsICghdGhpcy5zZXR0aW5ncy5pc0Nhc2VTZW5zaXRpdmUgPyAnaScgOiAnJykpO1xuICAgICAgICAgICAgZmluZ2Vycy5wdXNoKGZpbmdlcik7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgZmluZ2VycHJpbnQ6ICcvJyArIGZpbmdlcnMuam9pbignLycpLFxuICAgICAgICBwYXJhbXNcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucGFyc2VQYXJhbXMgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuXG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBzZWdtZW50LnJlcGxhY2UoaW50ZXJuYWxzLnBhdGhSZWdleC5wYXJzZVBhcmFtLCAobWF0Y2gsIGxpdGVyYWwsIG5hbWUsIHdpbGNhcmQsIGNvdW50LCBlbXB0eSkgPT4ge1xuXG4gICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB3aWxjYXJkOiAhIXdpbGNhcmQsXG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50ICYmIHBhcnNlSW50KGNvdW50LCAxMCksXG4gICAgICAgICAgICAgICAgZW1wdHk6ICEhZW1wdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnRzO1xufTtcblxuXG5pbnRlcm5hbHMuUm91dGVyLnByb3RvdHlwZS50YWJsZSA9IGZ1bmN0aW9uIChob3N0KSB7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBjb2xsZWN0ID0gKHRhYmxlKSA9PiB7XG5cbiAgICAgICAgaWYgKCF0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXModGFibGUpLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuXG4gICAgICAgICAgICB0YWJsZVttZXRob2RdLnJvdXRlcy5mb3JFYWNoKChyZWNvcmQpID0+IHtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlY29yZC5yb3V0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLnZob3N0cykge1xuICAgICAgICBjb25zdCB2aG9zdHMgPSBob3N0ID8gW10uY29uY2F0KGhvc3QpIDogT2JqZWN0LmtleXModGhpcy52aG9zdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZob3N0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29sbGVjdCh0aGlzLnZob3N0c1t2aG9zdHNbaV1dKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbGxlY3QodGhpcy5yb3V0ZXMpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuaW50ZXJuYWxzLnNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgYUZpcnN0ID0gLTE7XG4gICAgY29uc3QgYkZpcnN0ID0gMTtcblxuICAgIGNvbnN0IGFzID0gYS5zZWdtZW50cztcbiAgICBjb25zdCBicyA9IGIuc2VnbWVudHM7XG5cbiAgICBpZiAoYXMubGVuZ3RoICE9PSBicy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIChhcy5sZW5ndGggPiBicy5sZW5ndGggPyBiRmlyc3QgOiBhRmlyc3QpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyA7ICsraSkge1xuICAgICAgICBpZiAoYXNbaV0ubGl0ZXJhbCkge1xuICAgICAgICAgICAgaWYgKGJzW2ldLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXNbaV0ubGl0ZXJhbCA9PT0gYnNbaV0ubGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGFzW2ldLmxpdGVyYWwgPiBic1tpXS5saXRlcmFsID8gYkZpcnN0IDogYUZpcnN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFGaXJzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChic1tpXS5saXRlcmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChhc1tpXS53aWxkY2FyZCA/IGJGaXJzdCA6IGFGaXJzdCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5nZW5lcmF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qXG4gICAgICAgIC9wYXRoL3twYXJhbX0vcGF0aC97cGFyYW0/fVxuICAgICAgICAvcGF0aC97cGFyYW0qMn0vcGF0aFxuICAgICAgICAvcGF0aC97cGFyYW0qMn1cbiAgICAgICAgL3BhdGgveHtwYXJhbX14XG4gICAgICAgIC97cGFyYW0qfVxuICAgICovXG5cbiAgICBjb25zdCBlbXB0eSA9ICcoPzpeXFxcXC8kKSc7XG5cbiAgICBjb25zdCBsZWdhbENoYXJzID0gJ1tcXFxcd1xcXFwhXFxcXCQmXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLDtcXFxcPVxcXFw6QFxcXFwtXFxcXC5+XSc7XG4gICAgY29uc3QgZW5jb2RlZCA9ICclW0EtRjAtOV17Mn0nO1xuXG4gICAgY29uc3QgbGl0ZXJhbENoYXIgPSAnKD86JyArIGxlZ2FsQ2hhcnMgKyAnfCcgKyBlbmNvZGVkICsgJyknO1xuICAgIGNvbnN0IGxpdGVyYWwgPSBsaXRlcmFsQ2hhciArICcrJztcbiAgICBjb25zdCBsaXRlcmFsT3B0aW9uYWwgPSBsaXRlcmFsQ2hhciArICcqJztcblxuICAgIGNvbnN0IG1pZFBhcmFtID0gJyg/OlxcXFx7XFxcXHcrKD86XFxcXCpbMS05XVxcXFxkKik/XFxcXH0pJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ge3B9LCB7cCoyfVxuICAgIGNvbnN0IGVuZFBhcmFtID0gJyg/OlxcXFwvKD86XFxcXHtcXFxcdysoPzooPzpcXFxcKig/OlsxLTldXFxcXGQqKT8pfCg/OlxcXFw/KSk/XFxcXH0pPyk/JzsgICAgIC8vIHtwfSwge3AqMn0sIHtwKn0sIHtwP31cblxuICAgIGNvbnN0IHBhcnRpYWxQYXJhbSA9ICcoPzpcXFxce1xcXFx3K1xcXFw/P1xcXFx9KSc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHtwfSwge3A/fVxuICAgIGNvbnN0IG1peGVkUGFyYW0gPSAnKD86KD86JyArIGxpdGVyYWwgKyBwYXJ0aWFsUGFyYW0gKyAnKSsnICsgbGl0ZXJhbE9wdGlvbmFsICsgJyl8KD86JyArIHBhcnRpYWxQYXJhbSArICcoPzonICsgbGl0ZXJhbCArIHBhcnRpYWxQYXJhbSArICcpKycgKyBsaXRlcmFsT3B0aW9uYWwgKyAnKXwoPzonICsgcGFydGlhbFBhcmFtICsgbGl0ZXJhbCArICcpJztcblxuICAgIGNvbnN0IHNlZ21lbnRDb250ZW50ID0gJyg/OicgKyBsaXRlcmFsICsgJ3wnICsgbWlkUGFyYW0gKyAnfCcgKyBtaXhlZFBhcmFtICsgJyknO1xuICAgIGNvbnN0IHNlZ21lbnQgPSAnXFxcXC8nICsgc2VnbWVudENvbnRlbnQ7XG4gICAgY29uc3Qgc2VnbWVudHMgPSAnKD86JyArIHNlZ21lbnQgKyAnKSonO1xuXG4gICAgY29uc3QgcGF0aCA9ICcoPzpeJyArIHNlZ21lbnRzICsgZW5kUGFyYW0gKyAnJCknO1xuXG4gICAgLy8gICAgICAgICAgICAgICAgMTpsaXRlcmFsICAgICAgICAgICAgICAgMjpuYW1lICAgMzoqICA0OmNvdW50ICA1Oj9cbiAgICBjb25zdCBwYXJzZVBhcmFtID0gJygnICsgbGl0ZXJhbCArICcpfCg/OlxcXFx7KFxcXFx3KykoPzooXFxcXCopKFxcXFxkKyk/KT8oXFxcXD8pP1xcXFx9KSc7XG5cbiAgICBjb25zdCBleHByZXNzaW9ucyA9IHtcbiAgICAgICAgcGFyc2VQYXJhbTogbmV3IFJlZ0V4cChwYXJzZVBhcmFtLCAnZycpLFxuICAgICAgICB2YWxpZGF0ZVBhdGg6IG5ldyBSZWdFeHAoZW1wdHkgKyAnfCcgKyBwYXRoKSxcbiAgICAgICAgdmFsaWRhdGVQYXRoRW5jb2RlZDogLyUoPzoyWzE0Ni05QS1FXXwzW1xcZEFCRF18NFtcXGRBLUZdfDVbXFxkQUZdfDZbMS05QS1GXXw3W1xcZEFFXSkvZ1xuICAgIH07XG5cbiAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5TZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5fZWRnZSA9IG51bGw7ICAgICAgICAgICAgICAvLyB7IHNlZ21lbnQsIHJlY29yZCB9XG4gICAgdGhpcy5fZnVsbHMgPSBudWxsOyAgICAgICAgICAgICAvLyB7IHBhdGg6IHsgc2VnbWVudCwgcmVjb3JkIH1cbiAgICB0aGlzLl9saXRlcmFscyA9IG51bGw7ICAgICAgICAgIC8vIHsgbGl0ZXJhbDogeyBzZWdtZW50LCA8bm9kZT4gfSB9XG4gICAgdGhpcy5fcGFyYW0gPSBudWxsOyAgICAgICAgICAgICAvLyA8bm9kZT5cbiAgICB0aGlzLl9taXhlZCA9IG51bGw7ICAgICAgICAgICAgIC8vIFt7IHNlZ21lbnQsIDxub2RlPiB9XVxuICAgIHRoaXMuX3dpbGRjYXJkID0gbnVsbDsgICAgICAgICAgLy8geyBzZWdtZW50LCByZWNvcmQgfVxufTtcblxuXG5pbnRlcm5hbHMuU2VnbWVudC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHNlZ21lbnRzLCByZWNvcmQpIHtcblxuICAgIC8qXG4gICAgICAgIHsgbGl0ZXJhbDogJ3gnIH0gICAgICAgIC0+IHhcbiAgICAgICAgeyBlbXB0eTogZmFsc2UgfSAgICAgICAgLT4ge3B9XG4gICAgICAgIHsgd2lsZGNhcmQ6IHRydWUgfSAgICAgIC0+IHtwKn1cbiAgICAgICAgeyBtaXhlZDogL3JlZ2V4LyB9ICAgICAgLT4gYXtwfWJcbiAgICAqL1xuXG4gICAgY29uc3QgY3VycmVudCA9IHNlZ21lbnRzWzBdO1xuICAgIGNvbnN0IHJlbWFpbmluZyA9IHNlZ21lbnRzLnNsaWNlKDEpO1xuICAgIGNvbnN0IGlzRWRnZSA9ICFyZW1haW5pbmcubGVuZ3RoO1xuXG4gICAgY29uc3QgbGl0ZXJhbHMgPSBbXTtcbiAgICBsZXQgaXNMaXRlcmFsID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAmJiBpc0xpdGVyYWw7ICsraSkge1xuICAgICAgICBpc0xpdGVyYWwgPSBzZWdtZW50c1tpXS5saXRlcmFsICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIGxpdGVyYWxzLnB1c2goc2VnbWVudHNbaV0ubGl0ZXJhbCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTGl0ZXJhbCkge1xuICAgICAgICB0aGlzLl9mdWxscyA9IHRoaXMuX2Z1bGxzIHx8IHt9O1xuICAgICAgICBsZXQgbGl0ZXJhbCA9ICcvJyArIGxpdGVyYWxzLmpvaW4oJy8nKTtcbiAgICAgICAgaWYgKCFyZWNvcmQuc2V0dGluZ3MuaXNDYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICBsaXRlcmFsID0gbGl0ZXJhbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIXRoaXMuX2Z1bGxzW2xpdGVyYWxdLCAnTmV3IHJvdXRlJywgcmVjb3JkLnBhdGgsICdjb25mbGljdHMgd2l0aCBleGlzdGluZycsIHRoaXMuX2Z1bGxzW2xpdGVyYWxdICYmIHRoaXMuX2Z1bGxzW2xpdGVyYWxdLnJlY29yZC5wYXRoKTtcbiAgICAgICAgdGhpcy5fZnVsbHNbbGl0ZXJhbF0gPSB7IHNlZ21lbnQ6IGN1cnJlbnQsIHJlY29yZCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW50LmxpdGVyYWwgIT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgICAgIC8vIENhbiBiZSBlbXB0eSBzdHJpbmdcblxuICAgICAgICAvLyBMaXRlcmFsXG5cbiAgICAgICAgdGhpcy5fbGl0ZXJhbHMgPSB0aGlzLl9saXRlcmFscyB8fCB7fTtcbiAgICAgICAgY29uc3QgY3VycmVudExpdGVyYWwgPSAocmVjb3JkLnNldHRpbmdzLmlzQ2FzZVNlbnNpdGl2ZSA/IGN1cnJlbnQubGl0ZXJhbCA6IGN1cnJlbnQubGl0ZXJhbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgdGhpcy5fbGl0ZXJhbHNbY3VycmVudExpdGVyYWxdID0gdGhpcy5fbGl0ZXJhbHNbY3VycmVudExpdGVyYWxdIHx8IG5ldyBpbnRlcm5hbHMuU2VnbWVudCgpO1xuICAgICAgICB0aGlzLl9saXRlcmFsc1tjdXJyZW50TGl0ZXJhbF0uYWRkKHJlbWFpbmluZywgcmVjb3JkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VycmVudC53aWxkY2FyZCkge1xuXG4gICAgICAgIC8vIFdpbGRjYXJkXG5cbiAgICAgICAgSG9lay5hc3NlcnQoIXRoaXMuX3dpbGRjYXJkLCAnTmV3IHJvdXRlJywgcmVjb3JkLnBhdGgsICdjb25mbGljdHMgd2l0aCBleGlzdGluZycsIHRoaXMuX3dpbGRjYXJkICYmIHRoaXMuX3dpbGRjYXJkLnJlY29yZC5wYXRoKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIXRoaXMuX3BhcmFtIHx8ICF0aGlzLl9wYXJhbS5fd2lsZGNhcmQsICdOZXcgcm91dGUnLCByZWNvcmQucGF0aCwgJ2NvbmZsaWN0cyB3aXRoIGV4aXN0aW5nJywgdGhpcy5fcGFyYW0gJiYgdGhpcy5fcGFyYW0uX3dpbGRjYXJkICYmIHRoaXMuX3BhcmFtLl93aWxkY2FyZC5yZWNvcmQucGF0aCk7XG4gICAgICAgIHRoaXMuX3dpbGRjYXJkID0geyBzZWdtZW50OiBjdXJyZW50LCByZWNvcmQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VycmVudC5taXhlZCkge1xuXG4gICAgICAgIC8vIE1peGVkXG5cbiAgICAgICAgdGhpcy5fbWl4ZWQgPSB0aGlzLl9taXhlZCB8fCBbXTtcblxuICAgICAgICBsZXQgbWl4ZWQgPSB0aGlzLl9taXhlZExvb2t1cChjdXJyZW50KTtcbiAgICAgICAgaWYgKCFtaXhlZCkge1xuICAgICAgICAgICAgbWl4ZWQgPSB7IHNlZ21lbnQ6IGN1cnJlbnQsIG5vZGU6IG5ldyBpbnRlcm5hbHMuU2VnbWVudCgpIH07XG4gICAgICAgICAgICB0aGlzLl9taXhlZC5wdXNoKG1peGVkKTtcbiAgICAgICAgICAgIHRoaXMuX21peGVkLnNvcnQoaW50ZXJuYWxzLm1peGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFtaXhlZC5ub2RlLl9lZGdlLCAnTmV3IHJvdXRlJywgcmVjb3JkLnBhdGgsICdjb25mbGljdHMgd2l0aCBleGlzdGluZycsIG1peGVkLm5vZGUuX2VkZ2UgJiYgbWl4ZWQubm9kZS5fZWRnZS5yZWNvcmQucGF0aCk7XG4gICAgICAgICAgICBtaXhlZC5ub2RlLl9lZGdlID0geyBzZWdtZW50OiBjdXJyZW50LCByZWNvcmQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1peGVkLm5vZGUuYWRkKHJlbWFpbmluZywgcmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICAvLyBQYXJhbWV0ZXJcblxuICAgICAgICB0aGlzLl9wYXJhbSA9IHRoaXMuX3BhcmFtIHx8IG5ldyBpbnRlcm5hbHMuU2VnbWVudCgpO1xuXG4gICAgICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCF0aGlzLl9wYXJhbS5fZWRnZSwgJ05ldyByb3V0ZScsIHJlY29yZC5wYXRoLCAnY29uZmxpY3RzIHdpdGggZXhpc3RpbmcnLCB0aGlzLl9wYXJhbS5fZWRnZSAmJiB0aGlzLl9wYXJhbS5fZWRnZS5yZWNvcmQucGF0aCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbS5fZWRnZSA9IHsgc2VnbWVudDogY3VycmVudCwgcmVjb3JkIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5fd2lsZGNhcmQgfHwgIXJlbWFpbmluZ1swXS53aWxkY2FyZCwgJ05ldyByb3V0ZScsIHJlY29yZC5wYXRoLCAnY29uZmxpY3RzIHdpdGggZXhpc3RpbmcnLCB0aGlzLl93aWxkY2FyZCAmJiB0aGlzLl93aWxkY2FyZC5yZWNvcmQucGF0aCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJhbS5hZGQocmVtYWluaW5nLCByZWNvcmQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuU2VnbWVudC5wcm90b3R5cGUuX21peGVkTG9va3VwID0gZnVuY3Rpb24gKHNlZ21lbnQpIHtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbWl4ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGludGVybmFscy5taXhlZCh7IHNlZ21lbnQgfSwgdGhpcy5fbWl4ZWRbaV0pID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWl4ZWRbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLm1peGVkID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIGNvbnN0IGFGaXJzdCA9IC0xO1xuICAgIGNvbnN0IGJGaXJzdCA9IDE7XG5cbiAgICBjb25zdCBhcyA9IGEuc2VnbWVudDtcbiAgICBjb25zdCBicyA9IGIuc2VnbWVudDtcblxuICAgIGlmIChhcy5sZW5ndGggIT09IGJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gKGFzLmxlbmd0aCA+IGJzLmxlbmd0aCA/IGFGaXJzdCA6IGJGaXJzdCk7XG4gICAgfVxuXG4gICAgaWYgKGFzLmZpcnN0ICE9PSBicy5maXJzdCkge1xuICAgICAgICByZXR1cm4gKGFzLmZpcnN0ID8gYkZpcnN0IDogYUZpcnN0KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzLnNlZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFtID0gYXMuc2VnbWVudHNbaV07XG4gICAgICAgIGNvbnN0IGJtID0gYnMuc2VnbWVudHNbaV07XG5cbiAgICAgICAgaWYgKGFtID09PSBibSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW0ubGVuZ3RoID09PSBibS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAoYW0gPiBibSA/IGJGaXJzdCA6IGFGaXJzdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGFtLmxlbmd0aCA8IGJtLmxlbmd0aCA/IGJGaXJzdCA6IGFGaXJzdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59O1xuXG5cbmludGVybmFscy5TZWdtZW50LnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAocGF0aCwgc2VnbWVudHMsIG9wdGlvbnMpIHtcblxuICAgIGxldCBtYXRjaCA9IG51bGw7XG5cbiAgICAvLyBMaXRlcmFsIGVkZ2VcblxuICAgIGlmICh0aGlzLl9mdWxscykge1xuICAgICAgICBtYXRjaCA9IHRoaXMuX2Z1bGxzW29wdGlvbnMuaXNDYXNlU2Vuc2l0aXZlID8gcGF0aCA6IHBhdGgudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVjb3JkOiBtYXRjaC5yZWNvcmQsIGFycmF5OiBbXSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGl0ZXJhbCBub2RlXG5cbiAgICBjb25zdCBjdXJyZW50ID0gc2VnbWVudHNbMF07XG4gICAgY29uc3QgbmV4dFBhdGggPSBwYXRoLnNsaWNlKGN1cnJlbnQubGVuZ3RoICsgMSk7XG4gICAgY29uc3QgcmVtYWluZGVyID0gKHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5zbGljZSgxKSA6IG51bGwpO1xuXG4gICAgaWYgKHRoaXMuX2xpdGVyYWxzKSB7XG4gICAgICAgIGNvbnN0IGxpdGVyYWwgPSBvcHRpb25zLmlzQ2FzZVNlbnNpdGl2ZSA/IGN1cnJlbnQgOiBjdXJyZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG1hdGNoID0gdGhpcy5fbGl0ZXJhbHMuaGFzT3duUHJvcGVydHkobGl0ZXJhbCkgJiYgdGhpcy5fbGl0ZXJhbHNbbGl0ZXJhbF07XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gaW50ZXJuYWxzLmRlZXBlcihtYXRjaCwgbmV4dFBhdGgsIHJlbWFpbmRlciwgW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNaXhlZFxuXG4gICAgaWYgKHRoaXMuX21peGVkKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbWl4ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG1hdGNoID0gdGhpcy5fbWl4ZWRbaV07XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjdXJyZW50Lm1hdGNoKG1hdGNoLnNlZ21lbnQubWl4ZWQpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXJhbXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaChwYXJhbXNbal0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IGludGVybmFscy5kZWVwZXIobWF0Y2gubm9kZSwgbmV4dFBhdGgsIHJlbWFpbmRlciwgYXJyYXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJhbVxuXG4gICAgaWYgKHRoaXMuX3BhcmFtKSB7XG4gICAgICAgIGlmIChjdXJyZW50IHx8XG4gICAgICAgICAgICAodGhpcy5fcGFyYW0uX2VkZ2UgJiYgdGhpcy5fcGFyYW0uX2VkZ2Uuc2VnbWVudC5lbXB0eSkpIHtcblxuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gaW50ZXJuYWxzLmRlZXBlcih0aGlzLl9wYXJhbSwgbmV4dFBhdGgsIHJlbWFpbmRlciwgW2N1cnJlbnRdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2lsZGNhcmRcblxuICAgIGlmICh0aGlzLl93aWxkY2FyZCkge1xuICAgICAgICByZXR1cm4geyByZWNvcmQ6IHRoaXMuX3dpbGRjYXJkLnJlY29yZCwgYXJyYXk6IFtwYXRoLnNsaWNlKDEpXSB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuZGVlcGVyID0gZnVuY3Rpb24gKG1hdGNoLCBwYXRoLCBzZWdtZW50cywgYXJyYXksIG9wdGlvbnMpIHtcblxuICAgIGlmICghc2VnbWVudHMpIHtcbiAgICAgICAgaWYgKG1hdGNoLl9lZGdlKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZWNvcmQ6IG1hdGNoLl9lZGdlLnJlY29yZCwgYXJyYXkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaC5fd2lsZGNhcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlY29yZDogbWF0Y2guX3dpbGRjYXJkLnJlY29yZCwgYXJyYXkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2gubG9va3VwKHBhdGgsIHNlZ21lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVjb3JkOiByZXN1bHQucmVjb3JkLCBhcnJheTogYXJyYXkuY29uY2F0KHJlc3VsdC5hcnJheSkgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1heFRpbWVyOiAyMTQ3NDgzNjQ3LCAgIC8vIDIgXiAzMSAtIDFcbiAgICBlbnRyeVNpemU6IDE0NCAgICAgICAgICAvLyBBcHByb3hpbWF0ZSBjYWNoZSBlbnRyeSBzaXplIHdpdGhvdXQgdmFsdWU6IDE0NCBieXRlc1xufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdHMgPSB7XG4gICAgbWF4Qnl0ZVNpemU6IDEwMCAqIDEwMjQgKiAxMDI0LCAgICAgICAgICAvLyAxMDBNQlxuICAgIG1pbkNsZWFudXBJbnRlcnZhbE1zZWM6IDEwMDAsXG4gICAgY2xvbmVCdWZmZXJzT25HZXQ6IGZhbHNlXG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Db25uZWN0aW9uID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5jb25zdHJ1Y3RvciA9PT0gaW50ZXJuYWxzLkNvbm5lY3Rpb24sICdNZW1vcnkgY2FjaGUgY2xpZW50IG11c3QgYmUgaW5zdGFudGlhdGVkIHVzaW5nIG5ldycpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLm1heEJ5dGVTaXplID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXhCeXRlU2l6ZSA+PSAwLCAnSW52YWxpZCBjYWNoZSBtYXhCeXRlU2l6ZSB2YWx1ZScpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmFsbG93TWl4ZWRDb250ZW50ID09PSB1bmRlZmluZWQsICdhbGxvd01peGVkQ29udGVudCBubyBsb25nZXIgc3VwcG9ydGVkJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMubWluQ2xlYW51cEludGVydmFsTXNlYyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWluQ2xlYW51cEludGVydmFsTXNlYyA8IGludGVybmFscy5tYXhUaW1lciwgJ0ludmFsaWQgY2FjaGUgbWluQ2xlYW51cEludGVydmFsTXNlYyB2YWx1ZScpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmNsb25lQnVmZmVyc09uR2V0ID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMuY2xvbmVCdWZmZXJzT25HZXQgPT09ICdib29sZWFuJywgJ0ludmFsaWQgY2xvbmVCdWZmZXJzT25HZXQgdmFsdWUnKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gSG9lay5hcHBseVRvRGVmYXVsdHMoaW50ZXJuYWxzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl90aW1lckR1ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5ieXRlU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2NoZWR1bGVDbGVhbnVwKG1zZWMpIHtcblxuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90aW1lckR1ZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IEluZmluaXR5O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbLCBzZWdtZW50XSBvZiB0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIGVudmVsb3BlXSBvZiBzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR0bCA9IGVudmVsb3BlLnN0b3JlZCArIGVudmVsb3BlLnR0bCAtIG5vdztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR0bCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50LmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ5dGVTaXplIC09IGVudmVsb3BlLmJ5dGVTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IE1hdGgubWluKG5leHQsIHR0bCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlQ2xlYW51cChuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oTWF0aC5tYXgodGhpcy5zZXR0aW5ncy5taW5DbGVhbnVwSW50ZXJ2YWxNc2VjLCBtc2VjKSwgaW50ZXJuYWxzLm1heFRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGltZXJEdWUgLSBub3cgPCBtc2VjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdGltZXJEdWUgPSBub3cgKyB0aW1lb3V0O1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoY2xlYW51cCwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpbWVyRHVlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmNhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgaXNSZWFkeSgpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLmNhY2hlO1xuICAgIH1cblxuICAgIHZhbGlkYXRlU2VnbWVudE5hbWUobmFtZSkge1xuXG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0VtcHR5IHN0cmluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignXFx1MDAwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0luY2x1ZGVzIG51bGwgY2hhcmFjdGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnQ29ubmVjdGlvbiBub3Qgc3RhcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuY2FjaGUuZ2V0KGtleS5zZWdtZW50KTtcbiAgICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0gc2VnbWVudC5nZXQoa2V5LmlkKTtcbiAgICAgICAgaWYgKCFlbnZlbG9wZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW52ZWxvcGUuc3RvcmVkICsgZW52ZWxvcGUudHRsIDwgRGF0ZS5ub3coKSkge1xuICAgICAgICAgICAgdGhpcy5kcm9wKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdGVtID0gbnVsbDtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlbnZlbG9wZS5pdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IGVudmVsb3BlLml0ZW07XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jbG9uZUJ1ZmZlcnNPbkdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcHkgPSBCdWZmZXIuYWxsb2MoaXRlbS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGl0ZW0uY29weShjb3B5KTtcbiAgICAgICAgICAgICAgICBpdGVtID0gY29weTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IEpTT04ucGFyc2UoZW52ZWxvcGUuaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0JhZCB2YWx1ZSBjb250ZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgc3RvcmVkOiBlbnZlbG9wZS5zdG9yZWQsXG4gICAgICAgICAgICB0dGw6IGVudmVsb3BlLnR0bFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgc2V0KGtleSwgdmFsdWUsIHR0bCkge1xuXG4gICAgICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0Nvbm5lY3Rpb24gbm90IHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVudmVsb3BlID0gbmV3IGludGVybmFscy5NZW1vcnlDYWNoZUVudHJ5KGtleSwgdmFsdWUsIHR0bCk7XG5cbiAgICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLmNhY2hlLmdldChrZXkuc2VnbWVudCk7XG4gICAgICAgIGlmICghc2VnbWVudCkge1xuICAgICAgICAgICAgc2VnbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleS5zZWdtZW50LCBzZWdtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhY2hlZEl0ZW0gPSBzZWdtZW50LmdldChrZXkuaWQpO1xuICAgICAgICBpZiAoY2FjaGVkSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5ieXRlU2l6ZSAtPSBjYWNoZWRJdGVtLmJ5dGVTaXplOyAgICAgICAvLyBJZiB0aGUgaXRlbSBleGlzdGVkLCBkZWNyZW1lbnQgdGhlIGJ5dGVTaXplIGFzIHRoZSB2YWx1ZSBjb3VsZCBiZSBkaWZmZXJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1heEJ5dGVTaXplICYmXG4gICAgICAgICAgICAodGhpcy5ieXRlU2l6ZSArIGVudmVsb3BlLmJ5dGVTaXplID4gdGhpcy5zZXR0aW5ncy5tYXhCeXRlU2l6ZSkpIHtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0NhY2hlIHNpemUgbGltaXQgcmVhY2hlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2NoZWR1bGVDbGVhbnVwKHR0bCk7XG4gICAgICAgIHNlZ21lbnQuc2V0KGtleS5pZCwgZW52ZWxvcGUpO1xuICAgICAgICB0aGlzLmJ5dGVTaXplICs9IGVudmVsb3BlLmJ5dGVTaXplO1xuICAgIH1cblxuICAgIGRyb3Aoa2V5KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnQ29ubmVjdGlvbiBub3Qgc3RhcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuY2FjaGUuZ2V0KGtleS5zZWdtZW50KTtcbiAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzZWdtZW50LmdldChrZXkuaWQpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVTaXplIC09IGl0ZW0uYnl0ZVNpemU7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5kZWxldGUoa2V5LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLk1lbW9yeUNhY2hlRW50cnkgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCB0dGwpIHtcblxuICAgICAgICBsZXQgdmFsdWVCeXRlU2l6ZSA9IDA7XG5cbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbSA9IEJ1ZmZlci5hbGxvYyh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgdmFsdWUuY29weSh0aGlzLml0ZW0pOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGJ1ZmZlciB0byBwcmV2ZW50IHZhbHVlIGZyb20gY2hhbmdpbmcgd2hpbGUgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICB2YWx1ZUJ5dGVTaXplID0gdGhpcy5pdGVtLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTsgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5naWZ5KCkgdG8gcHJldmVudCB2YWx1ZSBmcm9tIGNoYW5naW5nIHdoaWxlIGluIHRoZSBjYWNoZVxuICAgICAgICAgICAgdmFsdWVCeXRlU2l6ZSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHRoaXMuaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0b3JlZCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMudHRsID0gdHRsO1xuICAgICAgICB0aGlzLmJ5dGVTaXplID0gaW50ZXJuYWxzLmVudHJ5U2l6ZSArIHZhbHVlQnl0ZVNpemUgKyBCdWZmZXIuYnl0ZUxlbmd0aChrZXkuc2VnbWVudCkgKyBCdWZmZXIuYnl0ZUxlbmd0aChrZXkuaWQpO1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHZhbGlkYXRlOiBTeW1ib2woJ3ZhbGlkYXRlJylcbn07XG5cblxuaW50ZXJuYWxzLmRlZmF1bHRzID0ge1xuICAgIHBhcnRpdGlvbjogJ2NhdGJveCdcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChlbmdpbmUsICdNaXNzaW5nIGNhdGJveCBjbGllbnQgZW5naW5lJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBlbmdpbmUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBlbmdpbmUgPT09ICdmdW5jdGlvbicsICdlbmdpbmUgbXVzdCBiZSBhbiBlbmdpbmUgb2JqZWN0IG9yIGVuZ2luZSBwcm90b3R5cGUgKGZ1bmN0aW9uKScpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZW5naW5lID09PSAnZnVuY3Rpb24nIHx8ICFvcHRpb25zLCAnQ2FuIG9ubHkgc3BlY2lmeSBvcHRpb25zIHdpdGggZnVuY3Rpb24gZW5naW5lIGNvbmZpZycpO1xuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxzLmRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgSG9lay5hc3NlcnQoc2V0dGluZ3MucGFydGl0aW9uLm1hdGNoKC9eW1xcd1xcLV0rJC8pLCAnSW52YWxpZCBwYXJ0aXRpb24gbmFtZTonICsgc2V0dGluZ3MucGFydGl0aW9uKTtcblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSAodHlwZW9mIGVuZ2luZSA9PT0gJ29iamVjdCcgPyBlbmdpbmUgOiBuZXcgZW5naW5lKHNldHRpbmdzKSk7XG4gICAgfVxuXG4gICAgYXN5bmMgc3RhcnQoKSB7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgYXN5bmMgc3RvcCgpIHtcblxuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc3RvcCgpO1xuICAgIH1cblxuICAgIGlzUmVhZHkoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5pc1JlYWR5KCk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVTZWdtZW50TmFtZShuYW1lKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi52YWxpZGF0ZVNlZ21lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldChrZXkpIHtcblxuICAgICAgICB0aGlzW2ludGVybmFscy52YWxpZGF0ZV0oa2V5LCBudWxsKTtcblxuICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFyZXN1bHQgfHxcbiAgICAgICAgICAgIHJlc3VsdC5pdGVtID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHJlc3VsdC5pdGVtID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBleHBpcmVzID0gcmVzdWx0LnN0b3JlZCArIHJlc3VsdC50dGw7XG4gICAgICAgIGNvbnN0IHR0bCA9IGV4cGlyZXMgLSBub3c7XG4gICAgICAgIGlmICh0dGwgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBpcmVkXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYWNoZWQgPSB7XG4gICAgICAgICAgICBpdGVtOiByZXN1bHQuaXRlbSxcbiAgICAgICAgICAgIHN0b3JlZDogcmVzdWx0LnN0b3JlZCxcbiAgICAgICAgICAgIHR0bFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjYWNoZWQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkXG4gICAgfVxuXG4gICAgYXN5bmMgc2V0KGtleSwgdmFsdWUsIHR0bCkge1xuXG4gICAgICAgIHRoaXNbaW50ZXJuYWxzLnZhbGlkYXRlXShrZXkpO1xuXG4gICAgICAgIGlmICh0dGwgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgY2FjaGFibGUgKG9yIGJhZCBydWxlcylcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zZXQoa2V5LCB2YWx1ZSwgdHRsKTtcbiAgICB9XG5cbiAgICBhc3luYyBkcm9wKGtleSkge1xuXG4gICAgICAgIHRoaXNbaW50ZXJuYWxzLnZhbGlkYXRlXShrZXkpO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5kcm9wKGtleSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIGRyb3AsIHJlZ2FyZGxlc3Mgb2YgY2FjaGluZyBydWxlc1xuICAgIH1cblxuICAgIFtpbnRlcm5hbHMudmFsaWRhdGVdKGtleSwgYWxsb3cgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uaW50ZXJuYWwoJ0Rpc2Nvbm5lY3RlZCcpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzY29ubmVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1ZhbGlkS2V5ID0gKGtleSAmJiB0eXBlb2Yga2V5LmlkID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleS5zZWdtZW50ICYmIHR5cGVvZiBrZXkuc2VnbWVudCA9PT0gJ3N0cmluZycpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZEtleSAmJiBrZXkgIT09IGFsbG93KSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmludGVybmFsKCdJbnZhbGlkIGtleScpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKTtcbmNvbnN0IFBvbGljeSA9IHJlcXVpcmUoJy4vcG9saWN5Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG5cblxuZXhwb3J0cy5Qb2xpY3kgPSBleHBvcnRzLnBvbGljeSA9IFBvbGljeTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoaWQsIHJ1bGUpIHtcblxuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgIHRoaXMucnVsZSA9IHJ1bGU7XG5cbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGpvaW4oKSB7XG5cbiAgICAgICAgKyt0aGlzLmNvdW50O1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cblxuICAgIHNlbmQoZXJyLCB2YWx1ZSwgY2FjaGVkLCByZXBvcnQpIHtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpO1xuXG4gICAgICAgIGlmIChlcnIgJiZcbiAgICAgICAgICAgICFjYWNoZWQpIHtcblxuICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5ydWxlLmdldERlY29yYXRlZFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVwb3J0LmVycm9yID0gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlKHsgdmFsdWUsIGNhY2hlZCwgcmVwb3J0IH0pO1xuICAgIH1cblxuICAgIHNldFRpbWVvdXQoZm4sIHRpbWVvdXRNcykge1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmbiwgdGltZW91dE1zKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IEpvaSA9IHJlcXVpcmUoJ0BoYXBpL2pvaScpO1xuY29uc3QgUG9kaXVtID0gcmVxdWlyZSgnQGhhcGkvcG9kaXVtJyk7XG5cbmNvbnN0IFBlbmRpbmcgPSByZXF1aXJlKCcuL3BlbmRpbmcnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgZGF5OiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIGV2ZW50czogUG9kaXVtLnZhbGlkYXRlKFtcbiAgICAgICAgeyBuYW1lOiAnZXJyb3InLCBjaGFubmVsczogWydnZW5lcmF0ZScsICdwZXJzaXN0J10gfVxuICAgIF0pXG59O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBKb2kub2JqZWN0KHtcbiAgICBleHBpcmVzSW46IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDEpLFxuICAgIGV4cGlyZXNBdDogSm9pLnN0cmluZygpLnJlZ2V4KC9eXFxkXFxkP1xcOlxcZFxcZCQvKSxcbiAgICBzdGFsZUluOiBbXG4gICAgICAgIEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDEpLndoZW4oJ2V4cGlyZXNBdCcsIHsgaXM6IEpvaS5yZXF1aXJlZCgpLCB0aGVuOiBKb2kubnVtYmVyKCkubWF4KDg2NDAwMDAwIC0gMSkgfSksICAgICAgIC8vIE9uZSBkYXkgLSAxIChtYXggaXMgaW5jbHVzaXZlKVxuICAgICAgICBKb2kuZnVuYygpXG4gICAgXSxcbiAgICBzdGFsZVRpbWVvdXQ6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDEpLFxuICAgIGdlbmVyYXRlRnVuYzogSm9pLmZ1bmMoKSxcbiAgICBnZW5lcmF0ZVRpbWVvdXQ6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDEpLmFsbG93KGZhbHNlKSxcbiAgICBnZW5lcmF0ZU9uUmVhZEVycm9yOiBKb2kuYm9vbGVhbigpLFxuICAgIGdlbmVyYXRlSWdub3JlV3JpdGVFcnJvcjogSm9pLmJvb2xlYW4oKSxcbiAgICBkcm9wT25FcnJvcjogSm9pLmJvb2xlYW4oKSxcbiAgICBwZW5kaW5nR2VuZXJhdGVUaW1lb3V0OiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLm1pbigxKSxcbiAgICBnZXREZWNvcmF0ZWRWYWx1ZTogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcblxuICAgIC8vIElnbm9yZWQgZXh0ZXJuYWwga2V5cyAoaGFwaSlcblxuICAgIHByaXZhY3k6IEpvaS5hbnkoKSxcbiAgICBjYWNoZTogSm9pLmFueSgpLFxuICAgIHNlZ21lbnQ6IEpvaS5hbnkoKSxcbiAgICBzaGFyZWQ6IEpvaS5hbnkoKVxufSlcbiAgICAud2l0aG91dCgnZXhwaXJlc0luJywgJ2V4cGlyZXNBdCcpXG4gICAgLndpdGgoJ3N0YWxlSW4nLCAnZ2VuZXJhdGVGdW5jJylcbiAgICAud2l0aCgnZ2VuZXJhdGVPblJlYWRFcnJvcicsICdnZW5lcmF0ZUZ1bmMnKVxuICAgIC53aXRoKCdnZW5lcmF0ZUlnbm9yZVdyaXRlRXJyb3InLCAnZ2VuZXJhdGVGdW5jJylcbiAgICAud2l0aCgnZHJvcE9uRXJyb3InLCAnZ2VuZXJhdGVGdW5jJylcbiAgICAuYW5kKCdnZW5lcmF0ZUZ1bmMnLCAnZ2VuZXJhdGVUaW1lb3V0JylcbiAgICAuYW5kKCdzdGFsZUluJywgJ3N0YWxlVGltZW91dCcpO1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Qb2xpY3kgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWNoZSwgc2VnbWVudCkge1xuXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gY2FjaGU7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdzID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gaWQgLT4gUGVuZGluZ1xuICAgICAgICB0aGlzLl9wZW5kaW5nR2VuZXJhdGVDYWxsID0gbmV3IE1hcCgpOyAgICAgICAgICAgIC8vIGlkIC0+IHRpbWVyXG4gICAgICAgIHRoaXMucnVsZXMob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgICAgIHNldHM6IDAsXG4gICAgICAgICAgICBnZXRzOiAwLFxuICAgICAgICAgICAgaGl0czogMCxcbiAgICAgICAgICAgIHN0YWxlczogMCxcbiAgICAgICAgICAgIGdlbmVyYXRlczogMCxcbiAgICAgICAgICAgIGVycm9yczogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZUVyciA9IGNhY2hlLnZhbGlkYXRlU2VnbWVudE5hbWUoc2VnbWVudCk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChuYW1lRXJyID09PSBudWxsLCAnSW52YWxpZCBzZWdtZW50IG5hbWU6ICcgKyBzZWdtZW50ICsgKG5hbWVFcnIgPyAnICgnICsgbmFtZUVyci5tZXNzYWdlICsgJyknIDogJycpKTtcblxuICAgICAgICAgICAgdGhpcy5fc2VnbWVudCA9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZXZlbnRzKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgUG9kaXVtKGludGVybmFscy5ldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cztcbiAgICB9XG5cbiAgICBfZXJyb3Ioc291cmNlLCBlcnJvcikge1xuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudHMuZW1pdCh7IG5hbWU6ICdlcnJvcicsIGNoYW5uZWw6IHNvdXJjZSB9LCB7IHNvdXJjZSwgZXJyb3IgfSk7XG4gICAgfVxuXG4gICAgcnVsZXMob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucnVsZSA9IGludGVybmFscy5Qb2xpY3kuY29tcGlsZShvcHRpb25zLCAhIXRoaXMuX2NhY2hlKTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXQoa2V5KSB7ICAgICAvLyBrZXk6IHN0cmluZyBvciB7IGlkOiAnaWQnIH1cblxuICAgICAgICArK3RoaXMuc3RhdHMuZ2V0cztcblxuICAgICAgICAvLyBDaGVjayBpZiByZXF1ZXN0IGlzIGFscmVhZHkgcGVuZGluZ1xuXG4gICAgICAgIGNvbnN0IGlkID0gKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JykgPyBrZXkuaWQgOiBrZXk7XG4gICAgICAgIGxldCBwZW5kaW5nID0gdGhpcy5fcGVuZGluZ3MuZ2V0KGlkKTtcbiAgICAgICAgaWYgKHBlbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHBlbmRpbmcuam9pbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGVuZGluZyA9IG5ldyBQZW5kaW5nKGlkLCB0aGlzLnJ1bGUpO1xuICAgICAgICB0aGlzLl9wZW5kaW5ncy5zZXQoaWQsIHBlbmRpbmcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9nZXQocGVuZGluZywga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kKHBlbmRpbmcsIGVycik7ICAgICAgICAgICAgICAgLy8gU2FmZWd1YXJkIHRvIGVuc3VyZSB0aGF0IHRoZSBwZW5kaW5nIHJlamVjdHMgb24gYW55IHByb2Nlc3NpbmcgZXJyb3JzXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGVuZGluZy5wcm9taXNlO1xuICAgIH1cblxuICAgIGFzeW5jIF9nZXQocGVuZGluZywga2V5KSB7XG5cbiAgICAgICAgLy8gUHJlcGFyZSByZXBvcnRcblxuICAgICAgICBjb25zdCByZXBvcnQgPSB7fTtcblxuICAgICAgICAvLyBMb29rdXAgaW4gY2FjaGVcblxuICAgICAgICBjb25zdCB0aW1lciA9IG5ldyBIb2VrLkJlbmNoKCk7XG5cbiAgICAgICAgbGV0IGNhY2hlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYWNoZWQgPSBhd2FpdCB0aGlzLl9jYWNoZS5nZXQoeyBzZWdtZW50OiB0aGlzLl9zZWdtZW50LCBpZDogcGVuZGluZy5pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXBvcnQuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgKyt0aGlzLnN0YXRzLmVycm9ycztcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcigncGVyc2lzdCcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXBvcnQubXNlYyA9IHRpbWVyLmVsYXBzZWQoKTtcblxuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXBvcnQuc3RvcmVkID0gY2FjaGVkLnN0b3JlZDtcbiAgICAgICAgICAgIHJlcG9ydC50dGwgPSBjYWNoZWQudHRsO1xuICAgICAgICAgICAgY29uc3Qgc3RhbGVJbiA9IHR5cGVvZiB0aGlzLnJ1bGUuc3RhbGVJbiA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMucnVsZS5zdGFsZUluKGNhY2hlZC5zdG9yZWQsIGNhY2hlZC50dGwpIDogdGhpcy5ydWxlLnN0YWxlSW47XG4gICAgICAgICAgICBjYWNoZWQuaXNTdGFsZSA9IChzdGFsZUluID8gKERhdGUubm93KCkgLSBjYWNoZWQuc3RvcmVkKSA+PSBzdGFsZUluIDogZmFsc2UpO1xuICAgICAgICAgICAgcmVwb3J0LmlzU3RhbGUgPSBjYWNoZWQuaXNTdGFsZTtcblxuICAgICAgICAgICAgaWYgKGNhY2hlZC5pc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgKyt0aGlzLnN0YXRzLnN0YWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIGdlbmVyYXRlIG1ldGhvZFxuXG4gICAgICAgIGlmICghdGhpcy5ydWxlLmdlbmVyYXRlRnVuYyB8fFxuICAgICAgICAgICAgKHJlcG9ydC5lcnJvciAmJiAhdGhpcy5ydWxlLmdlbmVyYXRlT25SZWFkRXJyb3IpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3NlbmQocGVuZGluZywgcmVwb3J0LmVycm9yLCBjYWNoZWQgPyBjYWNoZWQuaXRlbSA6IG51bGwsIGNhY2hlZCwgcmVwb3J0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGZvdW5kIGFuZCBmcmVzaFxuXG4gICAgICAgIGlmIChjYWNoZWQgJiZcbiAgICAgICAgICAgICFjYWNoZWQuaXNTdGFsZSkge1xuXG4gICAgICAgICAgICB0aGlzLl9zZW5kKHBlbmRpbmcsIG51bGwsIGNhY2hlZC5pdGVtLCBjYWNoZWQsIHJlcG9ydCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IHVudGlsIGdlbmVyYXRlZCBvciBvdGhlcndpc2UgcmVzb2x2ZWRcblxuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgcGVuZGluZy5wcm9taXNlLFxuICAgICAgICAgICAgdGhpcy5fZ2VuZXJhdGUocGVuZGluZywga2V5LCBjYWNoZWQsIHJlcG9ydClcbiAgICAgICAgXSk7XG4gICAgfVxuXG4gICAgX2dlbmVyYXRlKHBlbmRpbmcsIGtleSwgY2FjaGVkLCByZXBvcnQpIHtcblxuICAgICAgICBpZiAoY2FjaGVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBzdGFsZVxuXG4gICAgICAgICAgICAvLyBTZXQgc3RhbGUgdGltZW91dFxuXG4gICAgICAgICAgICBjYWNoZWQudHRsID0gY2FjaGVkLnR0bCAtIHRoaXMucnVsZS5zdGFsZVRpbWVvdXQ7ICAgICAgIC8vIEFkanVzdCBUVEwgZm9yIHdoZW4gdGhlIHRpbWVvdXQgaXMgaW52b2tlZCAoc3RhbGVUaW1lb3V0IG11c3QgYmUgdmFsaWQgaWYgaXNTdGFsZSBpcyB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlZCAmJlxuICAgICAgICAgICAgY2FjaGVkLnR0bCA+IDApIHtcblxuICAgICAgICAgICAgcGVuZGluZy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX3NlbmQocGVuZGluZywgbnVsbCwgY2FjaGVkLml0ZW0sIGNhY2hlZCwgcmVwb3J0KSwgdGhpcy5ydWxlLnN0YWxlVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ydWxlLmdlbmVyYXRlVGltZW91dCkge1xuXG4gICAgICAgICAgICAvLyBTZXQgaXRlbSBnZW5lcmF0aW9uIHRpbWVvdXQgKHdoZW4gbm90IGluIGNhY2hlKVxuXG4gICAgICAgICAgICBwZW5kaW5nLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2VuZChwZW5kaW5nLCBCb29tLnNlcnZlclVuYXZhaWxhYmxlKCksIG51bGwsIG51bGwsIHJlcG9ydCksIHRoaXMucnVsZS5nZW5lcmF0ZVRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBnZW5lcmF0ZSBjYWxsIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3NcblxuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0dlbmVyYXRlQ2FsbC5oYXMocGVuZGluZy5pZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIG5ldyB2YWx1ZVxuXG4gICAgICAgICsrdGhpcy5zdGF0cy5nZW5lcmF0ZXM7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIGdlbmVyYXRpb24gYmVmb3JlIGNhbGwgaW4gY2FzZSBpdCB0aW1lcyBvdXRcblxuICAgICAgICBpZiAodGhpcy5ydWxlLnBlbmRpbmdHZW5lcmF0ZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3BlbmRpbmdHZW5lcmF0ZUNhbGwuZGVsZXRlKHBlbmRpbmcuaWQpLCB0aGlzLnJ1bGUucGVuZGluZ0dlbmVyYXRlVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nR2VuZXJhdGVDYWxsLnNldChwZW5kaW5nLmlkLCB0aW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsR2VuZXJhdGVGdW5jKHBlbmRpbmcsIGtleSwgY2FjaGVkLCByZXBvcnQpO1xuICAgIH1cblxuICAgIGFzeW5jIF9jYWxsR2VuZXJhdGVGdW5jKHBlbmRpbmcsIGtleSwgY2FjaGVkLCByZXBvcnQpIHtcblxuICAgICAgICBjb25zdCBmbGFncyA9IHt9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhd2FpdCB0aGlzLnJ1bGUuZ2VuZXJhdGVGdW5jKGtleSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHZhciBnZW5lcmF0ZUVycm9yID0gZXJyO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoJ2dlbmVyYXRlJywgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBlbmRpbmdUaW1lb3V0ID0gdGhpcy5fcGVuZGluZ0dlbmVyYXRlQ2FsbC5nZXQocGVuZGluZy5pZCk7XG4gICAgICAgIGlmIChwZW5kaW5nVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBlbmRpbmdUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdHZW5lcmF0ZUNhbGwuZGVsZXRlKHBlbmRpbmcuaWQpO1xuXG4gICAgICAgICAgICBwZW5kaW5nID0gdGhpcy5fcGVuZGluZ3MuZ2V0KHBlbmRpbmcuaWQpIHx8IHBlbmRpbmc7ICAgICAgICAgICAgICAgICAgICAvLyBGZXRjaCBsYXRlc3QgLSBpdCBtaWdodCBoYXZlIGNoYW5nZWRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVycm9yIChpZiBkcm9wT25FcnJvciBpcyBub3Qgc2V0IHRvIGZhbHNlKSBvciBub3QgY2FjaGVkXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmbGFncy50dGwgPT09IDAgfHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgb3IgdW5kZWZpbmVkIG1lYW5zIHVzZSBwb2xpY3lcbiAgICAgICAgICAgICAgICAoZ2VuZXJhdGVFcnJvciAmJiB0aGlzLnJ1bGUuZHJvcE9uRXJyb3IpKSB7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRyb3AocGVuZGluZy5pZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgY2FjaGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFnZW5lcmF0ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQocGVuZGluZy5pZCwgdmFsdWUsIGZsYWdzLnR0bCk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHN0YWxlIGNhY2hlIGNvcHkgd2l0aCBsYXRlLWNvbWluZyBmcmVzaCBjb3B5XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKCdwZXJzaXN0JywgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9yID0gZ2VuZXJhdGVFcnJvciB8fCAodGhpcy5ydWxlLmdlbmVyYXRlSWdub3JlV3JpdGVFcnJvciA/IG51bGwgOiBwZXJzaXN0RXJyb3IpO1xuICAgICAgICBpZiAoY2FjaGVkICYmXG4gICAgICAgICAgICBlcnJvciAmJlxuICAgICAgICAgICAgIXRoaXMucnVsZS5kcm9wT25FcnJvcikge1xuXG4gICAgICAgICAgICB0aGlzLl9zZW5kKHBlbmRpbmcsIGVycm9yLCBjYWNoZWQuaXRlbSwgY2FjaGVkLCByZXBvcnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2VuZChwZW5kaW5nLCBlcnJvciwgdmFsdWUsIG51bGwsIHJlcG9ydCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZWQgaWYgc3RhbGUgdmFsdWUgYWxyZWFkeSByZXR1cm5lZFxuICAgIH1cblxuICAgIF9zZW5kKHBlbmRpbmcsIGVyciwgdmFsdWUsIGNhY2hlZCwgcmVwb3J0KSB7XG5cbiAgICAgICAgcGVuZGluZy5zZW5kKGVyciwgdmFsdWUsIGNhY2hlZCwgcmVwb3J0KTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ3MuZGVsZXRlKHBlbmRpbmcuaWQpO1xuXG4gICAgICAgIGlmIChyZXBvcnQgJiYgcmVwb3J0LmlzU3RhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0cy5oaXRzID0gdGhpcy5zdGF0cy5oaXRzICsgcGVuZGluZy5jb3VudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHNldChrZXksIHZhbHVlLCB0dGwpIHtcblxuICAgICAgICArK3RoaXMuc3RhdHMuc2V0cztcblxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0dGwgPSB0dGwgfHwgaW50ZXJuYWxzLlBvbGljeS50dGwodGhpcy5ydWxlKTtcbiAgICAgICAgY29uc3QgaWQgPSAoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSA/IGtleS5pZCA6IGtleTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FjaGUuc2V0KHsgc2VnbWVudDogdGhpcy5fc2VnbWVudCwgaWQgfSwgdmFsdWUsIHR0bCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRzLmVycm9ycztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGRyb3Aoa2V5KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWQgPSAoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSA/IGtleS5pZCA6IGtleTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY2FjaGUuZHJvcCh7IHNlZ21lbnQ6IHRoaXMuX3NlZ21lbnQsIGlkIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0cy5lcnJvcnM7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0dGwoY3JlYXRlZCkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuUG9saWN5LnR0bCh0aGlzLnJ1bGUsIGNyZWF0ZWQpO1xuICAgIH1cblxuICAgIGlzUmVhZHkoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmNvbm5lY3Rpb24uaXNSZWFkeSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb21waWxlKG9wdGlvbnMsIHNlcnZlclNpZGUpIHtcblxuICAgICAgICAvKlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNJbjogMzAwMDAsXG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0OiAnMTM6MDAnLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRnVuYzogKGlkLCBmbGFncykgPT4geyB0aHJvdyBlcnI7IH0gLyB7IHJldHVybiByZXN1bHQ7IH0gLyB7IGZsYWdzLnR0bCA9IHR0bDsgcmV0dXJuIHJlc3VsdDsgfVxuICAgICAgICAgICAgICAgIGdlbmVyYXRlVGltZW91dDogNTAwLFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlT25SZWFkRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVJZ25vcmVXcml0ZUVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0YWxlSW46IDIwMDAwLFxuICAgICAgICAgICAgICAgIHN0YWxlVGltZW91dDogNTAwLFxuICAgICAgICAgICAgICAgIGRyb3BPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldERlY29yYXRlZFZhbHVlOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgKi9cblxuICAgICAgICBjb25zdCBydWxlID0ge307XG5cbiAgICAgICAgaWYgKCFvcHRpb25zIHx8XG4gICAgICAgICAgICAhT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcnVsZVxuXG4gICAgICAgIG9wdGlvbnMgPSBKb2kuYXR0ZW1wdChvcHRpb25zLCBpbnRlcm5hbHMuc2NoZW1hLCAnSW52YWxpZCBjYWNoZSBwb2xpY3kgY29uZmlndXJhdGlvbicpO1xuXG4gICAgICAgIGNvbnN0IGhhc0V4cGlyZXNJbiA9IG9wdGlvbnMuZXhwaXJlc0luICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5leHBpcmVzSW4gIT09IG51bGw7XG4gICAgICAgIGNvbnN0IGhhc0V4cGlyZXNBdCA9IG9wdGlvbnMuZXhwaXJlc0F0ICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5leHBpcmVzQXQgIT09IG51bGw7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIWhhc0V4cGlyZXNJbiB8fCAhb3B0aW9ucy5zdGFsZUluIHx8IHR5cGVvZiBvcHRpb25zLnN0YWxlSW4gPT09ICdmdW5jdGlvbicgfHwgb3B0aW9ucy5zdGFsZUluIDwgb3B0aW9ucy5leHBpcmVzSW4sICdzdGFsZUluIG11c3QgYmUgbGVzcyB0aGFuIGV4cGlyZXNJbicpO1xuICAgICAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5zdGFsZUluIHx8IHNlcnZlclNpZGUsICdDYW5ub3QgdXNlIHN0YWxlIG9wdGlvbnMgd2l0aG91dCBzZXJ2ZXItc2lkZSBjYWNoaW5nJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLnN0YWxlVGltZW91dCB8fCAhaGFzRXhwaXJlc0luIHx8IG9wdGlvbnMuc3RhbGVUaW1lb3V0IDwgb3B0aW9ucy5leHBpcmVzSW4sICdzdGFsZVRpbWVvdXQgbXVzdCBiZSBsZXNzIHRoYW4gZXhwaXJlc0luJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLnN0YWxlVGltZW91dCB8fCAhaGFzRXhwaXJlc0luIHx8IHR5cGVvZiBvcHRpb25zLnN0YWxlSW4gPT09ICdmdW5jdGlvbicgfHwgb3B0aW9ucy5zdGFsZVRpbWVvdXQgPCAob3B0aW9ucy5leHBpcmVzSW4gLSBvcHRpb25zLnN0YWxlSW4pLCAnc3RhbGVUaW1lb3V0IG11c3QgYmUgbGVzcyB0aGFuIHRoZSBkZWx0YSBiZXR3ZWVuIGV4cGlyZXNJbiBhbmQgc3RhbGVJbicpO1xuICAgICAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5zdGFsZVRpbWVvdXQgfHwgIW9wdGlvbnMucGVuZGluZ0dlbmVyYXRlVGltZW91dCB8fCBvcHRpb25zLnN0YWxlVGltZW91dCA8IG9wdGlvbnMucGVuZGluZ0dlbmVyYXRlVGltZW91dCwgJ3BlbmRpbmdHZW5lcmF0ZVRpbWVvdXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhbGVUaW1lb3V0IGlmIHNwZWNpZmllZCcpO1xuXG4gICAgICAgIC8vIEV4cGlyYXRpb25cblxuICAgICAgICBpZiAoaGFzRXhwaXJlc0F0KSB7XG5cbiAgICAgICAgICAgIC8vIGV4cGlyZXNBdFxuXG4gICAgICAgICAgICBjb25zdCB0aW1lID0gL14oXFxkXFxkPyk6KFxcZFxcZCkkLy5leGVjKG9wdGlvbnMuZXhwaXJlc0F0KTtcbiAgICAgICAgICAgIHJ1bGUuZXhwaXJlc0F0ID0ge1xuICAgICAgICAgICAgICAgIGhvdXJzOiBwYXJzZUludCh0aW1lWzFdLCAxMCksXG4gICAgICAgICAgICAgICAgbWludXRlczogcGFyc2VJbnQodGltZVsyXSwgMTApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBleHBpcmVzSW5cblxuICAgICAgICAgICAgcnVsZS5leHBpcmVzSW4gPSBvcHRpb25zLmV4cGlyZXNJbiB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2VuZXJhdGVUaW1lb3V0XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZ2VuZXJhdGVGdW5jKSB7XG4gICAgICAgICAgICBydWxlLmdlbmVyYXRlRnVuYyA9IG9wdGlvbnMuZ2VuZXJhdGVGdW5jO1xuICAgICAgICAgICAgcnVsZS5nZW5lcmF0ZVRpbWVvdXQgPSBvcHRpb25zLmdlbmVyYXRlVGltZW91dDtcblxuICAgICAgICAgICAgLy8gU3RhbGVcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhbGVJbikge1xuICAgICAgICAgICAgICAgIHJ1bGUuc3RhbGVJbiA9IG9wdGlvbnMuc3RhbGVJbjtcbiAgICAgICAgICAgICAgICBydWxlLnN0YWxlVGltZW91dCA9IG9wdGlvbnMuc3RhbGVUaW1lb3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBydWxlLmRyb3BPbkVycm9yID0gb3B0aW9ucy5kcm9wT25FcnJvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kcm9wT25FcnJvciA6IHRydWU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgcnVsZS5wZW5kaW5nR2VuZXJhdGVUaW1lb3V0ID0gb3B0aW9ucy5wZW5kaW5nR2VuZXJhdGVUaW1lb3V0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnBlbmRpbmdHZW5lcmF0ZVRpbWVvdXQgOiAwOyAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHplcm9cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bGUuZ2VuZXJhdGVPblJlYWRFcnJvciA9IG9wdGlvbnMuZ2VuZXJhdGVPblJlYWRFcnJvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5nZW5lcmF0ZU9uUmVhZEVycm9yIDogdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICBydWxlLmdlbmVyYXRlSWdub3JlV3JpdGVFcnJvciA9IG9wdGlvbnMuZ2VuZXJhdGVJZ25vcmVXcml0ZUVycm9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlSWdub3JlV3JpdGVFcnJvciA6IHRydWU7ICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcblxuICAgICAgICAvLyBEZWNvcmF0aW9uc1xuXG4gICAgICAgIHJ1bGUuZ2V0RGVjb3JhdGVkVmFsdWUgPSBvcHRpb25zLmdldERlY29yYXRlZFZhbHVlO1xuXG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIHN0YXRpYyB0dGwocnVsZSwgY3JlYXRlZCwgbm93KSB7XG5cbiAgICAgICAgbm93ID0gbm93IHx8IERhdGUubm93KCk7XG4gICAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IG5vdztcbiAgICAgICAgY29uc3QgYWdlID0gbm93IC0gY3JlYXRlZDtcblxuICAgICAgICBpZiAoYWdlIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZWQgaW4gdGhlIGZ1dHVyZSwgYXNzdW1lIGV4cGlyZWQvYmFkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZS5leHBpcmVzSW4pIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChydWxlLmV4cGlyZXNJbiAtIGFnZSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZS5leHBpcmVzQXQpIHtcbiAgICAgICAgICAgIGlmIChhZ2UgPiBpbnRlcm5hbHMuZGF5KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaXRlbSB3YXMgY3JlYXRlZCBtb3JlIHRoYW4gYSAyNCBob3VycyBhZ29cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0F0ID0gbmV3IERhdGUoY3JlYXRlZCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZXhwaXJhdGlvbiB0aW1lIG9uIHRoZSBzYW1lIGRheVxuICAgICAgICAgICAgZXhwaXJlc0F0LnNldEhvdXJzKHJ1bGUuZXhwaXJlc0F0LmhvdXJzKTtcbiAgICAgICAgICAgIGV4cGlyZXNBdC5zZXRNaW51dGVzKHJ1bGUuZXhwaXJlc0F0Lm1pbnV0ZXMpO1xuICAgICAgICAgICAgZXhwaXJlc0F0LnNldFNlY29uZHMoMCk7XG4gICAgICAgICAgICBleHBpcmVzQXQuc2V0TWlsbGlzZWNvbmRzKDApO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXMgPSBleHBpcmVzQXQuZ2V0VGltZSgpO1xuXG4gICAgICAgICAgICBpZiAoZXhwaXJlcyA8PSBjcmVhdGVkKSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlcyA9IGV4cGlyZXMgKyBpbnRlcm5hbHMuZGF5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIHRvbW9ycm93XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub3cgPj0gZXhwaXJlcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGlyZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGV4cGlyZXMgLSBub3c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHJ1bGVcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbi8qXG4gICAgUkZDIDcyMzEgU2VjdGlvbiAzLjEuMS4xXG5cbiAgICBtZWRpYS10eXBlID0gdHlwZSBcIi9cIiBzdWJ0eXBlICooIE9XUyBcIjtcIiBPV1MgcGFyYW1ldGVyIClcbiAgICB0eXBlICAgICAgID0gdG9rZW5cbiAgICBzdWJ0eXBlICAgID0gdG9rZW5cbiAgICBwYXJhbWV0ZXIgID0gdG9rZW4gXCI9XCIgKCB0b2tlbiAvIHF1b3RlZC1zdHJpbmcgKVxuKi9cblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE6IHR5cGUvc3VidHlwZSAgICAyOiBwYXJhbXNcbmludGVybmFscy5jb250ZW50VHlwZVJlZ2V4ID0gL14oW15cXC9cXHNdK1xcL1teXFxzO10rKSguKik/JC87XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE6IFwiYlwiICAgMjogYlxuaW50ZXJuYWxzLnBhcmFtc1JlZ2V4ID0gLztcXHMqYm91bmRhcnk9KD86XCIoW15cIl0rKVwifChbXjtcIlxcc10rKSkvaTtcblxuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG5cbiAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29udGVudC10eXBlIGhlYWRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gaGVhZGVyLm1hdGNoKGludGVybmFscy5jb250ZW50VHlwZVJlZ2V4KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb250ZW50LXR5cGUgaGVhZGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBtaW1lOiBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpXG4gICAgfTtcblxuICAgIGlmIChyZXN1bHQubWltZS5pbmRleE9mKCdtdWx0aXBhcnQvJykgPT09IDApIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hbMl07XG4gICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gcGFyYW1zLm1hdGNoKGludGVybmFscy5wYXJhbXNSZWdleCk7XG4gICAgICAgICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYm91bmRhcnkgPSBwYXJhbVsxXSB8fCBwYXJhbVsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzdWx0LmJvdW5kYXJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29udGVudC10eXBlIGhlYWRlcjogbXVsdGlwYXJ0IG1pc3NpbmcgYm91bmRhcnknKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qXG4gICAgUkZDIDYyNjYgU2VjdGlvbiA0LjEgKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYyNjYjc2VjdGlvbi00LjEpXG5cbiAgICBjb250ZW50LWRpc3Bvc2l0aW9uID0gXCJDb250ZW50LURpc3Bvc2l0aW9uXCIgXCI6XCIgZGlzcG9zaXRpb24tdHlwZSAqKCBcIjtcIiBkaXNwb3NpdGlvbi1wYXJtIClcbiAgICBkaXNwb3NpdGlvbi10eXBlICAgID0gXCJpbmxpbmVcIiB8IFwiYXR0YWNobWVudFwiIHwgdG9rZW4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjYXNlLWluc2Vuc2l0aXZlXG4gICAgZGlzcG9zaXRpb24tcGFybSAgICA9IGZpbGVuYW1lLXBhcm0gfCB0b2tlbiBbIFwiKlwiIF0gXCI9XCIgKCB0b2tlbiB8IHF1b3RlZC1zdHJpbmcgfCBleHQtdmFsdWUpICAgIDsgZXh0LXZhbHVlIGRlZmluZWQgaW4gW1JGQzU5ODddLCBTZWN0aW9uIDMuMlxuXG4gICAgQ29udGVudC1EaXNwb3NpdGlvbiBoZWFkZXIgZmllbGQgdmFsdWVzIHdpdGggbXVsdGlwbGUgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHBhcmFtZXRlciBuYW1lIGFyZSBpbnZhbGlkLlxuXG4gICAgTm90ZSB0aGF0IGR1ZSB0byB0aGUgcnVsZXMgZm9yIGltcGxpZWQgbGluZWFyIHdoaXRlc3BhY2UgKFNlY3Rpb24gMi4xIG9mIFtSRkMyNjE2XSksIE9QVElPTkFMIHdoaXRlc3BhY2VcbiAgICBjYW4gYXBwZWFyIGJldHdlZW4gd29yZHMgKHRva2VuIG9yIHF1b3RlZC1zdHJpbmcpIGFuZCBzZXBhcmF0b3IgY2hhcmFjdGVycy5cblxuICAgIEZ1cnRoZXJtb3JlLCBub3RlIHRoYXQgdGhlIGZvcm1hdCB1c2VkIGZvciBleHQtdmFsdWUgYWxsb3dzIHNwZWNpZnlpbmcgYSBuYXR1cmFsIGxhbmd1YWdlIChlLmcuLCBcImVuXCIpOyB0aGlzIGlzIG9mIGxpbWl0ZWQgdXNlXG4gICAgZm9yIGZpbGVuYW1lcyBhbmQgaXMgbGlrZWx5IHRvIGJlIGlnbm9yZWQgYnkgcmVjaXBpZW50cy5cbiovXG5cblxuaW50ZXJuYWxzLmNvbnRlbnREaXNwb3NpdGlvblJlZ2V4ID0gL15cXHMqZm9ybS1kYXRhXFxzKig/OjtcXHMqKC4rKSk/JC9pO1xuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOiBuYW1lICAgICAyOiAqICAgICAgICAgICAgMzogZXh0LXZhbHVlICAgICAgICAgICAgICAgICAgICAgIDQ6IHF1b3RlZCAgNTogdG9rZW5cbmludGVybmFscy5jb250ZW50RGlzcG9zaXRpb25QYXJhbVJlZ2V4ID0gLyhbXlxcPVxcKlxcc10rKShcXCopP1xccypcXD1cXHMqKD86KFteOydcIlxcc10rXFwnW1xcdy1dKlxcJ1teO1xcc10rKXwoPzpcXFwiKFteXCJdKilcXFwiKXwoW147XFxzXSopKSg/OlxccyooPzo7XFxzKil8JCkvZztcblxuZXhwb3J0cy5kaXNwb3NpdGlvbiA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcblxuICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnTWlzc2luZyBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoID0gaGVhZGVyLm1hdGNoKGludGVybmFscy5jb250ZW50RGlzcG9zaXRpb25SZWdleCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXIgZm9ybWF0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYW1ldGVycyA9IG1hdGNoWzFdO1xuICAgIGlmICghcGFyYW1ldGVycykge1xuICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXIgbWlzc2luZyBwYXJhbWV0ZXJzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgcGFyYW1ldGVycy5yZXBsYWNlKGludGVybmFscy5jb250ZW50RGlzcG9zaXRpb25QYXJhbVJlZ2V4LCAoJDAsICQxLCAkMiwgJDMsICQ0LCAkNSkgPT4ge1xuXG4gICAgICAgIGlmICgkMikge1xuICAgICAgICAgICAgaWYgKCEkMykge1xuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciBmb3JtYXQgaW5jbHVkZXMgaW52YWxpZCBwYXJhbWV0ZXJzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0WyQxXSA9IGRlY29kZVVSSUNvbXBvbmVudCgkMy5zcGxpdCgnXFwnJylbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciBmb3JtYXQgaW5jbHVkZXMgaW52YWxpZCBwYXJhbWV0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbJDFdID0gJDQgfHwgJDUgfHwgJyc7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghcmVzdWx0Lm5hbWUpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIG1pc3NpbmcgbmFtZSBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLy8gR2VuZXJhdGUgYSBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgcHNldWRvLXJhbmRvbSBkYXRhXG5cbmV4cG9ydHMucmFuZG9tU3RyaW5nID0gZnVuY3Rpb24gKHNpemUpIHtcblxuICAgIGNvbnN0IGJ1ZmZlciA9IGV4cG9ydHMucmFuZG9tQml0cygoc2l6ZSArIDEpICogNik7XG4gICAgY29uc3Qgc3RyaW5nID0gYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXD0vZywgJycpO1xuICAgIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgc2l6ZSk7XG59O1xuXG5cbi8vIFJldHVybiBhIHJhbmRvbSBzdHJpbmcgb2YgZGlnaXRzXG5cbmV4cG9ydHMucmFuZG9tRGlnaXRzID0gZnVuY3Rpb24gKHNpemUpIHtcblxuICAgIGNvbnN0IGRpZ2l0cyA9IFtdO1xuXG4gICAgbGV0IGJ1ZmZlciA9IGludGVybmFscy5yYW5kb20oc2l6ZSAqIDIpOyAgICAgICAgICAgIC8vIFByb3Zpc2lvbiB0d2ljZSB0aGUgYW1vdW50IG9mIGJ5dGVzIG5lZWRlZCB0byBpbmNyZWFzZSBjaGFuY2Ugb2Ygc2luZ2xlIHBhc3NcbiAgICBsZXQgcG9zID0gMDtcblxuICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICBpZiAocG9zID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGludGVybmFscy5yYW5kb20oc2l6ZSAqIDIpO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChidWZmZXJbcG9zXSA8IDI1MCkge1xuICAgICAgICAgICAgZGlnaXRzLnB1c2goYnVmZmVyW3Bvc10gJSAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICArK3BvcztcbiAgICB9XG5cbiAgICByZXR1cm4gZGlnaXRzLmpvaW4oJycpO1xufTtcblxuXG4vLyBHZW5lcmF0ZSBhIGJ1ZmZlciBvZiByYW5kb20gYml0c1xuXG5leHBvcnRzLnJhbmRvbUJpdHMgPSBmdW5jdGlvbiAoYml0cykge1xuXG4gICAgaWYgKCFiaXRzIHx8XG4gICAgICAgIGJpdHMgPCAwKSB7XG5cbiAgICAgICAgdGhyb3cgQm9vbS5pbnRlcm5hbCgnSW52YWxpZCByYW5kb20gYml0cyBjb3VudCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGJ5dGVzID0gTWF0aC5jZWlsKGJpdHMgLyA4KTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLnJhbmRvbShieXRlcyk7XG59O1xuXG5cbmV4cG9ydHMuZml4ZWRUaW1lQ29tcGFyaXNvbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gQ3J5cHRvLnRpbWluZ1NhZmVFcXVhbChCdWZmZXIuZnJvbShhKSwgQnVmZmVyLmZyb20oYikpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5yYW5kb20gPSBmdW5jdGlvbiAoYnl0ZXMpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBDcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IEJvb20uaW50ZXJuYWwoJ0ZhaWxlZCBnZW5lcmF0aW5nIHJhbmRvbSBiaXRzOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnVuaXF1ZUZpbGVuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dGVuc2lvbikge1xuXG4gICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb25bMF0gIT09ICcuJyA/ICcuJyArIGV4dGVuc2lvbiA6IGV4dGVuc2lvbjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4dGVuc2lvbiA9ICcnO1xuICAgIH1cblxuICAgIHBhdGggPSBQYXRoLnJlc29sdmUocGF0aCk7XG4gICAgY29uc3QgbmFtZSA9IFtEYXRlLm5vdygpLCBwcm9jZXNzLnBpZCwgQ3J5cHRvLnJhbmRvbUJ5dGVzKDgpLnRvU3RyaW5nKCdoZXgnKV0uam9pbignLScpICsgZXh0ZW5zaW9uO1xuICAgIHJldHVybiBQYXRoLmpvaW4ocGF0aCwgbmFtZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgb3BlcmF0b3JzOiBbJyEnLCAnXicsICcqJywgJy8nLCAnJScsICcrJywgJy0nLCAnPCcsICc8PScsICc+JywgJz49JywgJz09JywgJyE9JywgJyYmJywgJ3x8JywgJz8/J10sXG4gICAgb3BlcmF0b3JDaGFyYWN0ZXJzOiBbJyEnLCAnXicsICcqJywgJy8nLCAnJScsICcrJywgJy0nLCAnPCcsICc9JywgJz4nLCAnJicsICd8JywgJz8nXSxcbiAgICBvcGVyYXRvcnNPcmRlcjogW1snXiddLCBbJyonLCAnLycsICclJ10sIFsnKycsICctJ10sIFsnPCcsICc8PScsICc+JywgJz49J10sIFsnPT0nLCAnIT0nXSwgWycmJiddLCBbJ3x8JywgJz8/J11dLFxuICAgIG9wZXJhdG9yc1ByZWZpeDogWychJywgJ24nXSxcblxuICAgIGxpdGVyYWxzOiB7XG4gICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICdgJzogJ2AnLFxuICAgICAgICAnXFwnJzogJ1xcJycsXG4gICAgICAgICdbJzogJ10nXG4gICAgfSxcblxuICAgIG51bWJlclJ4OiAvXig/OlswLTldKlxcLj9bMC05XSopezF9JC8sXG4gICAgdG9rZW5SeDogL15bXFx3XFwkXFwjXFwuXFxAXFw6XFx7XFx9XSskLyxcblxuICAgIHN5bWJvbDogU3ltYm9sKCdmb3JtdWxhJyksXG4gICAgc2V0dGluZ3M6IFN5bWJvbCgnc2V0dGluZ3MnKVxufTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuRm9ybXVsYSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zW2ludGVybmFscy5zZXR0aW5nc10gJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29uc3RhbnRzKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uc3RhbnQgaW4gb3B0aW9ucy5jb25zdGFudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuY29uc3RhbnRzW2NvbnN0YW50XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIVsnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb25zdGFudCAke2NvbnN0YW50fSBjb250YWlucyBpbnZhbGlkICR7dHlwZW9mIHZhbHVlfSB2YWx1ZSB0eXBlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IG9wdGlvbnNbaW50ZXJuYWxzLnNldHRpbmdzXSA/IG9wdGlvbnMgOiBPYmplY3QuYXNzaWduKHsgW2ludGVybmFscy5zZXR0aW5nc106IHRydWUsIGNvbnN0YW50czoge30sIGZ1bmN0aW9uczoge30gfSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2luZ2xlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9wYXJ0cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcnNlKHN0cmluZyk7XG4gICAgfVxuXG4gICAgX3BhcnNlKHN0cmluZykge1xuXG4gICAgICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgICAgICBsZXQgcGFyZW50aGVzaXMgPSAwO1xuICAgICAgICBsZXQgbGl0ZXJhbCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGZsdXNoID0gKGlubmVyKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBtaXNzaW5nIGNsb3NpbmcgcGFyZW50aGVzaXMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhcnRzLmxlbmd0aCA/IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKCFsaXRlcmFsICYmXG4gICAgICAgICAgICAgICAgIWN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICAhaW5uZXIpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICBsYXN0LnR5cGUgPT09ICdyZWZlcmVuY2UnICYmXG4gICAgICAgICAgICAgICAgaW5uZXIgPT09ICcpJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvblxuXG4gICAgICAgICAgICAgICAgbGFzdC50eXBlID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBsYXN0LnZhbHVlID0gdGhpcy5fc3ViRm9ybXVsYShjdXJyZW50LCBsYXN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5uZXIgPT09ICcpJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWdtZW50XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gbmV3IGludGVybmFscy5Gb3JtdWxhKGN1cnJlbnQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnc2VnbWVudCcsIHZhbHVlOiBzdWIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpdGVyYWwgPT09ICddJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdyZWZlcmVuY2UnLCB2YWx1ZTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdsaXRlcmFsJywgdmFsdWU6IGN1cnJlbnQgfSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMaXRlcmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMub3BlcmF0b3JDaGFyYWN0ZXJzLmluY2x1ZGVzKGN1cnJlbnQpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcGVyYXRvclxuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3QudHlwZSA9PT0gJ29wZXJhdG9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMub3BlcmF0b3JzLmluY2x1ZGVzKGxhc3QudmFsdWUgKyBjdXJyZW50KSkgeyAgICAgICAgICAgICAgICAgICAgICAgLy8gMiBjaGFyYWN0ZXJzIG9wZXJhdG9yXG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdC52YWx1ZSArPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnQubWF0Y2goaW50ZXJuYWxzLm51bWJlclJ4KSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE51bWJlclxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnY29uc3RhbnQnLCB2YWx1ZTogcGFyc2VGbG9hdChjdXJyZW50KSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuY29uc3RhbnRzW2N1cnJlbnRdICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0YW50XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdjb25zdGFudCcsIHZhbHVlOiB0aGlzLnNldHRpbmdzLmNvbnN0YW50c1tjdXJyZW50XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIGlmICghY3VycmVudC5tYXRjaChpbnRlcm5hbHMudG9rZW5SeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGludmFsaWQgdG9rZW46ICR7Y3VycmVudH1gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ3JlZmVyZW5jZScsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHN0cmluZykge1xuICAgICAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gbGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgKytwYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50aGVzaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyBpbiBpbnRlcm5hbHMubGl0ZXJhbHMpIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsID0gaW50ZXJuYWxzLmxpdGVyYWxzW2NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW50ZXJuYWxzLm9wZXJhdG9yQ2hhcmFjdGVycy5pbmNsdWRlcyhjKSkge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGM7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgIT09ICcgJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgcHJlZml4IC0gdG8gaW50ZXJuYWwgbmVnYXRpdmUgb3BlcmF0b3JcblxuICAgICAgICBwYXJ0cyA9IHBhcnRzLm1hcCgocGFydCwgaSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlICE9PSAnb3BlcmF0b3InIHx8XG4gICAgICAgICAgICAgICAgcGFydC52YWx1ZSAhPT0gJy0nIHx8XG4gICAgICAgICAgICAgICAgaSAmJiBwYXJ0c1tpIC0gMV0udHlwZSAhPT0gJ29wZXJhdG9yJykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdvcGVyYXRvcicsIHZhbHVlOiAnbicgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdG9rZW5zIG9yZGVyXG5cbiAgICAgICAgbGV0IG9wZXJhdG9yID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMub3BlcmF0b3JzUHJlZml4LmluY2x1ZGVzKHBhcnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIGNvbnRhaW5zIGFuIG9wZXJhdG9yIGluIGludmFsaWQgcG9zaXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5vcGVyYXRvcnMuaW5jbHVkZXMocGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGFuIHVua25vd24gb3BlcmF0b3IgJHtwYXJ0LnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIG1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3InKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3BlcmF0b3IgPSAhb3BlcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wZXJhdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgY29udGFpbnMgaW52YWxpZCB0cmFpbGluZyBvcGVyYXRvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWRlbnRpZnkgc2luZ2xlIHBhcnRcblxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBbJ3JlZmVyZW5jZScsICdsaXRlcmFsJywgJ2NvbnN0YW50J10uaW5jbHVkZXMocGFydHNbMF0udHlwZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5zaW5nbGUgPSB7IHR5cGU6IHBhcnRzWzBdLnR5cGUgPT09ICdyZWZlcmVuY2UnID8gJ3JlZmVyZW5jZScgOiAndmFsdWUnLCB2YWx1ZTogcGFydHNbMF0udmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICB0aGlzLl9wYXJ0cyA9IHBhcnRzLm1hcCgocGFydCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBPcGVyYXRvcnNcblxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMub3BlcmF0b3JzUHJlZml4LmluY2x1ZGVzKHBhcnQudmFsdWUpID8gcGFydCA6IHBhcnQudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExpdGVyYWxzLCBjb25zdGFudHMsIHNlZ21lbnRzXG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlZmVyZW5jZXNcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudG9rZW5SeCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnNldHRpbmdzLnRva2VuUngudGVzdChwYXJ0LnZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGludmFsaWQgcmVmZXJlbmNlICR7cGFydC52YWx1ZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucmVmZXJlbmNlKHBhcnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZmVyZW5jZShwYXJ0LnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3N1YkZvcm11bGEoc3RyaW5nLCBuYW1lKSB7XG5cbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5zZXR0aW5ncy5mdW5jdGlvbnNbbmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgdW5rbm93biBmdW5jdGlvbiAke25hbWV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBpZiAoc3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgbGV0IHBhcmVudGhlc2lzID0gMDtcbiAgICAgICAgICAgIGxldCBsaXRlcmFsID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyBmdW5jdGlvbiAke25hbWV9IHdpdGggaW52YWxpZCBhcmd1bWVudHMgJHtzdHJpbmd9YCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0cmluZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyBpbiBpbnRlcm5hbHMubGl0ZXJhbHMgJiZcbiAgICAgICAgICAgICAgICAgICAgIXBhcmVudGhlc2lzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gaW50ZXJuYWxzLmxpdGVyYWxzW2NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnLCcgJiZcbiAgICAgICAgICAgICAgICAgICAgIXBhcmVudGhlc2lzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytwYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tcGFyZW50aGVzaXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzID0gYXJncy5tYXAoKGFyZykgPT4gbmV3IGludGVybmFscy5Gb3JtdWxhKGFyZywgdGhpcy5zZXR0aW5ncykpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgICAgICAgICBjb25zdCBpbm5lclZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICAgICAgICAgIGlubmVyVmFsdWVzLnB1c2goYXJnLmV2YWx1YXRlKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKGNvbnRleHQsIC4uLmlubmVyVmFsdWVzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZShjb250ZXh0KSB7XG5cbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9wYXJ0cy5zbGljZSgpO1xuXG4gICAgICAgIC8vIFByZWZpeCBvcGVyYXRvcnNcblxuICAgICAgICBmb3IgKGxldCBpID0gcGFydHMubGVuZ3RoIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ICYmXG4gICAgICAgICAgICAgICAgcGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnRlcm5hbHMuZXZhbHVhdGUoY3VycmVudCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgcGFydHNbaV0gPSBpbnRlcm5hbHMuc2luZ2xlKHBhcnQudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExlZnQtcmlnaHQgb3BlcmF0b3JzXG5cbiAgICAgICAgaW50ZXJuYWxzLm9wZXJhdG9yc09yZGVyLmZvckVhY2goKHNldCkgPT4ge1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldC5pbmNsdWRlcyhwYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBwYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGludGVybmFscy5ldmFsdWF0ZShwYXJ0c1tpIC0gMV0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGludGVybmFscy5ldmFsdWF0ZShwYXJ0c1tpICsgMV0sIGNvbnRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmNhbGN1bGF0ZShvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0c1tpIC0gMV0gPSByZXN1bHQgPT09IDAgPyAwIDogcmVzdWx0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IC0wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzWzBdLCBjb250ZXh0KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5Gb3JtdWxhLnByb3RvdHlwZVtpbnRlcm5hbHMuc3ltYm9sXSA9IHRydWU7XG5cblxuaW50ZXJuYWxzLnJlZmVyZW5jZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcblxuICAgICAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0W25hbWVdICE9PSB1bmRlZmluZWQgPyBjb250ZXh0W25hbWVdIDogbnVsbDtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuZXZhbHVhdGUgPSBmdW5jdGlvbiAocGFydCwgY29udGV4dCkge1xuXG4gICAgaWYgKHBhcnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBwYXJ0KGNvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChwYXJ0W2ludGVybmFscy5zeW1ib2xdKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LmV2YWx1YXRlKGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJ0O1xufTtcblxuXG5pbnRlcm5hbHMuc2luZ2xlID0gZnVuY3Rpb24gKG9wZXJhdG9yLCB2YWx1ZSkge1xuXG4gICAgaWYgKG9wZXJhdG9yID09PSAnIScpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gZmFsc2UgOiB0cnVlO1xuICAgIH1cblxuICAgIC8vIG9wZXJhdG9yID09PSAnbidcblxuICAgIGNvbnN0IG5lZ2F0aXZlID0gLXZhbHVlO1xuICAgIGlmIChuZWdhdGl2ZSA9PT0gMCkgeyAgICAgICAvLyBPdmVycmlkZSAtMFxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmVnYXRpdmU7XG59O1xuXG5cbmludGVybmFscy5jYWxjdWxhdGUgPSBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICc/PycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5leGlzdHMobGVmdCkgPyBsZWZ0IDogcmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgcmlnaHQgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnKycpIHtcbiAgICAgICAgICAgIGxlZnQgPSBpbnRlcm5hbHMuZXhpc3RzKGxlZnQpID8gbGVmdCA6ICcnO1xuICAgICAgICAgICAgcmlnaHQgPSBpbnRlcm5hbHMuZXhpc3RzKHJpZ2h0KSA/IHJpZ2h0IDogJyc7XG4gICAgICAgICAgICByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICdeJzogcmV0dXJuIE1hdGgucG93KGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNhc2UgJyonOiByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICclJzogcmV0dXJuIGxlZnQgJSByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJysnOiByZXR1cm4gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgIGNhc2UgJzwnOiByZXR1cm4gbGVmdCA8IHJpZ2h0O1xuICAgICAgICBjYXNlICc8PSc6IHJldHVybiBsZWZ0IDw9IHJpZ2h0O1xuICAgICAgICBjYXNlICc+JzogcmV0dXJuIGxlZnQgPiByaWdodDtcbiAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gbGVmdCA+PSByaWdodDtcbiAgICAgICAgY2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJyE9JzogcmV0dXJuIGxlZnQgIT09IHJpZ2h0O1xuICAgICAgICBjYXNlICcmJic6IHJldHVybiBsZWZ0ICYmIHJpZ2h0O1xuICAgICAgICBjYXNlICd8fCc6IHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuZXhpc3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IENvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1pc3Npbmc6IFN5bWJvbCgnbWlzc2luZycpXG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5BdXRoID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoY29yZSkge1xuXG4gICAgICAgIHRoaXMuX2NvcmUgPSBjb3JlO1xuICAgICAgICB0aGlzLl9zY2hlbWVzID0ge307XG4gICAgICAgIHRoaXMuX3N0cmF0ZWdpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwgICAgICAgICAgIC8vIFN0cmF0ZWd5IHVzZWQgYXMgZGVmYXVsdCBpZiByb3V0ZSBoYXMgbm8gYXV0aCBzZXR0aW5nc1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYXBpID0ge307XG4gICAgfVxuXG4gICAgc2NoZW1lKG5hbWUsIHNjaGVtZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG5hbWUsICdBdXRoZW50aWNhdGlvbiBzY2hlbWUgbXVzdCBoYXZlIGEgbmFtZScpO1xuICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5fc2NoZW1lc1tuYW1lXSwgJ0F1dGhlbnRpY2F0aW9uIHNjaGVtZSBuYW1lIGFscmVhZHkgZXhpc3RzOicsIG5hbWUpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Ygc2NoZW1lID09PSAnZnVuY3Rpb24nLCAnc2NoZW1lIG11c3QgYmUgYSBmdW5jdGlvbjonLCBuYW1lKTtcblxuICAgICAgICB0aGlzLl9zY2hlbWVzW25hbWVdID0gc2NoZW1lO1xuICAgIH1cblxuICAgIF9zdHJhdGVneShzZXJ2ZXIsIG5hbWUsIHNjaGVtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQobmFtZSwgJ0F1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5IG11c3QgaGF2ZSBhIG5hbWUnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5fc3RyYXRlZ2llc1tuYW1lXSwgJ0F1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5IG5hbWUgYWxyZWFkeSBleGlzdHMnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1lLCAnQXV0aGVudGljYXRpb24gc3RyYXRlZ3knLCBuYW1lLCAnbWlzc2luZyBzY2hlbWUnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5fc2NoZW1lc1tzY2hlbWVdLCAnQXV0aGVudGljYXRpb24gc3RyYXRlZ3knLCBuYW1lLCAndXNlcyB1bmtub3duIHNjaGVtZTonLCBzY2hlbWUpO1xuXG4gICAgICAgIHNlcnZlciA9IHNlcnZlci5fY2xvbmUoKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9zY2hlbWVzW3NjaGVtZV0oc2VydmVyLCBvcHRpb25zKTtcblxuICAgICAgICBIb2VrLmFzc2VydChzdHJhdGVneS5hdXRoZW50aWNhdGUsICdJbnZhbGlkIHNjaGVtZTonLCBuYW1lLCAnbWlzc2luZyBhdXRoZW50aWNhdGUoKSBtZXRob2QnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHN0cmF0ZWd5LmF1dGhlbnRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgc2NoZW1lOicsIG5hbWUsICdpbnZhbGlkIGF1dGhlbnRpY2F0ZSgpIG1ldGhvZCcpO1xuICAgICAgICBIb2VrLmFzc2VydCghc3RyYXRlZ3kucGF5bG9hZCB8fCB0eXBlb2Ygc3RyYXRlZ3kucGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgc2NoZW1lOicsIG5hbWUsICdpbnZhbGlkIHBheWxvYWQoKSBtZXRob2QnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIXN0cmF0ZWd5LnJlc3BvbnNlIHx8IHR5cGVvZiBzdHJhdGVneS5yZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgc2NoZW1lOicsIG5hbWUsICdpbnZhbGlkIHJlc3BvbnNlKCkgbWV0aG9kJyk7XG4gICAgICAgIHN0cmF0ZWd5Lm9wdGlvbnMgPSBzdHJhdGVneS5vcHRpb25zIHx8IHt9O1xuICAgICAgICBIb2VrLmFzc2VydChzdHJhdGVneS5wYXlsb2FkIHx8ICFzdHJhdGVneS5vcHRpb25zLnBheWxvYWQsICdDYW5ub3QgcmVxdWlyZSBwYXlsb2FkIHZhbGlkYXRpb24gd2l0aG91dCBhIHBheWxvYWQgbWV0aG9kJyk7XG5cbiAgICAgICAgdGhpcy5fc3RyYXRlZ2llc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIG1ldGhvZHM6IHN0cmF0ZWd5LFxuICAgICAgICAgICAgcmVhbG06IHNlcnZlci5yZWFsbVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzdHJhdGVneS5hcGkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBpW25hbWVdID0gc3RyYXRlZ3kuYXBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmYXVsdChvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIXRoaXMuc2V0dGluZ3MuZGVmYXVsdCwgJ0Nhbm5vdCBzZXQgZGVmYXVsdCBzdHJhdGVneSBtb3JlIHRoYW4gb25jZScpO1xuICAgICAgICBvcHRpb25zID0gQ29uZmlnLmFwcGx5KCdhdXRoJywgb3B0aW9ucywgJ2RlZmF1bHQgc3RyYXRlZ3knKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLmRlZmF1bHQgPSB0aGlzLl9zZXR1cFJvdXRlKEhvZWsuY2xvbmUob3B0aW9ucykpOyAgICAgIC8vIFByZXZlbnQgY2hhbmdlcyB0byBvcHRpb25zXG5cbiAgICAgICAgY29uc3Qgcm91dGVzID0gdGhpcy5fY29yZS5yb3V0ZXIudGFibGUoKTtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpIHtcbiAgICAgICAgICAgIHJvdXRlLnJlYnVpbGQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHRlc3QobmFtZSwgcmVxdWVzdCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG5hbWUsICdNaXNzaW5nIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5IG5hbWUnKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVnaWVzW25hbWVdO1xuICAgICAgICBIb2VrLmFzc2VydChzdHJhdGVneSwgJ1Vua25vd24gYXV0aGVudGljYXRpb24gc3RyYXRlZ3k6JywgbmFtZSk7XG5cbiAgICAgICAgY29uc3QgYmluZCA9IHN0cmF0ZWd5Lm1ldGhvZHM7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gc3RyYXRlZ3kucmVhbG07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5fY29yZS50b29sa2l0LmV4ZWN1dGUoc3RyYXRlZ3kubWV0aG9kcy5hdXRoZW50aWNhdGUsIHJlcXVlc3QsIHsgYmluZCwgcmVhbG0sIGF1dGg6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5pc0F1dGgpIHtcbiAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgIH1cblxuICAgIGFzeW5jIHZlcmlmeShyZXF1ZXN0KSB7XG5cbiAgICAgICAgY29uc3QgYXV0aCA9IHJlcXVlc3QuYXV0aDtcblxuICAgICAgICBpZiAoYXV0aC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgYXV0aC5lcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYXV0aC5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ2llc1thdXRoLnN0cmF0ZWd5XTtcbiAgICAgICAgSG9lay5hc3NlcnQoc3RyYXRlZ3ksICdVbmtub3duIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5OicsIGF1dGguc3RyYXRlZ3kpO1xuXG4gICAgICAgIGlmICghc3RyYXRlZ3kubWV0aG9kcy52ZXJpZnkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJpbmQgPSBzdHJhdGVneS5tZXRob2RzO1xuICAgICAgICBhd2FpdCBzdHJhdGVneS5tZXRob2RzLnZlcmlmeS5jYWxsKGJpbmQsIGF1dGgpO1xuICAgIH1cblxuICAgIHN0YXRpYyB0ZXN0QWNjZXNzKHJlcXVlc3QsIHJvdXRlKSB7XG5cbiAgICAgICAgY29uc3QgYXV0aCA9IHJlcXVlc3QuX2NvcmUuYXV0aDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGguX2FjY2VzcyhyZXF1ZXN0LCByb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0dXBSb3V0ZShvcHRpb25zLCBwYXRoKSB7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uczsgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHVuZGVmaW5lZCBhbmQgZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHN0cmF0ZWdpZXM6IFtvcHRpb25zXSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc3RyYXRlZ2llcyA9IFtvcHRpb25zLnN0cmF0ZWd5XTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnN0cmF0ZWd5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGggJiZcbiAgICAgICAgICAgICFvcHRpb25zLnN0cmF0ZWdpZXMpIHtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodGhpcy5zZXR0aW5ncy5kZWZhdWx0LCAnUm91dGUgbWlzc2luZyBhdXRoZW50aWNhdGlvbiBzdHJhdGVneSBhbmQgbm8gZGVmYXVsdCBkZWZpbmVkOicsIHBhdGgpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKHRoaXMuc2V0dGluZ3MuZGVmYXVsdCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXRoID0gcGF0aCB8fCAnZGVmYXVsdCBzdHJhdGVneSc7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMuc3RyYXRlZ2llcyAmJiBvcHRpb25zLnN0cmF0ZWdpZXMubGVuZ3RoLCAnTWlzc2luZyBhdXRoZW50aWNhdGlvbiBzdHJhdGVneTonLCBwYXRoKTtcblxuICAgICAgICBvcHRpb25zLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ3JlcXVpcmVkJztcblxuICAgICAgICBpZiAob3B0aW9ucy5lbnRpdHkgIT09IHVuZGVmaW5lZCB8fCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggPD0gMTEueC54XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgb3B0aW9ucy5hY2Nlc3MgPSBbeyBlbnRpdHk6IG9wdGlvbnMuZW50aXR5LCBzY29wZTogb3B0aW9ucy5zY29wZSB9XTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmVudGl0eTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnNjb3BlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYWNjZXNzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjY2VzcyBvZiBvcHRpb25zLmFjY2Vzcykge1xuICAgICAgICAgICAgICAgIGFjY2Vzcy5zY29wZSA9IGludGVybmFscy5zZXR1cFNjb3BlKGFjY2Vzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wYXlsb2FkID09PSB0cnVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBheWxvYWQgPSAncmVxdWlyZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhc0F1dGhlbnRpY2F0ZVBheWxvYWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG9wdGlvbnMuc3RyYXRlZ2llcykge1xuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVnaWVzW25hbWVdO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoc3RyYXRlZ3ksICdVbmtub3duIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5JywgbmFtZSwgJ2luJywgcGF0aCk7XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHN0cmF0ZWd5Lm1ldGhvZHMucGF5bG9hZCB8fCBvcHRpb25zLnBheWxvYWQgIT09ICdyZXF1aXJlZCcsICdQYXlsb2FkIHZhbGlkYXRpb24gY2FuIG9ubHkgYmUgcmVxdWlyZWQgd2hlbiBhbGwgc3RyYXRlZ2llcyBzdXBwb3J0IGl0IGluJywgcGF0aCk7XG4gICAgICAgICAgICBoYXNBdXRoZW50aWNhdGVQYXlsb2FkID0gaGFzQXV0aGVudGljYXRlUGF5bG9hZCB8fCBzdHJhdGVneS5tZXRob2RzLnBheWxvYWQ7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCghc3RyYXRlZ3kubWV0aG9kcy5vcHRpb25zLnBheWxvYWQgfHwgb3B0aW9ucy5wYXlsb2FkID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5wYXlsb2FkID09PSAncmVxdWlyZWQnLCAnQ2Fubm90IHNldCBhdXRoZW50aWNhdGlvbiBwYXlsb2FkIHRvJywgb3B0aW9ucy5wYXlsb2FkLCAnd2hlbiBhIHN0cmF0ZWd5IHJlcXVpcmVzIHBheWxvYWQgdmFsaWRhdGlvbiBpbicsIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMucGF5bG9hZCB8fCBoYXNBdXRoZW50aWNhdGVQYXlsb2FkLCAnUGF5bG9hZCBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgc3RyYXRlZ3kgd2l0aCBwYXlsb2FkIHN1cHBvcnQgaW4nLCBwYXRoKTtcblxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBsb29rdXAocm91dGUpIHtcblxuICAgICAgICBpZiAocm91dGUuc2V0dGluZ3MuYXV0aCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3V0ZS5zZXR0aW5ncy5hdXRoIHx8IHRoaXMuc2V0dGluZ3MuZGVmYXVsdDtcbiAgICB9XG5cbiAgICBfZW5hYmxlZChyb3V0ZSwgdHlwZSkge1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMubG9va3VwKHJvdXRlKTtcbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYXV0aGVudGljYXRlJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2FjY2VzcycpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWNvbmZpZy5hY2Nlc3M7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY29uZmlnLnN0cmF0ZWdpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ2llc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChzdHJhdGVneS5tZXRob2RzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RhdGljIGF1dGhlbnRpY2F0ZShyZXF1ZXN0KSB7XG5cbiAgICAgICAgY29uc3QgYXV0aCA9IHJlcXVlc3QuX2NvcmUuYXV0aDtcbiAgICAgICAgcmV0dXJuIGF1dGguX2F1dGhlbnRpY2F0ZShyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBhc3luYyBfYXV0aGVudGljYXRlKHJlcXVlc3QpIHtcblxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmxvb2t1cChyZXF1ZXN0LnJvdXRlKTtcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgcmVxdWVzdC5hdXRoLm1vZGUgPSBjb25maWcubW9kZTtcblxuICAgICAgICAvLyBJbmplY3Rpb24gYnlwYXNzXG5cbiAgICAgICAgaWYgKHJlcXVlc3QuYXV0aC5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlKG51bGwsIHsgY3JlZGVudGlhbHM6IHJlcXVlc3QuYXV0aC5jcmVkZW50aWFscywgYXJ0aWZhY3RzOiByZXF1ZXN0LmF1dGguYXJ0aWZhY3RzIH0sIHJlcXVlc3QuYXV0aC5zdHJhdGVneSwgY29uZmlnLCByZXF1ZXN0LCBlcnJvcnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJ5IGVhY2ggc3RyYXRlZ3lcblxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgY29uZmlnLnN0cmF0ZWdpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ2llc1tuYW1lXTtcblxuICAgICAgICAgICAgY29uc3QgYmluZCA9IHN0cmF0ZWd5Lm1ldGhvZHM7XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IHN0cmF0ZWd5LnJlYWxtO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0Ll9jb3JlLnRvb2xraXQuZXhlY3V0ZShzdHJhdGVneS5tZXRob2RzLmF1dGhlbnRpY2F0ZSwgcmVxdWVzdCwgeyBiaW5kLCByZWFsbSwgYXV0aDogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IChyZXNwb25zZS5pc0F1dGggPyBpbnRlcm5hbHMudmFsaWRhdGUocmVzcG9uc2UuZXJyb3IsIHJlc3BvbnNlLmRhdGEsIG5hbWUsIGNvbmZpZywgcmVxdWVzdCwgZXJyb3JzKSA6IGludGVybmFscy52YWxpZGF0ZShyZXNwb25zZSwgbnVsbCwgbmFtZSwgY29uZmlnLCByZXF1ZXN0LCBlcnJvcnMpKTtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgIT09IGludGVybmFscy5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBObyBtb3JlIHN0cmF0ZWdpZXNcblxuICAgICAgICBjb25zdCBlcnIgPSBCb29tLnVuYXV0aG9yaXplZCgnTWlzc2luZyBhdXRoZW50aWNhdGlvbicsIGVycm9ycyk7XG4gICAgICAgIGlmIChjb25maWcubW9kZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hdXRoLmlzQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXF1ZXN0LmF1dGguY3JlZGVudGlhbHMgPSBudWxsO1xuICAgICAgICByZXF1ZXN0LmF1dGguZXJyb3IgPSBlcnI7XG4gICAgICAgIHJlcXVlc3QuX2xvZyhbJ2F1dGgnLCAndW5hdXRoZW50aWNhdGVkJ10pO1xuICAgIH1cblxuICAgIHN0YXRpYyBhY2Nlc3MocmVxdWVzdCkge1xuXG4gICAgICAgIGNvbnN0IGF1dGggPSByZXF1ZXN0Ll9jb3JlLmF1dGg7XG4gICAgICAgIHJlcXVlc3QuYXV0aC5pc0F1dGhvcml6ZWQgPSBhdXRoLl9hY2Nlc3MocmVxdWVzdCk7XG4gICAgfVxuXG4gICAgX2FjY2VzcyhyZXF1ZXN0LCByb3V0ZSkge1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMubG9va3VwKHJvdXRlIHx8IHJlcXVlc3Qucm91dGUpO1xuICAgICAgICBpZiAoIWNvbmZpZyB8fFxuICAgICAgICAgICAgIWNvbmZpZy5hY2Nlc3MpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHJlcXVlc3QuYXV0aC5jcmVkZW50aWFscztcbiAgICAgICAgaWYgKCFjcmVkZW50aWFscykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5tb2RlICE9PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBCb29tLmZvcmJpZGRlbignUmVxdWVzdCBpcyB1bmF1dGhlbnRpY2F0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RFbnRpdHkgPSAoY3JlZGVudGlhbHMudXNlciA/ICd1c2VyJyA6ICdhcHAnKTtcblxuICAgICAgICBjb25zdCBzY29wZUVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFjY2VzcyBvZiBjb25maWcuYWNjZXNzKSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGVudGl0eVxuXG4gICAgICAgICAgICBjb25zdCBlbnRpdHkgPSBhY2Nlc3MuZW50aXR5O1xuICAgICAgICAgICAgaWYgKGVudGl0eSAmJlxuICAgICAgICAgICAgICAgIGVudGl0eSAhPT0gJ2FueScgJiZcbiAgICAgICAgICAgICAgICBlbnRpdHkgIT09IHJlcXVlc3RFbnRpdHkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBzY29wZVxuXG4gICAgICAgICAgICBsZXQgc2NvcGUgPSBhY2Nlc3Muc2NvcGU7XG4gICAgICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNyZWRlbnRpYWxzLnNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlRXJyb3JzLnB1c2goc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzY29wZSA9IGludGVybmFscy5leHBhbmRTY29wZShyZXF1ZXN0LCBzY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMudmFsaWRhdGVTY29wZShjcmVkZW50aWFscywgc2NvcGUsICdyZXF1aXJlZCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICFpbnRlcm5hbHMudmFsaWRhdGVTY29wZShjcmVkZW50aWFscywgc2NvcGUsICdzZWxlY3Rpb24nKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaW50ZXJuYWxzLnZhbGlkYXRlU2NvcGUoY3JlZGVudGlhbHMsIHNjb3BlLCAnZm9yYmlkZGVuJykpIHtcblxuICAgICAgICAgICAgICAgICAgICBzY29wZUVycm9ycy5wdXNoKHNjb3BlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNjb3BlIGVycm9yXG5cbiAgICAgICAgaWYgKHNjb3BlRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVxdWVzdC5fbG9nKFsnYXV0aCcsICdzY29wZScsICdlcnJvciddKTtcbiAgICAgICAgICAgIHRocm93IEJvb20uZm9yYmlkZGVuKCdJbnN1ZmZpY2llbnQgc2NvcGUnLCB7IGdvdDogY3JlZGVudGlhbHMuc2NvcGUsIG5lZWQ6IHNjb3BlRXJyb3JzIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW50aXR5IGVycm9yXG5cbiAgICAgICAgaWYgKHJlcXVlc3RFbnRpdHkgPT09ICdhcHAnKSB7XG4gICAgICAgICAgICByZXF1ZXN0Ll9sb2coWydhdXRoJywgJ2VudGl0eScsICd1c2VyJywgJ2Vycm9yJ10pO1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5mb3JiaWRkZW4oJ0FwcGxpY2F0aW9uIGNyZWRlbnRpYWxzIGNhbm5vdCBiZSB1c2VkIG9uIGEgdXNlciBlbmRwb2ludCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5fbG9nKFsnYXV0aCcsICdlbnRpdHknLCAnYXBwJywgJ2Vycm9yJ10pO1xuICAgICAgICB0aHJvdyBCb29tLmZvcmJpZGRlbignVXNlciBjcmVkZW50aWFscyBjYW5ub3QgYmUgdXNlZCBvbiBhbiBhcHBsaWNhdGlvbiBlbmRwb2ludCcpO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyBwYXlsb2FkKHJlcXVlc3QpIHtcblxuICAgICAgICBpZiAoIXJlcXVlc3QuYXV0aC5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGF1dGggPSByZXF1ZXN0Ll9jb3JlLmF1dGg7XG4gICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gYXV0aC5fc3RyYXRlZ2llc1tyZXF1ZXN0LmF1dGguc3RyYXRlZ3ldO1xuICAgICAgICBIb2VrLmFzc2VydChzdHJhdGVneSwgJ1Vua25vd24gYXV0aGVudGljYXRpb24gc3RyYXRlZ3k6JywgcmVxdWVzdC5hdXRoLnN0cmF0ZWd5KTtcblxuICAgICAgICBpZiAoIXN0cmF0ZWd5Lm1ldGhvZHMucGF5bG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29uZmlnID0gYXV0aC5sb29rdXAocmVxdWVzdC5yb3V0ZSk7XG4gICAgICAgIGNvbnN0IHNldHRpbmcgPSBjb25maWcucGF5bG9hZCB8fCAoc3RyYXRlZ3kubWV0aG9kcy5vcHRpb25zLnBheWxvYWQgPyAncmVxdWlyZWQnIDogZmFsc2UpO1xuICAgICAgICBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJpbmQgPSBzdHJhdGVneS5tZXRob2RzO1xuICAgICAgICBjb25zdCByZWFsbSA9IHN0cmF0ZWd5LnJlYWxtO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuX2NvcmUudG9vbGtpdC5leGVjdXRlKHN0cmF0ZWd5Lm1ldGhvZHMucGF5bG9hZCwgcmVxdWVzdCwgeyBiaW5kLCByZWFsbSB9KTtcblxuICAgICAgICBpZiAocmVzcG9uc2UuaXNCb29tICYmXG4gICAgICAgICAgICByZXNwb25zZS5pc01pc3NpbmcpIHtcblxuICAgICAgICAgICAgcmV0dXJuIChzZXR0aW5nID09PSAnb3B0aW9uYWwnID8gdW5kZWZpbmVkIDogQm9vbS51bmF1dGhvcml6ZWQoJ01pc3NpbmcgcGF5bG9hZCBhdXRoZW50aWNhdGlvbicpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgcmVzcG9uc2UocmVxdWVzdCkge1xuXG4gICAgICAgIGNvbnN0IGF1dGggPSByZXF1ZXN0Ll9jb3JlLmF1dGg7XG4gICAgICAgIGlmICghcmVxdWVzdC5hdXRoLmlzQXV0aGVudGljYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBhdXRoLl9zdHJhdGVnaWVzW3JlcXVlc3QuYXV0aC5zdHJhdGVneV07XG4gICAgICAgIEhvZWsuYXNzZXJ0KHN0cmF0ZWd5LCAnVW5rbm93biBhdXRoZW50aWNhdGlvbiBzdHJhdGVneTonLCByZXF1ZXN0LmF1dGguc3RyYXRlZ3kpO1xuXG4gICAgICAgIGlmICghc3RyYXRlZ3kubWV0aG9kcy5yZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmluZCA9IHN0cmF0ZWd5Lm1ldGhvZHM7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gc3RyYXRlZ3kucmVhbG07XG4gICAgICAgIGNvbnN0IGVycm9yID0gYXdhaXQgcmVxdWVzdC5fY29yZS50b29sa2l0LmV4ZWN1dGUoc3RyYXRlZ3kubWV0aG9kcy5yZXNwb25zZSwgcmVxdWVzdCwgeyBiaW5kLCByZWFsbSwgY29udGludWU6ICd1bmRlZmluZWQnIH0pO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2V0dXBTY29wZSA9IGZ1bmN0aW9uIChhY2Nlc3MpIHtcblxuICAgIGlmICghYWNjZXNzLnNjb3BlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzY29wZSA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYWNjZXNzLnNjb3BlKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHZhbHVlWzBdO1xuICAgICAgICBjb25zdCB0eXBlID0gKHByZWZpeCA9PT0gJysnID8gJ3JlcXVpcmVkJyA6IChwcmVmaXggPT09ICchJyA/ICdmb3JiaWRkZW4nIDogJ3NlbGVjdGlvbicpKTtcbiAgICAgICAgY29uc3QgY2xlYW4gPSAodHlwZSA9PT0gJ3NlbGVjdGlvbicgPyB2YWx1ZSA6IHZhbHVlLnNsaWNlKDEpKTtcbiAgICAgICAgc2NvcGVbdHlwZV0gPSBzY29wZVt0eXBlXSB8fCBbXTtcbiAgICAgICAgc2NvcGVbdHlwZV0ucHVzaChjbGVhbik7XG5cbiAgICAgICAgaWYgKCghc2NvcGUuX2hhc1BhcmFtZXRlcnMgfHwgIXNjb3BlLl9oYXNQYXJhbWV0ZXJzW3R5cGVdKSAmJlxuICAgICAgICAgICAgL3soW159XSspfS8udGVzdChjbGVhbikpIHtcblxuICAgICAgICAgICAgc2NvcGUuX2hhc1BhcmFtZXRlcnMgPSBzY29wZS5faGFzUGFyYW1ldGVycyB8fCB7fTtcbiAgICAgICAgICAgIHNjb3BlLl9oYXNQYXJhbWV0ZXJzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY29wZTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGVyciwgcmVzdWx0LCBuYW1lLCBjb25maWcsIHJlcXVlc3QsIGVycm9ycykgeyAgICAgICAgICAgICAgICAgLy8gZXJyIGNhbiBiZSBCb29tLCBFcnJvciwgb3IgYSB2YWxpZCByZXNwb25zZSBvYmplY3RcblxuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcblxuICAgIC8vIFVuYXV0aGVudGljYXRlZFxuXG4gICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXF1ZXN0Ll9sb2coWydhdXRoJywgJ3VuYXV0aGVudGljYXRlZCcsICdyZXNwb25zZScsIG5hbWVdLCB7IHN0YXR1c0NvZGU6IGVyci5zdGF0dXNDb2RlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVycjsgICAgIC8vIE5vbi1lcnJvciByZXNwb25zZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVyci5pc01pc3NpbmcpIHtcblxuICAgICAgICAgICAgLy8gVHJ5IG5leHQgc3RyYXRlZ3lcblxuICAgICAgICAgICAgcmVxdWVzdC5fbG9nKFsnYXV0aCcsICd1bmF1dGhlbnRpY2F0ZWQnLCAnbWlzc2luZycsIG5hbWVdLCBlcnIpO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyLm91dHB1dC5oZWFkZXJzWydXV1ctQXV0aGVudGljYXRlJ10pO1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNzaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5tb2RlID09PSAndHJ5Jykge1xuICAgICAgICAgICAgcmVxdWVzdC5hdXRoLmlzQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVxdWVzdC5hdXRoLnN0cmF0ZWd5ID0gbmFtZTtcbiAgICAgICAgICAgIHJlcXVlc3QuYXV0aC5jcmVkZW50aWFscyA9IHJlc3VsdC5jcmVkZW50aWFscztcbiAgICAgICAgICAgIHJlcXVlc3QuYXV0aC5hcnRpZmFjdHMgPSByZXN1bHQuYXJ0aWZhY3RzO1xuICAgICAgICAgICAgcmVxdWVzdC5hdXRoLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgcmVxdWVzdC5fbG9nKFsnYXV0aCcsICd1bmF1dGhlbnRpY2F0ZWQnLCAndHJ5JywgbmFtZV0sIGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0Ll9sb2coWydhdXRoJywgJ3VuYXV0aGVudGljYXRlZCcsICdlcnJvcicsIG5hbWVdLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgLy8gQXV0aGVudGljYXRlZFxuXG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSByZXN1bHQuY3JlZGVudGlhbHM7XG4gICAgcmVxdWVzdC5hdXRoLnN0cmF0ZWd5ID0gbmFtZTtcbiAgICByZXF1ZXN0LmF1dGguY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICByZXF1ZXN0LmF1dGguYXJ0aWZhY3RzID0gcmVzdWx0LmFydGlmYWN0cztcbiAgICByZXF1ZXN0LmF1dGguaXNBdXRoZW50aWNhdGVkID0gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLmV4cGFuZFNjb3BlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHNjb3BlKSB7XG5cbiAgICBpZiAoIXNjb3BlLl9oYXNQYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBhbmRlZCA9IHtcbiAgICAgICAgcmVxdWlyZWQ6IGludGVybmFscy5leHBhbmRTY29wZVR5cGUocmVxdWVzdCwgc2NvcGUsICdyZXF1aXJlZCcpLFxuICAgICAgICBzZWxlY3Rpb246IGludGVybmFscy5leHBhbmRTY29wZVR5cGUocmVxdWVzdCwgc2NvcGUsICdzZWxlY3Rpb24nKSxcbiAgICAgICAgZm9yYmlkZGVuOiBpbnRlcm5hbHMuZXhwYW5kU2NvcGVUeXBlKHJlcXVlc3QsIHNjb3BlLCAnZm9yYmlkZGVuJylcbiAgICB9O1xuXG4gICAgcmV0dXJuIGV4cGFuZGVkO1xufTtcblxuXG5pbnRlcm5hbHMuZXhwYW5kU2NvcGVUeXBlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHNjb3BlLCB0eXBlKSB7XG5cbiAgICBpZiAoIXNjb3BlLl9oYXNQYXJhbWV0ZXJzW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBzY29wZVt0eXBlXTtcbiAgICB9XG5cbiAgICBjb25zdCBleHBhbmRlZCA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIHBhcmFtczogcmVxdWVzdC5wYXJhbXMsXG4gICAgICAgIHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxuICAgICAgICBwYXlsb2FkOiByZXF1ZXN0LnBheWxvYWQsXG4gICAgICAgIGNyZWRlbnRpYWxzOiByZXF1ZXN0LmF1dGguY3JlZGVudGlhbHNcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCB0ZW1wbGF0ZSBvZiBzY29wZVt0eXBlXSkge1xuICAgICAgICBleHBhbmRlZC5wdXNoKEhvZWsucmVhY2hUZW1wbGF0ZShjb250ZXh0LCB0ZW1wbGF0ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZDtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlU2NvcGUgPSBmdW5jdGlvbiAoY3JlZGVudGlhbHMsIHNjb3BlLCB0eXBlKSB7XG5cbiAgICBpZiAoIXNjb3BlW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvdW50ID0gdHlwZW9mIGNyZWRlbnRpYWxzLnNjb3BlID09PSAnc3RyaW5nJyA/XG4gICAgICAgIChzY29wZVt0eXBlXS5pbmRleE9mKGNyZWRlbnRpYWxzLnNjb3BlKSAhPT0gLTEgPyAxIDogMCkgOlxuICAgICAgICBIb2VrLmludGVyc2VjdChzY29wZVt0eXBlXSwgY3JlZGVudGlhbHMuc2NvcGUpLmxlbmd0aDtcblxuICAgIGlmICh0eXBlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICByZXR1cm4gY291bnQgPT09IDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50ID09PSBzY29wZS5yZXF1aXJlZC5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhY291bnQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBabGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBBY2NlcHQgPSByZXF1aXJlKCdAaGFwaS9hY2NlcHQnKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgY29tbW9uOiBbJ2d6aXAsIGRlZmxhdGUnLCAnZGVmbGF0ZSwgZ3ppcCcsICdnemlwJywgJ2RlZmxhdGUnLCAnZ3ppcCwgZGVmbGF0ZSwgYnInXVxufTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuQ29tcHJlc3Npb24gPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLmVuY29kaW5ncyA9IFsnaWRlbnRpdHknLCAnZ3ppcCcsICdkZWZsYXRlJ107XG4gICAgICAgIHRoaXMuX2VuY29kZXJzID0ge1xuICAgICAgICAgICAgaWRlbnRpdHk6IG51bGwsXG4gICAgICAgICAgICBnemlwOiAob3B0aW9ucykgPT4gWmxpYi5jcmVhdGVHemlwKG9wdGlvbnMpLFxuICAgICAgICAgICAgZGVmbGF0ZTogKG9wdGlvbnMpID0+IFpsaWIuY3JlYXRlRGVmbGF0ZShvcHRpb25zKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2RlY29kZXJzID0ge1xuICAgICAgICAgICAgZ3ppcDogKG9wdGlvbnMpID0+IFpsaWIuY3JlYXRlR3VuemlwKG9wdGlvbnMpLFxuICAgICAgICAgICAgZGVmbGF0ZTogKG9wdGlvbnMpID0+IFpsaWIuY3JlYXRlSW5mbGF0ZShvcHRpb25zKVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbW1vbnMoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQ29tbW9ucygpIHtcblxuICAgICAgICB0aGlzLl9jb21tb24gPSBuZXcgTWFwKCk7XG4gICAgICAgIGludGVybmFscy5jb21tb24uZm9yRWFjaCgoaGVhZGVyKSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbW1vbi5zZXQoaGVhZGVyLCBBY2NlcHQuZW5jb2RpbmcoaGVhZGVyLCB0aGlzLmVuY29kaW5ncykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRFbmNvZGVyKGVuY29kaW5nLCBlbmNvZGVyKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5fZW5jb2RlcnNbZW5jb2RpbmddID09PSB1bmRlZmluZWQsIGBDYW5ub3Qgb3ZlcnJpZGUgZXhpc3RpbmcgZW5jb2RlciBmb3IgJHtlbmNvZGluZ31gKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGVuY29kZXIgPT09ICdmdW5jdGlvbicsIGBJbnZhbGlkIGVuY29kZXIgZnVuY3Rpb24gZm9yICR7ZW5jb2Rpbmd9YCk7XG4gICAgICAgIHRoaXMuX2VuY29kZXJzW2VuY29kaW5nXSA9IGVuY29kZXI7XG4gICAgICAgIHRoaXMuZW5jb2RpbmdzLnVuc2hpZnQoZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLl91cGRhdGVDb21tb25zKCk7XG4gICAgfVxuXG4gICAgYWRkRGVjb2RlcihlbmNvZGluZywgZGVjb2Rlcikge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMuX2RlY29kZXJzW2VuY29kaW5nXSA9PT0gdW5kZWZpbmVkLCBgQ2Fubm90IG92ZXJyaWRlIGV4aXN0aW5nIGRlY29kZXIgZm9yICR7ZW5jb2Rpbmd9YCk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBkZWNvZGVyID09PSAnZnVuY3Rpb24nLCBgSW52YWxpZCBkZWNvZGVyIGZ1bmN0aW9uIGZvciAke2VuY29kaW5nfWApO1xuICAgICAgICB0aGlzLl9kZWNvZGVyc1tlbmNvZGluZ10gPSBkZWNvZGVyO1xuICAgIH1cblxuICAgIGFjY2VwdChyZXF1ZXN0KSB7XG5cbiAgICAgICAgY29uc3QgaGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzWydhY2NlcHQtZW5jb2RpbmcnXTtcbiAgICAgICAgY29uc3QgY29tbW9uID0gdGhpcy5fY29tbW9uLmdldChoZWFkZXIpO1xuICAgICAgICBpZiAoY29tbW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBBY2NlcHQuZW5jb2RpbmcoaGVhZGVyLCB0aGlzLmVuY29kaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgICAgICBlcnIuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgICAgcmVxdWVzdC5fbG9nKFsnYWNjZXB0LWVuY29kaW5nJywgJ2Vycm9yJ10sIGVycik7XG4gICAgICAgICAgICByZXR1cm4gJ2lkZW50aXR5JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuY29kaW5nKHJlc3BvbnNlLCBsZW5ndGgpIHtcblxuICAgICAgICBpZiAocmVzcG9uc2Uuc2V0dGluZ3MuY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddID0gcmVzcG9uc2Uuc2V0dGluZ3MuY29tcHJlc3NlZDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3Q7XG4gICAgICAgIGlmICghcmVxdWVzdC5fY29yZS5zZXR0aW5ncy5jb21wcmVzc2lvbiB8fFxuICAgICAgICAgICAgbGVuZ3RoICE9PSBudWxsICYmIGxlbmd0aCA8IHJlcXVlc3QuX2NvcmUuc2V0dGluZ3MuY29tcHJlc3Npb24ubWluQnl0ZXMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtaW1lID0gcmVxdWVzdC5fY29yZS5taW1lLnR5cGUocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICBpZiAoIW1pbWUuY29tcHJlc3NpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbnNlLnZhcnkoJ2FjY2VwdC1lbmNvZGluZycpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3QuaW5mby5hY2NlcHRFbmNvZGluZyA9PT0gJ2lkZW50aXR5JyA/IG51bGwgOiByZXF1ZXN0LmluZm8uYWNjZXB0RW5jb2Rpbmc7XG4gICAgfVxuXG4gICAgZW5jb2RlcihyZXF1ZXN0LCBlbmNvZGluZykge1xuXG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyc1tlbmNvZGluZ107XG4gICAgICAgIEhvZWsuYXNzZXJ0KGVuY29kZXIgIT09IHVuZGVmaW5lZCwgYFVua25vd24gZW5jb2RpbmcgJHtlbmNvZGluZ31gKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZXIocmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5jb21wcmVzc2lvbltlbmNvZGluZ10pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE9zID0gcmVxdWlyZSgnb3MnKTtcblxuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5zeW1ib2wgPSBTeW1ib2woJ2hhcGktcmVzcG9uc2UnKTtcblxuXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24gKHR5cGUsIG9wdGlvbnMsIC4uLm1lc3NhZ2UpIHtcblxuICAgIGNvbnN0IHJlc3VsdCA9IEpvaS52YWxpZGF0ZShvcHRpb25zLCBpbnRlcm5hbHNbdHlwZV0pO1xuXG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgJHt0eXBlfSBvcHRpb25zICR7bWVzc2FnZS5sZW5ndGggPyAnKCcgKyBtZXNzYWdlLmpvaW4oJyAnKSArICcpJyA6ICcnfSAke3Jlc3VsdC5lcnJvci5hbm5vdGF0ZSgpfWApO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG59O1xuXG5cbmV4cG9ydHMuZW5hYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHNldHRpbmdzID0gKG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSA6IHt9KTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcblxuICAgIGlmIChzZXR0aW5ncy5zZWN1cml0eSA9PT0gdHJ1ZSkge1xuICAgICAgICBzZXR0aW5ncy5zZWN1cml0eSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5jb3JzID09PSB0cnVlKSB7XG4gICAgICAgIHNldHRpbmdzLmNvcnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59O1xuXG5cbmludGVybmFscy5hY2Nlc3MgPSBKb2kub2JqZWN0KHtcbiAgICBlbnRpdHk6IEpvaS52YWxpZCgndXNlcicsICdhcHAnLCAnYW55JyksXG4gICAgc2NvcGU6IFtmYWxzZSwgSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKS5taW4oMSldXG59KTtcblxuXG5pbnRlcm5hbHMuYXV0aCA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5zdHJpbmcoKSxcbiAgICBpbnRlcm5hbHMuYWNjZXNzLmtleXMoe1xuICAgICAgICBtb2RlOiBKb2kudmFsaWQoJ3JlcXVpcmVkJywgJ29wdGlvbmFsJywgJ3RyeScpLFxuICAgICAgICBzdHJhdGVneTogSm9pLnN0cmluZygpLFxuICAgICAgICBzdHJhdGVnaWVzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLm1pbigxKSxcbiAgICAgICAgYWNjZXNzOiBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuYWNjZXNzLm1pbigxKSkuc2luZ2xlKCkubWluKDEpLFxuICAgICAgICBwYXlsb2FkOiBbXG4gICAgICAgICAgICBKb2kudmFsaWQoJ3JlcXVpcmVkJywgJ29wdGlvbmFsJyksXG4gICAgICAgICAgICBKb2kuYm9vbGVhbigpXG4gICAgICAgIF1cbiAgICB9KVxuICAgICAgICAud2l0aG91dCgnc3RyYXRlZ3knLCAnc3RyYXRlZ2llcycpXG4gICAgICAgIC53aXRob3V0KCdhY2Nlc3MnLCBbJ3Njb3BlJywgJ2VudGl0eSddKVxuXSk7XG5cblxuaW50ZXJuYWxzLmV2ZW50ID0gSm9pLm9iamVjdCh7XG4gICAgbWV0aG9kOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuZnVuYygpKS5zaW5nbGUoKSxcbiAgICBvcHRpb25zOiBKb2kub2JqZWN0KHtcbiAgICAgICAgYmVmb3JlOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLFxuICAgICAgICBhZnRlcjogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSxcbiAgICAgICAgYmluZDogSm9pLmFueSgpLFxuICAgICAgICBzYW5kYm94OiBKb2kudmFsaWQoJ3NlcnZlcicsICdwbHVnaW4nKSxcbiAgICAgICAgdGltZW91dDogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMSlcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCh7fSlcbn0pO1xuXG5cbmludGVybmFscy5leHRzID0gSm9pLmFycmF5KCkuaXRlbXMoaW50ZXJuYWxzLmV2ZW50LmtleXMoeyB0eXBlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSB9KSkuc2luZ2xlKCk7XG5cblxuaW50ZXJuYWxzLmZhaWxBY3Rpb24gPSBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICBKb2kudmFsaWQoJ2Vycm9yJywgJ2xvZycsICdpZ25vcmUnKSxcbiAgICBKb2kuZnVuYygpXG5dKVxuICAgIC5kZWZhdWx0KCdlcnJvcicpO1xuXG5cbmludGVybmFscy5yb3V0ZUJhc2UgPSBKb2kub2JqZWN0KHtcbiAgICBhcHA6IEpvaS5vYmplY3QoKS5hbGxvdyhudWxsKSxcbiAgICBhdXRoOiBpbnRlcm5hbHMuYXV0aC5hbGxvdyhmYWxzZSksXG4gICAgYmluZDogSm9pLm9iamVjdCgpLmFsbG93KG51bGwpLFxuICAgIGNhY2hlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgZXhwaXJlc0luOiBKb2kubnVtYmVyKCksXG4gICAgICAgIGV4cGlyZXNBdDogSm9pLnN0cmluZygpLFxuICAgICAgICBwcml2YWN5OiBKb2kudmFsaWQoJ2RlZmF1bHQnLCAncHVibGljJywgJ3ByaXZhdGUnKSxcbiAgICAgICAgc3RhdHVzZXM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDIwMCkpLm1pbigxKS5zaW5nbGUoKS5kZWZhdWx0KFsyMDAsIDIwNF0pLFxuICAgICAgICBvdGhlcndpc2U6IEpvaS5zdHJpbmcoKS5kZWZhdWx0KCduby1jYWNoZScpXG4gICAgfSlcbiAgICAgICAgLmFsbG93KGZhbHNlKVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIGNvbXByZXNzaW9uOiBKb2kub2JqZWN0KClcbiAgICAgICAgLnBhdHRlcm4oLy4rLywgSm9pLm9iamVjdCgpKVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIGNvcnM6IEpvaS5vYmplY3Qoe1xuICAgICAgICBvcmlnaW46IEpvaS5hcnJheSgpLm1pbigxKS5hbGxvdygnaWdub3JlJykuZGVmYXVsdChbJyonXSksXG4gICAgICAgIG1heEFnZTogSm9pLm51bWJlcigpLmRlZmF1bHQoODY0MDApLFxuICAgICAgICBoZWFkZXJzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLmRlZmF1bHQoWydBY2NlcHQnLCAnQXV0aG9yaXphdGlvbicsICdDb250ZW50LVR5cGUnLCAnSWYtTm9uZS1NYXRjaCddKSxcbiAgICAgICAgYWRkaXRpb25hbEhlYWRlcnM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuZGVmYXVsdChbXSksXG4gICAgICAgIGV4cG9zZWRIZWFkZXJzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLmRlZmF1bHQoWydXV1ctQXV0aGVudGljYXRlJywgJ1NlcnZlci1BdXRob3JpemF0aW9uJ10pLFxuICAgICAgICBhZGRpdGlvbmFsRXhwb3NlZEhlYWRlcnM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuZGVmYXVsdChbXSksXG4gICAgICAgIGNyZWRlbnRpYWxzOiBKb2kuYm9vbGVhbigpLndoZW4oJ29yaWdpbicsIHsgaXM6ICdpZ25vcmUnLCB0aGVuOiBmYWxzZSB9KS5kZWZhdWx0KGZhbHNlKVxuICAgIH0pXG4gICAgICAgIC5hbGxvdyhmYWxzZSwgdHJ1ZSlcbiAgICAgICAgLmRlZmF1bHQoZmFsc2UpLFxuICAgIGV4dDogSm9pLm9iamVjdCh7XG4gICAgICAgIG9uUHJlQXV0aDogSm9pLmFycmF5KCkuaXRlbXMoaW50ZXJuYWxzLmV2ZW50KS5zaW5nbGUoKSxcbiAgICAgICAgb25DcmVkZW50aWFsczogSm9pLmFycmF5KCkuaXRlbXMoaW50ZXJuYWxzLmV2ZW50KS5zaW5nbGUoKSxcbiAgICAgICAgb25Qb3N0QXV0aDogSm9pLmFycmF5KCkuaXRlbXMoaW50ZXJuYWxzLmV2ZW50KS5zaW5nbGUoKSxcbiAgICAgICAgb25QcmVIYW5kbGVyOiBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuZXZlbnQpLnNpbmdsZSgpLFxuICAgICAgICBvblBvc3RIYW5kbGVyOiBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuZXZlbnQpLnNpbmdsZSgpLFxuICAgICAgICBvblByZVJlc3BvbnNlOiBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuZXZlbnQpLnNpbmdsZSgpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoe30pLFxuICAgIGZpbGVzOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVsYXRpdmVUbzogSm9pLnN0cmluZygpLnJlZ2V4KC9eKFtcXC9cXC5dKXwoW0EtWmEtel06XFxcXCl8KFxcXFxcXFxcKS8pLmRlZmF1bHQoJy4nKVxuICAgIH0pXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAganNvbjogSm9pLm9iamVjdCh7XG4gICAgICAgIHJlcGxhY2VyOiBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5mdW5jKCksIEpvaS5hcnJheSgpKS5hbGxvdyhudWxsKS5kZWZhdWx0KG51bGwpLFxuICAgICAgICBzcGFjZTogSm9pLm51bWJlcigpLmFsbG93KG51bGwpLmRlZmF1bHQobnVsbCksXG4gICAgICAgIHN1ZmZpeDogSm9pLnN0cmluZygpLmFsbG93KG51bGwpLmRlZmF1bHQobnVsbCksXG4gICAgICAgIGVzY2FwZTogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKVxuICAgIH0pXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAganNvbnA6IEpvaS5zdHJpbmcoKSxcbiAgICBsb2c6IEpvaS5vYmplY3Qoe1xuICAgICAgICBjb2xsZWN0OiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBwYXlsb2FkOiBKb2kub2JqZWN0KHtcbiAgICAgICAgb3V0cHV0OiBKb2kudmFsaWQoJ2RhdGEnLCAnc3RyZWFtJywgJ2ZpbGUnKS5kZWZhdWx0KCdkYXRhJyksXG4gICAgICAgIHBhcnNlOiBKb2kuYm9vbGVhbigpLmFsbG93KCdndW56aXAnKS5kZWZhdWx0KHRydWUpLFxuICAgICAgICBtdWx0aXBhcnQ6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgb3V0cHV0OiBKb2kudmFsaWQoJ2RhdGEnLCAnc3RyZWFtJywgJ2ZpbGUnLCAnYW5ub3RhdGVkJykucmVxdWlyZWQoKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmFsbG93KGZhbHNlKSxcbiAgICAgICAgYWxsb3c6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCksXG4gICAgICAgIG92ZXJyaWRlOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIHByb3RvQWN0aW9uOiBKb2kudmFsaWQoJ2Vycm9yJywgJ3JlbW92ZScsICdpZ25vcmUnKS5kZWZhdWx0KCdlcnJvcicpLFxuICAgICAgICBtYXhCeXRlczogSm9pLm51bWJlcigpLmludGVnZXIoKS5wb3NpdGl2ZSgpLmRlZmF1bHQoMTAyNCAqIDEwMjQpLFxuICAgICAgICB1cGxvYWRzOiBKb2kuc3RyaW5nKCkuZGVmYXVsdChPcy50bXBkaXIoKSksXG4gICAgICAgIGZhaWxBY3Rpb246IGludGVybmFscy5mYWlsQWN0aW9uLFxuICAgICAgICB0aW1lb3V0OiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLnBvc2l0aXZlKCkuYWxsb3coZmFsc2UpLmRlZmF1bHQoMTAgKiAxMDAwKSxcbiAgICAgICAgZGVmYXVsdENvbnRlbnRUeXBlOiBKb2kuc3RyaW5nKCkuZGVmYXVsdCgnYXBwbGljYXRpb24vanNvbicpLFxuICAgICAgICBjb21wcmVzc2lvbjogSm9pLm9iamVjdCgpXG4gICAgICAgICAgICAucGF0dGVybigvLisvLCBKb2kub2JqZWN0KCkpXG4gICAgICAgICAgICAuZGVmYXVsdCgpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBwbHVnaW5zOiBKb2kub2JqZWN0KCksXG4gICAgcmVzcG9uc2U6IEpvaS5vYmplY3Qoe1xuICAgICAgICBkaXNjb25uZWN0U3RhdHVzQ29kZTogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oNDAwKS5kZWZhdWx0KDQ5OSksXG4gICAgICAgIGVtcHR5U3RhdHVzQ29kZTogSm9pLnZhbGlkKDIwMCwgMjA0KS5kZWZhdWx0KDIwMCksXG4gICAgICAgIGZhaWxBY3Rpb246IGludGVybmFscy5mYWlsQWN0aW9uLFxuICAgICAgICBtb2RpZnk6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG9wdGlvbnM6IEpvaS5vYmplY3QoKS5kZWZhdWx0KCksXG4gICAgICAgIHJhbmdlczogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLFxuICAgICAgICBzYW1wbGU6IEpvaS5udW1iZXIoKS5taW4oMCkubWF4KDEwMCkud2hlbignbW9kaWZ5JywgeyBpczogdHJ1ZSwgdGhlbjogSm9pLmZvcmJpZGRlbigpIH0pLFxuICAgICAgICBzY2hlbWE6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLm9iamVjdCgpLCBKb2kuYXJyYXkoKSwgSm9pLmZ1bmMoKSkuYWxsb3codHJ1ZSwgZmFsc2UpLFxuICAgICAgICBzdGF0dXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC9cXGRcXGRcXGQvLCBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5vYmplY3QoKSwgSm9pLmFycmF5KCksIEpvaS5mdW5jKCkpLmFsbG93KHRydWUsIGZhbHNlKSlcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCgpXG4gICAgICAgIC5hc3NlcnQoJ29wdGlvbnMuc3RyaXBVbmtub3duJywgSm9pLndoZW4oJ21vZGlmeScsIHsgaXM6IHRydWUsIG90aGVyd2lzZTogZmFsc2UgfSksICdtZWV0IHJlcXVpcmVtZW50IG9mIGhhdmluZyBwZWVyIG1vZGlmeSBzZXQgdG8gdHJ1ZScpLFxuICAgIHNlY3VyaXR5OiBKb2kub2JqZWN0KHtcbiAgICAgICAgaHN0czogSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgICAgICAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBtYXhBZ2U6IEpvaS5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlU3ViZG9tYWluczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgICAgICBpbmNsdWRlU3ViRG9tYWluczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgICAgICBwcmVsb2FkOiBKb2kuYm9vbGVhbigpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBKb2kubnVtYmVyKClcbiAgICAgICAgXSlcbiAgICAgICAgICAgIC5kZWZhdWx0KDE1NzY4MDAwKSxcbiAgICAgICAgeGZyYW1lOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgIEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBKb2kudmFsaWQoJ3NhbWVvcmlnaW4nLCAnZGVueScpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgcnVsZTogSm9pLnZhbGlkKCdzYW1lb3JpZ2luJywgJ2RlbnknLCAnYWxsb3ctZnJvbScpLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogSm9pLnN0cmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgICAgICAgLmRlZmF1bHQoJ2RlbnknKSxcbiAgICAgICAgeHNzOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQodHJ1ZSksXG4gICAgICAgIG5vT3BlbjogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLFxuICAgICAgICBub1NuaWZmOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQodHJ1ZSksXG4gICAgICAgIHJlZmVycmVyOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgIEpvaS5ib29sZWFuKCkudmFsaWQoZmFsc2UpLFxuICAgICAgICAgICAgSm9pLnZhbGlkKCcnLCAnbm8tcmVmZXJyZXInLCAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnLFxuICAgICAgICAgICAgICAgICd1bnNhZmUtdXJsJywgJ3NhbWUtb3JpZ2luJywgJ29yaWdpbicsICdzdHJpY3Qtb3JpZ2luJyxcbiAgICAgICAgICAgICAgICAnb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJywgJ3N0cmljdC1vcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nKVxuICAgICAgICBdKVxuICAgICAgICAgICAgLmRlZmF1bHQoZmFsc2UpXG4gICAgfSlcbiAgICAgICAgLmFsbG93KG51bGwsIGZhbHNlLCB0cnVlKVxuICAgICAgICAuZGVmYXVsdChmYWxzZSksXG4gICAgc3RhdGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBwYXJzZTogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLFxuICAgICAgICBmYWlsQWN0aW9uOiBpbnRlcm5hbHMuZmFpbEFjdGlvblxuICAgIH0pXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAgdGltZW91dDogSm9pLm9iamVjdCh7XG4gICAgICAgIHNvY2tldDogSm9pLm51bWJlcigpLmludGVnZXIoKS5wb3NpdGl2ZSgpLmFsbG93KGZhbHNlKSxcbiAgICAgICAgc2VydmVyOiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLnBvc2l0aXZlKCkuYWxsb3coZmFsc2UpLmRlZmF1bHQoZmFsc2UpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICB2YWxpZGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIGhlYWRlcnM6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLm9iamVjdCgpLCBKb2kuYXJyYXkoKSwgSm9pLmZ1bmMoKSkuYWxsb3cobnVsbCwgdHJ1ZSksXG4gICAgICAgIHBhcmFtczogSm9pLmFsdGVybmF0aXZlcyhKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpLCBKb2kuZnVuYygpKS5hbGxvdyhudWxsLCB0cnVlKSxcbiAgICAgICAgcXVlcnk6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLm9iamVjdCgpLCBKb2kuYXJyYXkoKSwgSm9pLmZ1bmMoKSkuYWxsb3cobnVsbCwgZmFsc2UsIHRydWUpLFxuICAgICAgICBwYXlsb2FkOiBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5vYmplY3QoKSwgSm9pLmFycmF5KCksIEpvaS5mdW5jKCkpLmFsbG93KG51bGwsIGZhbHNlLCB0cnVlKSxcbiAgICAgICAgc3RhdGU6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLm9iamVjdCgpLCBKb2kuYXJyYXkoKSwgSm9pLmZ1bmMoKSkuYWxsb3cobnVsbCwgZmFsc2UsIHRydWUpLFxuICAgICAgICBmYWlsQWN0aW9uOiBpbnRlcm5hbHMuZmFpbEFjdGlvbixcbiAgICAgICAgZXJyb3JGaWVsZHM6IEpvaS5vYmplY3QoKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpLmRlZmF1bHQoKVxuICAgIH0pXG4gICAgICAgIC5kZWZhdWx0KClcbn0pO1xuXG5cbmludGVybmFscy5zZXJ2ZXIgPSBKb2kub2JqZWN0KHtcbiAgICBhZGRyZXNzOiBKb2kuc3RyaW5nKCkuaG9zdG5hbWUoKSxcbiAgICBhcHA6IEpvaS5vYmplY3QoKS5hbGxvdyhudWxsKSxcbiAgICBhdXRvTGlzdGVuOiBKb2kuYm9vbGVhbigpLFxuICAgIGNhY2hlOiBKb2kuYWxsb3cobnVsbCksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGVkIGVsc2V3aGVyZVxuICAgIGNvbXByZXNzaW9uOiBKb2kub2JqZWN0KHtcbiAgICAgICAgbWluQnl0ZXM6IEpvaS5udW1iZXIoKS5taW4oMSkuaW50ZWdlcigpLmRlZmF1bHQoMTAyNClcbiAgICB9KVxuICAgICAgICAuYWxsb3coZmFsc2UpXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAgZGVidWc6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZXF1ZXN0OiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLmFsbG93KGZhbHNlKS5kZWZhdWx0KFsnaW1wbGVtZW50YXRpb24nXSksXG4gICAgICAgIGxvZzogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKS5hbGxvdyhmYWxzZSlcbiAgICB9KVxuICAgICAgICAuYWxsb3coZmFsc2UpXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAgaG9zdDogSm9pLnN0cmluZygpLmhvc3RuYW1lKCkuYWxsb3cobnVsbCksXG4gICAgbGlzdGVuZXI6IEpvaS5hbnkoKSxcbiAgICBsb2FkOiBKb2kub2JqZWN0KHtcbiAgICAgICAgc2FtcGxlSW50ZXJ2YWw6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDApLmRlZmF1bHQoMCksXG4gICAgICAgIGNvbmN1cnJlbnQ6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDApLmRlZmF1bHQoMClcbiAgICB9KVxuICAgICAgICAudW5rbm93bigpXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAgbWltZTogSm9pLm9iamVjdCgpLmFsbG93KG51bGwpLmRlZmF1bHQobnVsbCksXG4gICAgb3BlcmF0aW9uczogSm9pLm9iamVjdCh7XG4gICAgICAgIGNsZWFuU3RvcDogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBwbHVnaW5zOiBKb2kub2JqZWN0KCksXG4gICAgcG9ydDogSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgICAgIEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDApLCAgICAgICAgICAvLyBUQ1AgcG9ydFxuICAgICAgICBKb2kuc3RyaW5nKCkucmVnZXgoL1xcLy8pLCAgICAgICAgICAgICAgIC8vIFVuaXggZG9tYWluIHNvY2tldFxuICAgICAgICBKb2kuc3RyaW5nKCkucmVnZXgoL15cXFxcXFxcXFxcLlxcXFxwaXBlXFxcXC8pICAgLy8gV2luZG93cyBuYW1lZCBwaXBlXG4gICAgXSlcbiAgICAgICAgLmFsbG93KG51bGwpLFxuICAgIHF1ZXJ5OiBKb2kub2JqZWN0KHtcbiAgICAgICAgcGFyc2VyOiBKb2kuZnVuYygpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICByb3V0ZXI6IEpvaS5vYmplY3Qoe1xuICAgICAgICBpc0Nhc2VTZW5zaXRpdmU6IEpvaS5ib29sZWFuKCkuZGVmYXVsdCh0cnVlKSxcbiAgICAgICAgc3RyaXBUcmFpbGluZ1NsYXNoOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICByb3V0ZXM6IGludGVybmFscy5yb3V0ZUJhc2UuZGVmYXVsdCgpLFxuICAgIHN0YXRlOiBKb2kub2JqZWN0KCksICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29va2llIGRlZmF1bHRzXG4gICAgdGxzOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgSm9pLm9iamVjdCgpLmFsbG93KG51bGwpLFxuICAgICAgICBKb2kuYm9vbGVhbigpXG4gICAgXSksXG4gICAgdXJpOiBKb2kuc3RyaW5nKCkucmVnZXgoL1teL10kLylcbn0pO1xuXG5cbmludGVybmFscy52aG9zdCA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5zdHJpbmcoKS5ob3N0bmFtZSgpLFxuICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKS5ob3N0bmFtZSgpKS5taW4oMSlcbl0pO1xuXG5cbmludGVybmFscy5oYW5kbGVyID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLmZ1bmMoKSxcbiAgICBKb2kub2JqZWN0KCkubGVuZ3RoKDEpXG5dKTtcblxuXG5pbnRlcm5hbHMucm91dGUgPSBKb2kub2JqZWN0KHtcbiAgICBtZXRob2Q6IEpvaS5zdHJpbmcoKS5yZWdleCgvXlthLXpBLVowLTkhI1xcJCUmJ1xcKlxcK1xcLVxcLl5fYFxcfH5dKyQvKS5yZXF1aXJlZCgpLFxuICAgIHBhdGg6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgIHJ1bGVzOiBKb2kub2JqZWN0KCksXG4gICAgdmhvc3Q6IGludGVybmFscy52aG9zdCxcblxuICAgIC8vIFZhbGlkYXRlZCBpbiByb3V0ZSBjb25zdHJ1Y3Rpb25cblxuICAgIGhhbmRsZXI6IEpvaS5hbnkoKSxcbiAgICBvcHRpb25zOiBKb2kuYW55KCksXG4gICAgY29uZmlnOiBKb2kuYW55KCkgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxufSlcbiAgICAud2l0aG91dCgnY29uZmlnJywgJ29wdGlvbnMnKTtcblxuXG5pbnRlcm5hbHMucHJlID0gW1xuICAgIEpvaS5mdW5jKCksXG4gICAgSm9pLm9iamVjdCh7XG4gICAgICAgIG1ldGhvZDogSm9pLmFsdGVybmF0aXZlcyhKb2kuc3RyaW5nKCksIEpvaS5mdW5jKCkpLnJlcXVpcmVkKCksXG4gICAgICAgIGFzc2lnbjogSm9pLnN0cmluZygpLFxuICAgICAgICBtb2RlOiBKb2kudmFsaWQoJ3NlcmlhbCcsICdwYXJhbGxlbCcpLFxuICAgICAgICBmYWlsQWN0aW9uOiBpbnRlcm5hbHMuZmFpbEFjdGlvblxuICAgIH0pXG5dO1xuXG5cbmludGVybmFscy5yb3V0ZUNvbmZpZyA9IGludGVybmFscy5yb3V0ZUJhc2Uua2V5cyh7XG4gICAgZGVzY3JpcHRpb246IEpvaS5zdHJpbmcoKSxcbiAgICBpZDogSm9pLnN0cmluZygpLFxuICAgIGlzSW50ZXJuYWw6IEpvaS5ib29sZWFuKCksXG4gICAgbm90ZXM6IFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpXG4gICAgXSxcbiAgICBwcmU6IEpvaS5hcnJheSgpLml0ZW1zKGludGVybmFscy5wcmUuY29uY2F0KEpvaS5hcnJheSgpLml0ZW1zKGludGVybmFscy5wcmUpLm1pbigxKSkpLFxuICAgIHRhZ3M6IFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpXG4gICAgXVxufSk7XG5cblxuaW50ZXJuYWxzLmNhY2hlQ29uZmlnID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLmZ1bmMoKSxcbiAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLmludmFsaWQoJ19kZWZhdWx0JyksXG4gICAgICAgIHNoYXJlZDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgcHJvdmlkZXI6IFtcbiAgICAgICAgICAgIEpvaS5mdW5jKCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IEpvaS5mdW5jKCkucmVxdWlyZWQoKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGl0aW9uOiBKb2kuc3RyaW5nKCkuZGVmYXVsdCgnaGFwaS1jYWNoZScpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnVua25vd24oKSAgICAgIC8vIENhdGJveCBjbGllbnQgdmFsaWRhdGVzIG90aGVyIGtleXNcbiAgICAgICAgICAgICAgICAgICAgLmRlZmF1bHQoe30pXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGVuZ2luZTogSm9pLm9iamVjdCgpXG4gICAgfSlcbiAgICAgICAgLnhvcigncHJvdmlkZXInLCAnZW5naW5lJylcbl0pO1xuXG5cbmludGVybmFscy5jYWNoZSA9IEpvaS5hcnJheSgpLml0ZW1zKGludGVybmFscy5jYWNoZUNvbmZpZykubWluKDEpLnNpbmdsZSgpO1xuXG5cbmludGVybmFscy5jYWNoZVBvbGljeSA9IEpvaS5vYmplY3Qoe1xuICAgIGNhY2hlOiBKb2kuc3RyaW5nKCkuYWxsb3cobnVsbCkuYWxsb3coJycpLFxuICAgIHNlZ21lbnQ6IEpvaS5zdHJpbmcoKSxcbiAgICBzaGFyZWQ6IEpvaS5ib29sZWFuKClcbn0pXG4gICAgLnVua25vd24oKTsgICAgICAgICAgICAgICAgICAgICAvLyBDYXRib3ggcG9saWN5IHZhbGlkYXRlcyBvdGhlciBrZXlzXG5cblxuaW50ZXJuYWxzLm1ldGhvZCA9IEpvaS5vYmplY3Qoe1xuICAgIGJpbmQ6IEpvaS5vYmplY3QoKS5hbGxvdyhudWxsKSxcbiAgICBnZW5lcmF0ZUtleTogSm9pLmZ1bmMoKSxcbiAgICBjYWNoZTogaW50ZXJuYWxzLmNhY2hlUG9saWN5XG59KTtcblxuXG5pbnRlcm5hbHMubWV0aG9kT2JqZWN0ID0gSm9pLm9iamVjdCh7XG4gICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgbWV0aG9kOiBKb2kuZnVuYygpLnJlcXVpcmVkKCksXG4gICAgb3B0aW9uczogSm9pLm9iamVjdCgpXG59KTtcblxuXG5pbnRlcm5hbHMucmVnaXN0ZXIgPSBKb2kub2JqZWN0KHtcbiAgICBvbmNlOiB0cnVlLFxuICAgIHJvdXRlczogSm9pLm9iamVjdCh7XG4gICAgICAgIHByZWZpeDogSm9pLnN0cmluZygpLnJlZ2V4KC9eXFwvLisvKSxcbiAgICAgICAgdmhvc3Q6IGludGVybmFscy52aG9zdFxuICAgIH0pXG4gICAgICAgIC5kZWZhdWx0KHt9KVxufSk7XG5cblxuaW50ZXJuYWxzLnNlbXZlciA9IEpvaS5zdHJpbmcoKTtcblxuXG5pbnRlcm5hbHMucGx1Z2luID0gaW50ZXJuYWxzLnJlZ2lzdGVyLmtleXMoe1xuICAgIG9wdGlvbnM6IEpvaS5hbnkoKSxcbiAgICBwbHVnaW46IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWdpc3RlcjogSm9pLmZ1bmMoKS5yZXF1aXJlZCgpLFxuICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkud2hlbigncGtnLm5hbWUnLCB7IGlzOiBKb2kuZXhpc3QoKSwgb3RoZXJ3aXNlOiBKb2kucmVxdWlyZWQoKSB9KSxcbiAgICAgICAgdmVyc2lvbjogSm9pLnN0cmluZygpLFxuICAgICAgICBtdWx0aXBsZTogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICAgICAgICBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCgpLnBhdHRlcm4oLy4rLywgaW50ZXJuYWxzLnNlbXZlcilcbiAgICAgICAgXSxcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgcmVxdWlyZW1lbnRzOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIGhhcGk6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIG5vZGU6IEpvaS5zdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmRlZmF1bHQoKSxcbiAgICAgICAgcGtnOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIHZlcnNpb246IEpvaS5zdHJpbmcoKS5kZWZhdWx0KCcwLjAuMCcpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudW5rbm93bigpXG4gICAgICAgICAgICAuZGVmYXVsdCh7fSlcbiAgICB9KVxuICAgICAgICAudW5rbm93bigpXG59KVxuICAgIC53aXRob3V0KCdvbmNlJywgJ29wdGlvbnMnKVxuICAgIC51bmtub3duKCk7XG5cblxuaW50ZXJuYWxzLnJ1bGVzID0gSm9pLm9iamVjdCh7XG4gICAgdmFsaWRhdGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBzY2hlbWE6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLm9iamVjdCgpLCBKb2kuYXJyYXkoKSkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpXG4gICAgICAgICAgICAuZGVmYXVsdCh7IGFsbG93VW5rbm93bjogdHJ1ZSB9KVxuICAgIH0pXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IEh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IE9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IFBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IENhbGwgPSByZXF1aXJlKCdAaGFwaS9jYWxsJyk7XG5jb25zdCBDYXRib3ggPSByZXF1aXJlKCdAaGFwaS9jYXRib3gnKTtcbmNvbnN0IENhdGJveE1lbW9yeSA9IHJlcXVpcmUoJ0BoYXBpL2NhdGJveC1tZW1vcnknKTtcbmNvbnN0IEhlYXZ5ID0gcmVxdWlyZSgnQGhhcGkvaGVhdnknKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBNaW1vcyA9IHJlcXVpcmUoJ0BoYXBpL21pbW9zJyk7XG5jb25zdCBQb2RpdW0gPSByZXF1aXJlKCdAaGFwaS9wb2RpdW0nKTtcbmNvbnN0IFNvbWV2ZXIgPSByZXF1aXJlKCdAaGFwaS9zb21ldmVyJyk7XG5jb25zdCBTdGF0ZWhvb2QgPSByZXF1aXJlKCdAaGFwaS9zdGF0ZWhvb2QnKTtcblxuY29uc3QgQXV0aCA9IHJlcXVpcmUoJy4vYXV0aCcpO1xuY29uc3QgQ29tcHJlc3Npb24gPSByZXF1aXJlKCcuL2NvbXByZXNzaW9uJyk7XG5jb25zdCBDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuY29uc3QgQ29ycyA9IHJlcXVpcmUoJy4vY29ycycpO1xuY29uc3QgRXh0ID0gcmVxdWlyZSgnLi9leHQnKTtcbmNvbnN0IE1ldGhvZHMgPSByZXF1aXJlKCcuL21ldGhvZHMnKTtcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcbmNvbnN0IFJvdXRlID0gcmVxdWlyZSgnLi9yb3V0ZScpO1xuY29uc3QgVG9vbGtpdCA9IHJlcXVpcmUoJy4vdG9vbGtpdCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb3VudGVyOiB7XG4gICAgICAgIG1pbjogMTAwMDAsXG4gICAgICAgIG1heDogOTk5OTlcbiAgICB9LFxuICAgIGV2ZW50czogW1xuICAgICAgICB7IG5hbWU6ICdsb2cnLCBjaGFubmVsczogWydhcHAnLCAnaW50ZXJuYWwnXSwgdGFnczogdHJ1ZSB9LFxuICAgICAgICB7IG5hbWU6ICdyZXF1ZXN0JywgY2hhbm5lbHM6IFsnYXBwJywgJ2ludGVybmFsJywgJ2Vycm9yJ10sIHRhZ3M6IHRydWUsIHNwcmVhZDogdHJ1ZSB9LFxuICAgICAgICAncmVzcG9uc2UnLFxuICAgICAgICAncm91dGUnLFxuICAgICAgICAnc3RhcnQnLFxuICAgICAgICAnc3RvcCdcbiAgICBdLFxuICAgIGJhZFJlcXVlc3RSZXNwb25zZTogQnVmZmVyLmZyb20oJ0hUVFAvMS4xIDQwMCBCYWQgUmVxdWVzdFxcclxcblxcclxcbicsICdhc2NpaScpXG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Db3JlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzcGF0Y2ggcmVmZXJlbmNlIG9mIHRoZSByb290IHNlcnZlclxuXG4gICAgICAgIGNvbnN0IHsgc2V0dGluZ3MsIHR5cGUgfSA9IGludGVybmFscy5zZXR1cChvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgdGhpcy5hcHAgPSB7fTtcbiAgICAgICAgdGhpcy5hdXRoID0gbmV3IEF1dGgodGhpcyk7XG4gICAgICAgIHRoaXMuY2FjaGVzID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgY2xpZW50c1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uID0gbmV3IENvbXByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlZCA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXIgc2VydmVycyBsaW5rZWQgdG8gdGhlIHBoYXNlcyBvZiB0aGlzIHNlcnZlclxuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0geyBoYW5kbGVyOiBbXSwgcmVxdWVzdDogW10sIHNlcnZlcjogW10sIHRvb2xraXQ6IFtdIH07ICAgICAgIC8vIFB1YmxpYyBkZWNvcmF0aW9uIG5hbWVzXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW107ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGx1Z2luIGRlcGVuZGVuY2llc1xuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBQb2RpdW0oaW50ZXJuYWxzLmV2ZW50cyk7XG4gICAgICAgIHRoaXMuaGVhdnkgPSBuZXcgSGVhdnkodGhpcy5zZXR0aW5ncy5sb2FkKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IG5ldyBNZXRob2RzKHRoaXMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VydmVyIG1ldGhvZHNcbiAgICAgICAgdGhpcy5taW1lID0gbmV3IE1pbW9zKHRoaXMuc2V0dGluZ3MubWltZSk7XG4gICAgICAgIHRoaXMub25Db25uZWN0aW9uID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgb24gc3RvcFxuICAgICAgICB0aGlzLnBsdWdpbnMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cG9zZWQgcGx1Z2luIHByb3BlcnRpZXMgYnkgbmFtZVxuICAgICAgICB0aGlzLnF1ZXVlID0gbmV3IGludGVybmFscy5RdWV1ZSh0aGlzLnNldHRpbmdzLmxvYWQpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbnMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrcyBwbHVnaW4gZm9yIGRlcGVuZGVuY3kgdmFsaWRhdGlvbiB7IG5hbWUgLT4geyB2ZXJzaW9uIH0gfVxuICAgICAgICB0aGlzLnJlZ2lzdHJpbmcgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vID4gMCB3aGlsZSByZWdpc3RlcigpIGlzIHdhaXRpbmcgZm9yIHBsdWdpbiBjYWxsYmFja3NcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q291bnRlciA9IHsgdmFsdWU6IGludGVybmFscy5jb3VudGVyLm1pbiwgbWluOiBpbnRlcm5hbHMuY291bnRlci5taW4sIG1heDogaW50ZXJuYWxzLmNvdW50ZXIubWF4IH07XG4gICAgICAgIHRoaXMucm91dGVyID0gbmV3IENhbGwuUm91dGVyKHRoaXMuc2V0dGluZ3Mucm91dGVyKTtcbiAgICAgICAgdGhpcy5waGFzZSA9ICdzdG9wcGVkJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnc3RvcHBlZCcsICdpbml0aWFsaXppbmcnLCAnaW5pdGlhbGl6ZWQnLCAnc3RhcnRpbmcnLCAnc3RhcnRlZCcsICdzdG9wcGluZycsICdpbnZhbGlkJ1xuICAgICAgICB0aGlzLnNvY2tldHMgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWNrIG9wZW4gc29ja2V0cyBmb3IgZ3JhY2VmdWwgc2h1dGRvd25cbiAgICAgICAgdGhpcy5hY3RpdmVzID0gbmV3IFdlYWtNYXAoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBY3RpdmUgcmVxdWVzdHMgYmVpbmcgcHJvY2Vzc2VkXG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZWhvb2QuRGVmaW5pdGlvbnModGhpcy5zZXR0aW5ncy5zdGF0ZSk7XG4gICAgICAgIHRoaXMudG9vbGtpdCA9IG5ldyBUb29sa2l0KCk7XG5cbiAgICAgICAgdGhpcy5leHRlbnNpb25zU2VxID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VkIHRvIGtlZXAgYWJzb2x1dGUgb3JkZXIgb2YgZXh0ZW5zaW9ucyBiYXNlZCBvbiB0aGUgb3JkZXIgYWRkZWQgYWNyb3NzIGxvY2F0aW9uc1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgICAgICAgICBzZXJ2ZXI6IHtcbiAgICAgICAgICAgICAgICBvblByZVN0YXJ0OiBuZXcgRXh0KCdvblByZVN0YXJ0JywgdGhpcyksXG4gICAgICAgICAgICAgICAgb25Qb3N0U3RhcnQ6IG5ldyBFeHQoJ29uUG9zdFN0YXJ0JywgdGhpcyksXG4gICAgICAgICAgICAgICAgb25QcmVTdG9wOiBuZXcgRXh0KCdvblByZVN0b3AnLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBvblBvc3RTdG9wOiBuZXcgRXh0KCdvblBvc3RTdG9wJywgdGhpcylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByb3V0ZToge1xuICAgICAgICAgICAgICAgIG9uUmVxdWVzdDogbmV3IEV4dCgnb25SZXF1ZXN0JywgdGhpcyksXG4gICAgICAgICAgICAgICAgb25QcmVBdXRoOiBuZXcgRXh0KCdvblByZUF1dGgnLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBvbkNyZWRlbnRpYWxzOiBuZXcgRXh0KCdvbkNyZWRlbnRpYWxzJywgdGhpcyksXG4gICAgICAgICAgICAgICAgb25Qb3N0QXV0aDogbmV3IEV4dCgnb25Qb3N0QXV0aCcsIHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uUHJlSGFuZGxlcjogbmV3IEV4dCgnb25QcmVIYW5kbGVyJywgdGhpcyksXG4gICAgICAgICAgICAgICAgb25Qb3N0SGFuZGxlcjogbmV3IEV4dCgnb25Qb3N0SGFuZGxlcicsIHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uUHJlUmVzcG9uc2U6IG5ldyBFeHQoJ29uUHJlUmVzcG9uc2UnLCB0aGlzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgUmVxdWVzdCB7IH07XG5cbiAgICAgICAgdGhpcy5fZGVidWcoKTtcbiAgICAgICAgdGhpcy5fZGVjb3JhdGlvbnMgPSB7IGhhbmRsZXI6IHt9LCByZXF1ZXN0OiB7fSwgc2VydmVyOiB7fSwgdG9vbGtpdDoge30sIHJlcXVlc3RBcHBseTogbnVsbCB9O1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplQ2FjaGUoKTtcblxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gdGhpcy5fY3JlYXRlTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuaW5mbyA9IHRoaXMuX2luZm8oKTtcbiAgICB9XG5cbiAgICBfZGVidWcoKSB7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHNlcnZlciBsb2cgZXZlbnRzXG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnID0gKHJlcXVlc3QsIGV2ZW50KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZXZlbnQuZXJyb3IgfHwgZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEZWJ1ZzonLCBldmVudC50YWdzLmpvaW4oJywgJyksIGRhdGEgPyAnXFxuICAgICcgKyAoZGF0YS5zdGFjayB8fCAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8gSG9lay5zdHJpbmdpZnkoZGF0YSkgOiBkYXRhKSkgOiAnJyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLnNldHRpbmdzLmRlYnVnLmxvZy5zb21lKCh0YWcpID0+IHRhZyA9PT0gJyonKSA/IHVuZGVmaW5lZCA6IHRoaXMuc2V0dGluZ3MuZGVidWcubG9nO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLm9uKHsgbmFtZTogJ2xvZycsIGZpbHRlciB9LCAoZXZlbnQpID0+IGRlYnVnKG51bGwsIGV2ZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlYnVnLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLnNldHRpbmdzLmRlYnVnLnJlcXVlc3Quc29tZSgodGFnKSA9PiB0YWcgPT09ICcqJykgPyB1bmRlZmluZWQgOiB0aGlzLnNldHRpbmdzLmRlYnVnLnJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub24oeyBuYW1lOiAncmVxdWVzdCcsIGZpbHRlciB9LCBkZWJ1Zyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZUNhY2hlKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZSh0aGlzLnNldHRpbmdzLmNhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5jYWNoZXMuaGFzKCdfZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDYWNoZShbeyBwcm92aWRlcjogQ2F0Ym94TWVtb3J5IH1dKTsgICAgICAgIC8vIERlZmF1bHRzIHRvIG1lbW9yeS1iYXNlZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2luZm8oKSB7XG5cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLnR5cGUgPT09ICd0Y3AnID8gKHRoaXMuc2V0dGluZ3MudGxzID8gJ2h0dHBzJyA6ICdodHRwJykgOiB0aGlzLnR5cGU7XG4gICAgICAgIGNvbnN0IGhvc3QgPSB0aGlzLnNldHRpbmdzLmhvc3QgfHwgT3MuaG9zdG5hbWUoKSB8fCAnbG9jYWxob3N0JztcbiAgICAgICAgY29uc3QgcG9ydCA9IHRoaXMuc2V0dGluZ3MucG9ydDtcblxuICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgICAgY3JlYXRlZDogbm93LFxuICAgICAgICAgICAgc3RhcnRlZDogMCxcbiAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICBwb3J0LFxuICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICBpZDogT3MuaG9zdG5hbWUoKSArICc6JyArIHByb2Nlc3MucGlkICsgJzonICsgbm93LnRvU3RyaW5nKDM2KSxcbiAgICAgICAgICAgIHVyaTogdGhpcy5zZXR0aW5ncy51cmkgfHwgKHByb3RvY29sICsgJzonICsgKHRoaXMudHlwZSA9PT0gJ3RjcCcgPyAnLy8nICsgaG9zdCArIChwb3J0ID8gJzonICsgcG9ydCA6ICcnKSA6IHBvcnQpKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIF9jcmVhdGVDYWNoZShjb25maWdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5waGFzZSAhPT0gJ2luaXRpYWxpemluZycsICdDYW5ub3QgcHJvdmlzaW9uIHNlcnZlciBjYWNoZSB3aGlsZSBzZXJ2ZXIgaXMgaW5pdGlhbGl6aW5nJyk7XG5cbiAgICAgICAgY29uZmlncyA9IENvbmZpZy5hcHBseSgnY2FjaGUnLCBjb25maWdzKTtcblxuICAgICAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBjb25maWcgb2YgY29uZmlncykge1xuXG4gICAgICAgICAgICAvLyA8ZnVuY3Rpb24+XG4gICAgICAgICAgICAvLyB7IHByb3ZpZGVyOiA8ZnVuY3Rpb24+IH1cbiAgICAgICAgICAgIC8vIHsgcHJvdmlkZXI6IHsgY29uc3RydWN0b3I6IDxmdW5jdGlvbj4sIG9wdGlvbnMgfSB9XG4gICAgICAgICAgICAvLyB7IGVuZ2luZSB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0geyBwcm92aWRlcjogeyBjb25zdHJ1Y3RvcjogY29uZmlnIH0gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lIHx8ICdfZGVmYXVsdCc7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5jYWNoZXMuaGFzKG5hbWUpLCAnQ2Fubm90IGNvbmZpZ3VyZSB0aGUgc2FtZSBjYWNoZSBtb3JlIHRoYW4gb25jZTogJywgbmFtZSA9PT0gJ19kZWZhdWx0JyA/ICdkZWZhdWx0IGNhY2hlJyA6IG5hbWUpO1xuXG4gICAgICAgICAgICBsZXQgY2xpZW50ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5wcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGxldCBwcm92aWRlciA9IGNvbmZpZy5wcm92aWRlcjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geyBjb25zdHJ1Y3RvcjogcHJvdmlkZXIgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjbGllbnQgPSBuZXcgQ2F0Ym94LkNsaWVudChwcm92aWRlci5jb25zdHJ1Y3RvciwgcHJvdmlkZXIub3B0aW9ucyB8fCB7IHBhcnRpdGlvbjogJ2hhcGktY2FjaGUnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xpZW50ID0gbmV3IENhdGJveC5DbGllbnQoY29uZmlnLmVuZ2luZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2FjaGVzLnNldChuYW1lLCB7IGNsaWVudCwgc2VnbWVudHM6IHt9LCBzaGFyZWQ6IGNvbmZpZy5zaGFyZWQgfHwgZmFsc2UgfSk7XG4gICAgICAgICAgICBhZGRlZC5wdXNoKGNsaWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRkZWQ7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJTZXJ2ZXIoc2VydmVyKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHNlcnZlcjtcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRSb3V0ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzLmFkZChzZXJ2ZXIpO1xuICAgIH1cblxuICAgIGFzeW5jIF9zdGFydCgpIHtcblxuICAgICAgICBpZiAodGhpcy5waGFzZSA9PT0gJ2luaXRpYWxpemVkJyB8fFxuICAgICAgICAgICAgdGhpcy5waGFzZSA9PT0gJ3N0YXJ0ZWQnKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlRGVwcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGhhc2UgPT09ICdzdGFydGVkJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGhhc2UgIT09ICdzdG9wcGVkJyAmJlxuICAgICAgICAgICAgdGhpcy5waGFzZSAhPT0gJ2luaXRpYWxpemVkJykge1xuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdGFydCBzZXJ2ZXIgd2hpbGUgaXQgaXMgaW4gJyArIHRoaXMucGhhc2UgKyAnIHBoYXNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5waGFzZSAhPT0gJ2luaXRpYWxpemVkJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5waGFzZSA9ICdzdGFydGluZyc7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5mby5zdGFydGVkID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbGlzdGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnBoYXNlID0gJ2ludmFsaWQnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5waGFzZSA9ICdzdGFydGVkJztcbiAgICAgICAgYXdhaXQgdGhpcy5ldmVudHMuZW1pdCgnc3RhcnQnKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY29udHJvbGxlZC5tYXAoKGNvbnRyb2wpID0+IGNvbnRyb2wuc3RhcnQoKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9pbnZva2UoJ29uUG9zdFN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5waGFzZSA9ICdpbnZhbGlkJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9saXN0ZW4oKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmF1dG9MaXN0ZW4pIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuXG4gICAgICAgICAgICBjb25zdCBmaW5hbGl6ZSA9ICgpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICd0Y3AnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5saXN0ZW4odGhpcy5zZXR0aW5ncy5wb3J0LCBmaW5hbGl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5zZXR0aW5ncy5hZGRyZXNzIHx8IHRoaXMuc2V0dGluZ3MuaG9zdCB8fCAnMC4wLjAuMCc7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5saXN0ZW4odGhpcy5zZXR0aW5ncy5wb3J0LCBhZGRyZXNzLCBmaW5hbGl6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIF9pbml0aWFsaXplKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdHJpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN0YXJ0IHNlcnZlciBiZWZvcmUgcGx1Z2lucyBmaW5pc2hlZCByZWdpc3RyYXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBoYXNlID09PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5waGFzZSAhPT0gJ3N0b3BwZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbml0aWFsaXplIHNlcnZlciB3aGlsZSBpdCBpcyBpbiAnICsgdGhpcy5waGFzZSArICcgcGhhc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlRGVwcygpO1xuICAgICAgICB0aGlzLnBoYXNlID0gJ2luaXRpYWxpemluZyc7XG5cbiAgICAgICAgLy8gU3RhcnQgY2FjaGVcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmNhY2hlcy5mb3JFYWNoKChjYWNoZSkgPT4gY2FjaGVzLnB1c2goY2FjaGUuY2xpZW50LnN0YXJ0KCkpKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhY2hlcyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9pbnZva2UoJ29uUHJlU3RhcnQnKTtcbiAgICAgICAgICAgIHRoaXMuaGVhdnkuc3RhcnQoKTtcbiAgICAgICAgICAgIHRoaXMucGhhc2UgPSAnaW5pdGlhbGl6ZWQnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jb250cm9sbGVkLm1hcCgoY29udHJvbCkgPT4gY29udHJvbC5pbml0aWFsaXplKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnBoYXNlID0gJ2ludmFsaWQnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlRGVwcygpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHsgZGVwcywgcGx1Z2luIH0gb2YgdGhpcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwIGluIGRlcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gZGVwc1tkZXBdO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMucmVnaXN0cmF0aW9uc1tkZXBdLCAnUGx1Z2luJywgcGx1Z2luLCAnbWlzc2luZyBkZXBlbmRlbmN5JywgZGVwKTtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh2ZXJzaW9uID09PSAnKicgfHwgU29tZXZlci5tYXRjaCh0aGlzLnJlZ2lzdHJhdGlvbnNbZGVwXS52ZXJzaW9uLCB2ZXJzaW9uKSwgJ1BsdWdpbicsIHBsdWdpbiwgJ3JlcXVpcmVzJywgZGVwLCAndmVyc2lvbicsIHZlcnNpb24sICdidXQgZm91bmQnLCB0aGlzLnJlZ2lzdHJhdGlvbnNbZGVwXS52ZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIF9zdG9wKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIG9wdGlvbnMudGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCA1MDAwOyAgICAgICAgICAvLyBEZWZhdWx0IHRpbWVvdXQgdG8gNSBzZWNvbmRzXG5cbiAgICAgICAgaWYgKFsnc3RvcHBlZCcsICdpbml0aWFsaXplZCcsICdzdGFydGVkJywgJ2ludmFsaWQnXS5pbmRleE9mKHRoaXMucGhhc2UpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RvcCBzZXJ2ZXIgd2hpbGUgaW4gJyArIHRoaXMucGhhc2UgKyAnIHBoYXNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBoYXNlID0gJ3N0b3BwaW5nJztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5faW52b2tlKCdvblByZVN0b3AnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5zdGFydGVkID0gMDtcblxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VubGlzdGVuKG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jYWNoZXMuZm9yRWFjaCgoY2FjaGUpID0+IGNhY2hlcy5wdXNoKGNhY2hlLmNsaWVudC5zdG9wKCkpKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNhY2hlcyk7XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZXZlbnRzLmVtaXQoJ3N0b3AnKTtcbiAgICAgICAgICAgIHRoaXMuaGVhdnkuc3RvcCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jb250cm9sbGVkLm1hcCgoY29udHJvbCkgPT4gY29udHJvbC5zdG9wKG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2ludm9rZSgnb25Qb3N0U3RvcCcpO1xuICAgICAgICAgICAgdGhpcy5waGFzZSA9ICdzdG9wcGVkJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnBoYXNlID0gJ2ludmFsaWQnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VubGlzdGVuKHRpbWVvdXQpIHtcblxuICAgICAgICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mub3BlcmF0aW9ucy5jbGVhblN0b3ApIHtcblxuICAgICAgICAgICAgLy8gU2V0IGNvbm5lY3Rpb25zIHRpbWVvdXRcblxuICAgICAgICAgICAgY29uc3QgZGVzdHJveSA9ICgpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0cy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiBjb25uZWN0aW9uLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlc3Ryb3ksIHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBUZWxsIGlkbGUga2VlcC1hbGl2ZSBjb25uZWN0aW9ucyB0byBjbG9zZVxuXG4gICAgICAgICAgICB0aGlzLnNvY2tldHMuZm9yRWFjaCgoY29ubmVjdGlvbikgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZXMuaGFzKGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9zZSBjb25uZWN0aW9uXG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIuY2xvc2UoKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mub3BlcmF0aW9ucy5jbGVhblN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5yZW1vdmVMaXN0ZW5lcih0aGlzLnNldHRpbmdzLnRscyA/ICdzZWN1cmVDb25uZWN0aW9uJyA6ICdjb25uZWN0aW9uJywgdGhpcy5vbkNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2ludm9rZSh0eXBlKSB7XG5cbiAgICAgICAgY29uc3QgZXh0cyA9IHRoaXMuZXh0ZW5zaW9ucy5zZXJ2ZXJbdHlwZV07XG4gICAgICAgIGlmICghZXh0cy5ub2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBleHRlbnNpb25zXG5cbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgZXh0cy5ub2Rlcykge1xuICAgICAgICAgICAgY29uc3QgYmluZCA9IGV4dC5iaW5kIHx8IGV4dC5yZWFsbS5zZXR0aW5ncy5iaW5kO1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gZXh0LmZ1bmMuY2FsbChiaW5kLCBleHQuc2VydmVyLCBiaW5kKTtcbiAgICAgICAgICAgIGF3YWl0IFRvb2xraXQudGltZWQob3BlcmF0aW9uLCB7IHRpbWVvdXQ6IGV4dC50aW1lb3V0LCBuYW1lOiB0eXBlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2RlZmF1bHRSb3V0ZXMoKSB7XG5cbiAgICAgICAgdGhpcy5yb3V0ZXIuc3BlY2lhbCgnbm90Rm91bmQnLCBuZXcgUm91dGUoeyBtZXRob2Q6ICdfc3BlY2lhbCcsIHBhdGg6ICcve3AqfScsIGhhbmRsZXI6IGludGVybmFscy5ub3RGb3VuZCB9LCB0aGlzLnJvb3QsIHsgc3BlY2lhbDogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMucm91dGVyLnNwZWNpYWwoJ2JhZFJlcXVlc3QnLCBuZXcgUm91dGUoeyBtZXRob2Q6ICdfc3BlY2lhbCcsIHBhdGg6ICcve3AqfScsIGhhbmRsZXI6IGludGVybmFscy5iYWRSZXF1ZXN0IH0sIHRoaXMucm9vdCwgeyBzcGVjaWFsOiB0cnVlIH0pKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yb3V0ZXMuY29ycykge1xuICAgICAgICAgICAgQ29ycy5oYW5kbGVyKHRoaXMucm9vdCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlzcGF0Y2gob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgcmV0dXJuIChyZXEsIHJlcykgPT4ge1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgcmVxdWVzdFxuXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gUmVxdWVzdC5nZW5lcmF0ZSh0aGlzLnJvb3QsIHJlcSwgcmVzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gVHJhY2sgc29ja2V0IHJlcXVlc3QgcHJvY2Vzc2luZyBzdGF0ZVxuXG4gICAgICAgICAgICBpZiAocmVxLnNvY2tldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlcy5zZXQocmVxLnNvY2tldCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW52ID0geyBjb3JlOiB0aGlzLCByZXEgfTtcbiAgICAgICAgICAgICAgICByZXMub24oJ2ZpbmlzaCcsIGludGVybmFscy5vbkZpbmlzaC5iaW5kKHJlcywgZW52KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGxvYWRcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubG9hZC5zYW1wbGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhdnkuY2hlY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nKFsnbG9hZCddLCB0aGlzLmhlYXZ5LmxvYWQpO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Ll9yZXBseShlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlLmFkZChyZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfY3JlYXRlTGlzdGVuZXIoKSB7XG5cbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLnNldHRpbmdzLmxpc3RlbmVyIHx8ICh0aGlzLnNldHRpbmdzLnRscyA/IEh0dHBzLmNyZWF0ZVNlcnZlcih0aGlzLnNldHRpbmdzLnRscykgOiBIdHRwLmNyZWF0ZVNlcnZlcigpKTtcbiAgICAgICAgbGlzdGVuZXIub24oJ3JlcXVlc3QnLCB0aGlzLl9kaXNwYXRjaCgpKTtcbiAgICAgICAgbGlzdGVuZXIub24oJ2NoZWNrQ29udGludWUnLCB0aGlzLl9kaXNwYXRjaCh7IGV4cGVjdENvbnRpbnVlOiB0cnVlIH0pKTtcblxuICAgICAgICBsaXN0ZW5lci5vbignY2xpZW50RXJyb3InLCAoZXJyLCBzb2NrZXQpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5fbG9nKFsnY29ubmVjdGlvbicsICdjbGllbnQnLCAnZXJyb3InXSwgZXJyKTtcblxuICAgICAgICAgICAgaWYgKHNvY2tldC5yZWFkYWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmFjdGl2ZXMuZ2V0KHNvY2tldCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBCb29tLmJhZFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iub3V0cHV0LmhlYWRlcnMgPSB7IGNvbm5lY3Rpb246ICdjbG9zZScgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5fcmVwbHkoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmVuZChpbnRlcm5hbHMuYmFkUmVxdWVzdFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVMaXN0ZW5lcigpIHtcblxuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uY2UoJ2xpc3RlbmluZycsICgpID0+IHtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBhZGRyZXNzLCBwb3J0LCBhbmQgdXJpIHdpdGggYWN0aXZlIHZhbHVlc1xuXG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAndGNwJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmxpc3RlbmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8uYWRkcmVzcyA9IGFkZHJlc3MuYWRkcmVzcztcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8ucG9ydCA9IGFkZHJlc3MucG9ydDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZm8udXJpID0gdGhpcy5zZXR0aW5ncy51cmkgfHwgdGhpcy5pbmZvLnByb3RvY29sICsgJzovLycgKyB0aGlzLmluZm8uaG9zdCArICc6JyArIHRoaXMuaW5mby5wb3J0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vcGVyYXRpb25zLmNsZWFuU3RvcCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7ICAgICAgICAgICAvLyAndGhpcycgaXMgYm91bmQgdG8gdGhlIGVtaXR0ZXJcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNvY2tldHMuZGVsZXRlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdGlvbiA9IChjb25uZWN0aW9uKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmFkZChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5vbignY2xvc2UnLCBvbkNsb3NlKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbih0aGlzLnNldHRpbmdzLnRscyA/ICdzZWN1cmVDb25uZWN0aW9uJyA6ICdjb25uZWN0aW9uJywgdGhpcy5vbkNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfY2FjaGVQb2xpY3kob3B0aW9ucywgX3NlZ21lbnQsIHJlYWxtKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5hcHBseSgnY2FjaGVQb2xpY3knLCBvcHRpb25zKTtcblxuICAgICAgICBjb25zdCBwbHVnaW4gPSByZWFsbSAmJiByZWFsbS5wbHVnaW47XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBvcHRpb25zLnNlZ21lbnQgfHwgX3NlZ21lbnQgfHwgKHBsdWdpbiA/IGAhJHtwbHVnaW59YCA6ICcnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoc2VnbWVudCwgJ01pc3NpbmcgY2FjaGUgc2VnbWVudCBuYW1lJyk7XG5cbiAgICAgICAgY29uc3QgY2FjaGVOYW1lID0gb3B0aW9ucy5jYWNoZSB8fCAnX2RlZmF1bHQnO1xuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuY2FjaGVzLmdldChjYWNoZU5hbWUpO1xuICAgICAgICBIb2VrLmFzc2VydChjYWNoZSwgJ1Vua25vd24gY2FjaGUnLCBjYWNoZU5hbWUpO1xuICAgICAgICBIb2VrLmFzc2VydCghY2FjaGUuc2VnbWVudHNbc2VnbWVudF0gfHwgY2FjaGUuc2hhcmVkIHx8IG9wdGlvbnMuc2hhcmVkLCAnQ2Fubm90IHByb3Zpc2lvbiB0aGUgc2FtZSBjYWNoZSBzZWdtZW50IG1vcmUgdGhhbiBvbmNlJyk7XG4gICAgICAgIGNhY2hlLnNlZ21lbnRzW3NlZ21lbnRdID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gbmV3IENhdGJveC5Qb2xpY3kob3B0aW9ucywgY2FjaGUuY2xpZW50LCBzZWdtZW50KTtcbiAgICB9XG5cbiAgICBsb2codGFncywgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2codGFncywgZGF0YSwgJ2FwcCcpO1xuICAgIH1cblxuICAgIF9sb2codGFncywgZGF0YSwgY2hhbm5lbCA9ICdpbnRlcm5hbCcpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzLmhhc0xpc3RlbmVycygnbG9nJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgICAgICAgICAgdGFncyA9IFt0YWdzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZGF0YSBpbnN0YW5jZW9mIEVycm9yID8gJ2Vycm9yJyA6ICdkYXRhJztcblxuICAgICAgICBsZXQgZXZlbnQgPSB7IHRpbWVzdGFtcCwgdGFncywgW2ZpZWxkXTogZGF0YSwgY2hhbm5lbCB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXZlbnQgPSAoKSA9PiAoeyB0aW1lc3RhbXAsIHRhZ3MsIGRhdGE6IGRhdGEoKSwgY2hhbm5lbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoeyBuYW1lOiAnbG9nJywgdGFncywgY2hhbm5lbCB9LCBldmVudCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBIb2VrLmNsb25lKG9wdGlvbnMsIHsgc2hhbGxvdzogWydjYWNoZScsICdsaXN0ZW5lcicsICdyb3V0ZXMuYmluZCddIH0pO1xuICAgIHNldHRpbmdzLnJvdXRlcyA9IENvbmZpZy5lbmFibGUoc2V0dGluZ3Mucm91dGVzKTtcbiAgICBzZXR0aW5ncyA9IENvbmZpZy5hcHBseSgnc2VydmVyJywgc2V0dGluZ3MpO1xuXG4gICAgaWYgKHNldHRpbmdzLnBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXR0aW5ncy5wb3J0ID0gMDtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gKHR5cGVvZiBzZXR0aW5ncy5wb3J0ID09PSAnc3RyaW5nJyA/ICdzb2NrZXQnIDogJ3RjcCcpO1xuICAgIGlmICh0eXBlID09PSAnc29ja2V0Jykge1xuICAgICAgICBzZXR0aW5ncy5wb3J0ID0gKHNldHRpbmdzLnBvcnQuaW5kZXhPZignLycpICE9PSAtMSA/IFBhdGgucmVzb2x2ZShzZXR0aW5ncy5wb3J0KSA6IHNldHRpbmdzLnBvcnQudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLmF1dG9MaXN0ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXR0aW5ncy5hdXRvTGlzdGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBIb2VrLmFzc2VydChzZXR0aW5ncy5hdXRvTGlzdGVuIHx8ICFzZXR0aW5ncy5wb3J0LCAnQ2Fubm90IHNwZWNpZnkgcG9ydCB3aGVuIGF1dG9MaXN0ZW4gaXMgZmFsc2UnKTtcbiAgICBIb2VrLmFzc2VydChzZXR0aW5ncy5hdXRvTGlzdGVuIHx8ICFzZXR0aW5ncy5hZGRyZXNzLCAnQ2Fubm90IHNwZWNpZnkgYWRkcmVzcyB3aGVuIGF1dG9MaXN0ZW4gaXMgZmFsc2UnKTtcblxuICAgIHJldHVybiB7IHNldHRpbmdzLCB0eXBlIH07XG59O1xuXG5cbmludGVybmFscy5ub3RGb3VuZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRocm93IEJvb20ubm90Rm91bmQoKTtcbn07XG5cblxuaW50ZXJuYWxzLmJhZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoKTtcbn07XG5cblxuaW50ZXJuYWxzLm9uRmluaXNoID0gZnVuY3Rpb24gKGVudikge1xuXG4gICAgY29uc3QgeyBjb3JlLCByZXEgfSA9IGVudjtcblxuICAgIGNvcmUuYWN0aXZlcy5kZWxldGUocmVxLnNvY2tldCk7XG4gICAgaWYgKCFjb3JlLnN0YXJ0ZWQpIHtcbiAgICAgICAgcmVxLnNvY2tldC5lbmQoKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5RdWV1ZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gb3B0aW9ucztcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB9XG5cbiAgICBhZGQocmVxdWVzdCkge1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5fZXhlY3V0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV4dCgpIHtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggJiZcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlIDwgdGhpcy5zZXR0aW5ncy5jb25jdXJyZW50KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICArK3RoaXMuYWN0aXZlO1xuICAgICAgICAgICAgcmVxdWVzdC5fZXhlY3V0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVsZWFzZSgpIHtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICAtLXRoaXMuYWN0aXZlO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxubGV0IFJvdXRlID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxheWVkIGxvYWQgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY3lcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnJvdXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBIb2VrLmNsb25lKG9wdGlvbnMpO1xuICAgIHNldHRpbmdzLl9oZWFkZXJzID0gc2V0dGluZ3MuaGVhZGVycy5jb25jYXQoc2V0dGluZ3MuYWRkaXRpb25hbEhlYWRlcnMpO1xuICAgIHNldHRpbmdzLl9oZWFkZXJzU3RyaW5nID0gc2V0dGluZ3MuX2hlYWRlcnMuam9pbignLCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MuX2hlYWRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc2V0dGluZ3MuX2hlYWRlcnNbaV0gPSBzZXR0aW5ncy5faGVhZGVyc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5faGVhZGVycy5pbmRleE9mKCdvcmlnaW4nKSA9PT0gLTEpIHtcbiAgICAgICAgc2V0dGluZ3MuX2hlYWRlcnMucHVzaCgnb3JpZ2luJyk7XG4gICAgfVxuXG4gICAgc2V0dGluZ3MuX2V4cG9zZWRIZWFkZXJzID0gc2V0dGluZ3MuZXhwb3NlZEhlYWRlcnMuY29uY2F0KHNldHRpbmdzLmFkZGl0aW9uYWxFeHBvc2VkSGVhZGVycykuam9pbignLCcpO1xuXG4gICAgaWYgKHNldHRpbmdzLm9yaWdpbiA9PT0gJ2lnbm9yZScpIHtcbiAgICAgICAgc2V0dGluZ3MuX29yaWdpbiA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZXR0aW5ncy5vcmlnaW4uaW5kZXhPZignKicpICE9PSAtMSkge1xuICAgICAgICBIb2VrLmFzc2VydChzZXR0aW5ncy5vcmlnaW4ubGVuZ3RoID09PSAxLCAnQ2Fubm90IHNwZWNpZnkgY29ycy5vcmlnaW4gKiB0b2dldGhlciB3aXRoIG90aGVyIHZhbHVlcycpO1xuICAgICAgICBzZXR0aW5ncy5fb3JpZ2luID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldHRpbmdzLl9vcmlnaW4gPSB7XG4gICAgICAgICAgICBxdWFsaWZpZWQ6IFtdLFxuICAgICAgICAgICAgd2lsZGNhcmRzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3Qgb3JpZ2luIG9mIHNldHRpbmdzLm9yaWdpbikge1xuICAgICAgICAgICAgaWYgKG9yaWdpbi5pbmRleE9mKCcqJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX29yaWdpbi53aWxkY2FyZHMucHVzaChuZXcgUmVnRXhwKCdeJyArIEhvZWsuZXNjYXBlUmVnZXgob3JpZ2luKS5yZXBsYWNlKC9cXFxcXFwqL2csICcuKicpLnJlcGxhY2UoL1xcXFxcXD8vZywgJy4nKSArICckJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX29yaWdpbi5xdWFsaWZpZWQucHVzaChvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldHRpbmdzO1xufTtcblxuXG5leHBvcnRzLm9wdGlvbnMgPSBmdW5jdGlvbiAocm91dGUsIHNlcnZlcikge1xuXG4gICAgaWYgKHJvdXRlLm1ldGhvZCA9PT0gJ29wdGlvbnMnIHx8XG4gICAgICAgICFyb3V0ZS5zZXR0aW5ncy5jb3JzKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV4cG9ydHMuaGFuZGxlcihzZXJ2ZXIpO1xufTtcblxuXG5leHBvcnRzLmhhbmRsZXIgPSBmdW5jdGlvbiAoc2VydmVyKSB7XG5cbiAgICBSb3V0ZSA9IFJvdXRlIHx8IHJlcXVpcmUoJy4vcm91dGUnKTtcblxuICAgIGlmIChzZXJ2ZXIuX2NvcmUucm91dGVyLnNwZWNpYWxzLm9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIG1ldGhvZDogJ19zcGVjaWFsJyxcbiAgICAgICAgcGF0aDogJy97cCp9JyxcbiAgICAgICAgaGFuZGxlcjogaW50ZXJuYWxzLmhhbmRsZXIsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNvcnM6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgcm91dGUgPSBuZXcgUm91dGUoZGVmaW5pdGlvbiwgc2VydmVyLCB7IHNwZWNpYWw6IHRydWUgfSk7XG4gICAgc2VydmVyLl9jb3JlLnJvdXRlci5zcGVjaWFsKCdvcHRpb25zJywgcm91dGUpO1xufTtcblxuXG5pbnRlcm5hbHMuaGFuZGxlciA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBoKSB7XG5cbiAgICAvLyBWYWxpZGF0ZSBDT1JTIHByZWZsaWdodCByZXF1ZXN0XG5cbiAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0LmhlYWRlcnNbJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtbWV0aG9kJ107XG4gICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5ub3RGb3VuZCgnQ09SUyBlcnJvcjogTWlzc2luZyBBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZCBoZWFkZXInKTtcbiAgICB9XG5cbiAgICAvLyBMb29rdXAgcm91dGVcblxuICAgIGNvbnN0IHJvdXRlID0gcmVxdWVzdC5zZXJ2ZXIubWF0Y2gobWV0aG9kLCByZXF1ZXN0LnBhdGgsIHJlcXVlc3QuaW5mby5ob3N0bmFtZSk7XG4gICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICB0aHJvdyBCb29tLm5vdEZvdW5kKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSByb3V0ZS5zZXR0aW5ncy5jb3JzO1xuICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogJ0NPUlMgaXMgZGlzYWJsZWQgZm9yIHRoaXMgcm91dGUnIH07XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgT3JpZ2luIGhlYWRlclxuXG4gICAgY29uc3Qgb3JpZ2luID0gcmVxdWVzdC5oZWFkZXJzLm9yaWdpbjtcblxuICAgIGlmICghb3JpZ2luICYmXG4gICAgICAgIHNldHRpbmdzLl9vcmlnaW4gIT09IGZhbHNlKSB7XG5cbiAgICAgICAgdGhyb3cgQm9vbS5ub3RGb3VuZCgnQ09SUyBlcnJvcjogTWlzc2luZyBPcmlnaW4gaGVhZGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKCFleHBvcnRzLm1hdGNoT3JpZ2luKG9yaWdpbiwgc2V0dGluZ3MpKSB7XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6ICdDT1JTIGVycm9yOiBPcmlnaW4gbm90IGFsbG93ZWQnIH07XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgYWxsb3dlZCBoZWFkZXJzXG5cbiAgICBsZXQgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVyc1snYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1oZWFkZXJzJ107XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgICAgIGlmIChIb2VrLmludGVyc2VjdChoZWFkZXJzLCBzZXR0aW5ncy5faGVhZGVycykubGVuZ3RoICE9PSBoZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogJ0NPUlMgZXJyb3I6IFNvbWUgaGVhZGVycyBhcmUgbm90IGFsbG93ZWQnIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXBseSB3aXRoIHRoZSByb3V0ZSBDT1JTIGhlYWRlcnNcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gaC5yZXNwb25zZSgpO1xuICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2FjY2Vzcy1jb250cm9sLWFsbG93LW9yaWdpbicsIHNldHRpbmdzLl9vcmlnaW4gPyBvcmlnaW4gOiAnKicpO1xuICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2FjY2Vzcy1jb250cm9sLWFsbG93LW1ldGhvZHMnLCBtZXRob2QpO1xuICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2FjY2Vzcy1jb250cm9sLWFsbG93LWhlYWRlcnMnLCBzZXR0aW5ncy5faGVhZGVyc1N0cmluZyk7XG4gICAgcmVzcG9uc2UuX2hlYWRlcignYWNjZXNzLWNvbnRyb2wtbWF4LWFnZScsIHNldHRpbmdzLm1heEFnZSk7XG5cbiAgICBpZiAoc2V0dGluZ3MuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcignYWNjZXNzLWNvbnRyb2wtYWxsb3ctY3JlZGVudGlhbHMnLCAndHJ1ZScpO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5fZXhwb3NlZEhlYWRlcnMpIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcignYWNjZXNzLWNvbnRyb2wtZXhwb3NlLWhlYWRlcnMnLCBzZXR0aW5ncy5fZXhwb3NlZEhlYWRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbn07XG5cblxuZXhwb3J0cy5oZWFkZXJzID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIGNvbnN0IHNldHRpbmdzID0gcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5jb3JzO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcblxuICAgIGlmIChzZXR0aW5ncy5fb3JpZ2luICE9PSBmYWxzZSkge1xuICAgICAgICByZXNwb25zZS52YXJ5KCdvcmlnaW4nKTtcbiAgICB9XG5cbiAgICBpZiAoKHJlcXVlc3QuaW5mby5jb3JzICYmICFyZXF1ZXN0LmluZm8uY29ycy5pc09yaWdpbk1hdGNoKSB8fCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWZ0ZXIgcm91dGUgbG9va3VwXG4gICAgICAgICFleHBvcnRzLm1hdGNoT3JpZ2luKHJlcXVlc3QuaGVhZGVycy5vcmlnaW4sIHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuY29ycykpIHsgICAgICAgIC8vIFJlc3BvbnNlIGZyb20gb25SZXF1ZXN0XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2FjY2Vzcy1jb250cm9sLWFsbG93LW9yaWdpbicsIHNldHRpbmdzLl9vcmlnaW4gPyByZXF1ZXN0LmhlYWRlcnMub3JpZ2luIDogJyonKTtcblxuICAgIGlmIChzZXR0aW5ncy5jcmVkZW50aWFscykge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdhY2Nlc3MtY29udHJvbC1hbGxvdy1jcmVkZW50aWFscycsICd0cnVlJyk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLl9leHBvc2VkSGVhZGVycykge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdhY2Nlc3MtY29udHJvbC1leHBvc2UtaGVhZGVycycsIHNldHRpbmdzLl9leHBvc2VkSGVhZGVycywgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLm1hdGNoT3JpZ2luID0gZnVuY3Rpb24gKG9yaWdpbiwgc2V0dGluZ3MpIHtcblxuICAgIGlmIChzZXR0aW5ncy5fb3JpZ2luID09PSB0cnVlIHx8XG4gICAgICAgIHNldHRpbmdzLl9vcmlnaW4gPT09IGZhbHNlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzZXR0aW5ncy5fb3JpZ2luLnF1YWxpZmllZC5pbmRleE9mKG9yaWdpbikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgd2lsZGNhcmQgb2Ygc2V0dGluZ3MuX29yaWdpbi53aWxkY2FyZHMpIHtcbiAgICAgICAgaWYgKG9yaWdpbi5tYXRjaCh3aWxkY2FyZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IFRvcG8gPSByZXF1aXJlKCdAaGFwaS90b3BvJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkV4dCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGNvcmUpIHtcblxuICAgICAgICB0aGlzLl90b3BvID0gbmV3IFRvcG8oKTtcbiAgICAgICAgdGhpcy5fY29yZSA9IGNvcmU7XG4gICAgICAgIHRoaXMuX3JvdXRlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubm9kZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGFkZChldmVudCkge1xuXG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSBbXS5jb25jYXQoZXZlbnQubWV0aG9kKTtcbiAgICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBldmVudC5vcHRpb25zLmJlZm9yZSxcbiAgICAgICAgICAgICAgICBhZnRlcjogZXZlbnQub3B0aW9ucy5hZnRlcixcbiAgICAgICAgICAgICAgICBncm91cDogZXZlbnQucmVhbG0ucGx1Z2luLFxuICAgICAgICAgICAgICAgIHNvcnQ6IHRoaXMuX2NvcmUuZXh0ZW5zaW9uc1NlcSsrXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgICAgICAgIGZ1bmM6IG1ldGhvZCwgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBoKSwgU2VydmVyOiBmdW5jdGlvbiAoc2VydmVyKVxuICAgICAgICAgICAgICAgIGJpbmQ6IGV2ZW50Lm9wdGlvbnMuYmluZCxcbiAgICAgICAgICAgICAgICBzZXJ2ZXI6IGV2ZW50LnNlcnZlciwgICAgICAgICAgICAgICAvLyBTZXJ2ZXIgZXZlbnRcbiAgICAgICAgICAgICAgICByZWFsbTogZXZlbnQucmVhbG0sXG4gICAgICAgICAgICAgICAgdGltZW91dDogZXZlbnQub3B0aW9ucy50aW1lb3V0XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl90b3BvLmFkZChub2RlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vZGVzID0gdGhpcy5fdG9wby5ub2RlcztcblxuICAgICAgICAvLyBOb3RpZnkgcm91dGVzXG5cbiAgICAgICAgZm9yIChjb25zdCByb3V0ZSBvZiB0aGlzLl9yb3V0ZXMpIHtcbiAgICAgICAgICAgIHJvdXRlLnJlYnVpbGQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWVyZ2Uob3RoZXJzKSB7XG5cbiAgICAgICAgY29uc3QgbWVyZ2UgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvdGhlciBvZiBvdGhlcnMpIHtcbiAgICAgICAgICAgIG1lcmdlLnB1c2gob3RoZXIuX3RvcG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdG9wby5tZXJnZShtZXJnZSk7XG4gICAgICAgIHRoaXMubm9kZXMgPSAodGhpcy5fdG9wby5ub2Rlcy5sZW5ndGggPyB0aGlzLl90b3BvLm5vZGVzIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlKHJvdXRlKSB7XG5cbiAgICAgICAgdGhpcy5fcm91dGVzLnB1c2gocm91dGUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb21iaW5lKHJvdXRlLCB0eXBlKSB7XG5cbiAgICAgICAgY29uc3QgZXh0ID0gbmV3IGludGVybmFscy5FeHQodHlwZSwgcm91dGUuX2NvcmUpO1xuXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHJvdXRlLnNldHRpbmdzLmV4dFt0eXBlXTtcbiAgICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICAgICAgZm9yIChsZXQgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBPYmplY3QuYXNzaWduKHt9LCBldmVudCk7ICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoIWV2ZW50Lm9wdGlvbnMuc2FuZGJveCwgJ0Nhbm5vdCBzcGVjaWZ5IHNhbmRib3ggb3B0aW9uIGZvciByb3V0ZSBleHRlbnNpb24nKTtcbiAgICAgICAgICAgICAgICBldmVudC5yZWFsbSA9IHJvdXRlLnJlYWxtO1xuICAgICAgICAgICAgICAgIGV4dC5hZGQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VydmVyID0gcm91dGUuX2NvcmUuZXh0ZW5zaW9ucy5yb3V0ZVt0eXBlXTtcbiAgICAgICAgY29uc3QgcmVhbG0gPSByb3V0ZS5yZWFsbS5fZXh0ZW5zaW9uc1t0eXBlXTtcblxuICAgICAgICBleHQubWVyZ2UoW3NlcnZlciwgcmVhbG1dKTtcblxuICAgICAgICBzZXJ2ZXIuc3Vic2NyaWJlKHJvdXRlKTtcbiAgICAgICAgcmVhbG0uc3Vic2NyaWJlKHJvdXRlKTtcblxuICAgICAgICByZXR1cm4gZXh0O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5leGVjdXRlID0gYXN5bmMgZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIC8vIFByZXJlcXVpc2l0ZXNcblxuICAgIGlmIChyZXF1ZXN0Ll9yb3V0ZS5fcHJlcmVxdWlzaXRlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHNldCBvZiByZXF1ZXN0Ll9yb3V0ZS5fcHJlcmVxdWlzaXRlcykgeyAgICAgIC8vIFNlcmlhbCBleGVjdXRpb24gb2YgZWFjaCBzZXRcbiAgICAgICAgICAgIGNvbnN0IHByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzZXQpIHtcbiAgICAgICAgICAgICAgICBwcmVzLnB1c2goaW50ZXJuYWxzLmhhbmRsZXIocmVxdWVzdCwgaXRlbS5tZXRob2QsIGl0ZW0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJlcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJhbGxlbCBleGVjdXRpb24gd2l0aGluIHNldHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZXJcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGludGVybmFscy5oYW5kbGVyKHJlcXVlc3QsIHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuaGFuZGxlcik7XG4gICAgaWYgKHJlc3VsdC5fdGFrZW92ZXIgfHxcbiAgICAgICAgdHlwZW9mIHJlc3VsdCA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlcXVlc3QuX3NldFJlc3BvbnNlKHJlc3VsdCk7XG59O1xuXG5cbmludGVybmFscy5oYW5kbGVyID0gYXN5bmMgZnVuY3Rpb24gKHJlcXVlc3QsIG1ldGhvZCwgcHJlKSB7XG5cbiAgICBjb25zdCBiaW5kID0gcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5iaW5kO1xuICAgIGNvbnN0IHJlYWxtID0gcmVxdWVzdC5yb3V0ZS5yZWFsbTtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0Ll9jb3JlLnRvb2xraXQuZXhlY3V0ZShtZXRob2QsIHJlcXVlc3QsIHsgYmluZCwgcmVhbG0sIGNvbnRpbnVlOiAnbnVsbCcgfSk7XG5cbiAgICAvLyBIYW5kbGVyXG5cbiAgICBpZiAoIXByZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UuaXNCb29tKSB7XG4gICAgICAgICAgICByZXF1ZXN0Ll9sb2coWydoYW5kbGVyJywgJ2Vycm9yJ10sIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8vIFByZVxuXG4gICAgaWYgKHJlc3BvbnNlLmlzQm9vbSkge1xuICAgICAgICByZXNwb25zZS5hc3NpZ24gPSBwcmUuYXNzaWduO1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuX2NvcmUudG9vbGtpdC5mYWlsQWN0aW9uKHJlcXVlc3QsIHByZS5mYWlsQWN0aW9uLCByZXNwb25zZSwgeyB0YWdzOiBbJ3ByZScsICdlcnJvciddLCByZXRhaW46IHRydWUgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGlmIChwcmUuYXNzaWduKSB7XG4gICAgICAgIHJlcXVlc3QucHJlW3ByZS5hc3NpZ25dID0gKHJlc3BvbnNlLmlzQm9vbSA/IHJlc3BvbnNlIDogcmVzcG9uc2Uuc291cmNlKTtcbiAgICAgICAgcmVxdWVzdC5wcmVSZXNwb25zZXNbcHJlLmFzc2lnbl0gPSByZXNwb25zZTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UuX3Rha2VvdmVyKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuZGVmYXVsdHMgPSBmdW5jdGlvbiAobWV0aG9kLCBoYW5kbGVyLCBjb3JlKSB7XG5cbiAgICBsZXQgZGVmYXVsdHMgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCB0eXBlID0gT2JqZWN0LmtleXMoaGFuZGxlcilbMF07XG4gICAgICAgIGNvbnN0IHNlcnZlckhhbmRsZXIgPSBjb3JlLl9kZWNvcmF0aW9ucy5oYW5kbGVyW3R5cGVdO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHNlcnZlckhhbmRsZXIsICdVbmtub3duIGhhbmRsZXI6JywgdHlwZSk7XG5cbiAgICAgICAgaWYgKHNlcnZlckhhbmRsZXIuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gKHR5cGVvZiBzZXJ2ZXJIYW5kbGVyLmRlZmF1bHRzID09PSAnZnVuY3Rpb24nID8gc2VydmVySGFuZGxlci5kZWZhdWx0cyhtZXRob2QpIDogc2VydmVySGFuZGxlci5kZWZhdWx0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdHMgfHwge307XG59O1xuXG5cbmV4cG9ydHMuY29uZmlndXJlID0gZnVuY3Rpb24gKGhhbmRsZXIsIHJvdXRlKSB7XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3Qua2V5cyhoYW5kbGVyKVswXTtcbiAgICAgICAgY29uc3Qgc2VydmVySGFuZGxlciA9IHJvdXRlLl9jb3JlLl9kZWNvcmF0aW9ucy5oYW5kbGVyW3R5cGVdO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHNlcnZlckhhbmRsZXIsICdVbmtub3duIGhhbmRsZXI6JywgdHlwZSk7XG5cbiAgICAgICAgcmV0dXJuIHNlcnZlckhhbmRsZXIocm91dGUucHVibGljLCBoYW5kbGVyW3R5cGVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlcjtcbn07XG5cblxuZXhwb3J0cy5wcmVyZXF1aXNpdGVzQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuXG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChyZXF1ZXN0LCBoKSB7IH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBoKSB7IH1cbiAgICAgICAgICAgICAgICAgICAgYXNzaWduOiBrZXkxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHJlcXVlc3QsIGgpIHsgfSxcbiAgICAgICAgICAgICAgICAgICAgYXNzaWduOiBrZXkyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uIChyZXF1ZXN0LCBoKSB7IH0sXG4gICAgICAgICAgICAgICAgYXNzaWduOiBrZXkzXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAqL1xuXG4gICAgY29uc3QgcHJlcmVxdWlzaXRlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgcHJlcyBvZiBjb25maWcpIHtcbiAgICAgICAgcHJlcyA9IFtdLmNvbmNhdChwcmVzKTtcblxuICAgICAgICBjb25zdCBzZXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJlIG9mIHByZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHByZSA9IHsgbWV0aG9kOiBwcmUgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByZS5tZXRob2QsXG4gICAgICAgICAgICAgICAgYXNzaWduOiBwcmUuYXNzaWduLFxuICAgICAgICAgICAgICAgIGZhaWxBY3Rpb246IHByZS5mYWlsQWN0aW9uIHx8ICdlcnJvcidcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNldC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJlcmVxdWlzaXRlcy5wdXNoKHNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXJlcXVpc2l0ZXMubGVuZ3RoID8gcHJlcmVxdWlzaXRlcyA6IG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuXG5jb25zdCBSZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNhY2hlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICBpZiAocmVzcG9uc2UuaGVhZGVyc1snY2FjaGUtY29udHJvbCddKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuY2FjaGU7XG4gICAgY29uc3QgcG9saWN5ID0gc2V0dGluZ3MgJiYgcmVxdWVzdC5fcm91dGUuX2NhY2hlICYmIChzZXR0aW5ncy5fc3RhdHVzZXMuaGFzKHJlc3BvbnNlLnN0YXR1c0NvZGUpIHx8IChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDQgJiYgc2V0dGluZ3MuX3N0YXR1c2VzLmhhcygyMDApKSk7XG5cbiAgICBpZiAocG9saWN5IHx8XG4gICAgICAgIHJlc3BvbnNlLnNldHRpbmdzLnR0bCkge1xuXG4gICAgICAgIGNvbnN0IHR0bCA9IChyZXNwb25zZS5zZXR0aW5ncy50dGwgIT09IG51bGwgPyByZXNwb25zZS5zZXR0aW5ncy50dGwgOiByZXF1ZXN0Ll9yb3V0ZS5fY2FjaGUudHRsKCkpO1xuICAgICAgICBjb25zdCBwcml2YWN5ID0gKHJlcXVlc3QuYXV0aC5pc0F1dGhlbnRpY2F0ZWQgfHwgcmVzcG9uc2UuaGVhZGVyc1snc2V0LWNvb2tpZSddID8gJ3ByaXZhdGUnIDogc2V0dGluZ3MucHJpdmFjeSB8fCAnZGVmYXVsdCcpO1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdjYWNoZS1jb250cm9sJywgJ21heC1hZ2U9JyArIE1hdGguZmxvb3IodHRsIC8gMTAwMCkgKyAnLCBtdXN0LXJldmFsaWRhdGUnICsgKHByaXZhY3kgIT09ICdkZWZhdWx0JyA/ICcsICcgKyBwcml2YWN5IDogJycpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcignY2FjaGUtY29udHJvbCcsIHNldHRpbmdzLm90aGVyd2lzZSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNvbnRlbnQgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZS5faXNQYXlsb2FkU3VwcG9ydGVkKCkgfHxcbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPT09ICdoZWFkJykge1xuXG4gICAgICAgIGF3YWl0IHJlc3BvbnNlLl9tYXJzaGFsKCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3QuanNvbnAgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLl9wYXlsb2FkLmpzb25wKSB7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L2phdmFzY3JpcHQnICsgKHJlc3BvbnNlLnNldHRpbmdzLmNoYXJzZXQgPyAnOyBjaGFyc2V0PScgKyByZXNwb25zZS5zZXR0aW5ncy5jaGFyc2V0IDogJycpKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ3gtY29udGVudC10eXBlLW9wdGlvbnMnLCAnbm9zbmlmZicpO1xuICAgICAgICAgICAgcmVzcG9uc2UuX3BheWxvYWQuanNvbnAocmVxdWVzdC5qc29ucCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UuX3BheWxvYWQuc2l6ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHJlc3BvbnNlLl9wYXlsb2FkLnNpemUgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgcmVzcG9uc2UuX2hlYWRlcignY29udGVudC1sZW5ndGgnLCByZXNwb25zZS5fcGF5bG9hZC5zaXplKCksIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5faXNQYXlsb2FkU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLl9jbG9zZShyZXF1ZXN0KTsgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NlIHVudXNlZCBmaWxlIHN0cmVhbXNcbiAgICAgICAgICAgIHJlc3BvbnNlLl9wYXlsb2FkID0gbmV3IGludGVybmFscy5FbXB0eSgpOyAgICAgIC8vIFNldCBlbXB0eSBzdHJlYW1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4cG9ydHMudHlwZShyZXF1ZXN0LCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG5cbiAgICAgICAgLy8gU2V0IGVtcHR5IHN0cmVhbVxuXG4gICAgICAgIHJlc3BvbnNlLl9jbG9zZShyZXF1ZXN0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9zZSB1bnVzZWQgZmlsZSBzdHJlYW1zXG4gICAgICAgIHJlc3BvbnNlLl9wYXlsb2FkID0gbmV3IGludGVybmFscy5FbXB0eSgpO1xuICAgICAgICBkZWxldGUgcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuc3RhdGUgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGNvbnN0IHN0YXRlcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzdGF0ZU5hbWUgaW4gcmVxdWVzdC5fc3RhdGVzKSB7XG4gICAgICAgIHN0YXRlcy5wdXNoKHJlcXVlc3QuX3N0YXRlc1tzdGF0ZU5hbWVdKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVxdWVzdC5fY29yZS5zdGF0ZXMuY29va2llcykge1xuICAgICAgICAgICAgY29uc3QgYXV0b1ZhbHVlID0gcmVxdWVzdC5fY29yZS5zdGF0ZXMuY29va2llc1tuYW1lXS5hdXRvVmFsdWU7XG4gICAgICAgICAgICBpZiAoIWF1dG9WYWx1ZSB8fCBuYW1lIGluIHJlcXVlc3QuX3N0YXRlcyB8fCBuYW1lIGluIHJlcXVlc3Quc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRvVmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZXMucHVzaCh7IG5hbWUsIHZhbHVlOiBhdXRvVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgYXV0b1ZhbHVlKHJlcXVlc3QpO1xuICAgICAgICAgICAgc3RhdGVzLnB1c2goeyBuYW1lLCB2YWx1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhlYWRlciA9IGF3YWl0IHJlcXVlc3QuX2NvcmUuc3RhdGVzLmZvcm1hdChzdGF0ZXMpO1xuICAgICAgICBjb25zdCBleGlzdGluZyA9IHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICBoZWFkZXIgPSAoQXJyYXkuaXNBcnJheShleGlzdGluZykgPyBleGlzdGluZyA6IFtleGlzdGluZ10pLmNvbmNhdChoZWFkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcignc2V0LWNvb2tpZScsIGhlYWRlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBCb29tLmJvb21pZnkoZXJyKTtcbiAgICAgICAgcmVxdWVzdC5fbG9nKFsnc3RhdGUnLCAncmVzcG9uc2UnLCAnZXJyb3InXSwgZXJyb3IpO1xuICAgICAgICByZXF1ZXN0Ll9zdGF0ZXMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgYnJva2VuIHN0YXRlXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHBvc3RNYXJzaGFsKSB7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgbGV0IHR5cGUgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLl9jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhcnNldCA9IChyZXNwb25zZS5zZXR0aW5ncy5jaGFyc2V0ICYmIHJlc3BvbnNlLl9jb250ZW50VHlwZSAhPT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgPyAnOyBjaGFyc2V0PScgKyByZXNwb25zZS5zZXR0aW5ncy5jaGFyc2V0IDogJycpO1xuICAgICAgICAgICAgcmVzcG9uc2UudHlwZShyZXNwb25zZS5fY29udGVudFR5cGUgKyBjaGFyc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHR5cGUudHJpbSgpO1xuICAgICAgICBpZiAoKCFyZXNwb25zZS5fY29udGVudFR5cGUgfHwgIXBvc3RNYXJzaGFsKSAmJlxuICAgICAgICAgICAgcmVzcG9uc2Uuc2V0dGluZ3MuY2hhcnNldCAmJlxuICAgICAgICAgICAgdHlwZS5tYXRjaCgvXig/OnRleHRcXC8pfCg/OmFwcGxpY2F0aW9uXFwvKD86anNvbil8KD86amF2YXNjcmlwdCkpLykpIHtcblxuICAgICAgICAgICAgaWYgKCF0eXBlLm1hdGNoKC87ICpjaGFyc2V0PS8pKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VtaSA9ICh0eXBlW3R5cGUubGVuZ3RoIC0gMV0gPT09ICc7Jyk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UudHlwZSh0eXBlICsgKHNlbWkgPyAnICcgOiAnOyAnKSArICdjaGFyc2V0PScgKyAocmVzcG9uc2Uuc2V0dGluZ3MuY2hhcnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmVudGl0eSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBpZiAoIXJlcXVlc3QuX2VudGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuXG4gICAgaWYgKHJlcXVlc3QuX2VudGl0eS5ldGFnICYmXG4gICAgICAgICFyZXNwb25zZS5oZWFkZXJzLmV0YWcpIHtcblxuICAgICAgICByZXNwb25zZS5ldGFnKHJlcXVlc3QuX2VudGl0eS5ldGFnLCB7IHZhcnk6IHJlcXVlc3QuX2VudGl0eS52YXJ5IH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Ll9lbnRpdHkubW9kaWZpZWQgJiZcbiAgICAgICAgIXJlc3BvbnNlLmhlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXSkge1xuXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcignbGFzdC1tb2RpZmllZCcsIHJlcXVlc3QuX2VudGl0eS5tb2RpZmllZCk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnVubW9kaWZpZWQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGVudGl0eSA9IHtcbiAgICAgICAgZXRhZzogcmVzcG9uc2UuaGVhZGVycy5ldGFnLFxuICAgICAgICB2YXJ5OiByZXNwb25zZS5zZXR0aW5ncy52YXJ5RXRhZyxcbiAgICAgICAgbW9kaWZpZWQ6IHJlc3BvbnNlLmhlYWRlcnNbJ2xhc3QtbW9kaWZpZWQnXVxuICAgIH07XG5cbiAgICBjb25zdCBldGFnID0gUmVzcG9uc2UudW5tb2RpZmllZChyZXF1ZXN0LCBlbnRpdHkpO1xuICAgIGlmIChldGFnKSB7XG4gICAgICAgIHJlc3BvbnNlLmNvZGUoMzA0KTtcblxuICAgICAgICBpZiAoZXRhZyAhPT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgZXRhZyB3aXRoIGluY29taW5nIHdlYWsgbWF0Y2hcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZXRhZyA9IGV0YWc7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5FbXB0eSA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtLlJlYWRhYmxlIHtcblxuICAgIF9yZWFkKC8qIHNpemUgKi8pIHtcblxuICAgICAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgfVxuXG4gICAgd3JpdGVUb1N0cmVhbShzdHJlYW0pIHtcblxuICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU2VydmVyID0gcmVxdWlyZSgnLi9zZXJ2ZXInKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcblxuZXhwb3J0cy5zZXJ2ZXIgPSBTZXJ2ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtZXRob2ROYW1lUng6IC9eW18kYS16QS1aXVskXFx3XSooPzpcXC5bXyRhLXpBLVpdWyRcXHddKikqJC9cbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLk1ldGhvZHMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb3JlKSB7XG5cbiAgICAgICAgdGhpcy5jb3JlID0gY29yZTtcbiAgICAgICAgdGhpcy5tZXRob2RzID0ge307XG4gICAgfVxuXG4gICAgYWRkKG5hbWUsIG1ldGhvZCwgb3B0aW9ucywgcmVhbG0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkKG5hbWUsIG1ldGhvZCwgb3B0aW9ucywgcmVhbG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8ge30gb3IgW3t9LCB7fV1cblxuICAgICAgICBjb25zdCBpdGVtcyA9IFtdLmNvbmNhdChuYW1lKTtcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgaXRlbSA9IENvbmZpZy5hcHBseSgnbWV0aG9kT2JqZWN0JywgaXRlbSk7XG4gICAgICAgICAgICB0aGlzLl9hZGQoaXRlbS5uYW1lLCBpdGVtLm1ldGhvZCwgaXRlbS5vcHRpb25zIHx8IHt9LCByZWFsbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWRkKG5hbWUsIG1ldGhvZCwgb3B0aW9ucywgcmVhbG0pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnbWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICduYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgSG9lay5hc3NlcnQobmFtZS5tYXRjaChpbnRlcm5hbHMubWV0aG9kTmFtZVJ4KSwgJ0ludmFsaWQgbmFtZTonLCBuYW1lKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIUhvZWsucmVhY2godGhpcy5tZXRob2RzLCBuYW1lLCB7IGZ1bmN0aW9uczogZmFsc2UgfSksICdTZXJ2ZXIgbWV0aG9kIGZ1bmN0aW9uIG5hbWUgYWxyZWFkeSBleGlzdHM6JywgbmFtZSk7XG5cbiAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5hcHBseSgnbWV0aG9kJywgb3B0aW9ucywgbmFtZSk7XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBIb2VrLmNsb25lKG9wdGlvbnMsIHsgc2hhbGxvdzogWydiaW5kJ10gfSk7XG4gICAgICAgIHNldHRpbmdzLmdlbmVyYXRlS2V5ID0gc2V0dGluZ3MuZ2VuZXJhdGVLZXkgfHwgaW50ZXJuYWxzLmdlbmVyYXRlS2V5O1xuXG4gICAgICAgIGNvbnN0IGJpbmQgPSBzZXR0aW5ncy5iaW5kIHx8IHJlYWxtLnNldHRpbmdzLmJpbmQgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgYm91bmQgPSAhYmluZCA/IG1ldGhvZCA6ICguLi5hcmdzKSA9PiBtZXRob2QuYXBwbHkoYmluZCwgYXJncyk7XG5cbiAgICAgICAgLy8gTm90IGNhY2hlZFxuXG4gICAgICAgIGlmICghc2V0dGluZ3MuY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3NpZ24obmFtZSwgYm91bmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FjaGVkXG5cbiAgICAgICAgSG9lay5hc3NlcnQoIXNldHRpbmdzLmNhY2hlLmdlbmVyYXRlRnVuYywgJ0Nhbm5vdCBzZXQgZ2VuZXJhdGVGdW5jIHdpdGggbWV0aG9kIGNhY2hpbmc6JywgbmFtZSk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHNldHRpbmdzLmNhY2hlLmdlbmVyYXRlVGltZW91dCAhPT0gdW5kZWZpbmVkLCAnTWV0aG9kIGNhY2hpbmcgcmVxdWlyZXMgYSB0aW1lb3V0IHZhbHVlIGluIGdlbmVyYXRlVGltZW91dDonLCBuYW1lKTtcblxuICAgICAgICBzZXR0aW5ncy5jYWNoZS5nZW5lcmF0ZUZ1bmMgPSAoaWQsIGZsYWdzKSA9PiBib3VuZCguLi5pZC5hcmdzLCBmbGFncyk7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5jb3JlLl9jYWNoZVBvbGljeShzZXR0aW5ncy5jYWNoZSwgJyMnICsgbmFtZSk7XG5cbiAgICAgICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHNldHRpbmdzLmdlbmVyYXRlS2V5LmFwcGx5KGJpbmQsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0ludmFsaWQgbWV0aG9kIGtleSB3aGVuIGludm9raW5nOiAnICsgbmFtZSwgeyBuYW1lLCBhcmdzIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldCh7IGlkOiBrZXksIGFyZ3MgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuYy5jYWNoZSA9IHtcbiAgICAgICAgICAgIGRyb3A6IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBzZXR0aW5ncy5nZW5lcmF0ZUtleS5hcHBseShiaW5kLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0ludmFsaWQgbWV0aG9kIGtleSB3aGVuIGludm9raW5nOiAnICsgbmFtZSwgeyBuYW1lLCBhcmdzIH0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuZHJvcChrZXkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXRzOiBjYWNoZS5zdGF0c1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2Fzc2lnbihuYW1lLCBmdW5jLCBmdW5jKTtcbiAgICB9XG5cbiAgICBfYXNzaWduKG5hbWUsIG1ldGhvZCkge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCByZWYgPSB0aGlzLm1ldGhvZHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFyZWZbcGF0aFtpXV0pIHtcbiAgICAgICAgICAgICAgICByZWZbcGF0aFtpXV0gPSAoaSArIDEgPT09IHBhdGgubGVuZ3RoID8gbWV0aG9kIDoge30pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWYgPSByZWZbcGF0aFtpXV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zdXBwb3J0ZWRBcmdzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGVLZXkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgbGV0IGtleSA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICBpZiAoIWludGVybmFscy5zdXBwb3J0ZWRBcmdzLmluY2x1ZGVzKHR5cGVvZiBhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGtleSArIChpID8gJzonIDogJycpICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZy50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBQb2RpdW0gPSByZXF1aXJlKCdAaGFwaS9wb2RpdW0nKTtcblxuY29uc3QgQ29ycyA9IHJlcXVpcmUoJy4vY29ycycpO1xuY29uc3QgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG5jb25zdCBUcmFuc21pdCA9IHJlcXVpcmUoJy4vdHJhbnNtaXQnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgZXZlbnRzOiBQb2RpdW0udmFsaWRhdGUoWydmaW5pc2gnLCB7IG5hbWU6ICdwZWVrJywgc3ByZWFkOiB0cnVlIH0sICdkaXNjb25uZWN0J10pLFxuICAgIHJlc2VydmVkOiBbJ3NlcnZlcicsICd1cmwnLCAncXVlcnknLCAncGF0aCcsICdtZXRob2QnLCAnbWltZScsICdzZXRVcmwnLCAnc2V0TWV0aG9kJywgJ2hlYWRlcnMnLCAnaWQnLCAnYXBwJywgJ3BsdWdpbnMnLCAncm91dGUnLCAnYXV0aCcsICdwcmUnLCAncHJlUmVzcG9uc2VzJywgJ2luZm8nLCAnb3JpZycsICdwYXJhbXMnLCAncGFyYW1zQXJyYXknLCAncGF5bG9hZCcsICdzdGF0ZScsICdqc29ucCcsICdyZXNwb25zZScsICdyYXcnLCAnZG9tYWluJywgJ2xvZycsICdsb2dzJywgJ2dlbmVyYXRlUmVzcG9uc2UnXVxufTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuUmVxdWVzdCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHNlcnZlciwgcmVxLCByZXMsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLl9hbGxvd0ludGVybmFscyA9ICEhb3B0aW9ucy5hbGxvd0ludGVybmFscztcbiAgICAgICAgdGhpcy5fY29yZSA9IHNlcnZlci5fY29yZTtcbiAgICAgICAgdGhpcy5fZW50aXR5ID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVudGl0eSBpbmZvcm1hdGlvbiBzZXQgdmlhIGguZW50aXR5KClcbiAgICAgICAgdGhpcy5fZXZlbnRDb250ZXh0ID0geyByZXF1ZXN0OiB0aGlzIH07XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBc3NpZ25lZCBhbiBlbWl0dGVyIHdoZW4gcmVxdWVzdC5ldmVudHMgaXMgYWNjZXNzZWRcbiAgICAgICAgdGhpcy5fZXhwZWN0Q29udGludWUgPSAhIW9wdGlvbnMuZXhwZWN0Q29udGludWU7XG4gICAgICAgIHRoaXMuX2lzUGF5bG9hZFBlbmRpbmcgPSAhIShyZXEuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSB8fCByZXEuaGVhZGVyc1sndHJhbnNmZXItZW5jb2RpbmcnXSk7ICAgICAvLyBDaGFuZ2VzIHRvIGZhbHNlIHdoZW4gaW5jb21pbmcgcGF5bG9hZCBmdWxseSBwcm9jZXNzZWRcbiAgICAgICAgdGhpcy5faXNSZXBsaWVkID0gZmFsc2U7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgd2hlbiByZXNwb25zZSBwcm9jZXNzaW5nIHN0YXJ0ZWRcbiAgICAgICAgdGhpcy5fcm91dGUgPSB0aGlzLl9jb3JlLnJvdXRlci5zcGVjaWFscy5ub3RGb3VuZC5yb3V0ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgcHJpb3IgdG8gcm91dGluZyAob25seSBzZXR0aW5ncyBhcmUgdXNlZCwgbm90IHRoZSBoYW5kbGVyKVxuICAgICAgICB0aGlzLl9zZXJ2ZXJUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fdXJsRXJyb3IgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuYXBwID0gb3B0aW9ucy5hcHAgPyBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmFwcCkgOiB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbGFjZSBmb3IgYXBwbGljYXRpb24tc3BlY2lmaWMgc3RhdGUgd2l0aG91dCBjb25mbGljdHMgd2l0aCBoYXBpLCBzaG91bGQgbm90IGJlIHVzZWQgYnkgcGx1Z2lucyAoc2hhbGxvdyBjbG9uZWQpXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHJlcS5oZWFkZXJzO1xuICAgICAgICB0aGlzLmluZm8gPSBpbnRlcm5hbHMuaW5mbyh0aGlzLl9jb3JlLCByZXEpO1xuICAgICAgICB0aGlzLmpzb25wID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dzID0gW107XG4gICAgICAgIHRoaXMubWV0aG9kID0gcmVxLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLm1pbWUgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWcgPSB7fTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmFtc0FycmF5ID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgb2YgcGF0aCBwYXJhbWV0ZXJzIGluIHBhdGggb3JkZXJcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gbnVsbDtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zID8gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5wbHVnaW5zKSA6IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGZvciBwbHVnaW5zIHRvIHN0b3JlIHN0YXRlIHdpdGhvdXQgY29uZmxpY3RzIHdpdGggaGFwaSwgc2hvdWxkIGJlIG5hbWVzcGFjZWQgdXNpbmcgcGx1Z2luIG5hbWUgKHNoYWxsb3cgY2xvbmVkKVxuICAgICAgICB0aGlzLnByZSA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlIHJhdyB2YWx1ZXNcbiAgICAgICAgdGhpcy5wcmVSZXNwb25zZXMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZSByZXNwb25zZSB2YWx1ZXNcbiAgICAgICAgdGhpcy5yYXcgPSB7IHJlcSwgcmVzIH07XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnJvdXRlID0gdGhpcy5fcm91dGUucHVibGljO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5hdXRoID0ge1xuICAgICAgICAgICAgaXNBdXRoZW50aWNhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQXV0aG9yaXplZDogZmFsc2UsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogb3B0aW9ucy5hdXRoID8gb3B0aW9ucy5hdXRoLmNyZWRlbnRpYWxzIDogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGtleXM6ICdhcHAnLCAndXNlcicsICdzY29wZSdcbiAgICAgICAgICAgIGFydGlmYWN0czogb3B0aW9ucy5hdXRoICYmIG9wdGlvbnMuYXV0aC5hcnRpZmFjdHMgfHwgbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNjaGVtZS1zcGVjaWZpYyBhcnRpZmFjdHNcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBvcHRpb25zLmF1dGggPyBvcHRpb25zLmF1dGguc3RyYXRlZ3kgOiBudWxsLFxuICAgICAgICAgICAgbW9kZTogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0aCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoLmlzSW5qZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2UgcmVxdWVzdCB1cmxcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplVXJsKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdlbmVyYXRlKHNlcnZlciwgcmVxLCByZXMsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IHNlcnZlci5fY29yZS5SZXF1ZXN0KHNlcnZlciwgcmVxLCByZXMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIERlY29yYXRlXG5cbiAgICAgICAgaWYgKHNlcnZlci5fY29yZS5fZGVjb3JhdGlvbnMucmVxdWVzdEFwcGx5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHNlcnZlci5fY29yZS5fZGVjb3JhdGlvbnMucmVxdWVzdEFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudCA9IHNlcnZlci5fY29yZS5fZGVjb3JhdGlvbnMucmVxdWVzdEFwcGx5W3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0W3Byb3BlcnR5XSA9IGFzc2lnbm1lbnQocmVxdWVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0Ll9saXN0ZW4oKTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuXG4gICAgZ2V0IGV2ZW50cygpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IFBvZGl1bShpbnRlcm5hbHMuZXZlbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHM7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVVcmwoKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3NldFVybCh0aGlzLnJhdy5yZXEudXJsLCB0aGlzLl9jb3JlLnNldHRpbmdzLnJvdXRlci5zdHJpcFRyYWlsaW5nU2xhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHRoaXMucmF3LnJlcS51cmw7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG5cbiAgICAgICAgICAgIHRoaXMuX3VybEVycm9yID0gQm9vbS5ib29taWZ5KGVyciwgeyBzdGF0dXNDb2RlOiA0MDAsIG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFVybCh1cmwsIHN0cmlwVHJhaWxpbmdTbGFzaCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMucGFyYW1zID09PSBudWxsLCAnQ2Fubm90IGNoYW5nZSByZXF1ZXN0IFVSTCBhZnRlciByb3V0aW5nJyk7XG5cbiAgICAgICAgaWYgKHVybCBpbnN0YW5jZW9mIFVybC5VUkwpIHtcbiAgICAgICAgICAgIHVybCA9IHVybC5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHVybCA9PT0gJ3N0cmluZycsICdVcmwgbXVzdCBiZSBhIHN0cmluZyBvciBVUkwgb2JqZWN0Jyk7XG5cbiAgICAgICAgdGhpcy5fc2V0VXJsKHVybCwgc3RyaXBUcmFpbGluZ1NsYXNoKTtcbiAgICAgICAgdGhpcy5fdXJsRXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIF9zZXRVcmwodXJsLCBzdHJpcFRyYWlsaW5nU2xhc2gpIHtcblxuICAgICAgICBjb25zdCBiYXNlID0gdXJsWzBdID09PSAnLycgPyBgJHt0aGlzLl9jb3JlLmluZm8ucHJvdG9jb2x9Oi8vJHt0aGlzLmluZm8uaG9zdCB8fCBgJHt0aGlzLl9jb3JlLmluZm8uaG9zdH06JHt0aGlzLl9jb3JlLmluZm8ucG9ydH1gfWAgOiAnJztcblxuICAgICAgICB1cmwgPSBuZXcgVXJsLlVSTChiYXNlICsgdXJsKTtcblxuICAgICAgICAvLyBBcHBseSBwYXRoIG1vZGlmaWNhdGlvbnNcblxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMuX2NvcmUucm91dGVyLm5vcm1hbGl6ZSh1cmwucGF0aG5hbWUpOyAgICAgICAgLy8gcGF0aG5hbWUgZXhjbHVkZXMgcXVlcnlcblxuICAgICAgICBpZiAoc3RyaXBUcmFpbGluZ1NsYXNoICYmXG4gICAgICAgICAgICBwYXRoLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG5cbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybC5wYXRobmFtZSA9IHBhdGg7XG5cbiAgICAgICAgLy8gUGFyc2UgcXVlcnkgKG11c3QgYmUgZG9uZSBiZWZvcmUgdGhpcy51cmwgaXMgc2V0IGluIGNhc2UgcXVlcnkgcGFyc2luZyB0aHJvd3MpXG5cbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuX3BhcnNlUXVlcnkodXJsLnNlYXJjaFBhcmFtcyk7XG5cbiAgICAgICAgLy8gU3RvcmUgcmVxdWVzdCBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG5cbiAgICAgICAgdGhpcy5pbmZvLmhvc3RuYW1lID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB0aGlzLmluZm8uaG9zdCA9IHVybC5ob3N0O1xuICAgIH1cblxuICAgIF9wYXJzZVF1ZXJ5KHNlYXJjaFBhcmFtcykge1xuXG4gICAgICAgIC8vIEZsYXR0ZW4gbWFwXG5cbiAgICAgICAgbGV0IHF1ZXJ5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgaWYgKGVudHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChlbnRyeSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gcGFyc2VyXG5cbiAgICAgICAgY29uc3QgcGFyc2VyID0gdGhpcy5fY29yZS5zZXR0aW5ncy5xdWVyeS5wYXJzZXI7XG4gICAgICAgIGlmIChwYXJzZXIpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcGFyc2VyKHF1ZXJ5KTtcbiAgICAgICAgICAgIGlmICghcXVlcnkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgcXVlcnkgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdQYXJzZWQgcXVlcnkgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9XG5cbiAgICBzZXRNZXRob2QobWV0aG9kKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5wYXJhbXMgPT09IG51bGwsICdDYW5ub3QgY2hhbmdlIHJlcXVlc3QgbWV0aG9kIGFmdGVyIHJvdXRpbmcnKTtcbiAgICAgICAgSG9lay5hc3NlcnQobWV0aG9kICYmIHR5cGVvZiBtZXRob2QgPT09ICdzdHJpbmcnLCAnTWlzc2luZyBtZXRob2QnKTtcblxuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGFjdGl2ZSgpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLl9ldmVudENvbnRleHQucmVxdWVzdDtcbiAgICB9XG5cbiAgICBhc3luYyBfZXhlY3V0ZSgpIHtcblxuICAgICAgICB0aGlzLmluZm8uYWNjZXB0RW5jb2RpbmcgPSB0aGlzLl9jb3JlLmNvbXByZXNzaW9uLmFjY2VwdCh0aGlzKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25SZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVwbHkoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvb2t1cCgpO1xuICAgICAgICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9saWZlY3ljbGUoKTtcbiAgICAgICAgdGhpcy5fcmVwbHkoKTtcbiAgICB9XG5cbiAgICBhc3luYyBfb25SZXF1ZXN0KCkge1xuXG4gICAgICAgIC8vIG9uUmVxdWVzdCAoY2FuIGNoYW5nZSByZXF1ZXN0IG1ldGhvZCBhbmQgdXJsKVxuXG4gICAgICAgIGlmICh0aGlzLl9jb3JlLmV4dGVuc2lvbnMucm91dGUub25SZXF1ZXN0Lm5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ludm9rZSh0aGlzLl9jb3JlLmV4dGVuc2lvbnMucm91dGUub25SZXF1ZXN0KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnNraXAocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ29uUmVxdWVzdCBleHRlbnNpb24gbWV0aG9kcyBtdXN0IHJldHVybiBhbiBlcnJvciwgYSB0YWtlb3ZlciByZXNwb25zZSwgb3IgYSBjb250aW51ZSBzaWduYWwnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHBhdGhcblxuICAgICAgICBpZiAodGhpcy5fdXJsRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX3VybEVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2xpc3RlbigpIHtcblxuICAgICAgICBpZiAodGhpcy5faXNQYXlsb2FkUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5yYXcucmVxLm9uKCdlbmQnLCBpbnRlcm5hbHMuZXZlbnQuYmluZCh0aGlzLnJhdy5yZXEsIHRoaXMuX2V2ZW50Q29udGV4dCwgJ2VuZCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmF3LnJlcS5vbignY2xvc2UnLCBpbnRlcm5hbHMuZXZlbnQuYmluZCh0aGlzLnJhdy5yZXEsIHRoaXMuX2V2ZW50Q29udGV4dCwgJ2Nsb3NlJykpO1xuICAgICAgICB0aGlzLnJhdy5yZXEub24oJ2Vycm9yJywgaW50ZXJuYWxzLmV2ZW50LmJpbmQodGhpcy5yYXcucmVxLCB0aGlzLl9ldmVudENvbnRleHQsICdlcnJvcicpKTtcbiAgICAgICAgdGhpcy5yYXcucmVxLm9uKCdhYm9ydGVkJywgaW50ZXJuYWxzLmV2ZW50LmJpbmQodGhpcy5yYXcucmVxLCB0aGlzLl9ldmVudENvbnRleHQsICdhYm9ydCcpKTtcbiAgICB9XG5cbiAgICBfbG9va3VwKCkge1xuXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5fY29yZS5yb3V0ZXIucm91dGUodGhpcy5tZXRob2QsIHRoaXMucGF0aCwgdGhpcy5pbmZvLmhvc3RuYW1lKTtcbiAgICAgICAgaWYgKCFtYXRjaC5yb3V0ZS5zZXR0aW5ncy5pc0ludGVybmFsIHx8XG4gICAgICAgICAgICB0aGlzLl9hbGxvd0ludGVybmFscykge1xuXG4gICAgICAgICAgICB0aGlzLl9yb3V0ZSA9IG1hdGNoLnJvdXRlO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZSA9IHRoaXMuX3JvdXRlLnB1YmxpYztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGFyYW1zID0gbWF0Y2gucGFyYW1zIHx8IHt9O1xuICAgICAgICB0aGlzLnBhcmFtc0FycmF5ID0gbWF0Y2gucGFyYW1zQXJyYXkgfHwgW107XG5cbiAgICAgICAgaWYgKHRoaXMucm91dGUuc2V0dGluZ3MuY29ycykge1xuICAgICAgICAgICAgdGhpcy5pbmZvLmNvcnMgPSB7XG4gICAgICAgICAgICAgICAgaXNPcmlnaW5NYXRjaDogQ29ycy5tYXRjaE9yaWdpbih0aGlzLmhlYWRlcnMub3JpZ2luLCB0aGlzLnJvdXRlLnNldHRpbmdzLmNvcnMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldFRpbWVvdXRzKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnJhdy5yZXEuc29ja2V0ICYmXG4gICAgICAgICAgICB0aGlzLnJvdXRlLnNldHRpbmdzLnRpbWVvdXQuc29ja2V0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgdGhpcy5yYXcucmVxLnNvY2tldC5zZXRUaW1lb3V0KHRoaXMucm91dGUuc2V0dGluZ3MudGltZW91dC5zb2NrZXQgfHwgMCk7ICAgIC8vIFZhbHVlIGNhbiBiZSBmYWxzZSBvciBwb3NpdGl2ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlcnZlclRpbWVvdXQgPSB0aGlzLnJvdXRlLnNldHRpbmdzLnRpbWVvdXQuc2VydmVyO1xuICAgICAgICBpZiAoIXNlcnZlclRpbWVvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gdGhpcy5pbmZvLnJlY2VpdmVkO1xuICAgICAgICBzZXJ2ZXJUaW1lb3V0ID0gTWF0aC5mbG9vcihzZXJ2ZXJUaW1lb3V0IC0gZWxhcHNlZCk7ICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0aW1lb3V0IGZyb20gd2hlbiB0aGUgcmVxdWVzdCB3YXMgY29uc3RydWN0ZWRcblxuICAgICAgICBpZiAoc2VydmVyVGltZW91dCA8PSAwKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudGltZW91dFJlcGx5KHRoaXMsIHNlcnZlclRpbWVvdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2VydmVyVGltZW91dElkID0gc2V0VGltZW91dChpbnRlcm5hbHMudGltZW91dFJlcGx5LCBzZXJ2ZXJUaW1lb3V0LCB0aGlzLCBzZXJ2ZXJUaW1lb3V0KTtcbiAgICB9XG5cbiAgICBhc3luYyBfbGlmZWN5Y2xlKCkge1xuXG4gICAgICAgIGZvciAoY29uc3QgZnVuYyBvZiB0aGlzLl9yb3V0ZS5fY3ljbGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1JlcGxpZWQgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5fZXZlbnRDb250ZXh0LnJlcXVlc3QpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBhd2FpdCAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgPyBmdW5jKHRoaXMpIDogdGhpcy5faW52b2tlKGZ1bmMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IFJlc3BvbnNlLndyYXAoZXJyLCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID09PSB0aGlzLl9jb3JlLnRvb2xraXQuY29udGludWUpIHsgICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnNraXAocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdMaWZlY3ljbGUgbWV0aG9kcyBjYWxsZWQgYmVmb3JlIHRoZSBoYW5kbGVyIGNhbiBvbmx5IHJldHVybiBhbiBlcnJvciwgYSB0YWtlb3ZlciByZXNwb25zZSwgb3IgYSBjb250aW51ZSBzaWduYWwnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0UmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgX2ludm9rZShldmVudCkge1xuXG4gICAgICAgIGZvciAoY29uc3QgZXh0IG9mIGV2ZW50Lm5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCByZWFsbSA9IGV4dC5yZWFsbTtcbiAgICAgICAgICAgIGNvbnN0IGJpbmQgPSBleHQuYmluZCB8fCByZWFsbS5zZXR0aW5ncy5iaW5kO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9jb3JlLnRvb2xraXQuZXhlY3V0ZShleHQuZnVuYywgdGhpcywgeyBiaW5kLCByZWFsbSwgdGltZW91dDogZXh0LnRpbWVvdXQsIG5hbWU6IGV2ZW50LnR5cGUgfSk7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gdGhpcy5fY29yZS50b29sa2l0LmNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuc2tpcChyZXNwb25zZSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIF9yZXBseShleGl0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2lzUmVwbGllZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgYW55IGZ1dHVyZSByZXNwb25zZXMgdG8gdGhpcyByZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9pc1JlcGxpZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZXJUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zZXJ2ZXJUaW1lb3V0SWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudENvbnRleHQucmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGl0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYW4gYmUgYSB2YWxpZCByZXNwb25zZSBvciBlcnJvciAoaWYgcmV0dXJuZWQgZnJvbSBhbiBleHQsIGFscmVhZHkgaGFuZGxlZCBiZWNhdXNlIHRoaXMucmVzcG9uc2UgaXMgYWxzbyBzZXQpXG4gICAgICAgICAgICB0aGlzLl9zZXRSZXNwb25zZShSZXNwb25zZS53cmFwKGV4aXQsIHRoaXMpKTsgICAgICAgICAgICAgICAvLyBXcmFwIHRvIGVuc3VyZSBhbnkgb2JqZWN0IHRocm93biBpcyBhbHdheXMgYSB2YWxpZCBCb29tIG9yIFJlc3BvbnNlIG9iamVjdFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnJlc3BvbnNlID09PSAnc3ltYm9sJykgeyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIG9yIGFiYW5kb25cbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCB0aGlzLl9wb3N0Q3ljbGUoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50Q29udGV4dC5yZXF1ZXN0IHx8XG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5yZXNwb25zZSA9PT0gJ3N5bWJvbCcpIHsgICAgICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSBvciBhYmFuZG9uXG5cbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBUcmFuc21pdC5zZW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9maW5hbGl6ZSgpO1xuICAgIH1cblxuICAgIGFzeW5jIF9wb3N0Q3ljbGUoKSB7XG5cbiAgICAgICAgZm9yIChjb25zdCBmdW5jIG9mIHRoaXMuX3JvdXRlLl9wb3N0Q3ljbGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRDb250ZXh0LnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gYXdhaXQgKHR5cGVvZiBmdW5jID09PSAnZnVuY3Rpb24nID8gZnVuYyh0aGlzKSA6IHRoaXMuX2ludm9rZShmdW5jKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBSZXNwb25zZS53cmFwKGVyciwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlICE9PSB0aGlzLl9jb3JlLnRvb2xraXQuY29udGludWUpIHsgICAgICAgICAgICAgICAgICAgICAvLyBDb250aW51ZVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Fib3J0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlID09PSB0aGlzLl9jb3JlLnRvb2xraXQuY2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMucmF3LnJlcy5lbmQoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIHRoZSByZXNwb25zZSBpbiBjYXNlIGl0IHdhc24ndCBhbHJlYWR5IGNsb3NlZFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmluYWxpemUoKTtcbiAgICB9XG5cbiAgICBfZmluYWxpemUoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UgJiZcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNTAwICYmXG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlLl9lcnJvcikge1xuXG4gICAgICAgICAgICBjb25zdCB0YWdzID0gdGhpcy5yZXNwb25zZS5fZXJyb3IuaXNEZXZlbG9wZXJFcnJvciA/IFsnaW50ZXJuYWwnLCAnaW1wbGVtZW50YXRpb24nLCAnZXJyb3InXSA6IFsnaW50ZXJuYWwnLCAnZXJyb3InXTtcbiAgICAgICAgICAgIHRoaXMuX2xvZyh0YWdzLCB0aGlzLnJlc3BvbnNlLl9lcnJvciwgJ2Vycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbnVwXG5cbiAgICAgICAgdGhpcy5fZXZlbnRDb250ZXh0LnJlcXVlc3QgPSBudWxsOyAgICAgICAgICAgICAgLy8gRGlzYWJsZSByZXEgZXZlbnRzXG5cbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UgJiZcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UuX2Nsb3NlKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UuX2Nsb3NlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbmZvLmNvbXBsZXRlZCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuX2NvcmUuZXZlbnRzLmVtaXQoJ3Jlc3BvbnNlJywgdGhpcyk7XG4gICAgICAgIHRoaXMuX2NvcmUucXVldWUucmVsZWFzZSgpO1xuICAgIH1cblxuICAgIF9zZXRSZXNwb25zZShyZXNwb25zZSkge1xuXG4gICAgICAgIGlmICh0aGlzLnJlc3BvbnNlICYmXG4gICAgICAgICAgICAhdGhpcy5yZXNwb25zZS5pc0Jvb20gJiZcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgIT09IHJlc3BvbnNlICYmXG4gICAgICAgICAgICAocmVzcG9uc2UuaXNCb29tIHx8IHRoaXMucmVzcG9uc2Uuc291cmNlICE9PSByZXNwb25zZS5zb3VyY2UpKSB7XG5cbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UuX2Nsb3NlKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5mby5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5fY2xvc2UpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5fY2xvc2UodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICB9XG5cbiAgICBfc2V0U3RhdGUobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHsgbmFtZSwgdmFsdWUgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLmF1dG9WYWx1ZSwgJ0Nhbm5vdCBzZXQgYXV0b1ZhbHVlIGRpcmVjdGx5IGluIGEgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIHN0YXRlLm9wdGlvbnMgPSBIb2VrLmNsb25lKG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhdGVzW25hbWVdID0gc3RhdGU7XG4gICAgfVxuXG4gICAgX2NsZWFyU3RhdGUobmFtZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IG5hbWUgfTtcblxuICAgICAgICBzdGF0ZS5vcHRpb25zID0gSG9lay5jbG9uZShvcHRpb25zKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucy50dGwgPSAwO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlc1tuYW1lXSA9IHN0YXRlO1xuICAgIH1cblxuICAgIF90YXAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5oYXNMaXN0ZW5lcnMoJ3BlZWsnKSB8fFxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmhhc0xpc3RlbmVycygnZmluaXNoJykpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZS5QZWVrKHRoaXMuX2V2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsb2codGFncywgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2codGFncywgZGF0YSwgJ2FwcCcpO1xuICAgIH1cblxuICAgIF9sb2codGFncywgZGF0YSwgY2hhbm5lbCA9ICdpbnRlcm5hbCcpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2NvcmUuZXZlbnRzLmhhc0xpc3RlbmVycygncmVxdWVzdCcpICYmXG4gICAgICAgICAgICAhdGhpcy5yb3V0ZS5zZXR0aW5ncy5sb2cuY29sbGVjdCkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgICAgIHRhZ3MgPSBbdGFnc107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGRhdGEgaW5zdGFuY2VvZiBFcnJvciA/ICdlcnJvcicgOiAnZGF0YSc7XG5cbiAgICAgICAgbGV0IGV2ZW50ID0gW3RoaXMsIHsgcmVxdWVzdDogdGhpcy5pbmZvLmlkLCB0aW1lc3RhbXAsIHRhZ3MsIFtmaWVsZF06IGRhdGEsIGNoYW5uZWwgfV07XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXZlbnQgPSAoKSA9PiBbdGhpcywgeyByZXF1ZXN0OiB0aGlzLmluZm8uaWQsIHRpbWVzdGFtcCwgdGFncywgZGF0YTogZGF0YSgpLCBjaGFubmVsIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucm91dGUuc2V0dGluZ3MubG9nLmNvbGxlY3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2dzLnB1c2goZXZlbnRbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29yZS5ldmVudHMuZW1pdCh7IG5hbWU6ICdyZXF1ZXN0JywgY2hhbm5lbCwgdGFncyB9LCBldmVudCk7XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVSZXNwb25zZShzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHNvdXJjZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVxdWVzdC5yZXNlcnZlZCA9IGludGVybmFscy5yZXNlcnZlZDtcblxuXG5pbnRlcm5hbHMuaW5mbyA9IGZ1bmN0aW9uIChjb3JlLCByZXEpIHtcblxuICAgIGNvbnN0IGhvc3QgPSByZXEuaGVhZGVycy5ob3N0ID8gcmVxLmhlYWRlcnMuaG9zdC50cmltKCkgOiAnJztcbiAgICBjb25zdCByZWNlaXZlZCA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICByZWNlaXZlZCxcbiAgICAgICAgcmVtb3RlQWRkcmVzczogcmVxLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgcmVtb3RlUG9ydDogcmVxLmNvbm5lY3Rpb24ucmVtb3RlUG9ydCB8fCAnJyxcbiAgICAgICAgcmVmZXJyZXI6IHJlcS5oZWFkZXJzLnJlZmVycmVyIHx8IHJlcS5oZWFkZXJzLnJlZmVyZXIgfHwgJycsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lOiBob3N0LnNwbGl0KCc6JylbMF0sXG4gICAgICAgIGlkOiBgJHtyZWNlaXZlZH06JHtjb3JlLmluZm8uaWR9OiR7Y29yZS5yZXF1ZXN0Q291bnRlci52YWx1ZSsrfWAsXG5cbiAgICAgICAgLy8gQXNzaWduZWQgbGF0ZXJcblxuICAgICAgICBhY2NlcHRFbmNvZGluZzogbnVsbCxcbiAgICAgICAgY29yczogbnVsbCxcbiAgICAgICAgcmVzcG9uZGVkOiAwLFxuICAgICAgICBjb21wbGV0ZWQ6IDBcbiAgICB9O1xuXG4gICAgaWYgKGNvcmUucmVxdWVzdENvdW50ZXIudmFsdWUgPiBjb3JlLnJlcXVlc3RDb3VudGVyLm1heCkge1xuICAgICAgICBjb3JlLnJlcXVlc3RDb3VudGVyLnZhbHVlID0gY29yZS5yZXF1ZXN0Q291bnRlci5taW47XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG59O1xuXG5cbmludGVybmFscy5ldmVudCA9IGZ1bmN0aW9uICh7IHJlcXVlc3QgfSwgZXZlbnQsIGVycikge1xuXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXF1ZXN0Ll9pc1BheWxvYWRQZW5kaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoZXZlbnQgPT09ICdjbG9zZScgJiZcbiAgICAgICAgcmVxdWVzdC5yYXcucmVzLmZpbmlzaGVkKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcXVlc3QuX2xvZyhlcnIgPyBbJ3JlcXVlc3QnLCAnZXJyb3InXSA6IFsncmVxdWVzdCcsICdlcnJvcicsIGV2ZW50XSwgZXJyKTtcblxuICAgIGlmIChldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxdWVzdC5fZXZlbnRDb250ZXh0LnJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGV2ZW50ID09PSAnYWJvcnQnICYmXG4gICAgICAgIHJlcXVlc3QuX2V2ZW50cykge1xuXG4gICAgICAgIHJlcXVlc3QuX2V2ZW50cy5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMudGltZW91dFJlcGx5ID0gZnVuY3Rpb24gKHJlcXVlc3QsIHRpbWVvdXQpIHtcblxuICAgIGNvbnN0IGVsYXBzZWQgPSBEYXRlLm5vdygpIC0gcmVxdWVzdC5pbmZvLnJlY2VpdmVkO1xuICAgIHJlcXVlc3QuX2xvZyhbJ3JlcXVlc3QnLCAnc2VydmVyJywgJ3RpbWVvdXQnLCAnZXJyb3InXSwgeyB0aW1lb3V0LCBlbGFwc2VkIH0pO1xuICAgIHJlcXVlc3QuX3JlcGx5KEJvb20uc2VydmVyVW5hdmFpbGFibGUoKSk7XG59O1xuXG5cbmludGVybmFscy5za2lwID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuaXNCb29tIHx8IHJlc3BvbnNlLl90YWtlb3ZlciB8fCB0eXBlb2YgcmVzcG9uc2UgPT09ICdzeW1ib2wnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBQb2RpdW0gPSByZXF1aXJlKCdAaGFwaS9wb2RpdW0nKTtcblxuY29uc3QgU3RyZWFtcyA9IHJlcXVpcmUoJy4vc3RyZWFtcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBldmVudHM6IFBvZGl1bS52YWxpZGF0ZShbJ2ZpbmlzaCcsIHsgbmFtZTogJ3BlZWsnLCBzcHJlYWQ6IHRydWUgfV0pLFxuICAgIGhvcEJ5SG9wOiB7XG4gICAgICAgIGNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgICdrZWVwLWFsaXZlJzogdHJ1ZSxcbiAgICAgICAgJ3Byb3h5LWF1dGhlbnRpY2F0ZSc6IHRydWUsXG4gICAgICAgICdwcm94eS1hdXRob3JpemF0aW9uJzogdHJ1ZSxcbiAgICAgICAgJ3RlJzogdHJ1ZSxcbiAgICAgICAgJ3RyYWlsZXInOiB0cnVlLFxuICAgICAgICAndHJhbnNmZXItZW5jb2RpbmcnOiB0cnVlLFxuICAgICAgICAndXBncmFkZSc6IHRydWVcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5SZXNwb25zZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgdGhpcy5hcHAgPSB7fTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbmNvbXBsZXRlIGFzIHNvbWUgaGVhZGVycyBhcmUgc3RvcmVkIGluIGZsYWdzXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudmFyaWV0eSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIGNoYXJzZXQ6ICd1dGYtOCcsICAgICAgICAgICAgICAgICAgICAgICAvLyAnLScgcmVxdWlyZWQgYnkgSUFOQVxuICAgICAgICAgICAgY29tcHJlc3NlZDogbnVsbCxcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBudWxsLFxuICAgICAgICAgICAgcGFzc1Rocm91Z2g6IHRydWUsXG4gICAgICAgICAgICBzdHJpbmdpZnk6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgLy8gSlNPTi5zdHJpbmdpZnkgb3B0aW9uc1xuICAgICAgICAgICAgdHRsOiBudWxsLFxuICAgICAgICAgICAgdmFyeUV0YWc6IGZhbHNlXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGF5bG9hZCA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFkYWJsZSBzdHJlYW1cbiAgICAgICAgdGhpcy5fZXJyb3IgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYm9vbSBvYmplY3Qgd2hlbiBjcmVhdGVkIGZyb20gYW4gZXJyb3IgKHVzZWQgZm9yIGxvZ2dpbmcpXG4gICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gbnVsbDsgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBpZiBubyBleHBsaWNpdCBjb250ZW50LXR5cGUgaXMgc2V0IGFuZCB0eXBlIGlzIGtub3duXG4gICAgICAgIHRoaXMuX3Rha2VvdmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXR1c0NvZGUgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSB3aGVuIGNvZGUoKSBjYWxsZWRcblxuICAgICAgICB0aGlzLl9wcm9jZXNzb3JzID0ge1xuICAgICAgICAgICAgbWFyc2hhbDogb3B0aW9ucy5tYXJzaGFsLFxuICAgICAgICAgICAgcHJlcGFyZTogb3B0aW9ucy5wcmVwYXJlLFxuICAgICAgICAgICAgY2xvc2U6IG9wdGlvbnMuY2xvc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnRlbXBvcmFyeSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVybWFuZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXdyaXRhYmxlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zZXRTb3VyY2Uoc291cmNlLCBvcHRpb25zLnZhcmlldHkpO1xuICAgIH1cblxuICAgIHN0YXRpYyB3cmFwKHJlc3VsdCwgcmVxdWVzdCkge1xuXG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBpbnRlcm5hbHMuUmVzcG9uc2UgfHxcbiAgICAgICAgICAgIHR5cGVvZiByZXN1bHQgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29tLmJvb21pZnkocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlJlc3BvbnNlKHJlc3VsdCwgcmVxdWVzdCk7XG4gICAgfVxuXG4gICAgX3NldFNvdXJjZShzb3VyY2UsIHZhcmlldHkpIHtcblxuICAgICAgICAvLyBNZXRob2QgbXVzdCBub3Qgc2V0IGFueSBoZWFkZXJzIG9yIG90aGVyIHByb3BlcnRpZXMgYXMgc291cmNlIGNhbiBjaGFuZ2UgbGF0ZXJcblxuICAgICAgICB0aGlzLnZhcmlldHkgPSB2YXJpZXR5IHx8ICdwbGFpbic7XG5cbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgc291cmNlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgc291cmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy52YXJpZXR5ID0gJ2J1ZmZlcic7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFN0cmVhbXMuaXNTdHJlYW0oc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy52YXJpZXR5ID0gJ3N0cmVhbSc7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAgICAgaWYgKHRoaXMudmFyaWV0eSA9PT0gJ3BsYWluJyAmJlxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSAodHlwZW9mIHRoaXMuc291cmNlID09PSAnc3RyaW5nJyA/ICd0ZXh0L2h0bWwnIDogJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBldmVudHMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBQb2RpdW0oaW50ZXJuYWxzLmV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzO1xuICAgIH1cblxuICAgIGNvZGUoc3RhdHVzQ29kZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKHN0YXR1c0NvZGUpLCAnU3RhdHVzIGNvZGUgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG5cbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5fc3RhdHVzQ29kZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbWVzc2FnZShodHRwTWVzc2FnZSkge1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MubWVzc2FnZSA9IGh0dHBNZXNzYWdlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBoZWFkZXIoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoa2V5ID09PSAndmFyeScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcnkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcihrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfaGVhZGVyKGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGFwcGVuZCA9IG9wdGlvbnMuYXBwZW5kIHx8IGZhbHNlO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciB8fCAnLCc7XG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gb3B0aW9ucy5vdmVycmlkZSAhPT0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZSA9IG9wdGlvbnMuZHVwbGljYXRlICE9PSBmYWxzZTtcblxuICAgICAgICBpZiAoIWFwcGVuZCAmJiBvdmVycmlkZSB8fFxuICAgICAgICAgICAgIXRoaXMuaGVhZGVyc1trZXldKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyc1trZXldID0gW10uY29uY2F0KHRoaXMuaGVhZGVyc1trZXldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGV4aXN0aW5nLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzW2tleV0gPSBleGlzdGluZyArIHNlcGFyYXRvciArIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyeSh2YWx1ZSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJyonKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMudmFyeSA9ICcqJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5oZWFkZXJzLnZhcnkpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy52YXJ5ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXJzLnZhcnkgIT09ICcqJykge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyKCd2YXJ5JywgdmFsdWUsIHsgYXBwZW5kOiB0cnVlLCBkdXBsaWNhdGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZXRhZyh0YWcsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBlbnRpdHkgPSBpbnRlcm5hbHMuUmVzcG9uc2UuZW50aXR5KHRhZywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2hlYWRlcignZXRhZycsIGVudGl0eS5ldGFnKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy52YXJ5RXRhZyA9IGVudGl0eS52YXJ5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZW50aXR5KHRhZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGFnICE9PSAnKicsICdFVGFnIGNhbm5vdCBiZSAqJyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV0YWc6IChvcHRpb25zLndlYWsgPyAnVy8nIDogJycpICsgJ1wiJyArIHRhZyArICdcIicsXG4gICAgICAgICAgICB2YXJ5OiBvcHRpb25zLnZhcnkgIT09IGZhbHNlICYmICFvcHRpb25zLndlYWssICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcnkgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgbW9kaWZpZWQ6IG9wdGlvbnMubW9kaWZpZWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdW5tb2RpZmllZChyZXF1ZXN0LCBlbnRpdHkpIHtcblxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09ICdnZXQnICYmXG4gICAgICAgICAgICByZXF1ZXN0Lm1ldGhvZCAhPT0gJ2hlYWQnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0cm9uZyB2ZXJpZmllclxuXG4gICAgICAgIGlmIChlbnRpdHkuZXRhZyAmJlxuICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzWydpZi1ub25lLW1hdGNoJ10pIHtcblxuICAgICAgICAgICAgY29uc3QgaWZOb25lTWF0Y2ggPSByZXF1ZXN0LmhlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXS5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV0YWcgb2YgaWZOb25lTWF0Y2gpIHtcblxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgdGFncyAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzIjc2VjdGlvbi0yLjMuMilcblxuICAgICAgICAgICAgICAgIGlmIChldGFnID09PSBlbnRpdHkuZXRhZykgeyAgICAgICAgICAgICAvLyBTdHJvbmcgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWVudGl0eS52YXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChldGFnID09PSBgVy8ke2VudGl0eS5ldGFnfWApIHsgICAgICAvLyBXZWFrIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV0YWc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZXRhZ0Jhc2UgPSBlbnRpdHkuZXRhZy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlcnMgPSByZXF1ZXN0Ll9jb3JlLmNvbXByZXNzaW9uLmVuY29kaW5ncztcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kZXIgb2YgZW5jb2RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV0YWcgPT09IGV0YWdCYXNlICsgYC0ke2VuY29kZXJ9XCJgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2VhayB2ZXJpZmllclxuXG4gICAgICAgIGlmICghZW50aXR5Lm1vZGlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZk1vZGlmaWVkU2luY2VIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnNbJ2lmLW1vZGlmaWVkLXNpbmNlJ107XG4gICAgICAgIGlmICghaWZNb2RpZmllZFNpbmNlSGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZk1vZGlmaWVkU2luY2UgPSBpbnRlcm5hbHMucGFyc2VEYXRlKGlmTW9kaWZpZWRTaW5jZUhlYWRlcik7XG4gICAgICAgIGlmICghaWZNb2RpZmllZFNpbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYXN0TW9kaWZpZWQgPSBpbnRlcm5hbHMucGFyc2VEYXRlKGVudGl0eS5tb2RpZmllZCk7XG4gICAgICAgIGlmICghbGFzdE1vZGlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWZNb2RpZmllZFNpbmNlID49IGxhc3RNb2RpZmllZDtcbiAgICB9XG5cbiAgICB0eXBlKHR5cGUpIHtcblxuICAgICAgICB0aGlzLl9oZWFkZXIoJ2NvbnRlbnQtdHlwZScsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBieXRlcyhieXRlcykge1xuXG4gICAgICAgIHRoaXMuX2hlYWRlcignY29udGVudC1sZW5ndGgnLCBieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGxvY2F0aW9uKHVyaSkge1xuXG4gICAgICAgIHRoaXMuX2hlYWRlcignbG9jYXRpb24nLCB1cmkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjcmVhdGVkKGxvY2F0aW9uKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5yZXF1ZXN0Lm1ldGhvZCA9PT0gJ3Bvc3QnIHx8XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QubWV0aG9kID09PSAncHV0JyB8fFxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Lm1ldGhvZCA9PT0gJ3BhdGNoJywgJ0Nhbm5vdCByZXR1cm4gMjAxIHN0YXR1cyBjb2RlcyBmb3IgJyArIHRoaXMucmVxdWVzdC5tZXRob2QudG9VcHBlckNhc2UoKSk7XG5cbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gMjAxO1xuICAgICAgICB0aGlzLmxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29tcHJlc3NlZChlbmNvZGluZykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGVuY29kaW5nICYmIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycsICdJbnZhbGlkIGNvbnRlbnQtZW5jb2RpbmcnKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5jb21wcmVzc2VkID0gZW5jb2Rpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJlcGxhY2VyKG1ldGhvZCkge1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5ID0gdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkgfHwge307XG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5LnJlcGxhY2VyID0gbWV0aG9kO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzcGFjZXMoY291bnQpIHtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeSA9IHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5IHx8IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeS5zcGFjZSA9IGNvdW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdWZmaXgoc3VmZml4KSB7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkgPSB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeSB8fCB7fTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBlc2NhcGUoZXNjYXBlKSB7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkgPSB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeSB8fCB7fTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkuZXNjYXBlID0gZXNjYXBlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwYXNzVGhyb3VnaChlbmFibGVkKSB7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5wYXNzVGhyb3VnaCA9IGVuYWJsZWQgIT09IGZhbHNlOyAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVkaXJlY3QobG9jYXRpb24pIHtcblxuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAzMDI7XG4gICAgICAgIHRoaXMubG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeSA9IHRoaXMuX3RlbXBvcmFyeTtcbiAgICAgICAgdGhpcy5wZXJtYW5lbnQgPSB0aGlzLl9wZXJtYW5lbnQ7XG4gICAgICAgIHRoaXMucmV3cml0YWJsZSA9IHRoaXMuX3Jld3JpdGFibGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF90ZW1wb3JhcnkoaXNUZW1wb3JhcnkpIHtcblxuICAgICAgICB0aGlzLl9zZXRUZW1wb3JhcnkoaXNUZW1wb3JhcnkgIT09IGZhbHNlKTsgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3Blcm1hbmVudChpc1Blcm1hbmVudCkge1xuXG4gICAgICAgIHRoaXMuX3NldFRlbXBvcmFyeShpc1Blcm1hbmVudCA9PT0gZmFsc2UpOyAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfcmV3cml0YWJsZShpc1Jld3JpdGFibGUpIHtcblxuICAgICAgICB0aGlzLl9zZXRSZXdyaXRhYmxlKGlzUmV3cml0YWJsZSAhPT0gZmFsc2UpOyAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX2lzVGVtcG9yYXJ5KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1c0NvZGUgPT09IDMwMiB8fCB0aGlzLnN0YXR1c0NvZGUgPT09IDMwNztcbiAgICB9XG5cbiAgICBfaXNSZXdyaXRhYmxlKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1c0NvZGUgPT09IDMwMSB8fCB0aGlzLnN0YXR1c0NvZGUgPT09IDMwMjtcbiAgICB9XG5cbiAgICBfc2V0VGVtcG9yYXJ5KGlzVGVtcG9yYXJ5KSB7XG5cbiAgICAgICAgaWYgKGlzVGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXdyaXRhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAzMDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAzMDc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSZXdyaXRhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAzMDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAzMDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0UmV3cml0YWJsZShpc1Jld3JpdGFibGUpIHtcblxuICAgICAgICBpZiAoaXNSZXdyaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNUZW1wb3JhcnkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IDMwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IDMwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1RlbXBvcmFyeSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gMzA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gMzA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5jb2RpbmcoZW5jb2RpbmcpIHtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNoYXJzZXQoY2hhcnNldCkge1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY2hhcnNldCA9IGNoYXJzZXQgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdHRsKHR0bCkge1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MudHRsID0gdHRsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzdGF0ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucmVxdWVzdC5fc2V0U3RhdGUobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB1bnN0YXRlKG5hbWUsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLnJlcXVlc3QuX2NsZWFyU3RhdGUobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRha2VvdmVyKCkge1xuXG4gICAgICAgIHRoaXMuX3Rha2VvdmVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3ByZXBhcmUoKSB7XG5cbiAgICAgICAgdGhpcy5fcGFzc1Rocm91Z2goKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3Byb2Nlc3NvcnMucHJlcGFyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NvcnMucHJlcGFyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJvb21pZnkoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wYXNzVGhyb3VnaCgpIHtcblxuICAgICAgICBpZiAodGhpcy52YXJpZXR5ID09PSAnc3RyZWFtJyAmJlxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5wYXNzVGhyb3VnaCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2Uuc3RhdHVzQ29kZSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnN0YXR1c0NvZGUpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHRoaXMuc291cmNlLnN0YXR1c0NvZGU7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyZWFtIGlzIGFuIEhUVFAgcmVzcG9uc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGVhZGVyS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlLmhlYWRlcnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcktleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsSGVhZGVycyA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMuc291cmNlLmhlYWRlcnMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnlIb3AgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc3BsaXQoL1xccyosXFxzKi8pLmZvckVhY2goKGhlYWRlcikgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnlIb3BbaGVhZGVyXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGhlYWRlcktleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5ob3BCeUhvcFtsb3dlcl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYnlIb3BbbG93ZXJdKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcihsb3dlciwgSG9lay5jbG9uZSh0aGlzLnNvdXJjZS5oZWFkZXJzW2tleV0pKTsgICAgIC8vIENsb25lIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyS2V5cyA9IE9iamVjdC5rZXlzKGxvY2FsSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGhlYWRlcktleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyKGtleSwgbG9jYWxIZWFkZXJzW2tleV0sIHsgYXBwZW5kOiBrZXkgPT09ICdzZXQtY29va2llJyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IHRoaXMuc3RhdHVzQ29kZSB8fCAyMDA7XG4gICAgfVxuXG4gICAgYXN5bmMgX21hcnNoYWwoKSB7XG5cbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuXG4gICAgICAgIC8vIFByb2Nlc3NvciBtYXJzaGFsXG5cbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3NvcnMubWFyc2hhbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBhd2FpdCB0aGlzLl9wcm9jZXNzb3JzLm1hcnNoYWwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdHJlYW0gc291cmNlXG5cbiAgICAgICAgaWYgKFN0cmVhbXMuaXNTdHJlYW0oc291cmNlKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UuX3JlYWQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdTdHJlYW0gbXVzdCBoYXZlIGEgcmVhZGFibGUgaW50ZXJmYWNlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2UuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0Nhbm5vdCByZXBseSB3aXRoIHN0cmVhbSBpbiBvYmplY3QgbW9kZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9wYXlsb2FkID0gc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGxhaW4gc291cmNlIChub24gc3RyaW5nIG9yIG51bGwpXG5cbiAgICAgICAgY29uc3QganNvbmlmeSA9IHRoaXMudmFyaWV0eSA9PT0gJ3BsYWluJyAmJiBzb3VyY2UgIT09IG51bGwgJiYgdHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZyc7XG5cbiAgICAgICAgaWYgKCFqc29uaWZ5ICYmXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeSkge1xuXG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdDYW5ub3Qgc2V0IGZvcm1hdHRpbmcgb3B0aW9ucyBvbiBub24gb2JqZWN0IHJlc3BvbnNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGF5bG9hZCA9IHNvdXJjZTtcblxuICAgICAgICBpZiAoanNvbmlmeSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5IHx8IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3BhY2UgPSBvcHRpb25zLnNwYWNlIHx8IHRoaXMucmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5qc29uLnNwYWNlO1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZXIgPSBvcHRpb25zLnJlcGxhY2VyIHx8IHRoaXMucmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5qc29uLnJlcGxhY2VyO1xuICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gb3B0aW9ucy5zdWZmaXggfHwgdGhpcy5yZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmpzb24uc3VmZml4IHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgZXNjYXBlID0gdGhpcy5yZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmpzb24uZXNjYXBlIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlciB8fCBzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCwgcmVwbGFjZXIsIHNwYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gcGF5bG9hZCArIHN1ZmZpeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBIb2VrLmVzY2FwZUpzb24ocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXlsb2FkID0gbmV3IGludGVybmFscy5SZXNwb25zZS5QYXlsb2FkKHBheWxvYWQsIHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIF90YXAoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5oYXNMaXN0ZW5lcnMoJ3BlZWsnKSB8fFxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmhhc0xpc3RlbmVycygnZmluaXNoJykpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVzcG9uc2UuUGVlayh0aGlzLl9ldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX2Nsb3NlKHJlcXVlc3QpIHtcblxuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc29ycy5jbG9zZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzb3JzLmNsb3NlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuX2xvZyhbJ3Jlc3BvbnNlJywgJ2NsZWFudXAnLCAnZXJyb3InXSwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX3BheWxvYWQgfHwgdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChTdHJlYW1zLmlzU3RyZWFtKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIGludGVybmFscy5SZXNwb25zZS5kcmFpbihzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2lzUGF5bG9hZFN1cHBvcnRlZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0Lm1ldGhvZCAhPT0gJ2hlYWQnICYmIHRoaXMuc3RhdHVzQ29kZSAhPT0gMzA0ICYmIHRoaXMuc3RhdHVzQ29kZSAhPT0gMjA0O1xuICAgIH1cblxuICAgIHN0YXRpYyBkcmFpbihzdHJlYW0pIHtcblxuICAgICAgICBpZiAoc3RyZWFtLnVucGlwZSkge1xuICAgICAgICAgICAgc3RyZWFtLnVucGlwZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmVhbS5jbG9zZSkge1xuICAgICAgICAgICAgc3RyZWFtLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBTdHJlYW1zLmRyYWluKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5wYXJzZURhdGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gRGF0ZS5wYXJzZShzdHJpbmcpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJySWdub3JlKSB7IH1cbn07XG5cblxuaW50ZXJuYWxzLlJlc3BvbnNlLlBheWxvYWQgPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5SZWFkYWJsZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5fcHJlZml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3VmZml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2l6ZU9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICB9XG5cbiAgICBfcmVhZChzaXplKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX3ByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuX3ByZWZpeCwgdGhpcy5fZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9kYXRhLCB0aGlzLl9lbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc3VmZml4KSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5fc3VmZml4LCB0aGlzLl9lbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgfVxuXG4gICAgc2l6ZSgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2RhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaXplT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChCdWZmZXIuaXNCdWZmZXIodGhpcy5fZGF0YSkgPyB0aGlzLl9kYXRhLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKHRoaXMuX2RhdGEsIHRoaXMuX2VuY29kaW5nKSkgKyB0aGlzLl9zaXplT2Zmc2V0O1xuICAgIH1cblxuICAgIGpzb25wKHZhcmlhYmxlKSB7XG5cbiAgICAgICAgdGhpcy5fc2l6ZU9mZnNldCA9IHRoaXMuX3NpemVPZmZzZXQgKyB2YXJpYWJsZS5sZW5ndGggKyA3O1xuICAgICAgICB0aGlzLl9wcmVmaXggPSAnLyoqLycgKyB2YXJpYWJsZSArICcoJzsgICAgICAgICAgICAgICAgIC8vICcvKiovJyBwcmVmaXggcHJldmVudHMgQ1ZFLTIwMTQtNDY3MSBzZWN1cml0eSBleHBsb2l0XG4gICAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSA9PT0gbnVsbCB8fCBCdWZmZXIuaXNCdWZmZXIodGhpcy5fZGF0YSkpID8gdGhpcy5fZGF0YSA6IHRoaXMuX2RhdGEucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JykucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jyk7XG4gICAgICAgIHRoaXMuX3N1ZmZpeCA9ICcpOyc7XG4gICAgfVxuXG4gICAgd3JpdGVUb1N0cmVhbShzdHJlYW0pIHtcblxuICAgICAgICBpZiAodGhpcy5fcHJlZml4KSB7XG4gICAgICAgICAgICBzdHJlYW0ud3JpdGUodGhpcy5fcHJlZml4LCB0aGlzLl9lbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlKHRoaXMuX2RhdGEsIHRoaXMuX2VuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdWZmaXgpIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZSh0aGlzLl9zdWZmaXgsIHRoaXMuX2VuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5SZXNwb25zZS5QZWVrID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW0uVHJhbnNmb3JtIHtcblxuICAgIGNvbnN0cnVjdG9yKHBvZGl1bSkge1xuXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5fcG9kaXVtID0gcG9kaXVtO1xuICAgICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiBwb2RpdW0uZW1pdCgnZmluaXNoJykpO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXG4gICAgICAgIHRoaXMuX3BvZGl1bS5lbWl0KCdwZWVrJywgW2NodW5rLCBlbmNvZGluZ10pO1xuICAgICAgICB0aGlzLnB1c2goY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgQ2F0Ym94ID0gcmVxdWlyZSgnQGhhcGkvY2F0Ym94Jyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5jb25zdCBTdWJ0ZXh0ID0gcmVxdWlyZSgnQGhhcGkvc3VidGV4dCcpO1xuXG5jb25zdCBBdXRoID0gcmVxdWlyZSgnLi9hdXRoJyk7XG5jb25zdCBDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuY29uc3QgQ29ycyA9IHJlcXVpcmUoJy4vY29ycycpO1xuY29uc3QgRXh0ID0gcmVxdWlyZSgnLi9leHQnKTtcbmNvbnN0IEhhbmRsZXIgPSByZXF1aXJlKCcuL2hhbmRsZXInKTtcbmNvbnN0IEhlYWRlcnMgPSByZXF1aXJlKCcuL2hlYWRlcnMnKTtcbmNvbnN0IFNlY3VyaXR5ID0gcmVxdWlyZSgnLi9zZWN1cml0eScpO1xuY29uc3QgU3RyZWFtcyA9IHJlcXVpcmUoJy4vc3RyZWFtcycpO1xuY29uc3QgVmFsaWRhdGlvbiA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Sb3V0ZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHJvdXRlLCBzZXJ2ZXIsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGNvcmUgPSBzZXJ2ZXIuX2NvcmU7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gc2VydmVyLnJlYWxtO1xuXG4gICAgICAgIC8vIFJvdXRpbmcgaW5mb3JtYXRpb25cblxuICAgICAgICBDb25maWcuYXBwbHkoJ3JvdXRlJywgcm91dGUsIHJvdXRlLm1ldGhvZCwgcm91dGUucGF0aCk7XG5cbiAgICAgICAgY29uc3QgbWV0aG9kID0gcm91dGUubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG1ldGhvZCAhPT0gJ2hlYWQnLCAnQ2Fubm90IHNldCBIRUFEIHJvdXRlOicsIHJvdXRlLnBhdGgpO1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSAocmVhbG0ubW9kaWZpZXJzLnJvdXRlLnByZWZpeCA/IHJlYWxtLm1vZGlmaWVycy5yb3V0ZS5wcmVmaXggKyAocm91dGUucGF0aCAhPT0gJy8nID8gcm91dGUucGF0aCA6ICcnKSA6IHJvdXRlLnBhdGgpO1xuICAgICAgICBIb2VrLmFzc2VydChwYXRoID09PSAnLycgfHwgcGF0aFtwYXRoLmxlbmd0aCAtIDFdICE9PSAnLycgfHwgIWNvcmUuc2V0dGluZ3Mucm91dGVyLnN0cmlwVHJhaWxpbmdTbGFzaCwgJ1BhdGggY2Fubm90IGVuZCB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggd2hlbiBjb25maWd1cmVkIHRvIHN0cmlwOicsIHJvdXRlLm1ldGhvZCwgcm91dGUucGF0aCk7XG5cbiAgICAgICAgY29uc3Qgdmhvc3QgPSAocmVhbG0ubW9kaWZpZXJzLnJvdXRlLnZob3N0IHx8IHJvdXRlLnZob3N0KTtcblxuICAgICAgICAvLyBTZXQgaWRlbnRpZnlpbmcgbWVtYmVycyAoYXNzZXJ0KVxuXG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuXG4gICAgICAgIC8vIFByZXBhcmUgY29uZmlndXJhdGlvblxuXG4gICAgICAgIGxldCBjb25maWcgPSByb3V0ZS5vcHRpb25zIHx8IHJvdXRlLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZy5jYWxsKHJlYWxtLnNldHRpbmdzLmJpbmQsIHNlcnZlcik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcgPSBDb25maWcuZW5hYmxlKGNvbmZpZyk7ICAgICAvLyBTaGFsbG93IGNsb25lXG5cbiAgICAgICAgLy8gVmVyaWZ5IHJvdXRlIGxldmVsIGNvbmZpZyAoYXMgb3Bwb3NlZCB0byB0aGUgbWVyZ2VkIHNldHRpbmdzKVxuXG4gICAgICAgIHRoaXMuX2Fzc2VydChtZXRob2QgIT09ICdnZXQnIHx8ICFjb25maWcucGF5bG9hZCwgJ0Nhbm5vdCBzZXQgcGF5bG9hZCBzZXR0aW5ncyBvbiBIRUFEIG9yIEdFVCByZXF1ZXN0Jyk7XG4gICAgICAgIHRoaXMuX2Fzc2VydChtZXRob2QgIT09ICdnZXQnIHx8ICFjb25maWcudmFsaWRhdGUgfHwgIWNvbmZpZy52YWxpZGF0ZS5wYXlsb2FkLCAnQ2Fubm90IHZhbGlkYXRlIEhFQUQgb3IgR0VUIHJlcXVlc3QgcGF5bG9hZCcpO1xuXG4gICAgICAgIC8vIFJ1bGVzXG5cbiAgICAgICAgdGhpcy5fYXNzZXJ0KCFyb3V0ZS5ydWxlcyB8fCAhY29uZmlnLnJ1bGVzLCAnUm91dGUgcnVsZXMgY2FuIG9ubHkgYXBwZWFyIG9uY2UnKTsgICAgICAgICAgICAgICAgICAgIC8vIFhPUlxuICAgICAgICBjb25zdCBydWxlcyA9IChyb3V0ZS5ydWxlcyB8fCBjb25maWcucnVsZXMpO1xuICAgICAgICBjb25zdCBydWxlc0NvbmZpZyA9IGludGVybmFscy5ydWxlcyhydWxlcywgeyBtZXRob2QsIHBhdGgsIHZob3N0IH0sIHNlcnZlcik7XG4gICAgICAgIGRlbGV0ZSBjb25maWcucnVsZXM7XG5cbiAgICAgICAgLy8gSGFuZGxlclxuXG4gICAgICAgIHRoaXMuX2Fzc2VydChyb3V0ZS5oYW5kbGVyIHx8IGNvbmZpZy5oYW5kbGVyLCAnTWlzc2luZyBvciB1bmRlZmluZWQgaGFuZGxlcicpO1xuICAgICAgICB0aGlzLl9hc3NlcnQoISFyb3V0ZS5oYW5kbGVyIF4gISFjb25maWcuaGFuZGxlciwgJ0hhbmRsZXIgbXVzdCBvbmx5IGFwcGVhciBvbmNlJyk7ICAgICAgICAgICAgICAgICAgLy8gWE9SXG5cbiAgICAgICAgY29uc3QgaGFuZGxlciA9IENvbmZpZy5hcHBseSgnaGFuZGxlcicsIHJvdXRlLmhhbmRsZXIgfHwgY29uZmlnLmhhbmRsZXIpO1xuICAgICAgICBkZWxldGUgY29uZmlnLmhhbmRsZXI7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlckRlZmF1bHRzID0gSGFuZGxlci5kZWZhdWx0cyhtZXRob2QsIGhhbmRsZXIsIGNvcmUpO1xuXG4gICAgICAgIC8vIEFwcGx5IHNldHRpbmdzIGluIG9yZGVyOiBzZXJ2ZXIgPC0gaGFuZGxlciA8LSByZWFsbSA8LSByb3V0ZVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gaW50ZXJuYWxzLmNvbmZpZyhbY29yZS5zZXR0aW5ncy5yb3V0ZXMsIGhhbmRsZXJEZWZhdWx0cywgcmVhbG0uc2V0dGluZ3MsIHJ1bGVzQ29uZmlnLCBjb25maWddKTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IENvbmZpZy5hcHBseSgncm91dGVDb25maWcnLCBzZXR0aW5ncywgbWV0aG9kLCBwYXRoKTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0aW1lb3V0c1xuXG4gICAgICAgIGNvbnN0IHNvY2tldFRpbWVvdXQgPSAodGhpcy5zZXR0aW5ncy50aW1lb3V0LnNvY2tldCA9PT0gdW5kZWZpbmVkID8gMiAqIDYwICogMTAwMCA6IHRoaXMuc2V0dGluZ3MudGltZW91dC5zb2NrZXQpO1xuICAgICAgICB0aGlzLl9hc3NlcnQoIXRoaXMuc2V0dGluZ3MudGltZW91dC5zZXJ2ZXIgfHwgIXNvY2tldFRpbWVvdXQgfHwgdGhpcy5zZXR0aW5ncy50aW1lb3V0LnNlcnZlciA8IHNvY2tldFRpbWVvdXQsICdTZXJ2ZXIgdGltZW91dCBtdXN0IGJlIHNob3J0ZXIgdGhhbiBzb2NrZXQgdGltZW91dCcpO1xuICAgICAgICB0aGlzLl9hc3NlcnQoIXRoaXMuc2V0dGluZ3MucGF5bG9hZC50aW1lb3V0IHx8ICFzb2NrZXRUaW1lb3V0IHx8IHRoaXMuc2V0dGluZ3MucGF5bG9hZC50aW1lb3V0IDwgc29ja2V0VGltZW91dCwgJ1BheWxvYWQgdGltZW91dCBtdXN0IGJlIHNob3J0ZXIgdGhhbiBzb2NrZXQgdGltZW91dCcpO1xuXG4gICAgICAgIC8vIFJvdXRlIG1lbWJlcnNcblxuICAgICAgICB0aGlzLl9jb3JlID0gY29yZTtcbiAgICAgICAgdGhpcy5yZWFsbSA9IHJlYWxtO1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3Mudmhvc3QgPSB2aG9zdDtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5wbHVnaW5zID0gdGhpcy5zZXR0aW5ncy5wbHVnaW5zIHx8IHt9OyAgICAgICAgICAgIC8vIFJvdXRlLXNwZWNpZmljIHBsdWdpbnMgc2V0dGluZ3MsIG5hbWVzcGFjZWQgdXNpbmcgcGx1Z2luIG5hbWVcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hcHAgPSB0aGlzLnNldHRpbmdzLmFwcCB8fCB7fTsgICAgICAgICAgICAgICAgICAgIC8vIFJvdXRlLXNwZWNpZmljIGFwcGxpY2F0aW9uIHNldHRpbmdzXG5cbiAgICAgICAgLy8gUGF0aCBwYXJzaW5nXG5cbiAgICAgICAgdGhpcy5fc3BlY2lhbCA9ICEhb3B0aW9ucy5zcGVjaWFsO1xuICAgICAgICB0aGlzLl9hbmFseXNpcyA9IHRoaXMuX2NvcmUucm91dGVyLmFuYWx5emUodGhpcy5wYXRoKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9hbmFseXNpcy5wYXJhbXM7XG4gICAgICAgIHRoaXMuZmluZ2VycHJpbnQgPSB0aGlzLl9hbmFseXNpcy5maW5nZXJwcmludDtcblxuICAgICAgICB0aGlzLnB1YmxpYyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogdGhpcy5tZXRob2QsXG4gICAgICAgICAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgICAgICAgICB2aG9zdCxcbiAgICAgICAgICAgIHJlYWxtLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICAgICAgICBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgICAgICAgIGF1dGg6IHtcbiAgICAgICAgICAgICAgICBhY2Nlc3M6IChyZXF1ZXN0KSA9PiBBdXRoLnRlc3RBY2Nlc3MocmVxdWVzdCwgdGhpcy5wdWJsaWMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVmFsaWRhdGlvblxuXG4gICAgICAgIHRoaXMuX3NldHVwVmFsaWRhdGlvbigpO1xuXG4gICAgICAgIC8vIFBheWxvYWQgcGFyc2luZ1xuXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ2dldCcpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucGF5bG9hZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnBheWxvYWQuZGVjb2RlcnMgPSB0aGlzLl9jb3JlLmNvbXByZXNzaW9uLl9kZWNvZGVyczsgICAgICAgIC8vIFJlZmVyZW5jZSB0aGUgc2hhcmVkIG9iamVjdCB0byBrZWVwIHVwIHRvIGRhdGVcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Fzc2VydCghdGhpcy5zZXR0aW5ncy52YWxpZGF0ZS5wYXlsb2FkIHx8IHRoaXMuc2V0dGluZ3MucGF5bG9hZC5wYXJzZSwgJ1JvdXRlIHBheWxvYWQgbXVzdCBiZSBzZXQgdG8gXFwncGFyc2VcXCcgd2hlbiBwYXlsb2FkIHZhbGlkYXRpb24gZW5hYmxlZCcpO1xuICAgICAgICB0aGlzLl9hc3NlcnQoIXRoaXMuc2V0dGluZ3MudmFsaWRhdGUuc3RhdGUgfHwgdGhpcy5zZXR0aW5ncy5zdGF0ZS5wYXJzZSwgJ1JvdXRlIHN0YXRlIG11c3QgYmUgc2V0IHRvIFxcJ3BhcnNlXFwnIHdoZW4gc3RhdGUgdmFsaWRhdGlvbiBlbmFibGVkJyk7XG4gICAgICAgIHRoaXMuX2Fzc2VydCghdGhpcy5zZXR0aW5ncy5qc29ucCB8fCB0eXBlb2YgdGhpcy5zZXR0aW5ncy5qc29ucCA9PT0gJ3N0cmluZycsICdCYWQgcm91dGUgSlNPTlAgcGFyYW1ldGVyIG5hbWUnKTtcblxuICAgICAgICAvLyBBdXRoZW50aWNhdGlvbiBjb25maWd1cmF0aW9uXG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5hdXRoID0gKHRoaXMuX3NwZWNpYWwgPyBmYWxzZSA6IHRoaXMuX2NvcmUuYXV0aC5fc2V0dXBSb3V0ZSh0aGlzLnNldHRpbmdzLmF1dGgsIHBhdGgpKTtcblxuICAgICAgICAvLyBDYWNoZVxuXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ2dldCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLnNldHRpbmdzLmNhY2hlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKHRoaXMuc2V0dGluZ3MuY2FjaGUuZXhwaXJlc0luIHx8IHRoaXMuc2V0dGluZ3MuY2FjaGUuZXhwaXJlc0F0KSkge1xuXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmNhY2hlLl9zdGF0dXNlcyA9IG5ldyBTZXQodGhpcy5zZXR0aW5ncy5jYWNoZS5zdGF0dXNlcyk7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBDYXRib3guUG9saWN5KHsgZXhwaXJlc0luOiB0aGlzLnNldHRpbmdzLmNhY2hlLmV4cGlyZXNJbiwgZXhwaXJlc0F0OiB0aGlzLnNldHRpbmdzLmNhY2hlLmV4cGlyZXNBdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENPUlNcblxuICAgICAgICB0aGlzLnNldHRpbmdzLmNvcnMgPSBDb3JzLnJvdXRlKHRoaXMuc2V0dGluZ3MuY29ycyk7XG5cbiAgICAgICAgLy8gU2VjdXJpdHlcblxuICAgICAgICB0aGlzLnNldHRpbmdzLnNlY3VyaXR5ID0gU2VjdXJpdHkucm91dGUodGhpcy5zZXR0aW5ncy5zZWN1cml0eSk7XG5cbiAgICAgICAgLy8gSGFuZGxlclxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuaGFuZGxlciA9IEhhbmRsZXIuY29uZmlndXJlKGhhbmRsZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLl9wcmVyZXF1aXNpdGVzID0gSGFuZGxlci5wcmVyZXF1aXNpdGVzQ29uZmlnKHRoaXMuc2V0dGluZ3MucHJlKTtcblxuICAgICAgICAvLyBSb3V0ZSBsaWZlY3ljbGVcblxuICAgICAgICB0aGlzLl9leHRlbnNpb25zID0ge1xuICAgICAgICAgICAgb25QcmVSZXNwb25zZTogRXh0LmNvbWJpbmUodGhpcywgJ29uUHJlUmVzcG9uc2UnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLl9zcGVjaWFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZSA9IFtpbnRlcm5hbHMuZHJhaW4sIEhhbmRsZXIuZXhlY3V0ZV07XG4gICAgICAgICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbnMub25QcmVBdXRoID0gRXh0LmNvbWJpbmUodGhpcywgJ29uUHJlQXV0aCcpO1xuICAgICAgICB0aGlzLl9leHRlbnNpb25zLm9uQ3JlZGVudGlhbHMgPSBFeHQuY29tYmluZSh0aGlzLCAnb25DcmVkZW50aWFscycpO1xuICAgICAgICB0aGlzLl9leHRlbnNpb25zLm9uUG9zdEF1dGggPSBFeHQuY29tYmluZSh0aGlzLCAnb25Qb3N0QXV0aCcpO1xuICAgICAgICB0aGlzLl9leHRlbnNpb25zLm9uUHJlSGFuZGxlciA9IEV4dC5jb21iaW5lKHRoaXMsICdvblByZUhhbmRsZXInKTtcbiAgICAgICAgdGhpcy5fZXh0ZW5zaW9ucy5vblBvc3RIYW5kbGVyID0gRXh0LmNvbWJpbmUodGhpcywgJ29uUG9zdEhhbmRsZXInKTtcblxuICAgICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBfc2V0dXBWYWxpZGF0aW9uKCkge1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnNldHRpbmdzLnZhbGlkYXRlO1xuICAgICAgICBpZiAodGhpcy5tZXRob2QgPT09ICdnZXQnKSB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLnBheWxvYWQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXNzZXJ0KCF2YWxpZGF0aW9uLnBhcmFtcyB8fCB0aGlzLnBhcmFtcy5sZW5ndGgsICdDYW5ub3Qgc2V0IHBhdGggcGFyYW1ldGVycyB2YWxpZGF0aW9ucyB3aXRob3V0IHBhdGggcGFyYW1ldGVycycpO1xuXG4gICAgICAgIFsnaGVhZGVycycsICdwYXJhbXMnLCAncXVlcnknLCAncGF5bG9hZCcsICdzdGF0ZSddLmZvckVhY2goKHR5cGUpID0+IHtcblxuICAgICAgICAgICAgdmFsaWRhdGlvblt0eXBlXSA9IFZhbGlkYXRpb24uY29tcGlsZSh2YWxpZGF0aW9uW3R5cGVdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2Uuc2NoZW1hICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVzcG9uc2Uuc3RhdHVzKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVzcG9uc2UuX3ZhbGlkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHRoaXMuc2V0dGluZ3MucmVzcG9uc2Uuc2NoZW1hO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXNwb25zZS5zdGF0dXMgPSB0aGlzLnNldHRpbmdzLnJlc3BvbnNlLnN0YXR1cyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c2VzID0gT2JqZWN0LmtleXModGhpcy5zZXR0aW5ncy5yZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgICAgICAgICBpZiAocnVsZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICFzdGF0dXNlcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVzcG9uc2UuX3ZhbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlc3BvbnNlLnNjaGVtYSA9IFZhbGlkYXRpb24uY29tcGlsZShydWxlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvZGUgb2Ygc3RhdHVzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXNwb25zZS5zdGF0dXNbY29kZV0gPSBWYWxpZGF0aW9uLmNvbXBpbGUodGhpcy5zZXR0aW5ncy5yZXNwb25zZS5zdGF0dXNbY29kZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlYnVpbGQoZXZlbnQpIHtcblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4dGVuc2lvbnNbZXZlbnQudHlwZV0uYWRkKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zcGVjaWFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3N0Q3ljbGUgPSAodGhpcy5fZXh0ZW5zaW9ucy5vblByZVJlc3BvbnNlLm5vZGVzID8gW3RoaXMuX2V4dGVuc2lvbnMub25QcmVSZXNwb25zZV0gOiBbXSk7XG4gICAgICAgICAgICB0aGlzLl9idWlsZE1hcnNoYWxDeWNsZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgbGlmZWN5Y2xlIGFycmF5XG5cbiAgICAgICAgdGhpcy5fY3ljbGUgPSBbXTtcblxuICAgICAgICAvLyAnb25SZXF1ZXN0J1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmpzb25wKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKGludGVybmFscy5wYXJzZUpTT05QKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0YXRlLnBhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKGludGVybmFscy5zdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucy5vblByZUF1dGgubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2godGhpcy5fZXh0ZW5zaW9ucy5vblByZUF1dGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvcmUuYXV0aC5fZW5hYmxlZCh0aGlzLCAnYXV0aGVudGljYXRlJykpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goQXV0aC5hdXRoZW50aWNhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kICE9PSAnZ2V0Jykge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaChpbnRlcm5hbHMucGF5bG9hZCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3JlLmF1dGguX2VuYWJsZWQodGhpcywgJ3BheWxvYWQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goQXV0aC5wYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb3JlLmF1dGguX2VuYWJsZWQodGhpcywgJ2F1dGhlbnRpY2F0ZScpICYmXG4gICAgICAgICAgICB0aGlzLl9leHRlbnNpb25zLm9uQ3JlZGVudGlhbHMubm9kZXMpIHtcblxuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaCh0aGlzLl9leHRlbnNpb25zLm9uQ3JlZGVudGlhbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvcmUuYXV0aC5fZW5hYmxlZCh0aGlzLCAnYWNjZXNzJykpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goQXV0aC5hY2Nlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4dGVuc2lvbnMub25Qb3N0QXV0aC5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaCh0aGlzLl9leHRlbnNpb25zLm9uUG9zdEF1dGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRhdGUuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaChWYWxpZGF0aW9uLmhlYWRlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRhdGUucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKFZhbGlkYXRpb24ucGFyYW1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmpzb25wKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKGludGVybmFscy5jbGVhbnVwSlNPTlApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmFsaWRhdGUucXVlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goVmFsaWRhdGlvbi5xdWVyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZGF0ZS5wYXlsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKFZhbGlkYXRpb24ucGF5bG9hZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaChWYWxpZGF0aW9uLnN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9leHRlbnNpb25zLm9uUHJlSGFuZGxlci5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaCh0aGlzLl9leHRlbnNpb25zLm9uUHJlSGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKEhhbmRsZXIuZXhlY3V0ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4dGVuc2lvbnMub25Qb3N0SGFuZGxlci5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaCh0aGlzLl9leHRlbnNpb25zLm9uUG9zdEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcG9zdEN5Y2xlID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2UuX3ZhbGlkYXRlICYmXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlc3BvbnNlLnNhbXBsZSAhPT0gMCkge1xuXG4gICAgICAgICAgICB0aGlzLl9wb3N0Q3ljbGUucHVzaChWYWxpZGF0aW9uLnJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9leHRlbnNpb25zLm9uUHJlUmVzcG9uc2Uubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3RDeWNsZS5wdXNoKHRoaXMuX2V4dGVuc2lvbnMub25QcmVSZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWlsZE1hcnNoYWxDeWNsZSgpO1xuICAgIH1cblxuICAgIF9idWlsZE1hcnNoYWxDeWNsZSgpIHtcblxuICAgICAgICB0aGlzLl9tYXJzaGFsQ3ljbGUgPSBbSGVhZGVycy50eXBlXTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jb3JzKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJzaGFsQ3ljbGUucHVzaChDb3JzLmhlYWRlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2VjdXJpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcnNoYWxDeWNsZS5wdXNoKFNlY3VyaXR5LmhlYWRlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFyc2hhbEN5Y2xlLnB1c2goSGVhZGVycy5lbnRpdHkpO1xuXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ2dldCcgfHxcbiAgICAgICAgICAgIHRoaXMubWV0aG9kID09PSAnKicpIHtcblxuICAgICAgICAgICAgdGhpcy5fbWFyc2hhbEN5Y2xlLnB1c2goSGVhZGVycy51bm1vZGlmaWVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcnNoYWxDeWNsZS5wdXNoKEhlYWRlcnMuY2FjaGUpO1xuICAgICAgICB0aGlzLl9tYXJzaGFsQ3ljbGUucHVzaChIZWFkZXJzLnN0YXRlKTtcbiAgICAgICAgdGhpcy5fbWFyc2hhbEN5Y2xlLnB1c2goSGVhZGVycy5jb250ZW50KTtcblxuICAgICAgICBpZiAodGhpcy5fY29yZS5hdXRoLl9lbmFibGVkKHRoaXMsICdyZXNwb25zZScpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJzaGFsQ3ljbGUucHVzaChBdXRoLnJlc3BvbnNlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBsYXN0IGluIGNhc2UgcmVxdWlyZXMgYWNjZXNzIHRvIGhlYWRlcnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfTogJHt0aGlzLm1ldGhvZC50b1VwcGVyQ2FzZSgpfSAke3RoaXMucGF0aH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgYWN0dWFsOiBmYWxzZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgb3BlcmF0b3I6ICc9PScsXG4gICAgICAgICAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHRoaXMuX2Fzc2VydFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zdGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICByZXF1ZXN0LnN0YXRlID0ge307XG5cbiAgICBjb25zdCByZXEgPSByZXF1ZXN0LnJhdy5yZXE7XG4gICAgY29uc3QgY29va2llcyA9IHJlcS5oZWFkZXJzLmNvb2tpZTtcbiAgICBpZiAoIWNvb2tpZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBhd2FpdCByZXF1ZXN0Ll9jb3JlLnN0YXRlcy5wYXJzZShjb29raWVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgdmFyIHBhcnNlRXJyb3IgPSBlcnI7XG4gICAgfVxuXG4gICAgY29uc3QgeyBzdGF0ZXMsIGZhaWxlZCA9IFtdIH0gPSByZXN1bHQgfHwgcGFyc2VFcnJvcjtcbiAgICByZXF1ZXN0LnN0YXRlID0gc3RhdGVzIHx8IHt9O1xuXG4gICAgLy8gQ2xlYXIgY29va2llc1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGZhaWxlZCkge1xuICAgICAgICBpZiAoaXRlbS5zZXR0aW5ncy5jbGVhckludmFsaWQpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuX2NsZWFyU3RhdGUoaXRlbS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGFyc2VFcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFyc2VFcnJvci5oZWFkZXIgPSBjb29raWVzO1xuXG4gICAgcmV0dXJuIHJlcXVlc3QuX2NvcmUudG9vbGtpdC5mYWlsQWN0aW9uKHJlcXVlc3QsIHJlcXVlc3Qucm91dGUuc2V0dGluZ3Muc3RhdGUuZmFpbEFjdGlvbiwgcGFyc2VFcnJvciwgeyB0YWdzOiBbJ3N0YXRlJywgJ2Vycm9yJ10gfSk7XG59O1xuXG5cbmludGVybmFscy5wYXlsb2FkID0gYXN5bmMgZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ2dldCcgfHxcbiAgICAgICAgcmVxdWVzdC5tZXRob2QgPT09ICdoZWFkJykgeyAgICAgICAgICAgIC8vIFdoZW4gcm91dGUubWV0aG9kIGlzICcqJ1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5fZXhwZWN0Q29udGludWUpIHtcbiAgICAgICAgcmVxdWVzdC5yYXcucmVzLndyaXRlQ29udGludWUoKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHBheWxvYWQsIG1pbWUgfSA9IGF3YWl0IFN1YnRleHQucGFyc2UocmVxdWVzdC5yYXcucmVxLCByZXF1ZXN0Ll90YXAoKSwgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5wYXlsb2FkKTtcblxuICAgICAgICByZXF1ZXN0Ll9pc1BheWxvYWRQZW5kaW5nID0gISEocGF5bG9hZCAmJiBwYXlsb2FkLl9yZWFkYWJsZVN0YXRlKTtcbiAgICAgICAgcmVxdWVzdC5taW1lID0gbWltZTtcbiAgICAgICAgcmVxdWVzdC5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcblxuICAgICAgICBpZiAocmVxdWVzdC5faXNQYXlsb2FkUGVuZGluZykge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJuYWxzLmRyYWluKHJlcXVlc3QpO1xuICAgICAgICAgICAgcmVxdWVzdC5faXNQYXlsb2FkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdC5faXNQYXlsb2FkUGVuZGluZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0Lm1pbWUgPSBlcnIubWltZTtcbiAgICAgICAgcmVxdWVzdC5wYXlsb2FkID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gcmVxdWVzdC5fY29yZS50b29sa2l0LmZhaWxBY3Rpb24ocmVxdWVzdCwgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5wYXlsb2FkLmZhaWxBY3Rpb24sIGVyciwgeyB0YWdzOiBbJ3BheWxvYWQnLCAnZXJyb3InXSB9KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5kcmFpbiA9IGFzeW5jIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICAvLyBGbHVzaCBvdXQgYW55IHBlbmRpbmcgcmVxdWVzdCBwYXlsb2FkIG5vdCBjb25zdW1lZCBkdWUgdG8gZXJyb3JzXG5cbiAgICBhd2FpdCBTdHJlYW1zLmRyYWluKHJlcXVlc3QucmF3LnJlcSk7XG4gICAgcmVxdWVzdC5faXNQYXlsb2FkUGVuZGluZyA9IGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuanNvbnBSZWdleCA9IC9eW1xcd1xcJFxcW1xcXVxcLl0rJC87XG5cblxuaW50ZXJuYWxzLnBhcnNlSlNPTlAgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3QganNvbnAgPSByZXF1ZXN0LnF1ZXJ5W3JlcXVlc3Qucm91dGUuc2V0dGluZ3MuanNvbnBdO1xuICAgIGlmIChqc29ucCkge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLmpzb25wUmVnZXgudGVzdChqc29ucCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgSlNPTlAgcGFyYW1ldGVyIHZhbHVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0Lmpzb25wID0ganNvbnA7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuY2xlYW51cEpTT05QID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIGlmIChyZXF1ZXN0Lmpzb25wKSB7XG4gICAgICAgIGRlbGV0ZSByZXF1ZXN0LnF1ZXJ5W3JlcXVlc3Qucm91dGUuc2V0dGluZ3MuanNvbnBdO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmNvbmZpZyA9IGZ1bmN0aW9uIChjaGFpbikge1xuXG4gICAgaWYgKCFjaGFpbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGxldCBjb25maWcgPSBjaGFpblswXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2hhaW4pIHtcbiAgICAgICAgY29uZmlnID0gSG9lay5hcHBseVRvRGVmYXVsdHMoY29uZmlnLCBpdGVtLCB7IHNoYWxsb3c6IFsnYmluZCcsICd2YWxpZGF0ZS5oZWFkZXJzJywgJ3ZhbGlkYXRlLnBheWxvYWQnLCAndmFsaWRhdGUucGFyYW1zJywgJ3ZhbGlkYXRlLnF1ZXJ5JywgJ3ZhbGlkYXRlLnN0YXRlJ10gfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGVzID0gZnVuY3Rpb24gKHJ1bGVzLCBpbmZvLCBzZXJ2ZXIpIHtcblxuICAgIGNvbnN0IGNvbmZpZ3MgPSBbXTtcblxuICAgIGxldCByZWFsbSA9IHNlcnZlci5yZWFsbTtcbiAgICB3aGlsZSAocmVhbG0pIHtcbiAgICAgICAgaWYgKHJlYWxtLl9ydWxlcykge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gKCFyZWFsbS5fcnVsZXMuc2V0dGluZ3MudmFsaWRhdGUgPyBydWxlcyA6IEpvaS5hdHRlbXB0KHJ1bGVzLCByZWFsbS5fcnVsZXMuc2V0dGluZ3MudmFsaWRhdGUuc2NoZW1hLCByZWFsbS5fcnVsZXMuc2V0dGluZ3MudmFsaWRhdGUub3B0aW9ucykpO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gcmVhbG0uX3J1bGVzLnByb2Nlc3Nvcihzb3VyY2UsIGluZm8pO1xuICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3MudW5zaGlmdChjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVhbG0gPSByZWFsbS5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5jb25maWcoY29uZmlncyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnJvdXRlID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG5cbiAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY3VyaXR5ID0gc2V0dGluZ3M7XG4gICAgaWYgKHNlY3VyaXR5LmhzdHMpIHtcbiAgICAgICAgaWYgKHNlY3VyaXR5LmhzdHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHNlY3VyaXR5Ll9oc3RzID0gJ21heC1hZ2U9MTU3NjgwMDAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWN1cml0eS5oc3RzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgc2VjdXJpdHkuX2hzdHMgPSAnbWF4LWFnZT0nICsgc2VjdXJpdHkuaHN0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlY3VyaXR5Ll9oc3RzID0gJ21heC1hZ2U9JyArIChzZWN1cml0eS5oc3RzLm1heEFnZSB8fCAxNTc2ODAwMCk7XG4gICAgICAgICAgICBpZiAoc2VjdXJpdHkuaHN0cy5pbmNsdWRlU3ViZG9tYWlucyB8fCBzZWN1cml0eS5oc3RzLmluY2x1ZGVTdWJEb21haW5zKSB7XG4gICAgICAgICAgICAgICAgc2VjdXJpdHkuX2hzdHMgPSBzZWN1cml0eS5faHN0cyArICc7IGluY2x1ZGVTdWJEb21haW5zJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlY3VyaXR5LmhzdHMucHJlbG9hZCkge1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Ll9oc3RzID0gc2VjdXJpdHkuX2hzdHMgKyAnOyBwcmVsb2FkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWN1cml0eS54ZnJhbWUpIHtcbiAgICAgICAgaWYgKHNlY3VyaXR5LnhmcmFtZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2VjdXJpdHkuX3hmcmFtZSA9ICdERU5ZJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VjdXJpdHkueGZyYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VjdXJpdHkuX3hmcmFtZSA9IHNlY3VyaXR5LnhmcmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlY3VyaXR5LnhmcmFtZS5ydWxlID09PSAnYWxsb3ctZnJvbScpIHtcbiAgICAgICAgICAgIGlmICghc2VjdXJpdHkueGZyYW1lLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Ll94ZnJhbWUgPSAnU0FNRU9SSUdJTic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWN1cml0eS5feGZyYW1lID0gJ0FMTE9XLUZST00gJyArIHNlY3VyaXR5LnhmcmFtZS5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWN1cml0eS5feGZyYW1lID0gc2VjdXJpdHkueGZyYW1lLnJ1bGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWN1cml0eTtcbn07XG5cblxuZXhwb3J0cy5oZWFkZXJzID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICBjb25zdCBzZWN1cml0eSA9IHJlc3BvbnNlLnJlcXVlc3Qucm91dGUuc2V0dGluZ3Muc2VjdXJpdHk7XG5cbiAgICBpZiAoc2VjdXJpdHkuX2hzdHMpIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcignc3RyaWN0LXRyYW5zcG9ydC1zZWN1cml0eScsIHNlY3VyaXR5Ll9oc3RzLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2VjdXJpdHkuX3hmcmFtZSkge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCd4LWZyYW1lLW9wdGlvbnMnLCBzZWN1cml0eS5feGZyYW1lLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2VjdXJpdHkueHNzKSB7XG4gICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ3gteHNzLXByb3RlY3Rpb24nLCAnMTsgbW9kZT1ibG9jaycsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGlmIChzZWN1cml0eS5ub09wZW4pIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcigneC1kb3dubG9hZC1vcHRpb25zJywgJ25vb3BlbicsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGlmIChzZWN1cml0eS5ub1NuaWZmKSB7XG4gICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ3gtY29udGVudC10eXBlLW9wdGlvbnMnLCAnbm9zbmlmZicsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGlmIChzZWN1cml0eS5yZWZlcnJlciAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcigncmVmZXJyZXItcG9saWN5Jywgc2VjdXJpdHkucmVmZXJyZXIsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcbmNvbnN0IFNob3QgPSByZXF1aXJlKCdAaGFwaS9zaG90Jyk7XG5jb25zdCBTb21ldmVyID0gcmVxdWlyZSgnQGhhcGkvc29tZXZlcicpO1xuXG5jb25zdCBDb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuY29uc3QgQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuY29uc3QgQ29ycyA9IHJlcXVpcmUoJy4vY29ycycpO1xuY29uc3QgRXh0ID0gcmVxdWlyZSgnLi9leHQnKTtcbmNvbnN0IFBhY2thZ2UgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcbmNvbnN0IFJvdXRlID0gcmVxdWlyZSgnLi9yb3V0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBjb25zdCBjb3JlID0gbmV3IENvcmUob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuU2VydmVyKGNvcmUpO1xufTtcblxuXG5pbnRlcm5hbHMuU2VydmVyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoY29yZSwgbmFtZSwgcGFyZW50KSB7XG5cbiAgICAgICAgdGhpcy5fY29yZSA9IGNvcmU7XG5cbiAgICAgICAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gICAgICAgIHRoaXMuYXBwID0gY29yZS5hcHA7XG4gICAgICAgIHRoaXMuYXV0aCA9IE9iamVjdC5jcmVhdGUodGhpcy5fY29yZS5hdXRoKTtcbiAgICAgICAgdGhpcy5hdXRoLnN0cmF0ZWd5ID0gdGhpcy5hdXRoLl9zdHJhdGVneS5iaW5kKHRoaXMuYXV0aCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBjb3JlLmRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLmNhY2hlID0gaW50ZXJuYWxzLmNhY2hlKHRoaXMpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IGNvcmUuZXZlbnRzO1xuICAgICAgICB0aGlzLmluZm8gPSBjb3JlLmluZm87XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBjb3JlLmxpc3RlbmVyO1xuICAgICAgICB0aGlzLmxvYWQgPSBjb3JlLmhlYXZ5LmxvYWQ7XG4gICAgICAgIHRoaXMubWV0aG9kcyA9IGNvcmUubWV0aG9kcy5tZXRob2RzO1xuICAgICAgICB0aGlzLm1pbWUgPSBjb3JlLm1pbWU7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IGNvcmUucGx1Z2lucztcbiAgICAgICAgdGhpcy5yZWdpc3RyYXRpb25zID0gY29yZS5yZWdpc3RyYXRpb25zO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gY29yZS5zZXR0aW5ncztcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBjb3JlLnN0YXRlcztcbiAgICAgICAgdGhpcy50eXBlID0gY29yZS50eXBlO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBQYWNrYWdlLnZlcnNpb247XG5cbiAgICAgICAgdGhpcy5yZWFsbSA9IHtcbiAgICAgICAgICAgIF9leHRlbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgb25QcmVBdXRoOiBuZXcgRXh0KCdvblByZUF1dGgnLCBjb3JlKSxcbiAgICAgICAgICAgICAgICBvbkNyZWRlbnRpYWxzOiBuZXcgRXh0KCdvbkNyZWRlbnRpYWxzJywgY29yZSksXG4gICAgICAgICAgICAgICAgb25Qb3N0QXV0aDogbmV3IEV4dCgnb25Qb3N0QXV0aCcsIGNvcmUpLFxuICAgICAgICAgICAgICAgIG9uUHJlSGFuZGxlcjogbmV3IEV4dCgnb25QcmVIYW5kbGVyJywgY29yZSksXG4gICAgICAgICAgICAgICAgb25Qb3N0SGFuZGxlcjogbmV3IEV4dCgnb25Qb3N0SGFuZGxlcicsIGNvcmUpLFxuICAgICAgICAgICAgICAgIG9uUHJlUmVzcG9uc2U6IG5ldyBFeHQoJ29uUHJlUmVzcG9uc2UnLCBjb3JlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICAgICAgICAgIHJvdXRlOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcmVudDogKHBhcmVudCA/IHBhcmVudC5yZWFsbSA6IG51bGwpLFxuICAgICAgICAgICAgcGx1Z2luOiBuYW1lLFxuICAgICAgICAgICAgcGx1Z2luT3B0aW9uczoge30sXG4gICAgICAgICAgICBwbHVnaW5zOiB7fSxcbiAgICAgICAgICAgIF9ydWxlczogbnVsbCxcbiAgICAgICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgICAgICAgYmluZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGZpbGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlVG86IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZWNvcmF0aW9uc1xuXG4gICAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGNvcmUuZGVjb3JhdGlvbnMuc2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZF0gPSBjb3JlLl9kZWNvcmF0aW9ucy5zZXJ2ZXJbbWV0aG9kXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvcmUucmVnaXN0ZXJTZXJ2ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgX2Nsb25lKG5hbWUpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5TZXJ2ZXIodGhpcy5fY29yZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgYmluZChjb250ZXh0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnLCAnYmluZCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICB0aGlzLnJlYWxtLnNldHRpbmdzLmJpbmQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIGNvbnRyb2woc2VydmVyKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoc2VydmVyIGluc3RhbmNlb2YgaW50ZXJuYWxzLlNlcnZlciwgJ0NhbiBvbmx5IGNvbnRyb2wgU2VydmVyIG9iamVjdHMnKTtcblxuICAgICAgICB0aGlzLl9jb3JlLmNvbnRyb2xsZWQgPSB0aGlzLl9jb3JlLmNvbnRyb2xsZWQgfHwgW107XG4gICAgICAgIHRoaXMuX2NvcmUuY29udHJvbGxlZC5wdXNoKHNlcnZlcik7XG4gICAgfVxuXG4gICAgZGVjb2RlcihlbmNvZGluZywgZGVjb2Rlcikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLmNvbXByZXNzaW9uLmFkZERlY29kZXIoZW5jb2RpbmcsIGRlY29kZXIpO1xuICAgIH1cblxuICAgIGRlY29yYXRlKHR5cGUsIHByb3BlcnR5LCBtZXRob2QsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMuX2NvcmUuZGVjb3JhdGlvbnNbdHlwZV0sICdVbmtub3duIGRlY29yYXRpb24gdHlwZTonLCB0eXBlKTtcbiAgICAgICAgSG9lay5hc3NlcnQocHJvcGVydHksICdNaXNzaW5nIGRlY29yYXRpb24gcHJvcGVydHkgbmFtZScpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N5bWJvbCcsICdEZWNvcmF0aW9uIHByb3BlcnR5IG11c3QgYmUgYSBzdHJpbmcgb3IgYSBzeW1ib2wnKTtcblxuICAgICAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eS50b1N0cmluZygpO1xuICAgICAgICBIb2VrLmFzc2VydChwcm9wZXJ0eU5hbWVbMF0gIT09ICdfJywgJ1Byb3BlcnR5IG5hbWUgY2Fubm90IGJlZ2luIHdpdGggYW4gdW5kZXJzY29yZTonLCBwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fY29yZS5fZGVjb3JhdGlvbnNbdHlwZV1bcHJvcGVydHldO1xuICAgICAgICBpZiAob3B0aW9ucy5leHRlbmQpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGUgIT09ICdoYW5kbGVyJywgJ0Nhbm5vdCBleHRlbnQgaGFuZGxlciBkZWNvcmF0aW9uOicsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChleGlzdGluZywgYENhbm5vdCBleHRlbmQgbWlzc2luZyAke3R5cGV9IGRlY29yYXRpb246ICR7cHJvcGVydHlOYW1lfWApO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgYEV4dGVuZGVkICR7dHlwZX0gZGVjb3JhdGlvbiBtZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uOiAke3Byb3BlcnR5TmFtZX1gKTtcblxuICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kKGV4aXN0aW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGV4aXN0aW5nID09PSB1bmRlZmluZWQsIGAke3R5cGVbMF0udG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSl9IGRlY29yYXRpb24gYWxyZWFkeSBkZWZpbmVkOiAke3Byb3BlcnR5TmFtZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnaGFuZGxlcicpIHtcblxuICAgICAgICAgICAgLy8gSGFuZGxlclxuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnSGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb246JywgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFtZXRob2QuZGVmYXVsdHMgfHwgdHlwZW9mIG1ldGhvZC5kZWZhdWx0cyA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG1ldGhvZC5kZWZhdWx0cyA9PT0gJ2Z1bmN0aW9uJywgJ0hhbmRsZXIgZGVmYXVsdHMgcHJvcGVydHkgbXVzdCBiZSBhbiBvYmplY3Qgb3IgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLmV4dGVuZCwgJ0Nhbm5vdCBleHRlbmQgaGFuZGxlciBkZWNvcmF0aW9uOicsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3JlcXVlc3QnKSB7XG5cbiAgICAgICAgICAgIC8vIFJlcXVlc3RcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQoUmVxdWVzdC5yZXNlcnZlZC5pbmRleE9mKHByb3BlcnR5KSA9PT0gLTEsICdDYW5ub3Qgb3ZlcnJpZGUgYnVpbHQtaW4gcmVxdWVzdCBpbnRlcmZhY2UgZGVjb3JhdGlvbjonLCBwcm9wZXJ0eU5hbWUpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcHBseSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuX2RlY29yYXRpb25zLnJlcXVlc3RBcHBseSA9IHRoaXMuX2NvcmUuX2RlY29yYXRpb25zLnJlcXVlc3RBcHBseSB8fCB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLl9kZWNvcmF0aW9ucy5yZXF1ZXN0QXBwbHlbcHJvcGVydHldID0gbWV0aG9kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29yZS5SZXF1ZXN0LnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3Rvb2xraXQnKSB7XG5cbiAgICAgICAgICAgIC8vIFRvb2xraXRcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodGhpcy5fY29yZS50b29sa2l0LnJlc2VydmVkLmluZGV4T2YocHJvcGVydHkpID09PSAtMSwgJ0Nhbm5vdCBvdmVycmlkZSBidWlsdC1pbiB0b29sa2l0IGRlY29yYXRpb246JywgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgLy8gU2VydmVyXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW50ZXJuYWxzLlNlcnZlci5wcm90b3R5cGUpLmluZGV4T2YocHJvcGVydHkpID09PSAtMSwgJ0Nhbm5vdCBvdmVycmlkZSB0aGUgYnVpbHQtaW4gc2VydmVyIGludGVyZmFjZSBtZXRob2Q6JywgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaW50ZXJuYWxzLlNlcnZlci5wcm90b3R5cGUpLmluZGV4T2YocHJvcGVydHkpID09PSAtMSwgJ0Nhbm5vdCBvdmVycmlkZSB0aGUgYnVpbHQtaW4gc2VydmVyIGludGVyZmFjZSBtZXRob2Q6JywgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY29yZS5pbnN0YW5jZXMuZm9yRWFjaCgoc2VydmVyKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBzZXJ2ZXJbcHJvcGVydHldID0gbWV0aG9kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb3JlLl9kZWNvcmF0aW9uc1t0eXBlXVtwcm9wZXJ0eV0gPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuX2NvcmUuZGVjb3JhdGlvbnNbdHlwZV0ucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgZGVwZW5kZW5jeShkZXBlbmRlbmNpZXMsIGFmdGVyKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5yZWFsbS5wbHVnaW4sICdDYW5ub3QgY2FsbCBkZXBlbmRlbmN5KCkgb3V0c2lkZSBvZiBhIHBsdWdpbicpO1xuICAgICAgICBIb2VrLmFzc2VydCghYWZ0ZXIgfHwgdHlwZW9mIGFmdGVyID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBhZnRlciBtZXRob2QnKTtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdG8geyBwbHVnaW46IHZlcnNpb24gfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVwZW5kZW5jaWVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0geyBbZGVwZW5kZW5jaWVzXTogJyonIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwZW5kZW5jeSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBtYXBbZGVwZW5kZW5jeV0gPSAnKic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlcGVuZGVuY2llcyA9IG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvcmUuZGVwZW5kZW5jaWVzLnB1c2goeyBwbHVnaW46IHRoaXMucmVhbG0ucGx1Z2luLCBkZXBzOiBkZXBlbmRlbmNpZXMgfSk7XG5cbiAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmV4dCgnb25QcmVTdGFydCcsIGFmdGVyLCB7IGFmdGVyOiBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5jb2RlcihlbmNvZGluZywgZW5jb2Rlcikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLmNvbXByZXNzaW9uLmFkZEVuY29kZXIoZW5jb2RpbmcsIGVuY29kZXIpO1xuICAgIH1cblxuICAgIGV2ZW50KGV2ZW50KSB7XG5cbiAgICAgICAgdGhpcy5fY29yZS5ldmVudHMucmVnaXN0ZXJFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgZXhwb3NlKGtleSwgdmFsdWUpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLnJlYWxtLnBsdWdpbiwgJ0Nhbm5vdCBjYWxsIGV4cG9zZSgpIG91dHNpZGUgb2YgYSBwbHVnaW4nKTtcblxuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLnJlYWxtLnBsdWdpbjtcbiAgICAgICAgdGhpcy5fY29yZS5wbHVnaW5zW3BsdWdpbl0gPSB0aGlzLl9jb3JlLnBsdWdpbnNbcGx1Z2luXSB8fCB7fTtcblxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcmUucGx1Z2luc1twbHVnaW5dW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEhvZWsubWVyZ2UodGhpcy5fY29yZS5wbHVnaW5zW3BsdWdpbl0sIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHQoZXZlbnRzLCBtZXRob2QsIG9wdGlvbnMpIHsgICAgICAgIC8vIChldmVudCwgbWV0aG9kLCBvcHRpb25zKSAtT1ItIChldmVudHMpXG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBldmVudHMgPSB7IHR5cGU6IGV2ZW50cywgbWV0aG9kLCBvcHRpb25zIH07XG4gICAgICAgIH1cblxuICAgICAgICBldmVudHMgPSBDb25maWcuYXBwbHkoJ2V4dHMnLCBldmVudHMpO1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZXh0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9leHQoZXZlbnQpIHtcblxuICAgICAgICBldmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgZXZlbnQucmVhbG0gPSB0aGlzLnJlYWxtO1xuICAgICAgICBjb25zdCB0eXBlID0gZXZlbnQudHlwZTtcblxuICAgICAgICBpZiAoIXRoaXMuX2NvcmUuZXh0ZW5zaW9ucy5zZXJ2ZXJbdHlwZV0pIHtcblxuICAgICAgICAgICAgLy8gUmVhbG0gcm91dGUgZXh0ZW5zaW9uc1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQub3B0aW9ucy5zYW5kYm94ID09PSAncGx1Z2luJykge1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMucmVhbG0uX2V4dGVuc2lvbnNbdHlwZV0sICdVbmtub3duIGV2ZW50IHR5cGUnLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFsbS5fZXh0ZW5zaW9uc1t0eXBlXS5hZGQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb25uZWN0aW9uIHJvdXRlIGV4dGVuc2lvbnNcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodGhpcy5fY29yZS5leHRlbnNpb25zLnJvdXRlW3R5cGVdLCAnVW5rbm93biBldmVudCB0eXBlJywgdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5leHRlbnNpb25zLnJvdXRlW3R5cGVdLmFkZChldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXJ2ZXIgZXh0ZW5zaW9uc1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KCFldmVudC5vcHRpb25zLnNhbmRib3gsICdDYW5ub3Qgc3BlY2lmeSBzYW5kYm94IG9wdGlvbiBmb3Igc2VydmVyIGV4dGVuc2lvbicpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlICE9PSAnb25QcmVTdGFydCcgfHwgdGhpcy5fY29yZS5waGFzZSA9PT0gJ3N0b3BwZWQnLCAnQ2Fubm90IGFkZCBvblByZVN0YXJ0IChhZnRlcikgZXh0ZW5zaW9uIGFmdGVyIHRoZSBzZXJ2ZXIgd2FzIGluaXRpYWxpemVkJyk7XG5cbiAgICAgICAgZXZlbnQuc2VydmVyID0gdGhpcztcbiAgICAgICAgdGhpcy5fY29yZS5leHRlbnNpb25zLnNlcnZlclt0eXBlXS5hZGQoZXZlbnQpO1xuICAgIH1cblxuICAgIGFzeW5jIGluamVjdChvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHNldHRpbmdzID0gb3B0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzID0geyB1cmw6IHNldHRpbmdzIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNldHRpbmdzLmF1dGhvcml0eSB8fFxuICAgICAgICAgICAgc2V0dGluZ3MuYXV0aCB8fFxuICAgICAgICAgICAgc2V0dGluZ3MuYXBwIHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5wbHVnaW5zIHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5hbGxvd0ludGVybmFscyAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAvLyBDYW4gYmUgZmFsc2VcblxuICAgICAgICAgICAgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyk7ICAgICAgICAgLy8gb3B0aW9ucyBjYW4gYmUgcmV1c2VkIChzaGFsbG93IGNsb25lZClcbiAgICAgICAgICAgIGRlbGV0ZSBzZXR0aW5ncy5hdXRoO1xuICAgICAgICAgICAgZGVsZXRlIHNldHRpbmdzLmFwcDtcbiAgICAgICAgICAgIGRlbGV0ZSBzZXR0aW5ncy5wbHVnaW5zO1xuICAgICAgICAgICAgZGVsZXRlIHNldHRpbmdzLmFsbG93SW50ZXJuYWxzO1xuXG4gICAgICAgICAgICBzZXR0aW5ncy5hdXRob3JpdHkgPSBzZXR0aW5ncy5hdXRob3JpdHkgfHwgKHRoaXMuX2NvcmUuaW5mby5ob3N0ICsgJzonICsgdGhpcy5fY29yZS5pbmZvLnBvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuY3JlZGVudGlhbHMsICdvcHRpb25zLmNyZWRlbnRpYWxzIG5vIGxvbmdlciBzdXBwb3J0ZWQgKHVzZSBvcHRpb25zLmF1dGgpJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0aCkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIG9wdGlvbnMuYXV0aCA9PT0gJ29iamVjdCcsICdvcHRpb25zLmF1dGggbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMuYXV0aC5jcmVkZW50aWFscywgJ29wdGlvbnMuYXV0aC5jcmVkZW50aWFscyBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmF1dGguc3RyYXRlZ3ksICdvcHRpb25zLmF1dGguc3RyYXRlZ3kgaXMgbWlzc2luZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmVlZGxlID0gdGhpcy5fY29yZS5fZGlzcGF0Y2goe1xuICAgICAgICAgICAgYXV0aDogb3B0aW9ucy5hdXRoLFxuICAgICAgICAgICAgYWxsb3dJbnRlcm5hbHM6IG9wdGlvbnMuYWxsb3dJbnRlcm5hbHMsXG4gICAgICAgICAgICBhcHA6IG9wdGlvbnMuYXBwLFxuICAgICAgICAgICAgcGx1Z2luczogb3B0aW9ucy5wbHVnaW5zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IFNob3QuaW5qZWN0KG5lZWRsZSwgc2V0dGluZ3MpO1xuICAgICAgICBjb25zdCBjdXN0b20gPSByZXMucmF3LnJlc1tDb25maWcuc3ltYm9sXTtcbiAgICAgICAgaWYgKGN1c3RvbSkge1xuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGN1c3RvbS5yZXN1bHQ7XG4gICAgICAgICAgICByZXMucmVxdWVzdCA9IGN1c3RvbS5yZXF1ZXN0O1xuICAgICAgICAgICAgZGVsZXRlIHJlcy5yYXcucmVzW0NvbmZpZy5zeW1ib2xdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcy5yZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IHJlcy5wYXlsb2FkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBsb2codGFncywgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLmxvZyh0YWdzLCBkYXRhKTtcbiAgICB9XG5cbiAgICBsb29rdXAoaWQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChpZCAmJiB0eXBlb2YgaWQgPT09ICdzdHJpbmcnLCAnSW52YWxpZCByb3V0ZSBpZDonLCBpZCk7XG5cbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fY29yZS5yb3V0ZXIuaWRzW2lkXTtcbiAgICAgICAgaWYgKCFyZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZC5yb3V0ZS5wdWJsaWM7XG4gICAgfVxuXG4gICAgbWF0Y2gobWV0aG9kLCBwYXRoLCBob3N0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQobWV0aG9kICYmIHR5cGVvZiBtZXRob2QgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBtZXRob2Q6JywgbWV0aG9kKTtcbiAgICAgICAgSG9lay5hc3NlcnQocGF0aCAmJiB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgJiYgcGF0aFswXSA9PT0gJy8nLCAnSW52YWxpZCBwYXRoOicsIHBhdGgpO1xuICAgICAgICBIb2VrLmFzc2VydCghaG9zdCB8fCB0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIGhvc3Q6JywgaG9zdCk7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9jb3JlLnJvdXRlci5yb3V0ZShtZXRob2QudG9Mb3dlckNhc2UoKSwgcGF0aCwgaG9zdCk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG1hdGNoICE9PSB0aGlzLl9jb3JlLnJvdXRlci5zcGVjaWFscy5iYWRSZXF1ZXN0LCAnSW52YWxpZCBwYXRoOicsIHBhdGgpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IHRoaXMuX2NvcmUucm91dGVyLnNwZWNpYWxzLm5vdEZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaC5yb3V0ZS5wdWJsaWM7XG4gICAgfVxuXG4gICAgbWV0aG9kKG5hbWUsIG1ldGhvZCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUubWV0aG9kcy5hZGQobmFtZSwgbWV0aG9kLCBvcHRpb25zLCB0aGlzLnJlYWxtKTtcbiAgICB9XG5cbiAgICBwYXRoKHJlbGF0aXZlVG8pIHtcblxuICAgICAgICBIb2VrLmFzc2VydChyZWxhdGl2ZVRvICYmIHR5cGVvZiByZWxhdGl2ZVRvID09PSAnc3RyaW5nJywgJ3JlbGF0aXZlVG8gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgdGhpcy5yZWFsbS5zZXR0aW5ncy5maWxlcy5yZWxhdGl2ZVRvID0gcmVsYXRpdmVUbztcbiAgICB9XG5cbiAgICBhc3luYyByZWdpc3RlcihwbHVnaW5zLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAodGhpcy5yZWFsbS5tb2RpZmllcnMucm91dGUucHJlZml4IHx8XG4gICAgICAgICAgICB0aGlzLnJlYWxtLm1vZGlmaWVycy5yb3V0ZS52aG9zdCkge1xuXG4gICAgICAgICAgICBvcHRpb25zID0gSG9lay5jbG9uZShvcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMucm91dGVzID0gb3B0aW9ucy5yb3V0ZXMgfHwge307XG5cbiAgICAgICAgICAgIG9wdGlvbnMucm91dGVzLnByZWZpeCA9ICh0aGlzLnJlYWxtLm1vZGlmaWVycy5yb3V0ZS5wcmVmaXggfHwgJycpICsgKG9wdGlvbnMucm91dGVzLnByZWZpeCB8fCAnJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXMudmhvc3QgPSB0aGlzLnJlYWxtLm1vZGlmaWVycy5yb3V0ZS52aG9zdCB8fCBvcHRpb25zLnJvdXRlcy52aG9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMgPSBDb25maWcuYXBwbHkoJ3JlZ2lzdGVyJywgb3B0aW9ucyk7XG5cbiAgICAgICAgKyt0aGlzLl9jb3JlLnJlZ2lzdHJpbmc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gW10uY29uY2F0KHBsdWdpbnMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBpdGVtcykge1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgeyByZWdpc3RlciwgLi4uYXR0cmlidXRlcyB9XG4gICAgICAgICAgICAgICAgICAgIHsgcGx1Z2luOiB7IHJlZ2lzdGVyLCAuLi5hdHRyaWJ1dGVzIH0sIG9wdGlvbnMsIG9uY2UsIHJvdXRlcyB9XG4gICAgICAgICAgICAgICAgICAgIHsgcGx1Z2luOiB7IHBsdWdpbjogeyByZWdpc3RlciwgLi4uYXR0cmlidXRlcyB9IH0sIG9wdGlvbnMsIG9uY2UsIHJvdXRlcyB9ICAgICAgLy8gUmVxdWlyZWQgbW9kdWxlXG4gICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIGlmICghaXRlbS5wbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjogaXRlbVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXRlbS5wbHVnaW4ucmVnaXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGl0ZW0ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2U6IGl0ZW0ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlczogaXRlbS5yb3V0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW46IGl0ZW0ucGx1Z2luLnBsdWdpblxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0gT2JqZWN0LmFzc2lnbih7fSwgaXRlbSk7ICAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtID0gQ29uZmlnLmFwcGx5KCdwbHVnaW4nLCBpdGVtKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpdGVtLnBsdWdpbi5uYW1lIHx8IGl0ZW0ucGx1Z2luLnBrZy5uYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gdGhpcy5fY2xvbmUobmFtZSk7XG5cbiAgICAgICAgICAgICAgICBjbG9uZS5yZWFsbS5tb2RpZmllcnMucm91dGUucHJlZml4ID0gaXRlbS5yb3V0ZXMucHJlZml4IHx8IG9wdGlvbnMucm91dGVzLnByZWZpeDtcbiAgICAgICAgICAgICAgICBjbG9uZS5yZWFsbS5tb2RpZmllcnMucm91dGUudmhvc3QgPSBpdGVtLnJvdXRlcy52aG9zdCB8fCBvcHRpb25zLnJvdXRlcy52aG9zdDtcbiAgICAgICAgICAgICAgICBjbG9uZS5yZWFsbS5wbHVnaW5PcHRpb25zID0gaXRlbS5vcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgcmVxdWlyZW1lbnRzXG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlbWVudHMgPSBpdGVtLnBsdWdpbi5yZXF1aXJlbWVudHM7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoIXJlcXVpcmVtZW50cy5ub2RlIHx8IFNvbWV2ZXIubWF0Y2gocHJvY2Vzcy52ZXJzaW9uLCByZXF1aXJlbWVudHMubm9kZSksICdQbHVnaW4nLCBuYW1lLCAncmVxdWlyZXMgbm9kZSB2ZXJzaW9uJywgcmVxdWlyZW1lbnRzLm5vZGUsICdidXQgZm91bmQnLCBwcm9jZXNzLnZlcnNpb24pO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFyZXF1aXJlbWVudHMuaGFwaSB8fCBTb21ldmVyLm1hdGNoKHRoaXMudmVyc2lvbiwgcmVxdWlyZW1lbnRzLmhhcGkpLCAnUGx1Z2luJywgbmFtZSwgJ3JlcXVpcmVzIGhhcGkgdmVyc2lvbicsIHJlcXVpcmVtZW50cy5oYXBpLCAnYnV0IGZvdW5kJywgdGhpcy52ZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCBtdWx0aXBsZSByZWdpc3RyYXRpb25zXG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29yZS5yZWdpc3RyYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnBsdWdpbi5vbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9uY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGl0ZW0ucGx1Z2luLm11bHRpcGxlLCAnUGx1Z2luJywgbmFtZSwgJ2FscmVhZHkgcmVnaXN0ZXJlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29yZS5yZWdpc3RyYXRpb25zW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogaXRlbS5wbHVnaW4udmVyc2lvbiB8fCBpdGVtLnBsdWdpbi5wa2cudmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBpdGVtLm9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wbHVnaW4uZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLmRlcGVuZGVuY3koaXRlbS5wbHVnaW4uZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZWdpc3RlclxuXG4gICAgICAgICAgICAgICAgYXdhaXQgaXRlbS5wbHVnaW4ucmVnaXN0ZXIoY2xvbmUsIGl0ZW0ub3B0aW9ucyB8fCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLS10aGlzLl9jb3JlLnJlZ2lzdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByb3V0ZShvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCByb3V0ZSBvcHRpb25zJyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IFtdLmNvbmNhdChvcHRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLm1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBjb25maWcubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTsgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUm91dGUoc2V0dGluZ3MsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFJvdXRlKGNvbmZpZywgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWRkUm91dGUoY29uZmlnLCBzZXJ2ZXIpIHtcblxuICAgICAgICBjb25zdCByb3V0ZSA9IG5ldyBSb3V0ZShjb25maWcsIHNlcnZlcik7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm8gdXNlIGNvbmZpZyBiZXlvbmQgdGhpcyBwb2ludCwgdXNlIHJvdXRlIG1lbWJlcnNcbiAgICAgICAgY29uc3Qgdmhvc3RzID0gW10uY29uY2F0KHJvdXRlLnNldHRpbmdzLnZob3N0IHx8ICcqJyk7XG5cbiAgICAgICAgZm9yIChjb25zdCB2aG9zdCBvZiB2aG9zdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHRoaXMuX2NvcmUucm91dGVyLmFkZCh7IG1ldGhvZDogcm91dGUubWV0aG9kLCBwYXRoOiByb3V0ZS5wYXRoLCB2aG9zdCwgYW5hbHlzaXM6IHJvdXRlLl9hbmFseXNpcywgaWQ6IHJvdXRlLnNldHRpbmdzLmlkIH0sIHJvdXRlKTtcbiAgICAgICAgICAgIHJvdXRlLmZpbmdlcnByaW50ID0gcmVjb3JkLmZpbmdlcnByaW50O1xuICAgICAgICAgICAgcm91dGUucGFyYW1zID0gcmVjb3JkLnBhcmFtcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ3JvdXRlJywgcm91dGUucHVibGljKTtcbiAgICAgICAgQ29ycy5vcHRpb25zKHJvdXRlLnB1YmxpYywgc2VydmVyKTtcbiAgICB9XG5cbiAgICBydWxlcyhwcm9jZXNzb3IsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KCF0aGlzLnJlYWxtLl9ydWxlcywgJ1NlcnZlciByZWFsbSBydWxlcyBhbHJlYWR5IGRlZmluZWQnKTtcblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IENvbmZpZy5hcHBseSgncnVsZXMnLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnZhbGlkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBzZXR0aW5ncy52YWxpZGF0ZS5zY2hlbWE7XG4gICAgICAgICAgICBzZXR0aW5ncy52YWxpZGF0ZS5zY2hlbWEgPSBKb2kuY29tcGlsZShzY2hlbWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWFsbS5fcnVsZXMgPSB7IHByb2Nlc3Nvciwgc2V0dGluZ3MgfTtcbiAgICB9XG5cbiAgICBzdGF0ZShuYW1lLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5zdGF0ZXMuYWRkKG5hbWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRhYmxlKGhvc3QpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5yb3V0ZXIudGFibGUoaG9zdCk7XG4gICAgfVxuXG4gICAgc3RhcnQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUuX3N0YXJ0KCk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5faW5pdGlhbGl6ZSgpO1xuICAgIH1cblxuICAgIHN0b3Aob3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLl9zdG9wKG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmNhY2hlID0gKHBsdWdpbikgPT4ge1xuXG4gICAgY29uc3QgcG9saWN5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIF9zZWdtZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUuX2NhY2hlUG9saWN5KG9wdGlvbnMsIF9zZWdtZW50LCBwbHVnaW4ucmVhbG0pO1xuICAgIH07XG5cbiAgICBwb2xpY3kucHJvdmlzaW9uID0gYXN5bmMgKG9wdHMpID0+IHtcblxuICAgICAgICBjb25zdCBjbGllbnRzID0gcGx1Z2luLl9jb3JlLl9jcmVhdGVDYWNoZShvcHRzKTtcblxuICAgICAgICAvLyBTdGFydCBjYWNoZVxuXG4gICAgICAgIGlmIChbJ2luaXRpYWxpemVkJywgJ3N0YXJ0aW5nJywgJ3N0YXJ0ZWQnXS5pbmRleE9mKHBsdWdpbi5fY29yZS5waGFzZSkgIT09IC0xKSB7XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjbGllbnRzLm1hcCgoY2xpZW50KSA9PiBjbGllbnQuc3RhcnQoKSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBwb2xpY3k7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUZWFtd29yayA9IHJlcXVpcmUoJ0BoYXBpL3RlYW13b3JrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHRlYW06IFN5bWJvbCgndGVhbScpXG59O1xuXG5cbmV4cG9ydHMuaXNTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG5cbiAgICByZXR1cm4gc3RyZWFtICYmXG4gICAgICAgIHR5cGVvZiBzdHJlYW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR5cGVvZiBzdHJlYW0ucGlwZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuZXhwb3J0cy5kcmFpbiA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcblxuICAgIGNvbnN0IHRlYW0gPSBuZXcgVGVhbXdvcmsoKTtcbiAgICBzdHJlYW1baW50ZXJuYWxzLnRlYW1dID0gdGVhbTtcblxuICAgIHN0cmVhbS5vbigncmVhZGFibGUnLCBpbnRlcm5hbHMucmVhZCk7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGludGVybmFscy5lbmQpO1xuICAgIHN0cmVhbS5vbignZW5kJywgaW50ZXJuYWxzLmVuZCk7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIGludGVybmFscy5lbmQpO1xuXG4gICAgcmV0dXJuIHRlYW0ud29yaztcbn07XG5cblxuaW50ZXJuYWxzLnJlYWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB3aGlsZSAodGhpcy5yZWFkKCkpIHsgfVxufTtcblxuXG5pbnRlcm5hbHMuZW5kID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBpbnRlcm5hbHMucmVhZCk7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpbnRlcm5hbHMuZW5kKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBpbnRlcm5hbHMuZW5kKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGludGVybmFscy5lbmQpO1xuXG4gICAgdGhpc1tpbnRlcm5hbHMudGVhbV0uYXR0ZW5kKCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBSZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcmVzZXJ2ZWQ6IFsnYWJhbmRvbicsICdhdXRoZW50aWNhdGVkJywgJ2Nsb3NlJywgJ2NvbnRleHQnLCAnY29udGludWUnLCAnZW50aXR5JywgJ3JlZGlyZWN0JywgJ3JlYWxtJywgJ3JlcXVlc3QnLCAncmVzcG9uc2UnLCAnc3RhdGUnLCAndW5hdXRoZW50aWNhdGVkJywgJ3Vuc3RhdGUnXVxufTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuTWFuYWdlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuYWJhbmRvbiA9IFN5bWJvbCgnYWJhbmRvbicpO1xuICAgICAgICB0aGlzLmNsb3NlID0gU3ltYm9sKCdjbG9zZScpO1xuICAgICAgICB0aGlzLmNvbnRpbnVlID0gU3ltYm9sKCdjb250aW51ZScpO1xuICAgICAgICB0aGlzLnJlc2VydmVkID0gaW50ZXJuYWxzLnJlc2VydmVkO1xuICAgIH1cblxuICAgIGFzeW5jIGV4ZWN1dGUobWV0aG9kLCByZXF1ZXN0LCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgaCA9IG5ldyBpbnRlcm5hbHMuVG9vbGtpdChyZXF1ZXN0LCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYmluZCA9IG9wdGlvbnMuYmluZCB8fCBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoYmluZCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG1ldGhvZC5jYWxsKGJpbmQsIHJlcXVlc3QsIGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJncykge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBtZXRob2QocmVxdWVzdCwgaCwgLi4ub3B0aW9ucy5hcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG1ldGhvZChyZXF1ZXN0LCBoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGF3YWl0IGludGVybmFscy5NYW5hZ2VyLnRpbWVkKG9wZXJhdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKEJvdW5jZS5pc1N5c3RlbShlcnIpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBCb29tLmJhZEltcGxlbWVudGF0aW9uKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghQm91bmNlLmlzRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignQ2Fubm90IHRocm93IG5vbi1lcnJvciBvYmplY3QnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBCb29tLmJvb21pZnkoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByb2Nlc3MgcmVzcG9uc2VcblxuICAgICAgICBpZiAocmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBCb29tLmJhZEltcGxlbWVudGF0aW9uKGAke21ldGhvZC5uYW1lfSBtZXRob2QgZGlkIG5vdCByZXR1cm4gYSB2YWx1ZSwgYSBwcm9taXNlLCBvciB0aHJvdyBhbiBlcnJvcmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGludWUgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlID09PSB0aGlzLmNvbnRpbnVlKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRpbnVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gJ251bGwnXG5cbiAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmF1dGggJiZcbiAgICAgICAgICAgIHJlc3BvbnNlIGluc3RhbmNlb2YgaW50ZXJuYWxzLkF1dGgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gUmVzcG9uc2Uud3JhcChyZXNwb25zZSwgcmVxdWVzdCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmlzQm9vbSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuX3ByZXBhcmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBmYWlsQWN0aW9uKHJlcXVlc3QsIGZhaWxBY3Rpb24sIGVyciwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJldGFpbiA9IG9wdGlvbnMucmV0YWluID8gZXJyIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZmFpbEFjdGlvbiA9PT0gJ2lnbm9yZScpIHtcbiAgICAgICAgICAgIHJldHVybiByZXRhaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmFpbEFjdGlvbiA9PT0gJ2xvZycpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuX2xvZyhvcHRpb25zLnRhZ3MsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gcmV0YWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZhaWxBY3Rpb24gPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGUoZmFpbEFjdGlvbiwgcmVxdWVzdCwgeyByZWFsbTogcmVxdWVzdC5yb3V0ZS5yZWFsbSwgYXJnczogW29wdGlvbnMuZGV0YWlscyB8fCBlcnJdIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB0aW1lZChtZXRob2QsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoIW9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmVqZWN0KEJvb20uaW50ZXJuYWwoYCR7b3B0aW9ucy5uYW1lfSB0aW1lZCBvdXRgKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGhhbmRsZXIsIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3RpbWVyLCBtZXRob2RdKTtcbiAgICB9XG59O1xuXG5cbi8qXG4gICAgY29uc3QgaGFuZGxlciA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBoKSB7XG5cbiAgICAgICAgcmVzdWx0IC8gaC5yZXNwb25zZShyZXN1bHQpICAgICAgICAgLT4gcmVzdWx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFsbG93ZWQgYmVmb3JlIGhhbmRsZXJcbiAgICAgICAgaC5yZXNwb25zZShyZXN1bHQpLnRha2VvdmVyKCkgICAgICAgLT4gcmVzdWx0IChyZXNwb25kKVxuICAgICAgICBoLmNvbnRpbnVlICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBudWxsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byBudWxsIG9ubHkgaW4gaGFuZGxlciBhbmQgcHJlLCBub3QgYWxsb3dlZCBpbiBhdXRoXG5cbiAgICAgICAgdGhyb3cgZXJyb3IgLyBoLnJlc3BvbnNlKGVycm9yKSAgICAgLT4gZXJyb3IgKHJlc3BvbmQpICAgICAgICAgICAgICAgICAgLy8gZmFpbEFjdGlvbiBvdmVycmlkZSBpbiBwcmVcbiAgICAgICAgPHVuZGVmaW5lZD4gICAgICAgICAgICAgICAgICAgICAgICAgLT4gYmFkSW1wbGVtZW50YXRpb24gKHJlc3BvbmQpXG5cbiAgICAgICAgLy8gQXV0aCBvbmx5IChzY2hlbWUucGF5bG9hZCBhbmQgc2NoZW1lLnJlc3BvbnNlIHVzZSB0aGUgc2FtZSBpbnRlcmZhY2UgYXMgcHJlLWhhbmRsZXIgZXh0ZW5zaW9uIG1ldGhvZHMpXG5cbiAgICAgICAgaC51bmF1dGhlbnRpY2F0ZWQoZXJyb3IsIGRhdGEpICAgICAgLT4gZXJyb3IgKHJlc3BvbmQpICsgZGF0YVxuICAgICAgICBoLmF1dGhlbnRpY2F0ZWQoZGF0YSApICAgICAgICAgICAgICAtPiAoY29udGludWUpICsgZGF0YVxuICAgIH07XG4qL1xuXG5pbnRlcm5hbHMuVG9vbGtpdCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QsIG1hbmFnZXIsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLmFiYW5kb24gPSBtYW5hZ2VyLmFiYW5kb247XG4gICAgICAgIHRoaXMuY2xvc2UgPSBtYW5hZ2VyLmNsb3NlO1xuICAgICAgICB0aGlzLmNvbnRpbnVlID0gbWFuYWdlci5jb250aW51ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gb3B0aW9ucy5iaW5kO1xuICAgICAgICB0aGlzLnJlYWxtID0gb3B0aW9ucy5yZWFsbTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdXRoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSBpbnRlcm5hbHMuYXV0aGVudGljYXRlZDtcbiAgICAgICAgICAgIHRoaXMudW5hdXRoZW50aWNhdGVkID0gaW50ZXJuYWxzLnVuYXV0aGVudGljYXRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHJlcXVlc3QuX2NvcmUuZGVjb3JhdGlvbnMudG9vbGtpdCkge1xuICAgICAgICAgICAgdGhpc1ttZXRob2RdID0gcmVxdWVzdC5fY29yZS5fZGVjb3JhdGlvbnMudG9vbGtpdFttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzcG9uc2UocmVzdWx0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIXJlc3VsdCB8fCB0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVzdWx0LnRoZW4gIT09ICdmdW5jdGlvbicsICdDYW5ub3Qgd3JhcCBhIHByb21pc2UnKTtcbiAgICAgICAgSG9lay5hc3NlcnQocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IgPT09IGZhbHNlLCAnQ2Fubm90IHdyYXAgYW4gZXJyb3InKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHJlc3VsdCAhPT0gJ3N5bWJvbCcsICdDYW5ub3Qgd3JhcCBhIHN5bWJvbCcpO1xuXG4gICAgICAgIHJldHVybiBSZXNwb25zZS53cmFwKHJlc3VsdCwgdGhpcy5yZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZWRpcmVjdChsb2NhdGlvbikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlKCcnKS5yZWRpcmVjdChsb2NhdGlvbik7XG4gICAgfVxuXG4gICAgZW50aXR5KG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLCAnRW50aXR5IG1ldGhvZCBtaXNzaW5nIHJlcXVpcmVkIG9wdGlvbnMnKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5ldGFnIHx8IG9wdGlvbnMubW9kaWZpZWQsICdFbnRpdHkgbWV0aG9kcyBtaXNzaW5nIHJlcXVpcmVkIG9wdGlvbnMga2V5Jyk7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0Ll9lbnRpdHkgPSBvcHRpb25zO1xuXG4gICAgICAgIGNvbnN0IGVudGl0eSA9IFJlc3BvbnNlLmVudGl0eShvcHRpb25zLmV0YWcsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoUmVzcG9uc2UudW5tb2RpZmllZCh0aGlzLnJlcXVlc3QsIGVudGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlKCkuY29kZSgzMDQpLnRha2VvdmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucmVxdWVzdC5fc2V0U3RhdGUobmFtZSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHVuc3RhdGUobmFtZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucmVxdWVzdC5fY2xlYXJTdGF0ZShuYW1lLCBvcHRpb25zKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5hdXRoZW50aWNhdGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgIEhvZWsuYXNzZXJ0KGRhdGEgJiYgZGF0YS5jcmVkZW50aWFscywgJ0F1dGhlbnRpY2F0aW9uIGRhdGEgbWlzc2luZyBjcmVkZW50aWFscyBpbmZvcm1hdGlvbicpO1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQXV0aChudWxsLCBkYXRhKTtcbn07XG5cblxuaW50ZXJuYWxzLnVuYXV0aGVudGljYXRlZCA9IGZ1bmN0aW9uIChlcnJvciwgZGF0YSkge1xuXG4gICAgSG9lay5hc3NlcnQoIWRhdGEgfHwgZGF0YS5jcmVkZW50aWFscywgJ0F1dGhlbnRpY2F0aW9uIGRhdGEgbWlzc2luZyBjcmVkZW50aWFscyBpbmZvcm1hdGlvbicpO1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQXV0aChlcnJvciwgZGF0YSk7XG59O1xuXG5cbmludGVybmFscy5BdXRoID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoZXJyb3IsIGRhdGEpIHtcblxuICAgICAgICB0aGlzLmlzQXV0aCA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIdHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuXG5jb25zdCBBbW1vID0gcmVxdWlyZSgnQGhhcGkvYW1tbycpO1xuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IFNob3QgPSByZXF1aXJlKCdAaGFwaS9zaG90Jyk7XG5jb25zdCBUZWFtd29yayA9IHJlcXVpcmUoJ0BoYXBpL3RlYW13b3JrJyk7XG5cbmNvbnN0IENvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5jb25zdCBSZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNlbmQgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmlzQm9vbSkge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJuYWxzLmZhaWwocmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgaW50ZXJuYWxzLm1hcnNoYWwocmVxdWVzdCk7XG4gICAgICAgIGF3YWl0IGludGVybmFscy50cmFuc21pdChyZXNwb25zZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgIHJlcXVlc3QuX3NldFJlc3BvbnNlKGVycik7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmFpbChyZXF1ZXN0LCBlcnIpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLm1hcnNoYWwgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgZm9yIChjb25zdCBmdW5jIG9mIHJlcXVlc3QuX3JvdXRlLl9tYXJzaGFsQ3ljbGUpIHtcbiAgICAgICAgYXdhaXQgZnVuYyhyZXF1ZXN0KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mYWlsID0gYXN5bmMgZnVuY3Rpb24gKHJlcXVlc3QsIGJvb20pIHtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gaW50ZXJuYWxzLmVycm9yKHJlcXVlc3QsIGJvb20pO1xuICAgIHJlcXVlc3QucmVzcG9uc2UgPSByZXNwb25zZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCB1c2luZyByZXF1ZXN0Ll9zZXRSZXNwb25zZSgpIHRvIGF2b2lkIGRvdWJsZSBsb2dcblxuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGludGVybmFscy5tYXJzaGFsKHJlcXVlc3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuXG4gICAgICAgIC8vIEZhaWxlZCB0byBtYXJzaGFsIGFuIGVycm9yIC0gcmVwbGFjZSB3aXRoIG1pbmltYWwgcmVwcmVzZW50YXRpb24gb2Ygb3JpZ2luYWwgZXJyb3JcblxuICAgICAgICBjb25zdCBtaW5pbWFsID0ge1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgIGVycm9yOiBIdHRwLlNUQVRVU19DT0RFU1tyZXNwb25zZS5zdGF0dXNDb2RlXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGJvb20ubWVzc2FnZVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlc3BvbnNlLl9wYXlsb2FkID0gbmV3IFJlc3BvbnNlLlBheWxvYWQoSlNPTi5zdHJpbmdpZnkobWluaW1hbCksIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnRyYW5zbWl0KHJlc3BvbnNlKTtcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yID0gZnVuY3Rpb24gKHJlcXVlc3QsIGJvb20pIHtcblxuICAgIGNvbnN0IGVycm9yID0gYm9vbS5vdXRwdXQ7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoZXJyb3IucGF5bG9hZCwgcmVxdWVzdCk7XG4gICAgcmVzcG9uc2UuX2Vycm9yID0gYm9vbTtcbiAgICByZXNwb25zZS5jb2RlKGVycm9yLnN0YXR1c0NvZGUpO1xuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBIb2VrLmNsb25lKGVycm9yLmhlYWRlcnMpOyAgICAgICAgICAgICAgIC8vIFByZXZlbnQgc291cmNlIGZyb20gYmVpbmcgbW9kaWZpZWRcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59O1xuXG5cbmludGVybmFscy50cmFuc21pdCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgY29uc3QgcmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3Q7XG4gICAgY29uc3QgbGVuZ3RoID0gaW50ZXJuYWxzLmxlbmd0aChyZXNwb25zZSk7XG5cbiAgICAvLyBQaXBlc1xuXG4gICAgY29uc3QgZW5jb2RpbmcgPSByZXF1ZXN0Ll9jb3JlLmNvbXByZXNzaW9uLmVuY29kaW5nKHJlc3BvbnNlLCBsZW5ndGgpO1xuICAgIGNvbnN0IHJhbmdlciA9IGVuY29kaW5nID8gbnVsbCA6IGludGVybmFscy5yYW5nZShyZXNwb25zZSwgbGVuZ3RoKTtcbiAgICBjb25zdCBjb21wcmVzc29yID0gaW50ZXJuYWxzLmVuY29kaW5nKHJlc3BvbnNlLCBlbmNvZGluZyk7XG5cbiAgICAvLyBDb25uZWN0aW9uOiBjbG9zZVxuXG4gICAgY29uc3QgaXNJbmplY3Rpb24gPSBTaG90LmlzSW5qZWN0aW9uKHJlcXVlc3QucmF3LnJlcSk7XG4gICAgaWYgKCEoaXNJbmplY3Rpb24gfHwgcmVxdWVzdC5fY29yZS5zdGFydGVkKSB8fFxuICAgICAgICByZXF1ZXN0Ll9pc1BheWxvYWRQZW5kaW5nICYmICFyZXF1ZXN0LnJhdy5yZXEuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcblxuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdjb25uZWN0aW9uJywgJ2Nsb3NlJyk7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgaGVhZGVyc1xuXG4gICAgaW50ZXJuYWxzLndyaXRlSGVhZChyZXNwb25zZSk7XG5cbiAgICAvLyBJbmplY3Rpb25cblxuICAgIGlmIChpc0luamVjdGlvbikge1xuICAgICAgICByZXF1ZXN0LnJhdy5yZXNbQ29uZmlnLnN5bWJvbF0gPSB7IHJlcXVlc3QgfTtcblxuICAgICAgICBpZiAocmVzcG9uc2UudmFyaWV0eSA9PT0gJ3BsYWluJykge1xuICAgICAgICAgICAgcmVxdWVzdC5yYXcucmVzW0NvbmZpZy5zeW1ib2xdLnJlc3VsdCA9IHJlc3BvbnNlLl9pc1BheWxvYWRTdXBwb3J0ZWQoKSA/IHJlc3BvbnNlLnNvdXJjZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSByZXNwb25zZSBzdHJlYW1cblxuICAgIGNvbnN0IHN0cmVhbSA9IGludGVybmFscy5jaGFpbihbcmVzcG9uc2UuX3BheWxvYWQsIHJlc3BvbnNlLl90YXAoKSwgY29tcHJlc3NvciwgcmFuZ2VyXSk7XG4gICAgcmV0dXJuIGludGVybmFscy5waXBlKHJlcXVlc3QsIHN0cmVhbSk7XG59O1xuXG5cbmludGVybmFscy5sZW5ndGggPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSByZXNwb25zZS5yZXF1ZXN0O1xuXG4gICAgY29uc3QgaGVhZGVyID0gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxlbmd0aCA9IGhlYWRlcjtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGVuZ3RoID0gcGFyc2VJbnQoaGVhZGVyLCAxMCk7XG4gICAgICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgICAgICAgZGVsZXRlIHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVtcHR5IHJlc3BvbnNlXG5cbiAgICBpZiAobGVuZ3RoID09PSAwICYmXG4gICAgICAgICFyZXNwb25zZS5fc3RhdHVzQ29kZSAmJlxuICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDAgJiZcbiAgICAgICAgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5yZXNwb25zZS5lbXB0eVN0YXR1c0NvZGUgPT09IDIwNCkge1xuXG4gICAgICAgIHJlc3BvbnNlLmNvZGUoMjA0KTtcbiAgICAgICAgZGVsZXRlIHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlbmd0aDtcbn07XG5cblxuaW50ZXJuYWxzLnJhbmdlID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBsZW5ndGgpIHtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSByZXNwb25zZS5yZXF1ZXN0O1xuXG4gICAgaWYgKCFsZW5ndGggfHxcbiAgICAgICAgIXJlcXVlc3Qucm91dGUuc2V0dGluZ3MucmVzcG9uc2UucmFuZ2VzIHx8XG4gICAgICAgIHJlcXVlc3QubWV0aG9kICE9PSAnZ2V0JyB8fFxuICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDApIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXNwb25zZS5faGVhZGVyKCdhY2NlcHQtcmFuZ2VzJywgJ2J5dGVzJyk7XG5cbiAgICBpZiAoIXJlcXVlc3QuaGVhZGVycy5yYW5nZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBJZi1SYW5nZVxuXG4gICAgaWYgKHJlcXVlc3QuaGVhZGVyc1snaWYtcmFuZ2UnXSAmJlxuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ2lmLXJhbmdlJ10gIT09IHJlc3BvbnNlLmhlYWRlcnMuZXRhZykgeyAgICAgICAgICAgIC8vIElnbm9yaW5nIGxhc3QtbW9kaWZpZWQgZGF0ZSAod2VhaylcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBoZWFkZXJcblxuICAgIGNvbnN0IHJhbmdlcyA9IEFtbW8uaGVhZGVyKHJlcXVlc3QuaGVhZGVycy5yYW5nZSwgbGVuZ3RoKTtcbiAgICBpZiAoIXJhbmdlcykge1xuICAgICAgICBjb25zdCBlcnJvciA9IEJvb20ucmFuZ2VOb3RTYXRpc2ZpYWJsZSgpO1xuICAgICAgICBlcnJvci5vdXRwdXQuaGVhZGVyc1snY29udGVudC1yYW5nZSddID0gJ2J5dGVzICovJyArIGxlbmd0aDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSB0cmFuc2Zvcm1cblxuICAgIGlmIChyYW5nZXMubGVuZ3RoICE9PSAxKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSByZXF1ZXN0cyBmb3IgbXVsdGlwbGUgcmFuZ2VzXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzWzBdO1xuICAgIHJlc3BvbnNlLmNvZGUoMjA2KTtcbiAgICByZXNwb25zZS5ieXRlcyhyYW5nZS50byAtIHJhbmdlLmZyb20gKyAxKTtcbiAgICByZXNwb25zZS5faGVhZGVyKCdjb250ZW50LXJhbmdlJywgJ2J5dGVzICcgKyByYW5nZS5mcm9tICsgJy0nICsgcmFuZ2UudG8gKyAnLycgKyBsZW5ndGgpO1xuXG4gICAgcmV0dXJuIG5ldyBBbW1vLlN0cmVhbShyYW5nZSk7XG59O1xuXG5cbmludGVybmFscy5lbmNvZGluZyA9IGZ1bmN0aW9uIChyZXNwb25zZSwgZW5jb2RpbmcpIHtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSByZXNwb25zZS5yZXF1ZXN0O1xuXG4gICAgY29uc3QgaGVhZGVyID0gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddIHx8IGVuY29kaW5nO1xuICAgIGlmIChoZWFkZXIgJiZcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnICYmXG4gICAgICAgIHJlc3BvbnNlLnNldHRpbmdzLnZhcnlFdGFnKSB7XG5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnID0gcmVzcG9uc2UuaGVhZGVycy5ldGFnLnNsaWNlKDAsIC0xKSArICctJyArIGhlYWRlciArICdcIic7XG4gICAgfVxuXG4gICAgaWYgKCFlbmNvZGluZyB8fFxuICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDYgfHxcbiAgICAgICAgIXJlc3BvbnNlLl9pc1BheWxvYWRTdXBwb3J0ZWQoKSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGRlbGV0ZSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2NvbnRlbnQtZW5jb2RpbmcnLCBlbmNvZGluZyk7XG4gICAgY29uc3QgY29tcHJlc3NvciA9IHJlcXVlc3QuX2NvcmUuY29tcHJlc3Npb24uZW5jb2RlcihyZXF1ZXN0LCBlbmNvZGluZyk7XG4gICAgaWYgKHJlc3BvbnNlLnZhcmlldHkgPT09ICdzdHJlYW0nICYmXG4gICAgICAgIHR5cGVvZiByZXNwb25zZS5fcGF5bG9hZC5zZXRDb21wcmVzc29yID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgcmVzcG9uc2UuX3BheWxvYWQuc2V0Q29tcHJlc3Nvcihjb21wcmVzc29yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHJlc3Nvcjtcbn07XG5cblxuaW50ZXJuYWxzLnBpcGUgPSBmdW5jdGlvbiAocmVxdWVzdCwgc3RyZWFtKSB7XG5cbiAgICBjb25zdCB0ZWFtID0gbmV3IFRlYW13b3JrKCk7XG5cbiAgICAvLyBXcml0ZSBwYXlsb2FkXG5cbiAgICBjb25zdCBlbnYgPSB7IHN0cmVhbSwgcmVxdWVzdCwgdGVhbSB9O1xuXG4gICAgY29uc3QgYWJvcnRlZCA9IGludGVybmFscy5lbmQuYmluZChudWxsLCBlbnYsICdhYm9ydGVkJyk7XG4gICAgY29uc3QgY2xvc2UgPSBpbnRlcm5hbHMuZW5kLmJpbmQobnVsbCwgZW52LCAnY2xvc2UnKTtcbiAgICBjb25zdCBlbmQgPSBpbnRlcm5hbHMuZW5kLmJpbmQobnVsbCwgZW52LCBudWxsKTtcblxuICAgIHJlcXVlc3QucmF3LnJlcS5vbignYWJvcnRlZCcsIGFib3J0ZWQpO1xuICAgIHJlcXVlc3QucmF3LnJlcS5vbignY2xvc2UnLCBjbG9zZSk7XG5cbiAgICByZXF1ZXN0LnJhdy5yZXMub24oJ2Nsb3NlJywgY2xvc2UpO1xuICAgIHJlcXVlc3QucmF3LnJlcy5vbignZXJyb3InLCBlbmQpO1xuICAgIHJlcXVlc3QucmF3LnJlcy5vbignZmluaXNoJywgZW5kKTtcblxuICAgIGlmIChzdHJlYW0ud3JpdGVUb1N0cmVhbSkge1xuICAgICAgICBzdHJlYW0ud3JpdGVUb1N0cmVhbShyZXF1ZXN0LnJhdy5yZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIGVuZCk7XG4gICAgICAgIHN0cmVhbS5waXBlKHJlcXVlc3QucmF3LnJlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlYW0ud29yaztcbn07XG5cblxuaW50ZXJuYWxzLmVuZCA9IGZ1bmN0aW9uIChlbnYsIGV2ZW50LCBlcnIpIHtcblxuICAgIGNvbnN0IHsgcmVxdWVzdCwgc3RyZWFtLCB0ZWFtIH0gPSBlbnY7XG5cbiAgICBpZiAoIXRlYW0pIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgaW5zdGVhZCBvZiBjbGVhbmluZyB1cCBlbWl0dGVyIGxpc3RlbmVyc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZW52LnRlYW0gPSBudWxsO1xuXG4gICAgaWYgKHJlcXVlc3QucmF3LnJlcy5maW5pc2hlZCkge1xuICAgICAgICBpZiAoZXZlbnQgIT09ICdhYm9ydGVkJykge1xuICAgICAgICAgICAgcmVxdWVzdC5pbmZvLnJlc3BvbmRlZCA9IERhdGUubm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZWFtLmF0dGVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVycikge1xuICAgICAgICByZXF1ZXN0LnJhdy5yZXMuZGVzdHJveSgpO1xuICAgICAgICBSZXNwb25zZS5kcmFpbihzdHJlYW0pO1xuICAgIH1cblxuICAgIGVyciA9IGVyciB8fCBuZXcgQm9vbShgUmVxdWVzdCAke2V2ZW50fWAsIHsgc3RhdHVzQ29kZTogcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5yZXNwb25zZS5kaXNjb25uZWN0U3RhdHVzQ29kZSB9KTtcbiAgICBjb25zdCBlcnJvciA9IGludGVybmFscy5lcnJvcihyZXF1ZXN0LCBCb29tLmJvb21pZnkoZXJyKSk7XG4gICAgcmVxdWVzdC5fc2V0UmVzcG9uc2UoZXJyb3IpO1xuXG4gICAgaWYgKHJlcXVlc3QucmF3LnJlc1tDb25maWcuc3ltYm9sXSkge1xuICAgICAgICByZXF1ZXN0LnJhdy5yZXMuc3RhdHVzQ29kZSA9IGVycm9yLnN0YXR1c0NvZGU7XG4gICAgICAgIHJlcXVlc3QucmF3LnJlc1tDb25maWcuc3ltYm9sXS5yZXN1bHQgPSBlcnJvci5zb3VyY2U7ICAgICAgIC8vIEZvcmNlIGluamVjdGVkIHJlc3BvbnNlIHRvIGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIHJlcXVlc3QuX2xvZyhbJ3Jlc3BvbnNlJywgJ2Vycm9yJywgZXZlbnRdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcXVlc3QuX2xvZyhbJ3Jlc3BvbnNlJywgJ2Vycm9yJ10sIGVycik7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5yYXcucmVzLmVuZCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJzIGluamVjdGlvbiBwcm9taXNlIHJlc29sdmVcbiAgICB0ZWFtLmF0dGVuZCgpO1xufTtcblxuXG5pbnRlcm5hbHMud3JpdGVIZWFkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBjb25zdCByZXMgPSByZXNwb25zZS5yZXF1ZXN0LnJhdy5yZXM7XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5rZXlzKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgIGxldCBpID0gMDtcblxuICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyBpIDwgaGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzcG9uc2UuaGVhZGVyc1toZWFkZXJdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZm9yICgtLWk7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICByZXMucmVtb3ZlSGVhZGVyKGhlYWRlcnNbaV0pOyAgICAgICAvLyBVbmRvIGhlYWRlcnNcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IEJvb20uYm9vbWlmeShlcnIpO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5zZXR0aW5ncy5tZXNzYWdlKSB7XG4gICAgICAgIHJlcy5zdGF0dXNNZXNzYWdlID0gcmVzcG9uc2Uuc2V0dGluZ3MubWVzc2FnZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXMud3JpdGVIZWFkKHJlc3BvbnNlLnN0YXR1c0NvZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IEJvb20uYm9vbWlmeShlcnIpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmNoYWluID0gZnVuY3Rpb24gKHNvdXJjZXMpIHtcblxuICAgIGxldCBmcm9tID0gc291cmNlc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdG8gPSBzb3VyY2VzW2ldO1xuICAgICAgICBpZiAodG8pIHtcbiAgICAgICAgICAgIGZyb20ub24oJ2Vycm9yJywgaW50ZXJuYWxzLmVycm9yUGlwZS5iaW5kKGZyb20sIHRvKSk7XG4gICAgICAgICAgICBmcm9tID0gZnJvbS5waXBlKHRvKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmcm9tO1xufTtcblxuXG5pbnRlcm5hbHMuZXJyb3JQaXBlID0gZnVuY3Rpb24gKHRvLCBlcnIpIHtcblxuICAgIHRvLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcblxuICAgIC8vIGZhbHNlIC0gbm90aGluZyBhbGxvd2VkXG5cbiAgICBpZiAocnVsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIEpvaS5vYmplY3Qoe30pLmFsbG93KG51bGwpO1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSBmdW5jdGlvblxuXG4gICAgaWYgKHR5cGVvZiBydWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIC8vIG51bGwsIHVuZGVmaW5lZCwgdHJ1ZSAtIGFueXRoaW5nIGFsbG93ZWRcblxuICAgIGlmICghcnVsZSB8fCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxzZSB0ZXN0ZWQgYWJvdmVcbiAgICAgICAgcnVsZSA9PT0gdHJ1ZSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHsuLi59IC0gLi4uIGFsbG93ZWRcblxuICAgIGlmICh0eXBlb2YgcnVsZS52YWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gSm9pLmNvbXBpbGUocnVsZSk7XG59O1xuXG5cbmV4cG9ydHMuaGVhZGVycyA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmlucHV0KCdoZWFkZXJzJywgcmVxdWVzdCk7XG59O1xuXG5cbmV4cG9ydHMucGFyYW1zID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuaW5wdXQoJ3BhcmFtcycsIHJlcXVlc3QpO1xufTtcblxuXG5leHBvcnRzLnBheWxvYWQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnZ2V0JyB8fFxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9PT0gJ2hlYWQnKSB7ICAgICAgICAgICAgICAgIC8vIFdoZW4gcm91dGUubWV0aG9kIGlzICcqJ1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmlucHV0KCdwYXlsb2FkJywgcmVxdWVzdCk7XG59O1xuXG5cbmV4cG9ydHMucXVlcnkgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5pbnB1dCgncXVlcnknLCByZXF1ZXN0KTtcbn07XG5cblxuZXhwb3J0cy5zdGF0ZSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmlucHV0KCdzdGF0ZScsIHJlcXVlc3QpO1xufTtcblxuXG5pbnRlcm5hbHMuaW5wdXQgPSBhc3luYyBmdW5jdGlvbiAoc291cmNlLCByZXF1ZXN0KSB7XG5cbiAgICBjb25zdCBsb2NhbE9wdGlvbnMgPSB7XG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgICAgICAgIHBhcmFtczogcmVxdWVzdC5wYXJhbXMsXG4gICAgICAgICAgICBxdWVyeTogcmVxdWVzdC5xdWVyeSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlcXVlc3QucGF5bG9hZCxcbiAgICAgICAgICAgIHN0YXRlOiByZXF1ZXN0LnN0YXRlLFxuICAgICAgICAgICAgYXV0aDogcmVxdWVzdC5hdXRoLFxuICAgICAgICAgICAgYXBwOiB7XG4gICAgICAgICAgICAgICAgcm91dGU6IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuYXBwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QuYXBwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVsZXRlIGxvY2FsT3B0aW9ucy5jb250ZXh0W3NvdXJjZV07XG4gICAgSG9lay5tZXJnZShsb2NhbE9wdGlvbnMsIHJlcXVlc3Qucm91dGUuc2V0dGluZ3MudmFsaWRhdGUub3B0aW9ucyk7XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnZhbGlkYXRlW3NvdXJjZV07XG4gICAgICAgIGNvbnN0IGJpbmQgPSByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmJpbmQ7XG5cbiAgICAgICAgdmFyIHZhbHVlID0gYXdhaXQgKHR5cGVvZiBzY2hlbWEgIT09ICdmdW5jdGlvbicgPyBpbnRlcm5hbHMudmFsaWRhdGUocmVxdWVzdFtzb3VyY2VdLCBzY2hlbWEsIGxvY2FsT3B0aW9ucykgOiBzY2hlbWEuY2FsbChiaW5kLCByZXF1ZXN0W3NvdXJjZV0sIGxvY2FsT3B0aW9ucykpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdmFyIHZhbGlkYXRpb25FcnJvciA9IGVycjtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHJlcXVlc3Qub3JpZ1tzb3VyY2VdID0gcmVxdWVzdFtzb3VyY2VdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVxdWVzdFtzb3VyY2VdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy52YWxpZGF0ZS5mYWlsQWN0aW9uID09PSAnaWdub3JlJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSBlcnJvclxuXG4gICAgY29uc3QgZGVmYXVsdEVycm9yID0gdmFsaWRhdGlvbkVycm9yLmlzQm9vbSA/IHZhbGlkYXRpb25FcnJvciA6IEJvb20uYmFkUmVxdWVzdChgSW52YWxpZCByZXF1ZXN0ICR7c291cmNlfSBpbnB1dGApO1xuICAgIGNvbnN0IGRldGFpbGVkRXJyb3IgPSBCb29tLmJvb21pZnkodmFsaWRhdGlvbkVycm9yLCB7IHN0YXR1c0NvZGU6IDQwMCwgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIGRldGFpbGVkRXJyb3Iub3V0cHV0LnBheWxvYWQudmFsaWRhdGlvbiA9IHsgc291cmNlLCBrZXlzOiBbXSB9O1xuICAgIGlmICh2YWxpZGF0aW9uRXJyb3IuZGV0YWlscykge1xuICAgICAgICBmb3IgKGNvbnN0IGRldGFpbHMgb2YgdmFsaWRhdGlvbkVycm9yLmRldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBkZXRhaWxzLnBhdGg7XG4gICAgICAgICAgICBkZXRhaWxlZEVycm9yLm91dHB1dC5wYXlsb2FkLnZhbGlkYXRpb24ua2V5cy5wdXNoKEhvZWsuZXNjYXBlSHRtbChwYXRoLmpvaW4oJy4nKSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Qucm91dGUuc2V0dGluZ3MudmFsaWRhdGUuZXJyb3JGaWVsZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnZhbGlkYXRlLmVycm9yRmllbGRzKSB7XG4gICAgICAgICAgICBkZXRhaWxlZEVycm9yLm91dHB1dC5wYXlsb2FkW2ZpZWxkXSA9IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MudmFsaWRhdGUuZXJyb3JGaWVsZHNbZmllbGRdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcXVlc3QuX2NvcmUudG9vbGtpdC5mYWlsQWN0aW9uKHJlcXVlc3QsIHJlcXVlc3Qucm91dGUuc2V0dGluZ3MudmFsaWRhdGUuZmFpbEFjdGlvbiwgZGVmYXVsdEVycm9yLCB7IGRldGFpbHM6IGRldGFpbGVkRXJyb3IsIHRhZ3M6IFsndmFsaWRhdGlvbicsICdlcnJvcicsIHNvdXJjZV0gfSk7XG59O1xuXG5cbmV4cG9ydHMucmVzcG9uc2UgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgaWYgKHJlcXVlc3Qucm91dGUuc2V0dGluZ3MucmVzcG9uc2Uuc2FtcGxlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTYW1wbGUgPSBNYXRoLmNlaWwoKE1hdGgucmFuZG9tKCkgKiAxMDApKTtcbiAgICAgICAgaWYgKGN1cnJlbnRTYW1wbGUgPiByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLnNhbXBsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSByZXNwb25zZS5pc0Jvb20gPyByZXNwb25zZS5vdXRwdXQuc3RhdHVzQ29kZSA6IHJlc3BvbnNlLnN0YXR1c0NvZGU7XG5cbiAgICBjb25zdCBzdGF0dXNTY2hlbWEgPSByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLnN0YXR1c1tzdGF0dXNDb2RlXTtcbiAgICBpZiAoc3RhdHVzQ29kZSA+PSA0MDAgJiZcbiAgICAgICAgIXN0YXR1c1NjaGVtYSkge1xuXG4gICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAgIC8vIERvIG5vdCB2YWxpZGF0ZSBlcnJvcnMgYnkgZGVmYXVsdFxuICAgIH1cblxuICAgIGNvbnN0IHNjaGVtYSA9IHN0YXR1c1NjaGVtYSAhPT0gdW5kZWZpbmVkID8gc3RhdHVzU2NoZW1hIDogcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5yZXNwb25zZS5zY2hlbWE7XG4gICAgaWYgKHNjaGVtYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47ICAgICAgICAgICAgICAgICAvLyBObyBydWxlc1xuICAgIH1cblxuICAgIGlmICghcmVzcG9uc2UuaXNCb29tICYmXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2UudmFyaWV0eSAhPT0gJ3BsYWluJykge1xuXG4gICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0Nhbm5vdCB2YWxpZGF0ZSBub24tb2JqZWN0IHJlc3BvbnNlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxPcHRpb25zID0ge1xuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgICAgICBwYXJhbXM6IHJlcXVlc3QucGFyYW1zLFxuICAgICAgICAgICAgcXVlcnk6IHJlcXVlc3QucXVlcnksXG4gICAgICAgICAgICBwYXlsb2FkOiByZXF1ZXN0LnBheWxvYWQsXG4gICAgICAgICAgICBzdGF0ZTogcmVxdWVzdC5zdGF0ZSxcbiAgICAgICAgICAgIGF1dGg6IHJlcXVlc3QuYXV0aCxcbiAgICAgICAgICAgIGFwcDoge1xuICAgICAgICAgICAgICAgIHJvdXRlOiByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmFwcCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LmFwcFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNvdXJjZSA9IHJlc3BvbnNlLmlzQm9vbSA/IHJlc3BvbnNlLm91dHB1dC5wYXlsb2FkIDogcmVzcG9uc2Uuc291cmNlO1xuICAgIEhvZWsubWVyZ2UobG9jYWxPcHRpb25zLCByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLm9wdGlvbnMpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHZhbHVlO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGF3YWl0IGludGVybmFscy52YWxpZGF0ZShzb3VyY2UsIHNjaGVtYSwgbG9jYWxPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXdhaXQgc2NoZW1hKHNvdXJjZSwgbG9jYWxPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLm1vZGlmeSkge1xuXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuaXNCb29tKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub3V0cHV0LnBheWxvYWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNvdXJjZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcblxuICAgICAgICByZXR1cm4gcmVxdWVzdC5fY29yZS50b29sa2l0LmZhaWxBY3Rpb24ocmVxdWVzdCwgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5yZXNwb25zZS5mYWlsQWN0aW9uLCBlcnIsIHsgdGFnczogWyd2YWxpZGF0aW9uJywgJ3Jlc3BvbnNlJywgJ2Vycm9yJ10gfSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEudmFsaWRhdGVBc3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gc2NoZW1hLnZhbGlkYXRlQXN5bmModmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChKb2ksIGNvbmZpZykge1xuXG4gICAgaWYgKGNvbmZpZyAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZyAhPT0gbnVsbCAmJiB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIGlmIChjb25maWcuaXNKb2kpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gSm9pLmFsdGVybmF0aXZlcygpLnRyeShjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIEpvaS5zdHJpbmcoKS5yZWdleChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBKb2kuZGF0ZSgpLnZhbGlkKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSm9pLm9iamVjdCgpLmtleXMoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIEpvaS5zdHJpbmcoKS52YWxpZChjb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gSm9pLm51bWJlcigpLnZhbGlkKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gSm9pLmJvb2xlYW4oKS52YWxpZChjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChSZWYuaXNSZWYoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gSm9pLnZhbGlkKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgSG9lay5hc3NlcnQoY29uZmlnID09PSBudWxsLCAnSW52YWxpZCBzY2hlbWEgY29udGVudDonLCBjb25maWcpO1xuXG4gICAgcmV0dXJuIEpvaS52YWxpZChudWxsKTtcbn07XG5cblxuZXhwb3J0cy5yZWYgPSBmdW5jdGlvbiAoaWQpIHtcblxuICAgIHJldHVybiBSZWYuaXNSZWYoaWQpID8gaWQgOiBSZWYuY3JlYXRlKGlkKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IExhbmd1YWdlID0gcmVxdWlyZSgnLi9sYW5ndWFnZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBhbm5vdGF0aW9uczogU3ltYm9sKCdqb2ktYW5ub3RhdGlvbnMnKVxufTtcblxuXG5pbnRlcm5hbHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCB3cmFwQXJyYXlzKSB7XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBleHBvcnRzLkVyciB8fCB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBwYXJ0aWFsID0gJyc7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsID0gcGFydGlhbCArIChwYXJ0aWFsLmxlbmd0aCA/ICcsICcgOiAnJykgKyBpbnRlcm5hbHMuc3RyaW5naWZ5KHZhbHVlW2ldLCB3cmFwQXJyYXlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHdyYXBBcnJheXMgPyAnWycgKyBwYXJ0aWFsICsgJ10nIDogcGFydGlhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59O1xuXG5cbmV4cG9ydHMuRXJyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodHlwZSwgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMsIGZsYWdzLCBtZXNzYWdlLCB0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHRoaXMuaXNKb2kgPSB0cnVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHt9O1xuICAgICAgICB0aGlzLmNvbnRleHQua2V5ID0gc3RhdGUucGF0aFtzdGF0ZS5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmNvbnRleHQubGFiZWwgPSBzdGF0ZS5rZXk7XG4gICAgICAgIHRoaXMucGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IHRoaXMub3B0aW9ucy5sYW5ndWFnZTtcblxuICAgICAgICBpZiAodGhpcy5mbGFncy5sYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmxhYmVsID0gdGhpcy5mbGFncy5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb2NhbGl6ZWQgJiYgICAgICAgICAgICAgICAgICAgLy8gbGFuZ3VhZ2UgY2FuIGJlIG51bGwgZm9yIGFycmF5cyBleGNsdXNpb24gY2hlY2tcbiAgICAgICAgICAgICh0aGlzLmNvbnRleHQubGFiZWwgPT09ICcnIHx8XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWwgPT09IG51bGwpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWwgPSBsb2NhbGl6ZWQucm9vdCB8fCBMYW5ndWFnZS5lcnJvcnMucm9vdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZm9ybWF0O1xuXG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5vcHRpb25zLmxhbmd1YWdlO1xuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCBIb2VrLnJlYWNoKGxvY2FsaXplZCwgdGhpcy50eXBlKSB8fCBIb2VrLnJlYWNoKExhbmd1YWdlLmVycm9ycywgdGhpcy50eXBlKTtcblxuICAgICAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgY29kZSBcIiR7dGhpcy50eXBlfVwiIGlzIG5vdCBkZWZpbmVkLCB5b3VyIGN1c3RvbSB0eXBlIGlzIG1pc3NpbmcgdGhlIGNvcnJlY3QgbGFuZ3VhZ2UgZGVmaW5pdGlvbmA7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgd3JhcEFycmF5cyA9IEhvZWsucmVhY2gobG9jYWxpemVkLCAnbWVzc2FnZXMud3JhcEFycmF5cycpO1xuICAgICAgICBpZiAodHlwZW9mIHdyYXBBcnJheXMgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd3JhcEFycmF5cyA9IExhbmd1YWdlLmVycm9ycy5tZXNzYWdlcy53cmFwQXJyYXlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5TdHJpbmcgPSBpbnRlcm5hbHMuc3RyaW5naWZ5KHRoaXMuY29udGV4dC5yZWFzb24sIHdyYXBBcnJheXMpO1xuICAgICAgICAgICAgaWYgKHdyYXBBcnJheXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5TdHJpbmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYXNLZXkgPSAve3shP2xhYmVsfX0vLnRlc3QoZm9ybWF0KTtcbiAgICAgICAgY29uc3Qgc2tpcEtleSA9IGZvcm1hdC5sZW5ndGggPiAyICYmIGZvcm1hdFswXSA9PT0gJyEnICYmIGZvcm1hdFsxXSA9PT0gJyEnO1xuXG4gICAgICAgIGlmIChza2lwS2V5KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhc0tleSAmJiAhc2tpcEtleSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkS2V5ID0gSG9lay5yZWFjaChsb2NhbGl6ZWQsICdrZXknKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxpemVkS2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsaXplZEtleSArIGZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IEhvZWsucmVhY2goTGFuZ3VhZ2UuZXJyb3JzLCAna2V5JykgKyBmb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gIGZvcm1hdC5yZXBsYWNlKC97eyghPykoW159XSspfX0vZywgKCQwLCBpc1NlY3VyZSwgbmFtZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEhvZWsucmVhY2godGhpcy5jb250ZXh0LCBuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpbnRlcm5hbHMuc3RyaW5naWZ5KHZhbHVlLCB3cmFwQXJyYXlzKTtcbiAgICAgICAgICAgIHJldHVybiAoaXNTZWN1cmUgJiYgdGhpcy5vcHRpb25zLmVzY2FwZUh0bWwgPyBIb2VrLmVzY2FwZUh0bWwobm9ybWFsaXplZCkgOiBub3JtYWxpemVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy50b1N0cmluZyA9ICgpID0+IG1lc3NhZ2U7ICAvLyBQZXJzaXN0IHJlc3VsdCBvZiBsYXN0IHRvU3RyaW5nIGNhbGwsIGl0IHdvbid0IGNoYW5nZVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxufTtcblxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uICh0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZmxhZ3MsIG1lc3NhZ2UsIHRlbXBsYXRlKSB7XG5cbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuRXJyKHR5cGUsIGNvbnRleHQsIHN0YXRlLCBvcHRpb25zLCBmbGFncywgbWVzc2FnZSwgdGVtcGxhdGUpO1xufTtcblxuXG5leHBvcnRzLnByb2Nlc3MgPSBmdW5jdGlvbiAoZXJyb3JzLCBvYmplY3QpIHtcblxuICAgIGlmICghZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCBlcnJvclxuXG4gICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICBjb25zdCBkZXRhaWxzID0gW107XG5cbiAgICBjb25zdCBwcm9jZXNzRXJyb3JzID0gZnVuY3Rpb24gKGxvY2FsRXJyb3JzLCBwYXJlbnQsIG92ZXJyaWRlTWVzc2FnZSkge1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxFcnJvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBsb2NhbEVycm9yc1tpXTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXRlbS5mbGFncy5lcnJvciAmJiB0eXBlb2YgaXRlbS5mbGFncy5lcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5mbGFncy5zZWxmRXJyb3IgfHwgIWl0ZW0uY29udGV4dC5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZmxhZ3MuZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaXRlbU1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtTWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSArIChtZXNzYWdlID8gJy4gJyA6ICcnKSArIGl0ZW1NZXNzYWdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEbyBub3QgcHVzaCBpbnRlcm1lZGlhdGUgZXJyb3JzLCB3ZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gbGVhZnNcblxuICAgICAgICAgICAgaWYgKGl0ZW0uY29udGV4dC5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVycmlkZSA9IHByb2Nlc3NFcnJvcnMoaXRlbS5jb250ZXh0LnJlYXNvbiwgaXRlbS5wYXRoLCBpdGVtLnR5cGUgPT09ICdvdmVycmlkZScgPyBpdGVtLm1lc3NhZ2UgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG92ZXJyaWRlTWVzc2FnZSB8fCBpdGVtTWVzc2FnZSB8fCBpdGVtLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogaXRlbS50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBpdGVtLmNvbnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvdmVycmlkZSA9IHByb2Nlc3NFcnJvcnMoZXJyb3JzKTtcbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGVycm9yLmlzSm9pID0gdHJ1ZTtcbiAgICBlcnJvci5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG4gICAgZXJyb3IuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgZXJyb3IuX29iamVjdCA9IG9iamVjdDtcbiAgICBlcnJvci5hbm5vdGF0ZSA9IGludGVybmFscy5hbm5vdGF0ZTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5cbi8vIEluc3BpcmVkIGJ5IGpzb24tc3RyaW5naWZ5LXNhZmVcblxuaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqLCBzcGFjZXMpIHtcblxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGludGVybmFscy5zZXJpYWxpemVyKCksIHNwYWNlcyk7XG59O1xuXG5cbmludGVybmFscy5zZXJpYWxpemVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG5cbiAgICBjb25zdCBjeWNsZVJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHtcblxuICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+XSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1tDaXJjdWxhciB+LicgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKCcuJykgKyAnXSc7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgIGlmICh+dGhpc1Bvcykge1xuICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXMubGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5c1t0aGlzUG9zXSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGN5Y2xlUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBhbm5vdGF0aW9ucyA9IHZhbHVlW2ludGVybmFscy5hbm5vdGF0aW9uc107XG4gICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5ub3RhdGVkID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFubm90YXRpb25zLmVycm9yc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKGBfJGlkeCRfJHthbm5vdGF0aW9ucy5lcnJvcnNbaV0uc29ydCgpLmpvaW4oJywgJyl9XyRlbmQkX2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFubm90YXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yS2V5cyA9IE9iamVjdC5rZXlzKGFubm90YXRpb25zLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcktleSA9IGVycm9yS2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2Ake2Vycm9yS2V5fV8ka2V5JF8ke2Fubm90YXRpb25zLmVycm9yc1tlcnJvcktleV0uc29ydCgpLmpvaW4oJywgJyl9XyRlbmQkX2BdID0gdmFsdWVbZXJyb3JLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbZXJyb3JLZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ0tleXMgPSBPYmplY3Qua2V5cyhhbm5vdGF0aW9ucy5taXNzaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaXNzaW5nS2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ0tleSA9IG1pc3NpbmdLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYF8kbWlzcyRfJHttaXNzaW5nS2V5fXwke2Fubm90YXRpb25zLm1pc3NpbmdbbWlzc2luZ0tleV19XyRlbmQkX2BdID0gJ19fbWlzc2luZ19fJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHwgdmFsdWUgPT09IC1JbmZpbml0eSB8fCBOdW1iZXIuaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIHZhbHVlLnRvU3RyaW5nKCkgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLmFubm90YXRlID0gZnVuY3Rpb24gKHN0cmlwQ29sb3JDb2Rlcykge1xuXG4gICAgY29uc3QgcmVkRmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzMxbSc7XG4gICAgY29uc3QgcmVkQmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzQxbSc7XG4gICAgY29uc3QgZW5kQ29sb3IgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzBtJztcblxuICAgIGlmICh0eXBlb2YgdGhpcy5fb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzWzBdLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqID0gSG9lay5jbG9uZSh0aGlzLl9vYmplY3QgfHwge30pO1xuXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuZGV0YWlscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyAgICAgICAgLy8gUmV2ZXJzZSBvcmRlciB0byBwcm9jZXNzIGRlZXBlc3QgY2hpbGQgZmlyc3RcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5kZXRhaWxzW2ldO1xuICAgICAgICBjb25zdCBwYXRoID0gZXJyb3IucGF0aDtcbiAgICAgICAgbGV0IHJlZiA9IG9iajtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IDsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBzZWcgPSBwYXRoW2pdO1xuXG4gICAgICAgICAgICBpZiAocmVmLmlzSW1tdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVmID0gcmVmLmNsb25lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gam9pIHNjaGVtYXMgYXJlIG5vdCBjbG9uZWQgYnkgaG9laywgd2UgaGF2ZSB0byB0YWtlIHRoaXMgZXh0cmEgc3RlcFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaiArIDEgPCBwYXRoLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIHJlZltzZWddICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHJlZltzZWddICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgcmVmID0gcmVmW3NlZ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZBbm5vdGF0aW9ucyA9IHJlZltpbnRlcm5hbHMuYW5ub3RhdGlvbnNdID0gcmVmW2ludGVybmFscy5hbm5vdGF0aW9uc10gfHwgeyBlcnJvcnM6IHt9LCBtaXNzaW5nOiB7fSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVmW3NlZ107XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzZWcgfHwgZXJyb3IuY29udGV4dC5sYWJlbDtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gPSByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLm1pc3NpbmdbY2FjaGVLZXldID0gcG9zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVwbGFjZXJzID0ge1xuICAgICAgICBrZXk6IC9fXFwka2V5XFwkXyhbLCBcXGRdKylfXFwkZW5kXFwkX1wiL2csXG4gICAgICAgIG1pc3Npbmc6IC9cIl9cXCRtaXNzXFwkXyhbXnxdKylcXHwoXFxkKylfXFwkZW5kXFwkX1wiOiBcIl9fbWlzc2luZ19fXCIvZyxcbiAgICAgICAgYXJyYXlJbmRleDogL1xccypcIl9cXCRpZHhcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIsP1xcbiguKikvZyxcbiAgICAgICAgc3BlY2lhbHM6IC9cIlxcWyhOYU58U3ltYm9sLip8LT9JbmZpbml0eXxmdW5jdGlvbi4qfFxcKC4qKV1cIi9nXG4gICAgfTtcblxuICAgIGxldCBtZXNzYWdlID0gaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkob2JqLCAyKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMua2V5LCAoJDAsICQxKSA9PiBgXCIgJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMubWlzc2luZywgKCQwLCAkMSwgJDIpID0+IGAke3JlZEJnRXNjYXBlfVwiJHskMX1cIiR7ZW5kQ29sb3J9JHtyZWRGZ0VzY2FwZX0gWyR7JDJ9XTogLS0gbWlzc2luZyAtLSR7ZW5kQ29sb3J9YClcbiAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLmFycmF5SW5kZXgsICgkMCwgJDEsICQyKSA9PiBgXFxuJHskMn0gJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuc3BlY2lhbHMsICgkMCwgJDEpID0+ICQxKTtcblxuICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcbiR7cmVkRmdFc2NhcGV9YDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXRhaWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5bJHtwb3N9XSAke3RoaXMuZGV0YWlsc1tpXS5tZXNzYWdlfWA7XG4gICAgfVxuXG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyBlbmRDb2xvcjtcblxuICAgIHJldHVybiBtZXNzYWdlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi90eXBlcy9hbnknKTtcbmNvbnN0IENhc3QgPSByZXF1aXJlKCcuL2Nhc3QnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBMYXp5ID0gcmVxdWlyZSgnLi90eXBlcy9sYXp5Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBhbHRlcm5hdGl2ZXM6IHJlcXVpcmUoJy4vdHlwZXMvYWx0ZXJuYXRpdmVzJyksXG4gICAgYXJyYXk6IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXknKSxcbiAgICBib29sZWFuOiByZXF1aXJlKCcuL3R5cGVzL2Jvb2xlYW4nKSxcbiAgICBiaW5hcnk6IHJlcXVpcmUoJy4vdHlwZXMvYmluYXJ5JyksXG4gICAgZGF0ZTogcmVxdWlyZSgnLi90eXBlcy9kYXRlJyksXG4gICAgZnVuYzogcmVxdWlyZSgnLi90eXBlcy9mdW5jJyksXG4gICAgbnVtYmVyOiByZXF1aXJlKCcuL3R5cGVzL251bWJlcicpLFxuICAgIG9iamVjdDogcmVxdWlyZSgnLi90eXBlcy9vYmplY3QnKSxcbiAgICBzdHJpbmc6IHJlcXVpcmUoJy4vdHlwZXMvc3RyaW5nJyksXG4gICAgc3ltYm9sOiByZXF1aXJlKCcuL3R5cGVzL3N5bWJvbCcpXG59O1xuXG5cbmludGVybmFscy5jYWxsV2l0aERlZmF1bHRzID0gZnVuY3Rpb24gKHNjaGVtYSwgYXJncykge1xuXG4gICAgSG9lay5hc3NlcnQodGhpcywgJ011c3QgYmUgaW52b2tlZCBvbiBhIEpvaSBpbnN0YW5jZS4nKTtcblxuICAgIGlmICh0aGlzLl9kZWZhdWx0cykge1xuICAgICAgICBzY2hlbWEgPSB0aGlzLl9kZWZhdWx0cyhzY2hlbWEpO1xuICAgIH1cblxuICAgIHNjaGVtYS5fY3VycmVudEpvaSA9IHRoaXM7XG5cbiAgICByZXR1cm4gc2NoZW1hLl9pbml0KC4uLmFyZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMucm9vdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGFueSA9IG5ldyBBbnkoKTtcblxuICAgIGNvbnN0IHJvb3QgPSBhbnkuY2xvbmUoKTtcbiAgICBBbnkucHJvdG90eXBlLl9jdXJyZW50Sm9pID0gcm9vdDtcbiAgICByb290Ll9jdXJyZW50Sm9pID0gcm9vdDtcbiAgICByb290Ll9iaW5kcyA9IG5ldyBTZXQoWydhbnknLCAnYWx0ZXJuYXRpdmVzJywgJ2FsdCcsICdhcnJheScsICdib29sJywgJ2Jvb2xlYW4nLCAnYmluYXJ5JywgJ2RhdGUnLCAnZnVuYycsICdudW1iZXInLCAnb2JqZWN0JywgJ3N0cmluZycsICdzeW1ib2wnLCAndmFsaWRhdGUnLCAnZGVzY3JpYmUnLCAnY29tcGlsZScsICdhc3NlcnQnLCAnYXR0ZW1wdCcsICdsYXp5JywgJ2RlZmF1bHRzJywgJ2V4dGVuZCcsICdhbGxvdycsICd2YWxpZCcsICdvbmx5JywgJ2VxdWFsJywgJ2ludmFsaWQnLCAnZGlzYWxsb3cnLCAnbm90JywgJ3JlcXVpcmVkJywgJ2V4aXN0JywgJ29wdGlvbmFsJywgJ2ZvcmJpZGRlbicsICdzdHJpcCcsICd3aGVuJywgJ2VtcHR5JywgJ2RlZmF1bHQnXSk7XG5cbiAgICByb290LmFueSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuYW55KCkgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzLicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2FsbFdpdGhEZWZhdWx0cy5jYWxsKHRoaXMsIGFueSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuYWx0ZXJuYXRpdmVzID0gcm9vdC5hbHQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2FsbFdpdGhEZWZhdWx0cy5jYWxsKHRoaXMsIGludGVybmFscy5hbHRlcm5hdGl2ZXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmFycmF5ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5hcnJheSgpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuYXJyYXksIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmJvb2xlYW4gPSByb290LmJvb2wgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLmJvb2xlYW4oKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLmJvb2xlYW4sIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmJpbmFyeSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuYmluYXJ5KCkgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzLicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2FsbFdpdGhEZWZhdWx0cy5jYWxsKHRoaXMsIGludGVybmFscy5iaW5hcnksIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmRhdGUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLmRhdGUoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLmRhdGUsIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmZ1bmMgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLmZ1bmMoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLmZ1bmMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290Lm51bWJlciA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kubnVtYmVyKCkgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzLicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2FsbFdpdGhEZWZhdWx0cy5jYWxsKHRoaXMsIGludGVybmFscy5udW1iZXIsIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290Lm9iamVjdCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLm9iamVjdCwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3Quc3RyaW5nID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5zdHJpbmcoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLnN0cmluZywgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3Quc3ltYm9sID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5zeW1ib2woKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLnN5bWJvbCwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QucmVmID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmNyZWF0ZSguLi5hcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5pc1JlZiA9IGZ1bmN0aW9uIChyZWYpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmlzUmVmKHJlZik7XG4gICAgfTtcblxuICAgIHJvb3QudmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIC4uLmFyZ3MgLyosIFtzY2hlbWFdLCBbb3B0aW9uc10sIGNhbGxiYWNrICovKSB7XG5cbiAgICAgICAgY29uc3QgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0eXBlb2YgbGFzdCA9PT0gJ2Z1bmN0aW9uJyA/IGxhc3QgOiBudWxsO1xuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXJncy5sZW5ndGggLSAoY2FsbGJhY2sgPyAxIDogMCk7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFueS52YWxpZGF0ZSh2YWx1ZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvdW50ID09PSAyID8gYXJnc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5jb21waWxlKGFyZ3NbMF0pO1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEuX3ZhbGlkYXRlV2l0aE9wdGlvbnModmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgcm9vdC5kZXNjcmliZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gYXJncy5sZW5ndGggPyB0aGlzLmNvbXBpbGUoYXJnc1swXSkgOiBhbnk7XG4gICAgICAgIHJldHVybiBzY2hlbWEuZGVzY3JpYmUoKTtcbiAgICB9O1xuXG4gICAgcm9vdC5jb21waWxlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQ2FzdC5zY2hlbWEodGhpcywgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGVyci5tZXNzYWdlICsgJygnICsgZXJyLnBhdGggKyAnKSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByb290LmFzc2VydCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgdGhpcy5hdHRlbXB0KHZhbHVlLCBzY2hlbWEsIG1lc3NhZ2UpO1xuICAgIH07XG5cbiAgICByb290LmF0dGVtcHQgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgbWVzc2FnZSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsaWRhdGUodmFsdWUsIHNjaGVtYSk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IuYW5ub3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGVycm9yLmFubm90YXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yLmFubm90YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgJHttZXNzYWdlfSAke2Vycm9yLmFubm90YXRlKCl9YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfTtcblxuICAgIHJvb3QucmVhY2ggPSBmdW5jdGlvbiAoc2NoZW1hLCBwYXRoKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hICYmIHNjaGVtYSBpbnN0YW5jZW9mIEFueSwgJ3lvdSBtdXN0IHByb3ZpZGUgYSBqb2kgc2NoZW1hJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCkgfHwgdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MnKTtcblxuICAgICAgICBjb25zdCByZWFjaCA9IChzb3VyY2VTY2hlbWEsIHNjaGVtYVBhdGgpID0+IHtcblxuICAgICAgICAgICAgaWYgKCFzY2hlbWFQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VTY2hlbWE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gc291cmNlU2NoZW1hLl9pbm5lci5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHNjaGVtYVBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhY2goY2hpbGQuc2NoZW1hLCBzY2hlbWFQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyA/IChwYXRoID8gcGF0aC5zcGxpdCgnLicpIDogW10pIDogcGF0aC5zbGljZSgpO1xuXG4gICAgICAgIHJldHVybiByZWFjaChzY2hlbWEsIHNjaGVtYVBhdGgpO1xuICAgIH07XG5cbiAgICByb290LmxhenkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2FsbFdpdGhEZWZhdWx0cy5jYWxsKHRoaXMsIExhenksIGFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmRlZmF1bHRzID0gZnVuY3Rpb24gKGZuKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nLCAnRGVmYXVsdHMgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgbGV0IGpvaSA9IE9iamVjdC5jcmVhdGUodGhpcy5hbnkoKSk7XG4gICAgICAgIGpvaSA9IGZuKGpvaSk7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoam9pICYmIGpvaSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IsICdkZWZhdWx0cygpIG11c3QgcmV0dXJuIGEgc2NoZW1hJyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihqb2ksIHRoaXMsIGpvaS5jbG9uZSgpKTsgLy8gUmUtYWRkIHRoZSB0eXBlcyBmcm9tIGB0aGlzYCBidXQgYWxzbyBrZWVwIHRoZSBzZXR0aW5ncyBmcm9tIGpvaSdzIHBvdGVudGlhbCBuZXcgZGVmYXVsdHNcblxuICAgICAgICBqb2kuX2RlZmF1bHRzID0gKHNjaGVtYSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLl9kZWZhdWx0cyhzY2hlbWEpO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IsICdkZWZhdWx0cygpIG11c3QgcmV0dXJuIGEgc2NoZW1hJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjaGVtYSA9IGZuKHNjaGVtYSk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChzY2hlbWEgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yLCAnZGVmYXVsdHMoKSBtdXN0IHJldHVybiBhIHNjaGVtYScpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH07XG5cbiAgICByb290LmJpbmQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgY29uc3Qgam9pID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcblxuICAgICAgICBqb2kuX2JpbmRzLmZvckVhY2goKGJpbmQpID0+IHtcblxuICAgICAgICAgICAgam9pW2JpbmRdID0gam9pW2JpbmRdLmJpbmQoam9pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGpvaTtcbiAgICB9O1xuXG4gICAgcm9vdC5leHRlbmQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBIb2VrLmZsYXR0ZW4oYXJncyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KGV4dGVuc2lvbnMubGVuZ3RoID4gMCwgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIGV4dGVuc2lvbicpO1xuXG4gICAgICAgIHRoaXMuYXNzZXJ0KGV4dGVuc2lvbnMsIHJvb3QuZXh0ZW5zaW9uc1NjaGVtYSk7XG5cbiAgICAgICAgY29uc3Qgam9pID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmFueSgpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihqb2ksIHRoaXMpO1xuICAgICAgICBqb2kuX2N1cnJlbnRKb2kgPSBqb2k7XG4gICAgICAgIGpvaS5fYmluZHMgPSBuZXcgU2V0KGpvaS5fYmluZHMpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGV4dGVuc2lvbiA9IGV4dGVuc2lvbnNbaV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGpvaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGV4dGVuc2lvbiwgcm9vdC5leHRlbnNpb25TY2hlbWEpO1xuXG4gICAgICAgICAgICBjb25zdCBiYXNlID0gKGV4dGVuc2lvbi5iYXNlIHx8IHRoaXMuYW55KCkpLmNsb25lKCk7IC8vIENsb25pbmcgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byBvdmVycmlkZSBsYW5ndWFnZSBhZnRlcndhcmRzXG4gICAgICAgICAgICBjb25zdCBjdG9yID0gYmFzZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjbGFzcyBleHRlbmRzIGN0b3IgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvb3AtZnVuY1xuXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5iYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGJhc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHlwZSA9IGV4dGVuc2lvbi5uYW1lO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5sYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhbmcgPSB7XG4gICAgICAgICAgICAgICAgICAgIFtleHRlbnNpb24ubmFtZV06IGV4dGVuc2lvbi5sYW5ndWFnZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuX2xhbmd1YWdlID0gSG9lay5hcHBseVRvRGVmYXVsdHModHlwZS5wcm90b3R5cGUuX2xhbmd1YWdlIHx8IChiYXNlLl9zZXR0aW5ncyAmJiBiYXNlLl9zZXR0aW5ncy5sYW5ndWFnZSkgfHwge30sIGxhbmcpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb24uY29lcmNlKSB7XG4gICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuX2NvZXJjZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3Rvci5wcm90b3R5cGUuX2NvZXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVJldCA9IGN0b3IucHJvdG90eXBlLl9jb2VyY2UuY2FsbCh0aGlzLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJldC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlUmV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gZXh0ZW5zaW9uLmNvZXJjZS5jYWxsKHRoaXMsIHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcnMuRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXQgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLnByZSkge1xuICAgICAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLl9iYXNlID0gZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdG9yLnByb3RvdHlwZS5fYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVJldCA9IGN0b3IucHJvdG90eXBlLl9iYXNlLmNhbGwodGhpcywgdmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VSZXQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2VSZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFzZVJldC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGV4dGVuc2lvbi5wcmUuY2FsbCh0aGlzLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLkVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmV0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogcmV0IH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5ydWxlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZXh0ZW5zaW9uLnJ1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBleHRlbnNpb24ucnVsZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVBcmdzID0gcnVsZS5wYXJhbXMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgKHJ1bGUucGFyYW1zIGluc3RhbmNlb2YgQW55ID8gcnVsZS5wYXJhbXMuX2lubmVyLmNoaWxkcmVuLm1hcCgoaykgPT4gay5rZXkpIDogT2JqZWN0LmtleXMocnVsZS5wYXJhbXMpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVBcmdzID0gcnVsZS5wYXJhbXMgPyBDYXN0LnNjaGVtYSh0aGlzLCBydWxlLnBhcmFtcykgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIHR5cGUucHJvdG90eXBlW3J1bGUubmFtZV0gPSBmdW5jdGlvbiAoLi4uckFyZ3MpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb29wLWZ1bmNcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJBcmdzLmxlbmd0aCA+IHJ1bGVBcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBudW1iZXIgb2YgYXJndW1lbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNSZWYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhcmcgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBydWxlQXJncy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ1tydWxlQXJnc1trXV0gPSByQXJnc1trXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1JlZiAmJiBSZWYuaXNSZWYockFyZ3Nba10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gam9pLmF0dGVtcHQoYXJnLCB2YWxpZGF0ZUFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudmFsaWRhdGUgJiYgIXJ1bGUuc2V0dXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS52YWxpZGF0ZS5jYWxsKHRoaXMsIGFyZywgdmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy5fdGVzdChydWxlLm5hbWUsIGFyZywgdmFsaWRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHJ1bGUuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5zZXR1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NjaGVtYSA9IHJ1bGUuc2V0dXAuY2FsbChzY2hlbWEsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1NjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KG5ld1NjaGVtYSBpbnN0YW5jZW9mIEFueSwgYFNldHVwIG9mIGV4dGVuc2lvbiBKb2kuJHt0aGlzLl90eXBlfSgpLiR7cnVsZS5uYW1lfSgpIG11c3QgcmV0dXJuIHVuZGVmaW5lZCBvciBhIEpvaSBvYmplY3RgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hID0gbmV3U2NoZW1hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS52YWxpZGF0ZS5jYWxsKHRoaXMsIGFyZywgdmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEuX3Rlc3QocnVsZS5uYW1lLCBhcmcsIHZhbGlkYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcnVsZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmRlc2NyaWJlKSB7XG4gICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBjdG9yLnByb3RvdHlwZS5kZXNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uLmRlc2NyaWJlLmNhbGwodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IHR5cGUoKTtcbiAgICAgICAgICAgIGpvaVtleHRlbnNpb24ubmFtZV0gPSBmdW5jdGlvbiAoLi4uZXh0QXJncykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW5zdGFuY2UsIGV4dEFyZ3MpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgam9pLl9iaW5kcy5hZGQoZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpvaTtcbiAgICB9O1xuXG4gICAgcm9vdC5leHRlbnNpb25TY2hlbWEgPSBpbnRlcm5hbHMub2JqZWN0LmtleXMoe1xuICAgICAgICBiYXNlOiBpbnRlcm5hbHMub2JqZWN0LnR5cGUoQW55LCAnSm9pIG9iamVjdCcpLFxuICAgICAgICBuYW1lOiBpbnRlcm5hbHMuc3RyaW5nLnJlcXVpcmVkKCksXG4gICAgICAgIGNvZXJjZTogaW50ZXJuYWxzLmZ1bmMuYXJpdHkoMyksXG4gICAgICAgIHByZTogaW50ZXJuYWxzLmZ1bmMuYXJpdHkoMyksXG4gICAgICAgIGxhbmd1YWdlOiBpbnRlcm5hbHMub2JqZWN0LFxuICAgICAgICBkZXNjcmliZTogaW50ZXJuYWxzLmZ1bmMuYXJpdHkoMSksXG4gICAgICAgIHJ1bGVzOiBpbnRlcm5hbHMuYXJyYXkuaXRlbXMoaW50ZXJuYWxzLm9iamVjdC5rZXlzKHtcbiAgICAgICAgICAgIG5hbWU6IGludGVybmFscy5zdHJpbmcucmVxdWlyZWQoKSxcbiAgICAgICAgICAgIHNldHVwOiBpbnRlcm5hbHMuZnVuYy5hcml0eSgxKSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiBpbnRlcm5hbHMuZnVuYy5hcml0eSg0KSxcbiAgICAgICAgICAgIHBhcmFtczogW1xuICAgICAgICAgICAgICAgIGludGVybmFscy5vYmplY3QucGF0dGVybigvLiovLCBpbnRlcm5hbHMub2JqZWN0LnR5cGUoQW55LCAnSm9pIG9iamVjdCcpKSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHMub2JqZWN0LnR5cGUoaW50ZXJuYWxzLm9iamVjdC5jb25zdHJ1Y3RvciwgJ0pvaSBvYmplY3QnKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBbaW50ZXJuYWxzLnN0cmluZywgaW50ZXJuYWxzLmZ1bmMuYXJpdHkoMSldXG4gICAgICAgIH0pLm9yKCdzZXR1cCcsICd2YWxpZGF0ZScpKVxuICAgIH0pLnN0cmljdCgpO1xuXG4gICAgcm9vdC5leHRlbnNpb25zU2NoZW1hID0gaW50ZXJuYWxzLmFycmF5Lml0ZW1zKFtpbnRlcm5hbHMub2JqZWN0LCBpbnRlcm5hbHMuZnVuYy5hcml0eSgxKV0pLnN0cmljdCgpO1xuXG4gICAgcm9vdC52ZXJzaW9uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcblxuICAgIHJldHVybiByb290O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5yb290KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuZXJyb3JzID0ge1xuICAgIHJvb3Q6ICd2YWx1ZScsXG4gICAga2V5OiAnXCJ7eyFsYWJlbH19XCIgJyxcbiAgICBtZXNzYWdlczoge1xuICAgICAgICB3cmFwQXJyYXlzOiB0cnVlXG4gICAgfSxcbiAgICBhbnk6IHtcbiAgICAgICAgdW5rbm93bjogJ2lzIG5vdCBhbGxvd2VkJyxcbiAgICAgICAgaW52YWxpZDogJ2NvbnRhaW5zIGFuIGludmFsaWQgdmFsdWUnLFxuICAgICAgICBlbXB0eTogJ2lzIG5vdCBhbGxvd2VkIHRvIGJlIGVtcHR5JyxcbiAgICAgICAgcmVxdWlyZWQ6ICdpcyByZXF1aXJlZCcsXG4gICAgICAgIGFsbG93T25seTogJ211c3QgYmUgb25lIG9mIHt7dmFsaWRzfX0nLFxuICAgICAgICBkZWZhdWx0OiAndGhyZXcgYW4gZXJyb3Igd2hlbiBydW5uaW5nIGRlZmF1bHQgbWV0aG9kJ1xuICAgIH0sXG4gICAgYWx0ZXJuYXRpdmVzOiB7XG4gICAgICAgIGJhc2U6ICdub3QgbWF0Y2hpbmcgYW55IG9mIHRoZSBhbGxvd2VkIGFsdGVybmF0aXZlcycsXG4gICAgICAgIGNoaWxkOiBudWxsXG4gICAgfSxcbiAgICBhcnJheToge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhbiBhcnJheScsXG4gICAgICAgIGluY2x1ZGVzOiAnYXQgcG9zaXRpb24ge3twb3N9fSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICBpbmNsdWRlc1NpbmdsZTogJ3NpbmdsZSB2YWx1ZSBvZiBcInt7IWxhYmVsfX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICBpbmNsdWRlc09uZTogJ2F0IHBvc2l0aW9uIHt7cG9zfX0gZmFpbHMgYmVjYXVzZSB7e3JlYXNvbn19JyxcbiAgICAgICAgaW5jbHVkZXNPbmVTaW5nbGU6ICdzaW5nbGUgdmFsdWUgb2YgXCJ7eyFsYWJlbH19XCIgZmFpbHMgYmVjYXVzZSB7e3JlYXNvbn19JyxcbiAgICAgICAgaW5jbHVkZXNSZXF1aXJlZFVua25vd25zOiAnZG9lcyBub3QgY29udGFpbiB7e3Vua25vd25NaXNzZXN9fSByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgIGluY2x1ZGVzUmVxdWlyZWRLbm93bnM6ICdkb2VzIG5vdCBjb250YWluIHt7a25vd25NaXNzZXN9fScsXG4gICAgICAgIGluY2x1ZGVzUmVxdWlyZWRCb3RoOiAnZG9lcyBub3QgY29udGFpbiB7e2tub3duTWlzc2VzfX0gYW5kIHt7dW5rbm93bk1pc3Nlc319IG90aGVyIHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgZXhjbHVkZXM6ICdhdCBwb3NpdGlvbiB7e3Bvc319IGNvbnRhaW5zIGFuIGV4Y2x1ZGVkIHZhbHVlJyxcbiAgICAgICAgZXhjbHVkZXNTaW5nbGU6ICdzaW5nbGUgdmFsdWUgb2YgXCJ7eyFsYWJlbH19XCIgY29udGFpbnMgYW4gZXhjbHVkZWQgdmFsdWUnLFxuICAgICAgICBoYXNLbm93bjogJ2RvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoIGZvciB0eXBlIFwie3shcGF0dGVybkxhYmVsfX1cIicsXG4gICAgICAgIGhhc1Vua25vd246ICdkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBtYXRjaCcsXG4gICAgICAgIG1pbjogJ211c3QgY29udGFpbiBhdCBsZWFzdCB7e2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICBtYXg6ICdtdXN0IGNvbnRhaW4gbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fSBpdGVtcycsXG4gICAgICAgIGxlbmd0aDogJ211c3QgY29udGFpbiB7e2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICBvcmRlcmVkOiAnYXQgcG9zaXRpb24ge3twb3N9fSBmYWlscyBiZWNhdXNlIHt7cmVhc29ufX0nLFxuICAgICAgICBvcmRlcmVkTGVuZ3RoOiAnYXQgcG9zaXRpb24ge3twb3N9fSBmYWlscyBiZWNhdXNlIGFycmF5IG11c3QgY29udGFpbiBhdCBtb3N0IHt7bGltaXR9fSBpdGVtcycsXG4gICAgICAgIHJlZjogJ3JlZmVyZW5jZXMgXCJ7e3JlZn19XCIgd2hpY2ggaXMgbm90IGEgcG9zaXRpdmUgaW50ZWdlcicsXG4gICAgICAgIHNwYXJzZTogJ211c3Qgbm90IGJlIGEgc3BhcnNlIGFycmF5JyxcbiAgICAgICAgdW5pcXVlOiAncG9zaXRpb24ge3twb3N9fSBjb250YWlucyBhIGR1cGxpY2F0ZSB2YWx1ZSdcbiAgICB9LFxuICAgIGJvb2xlYW46IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBib29sZWFuJ1xuICAgIH0sXG4gICAgYmluYXJ5OiB7XG4gICAgICAgIGJhc2U6ICdtdXN0IGJlIGEgYnVmZmVyIG9yIGEgc3RyaW5nJyxcbiAgICAgICAgbWluOiAnbXVzdCBiZSBhdCBsZWFzdCB7e2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICBtYXg6ICdtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7e2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICBsZW5ndGg6ICdtdXN0IGJlIHt7bGltaXR9fSBieXRlcydcbiAgICB9LFxuICAgIGRhdGU6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHZhbGlkIGRhdGUgc3RyaW5nJyxcbiAgICAgICAgc3RyaWN0OiAnbXVzdCBiZSBhIHZhbGlkIGRhdGUnLFxuICAgICAgICBtaW46ICdtdXN0IGJlIGxhcmdlciB0aGFuIG9yIGVxdWFsIHRvIFwie3tsaW1pdH19XCInLFxuICAgICAgICBtYXg6ICdtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBcInt7bGltaXR9fVwiJyxcbiAgICAgICAgbGVzczogJ211c3QgYmUgbGVzcyB0aGFuIFwie3tsaW1pdH19XCInLFxuICAgICAgICBncmVhdGVyOiAnbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJ7e2xpbWl0fX1cIicsXG4gICAgICAgIGlzb0RhdGU6ICdtdXN0IGJlIGEgdmFsaWQgSVNPIDg2MDEgZGF0ZScsXG4gICAgICAgIHRpbWVzdGFtcDoge1xuICAgICAgICAgICAgamF2YXNjcmlwdDogJ211c3QgYmUgYSB2YWxpZCB0aW1lc3RhbXAgb3IgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICB1bml4OiAnbXVzdCBiZSBhIHZhbGlkIHRpbWVzdGFtcCBvciBudW1iZXIgb2Ygc2Vjb25kcydcbiAgICAgICAgfSxcbiAgICAgICAgcmVmOiAncmVmZXJlbmNlcyBcInt7cmVmfX1cIiB3aGljaCBpcyBub3QgYSBkYXRlJ1xuICAgIH0sXG4gICAgZnVuY3Rpb246IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBGdW5jdGlvbicsXG4gICAgICAgIGFyaXR5OiAnbXVzdCBoYXZlIGFuIGFyaXR5IG9mIHt7bn19JyxcbiAgICAgICAgbWluQXJpdHk6ICdtdXN0IGhhdmUgYW4gYXJpdHkgZ3JlYXRlciBvciBlcXVhbCB0byB7e259fScsXG4gICAgICAgIG1heEFyaXR5OiAnbXVzdCBoYXZlIGFuIGFyaXR5IGxlc3NlciBvciBlcXVhbCB0byB7e259fScsXG4gICAgICAgIHJlZjogJ211c3QgYmUgYSBKb2kgcmVmZXJlbmNlJyxcbiAgICAgICAgY2xhc3M6ICdtdXN0IGJlIGEgY2xhc3MnXG4gICAgfSxcbiAgICBsYXp5OiB7XG4gICAgICAgIGJhc2U6ICchIXNjaGVtYSBlcnJvcjogbGF6eSBzY2hlbWEgbXVzdCBiZSBzZXQnLFxuICAgICAgICBzY2hlbWE6ICchIXNjaGVtYSBlcnJvcjogbGF6eSBzY2hlbWEgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSBzY2hlbWEnXG4gICAgfSxcbiAgICBvYmplY3Q6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYW4gb2JqZWN0JyxcbiAgICAgICAgY2hpbGQ6ICchIWNoaWxkIFwie3shY2hpbGR9fVwiIGZhaWxzIGJlY2F1c2Uge3tyZWFzb259fScsXG4gICAgICAgIG1pbjogJ211c3QgaGF2ZSBhdCBsZWFzdCB7e2xpbWl0fX0gY2hpbGRyZW4nLFxuICAgICAgICBtYXg6ICdtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fSBjaGlsZHJlbicsXG4gICAgICAgIGxlbmd0aDogJ211c3QgaGF2ZSB7e2xpbWl0fX0gY2hpbGRyZW4nLFxuICAgICAgICBhbGxvd1Vua25vd246ICchIVwie3shY2hpbGR9fVwiIGlzIG5vdCBhbGxvd2VkJyxcbiAgICAgICAgd2l0aDogJyEhXCJ7e21haW5XaXRoTGFiZWx9fVwiIG1pc3NpbmcgcmVxdWlyZWQgcGVlciBcInt7cGVlcldpdGhMYWJlbH19XCInLFxuICAgICAgICB3aXRob3V0OiAnISFcInt7bWFpbldpdGhMYWJlbH19XCIgY29uZmxpY3Qgd2l0aCBmb3JiaWRkZW4gcGVlciBcInt7cGVlcldpdGhMYWJlbH19XCInLFxuICAgICAgICBtaXNzaW5nOiAnbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB7e3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgeG9yOiAnY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIGV4Y2x1c2l2ZSBwZWVycyB7e3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgb3hvcjogJ2NvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBvcHRpb25hbCBleGNsdXNpdmUgcGVlcnMge3twZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgIGFuZDogJ2NvbnRhaW5zIHt7cHJlc2VudFdpdGhMYWJlbHN9fSB3aXRob3V0IGl0cyByZXF1aXJlZCBwZWVycyB7e21pc3NpbmdXaXRoTGFiZWxzfX0nLFxuICAgICAgICBuYW5kOiAnISFcInt7bWFpbldpdGhMYWJlbH19XCIgbXVzdCBub3QgZXhpc3Qgc2ltdWx0YW5lb3VzbHkgd2l0aCB7e3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgYXNzZXJ0OiAnISFcInt7cmVmfX1cIiB2YWxpZGF0aW9uIGZhaWxlZCBiZWNhdXNlIFwie3tyZWZ9fVwiIGZhaWxlZCB0byB7e21lc3NhZ2V9fScsXG4gICAgICAgIHJlbmFtZToge1xuICAgICAgICAgICAgbXVsdGlwbGU6ICdjYW5ub3QgcmVuYW1lIGNoaWxkIFwie3tmcm9tfX1cIiBiZWNhdXNlIG11bHRpcGxlIHJlbmFtZXMgYXJlIGRpc2FibGVkIGFuZCBhbm90aGVyIGtleSB3YXMgYWxyZWFkeSByZW5hbWVkIHRvIFwie3t0b319XCInLFxuICAgICAgICAgICAgb3ZlcnJpZGU6ICdjYW5ub3QgcmVuYW1lIGNoaWxkIFwie3tmcm9tfX1cIiBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQgXCJ7e3RvfX1cIiBleGlzdHMnLFxuICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICBtdWx0aXBsZTogJ2Nhbm5vdCByZW5hbWUgY2hpbGRyZW4ge3tmcm9tfX0gYmVjYXVzZSBtdWx0aXBsZSByZW5hbWVzIGFyZSBkaXNhYmxlZCBhbmQgYW5vdGhlciBrZXkgd2FzIGFscmVhZHkgcmVuYW1lZCB0byBcInt7dG99fVwiJyxcbiAgICAgICAgICAgICAgICBvdmVycmlkZTogJ2Nhbm5vdCByZW5hbWUgY2hpbGRyZW4ge3tmcm9tfX0gYmVjYXVzZSBvdmVycmlkZSBpcyBkaXNhYmxlZCBhbmQgdGFyZ2V0IFwie3t0b319XCIgZXhpc3RzJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAnbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBcInt7dHlwZX19XCInLFxuICAgICAgICBzY2hlbWE6ICdtdXN0IGJlIGEgSm9pIGluc3RhbmNlJ1xuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICAgIGJhc2U6ICdtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgICAgdW5zYWZlOiAnbXVzdCBiZSBhIHNhZmUgbnVtYmVyJyxcbiAgICAgICAgbWluOiAnbXVzdCBiZSBsYXJnZXIgdGhhbiBvciBlcXVhbCB0byB7e2xpbWl0fX0nLFxuICAgICAgICBtYXg6ICdtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7e2xpbWl0fX0nLFxuICAgICAgICBsZXNzOiAnbXVzdCBiZSBsZXNzIHRoYW4ge3tsaW1pdH19JyxcbiAgICAgICAgZ3JlYXRlcjogJ211c3QgYmUgZ3JlYXRlciB0aGFuIHt7bGltaXR9fScsXG4gICAgICAgIGludGVnZXI6ICdtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgICBuZWdhdGl2ZTogJ211c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICAgICAgICBwb3NpdGl2ZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInLFxuICAgICAgICBwcmVjaXNpb246ICdtdXN0IGhhdmUgbm8gbW9yZSB0aGFuIHt7bGltaXR9fSBkZWNpbWFsIHBsYWNlcycsXG4gICAgICAgIHJlZjogJ3JlZmVyZW5jZXMgXCJ7e3JlZn19XCIgd2hpY2ggaXMgbm90IGEgbnVtYmVyJyxcbiAgICAgICAgbXVsdGlwbGU6ICdtdXN0IGJlIGEgbXVsdGlwbGUgb2Yge3ttdWx0aXBsZX19JyxcbiAgICAgICAgcG9ydDogJ211c3QgYmUgYSB2YWxpZCBwb3J0J1xuICAgIH0sXG4gICAgc3RyaW5nOiB7XG4gICAgICAgIGJhc2U6ICdtdXN0IGJlIGEgc3RyaW5nJyxcbiAgICAgICAgbWluOiAnbGVuZ3RoIG11c3QgYmUgYXQgbGVhc3Qge3tsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgIG1heDogJ2xlbmd0aCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7e2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgbGVuZ3RoOiAnbGVuZ3RoIG11c3QgYmUge3tsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgIGFscGhhbnVtOiAnbXVzdCBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzJyxcbiAgICAgICAgdG9rZW46ICdtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGFuZCB1bmRlcnNjb3JlIGNoYXJhY3RlcnMnLFxuICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgYmFzZTogJ3dpdGggdmFsdWUgXCJ7eyF2YWx1ZX19XCIgZmFpbHMgdG8gbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm46IHt7cGF0dGVybn19JyxcbiAgICAgICAgICAgIG5hbWU6ICd3aXRoIHZhbHVlIFwie3shdmFsdWV9fVwiIGZhaWxzIHRvIG1hdGNoIHRoZSB7e25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgICAgIGludmVydDoge1xuICAgICAgICAgICAgICAgIGJhc2U6ICd3aXRoIHZhbHVlIFwie3shdmFsdWV9fVwiIG1hdGNoZXMgdGhlIGludmVydGVkIHBhdHRlcm46IHt7cGF0dGVybn19JyxcbiAgICAgICAgICAgICAgICBuYW1lOiAnd2l0aCB2YWx1ZSBcInt7IXZhbHVlfX1cIiBtYXRjaGVzIHRoZSBpbnZlcnRlZCB7e25hbWV9fSBwYXR0ZXJuJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbWFpbDogJ211c3QgYmUgYSB2YWxpZCBlbWFpbCcsXG4gICAgICAgIHVyaTogJ211c3QgYmUgYSB2YWxpZCB1cmknLFxuICAgICAgICB1cmlSZWxhdGl2ZU9ubHk6ICdtdXN0IGJlIGEgdmFsaWQgcmVsYXRpdmUgdXJpJyxcbiAgICAgICAgdXJpQ3VzdG9tU2NoZW1lOiAnbXVzdCBiZSBhIHZhbGlkIHVyaSB3aXRoIGEgc2NoZW1lIG1hdGNoaW5nIHRoZSB7e3NjaGVtZX19IHBhdHRlcm4nLFxuICAgICAgICBpc29EYXRlOiAnbXVzdCBiZSBhIHZhbGlkIElTTyA4NjAxIGRhdGUnLFxuICAgICAgICBndWlkOiAnbXVzdCBiZSBhIHZhbGlkIEdVSUQnLFxuICAgICAgICBoZXg6ICdtdXN0IG9ubHkgY29udGFpbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzJyxcbiAgICAgICAgaGV4QWxpZ246ICdoZXggZGVjb2RlZCByZXByZXNlbnRhdGlvbiBtdXN0IGJlIGJ5dGUgYWxpZ25lZCcsXG4gICAgICAgIGJhc2U2NDogJ211c3QgYmUgYSB2YWxpZCBiYXNlNjQgc3RyaW5nJyxcbiAgICAgICAgZGF0YVVyaTogJ211c3QgYmUgYSB2YWxpZCBkYXRhVXJpIHN0cmluZycsXG4gICAgICAgIGhvc3RuYW1lOiAnbXVzdCBiZSBhIHZhbGlkIGhvc3RuYW1lJyxcbiAgICAgICAgbm9ybWFsaXplOiAnbXVzdCBiZSB1bmljb2RlIG5vcm1hbGl6ZWQgaW4gdGhlIHt7Zm9ybX19IGZvcm0nLFxuICAgICAgICBsb3dlcmNhc2U6ICdtdXN0IG9ubHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycycsXG4gICAgICAgIHVwcGVyY2FzZTogJ211c3Qgb25seSBjb250YWluIHVwcGVyY2FzZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgdHJpbTogJ211c3Qgbm90IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlJyxcbiAgICAgICAgY3JlZGl0Q2FyZDogJ211c3QgYmUgYSBjcmVkaXQgY2FyZCcsXG4gICAgICAgIHJlZjogJ3JlZmVyZW5jZXMgXCJ7e3JlZn19XCIgd2hpY2ggaXMgbm90IGEgbnVtYmVyJyxcbiAgICAgICAgaXA6ICdtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyB3aXRoIGEge3tjaWRyfX0gQ0lEUicsXG4gICAgICAgIGlwVmVyc2lvbjogJ211c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzIG9mIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZlcnNpb25zIHt7dmVyc2lvbn19IHdpdGggYSB7e2NpZHJ9fSBDSURSJ1xuICAgIH0sXG4gICAgc3ltYm9sOiB7XG4gICAgICAgIGJhc2U6ICdtdXN0IGJlIGEgc3ltYm9sJyxcbiAgICAgICAgbWFwOiAnbXVzdCBiZSBvbmUgb2Yge3ttYXB9fSdcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3B0aW9ucykge1xuXG4gICAgSG9lay5hc3NlcnQodHlwZW9mIGtleSA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHJlZmVyZW5jZSBrZXk6Jywga2V5KTtcblxuICAgIGNvbnN0IHNldHRpbmdzID0gSG9lay5jbG9uZShvcHRpb25zKTsgICAgICAgICAvLyBvcHRpb25zIGNhbiBiZSByZXVzZWQgYW5kIG1vZGlmaWVkXG5cbiAgICBjb25zdCByZWYgPSBmdW5jdGlvbiAodmFsdWUsIHZhbGlkYXRpb25PcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIEhvZWsucmVhY2gocmVmLmlzQ29udGV4dCA/IHZhbGlkYXRpb25PcHRpb25zLmNvbnRleHQgOiB2YWx1ZSwgcmVmLmtleSwgc2V0dGluZ3MpO1xuICAgIH07XG5cbiAgICByZWYuaXNDb250ZXh0ID0gKGtleVswXSA9PT0gKChzZXR0aW5ncyAmJiBzZXR0aW5ncy5jb250ZXh0UHJlZml4KSB8fCAnJCcpKTtcbiAgICByZWYua2V5ID0gKHJlZi5pc0NvbnRleHQgPyBrZXkuc2xpY2UoMSkgOiBrZXkpO1xuICAgIHJlZi5wYXRoID0gcmVmLmtleS5zcGxpdCgoc2V0dGluZ3MgJiYgc2V0dGluZ3Muc2VwYXJhdG9yKSB8fCAnLicpO1xuICAgIHJlZi5kZXB0aCA9IHJlZi5wYXRoLmxlbmd0aDtcbiAgICByZWYucm9vdCA9IHJlZi5wYXRoWzBdO1xuICAgIHJlZi5pc0pvaSA9IHRydWU7XG5cbiAgICByZWYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIChyZWYuaXNDb250ZXh0ID8gJ2NvbnRleHQ6JyA6ICdyZWY6JykgKyByZWYua2V5O1xuICAgIH07XG5cbiAgICByZXR1cm4gcmVmO1xufTtcblxuXG5leHBvcnRzLmlzUmVmID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgcmV0dXJuIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiYgcmVmLmlzSm9pO1xufTtcblxuXG5leHBvcnRzLnB1c2ggPSBmdW5jdGlvbiAoYXJyYXksIHJlZikge1xuXG4gICAgaWYgKGV4cG9ydHMuaXNSZWYocmVmKSAmJlxuICAgICAgICAhcmVmLmlzQ29udGV4dCkge1xuXG4gICAgICAgIGFycmF5LnB1c2gocmVmLnJvb3QpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEpvaSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLm9wdGlvbnMgPSBKb2kub2JqZWN0KHtcbiAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgIGNvbnZlcnQ6IEpvaS5ib29sZWFuKCksXG4gICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgIHNraXBGdW5jdGlvbnM6IEpvaS5ib29sZWFuKCksXG4gICAgc3RyaXBVbmtub3duOiBbSm9pLmJvb2xlYW4oKSwgSm9pLm9iamVjdCh7IGFycmF5czogSm9pLmJvb2xlYW4oKSwgb2JqZWN0czogSm9pLmJvb2xlYW4oKSB9KS5vcignYXJyYXlzJywgJ29iamVjdHMnKV0sXG4gICAgbGFuZ3VhZ2U6IEpvaS5vYmplY3QoKSxcbiAgICBwcmVzZW5jZTogSm9pLnN0cmluZygpLm9ubHkoJ3JlcXVpcmVkJywgJ29wdGlvbmFsJywgJ2ZvcmJpZGRlbicsICdpZ25vcmUnKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgbm9EZWZhdWx0czogSm9pLmJvb2xlYW4oKSxcbiAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpXG59KS5zdHJpY3QoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuZXh0ZW5kZWRDaGVja0ZvclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIERhdGUgJiYgdmFsdWUuZ2V0VGltZSgpID09PSBpdGVtLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGl0ZW0pICYmIHZhbHVlLmxlbmd0aCA9PT0gaXRlbS5sZW5ndGggJiYgdmFsdWUudG9TdHJpbmcoJ2JpbmFyeScpID09PSBpdGVtLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zZW5zaXRpdmUgJiYgdmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiAoaXRlbSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICYmIGxvd2VyY2FzZVZhbHVlID09PSBpdGVtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSW50ZXJuYWxTZXQge1xuXG4gICAgY29uc3RydWN0b3IoZnJvbSkge1xuXG4gICAgICAgIHRoaXMuX3NldCA9IG5ldyBTZXQoZnJvbSk7XG4gICAgICAgIHRoaXMuX2hhc1JlZiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGFkZCh2YWx1ZSwgcmVmcykge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKHZhbHVlKTtcbiAgICAgICAgaWYgKCFpc1JlZiAmJiB0aGlzLmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgZmFsc2UpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZnMgIT09IHVuZGVmaW5lZCkgeyAvLyBJZiBpdCdzIGEgbWVyZ2UsIHdlIGRvbid0IGhhdmUgYW55IHJlZnNcbiAgICAgICAgICAgIFJlZi5wdXNoKHJlZnMsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldC5hZGQodmFsdWUpO1xuXG4gICAgICAgIHRoaXMuX2hhc1JlZiB8PSBpc1JlZjtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtZXJnZShhZGQsIHJlbW92ZSkge1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhZGQuX3NldCkge1xuICAgICAgICAgICAgdGhpcy5hZGQoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVtb3ZlLl9zZXQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVtb3ZlKHZhbHVlKSB7XG5cbiAgICAgICAgdGhpcy5fc2V0LmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhhcyh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXQodmFsdWUsIHN0YXRlLCBvcHRpb25zLCBpbnNlbnNpdGl2ZSk7XG4gICAgfVxuXG4gICAgZ2V0KHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3NldC5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBoYXNWYWx1ZSA9IHRoaXMuX3NldC5oYXModmFsdWUpO1xuICAgICAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHRlbmRlZENoZWNrID0gaW50ZXJuYWxzLmV4dGVuZGVkQ2hlY2tGb3JWYWx1ZSh2YWx1ZSwgaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAoIWV4dGVuZGVkQ2hlY2spIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiB0aGlzLl9oYXNSZWYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuX3NldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoUmVmLmlzUmVmKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gW10uY29uY2F0KGl0ZW0oc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSBpdGVtLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbVtmb3VuZF0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhcyh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIGV4dGVuZGVkQ2hlY2spO1xuICAgIH1cblxuICAgIF9oYXModmFsdWUsIHN0YXRlLCBvcHRpb25zLCBjaGVjaykge1xuXG4gICAgICAgIGNvbnN0IGNoZWNrUmVmID0gISEoc3RhdGUgJiYgdGhpcy5faGFzUmVmKTtcblxuICAgICAgICBjb25zdCBpc1JlYWxseUVxdWFsID0gZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGVjayhpdGVtKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHRoaXMuX3NldCkge1xuICAgICAgICAgICAgaWYgKGNoZWNrUmVmICYmIFJlZi5pc1JlZihpdGVtKSkgeyAvLyBPbmx5IHJlc29sdmUgcmVmZXJlbmNlcyBpZiB0aGVyZSBpcyBhIHN0YXRlLCBvdGhlcndpc2UgaXQncyBhIG1lcmdlXG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW0oc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGl0ZW0uZmluZEluZGV4KGlzUmVhbGx5RXF1YWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVtmb3VuZF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1JlYWxseUVxdWFsKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhbHVlcyhvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zdHJpcFVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9zZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3NldCk7XG4gICAgfVxuXG4gICAgc2xpY2UoKSB7XG5cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IEludGVybmFsU2V0KHRoaXMuX3NldCk7XG4gICAgICAgIHNldC5faGFzUmVmID0gdGhpcy5faGFzUmVmO1xuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgSW50ZXJuYWxTZXQoWy4uLnRoaXMuX3NldCwgLi4uc291cmNlLl9zZXRdKTtcbiAgICAgICAgc2V0Ll9oYXNSZWYgPSAhISh0aGlzLl9oYXNSZWYgfCBzb3VyY2UuX2hhc1JlZik7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5jb25zdCBDYXN0ID0gcmVxdWlyZSgnLi4vLi4vY2FzdCcpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vLi4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLkFsdGVybmF0aXZlcyA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnYWx0ZXJuYXRpdmVzJztcbiAgICAgICAgdGhpcy5faW52YWxpZHMucmVtb3ZlKG51bGwpO1xuICAgICAgICB0aGlzLl9pbm5lci5tYXRjaGVzID0gW107XG4gICAgfVxuXG4gICAgX2luaXQoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA/IHRoaXMudHJ5KC4uLmFyZ3MpIDogdGhpcztcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgaWwgPSB0aGlzLl9pbm5lci5tYXRjaGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSB0aGlzLl9iYXNlVHlwZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pbm5lci5tYXRjaGVzW2ldO1xuICAgICAgICAgICAgaWYgKCFpdGVtLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IGl0ZW0ucGVlayB8fCBpdGVtLmlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaXRlbS5pcyA/IGl0ZW0ucmVmKHN0YXRlLnJlZmVyZW5jZSB8fCBzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbGVkID0gc2NoZW1hLl92YWxpZGF0ZShpbnB1dCwgbnVsbCwgb3B0aW9ucywgc3RhdGUucGFyZW50KS5lcnJvcnM7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ub3RoZXJ3aXNlLl92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udGhlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50aGVuLl92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpID09PSAoaWwgLSAxKSAmJiBiYXNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVR5cGUuX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7ICAgICAvLyBGb3VuZCBhIHZhbGlkIG1hdGNoXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiB0aGlzLmNyZWF0ZUVycm9yKCdhbHRlcm5hdGl2ZXMuY2hpbGQnLCB7IHJlYXNvbjogZXJyb3JzIH0sIHN0YXRlLCBvcHRpb25zKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiB0aGlzLmNyZWF0ZUVycm9yKCdhbHRlcm5hdGl2ZXMuYmFzZScsIG51bGwsIHN0YXRlLCBvcHRpb25zKSB9O1xuICAgIH1cblxuICAgIHRyeSguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgc2NoZW1hcyA9IEhvZWsuZmxhdHRlbihzY2hlbWFzKTtcbiAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hcy5sZW5ndGgsICdDYW5ub3QgYWRkIG90aGVyIGFsdGVybmF0aXZlcyB3aXRob3V0IGF0IGxlYXN0IG9uZSBzY2hlbWEnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWFzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjYXN0ID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgc2NoZW1hc1tpXSk7XG4gICAgICAgICAgICBpZiAoY2FzdC5fcmVmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmouX3JlZnMucHVzaCguLi5jYXN0Ll9yZWZzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9pbm5lci5tYXRjaGVzLnB1c2goeyBzY2hlbWE6IGNhc3QgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHdoZW4oY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHNjaGVtYUNvbmRpdGlvbiA9IGZhbHNlO1xuICAgICAgICBIb2VrLmFzc2VydChSZWYuaXNSZWYoY29uZGl0aW9uKSB8fCB0eXBlb2YgY29uZGl0aW9uID09PSAnc3RyaW5nJyB8fCAoc2NoZW1hQ29uZGl0aW9uID0gY29uZGl0aW9uIGluc3RhbmNlb2YgQW55KSwgJ0ludmFsaWQgY29uZGl0aW9uOicsIGNvbmRpdGlvbik7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMsICdNaXNzaW5nIG9wdGlvbnMnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBvcHRpb25zJyk7XG4gICAgICAgIGlmIChzY2hlbWFDb25kaXRpb24pIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLmhhc093blByb3BlcnR5KCdpcycpLCAnXCJpc1wiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnaXMnKSwgJ01pc3NpbmcgXCJpc1wiIGRpcmVjdGl2ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy50aGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vdGhlcndpc2UgIT09IHVuZGVmaW5lZCwgJ29wdGlvbnMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiBcInRoZW5cIiBvciBcIm90aGVyd2lzZVwiJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBsZXQgaXM7XG4gICAgICAgIGlmICghc2NoZW1hQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICBpcyA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIG9wdGlvbnMuaXMpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pcyA9PT0gbnVsbCB8fCAhKFJlZi5pc1JlZihvcHRpb25zLmlzKSB8fCBvcHRpb25zLmlzIGluc3RhbmNlb2YgQW55KSkge1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSByZXF1aXJlZCBpZiB0aGlzIHdhc24ndCBhbHJlYWR5IGEgc2NoZW1hIG9yIGEgcmVmLCB3ZSdsbCBzdXBwb3NlIHBlb3BsZSBrbm93IHdoYXQgdGhleSdyZSBkb2luZ1xuICAgICAgICAgICAgICAgIGlzID0gaXMucmVxdWlyZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICByZWY6IHNjaGVtYUNvbmRpdGlvbiA/IG51bGwgOiBDYXN0LnJlZihjb25kaXRpb24pLFxuICAgICAgICAgICAgcGVlazogc2NoZW1hQ29uZGl0aW9uID8gY29uZGl0aW9uIDogbnVsbCxcbiAgICAgICAgICAgIGlzLFxuICAgICAgICAgICAgdGhlbjogb3B0aW9ucy50aGVuICE9PSB1bmRlZmluZWQgPyBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBvcHRpb25zLnRoZW4pIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoZXJ3aXNlOiBvcHRpb25zLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkID8gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgb3B0aW9ucy5vdGhlcndpc2UpIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9iai5fYmFzZVR5cGUpIHtcblxuICAgICAgICAgICAgaXRlbS50aGVuID0gaXRlbS50aGVuICYmIG9iai5fYmFzZVR5cGUuY29uY2F0KGl0ZW0udGhlbik7XG4gICAgICAgICAgICBpdGVtLm90aGVyd2lzZSA9IGl0ZW0ub3RoZXJ3aXNlICYmIG9iai5fYmFzZVR5cGUuY29uY2F0KGl0ZW0ub3RoZXJ3aXNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICBSZWYucHVzaChvYmouX3JlZnMsIGl0ZW0ucmVmKTtcbiAgICAgICAgICAgIG9iai5fcmVmcy5wdXNoKC4uLml0ZW0uaXMuX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0udGhlbiAmJiBpdGVtLnRoZW4uX3JlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmouX3JlZnMucHVzaCguLi5pdGVtLnRoZW4uX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0ub3RoZXJ3aXNlICYmIGl0ZW0ub3RoZXJ3aXNlLl9yZWZzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqLl9yZWZzLnB1c2goLi4uaXRlbS5vdGhlcndpc2UuX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pbm5lci5tYXRjaGVzLnB1c2goaXRlbSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gc3VwZXIubGFiZWwobmFtZSk7XG4gICAgICAgIG9iai5faW5uZXIubWF0Y2hlcyA9IG9iai5faW5uZXIubWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaC5zY2hlbWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IG1hdGNoLnNjaGVtYS5sYWJlbChuYW1lKSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRjaCA9IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoKTtcbiAgICAgICAgICAgIGlmIChtYXRjaC50aGVuKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2gudGhlbiA9IG1hdGNoLnRoZW4ubGFiZWwobmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXRjaC5vdGhlcndpc2UpIHtcbiAgICAgICAgICAgICAgICBtYXRjaC5vdGhlcndpc2UgPSBtYXRjaC5vdGhlcndpc2UubGFiZWwobmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzdXBlci5kZXNjcmliZSgpO1xuICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faW5uZXIubWF0Y2hlc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtLnNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5KClcblxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlcy5wdXNoKGl0ZW0uc2NoZW1hLmRlc2NyaWJlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyB3aGVuKClcblxuICAgICAgICAgICAgICAgIGNvbnN0IHdoZW4gPSBpdGVtLmlzID8ge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGl0ZW0ucmVmLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGlzOiBpdGVtLmlzLmRlc2NyaWJlKClcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBwZWVrOiBpdGVtLnBlZWsuZGVzY3JpYmUoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoZW4udGhlbiA9IGl0ZW0udGhlbi5kZXNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgICAgICB3aGVuLm90aGVyd2lzZSA9IGl0ZW0ub3RoZXJ3aXNlLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVzLnB1c2god2hlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkZXNjcmlwdGlvbi5hbHRlcm5hdGl2ZXMgPSBhbHRlcm5hdGl2ZXM7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkFsdGVybmF0aXZlcygpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBDYXN0ID0gcmVxdWlyZSgnLi4vLi4vY2FzdCcpO1xuY29uc3QgU2V0dGluZ3MgPSByZXF1aXJlKCcuL3NldHRpbmdzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4uL3N5bWJvbHMnKTtcblxuY29uc3QgUGtnID0gcmVxdWlyZSgnLi4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbmxldCBBbHRlcm5hdGl2ZXMgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWxheS1sb2FkZWQgdG8gcHJldmVudCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbmxldCBTY2hlbWFzID0gbnVsbDtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgU2V0OiByZXF1aXJlKCcuLi8uLi9zZXQnKSxcbiAgICBzeW1ib2w6IFN5bWJvbC5mb3IoJ0BoYXBpL2pvaS9zY2hlbWEnKVxufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdHMgPSB7XG4gICAgYWJvcnRFYXJseTogdHJ1ZSxcbiAgICBjb252ZXJ0OiB0cnVlLFxuICAgIGFsbG93VW5rbm93bjogZmFsc2UsXG4gICAgc2tpcEZ1bmN0aW9uczogZmFsc2UsXG4gICAgc3RyaXBVbmtub3duOiBmYWxzZSxcbiAgICBsYW5ndWFnZToge30sXG4gICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsXG4gICAgbm9EZWZhdWx0czogZmFsc2UsXG4gICAgZXNjYXBlSHRtbDogZmFsc2VcblxuICAgIC8vIGNvbnRleHQ6IG51bGxcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuQW55ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5pc0pvaSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnYW55JztcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLl92YWxpZHMgPSBuZXcgaW50ZXJuYWxzLlNldCgpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcyA9IG5ldyBpbnRlcm5hbHMuU2V0KCk7XG4gICAgICAgIHRoaXMuX3Rlc3RzID0gW107XG4gICAgICAgIHRoaXMuX3JlZnMgPSBbXTtcbiAgICAgICAgdGhpcy5fZmxhZ3MgPSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgIHByZXNlbmNlOiAnb3B0aW9uYWwnLCAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCwgcmVxdWlyZWQsIGZvcmJpZGRlbiwgaWdub3JlXG4gICAgICAgICAgICAgYWxsb3dPbmx5OiBmYWxzZSxcbiAgICAgICAgICAgICBhbGxvd1Vua25vd246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgZm9yYmlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgICBlbmNvZGluZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgIGluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICB0cmltOiBmYWxzZSxcbiAgICAgICAgICAgICBub3JtYWxpemU6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgLy8gTkZDLCBORkQsIE5GS0MsIE5GS0RcbiAgICAgICAgICAgICBjYXNlOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBwZXIsIGxvd2VyXG4gICAgICAgICAgICAgZW1wdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICBmdW5jOiBmYWxzZSxcbiAgICAgICAgICAgICByYXc6IGZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX3VuaXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9ub3RlcyA9IFtdO1xuICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIHRoaXMuX2V4YW1wbGVzID0gW107XG4gICAgICAgIHRoaXMuX21ldGEgPSBbXTtcblxuICAgICAgICB0aGlzLl9pbm5lciA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhc2ggb2YgYXJyYXlzIG9mIGltbXV0YWJsZSBvYmplY3RzXG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IHNjaGVtYVR5cGUoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgY3JlYXRlRXJyb3IodHlwZSwgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMsIGZsYWdzID0gdGhpcy5fZmxhZ3MpIHtcblxuICAgICAgICByZXR1cm4gRXJyb3JzLmNyZWF0ZSh0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZmxhZ3MpO1xuICAgIH1cblxuICAgIGNyZWF0ZU92ZXJyaWRlRXJyb3IodHlwZSwgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMsIG1lc3NhZ2UsIHRlbXBsYXRlKSB7XG5cbiAgICAgICAgcmV0dXJuIEVycm9ycy5jcmVhdGUodHlwZSwgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMsIHRoaXMuX2ZsYWdzLCBtZXNzYWdlLCB0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgY2hlY2tPcHRpb25zKG9wdGlvbnMpIHtcblxuICAgICAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuLi8uLi9zY2hlbWFzJyk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gU2NoZW1hcy5vcHRpb25zLnZhbGlkYXRlKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcblxuICAgICAgICBvYmouaXNKb2kgPSB0cnVlO1xuICAgICAgICBvYmouX2N1cnJlbnRKb2kgPSB0aGlzLl9jdXJyZW50Sm9pO1xuICAgICAgICBvYmouX3R5cGUgPSB0aGlzLl90eXBlO1xuICAgICAgICBvYmouX3NldHRpbmdzID0gdGhpcy5fc2V0dGluZ3M7XG4gICAgICAgIG9iai5fYmFzZVR5cGUgPSB0aGlzLl9iYXNlVHlwZTtcbiAgICAgICAgb2JqLl92YWxpZHMgPSB0aGlzLl92YWxpZHMuc2xpY2UoKTtcbiAgICAgICAgb2JqLl9pbnZhbGlkcyA9IHRoaXMuX2ludmFsaWRzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fdGVzdHMgPSB0aGlzLl90ZXN0cy5zbGljZSgpO1xuICAgICAgICBvYmouX3JlZnMgPSB0aGlzLl9yZWZzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fZmxhZ3MgPSBIb2VrLmNsb25lKHRoaXMuX2ZsYWdzKTtcblxuICAgICAgICBvYmouX2Rlc2NyaXB0aW9uID0gdGhpcy5fZGVzY3JpcHRpb247XG4gICAgICAgIG9iai5fdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgICAgIG9iai5fbm90ZXMgPSB0aGlzLl9ub3Rlcy5zbGljZSgpO1xuICAgICAgICBvYmouX3RhZ3MgPSB0aGlzLl90YWdzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fZXhhbXBsZXMgPSB0aGlzLl9leGFtcGxlcy5zbGljZSgpO1xuICAgICAgICBvYmouX21ldGEgPSB0aGlzLl9tZXRhLnNsaWNlKCk7XG5cbiAgICAgICAgb2JqLl9pbm5lciA9IHt9O1xuICAgICAgICBjb25zdCBpbm5lcnMgPSBPYmplY3Qua2V5cyh0aGlzLl9pbm5lcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBpbm5lcnNbaV07XG4gICAgICAgICAgICBvYmouX2lubmVyW2tleV0gPSB0aGlzLl9pbm5lcltrZXldID8gdGhpcy5faW5uZXJba2V5XS5zbGljZSgpIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgY29uY2F0KHNjaGVtYSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSBpbnN0YW5jZW9mIGludGVybmFscy5BbnksICdJbnZhbGlkIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5fdHlwZSA9PT0gJ2FueScgfHwgc2NoZW1hLl90eXBlID09PSAnYW55JyB8fCBzY2hlbWEuX3R5cGUgPT09IHRoaXMuX3R5cGUsICdDYW5ub3QgbWVyZ2UgdHlwZScsIHRoaXMuX3R5cGUsICd3aXRoIGFub3RoZXIgdHlwZTonLCBzY2hlbWEuX3R5cGUpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdhbnknICYmIHNjaGVtYS5fdHlwZSAhPT0gJ2FueScpIHtcblxuICAgICAgICAgICAgLy8gUmVzZXQgdmFsdWVzIGFzIGlmIHdlIHdlcmUgXCJ0aGlzXCJcbiAgICAgICAgICAgIGNvbnN0IHRtcE9iaiA9IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgY29uc3Qga2V5c1RvUmVzdG9yZSA9IFsnX3NldHRpbmdzJywgJ192YWxpZHMnLCAnX2ludmFsaWRzJywgJ190ZXN0cycsICdfcmVmcycsICdfZmxhZ3MnLCAnX2Rlc2NyaXB0aW9uJywgJ191bml0JyxcbiAgICAgICAgICAgICAgICAnX25vdGVzJywgJ190YWdzJywgJ19leGFtcGxlcycsICdfbWV0YScsICdfaW5uZXInXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzVG9SZXN0b3JlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdG1wT2JqW2tleXNUb1Jlc3RvcmVbaV1dID0gb2JqW2tleXNUb1Jlc3RvcmVbaV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmogPSB0bXBPYmo7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX3NldHRpbmdzID0gb2JqLl9zZXR0aW5ncyA/IFNldHRpbmdzLmNvbmNhdChvYmouX3NldHRpbmdzLCBzY2hlbWEuX3NldHRpbmdzKSA6IHNjaGVtYS5fc2V0dGluZ3M7XG4gICAgICAgIG9iai5fdmFsaWRzLm1lcmdlKHNjaGVtYS5fdmFsaWRzLCBzY2hlbWEuX2ludmFsaWRzKTtcbiAgICAgICAgb2JqLl9pbnZhbGlkcy5tZXJnZShzY2hlbWEuX2ludmFsaWRzLCBzY2hlbWEuX3ZhbGlkcyk7XG4gICAgICAgIG9iai5fdGVzdHMucHVzaCguLi5zY2hlbWEuX3Rlc3RzKTtcbiAgICAgICAgb2JqLl9yZWZzLnB1c2goLi4uc2NoZW1hLl9yZWZzKTtcbiAgICAgICAgaWYgKG9iai5fZmxhZ3MuZW1wdHkgJiYgc2NoZW1hLl9mbGFncy5lbXB0eSkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IG9iai5fZmxhZ3MuZW1wdHkuY29uY2F0KHNjaGVtYS5fZmxhZ3MuZW1wdHkpO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIEhvZWsubWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYS5fZmxhZ3MuZW1wdHkpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBzY2hlbWEuX2ZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIEhvZWsubWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgSG9lay5tZXJnZShvYmouX2ZsYWdzLCBzY2hlbWEuX2ZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5fZGVzY3JpcHRpb24gPSBzY2hlbWEuX2Rlc2NyaXB0aW9uIHx8IG9iai5fZGVzY3JpcHRpb247XG4gICAgICAgIG9iai5fdW5pdCA9IHNjaGVtYS5fdW5pdCB8fCBvYmouX3VuaXQ7XG4gICAgICAgIG9iai5fbm90ZXMucHVzaCguLi5zY2hlbWEuX25vdGVzKTtcbiAgICAgICAgb2JqLl90YWdzLnB1c2goLi4uc2NoZW1hLl90YWdzKTtcbiAgICAgICAgb2JqLl9leGFtcGxlcy5wdXNoKC4uLnNjaGVtYS5fZXhhbXBsZXMpO1xuICAgICAgICBvYmouX21ldGEucHVzaCguLi5zY2hlbWEuX21ldGEpO1xuXG4gICAgICAgIGNvbnN0IGlubmVycyA9IE9iamVjdC5rZXlzKHNjaGVtYS5faW5uZXIpO1xuICAgICAgICBjb25zdCBpc09iamVjdCA9IG9iai5fdHlwZSA9PT0gJ29iamVjdCc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBpbm5lcnNbaV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzY2hlbWEuX2lubmVyW2tleV07XG4gICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JqLl9pbm5lcltrZXldO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0ICYmIGtleSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhcmdldC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXNbdGFyZ2V0W2pdLmtleV0gPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNvdXJjZS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUtleSA9IHNvdXJjZVtqXS5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbc291cmNlS2V5XSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXlzW3NvdXJjZUtleV1dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzb3VyY2VLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHRhcmdldFtrZXlzW3NvdXJjZUtleV1dLnNjaGVtYS5jb25jYXQoc291cmNlW2pdLnNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZVtqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLl9pbm5lcltrZXldID0gb2JqLl9pbm5lcltrZXldLmNvbmNhdChzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmouX2lubmVyW2tleV0gPSBzb3VyY2Uuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF90ZXN0KG5hbWUsIGFyZywgZnVuYywgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl90ZXN0cy5wdXNoKHsgZnVuYywgbmFtZSwgYXJnLCBvcHRpb25zIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF90ZXN0VW5pcXVlKG5hbWUsIGFyZywgZnVuYywgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl90ZXN0cyA9IG9iai5fdGVzdHMuZmlsdGVyKCh0ZXN0KSA9PiB0ZXN0Lm5hbWUgIT09IG5hbWUpO1xuICAgICAgICBvYmouX3Rlc3RzLnB1c2goeyBmdW5jLCBuYW1lLCBhcmcsIG9wdGlvbnMgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgb3B0aW9ucyhvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuY29udGV4dCwgJ0Nhbm5vdCBvdmVycmlkZSBjb250ZXh0Jyk7XG4gICAgICAgIHRoaXMuY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9zZXR0aW5ncyA9IFNldHRpbmdzLmNvbmNhdChvYmouX3NldHRpbmdzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdHJpY3QoaXNTdHJpY3QpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgY29uc3QgY29udmVydCA9IGlzU3RyaWN0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFpc1N0cmljdDtcbiAgICAgICAgb2JqLl9zZXR0aW5ncyA9IFNldHRpbmdzLmNvbmNhdChvYmouX3NldHRpbmdzLCB7IGNvbnZlcnQgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmF3KGlzUmF3KSB7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBpc1JhdyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzUmF3O1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5yYXcgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5yYXcgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBlcnJvcihlcnIsIG9wdGlvbnMgPSB7IHNlbGY6IGZhbHNlIH0pIHtcblxuICAgICAgICBIb2VrLmFzc2VydChlcnIgJiYgKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBlcnIgPT09ICdmdW5jdGlvbicpLCAnTXVzdCBwcm92aWRlIGEgdmFsaWQgRXJyb3Igb2JqZWN0IG9yIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigoaykgPT4gIVsnc2VsZiddLmluY2x1ZGVzKGspKTtcbiAgICAgICAgSG9lay5hc3NlcnQodW5rbm93bktleXMubGVuZ3RoID09PSAwLCBgT3B0aW9ucyAke3Vua25vd25LZXlzfSBhcmUgdW5rbm93bmApO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5lcnJvciA9IGVycjtcblxuICAgICAgICBpZiAob3B0aW9ucy5zZWxmKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLnNlbGZFcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGFsbG93KC4uLnZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFsdWVzID0gSG9lay5mbGF0dGVuKHZhbHVlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIGFsbG93L3ZhbGlkL2ludmFsaWQgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIG9iai5faW52YWxpZHMucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgICAgIG9iai5fdmFsaWRzLmFkZCh2YWx1ZSwgb2JqLl9yZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdmFsaWQoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5hbGxvdyguLi52YWx1ZXMpO1xuICAgICAgICBvYmouX2ZsYWdzLmFsbG93T25seSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaW52YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhbHVlcyA9IEhvZWsuZmxhdHRlbih2YWx1ZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBhbGxvdy92YWxpZC9pbnZhbGlkIHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBvYmouX3ZhbGlkcy5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgICAgb2JqLl9pbnZhbGlkcy5hZGQodmFsdWUsIG9iai5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJlcXVpcmVkKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MucHJlc2VuY2UgPSAncmVxdWlyZWQnO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG9wdGlvbmFsKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5wcmVzZW5jZSA9PT0gJ29wdGlvbmFsJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MucHJlc2VuY2UgPSAnb3B0aW9uYWwnO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuXG4gICAgZm9yYmlkZGVuKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5wcmVzZW5jZSA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnByZXNlbmNlID0gJ2ZvcmJpZGRlbic7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG5cbiAgICBzdHJpcCgpIHtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3Muc3RyaXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnN0cmlwID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBhcHBseUZ1bmN0aW9uVG9DaGlsZHJlbihjaGlsZHJlbiwgZm4sIGFyZ3MgPSBbXSwgcm9vdCkge1xuXG4gICAgICAgIGNoaWxkcmVuID0gW10uY29uY2F0KGNoaWxkcmVuKTtcblxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGNoaWxkcmVuWzBdICE9PSAnJykge1xuICAgICAgICAgICAgcm9vdCA9IHJvb3QgPyAocm9vdCArICcuJykgOiAnJztcblxuICAgICAgICAgICAgY29uc3QgZXh0cmFDaGlsZHJlbiA9IChjaGlsZHJlblswXSA9PT0gJycgPyBjaGlsZHJlbi5zbGljZSgxKSA6IGNoaWxkcmVuKS5tYXAoKGNoaWxkKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdCArIGNoaWxkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5rbm93biBrZXkocykgJyArIGV4dHJhQ2hpbGRyZW4uam9pbignLCAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpc1tmbl0oLi4uYXJncyk7XG4gICAgfVxuXG4gICAgZGVmYXVsdCh2YWx1ZSwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAhUmVmLmlzUmVmKHZhbHVlKSkge1xuXG4gICAgICAgICAgICBpZiAoIXZhbHVlLmRlc2NyaXB0aW9uICYmXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZmxhZ3MuZnVuYykge1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB2YWx1ZS5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZGVzY3JpcHRpb24ubGVuZ3RoID4gMCwgJ2Rlc2NyaXB0aW9uIG11c3QgYmUgcHJvdmlkZWQgd2hlbiBkZWZhdWx0IHZhbHVlIGlzIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5kZWZhdWx0ID0gdmFsdWU7XG4gICAgICAgIFJlZi5wdXNoKG9iai5fcmVmcywgdmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGVtcHR5KHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqLl9mbGFncy5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBzY2hlbWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB3aGVuKGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCBvcHRpb25zJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMudGhlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQsICdvcHRpb25zIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgXCJ0aGVuXCIgb3IgXCJvdGhlcndpc2VcIicpO1xuXG4gICAgICAgIGNvbnN0IHRoZW4gPSBvcHRpb25zLmhhc093blByb3BlcnR5KCd0aGVuJykgPyB0aGlzLmNvbmNhdChDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBvcHRpb25zLnRoZW4pKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3RoZXJ3aXNlID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnb3RoZXJ3aXNlJykgPyB0aGlzLmNvbmNhdChDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBvcHRpb25zLm90aGVyd2lzZSkpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIEFsdGVybmF0aXZlcyA9IEFsdGVybmF0aXZlcyB8fCByZXF1aXJlKCcuLi9hbHRlcm5hdGl2ZXMnKTtcblxuICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZU9wdGlvbnMgPSB7IHRoZW4sIG90aGVyd2lzZSB9O1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdpcycpKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGl2ZU9wdGlvbnMuaXMgPSBvcHRpb25zLmlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gQWx0ZXJuYXRpdmVzLndoZW4oY29uZGl0aW9uLCBhbHRlcm5hdGl2ZU9wdGlvbnMpO1xuICAgICAgICBvYmouX2ZsYWdzLnByZXNlbmNlID0gJ2lnbm9yZSc7XG4gICAgICAgIG9iai5fYmFzZVR5cGUgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZGVzY3JpcHRpb24oZGVzYykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGRlc2MgJiYgdHlwZW9mIGRlc2MgPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZGVzY3JpcHRpb24gPSBkZXNjO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG5vdGVzKG5vdGVzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQobm90ZXMgJiYgKHR5cGVvZiBub3RlcyA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShub3RlcykpLCAnTm90ZXMgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYXJyYXknKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fbm90ZXMgPSBvYmouX25vdGVzLmNvbmNhdChub3Rlcyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdGFncyh0YWdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGFncyAmJiAodHlwZW9mIHRhZ3MgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkodGFncykpLCAnVGFncyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl90YWdzID0gb2JqLl90YWdzLmNvbmNhdCh0YWdzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBtZXRhKG1ldGEpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChtZXRhICE9PSB1bmRlZmluZWQsICdNZXRhIGNhbm5vdCBiZSB1bmRlZmluZWQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fbWV0YSA9IG9iai5fbWV0YS5jb25jYXQobWV0YSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZXhhbXBsZSguLi5leGFtcGxlcykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGV4YW1wbGVzLmxlbmd0aCA+IDAsICdNaXNzaW5nIGV4YW1wbGVzJyk7XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhhbXBsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUgPSBbXS5jb25jYXQoZXhhbXBsZXNbaV0pO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoZXhhbXBsZS5sZW5ndGggPD0gMiwgYEJhZCBleGFtcGxlIGZvcm1hdCBhdCBpbmRleCAke2l9YCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXhhbXBsZVswXTtcbiAgICAgICAgICAgIGxldCBvcHRpb25zID0gZXhhbXBsZVsxXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgYE9wdGlvbnMgZm9yIGV4YW1wbGUgYXQgaW5kZXggJHtpfSBtdXN0IGJlIGFuIG9iamVjdGApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVua25vd25PcHRpb25zID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChvcHRpb24pID0+ICFbJ3BhcmVudCcsICdjb250ZXh0J10uaW5jbHVkZXMob3B0aW9uKSk7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodW5rbm93bk9wdGlvbnMubGVuZ3RoID09PSAwLCBgVW5rbm93biBleGFtcGxlIG9wdGlvbnMgJHt1bmtub3duT3B0aW9uc30gYXQgaW5kZXggJHtpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKCcnLCBbXSwgb3B0aW9ucy5wYXJlbnQgfHwgbnVsbCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl92YWxpZGF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgU2V0dGluZ3MuY29uY2F0KGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucy5jb250ZXh0ID8geyBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfSA6IG51bGwpKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFyZXN1bHQuZXJyb3JzLCBgQmFkIGV4YW1wbGUgYXQgaW5kZXggJHtpfTpgLCByZXN1bHQuZXJyb3JzICYmIEVycm9ycy5wcm9jZXNzKHJlc3VsdC5lcnJvcnMsIHZhbHVlKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4ID0geyB2YWx1ZSB9O1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGV4Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZXhhbXBsZXMgPSBwcm9jZXNzZWQ7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdW5pdChuYW1lKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdVbml0IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fdW5pdCA9IG5hbWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX3ByZXBhcmVFbXB0eVZhbHVlKHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdGhpcy5fZmxhZ3MudHJpbSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBfdmFsaWRhdGUodmFsdWUsIHN0YXRlLCBvcHRpb25zLCByZWZlcmVuY2UpIHtcblxuICAgICAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gU2V0dXAgc3RhdGUgYW5kIHNldHRpbmdzXG5cbiAgICAgICAgc3RhdGUgPSBzdGF0ZSB8fCBuZXcgU3RhdGUoJycsIFtdLCBudWxsLCByZWZlcmVuY2UpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncykge1xuICAgICAgICAgICAgY29uc3QgaXNEZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnMgPT09IGludGVybmFscy5kZWZhdWx0cztcbiAgICAgICAgICAgIGlmIChpc0RlZmF1bHRPcHRpb25zICYmIHRoaXMuX3NldHRpbmdzW1N5bWJvbHMuc2V0dGluZ3NDYWNoZV0pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhpcy5fc2V0dGluZ3NbU3ltYm9scy5zZXR0aW5nc0NhY2hlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBTZXR0aW5ncy5jb25jYXQodGhpcy5fbGFuZ3VhZ2UgPyBTZXR0aW5ncy5jb25jYXQoeyBsYW5ndWFnZTogdGhpcy5fbGFuZ3VhZ2UgfSwgb3B0aW9ucykgOiBvcHRpb25zLCB0aGlzLl9zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGluZ3NbU3ltYm9scy5zZXR0aW5nc0NhY2hlXSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2xhbmd1YWdlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gU2V0dGluZ3MuY29uY2F0KHsgbGFuZ3VhZ2U6IHRoaXMuX2xhbmd1YWdlIH0sIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVycm9ycyA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb2VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLl9jb2VyY2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChjb2VyY2VkLmVycm9ycykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGNvZXJjZWQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvZXJjZWQgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IGNvZXJjZWQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuZW1wdHkgJiYgIXRoaXMuX2ZsYWdzLmVtcHR5Ll92YWxpZGF0ZSh0aGlzLl9wcmVwYXJlRW1wdHlWYWx1ZSh2YWx1ZSksIG51bGwsIGludGVybmFscy5kZWZhdWx0cykuZXJyb3JzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHByZXNlbmNlIHJlcXVpcmVtZW50c1xuXG4gICAgICAgIGNvbnN0IHByZXNlbmNlID0gdGhpcy5fZmxhZ3MucHJlc2VuY2UgfHwgb3B0aW9ucy5wcmVzZW5jZTtcbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRGVlcERlZmF1bHQgPSB0aGlzLl9mbGFncy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpICYmIHRoaXMuX2ZsYWdzLmRlZmF1bHQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWVwRGVmYXVsdCAmJiB0aGlzLl90eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJyAmJlxuICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhbnkucmVxdWlyZWQnLCBudWxsLCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FueS51bmtub3duJywgbnVsbCwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGFsbG93ZWQgYW5kIGRlbmllZCB2YWx1ZXMgdXNpbmcgdGhlIG9yaWdpbmFsIHZhbHVlXG5cbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5fdmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ludmFsaWRzLmhhcyh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlKSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcih2YWx1ZSA9PT0gJycgPyAnYW55LmVtcHR5JyA6ICdhbnkuaW52YWxpZCcsIHsgdmFsdWUsIGludmFsaWRzOiB0aGlzLl9pbnZhbGlkcy52YWx1ZXMoeyBzdHJpcFVuZGVmaW5lZDogdHJ1ZSB9KSB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCB2YWx1ZSBhbmQgdmFsaWRhdGUgdHlwZVxuXG4gICAgICAgIGlmICh0aGlzLl9iYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGJhc2UuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlLnZhbHVlO1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChiYXNlLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYmFzZS52YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGFsbG93ZWQgYW5kIGRlbmllZCB2YWx1ZXMgdXNpbmcgdGhlIGNvbnZlcnRlZCB2YWx1ZVxuXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLl92YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludmFsaWRzLmhhcyh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKHZhbHVlID09PSAnJyA/ICdhbnkuZW1wdHknIDogJ2FueS5pbnZhbGlkJywgeyB2YWx1ZSwgaW52YWxpZHM6IHRoaXMuX2ludmFsaWRzLnZhbHVlcyh7IHN0cmlwVW5kZWZpbmVkOiB0cnVlIH0pIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcXVpcmVkIHZhbHVlcyBkaWQgbm90IG1hdGNoXG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLmFsbG93T25seSkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYW55LmFsbG93T25seScsIHsgdmFsdWUsIHZhbGlkczogdGhpcy5fdmFsaWRzLnZhbHVlcyh7IHN0cmlwVW5kZWZpbmVkOiB0cnVlIH0pIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGVzdHNcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3Rlc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGhpcy5fdGVzdHNbaV07XG4gICAgICAgICAgICBjb25zdCByZXQgPSB0ZXN0LmZ1bmMuY2FsbCh0aGlzLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9ycy5FcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChyZXQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IGZpbmFsVmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLl9mbGFncy5yYXcgPyBvcmlnaW5hbFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5ub0RlZmF1bHRzKSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUmVmLmlzUmVmKHRoaXMuX2ZsYWdzLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5fZmxhZ3MuZGVmYXVsdChzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9mbGFncy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAhKHRoaXMuX2ZsYWdzLmZ1bmMgJiYgIXRoaXMuX2ZsYWdzLmRlZmF1bHQuZGVzY3JpcHRpb24pKSB7XG5cbiAgICAgICAgICAgIGxldCBhcmdzO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUucGFyZW50ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZmxhZ3MuZGVmYXVsdC5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgICAgICBhcmdzID0gW0hvZWsuY2xvbmUoc3RhdGUucGFyZW50KSwgb3B0aW9uc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGludGVybmFscy5fdHJ5KHRoaXMuX2ZsYWdzLmRlZmF1bHQsIGFyZ3MpO1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0VmFsdWUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhbnkuZGVmYXVsdCcsIHsgZXJyb3I6IGRlZmF1bHRWYWx1ZS5lcnJvciB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IEhvZWsuY2xvbmUodGhpcy5fZmxhZ3MuZGVmYXVsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuX2ZsYWdzLmVycm9yID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgIXRoaXMuX2ZsYWdzLnNlbGZFcnJvciB8fFxuICAgICAgICAgICAgICAgIGVycm9ycy5zb21lKChlKSA9PiBzdGF0ZS5wYXRoLmxlbmd0aCA9PT0gZS5wYXRoLmxlbmd0aClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLl9mbGFncy5lcnJvci5jYWxsKHRoaXMsIGVycm9ycyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhbmdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IFt0aGlzLmNyZWF0ZU92ZXJyaWRlRXJyb3IoJ292ZXJyaWRlJywgeyByZWFzb246IGVycm9ycyB9LCBzdGF0ZSwgb3B0aW9ucywgY2hhbmdlKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBbXS5jb25jYXQoY2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChlcnIpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIEVycm9yID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlT3ZlcnJpZGVFcnJvcihlcnIudHlwZSB8fCAnb3ZlcnJpZGUnLCBlcnIuY29udGV4dCwgc3RhdGUsIG9wdGlvbnMsIGVyci5tZXNzYWdlLCBlcnIudGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5fZmxhZ3Muc3RyaXAgPyB1bmRlZmluZWQgOiBmaW5hbFZhbHVlLFxuICAgICAgICAgICAgZmluYWxWYWx1ZSxcbiAgICAgICAgICAgIGVycm9yczogZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfdmFsaWRhdGVXaXRoT3B0aW9ucyh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jaGVja09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IFNldHRpbmdzLmNvbmNhdChpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl92YWxpZGF0ZSh2YWx1ZSwgbnVsbCwgc2V0dGluZ3MpO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBFcnJvcnMucHJvY2VzcyhyZXN1bHQuZXJyb3JzLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLCByZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcnMsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgdGhlbihyZXNvbHZlLCByZWplY3QpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9ycykuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC52YWx1ZSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRjaChyZWplY3QpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9ycykuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVXaXRoT3B0aW9ucyh2YWx1ZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVXaXRoT3B0aW9ucyh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy5fdHlwZVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmtleXModGhpcy5fZmxhZ3MpO1xuICAgICAgICBpZiAoZmxhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoWydlbXB0eScsICdkZWZhdWx0JywgJ2xhenknLCAnbGFiZWwnXS5zb21lKChmbGFnKSA9PiB0aGlzLl9mbGFncy5oYXNPd25Qcm9wZXJ0eShmbGFnKSkpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFncyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmxhZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZyA9PT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24uZmxhZ3NbZmxhZ10gPSB0aGlzLl9mbGFnc1tmbGFnXS5kZXNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZsYWcgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJlZi5pc1JlZih0aGlzLl9mbGFnc1tmbGFnXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFnc1tmbGFnXSA9IHRoaXMuX2ZsYWdzW2ZsYWddLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5fZmxhZ3NbZmxhZ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFnc1tmbGFnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX2ZsYWdzW2ZsYWddLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAgIDogdGhpcy5fZmxhZ3NbZmxhZ11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24uZmxhZ3NbZmxhZ10gPSB0aGlzLl9mbGFnc1tmbGFnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmbGFnID09PSAnbGF6eScgfHwgZmxhZyA9PT0gJ2xhYmVsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCBpdCBpbiB0aGUgZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzW2ZsYWddID0gdGhpcy5fZmxhZ3NbZmxhZ107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFncyA9IHRoaXMuX2ZsYWdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5vcHRpb25zID0gSG9lay5jbG9uZSh0aGlzLl9zZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYmFzZVR5cGUpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmJhc2UgPSB0aGlzLl9iYXNlVHlwZS5kZXNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2Rlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5kZXNjcmlwdGlvbiA9IHRoaXMuX2Rlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX25vdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24ubm90ZXMgPSB0aGlzLl9ub3RlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl90YWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24udGFncyA9IHRoaXMuX3RhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWV0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLm1ldGEgPSB0aGlzLl9tZXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4YW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uZXhhbXBsZXMgPSB0aGlzLl9leGFtcGxlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl91bml0KSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi51bml0ID0gdGhpcy5fdW5pdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbGlkcyA9IHRoaXMuX3ZhbGlkcy52YWx1ZXMoKTtcbiAgICAgICAgaWYgKHZhbGlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnZhbGlkcyA9IHZhbGlkcy5tYXAoKHYpID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBSZWYuaXNSZWYodikgPyB2LnRvU3RyaW5nKCkgOiB2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbnZhbGlkcyA9IHRoaXMuX2ludmFsaWRzLnZhbHVlcygpO1xuICAgICAgICBpZiAoaW52YWxpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5pbnZhbGlkcyA9IGludmFsaWRzLm1hcCgodikgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZi5pc1JlZih2KSA/IHYudG9TdHJpbmcoKSA6IHY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2NyaXB0aW9uLnJ1bGVzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZXN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gdGhpcy5fdGVzdHNbaV07XG4gICAgICAgICAgICBjb25zdCBpdGVtID0geyBuYW1lOiB2YWxpZGF0b3IubmFtZSB9O1xuXG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLmFyZyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5hcmcgPSBSZWYuaXNSZWYodmFsaWRhdG9yLmFyZykgPyB2YWxpZGF0b3IuYXJnLnRvU3RyaW5nKCkgOiB2YWxpZGF0b3IuYXJnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdmFsaWRhdG9yLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc1JlZikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmFyZyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsaWRhdG9yLmFyZyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsaWRhdG9yLmFyZ1trZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hcmdba2V5XSA9IFJlZi5pc1JlZih2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbihpdGVtLmFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5ydWxlcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZXNjcmlwdGlvbi5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkZXNjcmlwdGlvbi5ydWxlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fZ2V0TGFiZWwoKTtcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5sYWJlbCA9IGxhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ0xhYmVsIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MubGFiZWwgPSBuYW1lO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9nZXRMYWJlbChkZWYpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3MubGFiZWwgfHwgZGVmO1xuICAgIH1cblxufTtcblxuXG5pbnRlcm5hbHMuQW55LnByb3RvdHlwZS5pc0ltbXV0YWJsZSA9IHRydWU7ICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzXG5cbi8vIEFsaWFzZXNcblxuaW50ZXJuYWxzLkFueS5wcm90b3R5cGUub25seSA9IGludGVybmFscy5BbnkucHJvdG90eXBlLmVxdWFsID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUudmFsaWQ7XG5pbnRlcm5hbHMuQW55LnByb3RvdHlwZS5kaXNhbGxvdyA9IGludGVybmFscy5BbnkucHJvdG90eXBlLm5vdCA9IGludGVybmFscy5BbnkucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQW55LnByb3RvdHlwZS5leGlzdCA9IGludGVybmFscy5BbnkucHJvdG90eXBlLnJlcXVpcmVkO1xuXG5cbmludGVybmFscy5BbnkucHJvdG90eXBlW2ludGVybmFscy5zeW1ib2xdID0ge1xuICAgIHZlcnNpb246IFBrZy52ZXJzaW9uLFxuICAgIGNvbXBpbGU6IENhc3Quc2NoZW1hLFxuICAgIHJvb3Q6ICdfY3VycmVudEpvaSdcbn07XG5cblxuaW50ZXJuYWxzLl90cnkgPSBmdW5jdGlvbiAoZm4sIGFyZ3MgPSBbXSkge1xuXG4gICAgbGV0IGVycjtcbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gZm4oLi4uYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgZXJyb3I6IGVyclxuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vc3ltYm9scycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuY29uY2F0ID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCk7XG5cbiAgICBjb25zdCBsYW5ndWFnZSA9IHNvdXJjZS5sYW5ndWFnZTtcblxuICAgIE9iamVjdC5hc3NpZ24ob2JqLCBzb3VyY2UpO1xuXG4gICAgaWYgKGxhbmd1YWdlICYmIHRhcmdldCAmJiB0YXJnZXQubGFuZ3VhZ2UpIHtcbiAgICAgICAgb2JqLmxhbmd1YWdlID0gSG9lay5hcHBseVRvRGVmYXVsdHModGFyZ2V0Lmxhbmd1YWdlLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgaWYgKG9ialtTeW1ib2xzLnNldHRpbmdzQ2FjaGVdKSB7XG4gICAgICAgIGRlbGV0ZSBvYmpbU3ltYm9scy5zZXR0aW5nc0NhY2hlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm91cm5lID0gcmVxdWlyZSgnQGhhcGkvYm91cm5lJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IENhc3QgPSByZXF1aXJlKCcuLi8uLi9jYXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcbmNvbnN0IFN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuZmFzdFNwbGljZSA9IGZ1bmN0aW9uIChhcnIsIGkpIHtcblxuICAgIGxldCBwb3MgPSBpO1xuICAgIHdoaWxlIChwb3MgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGFycltwb3MrK10gPSBhcnJbcG9zXTtcbiAgICB9XG5cbiAgICAtLWFyci5sZW5ndGg7XG59O1xuXG5cbmludGVybmFscy5BcnJheSA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnYXJyYXknO1xuICAgICAgICB0aGlzLl9pbm5lci5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbm5lci5vcmRlcmVkcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbm5lci5pbmNsdXNpb25zID0gW107XG4gICAgICAgIHRoaXMuX2lubmVyLmV4Y2x1c2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5uZXIucmVxdWlyZWRzID0gW107XG4gICAgICAgIHRoaXMuX2ZsYWdzLnNwYXJzZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZVswXSA9PT0gJ1snIHx8IC9eXFxzKlxcWy8udGVzdCh2YWx1ZSkpKSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBCb3VybmUucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgY29uc3Qgd2FzQXJyYXkgPSBpc0FycmF5O1xuICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0ICYmIHRoaXMuX2ZsYWdzLnNpbmdsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gW3Jlc3VsdC52YWx1ZV07XG4gICAgICAgICAgICBpc0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheSkge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LmJhc2UnLCBudWxsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lubmVyLmluY2x1c2lvbnMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLl9pbm5lci5leGNsdXNpb25zLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5faW5uZXIucmVxdWlyZWRzLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5faW5uZXIub3JkZXJlZHMubGVuZ3RoIHx8XG4gICAgICAgICAgICAhdGhpcy5fZmxhZ3Muc3BhcnNlKSB7XG5cbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBhcnJheSBzbyB0aGF0IHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIGlmICh3YXNBcnJheSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHJlc3VsdC52YWx1ZS5zbGljZSgwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuX2NoZWNrSXRlbXMocmVzdWx0LnZhbHVlLCB3YXNBcnJheSwgc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycyAmJiB3YXNBcnJheSAmJiBvcHRpb25zLmNvbnZlcnQgJiYgdGhpcy5fZmxhZ3Muc2luZ2xlKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IGEgMm5kIHBhc3MgYnkgcHV0dGluZyB0aGUgYXJyYXkgaW5zaWRlIG9uZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0Vycm9ycyA9IHJlc3VsdC5lcnJvcnM7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBbcmVzdWx0LnZhbHVlXTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5fY2hlY2tJdGVtcyhyZXN1bHQudmFsdWUsIHdhc0FycmF5LCBzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgcHJldmlvdXMgZXJyb3JzIGFuZCB2YWx1ZSBzaW5jZSB0aGlzIGRpZG4ndCB2YWxpZGF0ZSBlaXRoZXIuXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBwcmV2aW91c0Vycm9ycztcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gcmVzdWx0LnZhbHVlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgX2NoZWNrSXRlbXMoaXRlbXMsIHdhc0FycmF5LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBsZXQgZXJyb3JlZDtcblxuICAgICAgICBjb25zdCByZXF1aXJlZHMgPSB0aGlzLl9pbm5lci5yZXF1aXJlZHMuc2xpY2UoKTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZHMgPSB0aGlzLl9pbm5lci5vcmRlcmVkcy5zbGljZSgpO1xuICAgICAgICBjb25zdCBpbmNsdXNpb25zID0gWy4uLnRoaXMuX2lubmVyLmluY2x1c2lvbnMsIC4uLnJlcXVpcmVkc107XG5cbiAgICAgICAgbGV0IGlsID0gaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgIGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB3YXNBcnJheSA/IGkgOiBzdGF0ZS5rZXk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gd2FzQXJyYXkgPyBbLi4uc3RhdGUucGF0aCwgaV0gOiBzdGF0ZS5wYXRoO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShrZXksIHBhdGgsIHN0YXRlLnBhcmVudCwgc3RhdGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIGxldCByZXM7XG5cbiAgICAgICAgICAgIC8vIFNwYXJzZVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZsYWdzLnNwYXJzZSAmJiBpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5zcGFyc2UnLCBudWxsLCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGgsIHBvczogaSB9LCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeGNsdXNpb25zXG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5faW5uZXIuZXhjbHVzaW9ucy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIHJlcyA9IHRoaXMuX2lubmVyLmV4Y2x1c2lvbnNbal0uX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHt9KTsgICAgICAgICAgICAgICAgLy8gTm90IHBhc3Npbmcgb3B0aW9ucyB0byB1c2UgZGVmYXVsdHNcblxuICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKHdhc0FycmF5ID8gJ2FycmF5LmV4Y2x1ZGVzJyA6ICdhcnJheS5leGNsdWRlc1NpbmdsZScsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9yZGVyZWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbm5lci5vcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJlZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gb3JkZXJlZC5fdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyZWQuX2ZsYWdzLnN0cmlwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UoaXRlbXMsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2ZsYWdzLnNwYXJzZSAmJiByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnNwYXJzZScsIG51bGwsIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCwgcG9zOiBpIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkub3JkZXJlZCcsIHsgcG9zOiBpLCByZWFzb246IHJlcy5lcnJvcnMsIHZhbHVlOiBpdGVtIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faW5uZXIuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5Lm9yZGVyZWRMZW5ndGgnLCB7IHBvczogaSwgbGltaXQ6IHRoaXMuX2lubmVyLm9yZGVyZWRzLmxlbmd0aCB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXF1aXJlZHNcblxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRDaGVja3MgPSBbXTtcbiAgICAgICAgICAgIGxldCBqbCA9IHJlcXVpcmVkcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXF1aXJlZENoZWNrc1tqXSA9IHJlcXVpcmVkc1tqXS5fdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UocmVxdWlyZWRzLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgICAgICAgICAtLWpsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZmxhZ3Muc3BhcnNlICYmIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5zcGFyc2UnLCBudWxsLCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGgsIHBvczogaSB9LCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmNsdXNpb25zXG5cbiAgICAgICAgICAgIGNvbnN0IHN0cmlwVW5rbm93biA9IG9wdGlvbnMuc3RyaXBVbmtub3duICYmICEhb3B0aW9ucy5zdHJpcFVua25vd24uYXJyYXlzIHx8IGZhbHNlO1xuXG4gICAgICAgICAgICBqbCA9IGluY2x1c2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBqbDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jbHVzaW9uID0gaW5jbHVzaW9uc1tqXTtcblxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHJlLXJ1bm5pbmcgcmVxdWlyZWRzIHRoYXQgYWxyZWFkeSBkaWRuJ3QgbWF0Y2ggaW4gdGhlIHByZXZpb3VzIGxvb3BcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NoZWNrID0gcmVxdWlyZWRzLmluZGV4T2YoaW5jbHVzaW9uKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNDaGVjayAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVxdWlyZWRDaGVja3NbcHJldmlvdXNDaGVja107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBpbmNsdXNpb24uX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1c2lvbi5fZmxhZ3Muc3RyaXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShpdGVtcywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5fZmxhZ3Muc3BhcnNlICYmIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkuc3BhcnNlJywgbnVsbCwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoLCBwb3M6IGkgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBlcnJvciBpZiBvbmx5IG9uZSBpbmNsdXNpb24gZGVmaW5lZFxuICAgICAgICAgICAgICAgIGlmIChqbCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShpdGVtcywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3Iod2FzQXJyYXkgPyAnYXJyYXkuaW5jbHVkZXNPbmUnIDogJ2FycmF5LmluY2x1ZGVzT25lU2luZ2xlJywgeyBwb3M6IGksIHJlYXNvbjogcmVzLmVycm9ycywgdmFsdWU6IGl0ZW0gfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lubmVyLmluY2x1c2lvbnMubGVuZ3RoICYmICFpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShpdGVtcywgaSk7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcih3YXNBcnJheSA/ICdhcnJheS5pbmNsdWRlcycgOiAnYXJyYXkuaW5jbHVkZXNTaW5nbGUnLCB7IHBvczogaSwgdmFsdWU6IGl0ZW0gfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVxdWlyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbE1pc3NlZEVycm9ycyhlcnJvcnMsIHJlcXVpcmVkcywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbE9yZGVyZWRFcnJvcnMoZXJyb3JzLCBvcmRlcmVkcywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiBudWxsO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc3VwZXIuZGVzY3JpYmUoKTtcblxuICAgICAgICBpZiAodGhpcy5faW5uZXIub3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5vcmRlcmVkSXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5vcmRlcmVkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLm9yZGVyZWRJdGVtcy5wdXNoKHRoaXMuX2lubmVyLm9yZGVyZWRzW2ldLmRlc2NyaWJlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lubmVyLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uaXRlbXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLml0ZW1zLnB1c2godGhpcy5faW5uZXIuaXRlbXNbaV0uZGVzY3JpYmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzY3JpcHRpb24ucnVsZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3JpcHRpb24ucnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gZGVzY3JpcHRpb24ucnVsZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUubmFtZSA9PT0gJ2hhcycpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hcmcgPSBydWxlLmFyZy5kZXNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBpdGVtcyguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIEhvZWsuZmxhdHRlbihzY2hlbWFzKS5mb3JFYWNoKCh0eXBlLCBpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXN0RXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhc3RFcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBpbmRleCArICcuJyArIGNhc3RFcnIucGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc3RFcnIucGF0aCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc3RFcnIubWVzc2FnZSA9IGAke2Nhc3RFcnIubWVzc2FnZX0oJHtjYXN0RXJyLnBhdGh9KWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgY2FzdEVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9pbm5lci5pdGVtcy5wdXNoKHR5cGUpO1xuXG4gICAgICAgICAgICBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgICAgICBvYmouX2lubmVyLnJlcXVpcmVkcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9pbm5lci5leGNsdXNpb25zLnB1c2godHlwZS5vcHRpb25hbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5faW5uZXIuaW5jbHVzaW9ucy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG9yZGVyZWQoLi4uc2NoZW1hcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBIb2VrLmZsYXR0ZW4oc2NoZW1hcykuZm9yRWFjaCgodHlwZSwgaW5kZXgpID0+IHtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0eXBlID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoY2FzdEVycikge1xuICAgICAgICAgICAgICAgIGlmIChjYXN0RXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzdEVyci5wYXRoID0gaW5kZXggKyAnLicgKyBjYXN0RXJyLnBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXN0RXJyLm1lc3NhZ2UgPSBgJHtjYXN0RXJyLm1lc3NhZ2V9KCR7Y2FzdEVyci5wYXRofSlgO1xuICAgICAgICAgICAgICAgIHRocm93IGNhc3RFcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5faW5uZXIub3JkZXJlZHMucHVzaCh0eXBlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBtaW4obGltaXQpIHtcblxuICAgICAgICBjb25zdCBpc1JlZiA9IFJlZi5pc1JlZihsaW1pdCk7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoKE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSAmJiBsaW1pdCA+PSAwKSB8fCBpc1JlZiwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHJlZmVyZW5jZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0VW5pcXVlKCdtaW4nLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZVRvO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIShOdW1iZXIuaXNTYWZlSW50ZWdlcihjb21wYXJlVG8pICYmIGNvbXBhcmVUbyA+PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkucmVmJywgeyByZWY6IGxpbWl0LCB2YWx1ZTogY29tcGFyZVRvIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSBjb21wYXJlVG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5taW4nLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1heChsaW1pdCkge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGxpbWl0KTtcblxuICAgICAgICBIb2VrLmFzc2VydCgoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDApIHx8IGlzUmVmLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgcmVmZXJlbmNlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3RVbmlxdWUoJ21heCcsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGxldCBjb21wYXJlVG87XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdChzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICghKE51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbXBhcmVUbykgJiYgY29tcGFyZVRvID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5yZWYnLCB7IHJlZjogbGltaXQua2V5IH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBjb21wYXJlVG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5tYXgnLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxlbmd0aChsaW1pdCkge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGxpbWl0KTtcblxuICAgICAgICBIb2VrLmFzc2VydCgoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDApIHx8IGlzUmVmLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgcmVmZXJlbmNlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3RVbmlxdWUoJ2xlbmd0aCcsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGxldCBjb21wYXJlVG87XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdChzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICghKE51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbXBhcmVUbykgJiYgY29tcGFyZVRvID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5yZWYnLCB7IHJlZjogbGltaXQua2V5IH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gY29tcGFyZVRvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkubGVuZ3RoJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYXMoc2NoZW1hKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNjaGVtYSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgIGlmIChjYXN0RXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICBjYXN0RXJyLm1lc3NhZ2UgPSBgJHtjYXN0RXJyLm1lc3NhZ2V9KCR7Y2FzdEVyci5wYXRofSlgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2hhcycsIHNjaGVtYSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsdWUuc29tZSgoaXRlbSwgaWR4KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKGlkeCwgWy4uLnN0YXRlLnBhdGgsIGlkeF0sIHN0YXRlLmtleSwgc3RhdGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIXNjaGVtYS5fdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgb3B0aW9ucykuZXJyb3JzO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuTGFiZWwgPSBzY2hlbWEuX2dldExhYmVsKCk7XG4gICAgICAgICAgICBpZiAocGF0dGVybkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5Lmhhc0tub3duJywgeyBwYXR0ZXJuTGFiZWwgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkuaGFzVW5rbm93bicsIG51bGwsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdW5pcXVlKGNvbXBhcmF0b3IsIGNvbmZpZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChjb21wYXJhdG9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb21wYXJhdG9yID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycsICdjb21wYXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGNvbmZpZ3MgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZ3MgPT09ICdvYmplY3QnLCAnY29uZmlncyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgaWdub3JlVW5kZWZpbmVkOiAoY29uZmlncyAmJiBjb25maWdzLmlnbm9yZVVuZGVmaW5lZCkgfHwgZmFsc2VcbiAgICAgICAgfTtcblxuXG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnBhdGggPSBjb21wYXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCd1bmlxdWUnLCBzZXR0aW5ncywgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IHtcbiAgICAgICAgICAgICAgICBzdHJpbmc6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgbnVtYmVyOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBib29sZWFuOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgIG9iamVjdDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgY3VzdG9tOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBzZXR0aW5ncy5jb21wYXJhdG9yIHx8IEhvZWsuZGVlcEVxdWFsO1xuICAgICAgICAgICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gc2V0dGluZ3MuaWdub3JlVW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNldHRpbmdzLnBhdGggPyBIb2VrLnJlYWNoKHZhbHVlW2ldLCBzZXR0aW5ncy5wYXRoKSA6IHZhbHVlW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZHMgPSBzZXR0aW5ncy5jb21wYXJhdG9yID8gZm91bmQuY3VzdG9tIDogZm91bmRbdHlwZW9mIGl0ZW1dO1xuXG4gICAgICAgICAgICAgICAgLy8gQWxsIGF2YWlsYWJsZSB0eXBlcyBhcmUgc3VwcG9ydGVkLCBzbyBpdCdzIG5vdCBwb3NzaWJsZSB0byByZWFjaCAxMDAlIGNvdmVyYWdlIHdpdGhvdXQgaWdub3JpbmcgdGhpcyBsaW5lLlxuICAgICAgICAgICAgICAgIC8vIEkgc3RpbGwgd2FudCB0byBrZWVwIHRoZSB0ZXN0IGZvciBmdXR1cmUganMgdmVyc2lvbnMgd2l0aCBuZXcgdHlwZXMgKGVnLiBTeW1ib2wpLlxuICAgICAgICAgICAgICAgIGlmICgvKiAkbGFiOmNvdmVyYWdlOm9mZiQgKi8gcmVjb3JkcyAvKiAkbGFiOmNvdmVyYWdlOm9uJCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IHJlY29yZHMuZW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIShjdXJyZW50ID0gZW50cmllcy5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShjdXJyZW50LnZhbHVlWzBdLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKHN0YXRlLmtleSwgWy4uLnN0YXRlLnBhdGgsIGldLCBzdGF0ZS5wYXJlbnQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlUG9zOiBjdXJyZW50LnZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtjdXJyZW50LnZhbHVlWzFdXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSBzZXR0aW5ncy5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zZXQoaXRlbSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCFpZ25vcmVVbmRlZmluZWQgfHwgaXRlbSAhPT0gdW5kZWZpbmVkKSAmJiByZWNvcmRzW2l0ZW1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKHN0YXRlLmtleSwgWy4uLnN0YXRlLnBhdGgsIGldLCBzdGF0ZS5wYXJlbnQsIHN0YXRlLnJlZmVyZW5jZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogcmVjb3Jkc1tpdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtyZWNvcmRzW2l0ZW1dXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSBzZXR0aW5ncy5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS51bmlxdWUnLCBjb250ZXh0LCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3BhcnNlKGVuYWJsZWQpIHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnNwYXJzZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnNwYXJzZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHNpbmdsZShlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5zaW5nbGUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5zaW5nbGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfZmlsbE1pc3NlZEVycm9ycyhlcnJvcnMsIHJlcXVpcmVkcywgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBrbm93bk1pc3NlcyA9IFtdO1xuICAgICAgICBsZXQgdW5rbm93bk1pc3NlcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVxdWlyZWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IHJlcXVpcmVkc1tpXS5fZ2V0TGFiZWwoKTtcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgIGtub3duTWlzc2VzLnB1c2gobGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKyt1bmtub3duTWlzc2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtub3duTWlzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHVua25vd25NaXNzZXMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkQm90aCcsIHsga25vd25NaXNzZXMsIHVua25vd25NaXNzZXMgfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogc3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJywgeyBrbm93bk1pc3NlcyB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBzdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRVbmtub3ducycsIHsgdW5rbm93bk1pc3NlcyB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBzdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgX2ZpbGxPcmRlcmVkRXJyb3JzKGVycm9ycywgb3JkZXJlZHMsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcmVxdWlyZWRPcmRlcmVkcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlID0gSG9lay5yZWFjaChvcmRlcmVkc1tpXSwgJ19mbGFncy5wcmVzZW5jZScpO1xuICAgICAgICAgICAgaWYgKHByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRPcmRlcmVkcy5wdXNoKG9yZGVyZWRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1aXJlZE9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbE1pc3NlZEVycm9ycyhlcnJvcnMsIHJlcXVpcmVkT3JkZXJlZHMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQXJyYXkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLkJpbmFyeSA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnYmluYXJ5JztcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBvcHRpb25zLmNvbnZlcnQpIHtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgdGhpcy5fZmxhZ3MuZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmVycm9ycyA9IEJ1ZmZlci5pc0J1ZmZlcihyZXN1bHQudmFsdWUpID8gbnVsbCA6IHRoaXMuY3JlYXRlRXJyb3IoJ2JpbmFyeS5iYXNlJywgbnVsbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGVuY29kaW5nKGVuY29kaW5nKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLmVuY29kaW5nID09PSBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBtaW4obGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ21pbicsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdiaW5hcnkubWluJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtYXgobGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ21heCcsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdiaW5hcnkubWF4JywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBsZW5ndGgobGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2xlbmd0aCcsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYmluYXJ5Lmxlbmd0aCcsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5CaW5hcnkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIFNldDogcmVxdWlyZSgnLi4vLi4vc2V0Jylcbn07XG5cblxuaW50ZXJuYWxzLkJvb2xlYW4gPSBjbGFzcyBleHRlbmRzIEFueSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdib29sZWFuJztcbiAgICAgICAgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbm5lci50cnV0aHlTZXQgPSBuZXcgaW50ZXJuYWxzLlNldCgpO1xuICAgICAgICB0aGlzLl9pbm5lci5mYWxzeVNldCA9IG5ldyBpbnRlcm5hbHMuU2V0KCk7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB0aGlzLl9mbGFncy5pbnNlbnNpdGl2ZSA/IHZhbHVlLnRvTG93ZXJDYXNlKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IChub3JtYWxpemVkID09PSAndHJ1ZScgPyB0cnVlXG4gICAgICAgICAgICAgICAgOiAobm9ybWFsaXplZCA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LnZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9ICh0aGlzLl9pbm5lci50cnV0aHlTZXQuaGFzKHZhbHVlLCBudWxsLCBudWxsLCB0aGlzLl9mbGFncy5pbnNlbnNpdGl2ZSkgPyB0cnVlXG4gICAgICAgICAgICAgICAgOiAodGhpcy5faW5uZXIuZmFsc3lTZXQuaGFzKHZhbHVlLCBudWxsLCBudWxsLCB0aGlzLl9mbGFncy5pbnNlbnNpdGl2ZSkgPyBmYWxzZSA6IHZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuZXJyb3JzID0gKHR5cGVvZiByZXN1bHQudmFsdWUgPT09ICdib29sZWFuJykgPyBudWxsIDogdGhpcy5jcmVhdGVFcnJvcignYm9vbGVhbi5iYXNlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdHJ1dGh5KC4uLnZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFsdWVzID0gSG9lay5mbGF0dGVuKHZhbHVlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIHRydXRoeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgb2JqLl9pbm5lci50cnV0aHlTZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZmFsc3koLi4udmFsdWVzKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YWx1ZXMgPSBIb2VrLmZsYXR0ZW4odmFsdWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgZmFsc3kgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIG9iai5faW5uZXIuZmFsc3lTZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaW5zZW5zaXRpdmUoZW5hYmxlZCkge1xuXG4gICAgICAgIGNvbnN0IGluc2Vuc2l0aXZlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUgPT09IGluc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5pbnNlbnNpdGl2ZSA9IGluc2Vuc2l0aXZlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc3VwZXIuZGVzY3JpYmUoKTtcbiAgICAgICAgZGVzY3JpcHRpb24udHJ1dGh5ID0gW3RydWUsIC4uLnRoaXMuX2lubmVyLnRydXRoeVNldC52YWx1ZXMoKV07XG4gICAgICAgIGRlc2NyaXB0aW9uLmZhbHN5ID0gW2ZhbHNlLCAuLi50aGlzLl9pbm5lci5mYWxzeVNldC52YWx1ZXMoKV07XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5Cb29sZWFuKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vLi4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cbmludGVybmFscy5pc29EYXRlID0gL14oPzpbLStdXFxkezJ9KT8oPzpcXGR7NH0oPyFcXGR7Mn1cXGIpKSg/OigtPykoPzooPzowWzEtOV18MVswLTJdKSg/OlxcMSg/OlsxMl1cXGR8MFsxLTldfDNbMDFdKSk/fFcoPzpbMC00XVxcZHw1WzAtMl0pKD86LT9bMS03XSk/fCg/OjAwWzEtOV18MFsxLTldXFxkfFsxMl1cXGR7Mn18Myg/OlswLTVdXFxkfDZbMS02XSkpKSg/IVtUXSR8W1RdW1xcZF0rWiQpKD86W1RcXHNdKD86KD86KD86WzAxXVxcZHwyWzAtM10pKD86KDo/KVswLTVdXFxkKT98MjRcXDo/MDApKD86Wy4sXVxcZCsoPyE6KSk/KSg/OlxcMlswLTVdXFxkKD86Wy4sXVxcZCspPyk/KD86W1pdfCg/OlsrLV0pKD86WzAxXVxcZHwyWzAtM10pKD86Oj9bMC01XVxcZCk/KT8pPyk/JC87XG5pbnRlcm5hbHMuaW52YWxpZERhdGUgPSBuZXcgRGF0ZSgnJyk7XG5pbnRlcm5hbHMuaXNJc29EYXRlID0gKCgpID0+IHtcblxuICAgIGNvbnN0IGlzb1N0cmluZyA9IGludGVybmFscy5pc29EYXRlLnRvU3RyaW5nKCk7XG5cbiAgICByZXR1cm4gKGRhdGUpID0+IHtcblxuICAgICAgICByZXR1cm4gZGF0ZSAmJiAoZGF0ZS50b1N0cmluZygpID09PSBpc29TdHJpbmcpO1xuICAgIH07XG59KSgpO1xuXG5pbnRlcm5hbHMuRGF0ZSA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnZGF0ZSc7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmFsdWU6IChvcHRpb25zLmNvbnZlcnQgJiYgaW50ZXJuYWxzLkRhdGUudG9EYXRlKHZhbHVlLCB0aGlzLl9mbGFncy5mb3JtYXQsIHRoaXMuX2ZsYWdzLnRpbWVzdGFtcCwgdGhpcy5fZmxhZ3MubXVsdGlwbGllcikpIHx8IHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHJlc3VsdC52YWx1ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5jb252ZXJ0KSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignZGF0ZS5zdHJpY3QnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0eXBlO1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5pc0lzb0RhdGUodGhpcy5fZmxhZ3MuZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSAnaXNvRGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9mbGFncy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gYHRpbWVzdGFtcC4ke3RoaXMuX2ZsYWdzLnRpbWVzdGFtcH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdiYXNlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoYGRhdGUuJHt0eXBlfWAsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzdGF0aWMgdG9EYXRlKHZhbHVlLCBmb3JtYXQsIHRpbWVzdGFtcCwgbXVsdGlwbGllcikge1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKSkpIHtcblxuICAgICAgICAgICAgY29uc3QgaXNJc29EYXRlID0gZm9ybWF0ICYmIGludGVybmFscy5pc0lzb0RhdGUoZm9ybWF0KTtcbiAgICAgICAgICAgIGlmICghaXNJc29EYXRlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIC9eWystXT9cXGQrKFxcLlxcZCspPyQvLnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZGF0ZTtcbiAgICAgICAgICAgIGlmIChpc0lzb0RhdGUpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gZm9ybWF0LnRlc3QodmFsdWUpID8gbmV3IERhdGUodmFsdWUudG9TdHJpbmcoKSkgOiBpbnRlcm5hbHMuaW52YWxpZERhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gL15cXHMqJC8udGVzdCh2YWx1ZSkgPyBpbnRlcm5hbHMuaW52YWxpZERhdGUgOiBuZXcgRGF0ZSh2YWx1ZSAqIG11bHRpcGxpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlzbygpIHtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuZm9ybWF0ID09PSBpbnRlcm5hbHMuaXNvRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MuZm9ybWF0ID0gaW50ZXJuYWxzLmlzb0RhdGU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdGltZXN0YW1wKHR5cGUgPSAnamF2YXNjcmlwdCcpIHtcblxuICAgICAgICBjb25zdCBhbGxvd2VkID0gWydqYXZhc2NyaXB0JywgJ3VuaXgnXTtcbiAgICAgICAgSG9lay5hc3NlcnQoYWxsb3dlZC5pbmNsdWRlcyh0eXBlKSwgJ1widHlwZVwiIG11c3QgYmUgb25lIG9mIFwiJyArIGFsbG93ZWQuam9pbignXCIsIFwiJykgKyAnXCInKTtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MudGltZXN0YW1wID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy50aW1lc3RhbXAgPSB0eXBlO1xuICAgICAgICBvYmouX2ZsYWdzLm11bHRpcGxpZXIgPSB0eXBlID09PSAndW5peCcgPyAxMDAwIDogMTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfaXNJc29EYXRlKHZhbHVlKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5pc29EYXRlLnRlc3QodmFsdWUpO1xuICAgIH1cblxufTtcblxuaW50ZXJuYWxzLmNvbXBhcmUgPSBmdW5jdGlvbiAodHlwZSwgY29tcGFyZSkge1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG5cbiAgICAgICAgY29uc3QgaXNOb3cgPSBkYXRlID09PSAnbm93JztcbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYoZGF0ZSk7XG5cbiAgICAgICAgaWYgKCFpc05vdyAmJiAhaXNSZWYpIHtcbiAgICAgICAgICAgIGRhdGUgPSBpbnRlcm5hbHMuRGF0ZS50b0RhdGUoZGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydChkYXRlLCAnSW52YWxpZCBkYXRlIGZvcm1hdCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KHR5cGUsIGRhdGUsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgbGV0IGNvbXBhcmVUbztcbiAgICAgICAgICAgIGlmIChpc05vdykge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZlZhbHVlID0gZGF0ZShzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBpbnRlcm5hbHMuRGF0ZS50b0RhdGUocmVmVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb21wYXJlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2RhdGUucmVmJywgeyByZWY6IGRhdGUsIHZhbHVlOiByZWZWYWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gY29tcGFyZVRvLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZS5nZXRUaW1lKCksIGNvbXBhcmVUbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdkYXRlLicgKyB0eXBlLCB7IGxpbWl0OiBuZXcgRGF0ZShjb21wYXJlVG8pLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5EYXRlLnByb3RvdHlwZS5taW4gPSBpbnRlcm5hbHMuY29tcGFyZSgnbWluJywgKHZhbHVlLCBkYXRlKSA9PiB2YWx1ZSA+PSBkYXRlKTtcbmludGVybmFscy5EYXRlLnByb3RvdHlwZS5tYXggPSBpbnRlcm5hbHMuY29tcGFyZSgnbWF4JywgKHZhbHVlLCBkYXRlKSA9PiB2YWx1ZSA8PSBkYXRlKTtcbmludGVybmFscy5EYXRlLnByb3RvdHlwZS5ncmVhdGVyID0gaW50ZXJuYWxzLmNvbXBhcmUoJ2dyZWF0ZXInLCAodmFsdWUsIGRhdGUpID0+IHZhbHVlID4gZGF0ZSk7XG5pbnRlcm5hbHMuRGF0ZS5wcm90b3R5cGUubGVzcyA9IGludGVybmFscy5jb21wYXJlKCdsZXNzJywgKHZhbHVlLCBkYXRlKSA9PiB2YWx1ZSA8IGRhdGUpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5EYXRlKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IE9iamVjdFR5cGUgPSByZXF1aXJlKCcuLi9vYmplY3QnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uLy4uL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5GdW5jID0gY2xhc3MgZXh0ZW5kcyBPYmplY3RUeXBlLmNvbnN0cnVjdG9yIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2ZsYWdzLmZ1bmMgPSB0cnVlO1xuICAgIH1cblxuICAgIGFyaXR5KG4pIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2FyaXR5JywgbiwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignZnVuY3Rpb24uYXJpdHknLCB7IG4gfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtaW5Bcml0eShuKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+IDAsICduIG11c3QgYmUgYSBzdHJpY3QgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdtaW5Bcml0eScsIG4sIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSBuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignZnVuY3Rpb24ubWluQXJpdHknLCB7IG4gfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtYXhBcml0eShuKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+PSAwLCAnbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdtYXhBcml0eScsIG4sIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignZnVuY3Rpb24ubWF4QXJpdHknLCB7IG4gfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZWYoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3JlZicsIG51bGwsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdmdW5jdGlvbi5yZWYnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xhc3MoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2NsYXNzJywgbnVsbCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoKC9eXFxzKmNsYXNzXFxzLykudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2Z1bmN0aW9uLmNsYXNzJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5GdW5jKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5MYXp5ID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdsYXp5JztcbiAgICAgICAgdGhpcy5fZmxhZ3Mub25jZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbnVsbDtcbiAgICB9XG5cbiAgICBfaW5pdChmbiwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnNldChmbiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHNjaGVtYTtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSB0aGlzLl9jYWNoZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWUgfTtcbiAgICAgICAgICAgIGNvbnN0IGxhenkgPSB0aGlzLl9mbGFncy5sYXp5O1xuXG4gICAgICAgICAgICBpZiAoIWxhenkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignbGF6eS5iYXNlJywgbnVsbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjaGVtYSA9IGxhenkoKTtcblxuICAgICAgICAgICAgaWYgKCEoc2NoZW1hIGluc3RhbmNlb2YgQW55KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdsYXp5LnNjaGVtYScsIHsgc2NoZW1hIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3Mub25jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gc2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5fdmFsaWRhdGUodmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzZXQoZm4sIG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicsICdZb3UgbXVzdCBwcm92aWRlIGEgZnVuY3Rpb24gYXMgZmlyc3QgYXJndW1lbnQnKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSksIGBPcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0YCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVua25vd25PcHRpb25zID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrZXkpID0+ICFbJ29uY2UnXS5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHVua25vd25PcHRpb25zLmxlbmd0aCA9PT0gMCwgYE9wdGlvbnMgY29udGFpbiB1bmtub3duIGtleXM6ICR7dW5rbm93bk9wdGlvbnN9YCk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLm9uY2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5vbmNlID09PSAnYm9vbGVhbicsICdPcHRpb24gXCJvbmNlXCIgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5sYXp5ID0gZm47XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vbmNlICE9PSBvYmouX2ZsYWdzLm9uY2UpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3Mub25jZSA9IG9wdGlvbnMub25jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuTGF6eSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uLy4uL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBwcmVjaXNpb25SeDogLyg/OlxcLihcXGQrKSk/KD86W2VFXShbKy1dP1xcZCspKT8kLyxcbiAgICBub3JtYWxpemVFeHBvbmVudChzdHIpIHtcblxuICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuPzArZS8sICdlJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9lXFwrLywgJ2UnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eKC0/KTArKFsxLTldKS8sICckMSQyJyk7XG4gICAgfSxcbiAgICBub3JtYWxpemVEZWNpbWFsKHN0cikge1xuXG4gICAgICAgIHN0ciA9IHN0clxuICAgICAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC4wKyQvLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eKC0/KTArKFsxLTldKS8sICckMSQyJyk7XG5cbiAgICAgICAgaWYgKHN0ci5pbmNsdWRlcygnLicpICYmIHN0ci5lbmRzV2l0aCgnMCcpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvMCskLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5OdW1iZXIgPSBjbGFzcyBleHRlbmRzIEFueSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gJ251bWJlcic7XG4gICAgICAgIHRoaXMuX2ZsYWdzLnVuc2FmZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcy5hZGQoSW5maW5pdHkpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcy5hZGQoLUluZmluaXR5KTtcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBlcnJvcnM6IG51bGwsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBvcHRpb25zLmNvbnZlcnQpIHtcblxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKC9eXFxzKlsrLV0/XFxkKyg/OlxcLlxcZCspPyg/OmUoWystXT9cXGQrKSk/XFxzKiQvaSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2ZsYWdzLnVuc2FmZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ2UnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5ub3JtYWxpemVFeHBvbmVudChgJHtyZXN1bHQudmFsdWUgLyBNYXRoLnBvdygxMCwgbWF0Y2hlc1sxXSl9ZSR7bWF0Y2hlc1sxXX1gKSAhPT0gaW50ZXJuYWxzLm5vcm1hbGl6ZUV4cG9uZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIudW5zYWZlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUudG9TdHJpbmcoKSAhPT0gaW50ZXJuYWxzLm5vcm1hbGl6ZURlY2ltYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci51bnNhZmUnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNOdW1iZXIgPSB0eXBlb2YgcmVzdWx0LnZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ocmVzdWx0LnZhbHVlKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0ICYmICdwcmVjaXNpb24nIGluIHRoaXMuX2ZsYWdzICYmIGlzTnVtYmVyKSB7XG5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY29uY2VwdHVhbGx5IGVxdWl2YWxlbnQgdG8gdXNpbmcgdG9GaXhlZCBidXQgaXQgc2hvdWxkIGJlIG11Y2ggZmFzdGVyXG4gICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgdGhpcy5fZmxhZ3MucHJlY2lzaW9uKTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IE1hdGgucm91bmQocmVzdWx0LnZhbHVlICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc051bWJlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9mbGFncy51bnNhZmUgJiZcbiAgICAgICAgICAgICAgICAodmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCB2YWx1ZSA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIudW5zYWZlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLmJhc2UnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgbXVsdGlwbGUoYmFzZSkge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGJhc2UpO1xuXG4gICAgICAgIGlmICghaXNSZWYpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBiYXNlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShiYXNlKSwgJ211bHRpcGxlIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGJhc2UgPiAwLCAnbXVsdGlwbGUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ211bHRpcGxlJywgYmFzZSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBkaXZpc29yID0gaXNSZWYgPyBiYXNlKHN0YXRlLnJlZmVyZW5jZSB8fCBzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpIDogYmFzZTtcblxuICAgICAgICAgICAgaWYgKGlzUmVmICYmICh0eXBlb2YgZGl2aXNvciAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKGRpdmlzb3IpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIucmVmJywgeyByZWY6IGJhc2Uua2V5IH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbHVlICUgZGl2aXNvciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5tdWx0aXBsZScsIHsgbXVsdGlwbGU6IGJhc2UsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW50ZWdlcigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnaW50ZWdlcicsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICByZXR1cm4gTWF0aC50cnVuYyh2YWx1ZSkgLSB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLmludGVnZXInLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdW5zYWZlKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MudW5zYWZlID09PSBlbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy51bnNhZmUgPSBlbmFibGVkO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG5lZ2F0aXZlKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCduZWdhdGl2ZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLm5lZ2F0aXZlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBvc2l0aXZlKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdwb3NpdGl2ZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnBvc2l0aXZlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByZWNpc2lvbihsaW1pdCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSwgJ2xpbWl0IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICBIb2VrLmFzc2VydCghKCdwcmVjaXNpb24nIGluIHRoaXMuX2ZsYWdzKSwgJ3ByZWNpc2lvbiBhbHJlYWR5IHNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ3ByZWNpc2lvbicsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHBsYWNlcyA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2goaW50ZXJuYWxzLnByZWNpc2lvblJ4KTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gTWF0aC5tYXgoKHBsYWNlc1sxXSA/IHBsYWNlc1sxXS5sZW5ndGggOiAwKSAtIChwbGFjZXNbMl0gPyBwYXJzZUludChwbGFjZXNbMl0sIDEwKSA6IDApLCAwKTtcbiAgICAgICAgICAgIGlmIChkZWNpbWFscyA8PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5wcmVjaXNpb24nLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iai5fZmxhZ3MucHJlY2lzaW9uID0gbGltaXQ7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcG9ydCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgncG9ydCcsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiA2NTUzNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIucG9ydCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxufTtcblxuXG5pbnRlcm5hbHMuY29tcGFyZSA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGxpbWl0KSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYobGltaXQpO1xuICAgICAgICBjb25zdCBpc051bWJlciA9IHR5cGVvZiBsaW1pdCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGxpbWl0KTtcblxuICAgICAgICBIb2VrLmFzc2VydChpc051bWJlciB8fCBpc1JlZiwgJ2xpbWl0IG11c3QgYmUgYSBudW1iZXIgb3IgcmVmZXJlbmNlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QodHlwZSwgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgbGV0IGNvbXBhcmVUbztcbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0KHN0YXRlLnJlZmVyZW5jZSB8fCBzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGNvbXBhcmVUbyA9PT0gJ251bWJlcicgJiYgIWlzTmFOKGNvbXBhcmVUbykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIucmVmJywgeyByZWY6IGxpbWl0LmtleSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBjb21wYXJlVG8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLicgKyB0eXBlLCB7IGxpbWl0OiBjb21wYXJlVG8sIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLk51bWJlci5wcm90b3R5cGUubWluID0gaW50ZXJuYWxzLmNvbXBhcmUoJ21pbicsICh2YWx1ZSwgbGltaXQpID0+IHZhbHVlID49IGxpbWl0KTtcbmludGVybmFscy5OdW1iZXIucHJvdG90eXBlLm1heCA9IGludGVybmFscy5jb21wYXJlKCdtYXgnLCAodmFsdWUsIGxpbWl0KSA9PiB2YWx1ZSA8PSBsaW1pdCk7XG5pbnRlcm5hbHMuTnVtYmVyLnByb3RvdHlwZS5ncmVhdGVyID0gaW50ZXJuYWxzLmNvbXBhcmUoJ2dyZWF0ZXInLCAodmFsdWUsIGxpbWl0KSA9PiB2YWx1ZSA+IGxpbWl0KTtcbmludGVybmFscy5OdW1iZXIucHJvdG90eXBlLmxlc3MgPSBpbnRlcm5hbHMuY29tcGFyZSgnbGVzcycsICh2YWx1ZSwgbGltaXQpID0+IHZhbHVlIDwgbGltaXQpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5OdW1iZXIoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm91cm5lID0gcmVxdWlyZSgnQGhhcGkvYm91cm5lJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgVG9wbyA9IHJlcXVpcmUoJ0BoYXBpL3RvcG8nKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IENhc3QgPSByZXF1aXJlKCcuLi8uLi9jYXN0Jyk7XG5jb25zdCBTdGF0ZSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLk9iamVjdCA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnb2JqZWN0JztcbiAgICAgICAgdGhpcy5faW5uZXIuY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICB0aGlzLl9pbm5lci5yZW5hbWVzID0gW107XG4gICAgICAgIHRoaXMuX2lubmVyLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbm5lci5wYXR0ZXJucyA9IFtdO1xuICAgIH1cblxuICAgIF9pbml0KC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gYXJncy5sZW5ndGggPyB0aGlzLmtleXMoLi4uYXJncykgOiB0aGlzO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGxldCB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IGZpbmlzaCA9ICgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZVswXSA9PT0gJ3snIHx8IC9eXFxzKlxcey8udGVzdCh2YWx1ZSkpKSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJvdXJuZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl9mbGFncy5mdW5jID8gJ2Z1bmN0aW9uJyA6ICdvYmplY3QnO1xuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09IHR5cGUgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IodHlwZSArICcuYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgaWYgdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzIHRvIHRlc3RcblxuICAgICAgICBpZiAoIXRoaXMuX2lubmVyLnJlbmFtZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhdGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXRoaXMuX2lubmVyLmNoaWxkcmVuICYmICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aCkge1xuXG4gICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSB0YXJnZXQgaXMgYSBsb2NhbCBjb3B5IChwYXJzZWQpIG9yIHNoYWxsb3cgY29weVxuXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRhcmdldC5wcm90b3R5cGUgPSBIb2VrLmNsb25lKHZhbHVlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3ZhbHVlS2V5c1tpXV0gPSB2YWx1ZVt2YWx1ZUtleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5hbWUga2V5c1xuXG4gICAgICAgIGNvbnN0IHJlbmFtZWQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5yZW5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByZW5hbWUgPSB0aGlzLl9pbm5lci5yZW5hbWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAocmVuYW1lLmlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFRhcmdldEtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0S2V5cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVuYW1lLmZyb20udGVzdCh0YXJnZXRLZXlzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFRhcmdldEtleXMucHVzaCh0YXJnZXRLZXlzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFVuZGVmaW5lZCA9IG1hdGNoZWRUYXJnZXRLZXlzLmV2ZXJ5KChrZXkpID0+IHRhcmdldFtrZXldID09PSB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGlmIChyZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgJiYgYWxsVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lZFtyZW5hbWUudG9dKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5yZWdleC5tdWx0aXBsZScsIHsgZnJvbTogbWF0Y2hlZFRhcmdldEtleXMsIHRvOiByZW5hbWUudG8gfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHJlbmFtZS50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbmFtZS5vcHRpb25zLm92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICFyZW5hbWVkW3JlbmFtZS50b10pIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLnJlZ2V4Lm92ZXJyaWRlJywgeyBmcm9tOiBtYXRjaGVkVGFyZ2V0S2V5cywgdG86IHJlbmFtZS50byB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYWxsVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcmVuYW1lLnRvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtyZW5hbWUudG9dID0gdGFyZ2V0W21hdGNoZWRUYXJnZXRLZXlzW21hdGNoZWRUYXJnZXRLZXlzLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZW5hbWVkW3JlbmFtZS50b10gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZWRUYXJnZXRLZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W21hdGNoZWRUYXJnZXRLZXlzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgJiYgdGFyZ2V0W3JlbmFtZS5mcm9tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMubXVsdGlwbGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lZFtyZW5hbWUudG9dKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5tdWx0aXBsZScsIHsgZnJvbTogcmVuYW1lLmZyb20sIHRvOiByZW5hbWUudG8gfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHJlbmFtZS50bykgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbmFtZS5vcHRpb25zLm92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICFyZW5hbWVkW3JlbmFtZS50b10pIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm92ZXJyaWRlJywgeyBmcm9tOiByZW5hbWUuZnJvbSwgdG86IHJlbmFtZS50byB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W3JlbmFtZS5mcm9tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcmVuYW1lLnRvXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtyZW5hbWUudG9dID0gdGFyZ2V0W3JlbmFtZS5mcm9tXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZW5hbWVkW3JlbmFtZS50b10gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5hbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3JlbmFtZS5mcm9tXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBzY2hlbWFcblxuICAgICAgICBpZiAoIXRoaXMuX2lubmVyLmNoaWxkcmVuICYmICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICF0aGlzLl9pbm5lci5wYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgICAgICF0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVucHJvY2Vzc2VkID0gbmV3IFNldChPYmplY3Qua2V5cyh0YXJnZXQpKTtcblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmlwUHJvcHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5faW5uZXIuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0YXJnZXRba2V5XTtcblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShrZXksIFsuLi5zdGF0ZS5wYXRoLCBrZXldLCB0YXJnZXQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGQuc2NoZW1hLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QuY2hpbGQnLCB7IGtleSwgY2hpbGQ6IGNoaWxkLnNjaGVtYS5fZ2V0TGFiZWwoa2V5KSwgcmVhc29uOiByZXN1bHQuZXJyb3JzIH0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5zY2hlbWEuX2ZsYWdzLnN0cmlwIHx8IChyZXN1bHQudmFsdWUgPT09IHVuZGVmaW5lZCAmJiByZXN1bHQudmFsdWUgIT09IGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcFByb3BzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcmVzdWx0LmZpbmFsVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlwUHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3N0cmlwUHJvcHNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5rbm93biBrZXlzXG5cbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkLnNpemUgJiYgdGhpcy5faW5uZXIucGF0dGVybnMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShrZXksIFsuLi5zdGF0ZS5wYXRoLCBrZXldLCB0YXJnZXQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtrZXldO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5faW5uZXIucGF0dGVybnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ucmVnZXggP1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybi5yZWdleC50ZXN0KGtleSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIXBhdHRlcm4uc2NoZW1hLl92YWxpZGF0ZShrZXksIHN0YXRlLCB7IC4uLm9wdGlvbnMsIGFib3J0RWFybHk6dHJ1ZSB9KS5lcnJvcnMpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdHRlcm4ucnVsZS5fdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5jaGlsZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZDogcGF0dGVybi5ydWxlLl9nZXRMYWJlbChrZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdC5lcnJvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBsb2NhbFN0YXRlLCBvcHRpb25zKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkLnNpemUgJiYgKHRoaXMuX2lubmVyLmNoaWxkcmVuIHx8IHRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucy5zdHJpcFVua25vd24gJiYgdGhpcy5fZmxhZ3MuYWxsb3dVbmtub3duICE9PSB0cnVlKSB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2tpcEZ1bmN0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gb3B0aW9ucy5zdHJpcFVua25vd25cbiAgICAgICAgICAgICAgICAgICAgPyAob3B0aW9ucy5zdHJpcFVua25vd24gPT09IHRydWUgPyB0cnVlIDogISFvcHRpb25zLnN0cmlwVW5rbm93bi5vYmplY3RzKVxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlO1xuXG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHRoaXMuX2ZsYWdzLmFsbG93VW5rbm93biAhPT0gdW5kZWZpbmVkID8gIXRoaXMuX2ZsYWdzLmFsbG93VW5rbm93biA6ICFvcHRpb25zLmFsbG93VW5rbm93bikpIHtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdW5wcm9jZXNzZWRLZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LmFsbG93VW5rbm93bicsIHsgY2hpbGQ6IHVucHJvY2Vzc2VkS2V5LCB2YWx1ZTogdGFyZ2V0W3VucHJvY2Vzc2VkS2V5XSB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHVucHJvY2Vzc2VkS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogWy4uLnN0YXRlLnBhdGgsIHVucHJvY2Vzc2VkS2V5XVxuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLCB7fSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGRlcGVuZGVuY2llc1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBkZXAgPSB0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXNbaV07XG4gICAgICAgICAgICBjb25zdCBoYXNLZXkgPSBkZXAua2V5ICE9PSBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRLZXkgPSBoYXNLZXkgJiYgZGVwLmtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IGhhc0tleSA/IG5ldyBTdGF0ZShzcGxpdEtleVtzcGxpdEtleS5sZW5ndGggLSAxXSwgWy4uLnN0YXRlLnBhdGgsIC4uLnNwbGl0S2V5XSkgOiBuZXcgU3RhdGUobnVsbCwgc3RhdGUucGF0aCk7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBpbnRlcm5hbHNbZGVwLnR5cGVdLmNhbGwodGhpcywgZGVwLmtleSwgaGFzS2V5ICYmIEhvZWsucmVhY2godGFyZ2V0LCBkZXAua2V5LCB7IGZ1bmN0aW9uczogdHJ1ZSB9KSwgZGVwLnBlZXJzLCB0YXJnZXQsIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9ycy5FcnIpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICB9XG5cbiAgICBrZXlzKHNjaGVtYSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc2NoZW1hID09PSAnb2JqZWN0JywgJ09iamVjdCBzY2hlbWEgbXVzdCBiZSBhIHZhbGlkIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCghc2NoZW1hIHx8ICEoc2NoZW1hIGluc3RhbmNlb2YgQW55KSwgJ09iamVjdCBzY2hlbWEgY2Fubm90IGJlIGEgam9pIHNjaGVtYScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgb2JqLl9pbm5lci5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmouX2lubmVyLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9wbyA9IG5ldyBUb3BvKCk7XG4gICAgICAgIGlmIChvYmouX2lubmVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5faW5uZXIuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5faW5uZXIuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB0aGUga2V5IGlmIHdlIGFyZSBub3QgZ29pbmcgdG8gcmVwbGFjZSBpdCBsYXRlclxuICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4uaW5jbHVkZXMoY2hpbGQua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0b3BvLmFkZChjaGlsZCwgeyBhZnRlcjogY2hpbGQuX3JlZnMsIGdyb3VwOiBjaGlsZC5rZXkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHNjaGVtYVtrZXldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0ID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIHRvcG8uYWRkKHsga2V5LCBzY2hlbWE6IGNhc3QgfSwgeyBhZnRlcjogY2FzdC5fcmVmcywgZ3JvdXA6IGtleSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXN0RXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhc3RFcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBrZXkgKyAnLicgKyBjYXN0RXJyLnBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBrZXk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgY2FzdEVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5faW5uZXIuY2hpbGRyZW4gPSB0b3BvLm5vZGVzO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYXBwZW5kKHNjaGVtYSkge1xuICAgICAgICAvLyBTa2lwIGFueSBjaGFuZ2VzXG4gICAgICAgIGlmIChzY2hlbWEgPT09IG51bGwgfHwgc2NoZW1hID09PSB1bmRlZmluZWQgfHwgT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhzY2hlbWEpO1xuICAgIH1cblxuICAgIHVua25vd24oYWxsb3cpIHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGFsbG93ICE9PSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuYWxsb3dVbmtub3duID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MuYWxsb3dVbmtub3duID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbGVuZ3RoKGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDAsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdsZW5ndGgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QubGVuZ3RoJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtaW4obGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ21pbicsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm1pbicsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF4KGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDAsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdtYXgnLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA8PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5tYXgnLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBhdHRlcm4ocGF0dGVybiwgc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWdFeHAgPSBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgICAgICBIb2VrLmFzc2VydChpc1JlZ0V4cCB8fCBwYXR0ZXJuIGluc3RhbmNlb2YgQW55LCAncGF0dGVybiBtdXN0IGJlIGEgcmVnZXggb3Igc2NoZW1hJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCBydWxlJyk7XG5cbiAgICAgICAgaWYgKGlzUmVnRXhwKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNjaGVtYSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgIGlmIChjYXN0RXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICBjYXN0RXJyLm1lc3NhZ2UgPSBgJHtjYXN0RXJyLm1lc3NhZ2V9KCR7Y2FzdEVyci5wYXRofSlgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoaXNSZWdFeHApIHtcbiAgICAgICAgICAgIG9iai5faW5uZXIucGF0dGVybnMucHVzaCh7IHJlZ2V4OiBwYXR0ZXJuLCBydWxlOiBzY2hlbWEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouX2lubmVyLnBhdHRlcm5zLnB1c2goeyBzY2hlbWE6IHBhdHRlcm4sIHJ1bGU6IHNjaGVtYSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc2NoZW1hKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdzY2hlbWEnLCBudWxsLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFueSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5zY2hlbWEnLCBudWxsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHdpdGgoa2V5LCBwZWVycykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3VtZW50cy5sZW5ndGggPT09IDIsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMsIGV4cGVjdGVkIDIuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3koJ3dpdGgnLCBrZXksIHBlZXJzKTtcbiAgICB9XG5cbiAgICB3aXRob3V0KGtleSwgcGVlcnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzLCBleHBlY3RlZCAyLicpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBlbmRlbmN5KCd3aXRob3V0Jywga2V5LCBwZWVycyk7XG4gICAgfVxuXG4gICAgeG9yKC4uLnBlZXJzKSB7XG5cbiAgICAgICAgcGVlcnMgPSBIb2VrLmZsYXR0ZW4ocGVlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgneG9yJywgbnVsbCwgcGVlcnMpO1xuICAgIH1cblxuICAgIG94b3IoLi4ucGVlcnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgnb3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICB9XG5cbiAgICBvciguLi5wZWVycykge1xuXG4gICAgICAgIHBlZXJzID0gSG9lay5mbGF0dGVuKHBlZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3koJ29yJywgbnVsbCwgcGVlcnMpO1xuICAgIH1cblxuICAgIGFuZCguLi5wZWVycykge1xuXG4gICAgICAgIHBlZXJzID0gSG9lay5mbGF0dGVuKHBlZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3koJ2FuZCcsIG51bGwsIHBlZXJzKTtcbiAgICB9XG5cbiAgICBuYW5kKC4uLnBlZXJzKSB7XG5cbiAgICAgICAgcGVlcnMgPSBIb2VrLmZsYXR0ZW4ocGVlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgnbmFuZCcsIG51bGwsIHBlZXJzKTtcbiAgICB9XG5cbiAgICByZXF1aXJlZEtleXMoLi4uY2hpbGRyZW4pIHtcblxuICAgICAgICBjaGlsZHJlbiA9IEhvZWsuZmxhdHRlbihjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGNoaWxkcmVuLCAncmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBvcHRpb25hbEtleXMoLi4uY2hpbGRyZW4pIHtcblxuICAgICAgICBjaGlsZHJlbiA9IEhvZWsuZmxhdHRlbihjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGNoaWxkcmVuLCAnb3B0aW9uYWwnKTtcbiAgICB9XG5cbiAgICBmb3JiaWRkZW5LZXlzKC4uLmNoaWxkcmVuKSB7XG5cbiAgICAgICAgY2hpbGRyZW4gPSBIb2VrLmZsYXR0ZW4oY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseUZ1bmN0aW9uVG9DaGlsZHJlbihjaGlsZHJlbiwgJ2ZvcmJpZGRlbicpO1xuICAgIH1cblxuICAgIHJlbmFtZShmcm9tLCB0bywgb3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCBmcm9tIGluc3RhbmNlb2YgUmVnRXhwLCAnUmVuYW1lIG1pc3NpbmcgdGhlIGZyb20gYXJndW1lbnQnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHRvID09PSAnc3RyaW5nJywgJ1JlbmFtZSBtaXNzaW5nIHRoZSB0byBhcmd1bWVudCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0byAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUga2V5IHRvIHNhbWUgbmFtZTonLCBmcm9tKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLnJlbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMuX2lubmVyLnJlbmFtZXNbaV0uZnJvbSAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUgdGhlIHNhbWUga2V5IG11bHRpcGxlIHRpbWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgb2JqLl9pbm5lci5yZW5hbWVzLnB1c2goe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgb3B0aW9uczogSG9lay5hcHBseVRvRGVmYXVsdHMoaW50ZXJuYWxzLnJlbmFtZURlZmF1bHRzLCBvcHRpb25zIHx8IHt9KSxcbiAgICAgICAgICAgIGlzUmVnRXhwOiBmcm9tIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYXBwbHlGdW5jdGlvblRvQ2hpbGRyZW4oY2hpbGRyZW4sIGZuLCBhcmdzID0gW10sIHJvb3QpIHtcblxuICAgICAgICBjaGlsZHJlbiA9IFtdLmNvbmNhdChjaGlsZHJlbik7XG4gICAgICAgIEhvZWsuYXNzZXJ0KGNoaWxkcmVuLmxlbmd0aCA+IDAsICdleHBlY3RlZCBhdCBsZWFzdCBvbmUgY2hpbGRyZW4nKTtcblxuICAgICAgICBjb25zdCBncm91cGVkQ2hpbGRyZW4gPSBpbnRlcm5hbHMuZ3JvdXBDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgIGxldCBvYmo7XG5cbiAgICAgICAgaWYgKCcnIGluIGdyb3VwZWRDaGlsZHJlbikge1xuICAgICAgICAgICAgb2JqID0gdGhpc1tmbl0oLi4uYXJncyk7XG4gICAgICAgICAgICBkZWxldGUgZ3JvdXBlZENoaWxkcmVuWycnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouX2lubmVyLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByb290ID0gcm9vdCA/IChyb290ICsgJy4nKSA6ICcnO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5faW5uZXIuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5faW5uZXIuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cGVkQ2hpbGRyZW5bY2hpbGQua2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgICAgICAgICBvYmouX2lubmVyLmNoaWxkcmVuW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjaGlsZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVmczogY2hpbGQuX3JlZnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IGNoaWxkLnNjaGVtYS5hcHBseUZ1bmN0aW9uVG9DaGlsZHJlbihncm91cCwgZm4sIGFyZ3MsIHJvb3QgKyBjaGlsZC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdyb3VwZWRDaGlsZHJlbltjaGlsZC5rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IE9iamVjdC5rZXlzKGdyb3VwZWRDaGlsZHJlbik7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHJlbWFpbmluZy5sZW5ndGggPT09IDAsICd1bmtub3duIGtleShzKScsIHJlbWFpbmluZy5qb2luKCcsICcpKTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9kZXBlbmRlbmN5KHR5cGUsIGtleSwgcGVlcnMpIHtcblxuICAgICAgICBwZWVycyA9IFtdLmNvbmNhdChwZWVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBwZWVyc1tpXSA9PT0gJ3N0cmluZycsIHR5cGUsICdwZWVycyBtdXN0IGJlIGEgc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9pbm5lci5kZXBlbmRlbmNpZXMucHVzaCh7IHR5cGUsIGtleSwgcGVlcnMgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoc2hhbGxvdykge1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc3VwZXIuZGVzY3JpYmUoKTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRpb24ucnVsZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3JpcHRpb24ucnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gZGVzY3JpcHRpb24ucnVsZXNbaV07XG4gICAgICAgICAgICAgICAgLy8gQ292ZXJhZ2Ugb2ZmIGZvciBmdXR1cmUtcHJvb2YgZGVzY3JpcHRpb25zLCBvbmx5IG9iamVjdCgpLmFzc2VydCgpIGlzIHVzZSByaWdodCBub3dcbiAgICAgICAgICAgICAgICBpZiAoLyogJGxhYjpjb3ZlcmFnZTpvZmYkICovcnVsZS5hcmcgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJ1bGUuYXJnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLmFyZy5zY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hcmcucmVmIC8qICRsYWI6Y292ZXJhZ2U6b24kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBydWxlLmFyZy5zY2hlbWEuZGVzY3JpYmUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogcnVsZS5hcmcucmVmLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgICFzaGFsbG93KSB7XG5cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmNoaWxkcmVuID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9pbm5lci5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5jaGlsZHJlbltjaGlsZC5rZXldID0gY2hpbGQuc2NoZW1hLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uZGVwZW5kZW5jaWVzID0gSG9lay5jbG9uZSh0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24ucGF0dGVybnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl9pbm5lci5wYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5yZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5wYXR0ZXJucy5wdXNoKHsgcmVnZXg6IHBhdHRlcm4ucmVnZXgudG9TdHJpbmcoKSwgcnVsZTogcGF0dGVybi5ydWxlLmRlc2NyaWJlKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5wYXR0ZXJucy5wdXNoKHsgc2NoZW1hOiBwYXR0ZXJuLnNjaGVtYS5kZXNjcmliZSgpLCBydWxlOiBwYXR0ZXJuLnJ1bGUuZGVzY3JpYmUoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIucmVuYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5yZW5hbWVzID0gSG9lay5jbG9uZSh0aGlzLl9pbm5lci5yZW5hbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBhc3NlcnQocmVmLCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICByZWYgPSBDYXN0LnJlZihyZWYpO1xuICAgICAgICBIb2VrLmFzc2VydChyZWYuaXNDb250ZXh0IHx8IHJlZi5kZXB0aCA+IDEsICdDYW5ub3QgdXNlIGFzc2VydGlvbnMgZm9yIHJvb3QgbGV2ZWwgcmVmZXJlbmNlcyAtIHVzZSBkaXJlY3Qga2V5IHJ1bGVzIGluc3RlYWQnKTtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ3Bhc3MgdGhlIGFzc2VydGlvbiB0ZXN0JztcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnLCAnTWVzc2FnZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNjaGVtYSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgIGlmIChjYXN0RXJyLmhhc093blByb3BlcnR5KCdwYXRoJykpIHtcbiAgICAgICAgICAgICAgICBjYXN0RXJyLm1lc3NhZ2UgPSBgJHtjYXN0RXJyLm1lc3NhZ2V9KCR7Y2FzdEVyci5wYXRofSlgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5ID0gcmVmLnBhdGhbcmVmLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhdGggPSByZWYucGF0aC5qb2luKCcuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2Fzc2VydCcsIHsgc2NoZW1hLCByZWYgfSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3ZhbGlkYXRlKHJlZih2YWx1ZSksIG51bGwsIG9wdGlvbnMsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IG5ldyBTdGF0ZShrZXksIHJlZi5wYXRoLCBzdGF0ZS5wYXJlbnQsIHN0YXRlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LmFzc2VydCcsIHsgcmVmOiBwYXRoLCBtZXNzYWdlIH0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0eXBlKGNvbnN0cnVjdG9yLCBuYW1lID0gY29uc3RydWN0b3IubmFtZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBjb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJywgJ3R5cGUgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHR5cGVEYXRhID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGN0b3I6IGNvbnN0cnVjdG9yXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3R5cGUnLCB0eXBlRGF0YSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC50eXBlJywgeyB0eXBlOiB0eXBlRGF0YS5uYW1lLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJlbmFtZURlZmF1bHRzID0ge1xuICAgIGFsaWFzOiBmYWxzZSwgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvbGQgdmFsdWUgaW4gcGxhY2VcbiAgICBtdWx0aXBsZTogZmFsc2UsICAgICAgICAgICAgICAgIC8vIEFsbG93IHJlbmFtaW5nIG11bHRpcGxlIGtleXMgaW50byB0aGUgc2FtZSB0YXJnZXRcbiAgICBvdmVycmlkZTogZmFsc2UgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBhbiBleGlzdGluZyBrZXlcbn07XG5cblxuaW50ZXJuYWxzLmdyb3VwQ2hpbGRyZW4gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcblxuICAgIGNoaWxkcmVuLnNvcnQoKTtcblxuICAgIGNvbnN0IGdyb3VwZWQgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJywgJ2NoaWxkcmVuIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICBjb25zdCBncm91cCA9IGNoaWxkLnNwbGl0KCcuJylbMF07XG4gICAgICAgIGNvbnN0IGNoaWxkR3JvdXAgPSBncm91cGVkW2dyb3VwXSA9IChncm91cGVkW2dyb3VwXSB8fCBbXSk7XG4gICAgICAgIGNoaWxkR3JvdXAucHVzaChjaGlsZC5zdWJzdHJpbmcoZ3JvdXAubGVuZ3RoICsgMSkpO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cGVkO1xufTtcblxuXG5pbnRlcm5hbHMua2V5c1RvTGFiZWxzID0gZnVuY3Rpb24gKHNjaGVtYSwga2V5cykge1xuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBzY2hlbWEuX2lubmVyLmNoaWxkcmVuO1xuXG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICBjb25zdCBmaW5kTGFiZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hpbmdDaGlsZCA9IHNjaGVtYS5fY3VycmVudEpvaS5yZWFjaChzY2hlbWEsIGtleSk7XG4gICAgICAgIHJldHVybiBtYXRjaGluZ0NoaWxkID8gbWF0Y2hpbmdDaGlsZC5fZ2V0TGFiZWwoa2V5KSA6IGtleTtcbiAgICB9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubWFwKGZpbmRMYWJlbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRMYWJlbChrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLndpdGggPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgY29uc3QgcGVlciA9IHBlZXJzW2ldO1xuICAgICAgICBjb25zdCBrZXlzRXhpc3QgPSBIb2VrLnJlYWNoKHBhcmVudCwgcGVlciwgeyBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIGlmIChrZXlzRXhpc3QgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LndpdGgnLCB7XG4gICAgICAgICAgICAgICAgbWFpbjoga2V5LFxuICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywga2V5KSxcbiAgICAgICAgICAgICAgICBwZWVyLFxuICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcGVlcilcbiAgICAgICAgICAgIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLndpdGhvdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC53aXRob3V0Jywge1xuICAgICAgICAgICAgICAgIG1haW46IGtleSxcbiAgICAgICAgICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIGtleSksXG4gICAgICAgICAgICAgICAgcGVlcixcbiAgICAgICAgICAgICAgICBwZWVyV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHBlZXIpXG4gICAgICAgICAgICB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy54b3IgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwZWVycykgfTtcblxuICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm1pc3NpbmcnLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5wcmVzZW50ID0gcHJlc2VudDtcbiAgICBjb250ZXh0LnByZXNlbnRXaXRoTGFiZWxzID0gaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwcmVzZW50KTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QueG9yJywgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMub3hvciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGVlciA9IHBlZXJzW2ldO1xuICAgICAgICBjb25zdCBrZXlzRXhpc3QgPSBIb2VrLnJlYWNoKHBhcmVudCwgcGVlciwgeyBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIGlmIChrZXlzRXhpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwcmVzZW50Lmxlbmd0aCB8fFxuICAgICAgICBwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0geyBwZWVycywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHBlZXJzKSB9O1xuICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgY29udGV4dC5wcmVzZW50V2l0aExhYmVscyA9IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcHJlc2VudCk7XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm94b3InLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5vciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwZWVyID0gcGVlcnNbaV07XG4gICAgICAgIGNvbnN0IGtleXNFeGlzdCA9IEhvZWsucmVhY2gocGFyZW50LCBwZWVyLCB7IGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGtleXNFeGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm1pc3NpbmcnLCB7XG4gICAgICAgIHBlZXJzLFxuICAgICAgICBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcGVlcnMpXG4gICAgfSwgc3RhdGUsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuYW5kID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHBlZXJzLCBwYXJlbnQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgIGNvbnN0IGNvdW50ID0gcGVlcnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBjb25zdCBwZWVyID0gcGVlcnNbaV07XG4gICAgICAgIGNvbnN0IGtleXNFeGlzdCA9IEhvZWsucmVhY2gocGFyZW50LCBwZWVyLCB7IGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGtleXNFeGlzdCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChwZWVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFvbiA9IChtaXNzaW5nLmxlbmd0aCA9PT0gY291bnQgfHwgcHJlc2VudC5sZW5ndGggPT09IGNvdW50KTtcblxuICAgIGlmICghYW9uKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5hbmQnLCB7XG4gICAgICAgICAgICBwcmVzZW50LFxuICAgICAgICAgICAgcHJlc2VudFdpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcHJlc2VudCksXG4gICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgbWlzc2luZ1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgbWlzc2luZylcbiAgICAgICAgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLm5hbmQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbWFpbiA9IHBlZXJzWzBdO1xuICAgIGNvbnN0IHZhbHVlcyA9IHBlZXJzLnNsaWNlKDEpO1xuICAgIGNvbnN0IGFsbFByZXNlbnQgPSAocHJlc2VudC5sZW5ndGggPT09IHBlZXJzLmxlbmd0aCk7XG4gICAgcmV0dXJuIGFsbFByZXNlbnQgPyB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QubmFuZCcsIHtcbiAgICAgICAgbWFpbixcbiAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBtYWluKSxcbiAgICAgICAgcGVlcnM6IHZhbHVlcyxcbiAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHZhbHVlcylcbiAgICB9LCBzdGF0ZSwgb3B0aW9ucykgOiBudWxsO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuT2JqZWN0KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgcGF0aCwgcGFyZW50LCByZWZlcmVuY2UpIHtcblxuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IE5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuXG5jb25zdCBBZGRyZXNzID0gcmVxdWlyZSgnQGhhcGkvYWRkcmVzcycpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcbmNvbnN0IEpvaURhdGUgPSByZXF1aXJlKCcuLi9kYXRlJyk7XG5cbmNvbnN0IFVyaSA9IHJlcXVpcmUoJy4vdXJpJyk7XG5jb25zdCBJcCA9IHJlcXVpcmUoJy4vaXAnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdXJpUmVnZXg6IFVyaS5jcmVhdGVVcmlSZWdleCgpLFxuICAgIGlwUmVnZXg6IElwLmNyZWF0ZUlwUmVnZXgoWydpcHY0JywgJ2lwdjYnLCAnaXB2ZnV0dXJlJ10sICdvcHRpb25hbCcpLFxuICAgIGd1aWRCcmFja2V0czoge1xuICAgICAgICAneyc6ICd9JywgJ1snOiAnXScsICcoJzogJyknLCAnJzogJydcbiAgICB9LFxuICAgIGd1aWRWZXJzaW9uczoge1xuICAgICAgICB1dWlkdjE6ICcxJyxcbiAgICAgICAgdXVpZHYyOiAnMicsXG4gICAgICAgIHV1aWR2MzogJzMnLFxuICAgICAgICB1dWlkdjQ6ICc0JyxcbiAgICAgICAgdXVpZHY1OiAnNSdcbiAgICB9LFxuICAgIGNpZHJQcmVzZW5jZXM6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgbm9ybWFsaXphdGlvbkZvcm1zOiBbJ05GQycsICdORkQnLCAnTkZLQycsICdORktEJ11cbn07XG5cblxuaW50ZXJuYWxzLlN0cmluZyA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnc3RyaW5nJztcbiAgICAgICAgdGhpcy5faW52YWxpZHMuYWRkKCcnKTtcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vcm1hbGl6ZSh0aGlzLl9mbGFncy5ub3JtYWxpemUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3MuY2FzZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHRoaXMuX2ZsYWdzLmNhc2UgPT09ICd1cHBlcicgPyB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpIDogdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy50cmltKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbm5lci5yZXBsYWNlbWVudHMpIHtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIucmVwbGFjZW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gdGhpcy5faW5uZXIucmVwbGFjZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVwbGFjZW1lbnQucGF0dGVybiwgcmVwbGFjZW1lbnQucmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnRydW5jYXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90ZXN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gdGhpcy5fdGVzdHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0Lm5hbWUgPT09ICdtYXgnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIHRlc3QuYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3MuYnl0ZUFsaWduZWQgJiYgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYDAke3ZhbHVlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlcnJvcnM6ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IG51bGwgOiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5zZW5zaXRpdmUoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5pbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgY3JlZGl0Q2FyZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnY3JlZGl0Q2FyZCcsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgbGV0IG11bCA9IDE7XG5cbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gdmFsdWUuY2hhckF0KGkpICogbXVsO1xuICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIChjaGFyIC0gKGNoYXIgPiA5KSAqIDkpO1xuICAgICAgICAgICAgICAgIG11bCA9IG11bCBeIDM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gKHN1bSAlIDEwID09PSAwKSAmJiAoc3VtID4gMCk7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2sgPyB2YWx1ZSA6IHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5jcmVkaXRDYXJkJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlZ2V4KHBhdHRlcm4sIHBhdHRlcm5PcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCwgJ3BhdHRlcm4gbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICBIb2VrLmFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuXG4gICAgICAgIGNvbnN0IHBhdHRlcm5PYmplY3QgPSB7IHBhdHRlcm4gfTtcblxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm5PcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVybk9iamVjdC5uYW1lID0gcGF0dGVybk9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhdHRlcm5PcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcGF0dGVybk9iamVjdC5pbnZlcnQgPSAhIXBhdHRlcm5PcHRpb25zLmludmVydDtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm5PcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuT2JqZWN0Lm5hbWUgPSBwYXR0ZXJuT3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gWydzdHJpbmcucmVnZXgnLCBwYXR0ZXJuT2JqZWN0LmludmVydCA/ICcuaW52ZXJ0JyA6ICcnLCBwYXR0ZXJuT2JqZWN0Lm5hbWUgPyAnLm5hbWUnIDogJy5iYXNlJ10uam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3JlZ2V4JywgcGF0dGVybk9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSBwYXR0ZXJuT2JqZWN0LnBhdHRlcm4udGVzdCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXR0ZXJuTWF0Y2ggXiBwYXR0ZXJuT2JqZWN0LmludmVydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoZXJyb3JDb2RlLCB7IG5hbWU6IHBhdHRlcm5PYmplY3QubmFtZSwgcGF0dGVybjogcGF0dGVybk9iamVjdC5wYXR0ZXJuLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFscGhhbnVtKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdhbHBoYW51bScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoL15bYS16QS1aMC05XSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5hbHBoYW51bScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0b2tlbigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgndG9rZW4nLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKC9eXFx3KyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnRva2VuJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGVtYWlsKHZhbGlkYXRpb25PcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKHZhbGlkYXRpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgdmFsaWRhdGlvbk9wdGlvbnMgPT09ICdvYmplY3QnLCAnZW1haWwgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXG4gICAgICAgICAgICAvLyBNaWdyYXRpb24gdmFsaWRhdGlvbiBmb3IgdW5zdXBwb3J0ZWQgb3B0aW9uc1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWxpZGF0aW9uT3B0aW9ucy5jaGVja0ROUyA9PT0gdW5kZWZpbmVkLCAnY2hlY2tETlMgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLmVycm9yTGV2ZWwgPT09IHVuZGVmaW5lZCwgJ2Vycm9yTGV2ZWwgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLm1pbkRvbWFpbkF0b21zID09PSB1bmRlZmluZWQsICdtaW5Eb21haW5BdG9tcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCwgdXNlIG1pbkRvbWFpblNlZ21lbnRzIGluc3RlYWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLnRsZEJsYWNrbGlzdCA9PT0gdW5kZWZpbmVkLCAndGxkQmxhY2tsaXN0IG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGxkcy5kZW55IGluc3RlYWQnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLnRsZFdoaXRlbGlzdCA9PT0gdW5kZWZpbmVkLCAndGxkV2hpdGVsaXN0IG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGxkcy5hbGxvdyBpbnN0ZWFkJyk7XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIG9wdGlvbnNcblxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25PcHRpb25zLnRsZHMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsaWRhdGlvbk9wdGlvbnMudGxkcyA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLnRsZHMuYWxsb3cgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmFsbG93ID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmFsbG93ID09PSB0cnVlIHx8XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvbk9wdGlvbnMudGxkcy5hbGxvdykgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbk9wdGlvbnMudGxkcy5hbGxvdyBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuYWxsb3cgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmRlbnkgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KHZhbGlkYXRpb25PcHRpb25zLnRsZHMuZGVueSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbk9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0LCAndGxkcy5kZW55IG11c3QgYmUgYW4gYXJyYXkgb3IgU2V0Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVUYWJsZSA9ICh0YWJsZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGFibGUgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGUgaW5zdGFuY2VvZiBTZXQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGFibGUpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbGlkYXRpb25PcHRpb25zKTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzID0ge1xuICAgICAgICAgICAgICAgICAgICBhbGxvdzogbm9ybWFsaXplVGFibGUodmFsaWRhdGlvbk9wdGlvbnMudGxkcy5hbGxvdyksXG4gICAgICAgICAgICAgICAgICAgIGRlbnk6IG5vcm1hbGl6ZVRhYmxlKHZhbGlkYXRpb25PcHRpb25zLnRsZHMuZGVueSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWxpZGF0aW9uT3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsaWRhdGlvbk9wdGlvbnMubWluRG9tYWluU2VnbWVudHMpICYmIHZhbGlkYXRpb25PcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID4gMCwgJ21pbkRvbWFpblNlZ21lbnRzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnZW1haWwnLCB2YWxpZGF0aW9uT3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoQWRkcmVzcy5lbWFpbC5pc1ZhbGlkKHZhbHVlLCB2YWxpZGF0aW9uT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuZW1haWwnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXAoaXBPcHRpb25zID0ge30pIHtcblxuICAgICAgICBsZXQgcmVnZXggPSBpbnRlcm5hbHMuaXBSZWdleDtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGlwT3B0aW9ucyA9PT0gJ29iamVjdCcsICdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICAgICAgaWYgKGlwT3B0aW9ucy5jaWRyKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgaXBPcHRpb25zLmNpZHIgPT09ICdzdHJpbmcnLCAnY2lkciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICBpcE9wdGlvbnMuY2lkciA9IGlwT3B0aW9ucy5jaWRyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KEhvZWsuY29udGFpbihpbnRlcm5hbHMuY2lkclByZXNlbmNlcywgaXBPcHRpb25zLmNpZHIpLCAnY2lkciBtdXN0IGJlIG9uZSBvZiAnICsgaW50ZXJuYWxzLmNpZHJQcmVzZW5jZXMuam9pbignLCAnKSk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIG9ubHkgcmVjZWl2ZWQgYSBgY2lkcmAgc2V0dGluZywgY3JlYXRlIGEgcmVnZXggZm9yIGl0LiBCdXQgd2UgZG9uJ3QgbmVlZCB0byBjcmVhdGUgb25lIGlmIGBjaWRyYCBpcyBcIm9wdGlvbmFsXCIgc2luY2UgdGhhdCBpcyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKCFpcE9wdGlvbnMudmVyc2lvbiAmJiBpcE9wdGlvbnMuY2lkciAhPT0gJ29wdGlvbmFsJykge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gSXAuY3JlYXRlSXBSZWdleChbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXSwgaXBPcHRpb25zLmNpZHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBTZXQgb3VyIGRlZmF1bHQgY2lkciBzdHJhdGVneVxuICAgICAgICAgICAgaXBPcHRpb25zLmNpZHIgPSAnb3B0aW9uYWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZlcnNpb25zO1xuICAgICAgICBpZiAoaXBPcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpcE9wdGlvbnMudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICBpcE9wdGlvbnMudmVyc2lvbiA9IFtpcE9wdGlvbnMudmVyc2lvbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGlwT3B0aW9ucy52ZXJzaW9uLmxlbmd0aCA+PSAxLCAndmVyc2lvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2ZXJzaW9uIHNwZWNpZmllZCcpO1xuXG4gICAgICAgICAgICB2ZXJzaW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpcE9wdGlvbnMudmVyc2lvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gaXBPcHRpb25zLnZlcnNpb25baV07XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoSXAudmVyc2lvbnNbdmVyc2lvbl0sICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoSXAudmVyc2lvbnMpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIHZlcnNpb25zLnB1c2godmVyc2lvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc2V0IG9mIHZlcnNpb25zXG4gICAgICAgICAgICB2ZXJzaW9ucyA9IEFycmF5LmZyb20obmV3IFNldCh2ZXJzaW9ucykpO1xuXG4gICAgICAgICAgICByZWdleCA9IElwLmNyZWF0ZUlwUmVnZXgodmVyc2lvbnMsIGlwT3B0aW9ucy5jaWRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdpcCcsIGlwT3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2ZXJzaW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaXBWZXJzaW9uJywgeyB2YWx1ZSwgY2lkcjogaXBPcHRpb25zLmNpZHIsIHZlcnNpb246IHZlcnNpb25zIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5pcCcsIHsgdmFsdWUsIGNpZHI6IGlwT3B0aW9ucy5jaWRyIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXJpKHVyaU9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgY3VzdG9tU2NoZW1lID0gJyc7XG4gICAgICAgIGxldCBhbGxvd1JlbGF0aXZlID0gZmFsc2U7XG4gICAgICAgIGxldCByZWxhdGl2ZU9ubHkgPSBmYWxzZTtcbiAgICAgICAgbGV0IGFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVnZXggPSBpbnRlcm5hbHMudXJpUmVnZXg7XG5cbiAgICAgICAgaWYgKHVyaU9wdGlvbnMpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB1cmlPcHRpb25zID09PSAnb2JqZWN0JywgJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgICAgICAgICAgY29uc3QgdW5rbm93bk9wdGlvbnMgPSBPYmplY3Qua2V5cyh1cmlPcHRpb25zKS5maWx0ZXIoKGtleSkgPT4gIVsnc2NoZW1lJywgJ2FsbG93UmVsYXRpdmUnLCAncmVsYXRpdmVPbmx5JywgJ2FsbG93UXVlcnlTcXVhcmVCcmFja2V0cyddLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodW5rbm93bk9wdGlvbnMubGVuZ3RoID09PSAwLCBgb3B0aW9ucyBjb250YWluIHVua25vd24ga2V5czogJHt1bmtub3duT3B0aW9uc31gKTtcblxuICAgICAgICAgICAgaWYgKHVyaU9wdGlvbnMuc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodXJpT3B0aW9ucy5zY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIHVyaU9wdGlvbnMuc2NoZW1lID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHVyaU9wdGlvbnMuc2NoZW1lKSwgJ3NjaGVtZSBtdXN0IGJlIGEgUmVnRXhwLCBTdHJpbmcsIG9yIEFycmF5Jyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodXJpT3B0aW9ucy5zY2hlbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVyaU9wdGlvbnMuc2NoZW1lID0gW3VyaU9wdGlvbnMuc2NoZW1lXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh1cmlPcHRpb25zLnNjaGVtZS5sZW5ndGggPj0gMSwgJ3NjaGVtZSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBzY2hlbWUgc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBGbGF0dGVuIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nIHRvIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNjaGVtZXMuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmlPcHRpb25zLnNjaGVtZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWUgPSB1cmlPcHRpb25zLnNjaGVtZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgUmVnRXhwIG9yIFN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBPUiBzZXBhcmF0b3JzIGlmIGEgdmFsdWUgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tU2NoZW1lID0gY3VzdG9tU2NoZW1lICsgKGN1c3RvbVNjaGVtZSA/ICd8JyA6ICcnKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb21lb25lIHdhbnRzIHRvIG1hdGNoIEhUVFAgb3IgSFRUUFMgZm9yIGV4YW1wbGUgdGhlbiB3ZSBuZWVkIHRvIHN1cHBvcnQgYm90aCBSZWdFeHAgYW5kIFN0cmluZyBzbyB3ZSBkb24ndCBlc2NhcGUgdGhlaXIgcGF0dGVybiB1bmtub3dpbmdseS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tU2NoZW1lID0gY3VzdG9tU2NoZW1lICsgc2NoZW1lLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KC9bYS16QS1aXVthLXpBLVowLTkrLVxcLl0qLy50ZXN0KHNjaGVtZSksICdzY2hlbWUgYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSB2YWxpZCBzY2hlbWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVNjaGVtZSA9IGN1c3RvbVNjaGVtZSArIEhvZWsuZXNjYXBlUmVnZXgoc2NoZW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVyaU9wdGlvbnMuYWxsb3dSZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIGFsbG93UmVsYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXJpT3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZU9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXJpT3B0aW9ucy5hbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpIHtcbiAgICAgICAgICAgICAgICBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1c3RvbVNjaGVtZSB8fCBhbGxvd1JlbGF0aXZlIHx8IHJlbGF0aXZlT25seSB8fCBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gVXJpLmNyZWF0ZVVyaVJlZ2V4KGN1c3RvbVNjaGVtZSwgYWxsb3dSZWxhdGl2ZSwgcmVsYXRpdmVPbmx5LCBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3VyaScsIHVyaU9wdGlvbnMsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVsYXRpdmVPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy51cmlSZWxhdGl2ZU9ubHknLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1c3RvbVNjaGVtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcudXJpQ3VzdG9tU2NoZW1lJywgeyBzY2hlbWU6IGN1c3RvbVNjaGVtZSwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnVyaScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc29EYXRlKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdpc29EYXRlJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChKb2lEYXRlLl9pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLmNvbnZlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihkLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaXNvRGF0ZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBndWlkKGd1aWRPcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHZlcnNpb25OdW1iZXJzID0gJyc7XG5cbiAgICAgICAgaWYgKGd1aWRPcHRpb25zICYmIGd1aWRPcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShndWlkT3B0aW9ucy52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIGd1aWRPcHRpb25zLnZlcnNpb24gPSBbZ3VpZE9wdGlvbnMudmVyc2lvbl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGd1aWRPcHRpb25zLnZlcnNpb24ubGVuZ3RoID49IDEsICd2ZXJzaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZhbGlkIHZlcnNpb24gc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBndWlkT3B0aW9ucy52ZXJzaW9uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBndWlkT3B0aW9ucy52ZXJzaW9uW2ldO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJywgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdmVyc2lvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBpbnRlcm5hbHMuZ3VpZFZlcnNpb25zW3ZlcnNpb25dO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZlcnNpb25OdW1iZXIsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoaW50ZXJuYWxzLmd1aWRWZXJzaW9ucykuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoISh2ZXJzaW9ucy5oYXModmVyc2lvbk51bWJlcikpLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBub3QgYmUgYSBkdXBsaWNhdGUuJyk7XG5cbiAgICAgICAgICAgICAgICB2ZXJzaW9uTnVtYmVycyArPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgICAgIHZlcnNpb25zLmFkZCh2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGd1aWRSZWdleCA9IG5ldyBSZWdFeHAoYF4oW1xcXFxbe1xcXFwoXT8pWzAtOUEtRl17OH0oWzotXT8pWzAtOUEtRl17NH1cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyB8fCAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bJHt2ZXJzaW9uTnVtYmVycyA/ICc4OUFCJyA6ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1swLTlBLUZdezEyfShbXFxcXF19XFxcXCldPykkYCwgJ2knKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnZ3VpZCcsIGd1aWRPcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBndWlkUmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICghcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuZ3VpZCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYXRjaGluZyBicmFjZXNcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZ3VpZEJyYWNrZXRzW3Jlc3VsdHNbMV1dICE9PSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmd1aWQnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoZXgoaGV4T3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGhleE9wdGlvbnMgPT09ICdvYmplY3QnLCAnaGV4IG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGhleE9wdGlvbnMuYnl0ZUFsaWduZWQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBoZXhPcHRpb25zLmJ5dGVBbGlnbmVkID09PSAnYm9vbGVhbicsXG4gICAgICAgICAgICAnYnl0ZUFsaWduZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgY29uc3QgYnl0ZUFsaWduZWQgPSBoZXhPcHRpb25zLmJ5dGVBbGlnbmVkID09PSB0cnVlO1xuICAgICAgICBjb25zdCByZWdleCA9IC9eW2EtZjAtOV0rJC9pO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ2hleCcsIHJlZ2V4LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChieXRlQWxpZ25lZCAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaGV4QWxpZ24nLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuaGV4JywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChieXRlQWxpZ25lZCkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5ieXRlQWxpZ25lZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGJhc2U2NChiYXNlNjRPcHRpb25zID0ge30pIHtcblxuICAgICAgICAvLyBWYWxpZGF0aW9uLlxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgYmFzZTY0T3B0aW9ucyA9PT0gJ29iamVjdCcsICdiYXNlNjQgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgYmFzZTY0T3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBiYXNlNjRPcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAgICAgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgcGFkZGluZyBpcyByZXF1aXJlZC5cbiAgICAgICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gYmFzZTY0T3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09IGZhbHNlID9cbiAgICAgICAgICAgIGJhc2U2NE9wdGlvbnMucGFkZGluZ1JlcXVpcmVkXG4gICAgICAgICAgICA6IGJhc2U2NE9wdGlvbnMucGFkZGluZ1JlcXVpcmVkIHx8IHRydWU7XG5cbiAgICAgICAgLy8gU2V0IHZhbGlkYXRpb24gYmFzZWQgb24gcHJlZmVyZW5jZS5cbiAgICAgICAgY29uc3QgcmVnZXggPSBwYWRkaW5nUmVxdWlyZWQgP1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpcyByZXF1aXJlZC5cbiAgICAgICAgICAgIC9eKD86W0EtWmEtejAtOStcXC9dezJ9W0EtWmEtejAtOStcXC9dezJ9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kL1xuICAgICAgICAgICAgLy8gUGFkZGluZyBpcyBvcHRpb25hbC5cbiAgICAgICAgICAgIDogL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfSg9PSk/fFtBLVphLXowLTkrXFwvXXszfT0/KT8kLztcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnYmFzZTY0JywgcmVnZXgsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmJhc2U2NCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkYXRhVXJpKGRhdGFVcmlPcHRpb25zID0ge30pIHtcblxuICAgICAgICBjb25zdCByZWdleCA9IC9eZGF0YTpbXFx3Ky4tXStcXC9bXFx3Ky4tXSs7KChjaGFyc2V0PVtcXHctXSt8YmFzZTY0KSwpPyguKikkLztcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgcGFkZGluZyBpcyByZXF1aXJlZC5cbiAgICAgICAgY29uc3QgcGFkZGluZ1JlcXVpcmVkID0gZGF0YVVyaU9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSBmYWxzZSA/XG4gICAgICAgICAgICBkYXRhVXJpT3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRcbiAgICAgICAgICAgIDogZGF0YVVyaU9wdGlvbnMucGFkZGluZ1JlcXVpcmVkIHx8IHRydWU7XG5cbiAgICAgICAgY29uc3QgYmFzZTY0cmVnZXggPSBwYWRkaW5nUmVxdWlyZWQgP1xuICAgICAgICAgICAgL14oPzpbQS1aYS16MC05K1xcL117NH0pKig/OltBLVphLXowLTkrXFwvXXsyfT09fFtBLVphLXowLTkrXFwvXXszfT0pPyQvXG4gICAgICAgICAgICA6IC9eKD86W0EtWmEtejAtOStcXC9dezR9KSooPzpbQS1aYS16MC05K1xcL117Mn0oPT0pP3xbQS1aYS16MC05K1xcL117M309Pyk/JC87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2RhdGFVcmknLCByZWdleCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2gocmVnZXgpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0gIT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZTY0cmVnZXgudGVzdChtYXRjaGVzWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmRhdGFVcmknLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaG9zdG5hbWUoKSB7XG5cbiAgICAgICAgY29uc3QgcmVnZXggPSAvXigoW2EtekEtWjAtOV18W2EtekEtWjAtOV1bYS16QS1aMC05XFwtXSpbYS16QS1aMC05XSlcXC4pKihbQS1aYS16MC05XXxbQS1aYS16MC05XVtBLVphLXowLTlcXC1dKltBLVphLXowLTldKSQvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdob3N0bmFtZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoKHZhbHVlLmxlbmd0aCA8PSAyNTUgJiYgcmVnZXgudGVzdCh2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgTmV0LmlzSVB2Nih2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5ob3N0bmFtZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBub3JtYWxpemUoZm9ybSA9ICdORkMnKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoSG9lay5jb250YWluKGludGVybmFscy5ub3JtYWxpemF0aW9uRm9ybXMsIGZvcm0pLCAnbm9ybWFsaXphdGlvbiBmb3JtIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmpvaW4oJywgJykpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ25vcm1hbGl6ZScsIGZvcm0sIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCB8fFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS5ub3JtYWxpemUoZm9ybSkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5ub3JtYWxpemUnLCB7IHZhbHVlLCBmb3JtIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqLl9mbGFncy5ub3JtYWxpemUgPSBmb3JtO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGxvd2VyY2FzZSgpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl90ZXN0KCdsb3dlcmNhc2UnLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCB8fFxuICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcubG93ZXJjYXNlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iai5fZmxhZ3MuY2FzZSA9ICdsb3dlcic7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdXBwZXJjYXNlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ3VwcGVyY2FzZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy51cHBlcmNhc2UnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqLl9mbGFncy5jYXNlID0gJ3VwcGVyJztcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0cmltKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ29wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgIGlmICgodGhpcy5fZmxhZ3MudHJpbSAmJiBlbmFibGVkKSB8fCAoIXRoaXMuX2ZsYWdzLnRyaW0gJiYgIWVuYWJsZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvYmo7XG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzLl90ZXN0KCd0cmltJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS50cmltKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy50cmltJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai5fdGVzdHMgPSBvYmouX3Rlc3RzLmZpbHRlcigodGVzdCkgPT4gdGVzdC5uYW1lICE9PSAndHJpbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9mbGFncy50cmltID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByZXBsYWNlKHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoSG9lay5lc2NhcGVSZWdleChwYXR0ZXJuKSwgJ2cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAsICdwYXR0ZXJuIG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJywgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnKTtcblxuICAgICAgICAvLyBUaGlzIGNhbiBub3QgYmUgY29uc2lkZXJlIGEgdGVzdCBsaWtlIHRyaW0sIHdlIGNhbid0IFwicmVqZWN0XCJcbiAgICAgICAgLy8gYW55dGhpbmcgZnJvbSB0aGlzIHJ1bGUsIHNvIGp1c3QgY2xvbmUgdGhlIGN1cnJlbnQgb2JqZWN0XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9iai5faW5uZXIucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICBvYmouX2lubmVyLnJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pbm5lci5yZXBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICBwYXR0ZXJuLFxuICAgICAgICAgICAgcmVwbGFjZW1lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0cnVuY2F0ZShlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy50cnVuY2F0ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnRydW5jYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG59O1xuXG5pbnRlcm5hbHMuY29tcGFyZSA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGxpbWl0KTtcblxuICAgICAgICBIb2VrLmFzc2VydCgoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDApIHx8IGlzUmVmLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgcmVmZXJlbmNlJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFlbmNvZGluZyB8fCBCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCh0eXBlLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZVRvO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbXBhcmVUbykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5yZWYnLCB7IHJlZjogbGltaXQsIHZhbHVlOiBjb21wYXJlVG8gfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcGFyZSh2YWx1ZSwgY29tcGFyZVRvLCBlbmNvZGluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuJyArIHR5cGUsIHsgbGltaXQ6IGNvbXBhcmVUbywgdmFsdWUsIGVuY29kaW5nIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLlN0cmluZy5wcm90b3R5cGUubWluID0gaW50ZXJuYWxzLmNvbXBhcmUoJ21pbicsICh2YWx1ZSwgbGltaXQsIGVuY29kaW5nKSA9PiB7XG5cbiAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZykgOiB2YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA+PSBsaW1pdDtcbn0pO1xuXG5cbmludGVybmFscy5TdHJpbmcucHJvdG90eXBlLm1heCA9IGludGVybmFscy5jb21wYXJlKCdtYXgnLCAodmFsdWUsIGxpbWl0LCBlbmNvZGluZykgPT4ge1xuXG4gICAgY29uc3QgbGVuZ3RoID0gZW5jb2RpbmcgPyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPD0gbGltaXQ7XG59KTtcblxuXG5pbnRlcm5hbHMuU3RyaW5nLnByb3RvdHlwZS5sZW5ndGggPSBpbnRlcm5hbHMuY29tcGFyZSgnbGVuZ3RoJywgKHZhbHVlLCBsaW1pdCwgZW5jb2RpbmcpID0+IHtcblxuICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kaW5nID8gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUsIGVuY29kaW5nKSA6IHZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID09PSBsaW1pdDtcbn0pO1xuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5TdHJpbmcucHJvdG90eXBlLnV1aWQgPSBpbnRlcm5hbHMuU3RyaW5nLnByb3RvdHlwZS5ndWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuU3RyaW5nKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJGQzM5ODYgPSByZXF1aXJlKCcuL3JmYzM5ODYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgSXA6IHtcbiAgICAgICAgY2lkcnM6IHtcbiAgICAgICAgICAgIGlwdjQ6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogJ1xcXFwvKD86JyArIFJGQzM5ODYuaXB2NENpZHIgKyAnKScsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6ICcoPzpcXFxcLyg/OicgKyBSRkMzOTg2LmlwdjRDaWRyICsgJykpPycsXG4gICAgICAgICAgICAgICAgZm9yYmlkZGVuOiAnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlwdjY6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogJ1xcXFwvJyArIFJGQzM5ODYuaXB2NkNpZHIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6ICcoPzpcXFxcLycgKyBSRkMzOTg2LmlwdjZDaWRyICsgJyk/JyxcbiAgICAgICAgICAgICAgICBmb3JiaWRkZW46ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXB2ZnV0dXJlOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICdcXFxcLycgKyBSRkMzOTg2LmlwdjZDaWRyLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiAnKD86XFxcXC8nICsgUkZDMzk4Ni5pcHY2Q2lkciArICcpPycsXG4gICAgICAgICAgICAgICAgZm9yYmlkZGVuOiAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJzaW9uczoge1xuICAgICAgICAgICAgaXB2NDogUkZDMzk4Ni5JUHY0YWRkcmVzcyxcbiAgICAgICAgICAgIGlwdjY6IFJGQzM5ODYuSVB2NmFkZHJlc3MsXG4gICAgICAgICAgICBpcHZmdXR1cmU6IFJGQzM5ODYuSVB2RnV0dXJlXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5JcC5jcmVhdGVJcFJlZ2V4ID0gZnVuY3Rpb24gKHZlcnNpb25zLCBjaWRyKSB7XG5cbiAgICBsZXQgcmVnZXg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gdmVyc2lvbnNbaV07XG4gICAgICAgIGlmICghcmVnZXgpIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14oPzonICsgaW50ZXJuYWxzLklwLnZlcnNpb25zW3ZlcnNpb25dICsgaW50ZXJuYWxzLklwLmNpZHJzW3ZlcnNpb25dW2NpZHJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVnZXggKz0gJ3wnICsgaW50ZXJuYWxzLklwLnZlcnNpb25zW3ZlcnNpb25dICsgaW50ZXJuYWxzLklwLmNpZHJzW3ZlcnNpb25dW2NpZHJdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXggKyAnKSQnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLklwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcmZjMzk4Njoge31cbn07XG5cblxuaW50ZXJuYWxzLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogZWxlbWVudHMgc2VwYXJhdGVkIGJ5IGZvcndhcmQgc2xhc2ggKFwiL1wiKSBhcmUgYWx0ZXJuYXRpdmVzLlxuICAgICAqL1xuICAgIGNvbnN0IG9yID0gJ3wnO1xuXG4gICAgLyoqXG4gICAgICogUnVsZSB0byBzdXBwb3J0IHplcm8tcGFkZGVkIGFkZHJlc3Nlcy5cbiAgICAgKi9cbiAgICBjb25zdCB6ZXJvUGFkID0gJzA/JztcblxuICAgIC8qKlxuICAgICAqIERJR0lUID0gJXgzMC0zOSA7IDAtOVxuICAgICAqL1xuICAgIGNvbnN0IGRpZ2l0ID0gJzAtOSc7XG4gICAgY29uc3QgZGlnaXRPbmx5ID0gJ1snICsgZGlnaXQgKyAnXSc7XG5cbiAgICAvKipcbiAgICAgKiBBTFBIQSA9ICV4NDEtNUEgLyAleDYxLTdBICAgOyBBLVogLyBhLXpcbiAgICAgKi9cbiAgICBjb25zdCBhbHBoYSA9ICdhLXpBLVonO1xuICAgIGNvbnN0IGFscGhhT25seSA9ICdbJyArIGFscGhhICsgJ10nO1xuXG4gICAgLyoqXG4gICAgICogSVB2NFxuICAgICAqIGNpZHIgICAgICAgPSBESUdJVCAgICAgICAgICAgICAgICA7IDAtOVxuICAgICAqICAgICAgICAgICAgLyAleDMxLTMyIERJR0lUICAgICAgICAgOyAxMC0yOVxuICAgICAqICAgICAgICAgICAgLyBcIjNcIiAleDMwLTMyICAgICAgICAgICA7IDMwLTMyXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuaXB2NENpZHIgPSBkaWdpdE9ubHkgKyBvciArICdbMS0yXScgKyBkaWdpdE9ubHkgKyBvciArICczJyArICdbMC0yXSc7XG5cbiAgICAvKipcbiAgICAgKiBJUHY2XG4gICAgICogY2lkciAgICAgICA9IERJR0lUICAgICAgICAgICAgICAgICA7IDAtOVxuICAgICAqICAgICAgICAgICAgLyAleDMxLTM5IERJR0lUICAgICAgICAgOyAxMC05OVxuICAgICAqICAgICAgICAgICAgLyBcIjFcIiAleDAtMSBESUdJVCAgICAgICA7IDEwMC0xMTlcbiAgICAgKiAgICAgICAgICAgIC8gXCIxMlwiICV4MC04ICAgICAgICAgICAgOyAxMjAtMTI4XG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuaXB2NkNpZHIgPSAnKD86JyArIHplcm9QYWQgKyB6ZXJvUGFkICsgZGlnaXRPbmx5ICsgb3IgKyB6ZXJvUGFkICsgJ1sxLTldJyArIGRpZ2l0T25seSArIG9yICsgJzEnICsgJ1swMV0nICsgZGlnaXRPbmx5ICsgb3IgKyAnMTJbMC04XSknO1xuXG4gICAgLyoqXG4gICAgICogSEVYRElHID0gRElHSVQgLyBcIkFcIiAvIFwiQlwiIC8gXCJDXCIgLyBcIkRcIiAvIFwiRVwiIC8gXCJGXCJcbiAgICAgKi9cbiAgICBjb25zdCBoZXhEaWdpdCA9IGRpZ2l0ICsgJ0EtRmEtZic7XG4gICAgY29uc3QgaGV4RGlnaXRPbmx5ID0gJ1snICsgaGV4RGlnaXQgKyAnXSc7XG5cbiAgICAvKipcbiAgICAgKiB1bnJlc2VydmVkID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgICovXG4gICAgY29uc3QgdW5yZXNlcnZlZCA9IGFscGhhICsgZGlnaXQgKyAnLVxcXFwuX34nO1xuXG4gICAgLyoqXG4gICAgICogc3ViLWRlbGltcyA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICAgKi9cbiAgICBjb25zdCBzdWJEZWxpbXMgPSAnIVxcXFwkJlxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9JztcblxuICAgIC8qKlxuICAgICAqIHBjdC1lbmNvZGVkID0gXCIlXCIgSEVYRElHIEhFWERJR1xuICAgICAqL1xuICAgIGNvbnN0IHBjdEVuY29kZWQgPSAnJScgKyBoZXhEaWdpdDtcblxuICAgIC8qKlxuICAgICAqIHBjaGFyID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICAgKi9cbiAgICBjb25zdCBwY2hhciA9IHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJzpAJztcbiAgICBjb25zdCBwY2hhck9ubHkgPSAnWycgKyBwY2hhciArICddJztcblxuICAgIC8qKlxuICAgICAqIHNxdWFyZUJyYWNrZXRzIGV4YW1wbGU6IFtdXG4gICAgICovXG4gICAgY29uc3Qgc3F1YXJlQnJhY2tldHMgPSAnXFxcXFtcXFxcXSc7XG5cbiAgICAvKipcbiAgICAgKiBkZWMtb2N0ZXQgICA9IERJR0lUICAgICAgICAgICAgICAgICA7IDAtOVxuICAgICAqICAgICAgICAgICAgLyAleDMxLTM5IERJR0lUICAgICAgICAgOyAxMC05OVxuICAgICAqICAgICAgICAgICAgLyBcIjFcIiAyRElHSVQgICAgICAgICAgICA7IDEwMC0xOTlcbiAgICAgKiAgICAgICAgICAgIC8gXCIyXCIgJXgzMC0zNCBESUdJVCAgICAgOyAyMDAtMjQ5XG4gICAgICogICAgICAgICAgICAvIFwiMjVcIiAleDMwLTM1ICAgICAgICAgIDsgMjUwLTI1NVxuICAgICAqL1xuICAgIGNvbnN0IGRlY09jdGVjdCA9ICcoPzonICsgemVyb1BhZCArIHplcm9QYWQgKyBkaWdpdE9ubHkgKyBvciArIHplcm9QYWQgKyAnWzEtOV0nICsgZGlnaXRPbmx5ICsgb3IgKyAnMScgKyBkaWdpdE9ubHkgKyBkaWdpdE9ubHkgKyBvciArICcyJyArICdbMC00XScgKyBkaWdpdE9ubHkgKyBvciArICcyNScgKyAnWzAtNV0pJztcblxuICAgIC8qKlxuICAgICAqIElQdjRhZGRyZXNzID0gZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0XG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NGFkZHJlc3MgPSAnKD86JyArIGRlY09jdGVjdCArICdcXFxcLil7M30nICsgZGVjT2N0ZWN0O1xuXG4gICAgLyoqXG4gICAgICogaDE2ID0gMSo0SEVYRElHIDsgMTYgYml0cyBvZiBhZGRyZXNzIHJlcHJlc2VudGVkIGluIGhleGFkZWNpbWFsXG4gICAgICogbHMzMiA9ICggaDE2IFwiOlwiIGgxNiApIC8gSVB2NGFkZHJlc3MgOyBsZWFzdC1zaWduaWZpY2FudCAzMiBiaXRzIG9mIGFkZHJlc3NcbiAgICAgKiBJUHY2YWRkcmVzcyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvICAgICAgICAgICAgICAgICAgICAgICBcIjo6XCIgNSggaDE2IFwiOlwiICkgbHMzMlxuICAgICAqICAgICAgICAgICAgIC8gWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICogICAgICAgICAgICAgLyBbICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgICAqICAgICAgICAgICAgIC8gWyAqMiggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDIoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvIFsgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG4gICAgICogICAgICAgICAgICAgLyBbICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvIFsgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG4gICAgICogICAgICAgICAgICAgLyBbICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcbiAgICAgKi9cbiAgICBjb25zdCBoMTYgPSBoZXhEaWdpdE9ubHkgKyAnezEsNH0nO1xuICAgIGNvbnN0IGxzMzIgPSAnKD86JyArIGgxNiArICc6JyArIGgxNiArICd8JyArIGludGVybmFscy5yZmMzOTg2LklQdjRhZGRyZXNzICsgJyknO1xuICAgIGNvbnN0IElQdjZTaXhIZXggPSAnKD86JyArIGgxNiArICc6KXs2fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZGaXZlSGV4ID0gJzo6KD86JyArIGgxNiArICc6KXs1fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZGb3VySGV4ID0gJyg/OicgKyBoMTYgKyAnKT86Oig/OicgKyBoMTYgKyAnOil7NH0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2VGhyZWVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDF9JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXszfScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZUd29IZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDJ9JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXsyfScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZPbmVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDN9JyArIGgxNiArICcpPzo6JyArIGgxNiArICc6JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDR9JyArIGgxNiArICcpPzo6JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXgyID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw1fScgKyBoMTYgKyAnKT86OicgKyBoMTY7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXgzID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw2fScgKyBoMTYgKyAnKT86Oic7XG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NmFkZHJlc3MgPSAnKD86JyArIElQdjZTaXhIZXggKyBvciArIElQdjZGaXZlSGV4ICsgb3IgKyBJUHY2Rm91ckhleCArIG9yICsgSVB2NlRocmVlSGV4ICsgb3IgKyBJUHY2VHdvSGV4ICsgb3IgKyBJUHY2T25lSGV4ICsgb3IgKyBJUHY2Tm9uZUhleCArIG9yICsgSVB2Nk5vbmVIZXgyICsgb3IgKyBJUHY2Tm9uZUhleDMgKyAnKSc7XG5cbiAgICAvKipcbiAgICAgKiBJUHZGdXR1cmUgPSBcInZcIiAxKkhFWERJRyBcIi5cIiAxKiggdW5yZXNlcnZlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuSVB2RnV0dXJlID0gJ3YnICsgaGV4RGlnaXRPbmx5ICsgJytcXFxcLlsnICsgdW5yZXNlcnZlZCArIHN1YkRlbGltcyArICc6XSsnO1xuXG4gICAgLyoqXG4gICAgICogc2NoZW1lID0gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuc2NoZW1lID0gYWxwaGFPbmx5ICsgJ1snICsgYWxwaGEgKyBkaWdpdCArICcrLVxcXFwuXSonO1xuXG4gICAgLyoqXG4gICAgICogdXNlcmluZm8gPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuICAgICAqL1xuICAgIGNvbnN0IHVzZXJpbmZvID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnOl0qJztcblxuICAgIC8qKlxuICAgICAqIElQLWxpdGVyYWwgPSBcIltcIiAoIElQdjZhZGRyZXNzIC8gSVB2RnV0dXJlICApIFwiXVwiXG4gICAgICovXG4gICAgY29uc3QgSVBMaXRlcmFsID0gJ1xcXFxbKD86JyArIGludGVybmFscy5yZmMzOTg2LklQdjZhZGRyZXNzICsgb3IgKyBpbnRlcm5hbHMucmZjMzk4Ni5JUHZGdXR1cmUgKyAnKVxcXFxdJztcblxuICAgIC8qKlxuICAgICAqIHJlZy1uYW1lID0gKiggdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyApXG4gICAgICovXG4gICAgY29uc3QgcmVnTmFtZSA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJ117MCwyNTV9JztcblxuICAgIC8qKlxuICAgICAqIGhvc3QgPSBJUC1saXRlcmFsIC8gSVB2NGFkZHJlc3MgLyByZWctbmFtZVxuICAgICAqL1xuICAgIGNvbnN0IGhvc3QgPSAnKD86JyArIElQTGl0ZXJhbCArIG9yICsgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NGFkZHJlc3MgKyBvciArIHJlZ05hbWUgKyAnKSc7XG5cbiAgICAvKipcbiAgICAgKiBwb3J0ID0gKkRJR0lUXG4gICAgICovXG4gICAgY29uc3QgcG9ydCA9IGRpZ2l0T25seSArICcqJztcblxuICAgIC8qKlxuICAgICAqIGF1dGhvcml0eSAgID0gWyB1c2VyaW5mbyBcIkBcIiBdIGhvc3QgWyBcIjpcIiBwb3J0IF1cbiAgICAgKi9cbiAgICBjb25zdCBhdXRob3JpdHkgPSAnKD86JyArIHVzZXJpbmZvICsgJ0ApPycgKyBob3N0ICsgJyg/OjonICsgcG9ydCArICcpPyc7XG5cbiAgICAvKipcbiAgICAgKiBzZWdtZW50ICAgICAgID0gKnBjaGFyXG4gICAgICogc2VnbWVudC1ueiAgICA9IDEqcGNoYXJcbiAgICAgKiBwYXRoICAgICAgICAgID0gcGF0aC1hYmVtcHR5ICAgIDsgYmVnaW5zIHdpdGggXCIvXCIgb3IgaXMgZW1wdHlcbiAgICAgKiAgICAgICAgICAgICAgIC8gcGF0aC1hYnNvbHV0ZSAgIDsgYmVnaW5zIHdpdGggXCIvXCIgYnV0IG5vdCBcIi8vXCJcbiAgICAgKiAgICAgICAgICAgICAgIC8gcGF0aC1ub3NjaGVtZSAgIDsgYmVnaW5zIHdpdGggYSBub24tY29sb24gc2VnbWVudFxuICAgICAqICAgICAgICAgICAgICAgLyBwYXRoLXJvb3RsZXNzICAgOyBiZWdpbnMgd2l0aCBhIHNlZ21lbnRcbiAgICAgKiAgICAgICAgICAgICAgIC8gcGF0aC1lbXB0eSAgICAgIDsgemVybyBjaGFyYWN0ZXJzXG4gICAgICogcGF0aC1hYmVtcHR5ICA9ICooIFwiL1wiIHNlZ21lbnQgKVxuICAgICAqIHBhdGgtYWJzb2x1dGUgPSBcIi9cIiBbIHNlZ21lbnQtbnogKiggXCIvXCIgc2VnbWVudCApIF1cbiAgICAgKiBwYXRoLXJvb3RsZXNzID0gc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAgKi9cbiAgICBjb25zdCBzZWdtZW50ID0gcGNoYXJPbmx5ICsgJyonO1xuICAgIGNvbnN0IHNlZ21lbnROeiA9IHBjaGFyT25seSArICcrJztcbiAgICBjb25zdCBzZWdtZW50TnpOYyA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJ0AnICsgJ10rJztcbiAgICBjb25zdCBwYXRoRW1wdHkgPSAnJztcbiAgICBjb25zdCBwYXRoQWJFbXB0eSA9ICcoPzpcXFxcLycgKyBzZWdtZW50ICsgJykqJztcbiAgICBjb25zdCBwYXRoQWJzb2x1dGUgPSAnXFxcXC8oPzonICsgc2VnbWVudE56ICsgcGF0aEFiRW1wdHkgKyAnKT8nO1xuICAgIGNvbnN0IHBhdGhSb290bGVzcyA9IHNlZ21lbnROeiArIHBhdGhBYkVtcHR5O1xuICAgIGNvbnN0IHBhdGhOb1NjaGVtZSA9IHNlZ21lbnROek5jICsgcGF0aEFiRW1wdHk7XG5cbiAgICAvKipcbiAgICAgKiBoaWVyLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGhcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5oaWVyUGFydCA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgKyAnKScgKyBvciArIHBhdGhBYnNvbHV0ZSArIG9yICsgcGF0aFJvb3RsZXNzICsgJyknO1xuXG4gICAgLyoqXG4gICAgICogcmVsYXRpdmUtcGFydCA9IFwiLy9cIiBhdXRob3JpdHkgcGF0aC1hYmVtcHR5XG4gICAgICogICAgICAgICAgICAgICAgIC8gcGF0aC1hYnNvbHV0ZVxuICAgICAqICAgICAgICAgICAgICAgICAvIHBhdGgtbm9zY2hlbWVcbiAgICAgKiAgICAgICAgICAgICAgICAgLyBwYXRoLWVtcHR5XG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYucmVsYXRpdmVSZWYgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eSArIHBhdGhBYkVtcHR5ICArICcpJyArIG9yICsgcGF0aEFic29sdXRlICsgb3IgKyBwYXRoTm9TY2hlbWUgKyBvciArIHBhdGhFbXB0eSArICcpJztcblxuICAgIC8qKlxuICAgICAqIHF1ZXJ5ID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5xdWVyeSA9ICdbJyArIHBjaGFyICsgJ1xcXFwvXFxcXD9dKig/PSN8JCknOyAvL0ZpbmlzaCBtYXRjaGluZyBlaXRoZXIgYXQgdGhlIGZyYWdtZW50IHBhcnQgb3IgZW5kIG9mIHRoZSBsaW5lLlxuXG4gICAgLyoqXG4gICAgICogcXVlcnkgPSAqKCBwY2hhciAvIFwiW1wiIC8gXCJdXCIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5xdWVyeVdpdGhTcXVhcmVCcmFja2V0cyA9ICdbJyArIHBjaGFyICsgc3F1YXJlQnJhY2tldHMgKyAnXFxcXC9cXFxcP10qKD89I3wkKSc7IC8vRmluaXNoIG1hdGNoaW5nIGVpdGhlciBhdCB0aGUgZnJhZ21lbnQgcGFydCBvciBlbmQgb2YgdGhlIGxpbmUuXG5cbiAgICAvKipcbiAgICAgKiBmcmFnbWVudCA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG4gICAgICovXG4gICAgaW50ZXJuYWxzLnJmYzM5ODYuZnJhZ21lbnQgPSAnWycgKyBwY2hhciArICdcXFxcL1xcXFw/XSonO1xufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMucmZjMzk4NjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUkZDMzk4NiA9IHJlcXVpcmUoJy4vcmZjMzk4NicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBVcmk6IHtcbiAgICAgICAgY3JlYXRlVXJpUmVnZXg6IGZ1bmN0aW9uIChvcHRpb25hbFNjaGVtZSwgYWxsb3dSZWxhdGl2ZSwgcmVsYXRpdmVPbmx5LCBhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMpIHtcblxuICAgICAgICAgICAgbGV0IHNjaGVtZSA9IFJGQzM5ODYuc2NoZW1lO1xuICAgICAgICAgICAgbGV0IHByZWZpeDtcblxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlT25seSkge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICcoPzonICsgUkZDMzk4Ni5yZWxhdGl2ZVJlZiArICcpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmUgcGFzc2VkIGEgc2NoZW1lLCB1c2UgaXQgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmVcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWxTY2hlbWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBIYXZlIHRvIHB1dCB0aGlzIGluIGEgbm9uLWNhcHR1cmluZyBncm91cCB0byBoYW5kbGUgdGhlIE9SIHN0YXRlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1lID0gJyg/OicgKyBvcHRpb25hbFNjaGVtZSArICcpJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB3aXRoU2NoZW1lID0gJyg/OicgKyBzY2hlbWUgKyAnOicgKyBSRkMzOTg2LmhpZXJQYXJ0ICsgJyknO1xuXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gYWxsb3dSZWxhdGl2ZSA/ICcoPzonICsgd2l0aFNjaGVtZSArICd8JyArIFJGQzM5ODYucmVsYXRpdmVSZWYgKyAnKScgOiB3aXRoU2NoZW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVSSSA9IHNjaGVtZSBcIjpcIiBoaWVyLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE9SXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogcmVsYXRpdmUtcmVmID0gcmVsYXRpdmUtcGFydCBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoPzpcXFxcPycgKyAoYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzID8gUkZDMzk4Ni5xdWVyeVdpdGhTcXVhcmVCcmFja2V0cyA6IFJGQzM5ODYucXVlcnkpICsgJyk/JyArICcoPzojJyArIFJGQzM5ODYuZnJhZ21lbnQgKyAnKT8kJyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Vcmk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5NYXAgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG5cbiAgICBzbGljZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5NYXAodGhpcyk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIFV0aWwuaW5zcGVjdCh0aGlzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5TeW1ib2wgPSBjbGFzcyBleHRlbmRzIEFueSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gJ3N5bWJvbCc7XG4gICAgICAgIHRoaXMuX2lubmVyLm1hcCA9IG5ldyBpbnRlcm5hbHMuTWFwKCk7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY29udmVydCkge1xuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faW5uZXIubWFwLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsb29rdXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5hbGxvd09ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykgPyBudWxsIDogdGhpcy5jcmVhdGVFcnJvcignc3ltYm9sLm1hcCcsIHsgdmFsdWUsIG1hcDogdGhpcy5faW5uZXIubWFwIH0sIHN0YXRlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBlcnJvcnM6ICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSA/IG51bGwgOiB0aGlzLmNyZWF0ZUVycm9yKCdzeW1ib2wuYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbWFwKGl0ZXJhYmxlKSB7XG5cbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmICFpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdICYmIHR5cGVvZiBpdGVyYWJsZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0LmVudHJpZXMoaXRlcmFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQoaXRlcmFibGUgJiYgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSwgJ0l0ZXJhYmxlIG11c3QgYmUgYW4gaXRlcmFibGUgb3Igb2JqZWN0Jyk7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBzeW1ib2xzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGVudHJ5ICYmIGVudHJ5W1N5bWJvbC5pdGVyYXRvcl0sICdFbnRyeSBtdXN0IGJlIGFuIGl0ZXJhYmxlJyk7XG4gICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Yga2V5ICE9PSAnc3ltYm9sJywgJ0tleSBtdXN0IG5vdCBiZSBhbiBvYmplY3QsIGZ1bmN0aW9uLCBvciBTeW1ib2wnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcsICdWYWx1ZSBtdXN0IGJlIGEgU3ltYm9sJyk7XG4gICAgICAgICAgICBvYmouX2lubmVyLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBzeW1ib2xzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai52YWxpZCguLi5zeW1ib2xzKTtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHN1cGVyLmRlc2NyaWJlKCk7XG4gICAgICAgIGRlc2NyaXB0aW9uLm1hcCA9IG5ldyBNYXAodGhpcy5faW5uZXIubWFwKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLlN5bWJvbCgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzZXR0aW5nc0NhY2hlOiBTeW1ib2woJ3NldHRpbmdzQ2FjaGUnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hID0gSm9pLm9iamVjdCh7XG4gICAgc2FtcGxlSW50ZXJ2YWw6IEpvaS5udW1iZXIoKS5taW4oMCksXG4gICAgbWF4SGVhcFVzZWRCeXRlczogSm9pLm51bWJlcigpLm1pbigwKSxcbiAgICBtYXhFdmVudExvb3BEZWxheTogSm9pLm51bWJlcigpLm1pbigwKSxcbiAgICBtYXhSc3NCeXRlczogSm9pLm51bWJlcigpLm1pbigwKVxufSlcbiAgICAudW5rbm93bigpO1xuXG5cbmludGVybmFscy5kZWZhdWx0cyA9IHtcbiAgICBzYW1wbGVJbnRlcnZhbDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyZXF1ZW5jeSBvZiBsb2FkIHNhbXBsaW5nIGluIG1pbGxpc2Vjb25kcyAoemVybyBpcyBubyBzYW1wbGluZylcbiAgICBtYXhIZWFwVXNlZEJ5dGVzOiAwLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCByZXF1ZXN0cyB3aGVuIFY4IGhlYXAgaXMgb3ZlciBzaXplIGluIGJ5dGVzICh6ZXJvIGlzIG5vIG1heClcbiAgICBtYXhSc3NCeXRlczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlamVjdCByZXF1ZXN0cyB3aGVuIHByb2Nlc3MgUlNTIGlzIG92ZXIgc2l6ZSBpbiBieXRlcyAoemVybyBpcyBubyBtYXgpXG4gICAgbWF4RXZlbnRMb29wRGVsYXk6IDAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgb2YgZGVsYXkgYWZ0ZXIgd2hpY2ggcmVxdWVzdHMgYXJlIHJlamVjdGVkICh6ZXJvIGlzIG5vIG1heClcbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkhlYXZ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgSm9pLmFzc2VydChvcHRpb25zLCBpbnRlcm5hbHMuc2NoZW1hLCAnSW52YWxpZCBsb2FkIG1vbml0b3Jpbmcgb3B0aW9ucycpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIEhvZWsuYXNzZXJ0KHRoaXMuc2V0dGluZ3Muc2FtcGxlSW50ZXJ2YWwgfHwgKCF0aGlzLnNldHRpbmdzLm1heEV2ZW50TG9vcERlbGF5ICYmICF0aGlzLnNldHRpbmdzLm1heEhlYXBVc2VkQnl0ZXMgJiYgIXRoaXMuc2V0dGluZ3MubWF4UnNzQnl0ZXMpLCAnTG9hZCBzYW1wbGUgaW50ZXJ2YWwgbXVzdCBiZSBzZXQgdG8gZW5hYmxlIGxvYWQgbGltaXRzJyk7XG5cbiAgICB0aGlzLl9ldmVudExvb3BUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZEJlbmNoID0gbmV3IEhvZWsuQmVuY2goKTtcbiAgICB0aGlzLmxvYWQgPSB7XG4gICAgICAgIGV2ZW50TG9vcERlbGF5OiAwLFxuICAgICAgICBoZWFwVXNlZDogMCxcbiAgICAgICAgcnNzOiAwXG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLkhlYXZ5LnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5zZXR0aW5ncy5zYW1wbGVJbnRlcnZhbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbG9vcFNhbXBsZSA9ICgpID0+IHtcblxuICAgICAgICB0aGlzLl9sb2FkQmVuY2gucmVzZXQoKTtcbiAgICAgICAgY29uc3QgbWVhc3VyZSA9ICgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbWVtID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuXG4gICAgICAgICAgICAvLyBSZXRhaW4gdGhlIHNhbWUgdGhpcy5sb2FkIG9iamVjdCB0byBrZWVwIGV4dGVybmFsIHJlZmVyZW5jZXMgdmFsaWRcblxuICAgICAgICAgICAgdGhpcy5sb2FkLmV2ZW50TG9vcERlbGF5ID0gKHRoaXMuX2xvYWRCZW5jaC5lbGFwc2VkKCkgLSB0aGlzLnNldHRpbmdzLnNhbXBsZUludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMubG9hZC5oZWFwVXNlZCA9IG1lbS5oZWFwVXNlZDtcbiAgICAgICAgICAgIHRoaXMubG9hZC5yc3MgPSBtZW0ucnNzO1xuXG4gICAgICAgICAgICBsb29wU2FtcGxlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZXZlbnRMb29wVGltZXIgPSBzZXRUaW1lb3V0KG1lYXN1cmUsIHRoaXMuc2V0dGluZ3Muc2FtcGxlSW50ZXJ2YWwpO1xuICAgIH07XG5cbiAgICBsb29wU2FtcGxlKCk7XG59O1xuXG5cbmludGVybmFscy5IZWF2eS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLl9ldmVudExvb3BUaW1lcik7XG4gICAgdGhpcy5fZXZlbnRMb29wVGltZXIgPSBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuSGVhdnkucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnNhbXBsZUludGVydmFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLl9ldmVudExvb3BUaW1lciwgJ0Nhbm5vdCBjaGVjayBsb2FkIHdoZW4gc2FtcGxlciBpcyBub3Qgc3RhcnRlZCcpO1xuXG4gICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuX2xvYWRCZW5jaC5lbGFwc2VkKCk7XG4gICAgY29uc3QgbG9hZCA9IHRoaXMubG9hZDtcblxuICAgIGlmIChlbGFwc2VkID4gdGhpcy5zZXR0aW5ncy5zYW1wbGVJbnRlcnZhbCkge1xuICAgICAgICBsb2FkLmV2ZW50TG9vcERlbGF5ID0gTWF0aC5tYXgobG9hZC5ldmVudExvb3BEZWxheSwgZWxhcHNlZCAtIHRoaXMuc2V0dGluZ3Muc2FtcGxlSW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNldHRpbmdzLm1heEV2ZW50TG9vcERlbGF5ICYmXG4gICAgICAgIGxvYWQuZXZlbnRMb29wRGVsYXkgPiB0aGlzLnNldHRpbmdzLm1heEV2ZW50TG9vcERlbGF5KSB7XG5cbiAgICAgICAgdGhyb3cgQm9vbS5zZXJ2ZXJVbmF2YWlsYWJsZSgnU2VydmVyIHVuZGVyIGhlYXZ5IGxvYWQgKGV2ZW50IGxvb3ApJywgbG9hZCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4SGVhcFVzZWRCeXRlcyAmJlxuICAgICAgICBsb2FkLmhlYXBVc2VkID4gdGhpcy5zZXR0aW5ncy5tYXhIZWFwVXNlZEJ5dGVzKSB7XG5cbiAgICAgICAgdGhyb3cgQm9vbS5zZXJ2ZXJVbmF2YWlsYWJsZSgnU2VydmVyIHVuZGVyIGhlYXZ5IGxvYWQgKGhlYXApJywgbG9hZCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4UnNzQnl0ZXMgJiZcbiAgICAgICAgbG9hZC5yc3MgPiB0aGlzLnNldHRpbmdzLm1heFJzc0J5dGVzKSB7XG5cbiAgICAgICAgdGhyb3cgQm9vbS5zZXJ2ZXJVbmF2YWlsYWJsZSgnU2VydmVyIHVuZGVyIGhlYXZ5IGxvYWQgKHJzcyknLCBsb2FkKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJy4vbWVyZ2UnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRlZmF1bHRzLCBzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQXNzZXJ0KGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIGRlZmF1bHRzIHZhbHVlOiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIEFzc2VydCghc291cmNlIHx8IHNvdXJjZSA9PT0gdHJ1ZSB8fCB0eXBlb2Ygc291cmNlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgc291cmNlIHZhbHVlOiBtdXN0IGJlIHRydWUsIGZhbHN5IG9yIGFuIG9iamVjdCcpO1xuICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnM6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICBpZiAoIXNvdXJjZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gc291cmNlLCByZXR1cm4gbnVsbFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuYXBwbHlUb0RlZmF1bHRzV2l0aFNoYWxsb3coZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29weSA9IENsb25lKGRlZmF1bHRzKTtcblxuICAgIGlmIChzb3VyY2UgPT09IHRydWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb3VyY2UgaXMgc2V0IHRvIHRydWUsIHVzZSBkZWZhdWx0c1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICBjb25zdCBudWxsT3ZlcnJpZGUgPSBvcHRpb25zLm51bGxPdmVycmlkZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5udWxsT3ZlcnJpZGUgOiBmYWxzZTtcbiAgICByZXR1cm4gTWVyZ2UoY29weSwgc291cmNlLCB7IG51bGxPdmVycmlkZSwgbWVyZ2VBcnJheXM6IGZhbHNlIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuYXBwbHlUb0RlZmF1bHRzV2l0aFNoYWxsb3cgPSBmdW5jdGlvbiAoZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3Qga2V5cyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICBBc3NlcnQoQXJyYXkuaXNBcnJheShrZXlzKSwgJ0ludmFsaWQga2V5cycpO1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuc2hhbGxvdyA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29weSA9IENsb25lKGRlZmF1bHRzLCB7IHNoYWxsb3c6IGtleXMgfSk7XG5cbiAgICBpZiAoc291cmNlID09PSB0cnVlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc291cmNlIGlzIHNldCB0byB0cnVlLCB1c2UgZGVmYXVsdHNcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmFnZSA9IFV0aWxzLnN0b3JlKHNvdXJjZSwga2V5cyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBzaGFsbG93IGNvcHkgaXRlbXMgdG8gc3RvcmFnZVxuICAgIE1lcmdlKGNvcHksIHNvdXJjZSwgeyBtZXJnZUFycmF5czogZmFsc2UsIG51bGxPdmVycmlkZTogZmFsc2UgfSk7ICAgLy8gRGVlcCBjb3B5IHRoZSByZXN0XG4gICAgVXRpbHMucmVzdG9yZShjb3B5LCBzb3VyY2UsIHN0b3JhZ2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSBzdG9yZWQgaXRlbXMgYW5kIHJlc3RvcmVcbiAgICByZXR1cm4gY29weTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydEVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIC4uLmFyZ3MpIHtcblxuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBhcmdzWzBdIGluc3RhbmNlb2YgRXJyb3IpIHtcblxuICAgICAgICB0aHJvdyBhcmdzWzBdO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBBc3NlcnRFcnJvcihhcmdzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkJlbmNoID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy50cyA9IDA7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLnRzID0gaW50ZXJuYWxzLkJlbmNoLm5vdygpO1xuICAgIH1cblxuICAgIGVsYXBzZWQoKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5CZW5jaC5ub3coKSAtIHRoaXMudHM7XG4gICAgfVxuXG4gICAgc3RhdGljIG5vdygpIHtcblxuICAgICAgICBjb25zdCB0cyA9IHByb2Nlc3MuaHJ0aW1lKCk7XG4gICAgICAgIHJldHVybiAodHNbMF0gKiAxZTMpICsgKHRzWzFdIC8gMWU2KTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBJZ25vcmUgPSByZXF1aXJlKCcuL2lnbm9yZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKElnbm9yZSk7ICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBuZWVkc1Byb3RvSGFjazogbmV3IFNldChbVHlwZXMuc2V0LCBUeXBlcy5tYXAsIFR5cGVzLndlYWtTZXQsIFR5cGVzLndlYWtNYXBdKVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMgPSB7fSwgX3NlZW4gPSBudWxsKSB7XG5cbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgb2JqID09PSBudWxsKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBsZXQgY2xvbmUgPSBpbnRlcm5hbHMuY2xvbmU7XG4gICAgbGV0IHNlZW4gPSBfc2VlbjtcblxuICAgIGlmIChvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hhbGxvdyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5jbG9uZVdpdGhTaGFsbG93KG9iaiwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9uZSA9ICh2YWx1ZSkgPT4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwKCk7XG5cbiAgICAgICAgY29uc3QgbG9va3VwID0gc2Vlbi5nZXQob2JqKTtcbiAgICAgICAgaWYgKGxvb2t1cCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb2t1cDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWx0LWluIG9iamVjdCB0eXBlc1xuXG4gICAgY29uc3QgYmFzZVByb3RvID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyICYmIEJ1ZmZlci5mcm9tKG9iaik7ICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5kYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvYmouZ2V0VGltZSgpKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5yZWdleCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChvYmopO1xuICAgIH1cblxuICAgIC8vIEdlbmVyaWMgb2JqZWN0c1xuXG4gICAgY29uc3QgbmV3T2JqID0gaW50ZXJuYWxzLmJhc2Uob2JqLCBiYXNlUHJvdG8sIG9wdGlvbnMpO1xuICAgIGlmIChuZXdPYmogPT09IG9iaikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGlmIChzZWVuKSB7XG4gICAgICAgIHNlZW4uc2V0KG9iaiwgbmV3T2JqKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc2Vlbiwgc2luY2Ugb2JqIGNvdWxkIHJlY3Vyc2VcbiAgICB9XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5zZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmopIHtcbiAgICAgICAgICAgIG5ld09iai5hZGQoY2xvbmUodmFsdWUsIG9wdGlvbnMsIHNlZW4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLm1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopIHtcbiAgICAgICAgICAgIG5ld09iai5zZXQoa2V5LCBjbG9uZSh2YWx1ZSwgb3B0aW9ucywgc2VlbikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IFV0aWxzLmtleXMob2JqLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5ICYmXG4gICAgICAgICAgICBrZXkgPT09ICdsZW5ndGgnKSB7XG5cbiAgICAgICAgICAgIG5ld09iai5sZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQgfHxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCkge1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCB7IGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lKG9ialtrZXldLCBvcHRpb25zLCBzZWVuKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3T2JqO1xufTtcblxuXG5pbnRlcm5hbHMuY2xvbmVXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGtleXMgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuc2hhbGxvdyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgc3RvcmFnZSA9IFV0aWxzLnN0b3JlKHNvdXJjZSwga2V5cyk7ICAgIC8vIE1vdmUgc2hhbGxvdyBjb3B5IGl0ZW1zIHRvIHN0b3JhZ2VcbiAgICBjb25zdCBjb3B5ID0gaW50ZXJuYWxzLmNsb25lKHNvdXJjZSwgb3B0aW9ucyk7ICAgICAgLy8gRGVlcCBjb3B5IHRoZSByZXN0XG4gICAgVXRpbHMucmVzdG9yZShjb3B5LCBzb3VyY2UsIHN0b3JhZ2UpOyAgICAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgc3RvcmVkIGl0ZW1zIGFuZCByZXN0b3JlXG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG5cbmludGVybmFscy5iYXNlID0gZnVuY3Rpb24gKG9iaiwgYmFzZVByb3RvLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoYmFzZVByb3RvID09PSBUeXBlcy5hcnJheSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucHJvdG90eXBlID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgaWYgKGludGVybmFscy5uZWVkc1Byb3RvSGFjay5oYXMoYmFzZVByb3RvKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBiYXNlUHJvdG8uY29uc3RydWN0b3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICAgIGlmIChwcm90byAmJlxuICAgICAgICBwcm90by5pc0ltbXV0YWJsZSkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFscy5uZWVkc1Byb3RvSGFjay5oYXMoYmFzZVByb3RvKSkge1xuICAgICAgICBjb25zdCBuZXdPYmogPSBuZXcgcHJvdG8uY29uc3RydWN0b3IoKTtcbiAgICAgICAgaWYgKHByb3RvICE9PSBiYXNlUHJvdG8pIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdPYmosIHByb3RvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUocHJvdG8pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJy4vZGVlcEVxdWFsJyk7XG5jb25zdCBFc2NhcGVSZWdleCA9IHJlcXVpcmUoJy4vZXNjYXBlUmVnZXgnKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJlZiwgdmFsdWVzLCBvcHRpb25zID0ge30pIHsgICAgICAgIC8vIG9wdGlvbnM6IHsgZGVlcCwgb25jZSwgb25seSwgcGFydCwgc3ltYm9scyB9XG5cbiAgICAvKlxuICAgICAgICBzdHJpbmcgLT4gc3RyaW5nKHMpXG4gICAgICAgIGFycmF5IC0+IGl0ZW0ocylcbiAgICAgICAgb2JqZWN0IC0+IGtleShzKVxuICAgICAgICBvYmplY3QgLT4gb2JqZWN0IChrZXk6dmFsdWUpXG4gICAgKi9cblxuICAgIGlmICh0eXBlb2YgdmFsdWVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG5cbiAgICBBc3NlcnQoIUFycmF5LmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoLCAnVmFsdWVzIGFycmF5IGNhbm5vdCBiZSBlbXB0eScpO1xuXG4gICAgLy8gU3RyaW5nXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zdHJpbmcocmVmLCB2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEFycmF5XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWYpKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuYXJyYXkocmVmLCB2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIE9iamVjdFxuXG4gICAgQXNzZXJ0KHR5cGVvZiByZWYgPT09ICdvYmplY3QnLCAnUmVmZXJlbmNlIG11c3QgYmUgc3RyaW5nIG9yIGFuIG9iamVjdCcpO1xuICAgIHJldHVybiBpbnRlcm5hbHMub2JqZWN0KHJlZiwgdmFsdWVzLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLmFycmF5ID0gZnVuY3Rpb24gKHJlZiwgdmFsdWVzLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm9ubHkgJiZcbiAgICAgICAgb3B0aW9ucy5vbmNlICYmXG4gICAgICAgIHJlZi5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGNvbXBhcmU7XG5cbiAgICAvLyBNYXAgdmFsdWVzXG5cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZXAgfHxcbiAgICAgICAgICAgICF2YWx1ZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IG1hcC5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgKytleGlzdGluZy5hbGxvd2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldCh2YWx1ZSwgeyBhbGxvd2VkOiAxLCBoaXRzOiAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcGFyZSA9IGNvbXBhcmUgfHwgaW50ZXJuYWxzLmNvbXBhcmUob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBleGlzdGluZ10gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICsrZXhpc3RpbmcuYWxsb3dlZDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHZhbHVlLCB7IGFsbG93ZWQ6IDEsIGhpdHM6IDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMb29rdXAgdmFsdWVzXG5cbiAgICBsZXQgaGl0cyA9IDA7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHJlZikge1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGlmICghb3B0aW9ucy5kZWVwIHx8XG4gICAgICAgICAgICAhaXRlbSB8fFxuICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIG1hdGNoID0gbWFwLmdldChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZXhpc3RpbmddIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShrZXksIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgKyttYXRjaC5oaXRzO1xuICAgICAgICAgICAgKytoaXRzO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmNlICYmXG4gICAgICAgICAgICAgICAgbWF0Y2guaGl0cyA+IG1hdGNoLmFsbG93ZWQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHJlc3VsdHNcblxuICAgIGlmIChvcHRpb25zLm9ubHkgJiZcbiAgICAgICAgaGl0cyAhPT0gcmVmLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobWF0Y2guaGl0cyA9PT0gbWF0Y2guYWxsb3dlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2guaGl0cyA8IG1hdGNoLmFsbG93ZWQgJiZcbiAgICAgICAgICAgICFvcHRpb25zLnBhcnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICEhaGl0cztcbn07XG5cblxuaW50ZXJuYWxzLm9iamVjdCA9IGZ1bmN0aW9uIChyZWYsIHZhbHVlcywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMub25jZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHVzZSBvcHRpb24gb25jZSB3aXRoIG9iamVjdCcpO1xuXG4gICAgY29uc3Qga2V5cyA9IFV0aWxzLmtleXMocmVmLCBvcHRpb25zKTtcbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBLZXlzIGxpc3RcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcnJheShrZXlzLCB2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEtleSB2YWx1ZSBwYWlyc1xuXG4gICAgY29uc3Qgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModmFsdWVzKS5maWx0ZXIoKHN5bSkgPT4gdmFsdWVzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bSkpO1xuICAgIGNvbnN0IHRhcmdldHMgPSBbLi4uT2JqZWN0LmtleXModmFsdWVzKSwgLi4uc3ltYm9sc107XG5cbiAgICBjb25zdCBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUob3B0aW9ucyk7XG4gICAgY29uc3Qgc2V0ID0gbmV3IFNldCh0YXJnZXRzKTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFzZXQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb21wYXJlKHZhbHVlc1trZXldLCByZWZba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldC5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICBpZiAoc2V0LnNpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucGFydCA/IHNldC5zaXplIDwgdGFyZ2V0cy5sZW5ndGggOiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZyA9IGZ1bmN0aW9uIChyZWYsIHZhbHVlcywgb3B0aW9ucykge1xuXG4gICAgLy8gRW1wdHkgc3RyaW5nXG5cbiAgICBpZiAocmVmID09PSAnJykge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXNbMF0gPT09ICcnIHx8ICAgICAgICAgICAgICAgLy8gJycgY29udGFpbnMgJydcbiAgICAgICAgICAgICFvcHRpb25zLm9uY2UgJiYgIXZhbHVlcy5zb21lKCh2KSA9PiB2ICE9PSAnJyk7ICAgICAgICAgICAgIC8vICcnIGNvbnRhaW5zIG11bHRpcGxlICcnIGlmICFvbmNlXG4gICAgfVxuXG4gICAgLy8gTWFwIHZhbHVlc1xuXG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhdHRlcm5zID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBBc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ0Nhbm5vdCBjb21wYXJlIHN0cmluZyByZWZlcmVuY2UgdG8gbm9uLXN0cmluZyB2YWx1ZScpO1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBtYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgICAgICsrZXhpc3RpbmcuYWxsb3dlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUsIHsgYWxsb3dlZDogMSwgaGl0czogMCB9KTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJucy5wdXNoKEVzY2FwZVJlZ2V4KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlIHx8XG4gICAgICAgICAgICBvcHRpb25zLm9ubHkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXR0ZXJucy5sZW5ndGgpIHsgICAgICAgICAgICAgICAgICAgICAvLyBOb24tZW1wdHkgc3RyaW5nIGNvbnRhaW5zIHVubGltaXRlZCBlbXB0eSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTWF0Y2ggcGF0dGVybnNcblxuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgKCR7cGF0dGVybnMuam9pbignfCcpfSlgLCAnZycpO1xuICAgIGNvbnN0IGxlZnRvdmVycyA9IHJlZi5yZXBsYWNlKHJlZ2V4LCAoJDAsICQxKSA9PiB7XG5cbiAgICAgICAgKyttYXAuZ2V0KCQxKS5oaXRzO1xuICAgICAgICByZXR1cm4gJyc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gc3RyaW5nXG4gICAgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSByZXN1bHRzXG5cbiAgICBpZiAob3B0aW9ucy5vbmx5ICYmXG4gICAgICAgIGxlZnRvdmVycykge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgYW55ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKG1hdGNoLmhpdHMpIHtcbiAgICAgICAgICAgIGFueSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2guaGl0cyA9PT0gbWF0Y2guYWxsb3dlZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF0Y2guaGl0cyA8IG1hdGNoLmFsbG93ZWQgJiZcbiAgICAgICAgICAgICFvcHRpb25zLnBhcnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWF0Y2guaGl0cyA+IG1hdGNoLmFsbG93ZWRcblxuICAgICAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gISFhbnk7XG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGlmICghb3B0aW9ucy5kZWVwKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2hhbGxvdztcbiAgICB9XG5cbiAgICBjb25zdCBoYXNPbmx5ID0gb3B0aW9ucy5vbmx5ICE9PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzUGFydCA9IG9wdGlvbnMucGFydCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgZmxhZ3MgPSB7XG4gICAgICAgIHByb3RvdHlwZTogaGFzT25seSA/IG9wdGlvbnMub25seSA6IGhhc1BhcnQgPyAhb3B0aW9ucy5wYXJ0IDogZmFsc2UsXG4gICAgICAgIHBhcnQ6IGhhc09ubHkgPyAhb3B0aW9ucy5vbmx5IDogaGFzUGFydCA/IG9wdGlvbnMucGFydCA6IGZhbHNlXG4gICAgfTtcblxuICAgIHJldHVybiAoYSwgYikgPT4gRGVlcEVxdWFsKGEsIGIsIGZsYWdzKTtcbn07XG5cblxuaW50ZXJuYWxzLnNoYWxsb3cgPSBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcmV0dXJuIGEgPT09IGI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUeXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWlzbWF0Y2hlZDogbnVsbFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIHJlZiwgb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBwcm90b3R5cGU6IHRydWUgfSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gISFpbnRlcm5hbHMuaXNEZWVwRXF1YWwob2JqLCByZWYsIG9wdGlvbnMsIFtdKTtcbn07XG5cblxuaW50ZXJuYWxzLmlzRGVlcEVxdWFsID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBvcHRpb25zLCBzZWVuKSB7XG5cbiAgICBpZiAob2JqID09PSByZWYpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3BpZWQgZnJvbSBEZWVwLWVxbCwgY29weXJpZ2h0KGMpIDIwMTMgSmFrZSBMdWVyLCBqYWtlQGFsb2dpY2FscGFyYWRveC5jb20sIE1JVCBMaWNlbnNlZCwgaHR0cHM6Ly9naXRodWIuY29tL2NoYWlqcy9kZWVwLWVxbFxuICAgICAgICByZXR1cm4gb2JqICE9PSAwIHx8IDEgLyBvYmogPT09IDEgLyByZWY7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBvYmo7XG5cbiAgICBpZiAodHlwZSAhPT0gdHlwZW9mIHJlZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fFxuICAgICAgICByZWYgPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZXBGdW5jdGlvbiB8fFxuICAgICAgICAgICAgb2JqLnRvU3RyaW5nKCkgIT09IHJlZi50b1N0cmluZygpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRpbnVlIGFzIG9iamVjdFxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb2JqICE9PSBvYmogJiYgcmVmICE9PSByZWY7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5hTlxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlVHlwZSA9IGludGVybmFscy5nZXRTaGFyZWRUeXBlKG9iaiwgcmVmLCAhIW9wdGlvbnMucHJvdG90eXBlKTtcbiAgICBzd2l0Y2ggKGluc3RhbmNlVHlwZSkge1xuICAgICAgICBjYXNlIFR5cGVzLmJ1ZmZlcjpcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIgJiYgQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMuY2FsbChvYmosIHJlZik7ICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgY2FzZSBUeXBlcy5wcm9taXNlOlxuICAgICAgICAgICAgcmV0dXJuIG9iaiA9PT0gcmVmO1xuICAgICAgICBjYXNlIFR5cGVzLnJlZ2V4OlxuICAgICAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpID09PSByZWYudG9TdHJpbmcoKTtcbiAgICAgICAgY2FzZSBpbnRlcm5hbHMubWlzbWF0Y2hlZDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gc2Vlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoc2VlbltpXS5pc1NhbWUob2JqLCByZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJldmlvdXMgY29tcGFyaXNvbiBmYWlsZWQsIGl0IHdvdWxkIGhhdmUgc3RvcHBlZCBleGVjdXRpb25cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlZW4ucHVzaChuZXcgaW50ZXJuYWxzLlNlZW5FbnRyeShvYmosIHJlZikpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICEhaW50ZXJuYWxzLmlzRGVlcEVxdWFsT2JqKGluc3RhbmNlVHlwZSwgb2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgc2Vlbi5wb3AoKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5nZXRTaGFyZWRUeXBlID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBjaGVja1Byb3RvdHlwZSkge1xuXG4gICAgaWYgKGNoZWNrUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSAhPT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubWlzbWF0Y2hlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKG9iaik7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICBpZiAodHlwZSAhPT0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhyZWYpKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMubWlzbWF0Y2hlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbHVlT2YgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBjb25zdCBvYmpWYWx1ZU9mID0gb2JqLnZhbHVlT2Y7XG4gICAgaWYgKG9ialZhbHVlT2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvYmpWYWx1ZU9mLmNhbGwob2JqKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmhhc093bkVudW1lcmFibGVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIGtleSk7XG59O1xuXG5cbmludGVybmFscy5pc1NldFNpbXBsZUVxdWFsID0gZnVuY3Rpb24gKG9iaiwgcmVmKSB7XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG9iaikge1xuICAgICAgICBpZiAoIXJlZi5oYXMoZW50cnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLmlzRGVlcEVxdWFsT2JqID0gZnVuY3Rpb24gKGluc3RhbmNlVHlwZSwgb2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pIHtcblxuICAgIGNvbnN0IHsgaXNEZWVwRXF1YWwsIHZhbHVlT2YsIGhhc093bkVudW1lcmFibGVQcm9wZXJ0eSB9ID0gaW50ZXJuYWxzO1xuICAgIGNvbnN0IHsga2V5cywgZ2V0T3duUHJvcGVydHlTeW1ib2xzIH0gPSBPYmplY3Q7XG5cbiAgICBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5hcnJheSkge1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJ0KSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSBpbmRleCBtYXRjaCBhbnkgb3RoZXIgaW5kZXhcblxuICAgICAgICAgICAgZm9yIChjb25zdCBvYmpWYWx1ZSBvZiBvYmopIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZlZhbHVlIG9mIHJlZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwob2JqVmFsdWUsIHJlZlZhbHVlLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob2JqLmxlbmd0aCAhPT0gcmVmLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtpXSwgcmVmW2ldLCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLnNldCkge1xuICAgICAgICBpZiAob2JqLnNpemUgIT09IHJlZi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludGVybmFscy5pc1NldFNpbXBsZUVxdWFsKG9iaiwgcmVmKSkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZGVlcCBlcXVhbGl0eVxuXG4gICAgICAgICAgICBjb25zdCByZWYyID0gbmV3IFNldChyZWYpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvYmpFbnRyeSBvZiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmMi5kZWxldGUob2JqRW50cnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVmRW50cnkgb2YgcmVmMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWVwRXF1YWwob2JqRW50cnksIHJlZkVudHJ5LCBvcHRpb25zLCBzZWVuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmMi5kZWxldGUocmVmRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5tYXApIHtcbiAgICAgICAgaWYgKG9iai5zaXplICE9PSByZWYuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhcmVmLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKHZhbHVlLCByZWYuZ2V0KGtleSksIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuZXJyb3IpIHtcblxuICAgICAgICAvLyBBbHdheXMgY2hlY2sgbmFtZSBhbmQgbWVzc2FnZVxuXG4gICAgICAgIGlmIChvYmoubmFtZSAhPT0gcmVmLm5hbWUgfHxcbiAgICAgICAgICAgIG9iai5tZXNzYWdlICE9PSByZWYubWVzc2FnZSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayAudmFsdWVPZigpXG5cbiAgICBjb25zdCB2YWx1ZU9mT2JqID0gdmFsdWVPZihvYmopO1xuICAgIGNvbnN0IHZhbHVlT2ZSZWYgPSB2YWx1ZU9mKHJlZik7XG4gICAgaWYgKChvYmogIT09IHZhbHVlT2ZPYmogfHwgcmVmICE9PSB2YWx1ZU9mUmVmKSAmJlxuICAgICAgICAhaXNEZWVwRXF1YWwodmFsdWVPZk9iaiwgdmFsdWVPZlJlZiwgb3B0aW9ucywgc2VlbikpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgcHJvcGVydGllc1xuXG4gICAgY29uc3Qgb2JqS2V5cyA9IGtleXMob2JqKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydCAmJlxuICAgICAgICBvYmpLZXlzLmxlbmd0aCAhPT0ga2V5cyhyZWYpLmxlbmd0aCAmJlxuICAgICAgICAhb3B0aW9ucy5za2lwKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBza2lwcGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBvYmpLZXlzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNraXAgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuc2tpcC5pbmNsdWRlcyhrZXkpKSB7XG5cbiAgICAgICAgICAgIGlmIChyZWZba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgKytza2lwcGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpba2V5XSwgcmVmW2tleV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMucGFydCAmJlxuICAgICAgICBvYmpLZXlzLmxlbmd0aCAtIHNraXBwZWQgIT09IGtleXMocmVmKS5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgc3ltYm9sc1xuXG4gICAgaWYgKG9wdGlvbnMuc3ltYm9scyAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgY29uc3Qgb2JqU3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuICAgICAgICBjb25zdCByZWZTeW1ib2xzID0gbmV3IFNldChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocmVmKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb2JqU3ltYm9scykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnNraXAgfHxcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5za2lwLmluY2x1ZGVzKGtleSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbChvYmpba2V5XSwgcmVmW2tleV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWZTeW1ib2xzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVmU3ltYm9scykge1xuICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShyZWYsIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLlNlZW5FbnRyeSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9iaiwgcmVmKSB7XG5cbiAgICAgICAgdGhpcy5vYmogPSBvYmo7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cblxuICAgIGlzU2FtZShvYmosIHJlZikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9iaiA9PT0gb2JqICYmIHRoaXMucmVmID09PSByZWY7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IoYXJncykge1xuXG4gICAgICAgIGNvbnN0IG1zZ3MgPSBhcmdzXG4gICAgICAgICAgICAuZmlsdGVyKChhcmcpID0+IGFyZyAhPT0gJycpXG4gICAgICAgICAgICAubWFwKChhcmcpID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyA/IGFyZyA6IGFyZyBpbnN0YW5jZW9mIEVycm9yID8gYXJnLm1lc3NhZ2UgOiBTdHJpbmdpZnkoYXJnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyKG1zZ3Muam9pbignICcpIHx8ICdVbmtub3duIGVycm9yJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJykgeyAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgZXhwb3J0cy5hc3NlcnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblxuICAgIC8vIEFsbG93ZWQgdmFsdWUgY2hhcmFjdGVyczogISMkJSYnKCkqKywtLi86Ozw9Pj9AW11eX2B7fH1+IGFuZCBzcGFjZSwgYS16LCBBLVosIDAtOSwgXFwsIFwiXG5cbiAgICBBc3NlcnQoL15bIFxcd1xcISNcXCQlJidcXChcXClcXCpcXCssXFwtXFwuXFwvXFw6OzxcXD0+XFw/QFxcW1xcXVxcXmBcXHtcXHxcXH1+XFxcIlxcXFxdKiQvLnRlc3QoYXR0cmlidXRlKSwgJ0JhZCBhdHRyaWJ1dGUgdmFsdWUgKCcgKyBhdHRyaWJ1dGUgKyAnKScpO1xuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZS5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1xcXCIvZywgJ1xcXFxcIicpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXNjYXBlIHF1b3RlcyBhbmQgc2xhc2hcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgZXNjYXBlZCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7ICsraSkge1xuXG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoaW50ZXJuYWxzLmlzU2FmZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW5wdXRbaV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlc2NhcGVkICs9IGludGVybmFscy5lc2NhcGVIdG1sQ2hhcihjaGFyQ29kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXNjYXBlZDtcbn07XG5cblxuaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG5cbiAgICBjb25zdCBuYW1lZEVzY2FwZSA9IGludGVybmFscy5uYW1lZEh0bWxbY2hhckNvZGVdO1xuICAgIGlmICh0eXBlb2YgbmFtZWRFc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYW1lZEVzY2FwZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhckNvZGUgPj0gMjU2KSB7XG4gICAgICAgIHJldHVybiAnJiMnICsgY2hhckNvZGUgKyAnOyc7XG4gICAgfVxuXG4gICAgY29uc3QgaGV4VmFsdWUgPSBjaGFyQ29kZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKTtcbiAgICByZXR1cm4gYCYjeCR7aGV4VmFsdWV9O2A7XG59O1xuXG5cbmludGVybmFscy5pc1NhZmUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcblxuICAgIHJldHVybiAodHlwZW9mIGludGVybmFscy5zYWZlQ2hhckNvZGVzW2NoYXJDb2RlXSAhPT0gJ3VuZGVmaW5lZCcpO1xufTtcblxuXG5pbnRlcm5hbHMubmFtZWRIdG1sID0ge1xuICAgICczOCc6ICcmYW1wOycsXG4gICAgJzYwJzogJyZsdDsnLFxuICAgICc2Mic6ICcmZ3Q7JyxcbiAgICAnMzQnOiAnJnF1b3Q7JyxcbiAgICAnMTYwJzogJyZuYnNwOycsXG4gICAgJzE2Mic6ICcmY2VudDsnLFxuICAgICcxNjMnOiAnJnBvdW5kOycsXG4gICAgJzE2NCc6ICcmY3VycmVuOycsXG4gICAgJzE2OSc6ICcmY29weTsnLFxuICAgICcxNzQnOiAnJnJlZzsnXG59O1xuXG5cbmludGVybmFscy5zYWZlQ2hhckNvZGVzID0gKGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHNhZmUgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAzMjsgaSA8IDEyMzsgKytpKSB7XG5cbiAgICAgICAgaWYgKChpID49IDk3KSB8fCAgICAgICAgICAgICAgICAgICAgLy8gYS16XG4gICAgICAgICAgICAoaSA+PSA2NSAmJiBpIDw9IDkwKSB8fCAgICAgICAgIC8vIEEtWlxuICAgICAgICAgICAgKGkgPj0gNDggJiYgaSA8PSA1NykgfHwgICAgICAgICAvLyAwLTlcbiAgICAgICAgICAgIGkgPT09IDMyIHx8ICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgICAgIGkgPT09IDQ2IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLlxuICAgICAgICAgICAgaSA9PT0gNDQgfHwgICAgICAgICAgICAgICAgICAgICAvLyAsXG4gICAgICAgICAgICBpID09PSA0NSB8fCAgICAgICAgICAgICAgICAgICAgIC8vIC1cbiAgICAgICAgICAgIGkgPT09IDU4IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gOlxuICAgICAgICAgICAgaSA9PT0gOTUpIHsgICAgICAgICAgICAgICAgICAgICAvLyBfXG5cbiAgICAgICAgICAgIHNhZmVbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhZmU7XG59KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgbGVzc1RoYW4gPSAweDNDO1xuICAgIGNvbnN0IGdyZWF0ZXJUaGFuID0gMHgzRTtcbiAgICBjb25zdCBhbmRTeW1ib2wgPSAweDI2O1xuICAgIGNvbnN0IGxpbmVTZXBlcmF0b3IgPSAweDIwMjg7XG5cbiAgICAvLyByZXBsYWNlIG1ldGhvZFxuICAgIGxldCBjaGFyQ29kZTtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWzw+JlxcdTIwMjhcXHUyMDI5XS9nLCAobWF0Y2gpID0+IHtcblxuICAgICAgICBjaGFyQ29kZSA9IG1hdGNoLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSBsZXNzVGhhbikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTAwM2MnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSBncmVhdGVyVGhhbikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTAwM2UnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSBhbmRTeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHUwMDI2JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFyQ29kZSA9PT0gbGluZVNlcGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTIwMjgnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdcXFxcdTIwMjknO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICAvLyBFc2NhcGUgXiQuKistPz0hOnxcXC8oKVtde30sXG5cbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXF5cXCRcXC5cXCpcXCtcXC1cXD9cXD1cXCFcXDpcXHxcXFxcXFwvXFwoXFwpXFxbXFxdXFx7XFx9XFwsXS9nLCAnXFxcXCQmJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5mbGF0dGVuID0gZnVuY3Rpb24gKGFycmF5LCB0YXJnZXQpIHtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHRhcmdldCB8fCBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlbaV0pKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuZmxhdHRlbihhcnJheVtpXSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYXBwbHlUb0RlZmF1bHRzOiByZXF1aXJlKCcuL2FwcGx5VG9EZWZhdWx0cycpLFxuICAgIGFzc2VydDogcmVxdWlyZSgnLi9hc3NlcnQnKSxcbiAgICBCZW5jaDogcmVxdWlyZSgnLi9iZW5jaCcpLFxuICAgIGJsb2NrOiByZXF1aXJlKCcuL2Jsb2NrJyksXG4gICAgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKSxcbiAgICBjb250YWluOiByZXF1aXJlKCcuL2NvbnRhaW4nKSxcbiAgICBkZWVwRXF1YWw6IHJlcXVpcmUoJy4vZGVlcEVxdWFsJyksXG4gICAgRXJyb3I6IHJlcXVpcmUoJy4vZXJyb3InKSxcbiAgICBlc2NhcGVIZWFkZXJBdHRyaWJ1dGU6IHJlcXVpcmUoJy4vZXNjYXBlSGVhZGVyQXR0cmlidXRlJyksXG4gICAgZXNjYXBlSHRtbDogcmVxdWlyZSgnLi9lc2NhcGVIdG1sJyksXG4gICAgZXNjYXBlSnNvbjogcmVxdWlyZSgnLi9lc2NhcGVKc29uJyksXG4gICAgZXNjYXBlUmVnZXg6IHJlcXVpcmUoJy4vZXNjYXBlUmVnZXgnKSxcbiAgICBmbGF0dGVuOiByZXF1aXJlKCcuL2ZsYXR0ZW4nKSxcbiAgICBpZ25vcmU6IHJlcXVpcmUoJy4vaWdub3JlJyksXG4gICAgaW50ZXJzZWN0OiByZXF1aXJlKCcuL2ludGVyc2VjdCcpLFxuICAgIG1lcmdlOiByZXF1aXJlKCcuL21lcmdlJyksXG4gICAgb25jZTogcmVxdWlyZSgnLi9vbmNlJyksXG4gICAgcmVhY2g6IHJlcXVpcmUoJy4vcmVhY2gnKSxcbiAgICByZWFjaFRlbXBsYXRlOiByZXF1aXJlKCcuL3JlYWNoVGVtcGxhdGUnKSxcbiAgICBzdHJpbmdpZnk6IHJlcXVpcmUoJy4vc3RyaW5naWZ5JyksXG4gICAgd2FpdDogcmVxdWlyZSgnLi93YWl0Jylcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmICghYXJyYXkxIHx8XG4gICAgICAgICFhcnJheTIpIHtcblxuICAgICAgICByZXR1cm4gKG9wdGlvbnMuZmlyc3QgPyBudWxsIDogW10pO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1vbiA9IFtdO1xuICAgIGNvbnN0IGhhc2ggPSAoQXJyYXkuaXNBcnJheShhcnJheTEpID8gbmV3IFNldChhcnJheTEpIDogYXJyYXkxKTtcbiAgICBjb25zdCBmb3VuZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGFycmF5Mikge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLmhhcyhoYXNoLCB2YWx1ZSkgJiZcbiAgICAgICAgICAgICFmb3VuZC5oYXModmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpcnN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb21tb24ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBmb3VuZC5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChvcHRpb25zLmZpcnN0ID8gbnVsbCA6IGNvbW1vbik7XG59O1xuXG5cbmludGVybmFscy5oYXMgPSBmdW5jdGlvbiAocmVmLCBrZXkpIHtcblxuICAgIGlmICh0eXBlb2YgcmVmLmhhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcmVmLmhhcyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZba2V5XSAhPT0gdW5kZWZpbmVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnLi9jbG9uZScpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydCh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHRhcmdldCB2YWx1ZTogbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICBBc3NlcnQoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBudWxsT3ZlcnJpZGU6IHRydWUsIG1lcmdlQXJyYXlzOiB0cnVlIH0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICBBc3NlcnQoQXJyYXkuaXNBcnJheSh0YXJnZXQpLCAnQ2Fubm90IG1lcmdlIGFycmF5IG9udG8gYW4gb2JqZWN0Jyk7XG4gICAgICAgIGlmICghb3B0aW9ucy5tZXJnZUFycmF5cykge1xuICAgICAgICAgICAgdGFyZ2V0Lmxlbmd0aCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE11c3Qgbm90IGNoYW5nZSB0YXJnZXQgYXNzaWdubWVudFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKENsb25lKHNvdXJjZVtpXSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gVXRpbHMua2V5cyhzb3VyY2UsIG9wdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJyB8fFxuICAgICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIHtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRba2V5XSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh0YXJnZXRba2V5XSkgIT09IEFycmF5LmlzQXJyYXkodmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgICAgIChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkgfHwgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBDbG9uZSh2YWx1ZSwgeyBzeW1ib2xzOiBvcHRpb25zLnN5bWJvbHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHMubWVyZ2UodGFyZ2V0W2tleV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCB0byBwcmVzZXJ2ZSBlbXB0eSBzdHJpbmdzXG5cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5udWxsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuXG4gICAgaWYgKG1ldGhvZC5faG9la09uY2UpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICB9XG5cbiAgICBsZXQgb25jZSA9IGZhbHNlO1xuICAgIGNvbnN0IHdyYXBwZWQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIGlmICghb25jZSkge1xuICAgICAgICAgICAgb25jZSA9IHRydWU7XG4gICAgICAgICAgICBtZXRob2QoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgd3JhcHBlZC5faG9la09uY2UgPSB0cnVlO1xuICAgIHJldHVybiB3cmFwcGVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGNoYWluLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoY2hhaW4gPT09IGZhbHNlIHx8XG4gICAgICAgIGNoYWluID09PSBudWxsIHx8XG4gICAgICAgIGNoYWluID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc2VwYXJhdG9yOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgY29uc3QgaXNDaGFpbkFycmF5ID0gQXJyYXkuaXNBcnJheShjaGFpbik7XG5cbiAgICBBc3NlcnQoIWlzQ2hhaW5BcnJheSB8fCAhb3B0aW9ucy5zZXBhcmF0b3IsICdTZXBhcmF0b3Igb3B0aW9uIG5vIHZhbGlkIGZvciBhcnJheS1iYXNlZCBjaGFpbicpO1xuXG4gICAgY29uc3QgcGF0aCA9IGlzQ2hhaW5BcnJheSA/IGNoYWluIDogY2hhaW4uc3BsaXQob3B0aW9ucy5zZXBhcmF0b3IgfHwgJy4nKTtcbiAgICBsZXQgcmVmID0gb2JqO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICBsZXQga2V5ID0gcGF0aFtpXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMuaXRlcmFibGVzICYmIGludGVybmFscy5pdGVyYWJsZXMocmVmKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWYpIHx8XG4gICAgICAgICAgICB0eXBlID09PSAnc2V0Jykge1xuXG4gICAgICAgICAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIoa2V5KTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBudW1iZXIgPCAwID8gcmVmLmxlbmd0aCArIG51bWJlciA6IG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmIHx8XG4gICAgICAgICAgICB0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMuZnVuY3Rpb25zID09PSBmYWxzZSB8fCAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICF0eXBlICYmIHJlZltrZXldID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KCFvcHRpb25zLnN0cmljdCB8fCBpICsgMSA9PT0gcGF0aC5sZW5ndGgsICdNaXNzaW5nIHNlZ21lbnQnLCBrZXksICdpbiByZWFjaCBwYXRoICcsIGNoYWluKTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyB8fCBvcHRpb25zLmZ1bmN0aW9ucyA9PT0gdHJ1ZSB8fCB0eXBlb2YgcmVmICE9PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBzZWdtZW50Jywga2V5LCAnaW4gcmVhY2ggcGF0aCAnLCBjaGFpbik7XG4gICAgICAgICAgICByZWYgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmVmID0gcmVmW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgIHJlZiA9IFsuLi5yZWZdW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7ICAvLyB0eXBlID09PSAnbWFwJ1xuICAgICAgICAgICAgcmVmID0gcmVmLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZjtcbn07XG5cblxuaW50ZXJuYWxzLml0ZXJhYmxlcyA9IGZ1bmN0aW9uIChyZWYpIHtcblxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuICdzZXQnO1xuICAgIH1cblxuICAgIGlmIChyZWYgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuICdtYXAnO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnLi9yZWFjaCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgdGVtcGxhdGUsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97KFtefV0rKX0vZywgKCQwLCBjaGFpbikgPT4ge1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gUmVhY2gob2JqLCBjaGFpbiwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiAnW0Nhbm5vdCBkaXNwbGF5IG9iamVjdDogJyArIGVyci5tZXNzYWdlICsgJ10nO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcnJheTogQXJyYXkucHJvdG90eXBlLFxuICAgIGJ1ZmZlcjogQnVmZmVyICYmIEJ1ZmZlci5wcm90b3R5cGUsICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGRhdGU6IERhdGUucHJvdG90eXBlLFxuICAgIGVycm9yOiBFcnJvci5wcm90b3R5cGUsXG4gICAgZ2VuZXJpYzogT2JqZWN0LnByb3RvdHlwZSxcbiAgICBtYXA6IE1hcC5wcm90b3R5cGUsXG4gICAgcHJvbWlzZTogUHJvbWlzZS5wcm90b3R5cGUsXG4gICAgcmVnZXg6IFJlZ0V4cC5wcm90b3R5cGUsXG4gICAgc2V0OiBTZXQucHJvdG90eXBlLFxuICAgIHdlYWtNYXA6IFdlYWtNYXAucHJvdG90eXBlLFxuICAgIHdlYWtTZXQ6IFdlYWtTZXQucHJvdG90eXBlXG59O1xuXG5cbmludGVybmFscy50eXBlTWFwID0gbmV3IE1hcChbXG4gICAgWydbb2JqZWN0IEVycm9yXScsIGV4cG9ydHMuZXJyb3JdLFxuICAgIFsnW29iamVjdCBNYXBdJywgZXhwb3J0cy5tYXBdLFxuICAgIFsnW29iamVjdCBQcm9taXNlXScsIGV4cG9ydHMucHJvbWlzZV0sXG4gICAgWydbb2JqZWN0IFNldF0nLCBleHBvcnRzLnNldF0sXG4gICAgWydbb2JqZWN0IFdlYWtNYXBdJywgZXhwb3J0cy53ZWFrTWFwXSxcbiAgICBbJ1tvYmplY3QgV2Vha1NldF0nLCBleHBvcnRzLndlYWtTZXRdXG5dKTtcblxuXG5leHBvcnRzLmdldEludGVybmFsUHJvdG8gPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmFycmF5O1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQnVmZmVyKSB7ICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICByZXR1cm4gZXhwb3J0cy5idWZmZXI7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlZ2V4O1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lcnJvcjtcbiAgICB9XG5cbiAgICBjb25zdCBvYmpOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgcmV0dXJuIGludGVybmFscy50eXBlTWFwLmdldChvYmpOYW1lKSB8fCBleHBvcnRzLmdlbmVyaWM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJy4vcmVhY2gnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmtleXMgPSBmdW5jdGlvbiAob2JqLCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBvcHRpb25zLnN5bWJvbHMgIT09IGZhbHNlID8gUmVmbGVjdC5vd25LZXlzKG9iaikgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopOyAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxufTtcblxuXG5leHBvcnRzLnN0b3JlID0gZnVuY3Rpb24gKHNvdXJjZSwga2V5cykge1xuXG4gICAgY29uc3Qgc3RvcmFnZSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBSZWFjaChzb3VyY2UsIGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBpbnRlcm5hbHMucmVhY2hTZXQoc291cmNlLCBrZXksIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RvcmFnZTtcbn07XG5cblxuZXhwb3J0cy5yZXN0b3JlID0gZnVuY3Rpb24gKGNvcHksIHNvdXJjZSwgc3RvcmFnZSkge1xuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RvcmFnZSkge1xuICAgICAgICBpbnRlcm5hbHMucmVhY2hTZXQoY29weSwga2V5LCB2YWx1ZSk7XG4gICAgICAgIGludGVybmFscy5yZWFjaFNldChzb3VyY2UsIGtleSwgdmFsdWUpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJlYWNoU2V0ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuXG4gICAgY29uc3QgcGF0aCA9IEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleSA6IGtleS5zcGxpdCgnLicpO1xuICAgIGxldCByZWYgPSBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoW2ldO1xuICAgICAgICBpZiAoaSArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICByZWZbc2VnbWVudF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZiA9IHJlZltzZWdtZW50XTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IEpvaSA9IHJlcXVpcmUoJ0BoYXBpL2pvaScpO1xuXG5jb25zdCBGaWxlID0gcmVxdWlyZSgnLi9maWxlJyk7XG5jb25zdCBGcyA9IHJlcXVpcmUoJy4vZnMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hID0gSm9pLm9iamVjdCh7XG4gICAgcGF0aDogSm9pLmFsdGVybmF0aXZlcyhKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLCBKb2kuZnVuYygpKS5yZXF1aXJlZCgpLFxuICAgIGluZGV4OiBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5ib29sZWFuKCksIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCkpLmRlZmF1bHQodHJ1ZSksXG4gICAgbGlzdGluZzogSm9pLmJvb2xlYW4oKSxcbiAgICBzaG93SGlkZGVuOiBKb2kuYm9vbGVhbigpLFxuICAgIHJlZGlyZWN0VG9TbGFzaDogSm9pLmJvb2xlYW4oKSxcbiAgICBsb29rdXBDb21wcmVzc2VkOiBKb2kuYm9vbGVhbigpLFxuICAgIGxvb2t1cE1hcDogSm9pLm9iamVjdCgpLm1pbigxKS5wYXR0ZXJuKC8uKy8sIEpvaS5zdHJpbmcoKSksXG4gICAgZXRhZ01ldGhvZDogSm9pLnN0cmluZygpLnZhbGlkKCdoYXNoJywgJ3NpbXBsZScpLmFsbG93KGZhbHNlKSxcbiAgICBkZWZhdWx0RXh0ZW5zaW9uOiBKb2kuc3RyaW5nKCkuYWxwaGFudW0oKVxufSk7XG5cblxuaW50ZXJuYWxzLnJlc29sdmVQYXRoT3B0aW9uID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuXG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtyZXN1bHRdO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB0aHJvdyBCb29tLmludGVybmFsKCdJbnZhbGlkIHBhdGggZnVuY3Rpb24nKTtcbn07XG5cblxuZXhwb3J0cy5oYW5kbGVyID0gZnVuY3Rpb24gKHJvdXRlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IEpvaS5hdHRlbXB0KG9wdGlvbnMsIGludGVybmFscy5zY2hlbWEsICdJbnZhbGlkIGRpcmVjdG9yeSBoYW5kbGVyIG9wdGlvbnMgKCcgKyByb3V0ZS5wYXRoICsgJyknKTtcbiAgICBIb2VrLmFzc2VydChyb3V0ZS5wYXRoW3JvdXRlLnBhdGgubGVuZ3RoIC0gMV0gPT09ICd9JywgJ1RoZSByb3V0ZSBwYXRoIGZvciBhIGRpcmVjdG9yeSBoYW5kbGVyIG11c3QgZW5kIHdpdGggYSBwYXJhbWV0ZXI6Jywgcm91dGUucGF0aCk7XG5cbiAgICBjb25zdCBwYXJhbU5hbWUgPSAvXFx3Ky8uZXhlYyhyb3V0ZS5wYXRoLnNsaWNlKHJvdXRlLnBhdGgubGFzdEluZGV4T2YoJ3snKSkpWzBdO1xuICAgIGNvbnN0IGJhc2VQYXRoID0gcm91dGUuc2V0dGluZ3MuZmlsZXMucmVsYXRpdmVUbztcblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAoQXJyYXkuaXNBcnJheShzZXR0aW5ncy5wYXRoKSA/IHNldHRpbmdzLnBhdGggOiBudWxsKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXJyYXkgb3IgZnVuY3Rpb25cbiAgICBjb25zdCBpbmRleE5hbWVzID0gKHNldHRpbmdzLmluZGV4ID09PSB0cnVlKSA/IFsnaW5kZXguaHRtbCddIDogKHNldHRpbmdzLmluZGV4IHx8IFtdKTtcblxuICAgIC8vIERlY2xhcmUgaGFuZGxlclxuXG4gICAgY29uc3QgaGFuZGxlciA9IGFzeW5jIChyZXF1ZXN0LCByZXBseSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhdGhzID0gbm9ybWFsaXplZCB8fCBpbnRlcm5hbHMucmVzb2x2ZVBhdGhPcHRpb24oc2V0dGluZ3MucGF0aC5jYWxsKG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgICAvLyBBcHBlbmQgcGFyYW1ldGVyXG5cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gcmVxdWVzdC5wYXJhbXNbcGFyYW1OYW1lXTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJlxuICAgICAgICAgICAgIXNldHRpbmdzLnNob3dIaWRkZW4gJiZcbiAgICAgICAgICAgIGludGVybmFscy5pc0ZpbGVIaWRkZW4oc2VsZWN0aW9uKSkge1xuXG4gICAgICAgICAgICB0aHJvdyBCb29tLm5vdEZvdW5kKG51bGwsIHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZWN0aW9uICYmXG4gICAgICAgICAgICAocmVxdWVzdC5zZXJ2ZXIuc2V0dGluZ3Mucm91dGVyLnN0cmlwVHJhaWxpbmdTbGFzaCB8fCAhcmVxdWVzdC5wYXRoLmVuZHNXaXRoKCcvJykpKSB7XG5cbiAgICAgICAgICAgIHJlcXVlc3QucGF0aCArPSAnLyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSByZXNwb25zZVxuXG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gcmVxdWVzdC5wYXRoO1xuICAgICAgICBjb25zdCBoYXNUcmFpbGluZ1NsYXNoID0gcmVzb3VyY2UuZW5kc1dpdGgoJy8nKTtcbiAgICAgICAgY29uc3QgZmlsZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb25maW5lOiBudWxsLFxuICAgICAgICAgICAgbG9va3VwQ29tcHJlc3NlZDogc2V0dGluZ3MubG9va3VwQ29tcHJlc3NlZCxcbiAgICAgICAgICAgIGxvb2t1cE1hcDogc2V0dGluZ3MubG9va3VwTWFwLFxuICAgICAgICAgICAgZXRhZ01ldGhvZDogc2V0dGluZ3MuZXRhZ01ldGhvZFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVhY2ggPSBhc3luYyAoYmFzZURpcikgPT4ge1xuXG4gICAgICAgICAgICBmaWxlT3B0aW9ucy5jb25maW5lID0gYmFzZURpcjtcblxuICAgICAgICAgICAgbGV0IHBhdGggPSBzZWxlY3Rpb24gfHwgJyc7XG4gICAgICAgICAgICBsZXQgZXJyb3I7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IEZpbGUubG9hZChwYXRoLCByZXF1ZXN0LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgQm91bmNlLmlnbm9yZShlcnIsICdib29tJyk7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBOb3QgZm91bmRcblxuICAgICAgICAgICAgaWYgKGludGVybmFscy5pc05vdEZvdW5kKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuZGVmYXVsdEV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IEZpbGUubG9hZChwYXRoICsgJy4nICsgc2V0dGluZ3MuZGVmYXVsdEV4dGVuc2lvbiwgcmVxdWVzdCwgZmlsZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIYW5kbGUgRGlyZWN0b3J5XG5cbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNEaXJlY3RvcnkoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJlZGlyZWN0VG9TbGFzaCAhPT0gZmFsc2UgJiYgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgICAgIXJlcXVlc3Quc2VydmVyLnNldHRpbmdzLnJvdXRlci5zdHJpcFRyYWlsaW5nU2xhc2ggJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc1RyYWlsaW5nU2xhc2gpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbHkucmVkaXJlY3QocmVzb3VyY2UgKyAnLycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXhOYW1lIG9mIGluZGV4TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXhGaWxlID0gUGF0aC5qb2luKHBhdGgsIGluZGV4TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgRmlsZS5sb2FkKGluZGV4RmlsZSwgcmVxdWVzdCwgZmlsZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJvdW5jZS5pZ25vcmUoZXJyLCAnYm9vbScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5pc05vdEZvdW5kKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmludGVybmFsKGluZGV4TmFtZSArICcgaXMgYSBkaXJlY3RvcnknLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZm91bmQgLSB0cnkgbmV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm9uZSBvZiB0aGUgaW5kZXggZmlsZXMgd2VyZSBmb3VuZFxuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmxpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZUxpc3RpbmcoUGF0aC5qb2luKGJhc2VQYXRoLCBiYXNlRGlyLCBwYXRoKSwgcmVzb3VyY2UsIHNlbGVjdGlvbiwgaGFzVHJhaWxpbmdTbGFzaCwgc2V0dGluZ3MsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZWFjaChwYXRoc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgQm91bmNlLmlnbm9yZShlcnIsICdib29tJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBQcm9wYWdhdGUgYW55IG5vbi00MDQgZXJyb3JzXG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy5pc05vdEZvdW5kKGVycikgfHxcbiAgICAgICAgICAgICAgICAgICAgaSA9PT0gcGF0aHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgQm9vbS5ub3RGb3VuZChudWxsLCB7fSk7XG4gICAgfTtcblxuICAgIHJldHVybiBoYW5kbGVyO1xufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGVMaXN0aW5nID0gYXN5bmMgZnVuY3Rpb24gKHBhdGgsIHJlc291cmNlLCBzZWxlY3Rpb24sIGhhc1RyYWlsaW5nU2xhc2gsIHNldHRpbmdzLCByZXF1ZXN0KSB7XG5cbiAgICBsZXQgZmlsZXM7XG4gICAgdHJ5IHtcbiAgICAgICAgZmlsZXMgPSBhd2FpdCBGcy5yZWFkZGlyKHBhdGgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICB0aHJvdyBCb29tLmludGVybmFsKCdFcnJvciBhY2Nlc3NpbmcgZGlyZWN0b3J5JywgZXJyKTtcbiAgICB9XG5cbiAgICByZXNvdXJjZSA9IGRlY29kZVVSSUNvbXBvbmVudChyZXNvdXJjZSk7XG4gICAgY29uc3QgZGlzcGxheSA9IEhvZWsuZXNjYXBlSHRtbChyZXNvdXJjZSk7XG4gICAgbGV0IGh0bWwgPSAnPGh0bWw+PGhlYWQ+PHRpdGxlPicgKyBkaXNwbGF5ICsgJzwvdGl0bGU+PC9oZWFkPjxib2R5PjxoMT5EaXJlY3Rvcnk6ICcgKyBkaXNwbGF5ICsgJzwvaDE+PHVsPic7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHJlc291cmNlLnN1YnN0cmluZygwLCByZXNvdXJjZS5sYXN0SW5kZXhPZignLycsIHJlc291cmNlLmxlbmd0aCAtIChoYXNUcmFpbGluZ1NsYXNoID8gMiA6IDEpKSkgKyAnLyc7XG4gICAgICAgIGh0bWwgPSBodG1sICsgJzxsaT48YSBocmVmPVwiJyArIGludGVybmFscy5wYXRoRW5jb2RlKHBhcmVudCkgKyAnXCI+UGFyZW50IERpcmVjdG9yeTwvYT48L2xpPic7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2hvd0hpZGRlbiB8fFxuICAgICAgICAgICAgIWludGVybmFscy5pc0ZpbGVIaWRkZW4oZmlsZXNbaV0pKSB7XG5cbiAgICAgICAgICAgIGh0bWwgPSBodG1sICsgJzxsaT48YSBocmVmPVwiJyArIGludGVybmFscy5wYXRoRW5jb2RlKHJlc291cmNlICsgKCFoYXNUcmFpbGluZ1NsYXNoID8gJy8nIDogJycpICsgZmlsZXNbaV0pICsgJ1wiPicgKyBIb2VrLmVzY2FwZUh0bWwoZmlsZXNbaV0pICsgJzwvYT48L2xpPic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBodG1sID0gaHRtbCArICc8L3VsPjwvYm9keT48L2h0bWw+JztcblxuICAgIHJldHVybiByZXF1ZXN0LmdlbmVyYXRlUmVzcG9uc2UoaHRtbCk7XG59O1xuXG5cbmludGVybmFscy5pc0ZpbGVIaWRkZW4gPSBmdW5jdGlvbiAocGF0aCkge1xuXG4gICAgcmV0dXJuIC8oXnxbXFxcXFxcL10pXFwuKFteLlxcXFxcXC9dfFxcLlteXFxcXFxcL10pLy50ZXN0KHBhdGgpOyAgICAgICAgICAgLy8gU3RhcnRzIHdpdGggYSAnLicgb3IgY29udGFpbnMgJy8uJyBvciAnXFwuJywgd2hpY2ggaXMgbm90IGZvbGxvd2VkIGJ5IGEgJy8nIG9yICdcXCcgb3IgJy4nXG59O1xuXG5cbmludGVybmFscy5wYXRoRW5jb2RlID0gZnVuY3Rpb24gKHBhdGgpIHtcblxuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQocGF0aCkucmVwbGFjZSgvJTJGL2csICcvJykucmVwbGFjZSgvJTVDL2csICdcXFxcJyk7XG59O1xuXG5cbmludGVybmFscy5pc05vdEZvdW5kID0gZnVuY3Rpb24gKGJvb20pIHtcblxuICAgIHJldHVybiBib29tLm91dHB1dC5zdGF0dXNDb2RlID09PSA0MDQ7XG59O1xuXG5cbmludGVybmFscy5pc0RpcmVjdG9yeSA9IGZ1bmN0aW9uIChib29tKSB7XG5cbiAgICByZXR1cm4gYm9vbS5vdXRwdXQuc3RhdHVzQ29kZSA9PT0gNDAzICYmIGJvb20uZGF0YS5jb2RlID09PSAnRUlTRElSJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBMcnVDYWNoZSA9IHJlcXVpcmUoJ2xydS1jYWNoZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBwZW5kaW5nczogT2JqZWN0LmNyZWF0ZShudWxsKVxufTtcblxuXG5pbnRlcm5hbHMuc3RyZWFtRW5kID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsIHJlc29sdmUpO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICB9KTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbXB1dGVIYXNoZWQgPSBhc3luYyBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXQpIHtcblxuICAgIGNvbnN0IGV0YWdzID0gcmVzcG9uc2UucmVxdWVzdC5zZXJ2ZXIucGx1Z2lucy5pbmVydC5fZXRhZ3M7XG4gICAgaWYgKCFldGFncykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBVc2Ugc3RhdCBpbmZvIGZvciBhbiBMUlUgY2FjaGUga2V5LlxuXG4gICAgY29uc3QgcGF0aCA9IHJlc3BvbnNlLnNvdXJjZS5wYXRoO1xuICAgIGNvbnN0IGNhY2hla2V5ID0gW3BhdGgsIHN0YXQuaW5vLCBzdGF0LnNpemUsIHN0YXQubXRpbWUuZ2V0VGltZSgpXS5qb2luKCctJyk7XG5cbiAgICAvLyBUaGUgZXRhZyBoYXNoZXMgdGhlIGZpbGUgY29udGVudHMgaW4gb3JkZXIgdG8gYmUgY29uc2lzdGVudCBhY3Jvc3MgZGlzdHJpYnV0ZWQgZGVwbG95bWVudHNcblxuICAgIGNvbnN0IGNhY2hlZEV0YWcgPSBldGFncy5nZXQoY2FjaGVrZXkpO1xuICAgIGlmIChjYWNoZWRFdGFnKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRFdGFnO1xuICAgIH1cblxuICAgIGxldCBwcm9taXNlID0gaW50ZXJuYWxzLnBlbmRpbmdzW2NhY2hla2V5XTtcbiAgICBpZiAocHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbiAgICB9XG5cbiAgICAvLyBTdGFydCBoYXNoaW5nXG5cbiAgICBjb25zdCBjb21wdXRlID0gYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgaW50ZXJuYWxzLmhhc2hGaWxlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGV0YWdzLnNldChjYWNoZWtleSwgaGFzaCk7XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIGludGVybmFscy5wZW5kaW5nc1tjYWNoZWtleV07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaW50ZXJuYWxzLnBlbmRpbmdzW2NhY2hla2V5XSA9IHByb21pc2UgPSBjb21wdXRlKCk7XG5cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzZTtcbn07XG5cblxuaW50ZXJuYWxzLmhhc2hGaWxlID0gYXN5bmMgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBjb25zdCBoYXNoID0gQ3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICBoYXNoLnNldEVuY29kaW5nKCdoZXgnKTtcblxuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSByZXNwb25zZS5zb3VyY2UuZmlsZS5jcmVhdGVSZWFkU3RyZWFtKHsgYXV0b0Nsb3NlOiBmYWxzZSB9KTtcbiAgICBmaWxlU3RyZWFtLnBpcGUoaGFzaCk7XG5cbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBpbnRlcm5hbHMuc3RyZWFtRW5kKGZpbGVTdHJlYW0pO1xuICAgICAgICByZXR1cm4gaGFzaC5yZWFkKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgIHRocm93IEJvb20uYm9vbWlmeShlcnIsIHsgbWVzc2FnZTogJ0ZhaWxlZCB0byBoYXNoIGZpbGUnLCBkYXRhOiB7IHBhdGg6IHJlc3BvbnNlLnNvdXJjZS5wYXRoIH0gfSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuY29tcHV0ZVNpbXBsZSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdCkge1xuXG4gICAgY29uc3Qgc2l6ZSA9IHN0YXQuc2l6ZS50b1N0cmluZygxNik7XG4gICAgY29uc3QgbXRpbWUgPSBzdGF0Lm10aW1lLmdldFRpbWUoKS50b1N0cmluZygxNik7XG5cbiAgICByZXR1cm4gc2l6ZSArICctJyArIG10aW1lO1xufTtcblxuXG5leHBvcnRzLmFwcGx5ID0gYXN5bmMgZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0KSB7XG5cbiAgICBjb25zdCBldGFnTWV0aG9kID0gcmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLmV0YWdNZXRob2Q7XG4gICAgaWYgKGV0YWdNZXRob2QgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZXRhZztcbiAgICBpZiAoZXRhZ01ldGhvZCA9PT0gJ3NpbXBsZScpIHtcbiAgICAgICAgZXRhZyA9IGludGVybmFscy5jb21wdXRlU2ltcGxlKHJlc3BvbnNlLCBzdGF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV0YWcgPSBhd2FpdCBpbnRlcm5hbHMuY29tcHV0ZUhhc2hlZChyZXNwb25zZSwgc3RhdCk7XG4gICAgfVxuXG4gICAgaWYgKGV0YWcgIT09IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2UuZXRhZyhldGFnLCB7IHZhcnk6IHRydWUgfSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLkNhY2hlID0gTHJ1Q2FjaGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IEFtbW8gPSByZXF1aXJlKCdAaGFwaS9hbW1vJyk7XG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5cbmNvbnN0IEV0YWcgPSByZXF1aXJlKCcuL2V0YWcnKTtcbmNvbnN0IEZzID0gcmVxdWlyZSgnLi9mcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5kZWZhdWx0TWFwID0ge1xuICAgIGd6aXA6ICcuZ3onXG59O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICBKb2kuc3RyaW5nKCksXG4gICAgSm9pLmZ1bmMoKSxcbiAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgcGF0aDogSm9pLmFsdGVybmF0aXZlcyhKb2kuc3RyaW5nKCksIEpvaS5mdW5jKCkpLnJlcXVpcmVkKCksXG4gICAgICAgIGNvbmZpbmU6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLnN0cmluZygpLCBKb2kuYm9vbGVhbigpKS5kZWZhdWx0KHRydWUpLFxuICAgICAgICBmaWxlbmFtZTogSm9pLnN0cmluZygpLFxuICAgICAgICBtb2RlOiBKb2kuc3RyaW5nKCkudmFsaWQoJ2F0dGFjaG1lbnQnLCAnaW5saW5lJykuYWxsb3coZmFsc2UpLFxuICAgICAgICBsb29rdXBDb21wcmVzc2VkOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBsb29rdXBNYXA6IEpvaS5vYmplY3QoKS5taW4oMSkucGF0dGVybigvLisvLCBKb2kuc3RyaW5nKCkpLFxuICAgICAgICBldGFnTWV0aG9kOiBKb2kuc3RyaW5nKCkudmFsaWQoJ2hhc2gnLCAnc2ltcGxlJykuYWxsb3coZmFsc2UpLFxuICAgICAgICBzdGFydDogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMCkuZGVmYXVsdCgwKSxcbiAgICAgICAgZW5kOiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLm1pbihKb2kucmVmKCdzdGFydCcpKVxuICAgIH0pXG4gICAgICAgIC53aXRoKCdmaWxlbmFtZScsICdtb2RlJylcbl0pO1xuXG5cbmV4cG9ydHMuaGFuZGxlciA9IGZ1bmN0aW9uIChyb3V0ZSwgb3B0aW9ucykge1xuXG4gICAgbGV0IHNldHRpbmdzID0gSm9pLmF0dGVtcHQob3B0aW9ucywgaW50ZXJuYWxzLnNjaGVtYSwgJ0ludmFsaWQgZmlsZSBoYW5kbGVyIG9wdGlvbnMgKCcgKyByb3V0ZS5wYXRoICsgJyknKTtcbiAgICBzZXR0aW5ncyA9ICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgPyB7IHBhdGg6IG9wdGlvbnMsIGNvbmZpbmU6ICcuJyB9IDogc2V0dGluZ3MpO1xuICAgIHNldHRpbmdzLmNvbmZpbmUgPSBzZXR0aW5ncy5jb25maW5lID09PSB0cnVlID8gJy4nIDogc2V0dGluZ3MuY29uZmluZTtcbiAgICBIb2VrLmFzc2VydCh0eXBlb2Ygc2V0dGluZ3MucGF0aCAhPT0gJ3N0cmluZycgfHwgc2V0dGluZ3MucGF0aFtzZXR0aW5ncy5wYXRoLmxlbmd0aCAtIDFdICE9PSAnLycsICdGaWxlIHBhdGggY2Fubm90IGVuZCB3aXRoIGEgXFwnL1xcJzonLCByb3V0ZS5wYXRoKTtcblxuICAgIGNvbnN0IGhhbmRsZXIgPSAocmVxdWVzdCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSAodHlwZW9mIHNldHRpbmdzLnBhdGggPT09ICdmdW5jdGlvbicgPyBzZXR0aW5ncy5wYXRoKHJlcXVlc3QpIDogc2V0dGluZ3MucGF0aCk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJlc3BvbnNlKHBhdGgsIHNldHRpbmdzLCByZXF1ZXN0KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG5cbmV4cG9ydHMubG9hZCA9IGZ1bmN0aW9uIChwYXRoLCByZXF1ZXN0LCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGV4cG9ydHMucmVzcG9uc2UocGF0aCwgb3B0aW9ucywgcmVxdWVzdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIGludGVybmFscy5wcmVwYXJlKHJlc3BvbnNlKTtcbn07XG5cblxuZXhwb3J0cy5yZXNwb25zZSA9IGZ1bmN0aW9uIChwYXRoLCBvcHRpb25zLCByZXF1ZXN0LCBfcHJlbG9hZGVkKSB7XG5cbiAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5tb2RlIHx8IFsnYXR0YWNobWVudCcsICdpbmxpbmUnXS5pbmRleE9mKG9wdGlvbnMubW9kZSkgIT09IC0xLCAnb3B0aW9ucy5tb2RlIG11c3QgYmUgZWl0aGVyIGZhbHNlLCBhdHRhY2htZW50LCBvciBpbmxpbmUnKTtcblxuICAgIGlmIChvcHRpb25zLmNvbmZpbmUpIHtcbiAgICAgICAgY29uc3QgY29uZmluZURpciA9IFBhdGgucmVzb2x2ZShyZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmZpbGVzLnJlbGF0aXZlVG8sIG9wdGlvbnMuY29uZmluZSk7XG4gICAgICAgIHBhdGggPSBQYXRoLmlzQWJzb2x1dGUocGF0aCkgPyBQYXRoLm5vcm1hbGl6ZShwYXRoKSA6IFBhdGguam9pbihjb25maW5lRGlyLCBwYXRoKTtcblxuICAgICAgICAvLyBWZXJpZnkgdGhhdCByZXNvbHZlZCBwYXRoIGlzIHdpdGhpbiBjb25maW5lRGlyXG4gICAgICAgIGlmIChwYXRoLmxhc3RJbmRleE9mKGNvbmZpbmVEaXIsIDApICE9PSAwKSB7XG4gICAgICAgICAgICBwYXRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGF0aCA9IFBhdGguaXNBYnNvbHV0ZShwYXRoKSA/IFBhdGgubm9ybWFsaXplKHBhdGgpIDogUGF0aC5qb2luKHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuZmlsZXMucmVsYXRpdmVUbywgcGF0aCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzZXR0aW5nczogb3B0aW9ucyxcbiAgICAgICAgc3RhdDogbnVsbCxcbiAgICAgICAgZmlsZTogbnVsbFxuICAgIH07XG5cbiAgICBjb25zdCBwcmVwYXJlID0gX3ByZWxvYWRlZCA/IG51bGwgOiBpbnRlcm5hbHMucHJlcGFyZTtcblxuICAgIHJldHVybiByZXF1ZXN0LmdlbmVyYXRlUmVzcG9uc2Uoc291cmNlLCB7IHZhcmlldHk6ICdmaWxlJywgbWFyc2hhbDogaW50ZXJuYWxzLm1hcnNoYWwsIHByZXBhcmUsIGNsb3NlOiBpbnRlcm5hbHMuY2xvc2UgfSk7XG59O1xuXG5cbmludGVybmFscy5wcmVwYXJlID0gYXN5bmMgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBjb25zdCBwYXRoID0gcmVzcG9uc2Uuc291cmNlLnBhdGg7XG5cbiAgICBpZiAocGF0aCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBCb29tLmZvcmJpZGRlbihudWxsLCB7IGNvZGU6ICdFQUNDRVMnIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbGUgPSByZXNwb25zZS5zb3VyY2UuZmlsZSA9IG5ldyBGcy5GaWxlKHBhdGgpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZpbGUub3BlblN0YXQoJ3InKTtcblxuICAgICAgICBjb25zdCBzdGFydCA9IHJlc3BvbnNlLnNvdXJjZS5zZXR0aW5ncy5zdGFydCB8fCAwO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNwb25zZS5ieXRlcyhyZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3MuZW5kIC0gc3RhcnQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmJ5dGVzKHN0YXQuc2l6ZSAtIHN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC10eXBlJ10pIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLnR5cGUocmVzcG9uc2UucmVxdWVzdC5zZXJ2ZXIubWltZS5wYXRoKHBhdGgpLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyKCdsYXN0LW1vZGlmaWVkJywgc3RhdC5tdGltZS50b1VUQ1N0cmluZygpKTtcblxuICAgICAgICBpZiAocmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLm1vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLmZpbGVuYW1lIHx8IFBhdGguYmFzZW5hbWUocGF0aCk7XG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXIoJ2NvbnRlbnQtZGlzcG9zaXRpb24nLCByZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3MubW9kZSArICc7IGZpbGVuYW1lPScgKyBlbmNvZGVVUklDb21wb25lbnQoZmlsZU5hbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IEV0YWcuYXBwbHkocmVzcG9uc2UsIHN0YXQpO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpbnRlcm5hbHMuY2xvc2UocmVzcG9uc2UpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMubWFyc2hhbCA9IGFzeW5jIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgaWYgKHJlc3BvbnNlLnNvdXJjZS5zZXR0aW5ncy5sb29rdXBDb21wcmVzc2VkICYmXG4gICAgICAgICFyZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3Muc3RhcnQgJiZcbiAgICAgICAgcmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHJlc3BvbnNlLnJlcXVlc3Quc2VydmVyLnNldHRpbmdzLmNvbXByZXNzaW9uICE9PSBmYWxzZSkge1xuXG4gICAgICAgIGNvbnN0IGxvb2t1cE1hcCA9IHJlc3BvbnNlLnNvdXJjZS5zZXR0aW5ncy5sb29rdXBNYXAgfHwgaW50ZXJuYWxzLmRlZmF1bHRNYXA7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gcmVzcG9uc2UucmVxdWVzdC5pbmZvLmFjY2VwdEVuY29kaW5nO1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBsb29rdXBNYXAuaGFzT3duUHJvcGVydHkoZW5jb2RpbmcpID8gbG9va3VwTWFwW2VuY29kaW5nXSA6IG51bGw7XG4gICAgICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWNvbXByZXNzZWQgPSBuZXcgRnMuRmlsZShgJHtyZXNwb25zZS5zb3VyY2UucGF0aH0ke2V4dGVuc2lvbn1gKTtcbiAgICAgICAgICAgIGxldCBzdGF0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGF0ID0gYXdhaXQgcHJlY29tcHJlc3NlZC5vcGVuU3RhdCgncicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHByZWNvbXByZXNzZWQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBCb3VuY2UuaWdub3JlKGVyciwgJ2Jvb20nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zb3VyY2UuZmlsZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNvdXJjZS5maWxlID0gcHJlY29tcHJlc3NlZDtcblxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJ5dGVzKHN0YXQuc2l6ZSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVyKCdjb250ZW50LWVuY29kaW5nJywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnZhcnkoJ2FjY2VwdC1lbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5jcmVhdGVTdHJlYW0ocmVzcG9uc2UpO1xufTtcblxuXG5pbnRlcm5hbHMuYWRkQ29udGVudFJhbmdlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gcmVzcG9uc2UucmVxdWVzdDtcbiAgICBjb25zdCBsZW5ndGggPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgIGxldCByYW5nZSA9IG51bGw7XG5cbiAgICBpZiAocmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5yZXNwb25zZS5yYW5nZXMpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuaGVhZGVycy5yYW5nZSAmJiBsZW5ndGgpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgSWYtUmFuZ2VcblxuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNbJ2lmLXJhbmdlJ10gfHxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ2lmLXJhbmdlJ10gPT09IHJlc3BvbnNlLmhlYWRlcnMuZXRhZykgeyAgICAgICAgICAgIC8vIElnbm9yaW5nIGxhc3QtbW9kaWZpZWQgZGF0ZSAod2VhaylcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgcmVzcG9uc2UgaXMgbm90IGVuY29kZWQgb25jZSB0cmFuc21pdHRlZFxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWltZSA9IHJlcXVlc3Quc2VydmVyLm1pbWUudHlwZShyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSAocmVxdWVzdC5zZXJ2ZXIuc2V0dGluZ3MuY29tcHJlc3Npb24gJiYgbWltZS5jb21wcmVzc2libGUgJiYgIXJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSA/IHJlcXVlc3QuaW5mby5hY2NlcHRFbmNvZGluZyA6IG51bGwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaWRlbnRpdHknIHx8ICFlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGhlYWRlclxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlcyA9IEFtbW8uaGVhZGVyKHJlcXVlc3QuaGVhZGVycy5yYW5nZSwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gQm9vbS5yYW5nZU5vdFNhdGlzZmlhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5vdXRwdXQuaGVhZGVyc1snY29udGVudC1yYW5nZSddID0gJ2J5dGVzICovJyArIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlcGFyZSB0cmFuc2Zvcm1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSByZXF1ZXN0cyBmb3IgbXVsdGlwbGUgcmFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmNvZGUoMjA2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJ5dGVzKHJhbmdlLnRvIC0gcmFuZ2UuZnJvbSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVyKCdjb250ZW50LXJhbmdlJywgJ2J5dGVzICcgKyByYW5nZS5mcm9tICsgJy0nICsgcmFuZ2UudG8gKyAnLycgKyBsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyKCdhY2NlcHQtcmFuZ2VzJywgJ2J5dGVzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xufTtcblxuXG5pbnRlcm5hbHMuY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBjb25zdCBzb3VyY2UgPSByZXNwb25zZS5zb3VyY2U7XG5cbiAgICBIb2VrLmFzc2VydChzb3VyY2UuZmlsZSAhPT0gbnVsbCk7XG5cbiAgICBjb25zdCByYW5nZSA9IGludGVybmFscy5hZGRDb250ZW50UmFuZ2UocmVzcG9uc2UpO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhcnQ6IHNvdXJjZS5zZXR0aW5ncy5zdGFydCB8fCAwLFxuICAgICAgICBlbmQ6IHNvdXJjZS5zZXR0aW5ncy5lbmRcbiAgICB9O1xuXG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kID0gcmFuZ2UudG8gKyBvcHRpb25zLnN0YXJ0O1xuICAgICAgICBvcHRpb25zLnN0YXJ0ID0gcmFuZ2UuZnJvbSArIG9wdGlvbnMuc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZS5maWxlLmNyZWF0ZVJlYWRTdHJlYW0ob3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5jbG9zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgaWYgKHJlc3BvbnNlLnNvdXJjZS5maWxlICE9PSBudWxsKSB7XG4gICAgICAgIHJlc3BvbnNlLnNvdXJjZS5maWxlLmNsb3NlKCk7XG4gICAgICAgIHJlc3BvbnNlLnNvdXJjZS5maWxlID0gbnVsbDtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBGcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHByb21pc2VkOiBbJ29wZW4nLCAnY2xvc2UnLCAnZnN0YXQnLCAncmVhZGRpciddLFxuICAgICAgICByYXc6IFsnY3JlYXRlUmVhZFN0cmVhbSddXG4gICAgfVxufTtcblxuXG5leHBvcnRzLkZpbGUgPSBmdW5jdGlvbiAocGF0aCkge1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbn07XG5cblxuZXhwb3J0cy5GaWxlLnByb3RvdHlwZS5vcGVuID0gYXN5bmMgZnVuY3Rpb24gKG1vZGUpIHtcblxuICAgIEhvZWsuYXNzZXJ0KHRoaXMuZmQgPT09IG51bGwpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5mZCA9IGF3YWl0IGV4cG9ydHMub3Blbih0aGlzLnBhdGgsIG1vZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IHBhdGg6IHRoaXMucGF0aCB9O1xuXG4gICAgICAgIGlmICh0aGlzLnBhdGguaW5kZXhPZignXFx1MDAwMCcpICE9PSAtMSB8fCBlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20ubm90Rm91bmQobnVsbCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFQUNDRVMnIHx8IGVyci5jb2RlID09PSAnRVBFUk0nKSB7XG4gICAgICAgICAgICBkYXRhLmNvZGUgPSBlcnIuY29kZTtcbiAgICAgICAgICAgIHRocm93IEJvb20uZm9yYmlkZGVuKG51bGwsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVyciwgeyBtZXNzYWdlOiAnRmFpbGVkIHRvIG9wZW4gZmlsZScsIGRhdGEgfSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLkZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuZmQgIT09IG51bGwpIHtcbiAgICAgICAgQm91bmNlLmJhY2tncm91bmQoZXhwb3J0cy5jbG9zZSh0aGlzLmZkKSk7XG4gICAgICAgIHRoaXMuZmQgPSBudWxsO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5GaWxlLnByb3RvdHlwZS5zdGF0ID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuXG4gICAgSG9lay5hc3NlcnQodGhpcy5mZCAhPT0gbnVsbCk7XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgZXhwb3J0cy5mc3RhdCh0aGlzLmZkKTtcblxuICAgICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmZvcmJpZGRlbihudWxsLCB7IGNvZGU6ICdFSVNESVInLCBwYXRoOiB0aGlzLnBhdGggfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmNsb3NlKHRoaXMuZmQpO1xuXG4gICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgWydib29tJywgJ3N5c3RlbSddKTtcbiAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVyciwgeyBtZXNzYWdlOiAnRmFpbGVkIHRvIHN0YXQgZmlsZScsIGRhdGE6IHsgcGF0aDogdGhpcy5wYXRoIH0gfSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLkZpbGUucHJvdG90eXBlLm9wZW5TdGF0ID0gYXN5bmMgZnVuY3Rpb24gKG1vZGUpIHtcblxuICAgIGF3YWl0IHRoaXMub3Blbihtb2RlKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0KCk7XG59O1xuXG5cbmV4cG9ydHMuRmlsZS5wcm90b3R5cGUuY3JlYXRlUmVhZFN0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLmZkICE9PSBudWxsKTtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZmQ6IHRoaXMuZmQsIHN0YXJ0OiAwIH0sIG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3RyZWFtID0gZXhwb3J0cy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMucGF0aCwgb3B0aW9ucyk7XG5cbiAgICBpZiAob3B0aW9ucy5hdXRvQ2xvc2UgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZmQgPSBudWxsOyAgICAgICAgICAgLy8gVGhlIHN0cmVhbSBub3cgb3ducyB0aGUgZmRcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyZWFtO1xufTtcblxuXG4vLyBFeHBvcnQgRnMgbWV0aG9kc1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IGludGVybmFscy5tZXRob2RzLnJhdy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IG1ldGhvZCA9IGludGVybmFscy5tZXRob2RzLnJhd1tpXTtcbiAgICBleHBvcnRzW21ldGhvZF0gPSBGc1ttZXRob2RdLmJpbmQoRnMpO1xufVxuXG5mb3IgKGxldCBpID0gMDsgaSA8IGludGVybmFscy5tZXRob2RzLnByb21pc2VkLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgbWV0aG9kID0gaW50ZXJuYWxzLm1ldGhvZHMucHJvbWlzZWRbaV07XG4gICAgZXhwb3J0c1ttZXRob2RdID0gVXRpbC5wcm9taXNpZnkoRnNbbWV0aG9kXSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuY29uc3QgRGlyZWN0b3J5ID0gcmVxdWlyZSgnLi9kaXJlY3RvcnknKTtcbmNvbnN0IEV0YWcgPSByZXF1aXJlKCcuL2V0YWcnKTtcbmNvbnN0IEZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc2NoZW1hOiBKb2kub2JqZWN0KHtcbiAgICAgICAgZXRhZ3NDYWNoZU1heFNpemU6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDApLmRlZmF1bHQoMTAwMClcbiAgICB9KS5yZXF1aXJlZCgpXG59O1xuXG5cbmludGVybmFscy5maWxlTWV0aG9kID0gZnVuY3Rpb24gKHBhdGgsIHJlc3BvbnNlT3B0aW9ucykge1xuXG4gICAgLy8gU2V0IGNvcnJlY3QgY29uZmluZSB2YWx1ZVxuXG4gICAgcmVzcG9uc2VPcHRpb25zID0gcmVzcG9uc2VPcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZU9wdGlvbnMuY29uZmluZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcmVzcG9uc2VPcHRpb25zLmNvbmZpbmUgPT09IHRydWUpIHtcbiAgICAgICAgcmVzcG9uc2VPcHRpb25zLmNvbmZpbmUgPSAnLic7XG4gICAgfVxuXG4gICAgSG9lay5hc3NlcnQocmVzcG9uc2VPcHRpb25zLmVuZCA9PT0gdW5kZWZpbmVkIHx8ICtyZXNwb25zZU9wdGlvbnMuc3RhcnQgPD0gK3Jlc3BvbnNlT3B0aW9ucy5lbmQsICdvcHRpb25zLnN0YXJ0IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIG9wdGlvbnMuZW5kJyk7XG5cbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZShGaWxlLnJlc3BvbnNlKHBhdGgsIHJlc3BvbnNlT3B0aW9ucywgdGhpcy5yZXF1ZXN0KSk7XG59O1xuXG5cbmV4cG9ydHMucGx1Z2luID0ge1xuICAgIG5hbWU6ICdpbmVydCcsXG4gICAgcGtnOiByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKSxcbiAgICBvbmNlOiB0cnVlLFxuICAgIHJlcXVpcmVtZW50czoge1xuICAgICAgICBoYXBpOiAnPj0xNy43LjAnXG4gICAgfSxcblxuICAgIHJlZ2lzdGVyKHNlcnZlciwgb3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCwgJ0luZXJ0IGRvZXMgbm90IHN1cHBvcnQgcmVnaXN0cmF0aW9uIG9wdGlvbnMnKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBKb2kuYXR0ZW1wdChIb2VrLnJlYWNoKHNlcnZlci5zZXR0aW5ncy5wbHVnaW5zLCAnaW5lcnQnKSB8fCB7fSwgaW50ZXJuYWxzLnNjaGVtYSwgJ0ludmFsaWQgXCJpbmVydFwiIHNlcnZlciBvcHRpb25zJyk7XG5cbiAgICAgICAgc2VydmVyLmV4cG9zZSgnX2V0YWdzJywgc2V0dGluZ3MuZXRhZ3NDYWNoZU1heFNpemUgPiAwID8gbmV3IEV0YWcuQ2FjaGUoc2V0dGluZ3MuZXRhZ3NDYWNoZU1heFNpemUpIDogbnVsbCk7XG5cbiAgICAgICAgc2VydmVyLmRlY29yYXRlKCdoYW5kbGVyJywgJ2ZpbGUnLCBGaWxlLmhhbmRsZXIpO1xuICAgICAgICBzZXJ2ZXIuZGVjb3JhdGUoJ2hhbmRsZXInLCAnZGlyZWN0b3J5JywgRGlyZWN0b3J5LmhhbmRsZXIpO1xuICAgICAgICBzZXJ2ZXIuZGVjb3JhdGUoJ3Rvb2xraXQnLCAnZmlsZScsIGludGVybmFscy5maWxlTWV0aG9kKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgQjY0ID0gcmVxdWlyZSgnQGhhcGkvYjY0Jyk7XG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91cm5lID0gcmVxdWlyZSgnQGhhcGkvYm91cm5lJyk7XG5jb25zdCBDcnlwdGlsZXMgPSByZXF1aXJlKCdAaGFwaS9jcnlwdGlsZXMnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5kZWZhdWx0cyA9IHtcbiAgICBlbmNyeXB0aW9uOiB7XG4gICAgICAgIHNhbHRCaXRzOiAyNTYsXG4gICAgICAgIGFsZ29yaXRobTogJ2Flcy0yNTYtY2JjJyxcbiAgICAgICAgaXRlcmF0aW9uczogMSxcbiAgICAgICAgbWluUGFzc3dvcmRsZW5ndGg6IDMyXG4gICAgfSxcblxuICAgIGludGVncml0eToge1xuICAgICAgICBzYWx0Qml0czogMjU2LFxuICAgICAgICBhbGdvcml0aG06ICdzaGEyNTYnLFxuICAgICAgICBpdGVyYXRpb25zOiAxLFxuICAgICAgICBtaW5QYXNzd29yZGxlbmd0aDogMzJcbiAgICB9LFxuXG4gICAgdHRsOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcywgMCBtZWFucyBmb3JldmVyXG4gICAgdGltZXN0YW1wU2tld1NlYzogNjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlY29uZHMgb2YgcGVybWl0dGVkIGNsb2NrIHNrZXcgZm9yIGluY29taW5nIGV4cGlyYXRpb25zXG4gICAgbG9jYWx0aW1lT2Zmc2V0TXNlYzogMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2FsIGNsb2NrIHRpbWUgb2Zmc2V0IGV4cHJlc3MgaW4gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIChwb3NpdGl2ZSBvciBuZWdhdGl2ZSlcbn07XG5cblxuLy8gQWxnb3JpdGhtIGNvbmZpZ3VyYXRpb25cblxuZXhwb3J0cy5hbGdvcml0aG1zID0ge1xuICAgICdhZXMtMTI4LWN0cic6IHsga2V5Qml0czogMTI4LCBpdkJpdHM6IDEyOCB9LFxuICAgICdhZXMtMjU2LWNiYyc6IHsga2V5Qml0czogMjU2LCBpdkJpdHM6IDEyOCB9LFxuICAgICdzaGEyNTYnOiB7IGtleUJpdHM6IDI1NiB9XG59O1xuXG5cbi8vIE1BQyBub3JtYWxpemF0aW9uIGZvcm1hdCB2ZXJzaW9uXG5cbmV4cG9ydHMubWFjRm9ybWF0VmVyc2lvbiA9ICcyJzsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBjb21wYXJpc29uIG9mIG1hYyB2YWx1ZXMgZ2VuZXJhdGVkIHdpdGggZGlmZmVyZW50IG5vcm1hbGl6ZWQgc3RyaW5nIGZvcm1hdHNcblxuZXhwb3J0cy5tYWNQcmVmaXggPSAnRmUyNi4nICsgZXhwb3J0cy5tYWNGb3JtYXRWZXJzaW9uO1xuXG5cbi8vIEdlbmVyYXRlIGEgdW5pcXVlIGVuY3J5cHRpb24ga2V5XG5cbi8qXG4gICAgY29uc3Qgb3B0aW9ucyA9ICB7XG4gICAgICAgIHNhbHRCaXRzOiAyNTYsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZWQgaWYgc2FsdCBpcyBzZXRcbiAgICAgICAgc2FsdDogJzRkOG5yOXEzODRucjlxMzg0bnI5M3E4bnJ1cTkzNDhydW4nLFxuICAgICAgICBhbGdvcml0aG06ICdhZXMtMTI4LWN0cicsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwLFxuICAgICAgICBpdjogJ3NkZnNkZnNkZnNkZnNjZHJnZXJjZ2VzcmNnc2VyY2cnLCAgICAgICAgICAvLyBPcHRpb25hbFxuICAgICAgICBtaW5QYXNzd29yZGxlbmd0aDogMzJcbiAgICB9O1xuKi9cblxuZXhwb3J0cy5nZW5lcmF0ZUtleSA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFwYXNzd29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgQm9vbSgnRW1wdHkgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMgfHxcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0JhZCBvcHRpb25zJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYWxnb3JpdGhtID0gZXhwb3J0cy5hbGdvcml0aG1zW29wdGlvbnMuYWxnb3JpdGhtXTtcbiAgICBpZiAoIWFsZ29yaXRobSkge1xuICAgICAgICB0aHJvdyBuZXcgQm9vbSgnVW5rbm93biBhbGdvcml0aG06ICcgKyBvcHRpb25zLmFsZ29yaXRobSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkge1xuICAgICAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgYWxnb3JpdGhtLmtleUJpdHMgLyA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnS2V5IGJ1ZmZlciAocGFzc3dvcmQpIHRvbyBzbWFsbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmtleSA9IHBhc3N3b3JkO1xuICAgICAgICByZXN1bHQuc2FsdCA9ICcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHBhc3N3b3JkLmxlbmd0aCA8IG9wdGlvbnMubWluUGFzc3dvcmRsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb29tKCdQYXNzd29yZCBzdHJpbmcgdG9vIHNob3J0IChtaW4gJyArIG9wdGlvbnMubWluUGFzc3dvcmRsZW5ndGggKyAnIGNoYXJhY3RlcnMgcmVxdWlyZWQpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2FsdCA9IG9wdGlvbnMuc2FsdDtcbiAgICAgICAgaWYgKCFzYWx0KSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2FsdEJpdHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnTWlzc2luZyBzYWx0IGFuZCBzYWx0Qml0cyBvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbVNhbHQgPSBDcnlwdGlsZXMucmFuZG9tQml0cyhvcHRpb25zLnNhbHRCaXRzKTtcbiAgICAgICAgICAgIHNhbHQgPSByYW5kb21TYWx0LnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBhd2FpdCBpbnRlcm5hbHMucGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBvcHRpb25zLml0ZXJhdGlvbnMsIGFsZ29yaXRobS5rZXlCaXRzIC8gOCwgJ3NoYTEnKTtcblxuICAgICAgICByZXN1bHQua2V5ID0gZGVyaXZlZEtleTtcbiAgICAgICAgcmVzdWx0LnNhbHQgPSBzYWx0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLml2KSB7XG4gICAgICAgIHJlc3VsdC5pdiA9IG9wdGlvbnMuaXY7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsZ29yaXRobS5pdkJpdHMpIHtcbiAgICAgICAgcmVzdWx0Lml2ID0gQ3J5cHRpbGVzLnJhbmRvbUJpdHMoYWxnb3JpdGhtLml2Qml0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLy8gRW5jcnlwdCBkYXRhXG4vLyBvcHRpb25zOiBzZWUgZXhwb3J0cy5nZW5lcmF0ZUtleSgpXG5cbmV4cG9ydHMuZW5jcnlwdCA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0aW9ucywgZGF0YSkge1xuXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZXhwb3J0cy5nZW5lcmF0ZUtleShwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KG9wdGlvbnMuYWxnb3JpdGhtLCBrZXkua2V5LCBrZXkuaXYpO1xuICAgIGNvbnN0IGVuY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUoZGF0YSwgJ3V0ZjgnKSwgY2lwaGVyLmZpbmFsKCldKTtcblxuICAgIHJldHVybiB7IGVuY3J5cHRlZCwga2V5IH07XG59O1xuXG5cbi8vIERlY3J5cHQgZGF0YVxuLy8gb3B0aW9uczogc2VlIGV4cG9ydHMuZ2VuZXJhdGVLZXkoKVxuXG5leHBvcnRzLmRlY3J5cHQgPSBhc3luYyBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdGlvbnMsIGRhdGEpIHtcblxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGV4cG9ydHMuZ2VuZXJhdGVLZXkocGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlY2lwaGVyID0gQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYob3B0aW9ucy5hbGdvcml0aG0sIGtleS5rZXksIGtleS5pdik7XG4gICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhLCBudWxsLCAndXRmOCcpO1xuICAgIGRlYyA9IGRlYyArIGRlY2lwaGVyLmZpbmFsKCd1dGY4Jyk7XG5cbiAgICByZXR1cm4gZGVjO1xufTtcblxuXG4vLyBITUFDIHVzaW5nIGEgcGFzc3dvcmRcbi8vIG9wdGlvbnM6IHNlZSBleHBvcnRzLmdlbmVyYXRlS2V5KClcblxuZXhwb3J0cy5obWFjV2l0aFBhc3N3b3JkID0gYXN5bmMgZnVuY3Rpb24gKHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSB7XG5cbiAgICBjb25zdCBrZXkgPSBhd2FpdCBleHBvcnRzLmdlbmVyYXRlS2V5KHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgICBjb25zdCBobWFjID0gQ3J5cHRvLmNyZWF0ZUhtYWMob3B0aW9ucy5hbGdvcml0aG0sIGtleS5rZXkpLnVwZGF0ZShkYXRhKTtcbiAgICBjb25zdCBkaWdlc3QgPSBobWFjLmRpZ2VzdCgnYmFzZTY0JykucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvXFw9L2csICcnKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRpZ2VzdCxcbiAgICAgICAgc2FsdDoga2V5LnNhbHRcbiAgICB9O1xufTtcblxuXG4vLyBOb3JtYWxpemVzIGEgcGFzc3dvcmQgcGFyYW1ldGVyIGludG8gYSB7IGlkLCBlbmNyeXB0aW9uLCBpbnRlZ3JpdHkgfSBvYmplY3Rcbi8vIHBhc3N3b3JkOiBzdHJpbmcsIGJ1ZmZlciBvciBvYmplY3Qgd2l0aCB7IGlkLCBzZWNyZXQgfSBvciB7IGlkLCBlbmNyeXB0aW9uLCBpbnRlZ3JpdHkgfVxuXG5pbnRlcm5hbHMubm9ybWFsaXplUGFzc3dvcmQgPSBmdW5jdGlvbiAocGFzc3dvcmQpIHtcblxuICAgIGlmIChwYXNzd29yZCAmJlxuICAgICAgICB0eXBlb2YgcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICFCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSB7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBwYXNzd29yZC5pZCxcbiAgICAgICAgICAgIGVuY3J5cHRpb246IHBhc3N3b3JkLnNlY3JldCB8fCBwYXNzd29yZC5lbmNyeXB0aW9uLFxuICAgICAgICAgICAgaW50ZWdyaXR5OiBwYXNzd29yZC5zZWNyZXQgfHwgcGFzc3dvcmQuaW50ZWdyaXR5XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jcnlwdGlvbjogcGFzc3dvcmQsXG4gICAgICAgIGludGVncml0eTogcGFzc3dvcmRcbiAgICB9O1xufTtcblxuXG4vLyBFbmNyeXB0IGFuZCBITUFDIGFuIG9iamVjdFxuLy8gcGFzc3dvcmQ6IHN0cmluZywgYnVmZmVyIG9yIG9iamVjdCB3aXRoIHsgaWQsIHNlY3JldCB9IG9yIHsgaWQsIGVuY3J5cHRpb24sIGludGVncml0eSB9XG4vLyBvcHRpb25zOiBzZWUgZXhwb3J0cy5kZWZhdWx0c1xuXG5leHBvcnRzLnNlYWwgPSBhc3luYyBmdW5jdGlvbiAob2JqZWN0LCBwYXNzd29yZCwgb3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZCB0byBwcmV2ZW50IGNoYW5nZXMgZHVyaW5nIGFzeW5jIG9wZXJhdGlvbnNcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCkgKyAob3B0aW9ucy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApOyAgICAgICAgICAgICAgICAgLy8gTWVhc3VyZSBub3cgYmVmb3JlIGFueSBvdGhlciBwcm9jZXNzaW5nXG5cbiAgICAvLyBTZXJpYWxpemUgb2JqZWN0XG5cbiAgICBjb25zdCBvYmplY3RTdHJpbmcgPSBpbnRlcm5hbHMuc3RyaW5naWZ5KG9iamVjdCk7XG5cbiAgICAvLyBPYnRhaW4gcGFzc3dvcmRcblxuICAgIGxldCBwYXNzd29yZElkID0gJyc7XG4gICAgcGFzc3dvcmQgPSBpbnRlcm5hbHMubm9ybWFsaXplUGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIGlmIChwYXNzd29yZC5pZCkge1xuICAgICAgICBpZiAoIS9eXFx3KyQvLnRlc3QocGFzc3dvcmQuaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnSW52YWxpZCBwYXNzd29yZCBpZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFzc3dvcmRJZCA9IHBhc3N3b3JkLmlkO1xuICAgIH1cblxuICAgIC8vIEVuY3J5cHQgb2JqZWN0IHN0cmluZ1xuXG4gICAgY29uc3QgeyBlbmNyeXB0ZWQsIGtleSB9ID0gYXdhaXQgZXhwb3J0cy5lbmNyeXB0KHBhc3N3b3JkLmVuY3J5cHRpb24sIG9wdGlvbnMuZW5jcnlwdGlvbiwgb2JqZWN0U3RyaW5nKTtcblxuICAgIC8vIEJhc2U2NHVybCB0aGUgZW5jcnlwdGVkIHZhbHVlXG5cbiAgICBjb25zdCBlbmNyeXB0ZWRCNjQgPSBCNjQuYmFzZTY0dXJsRW5jb2RlKGVuY3J5cHRlZCk7XG4gICAgY29uc3QgaXYgPSBCNjQuYmFzZTY0dXJsRW5jb2RlKGtleS5pdik7XG4gICAgY29uc3QgZXhwaXJhdGlvbiA9IChvcHRpb25zLnR0bCA/IG5vdyArIG9wdGlvbnMudHRsIDogJycpO1xuICAgIGNvbnN0IG1hY0Jhc2VTdHJpbmcgPSBleHBvcnRzLm1hY1ByZWZpeCArICcqJyArIHBhc3N3b3JkSWQgKyAnKicgKyBrZXkuc2FsdCArICcqJyArIGl2ICsgJyonICsgZW5jcnlwdGVkQjY0ICsgJyonICsgZXhwaXJhdGlvbjtcblxuICAgIC8vIE1hYyB0aGUgY29tYmluZWQgdmFsdWVzXG5cbiAgICBjb25zdCBtYWMgPSBhd2FpdCBleHBvcnRzLmhtYWNXaXRoUGFzc3dvcmQocGFzc3dvcmQuaW50ZWdyaXR5LCBvcHRpb25zLmludGVncml0eSwgbWFjQmFzZVN0cmluZyk7XG5cbiAgICAvLyBQdXQgaXQgYWxsIHRvZ2V0aGVyXG5cbiAgICAvLyBwcmVmaXgqW3Bhc3N3b3JkLWlkXSplbmNyeXB0aW9uLXNhbHQqZW5jcnlwdGlvbi1pdiplbmNyeXB0ZWQqW2V4cGlyYXRpb25dKmhtYWMtc2FsdCpobWFjXG4gICAgLy8gQWxsb3dlZCBVUkkgcXVlcnkgbmFtZS92YWx1ZSBjaGFyYWN0ZXJzOiAqLS4gXFxkIFxcd1xuXG4gICAgY29uc3Qgc2VhbGVkID0gbWFjQmFzZVN0cmluZyArICcqJyArIG1hYy5zYWx0ICsgJyonICsgbWFjLmRpZ2VzdDtcbiAgICByZXR1cm4gc2VhbGVkO1xufTtcblxuXG4vLyBEZWNyeXB0IGFuZCB2YWxpZGF0ZSBzZWFsZWQgc3RyaW5nXG4vLyBwYXNzd29yZDogc3RyaW5nLCBidWZmZXIgb3Igb2JqZWN0IHdpdGggeyBpZDogc2VjcmV0IH0gb3IgeyBpZDogeyBlbmNyeXB0aW9uLCBpbnRlZ3JpdHkgfSB9XG4vLyBvcHRpb25zOiBzZWUgZXhwb3J0cy5kZWZhdWx0c1xuXG5leHBvcnRzLnVuc2VhbCA9IGFzeW5jIGZ1bmN0aW9uIChzZWFsZWQsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWQgdG8gcHJldmVudCBjaGFuZ2VzIGR1cmluZyBhc3luYyBvcGVyYXRpb25zXG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpICsgKG9wdGlvbnMubG9jYWx0aW1lT2Zmc2V0TXNlYyB8fCAwKTsgICAgICAgICAgICAgICAgLy8gTWVhc3VyZSBub3cgYmVmb3JlIGFueSBvdGhlciBwcm9jZXNzaW5nXG5cbiAgICAvLyBCcmVhayBzdHJpbmcgaW50byBjb21wb25lbnRzXG5cbiAgICBjb25zdCBwYXJ0cyA9IHNlYWxlZC5zcGxpdCgnKicpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0luY29ycmVjdCBudW1iZXIgb2Ygc2VhbGVkIGNvbXBvbmVudHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYWNQcmVmaXggPSBwYXJ0c1swXTtcbiAgICBjb25zdCBwYXNzd29yZElkID0gcGFydHNbMV07XG4gICAgY29uc3QgZW5jcnlwdGlvblNhbHQgPSBwYXJ0c1syXTtcbiAgICBjb25zdCBlbmNyeXB0aW9uSXYgPSBwYXJ0c1szXTtcbiAgICBjb25zdCBlbmNyeXB0ZWRCNjQgPSBwYXJ0c1s0XTtcbiAgICBjb25zdCBleHBpcmF0aW9uID0gcGFydHNbNV07XG4gICAgY29uc3QgaG1hY1NhbHQgPSBwYXJ0c1s2XTtcbiAgICBjb25zdCBobWFjID0gcGFydHNbN107XG4gICAgY29uc3QgbWFjQmFzZVN0cmluZyA9IG1hY1ByZWZpeCArICcqJyArIHBhc3N3b3JkSWQgKyAnKicgKyBlbmNyeXB0aW9uU2FsdCArICcqJyArIGVuY3J5cHRpb25JdiArICcqJyArIGVuY3J5cHRlZEI2NCArICcqJyArIGV4cGlyYXRpb247XG5cbiAgICAvLyBDaGVjayBwcmVmaXhcblxuICAgIGlmIChtYWNQcmVmaXggIT09IGV4cG9ydHMubWFjUHJlZml4KSB7XG4gICAgICAgIHRocm93IG5ldyBCb29tKCdXcm9uZyBtYWMgcHJlZml4Jyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZXhwaXJhdGlvblxuXG4gICAgaWYgKGV4cGlyYXRpb24pIHtcbiAgICAgICAgaWYgKCFleHBpcmF0aW9uLm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0ludmFsaWQgZXhwaXJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwID0gcGFyc2VJbnQoZXhwaXJhdGlvbiwgMTApO1xuICAgICAgICBpZiAoZXhwIDw9IChub3cgLSAob3B0aW9ucy50aW1lc3RhbXBTa2V3U2VjICogMTAwMCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnRXhwaXJlZCBzZWFsJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPYnRhaW4gcGFzc3dvcmRcblxuICAgIGlmICghcGFzc3dvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0VtcHR5IHBhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHtcblxuICAgICAgICBwYXNzd29yZCA9IHBhc3N3b3JkW3Bhc3N3b3JkSWQgfHwgJ2RlZmF1bHQnXTtcbiAgICAgICAgaWYgKCFwYXNzd29yZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0Nhbm5vdCBmaW5kIHBhc3N3b3JkOiAnICsgcGFzc3dvcmRJZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXNzd29yZCA9IGludGVybmFscy5ub3JtYWxpemVQYXNzd29yZChwYXNzd29yZCk7XG5cbiAgICAvLyBDaGVjayBobWFjXG5cbiAgICBjb25zdCBtYWNPcHRpb25zID0gSG9lay5jbG9uZShvcHRpb25zLmludGVncml0eSk7XG4gICAgbWFjT3B0aW9ucy5zYWx0ID0gaG1hY1NhbHQ7XG4gICAgY29uc3QgbWFjID0gYXdhaXQgZXhwb3J0cy5obWFjV2l0aFBhc3N3b3JkKHBhc3N3b3JkLmludGVncml0eSwgbWFjT3B0aW9ucywgbWFjQmFzZVN0cmluZyk7XG5cbiAgICBpZiAoIUNyeXB0aWxlcy5maXhlZFRpbWVDb21wYXJpc29uKG1hYy5kaWdlc3QsIGhtYWMpKSB7XG4gICAgICAgIHRocm93IG5ldyBCb29tKCdCYWQgaG1hYyB2YWx1ZScpO1xuICAgIH1cblxuICAgIC8vIERlY3J5cHRcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciBlbmNyeXB0ZWQgPSBCNjQuYmFzZTY0dXJsRGVjb2RlKGVuY3J5cHRlZEI2NCwgJ2J1ZmZlcicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IEJvb20uYm9vbWlmeShlcnIpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY3J5cHRPcHRpb25zID0gSG9lay5jbG9uZShvcHRpb25zLmVuY3J5cHRpb24pO1xuICAgIGRlY3J5cHRPcHRpb25zLnNhbHQgPSBlbmNyeXB0aW9uU2FsdDtcblxuICAgIHRyeSB7XG4gICAgICAgIGRlY3J5cHRPcHRpb25zLml2ID0gQjY0LmJhc2U2NHVybERlY29kZShlbmNyeXB0aW9uSXYsICdidWZmZXInKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBCb29tLmJvb21pZnkoZXJyKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNyeXB0ZWQgPSBhd2FpdCBleHBvcnRzLmRlY3J5cHQocGFzc3dvcmQuZW5jcnlwdGlvbiwgZGVjcnlwdE9wdGlvbnMsIGVuY3J5cHRlZCk7XG5cbiAgICAvLyBQYXJzZSBKU09OXG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gQm91cm5lLnBhcnNlKGRlY3J5cHRlZCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0ZhaWxlZCBwYXJzaW5nIHNlYWxlZCBvYmplY3QgSlNPTjogJyArIGVyci5tZXNzYWdlKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgQm9vbSgnRmFpbGVkIHRvIHN0cmluZ2lmeSBvYmplY3Q6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucGJrZGYyID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgY29uc3QgbmV4dCA9IChlcnIsIHJlc3VsdCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChCb29tLmJvb21pZnkoZXJyKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhcmdzLnB1c2gobmV4dCk7XG4gICAgICAgIENyeXB0by5wYmtkZjIoLi4uYXJncyk7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgTWVyZ2UgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9tZXJnZScpO1xuXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbmNvbnN0IE1hbmlmZXN0ID0gcmVxdWlyZSgnLi9tYW5pZmVzdCcpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5jb25zdCBNb2RpZnkgPSByZXF1aXJlKCcuL21vZGlmeScpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRyYWNlID0gcmVxdWlyZSgnLi90cmFjZScpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZSgnLi92YWxpZGF0b3InKTtcbmNvbnN0IFZhbHVlcyA9IHJlcXVpcmUoJy4vdmFsdWVzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLkJhc2UgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG5cbiAgICAgICAgLy8gTmFtaW5nOiBwdWJsaWMsIF9wcml2YXRlLCAkX2V4dGVuc2lvbiwgJF9tdXRhdGV7YWN0aW9ufVxuXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG5cbiAgICAgICAgdGhpcy4kX3Jvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0ge307XG4gICAgICAgIHRoaXMuX2lkcyA9IG5ldyBNb2RpZnkuSWRzKCk7XG4gICAgICAgIHRoaXMuX3ByZWZlcmVuY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVmcyA9IG5ldyBSZWYuTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fdmFsaWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW52YWxpZHMgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2ZsYWdzID0ge307XG4gICAgICAgIHRoaXMuX3J1bGVzID0gW107XG4gICAgICAgIHRoaXMuX3NpbmdsZVJ1bGVzID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgLy8gVGhlIHJ1bGUgb3B0aW9ucyBwYXNzZWQgZm9yIG5vbi1tdWx0aSBydWxlc1xuXG4gICAgICAgIHRoaXMuJF90ZXJtcyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFzaCBvZiBhcnJheXMgb2YgaW1tdXRhYmxlIG9iamVjdHMgKGV4dGVuZGVkIGJ5IG90aGVyIHR5cGVzKVxuXG4gICAgICAgIHRoaXMuJF90ZW1wID0geyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVudGltZSBzdGF0ZSAobm90IGNsb25lZClcbiAgICAgICAgICAgIHJ1bGVzZXQ6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsOiB1c2UgbGFzdCwgZmFsc2U6IGVycm9yLCBudW1iZXI6IHN0YXJ0IHBvc2l0aW9uXG4gICAgICAgICAgICB3aGVuczoge30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVudGltZSBjYWNoZSBvZiBnZW5lcmF0ZWQgd2hlbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNYW5pZmVzdFxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBNYW5pZmVzdC5kZXNjcmliZSA9PT0gJ2Z1bmN0aW9uJywgJ01hbmlmZXN0IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE1hbmlmZXN0LmRlc2NyaWJlKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFJ1bGVzXG5cbiAgICBhbGxvdyguLi52YWx1ZXMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzKHZhbHVlcywgJ192YWxpZHMnKTtcbiAgICB9XG5cbiAgICBhbHRlcih0YXJnZXRzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRhcmdldHMgJiYgdHlwZW9mIHRhcmdldHMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHRhcmdldHMpLCAnSW52YWxpZCB0YXJnZXRzIGFyZ3VtZW50Jyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc2V0IGFsdGVyYXRpb25zIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zID0gb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMgfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IGluIHRhcmdldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkanVzdGVyID0gdGFyZ2V0c1t0YXJnZXRdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBhZGp1c3RlciA9PT0gJ2Z1bmN0aW9uJywgJ0FsdGVyYXRpb24gYWRqdXN0ZXIgZm9yJywgdGFyZ2V0LCAnbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucy5wdXNoKHsgdGFyZ2V0LCBhZGp1c3RlciB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGNhc3QodG8pIHtcblxuICAgICAgICBBc3NlcnQodG8gPT09IGZhbHNlIHx8IHR5cGVvZiB0byA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHRvIHZhbHVlJyk7XG4gICAgICAgIEFzc2VydCh0byA9PT0gZmFsc2UgfHwgdGhpcy5fZGVmaW5pdGlvbi5jYXN0W3RvXSwgJ1R5cGUnLCB0aGlzLnR5cGUsICdkb2VzIG5vdCBzdXBwb3J0IGNhc3RpbmcgdG8nLCB0byk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdjYXN0JywgdG8gPT09IGZhbHNlID8gdW5kZWZpbmVkIDogdG8pO1xuICAgIH1cblxuICAgIGRlZmF1bHQodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZGVmYXVsdCcsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbihkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KGRlc2MgJiYgdHlwZW9mIGRlc2MgPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Rlc2NyaXB0aW9uJywgZGVzYyk7XG4gICAgfVxuXG4gICAgZW1wdHkoc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NoZW1hID0gb2JqLiRfY29tcGlsZShzY2hlbWEsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iai4kX3NldEZsYWcoJ2VtcHR5Jywgc2NoZW1hLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBlcnJvcihlcnIpIHtcblxuICAgICAgICBBc3NlcnQoZXJyLCAnTWlzc2luZyBlcnJvcicpO1xuICAgICAgICBBc3NlcnQoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJywgJ011c3QgcHJvdmlkZSBhIHZhbGlkIEVycm9yIG9iamVjdCBvciBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdlcnJvcicsIGVycik7XG4gICAgfVxuXG4gICAgZXhhbXBsZShleGFtcGxlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQoZXhhbXBsZSAhPT0gdW5kZWZpbmVkLCAnTWlzc2luZyBleGFtcGxlJyk7XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnb3ZlcnJpZGUnXSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleGFtcGxlcycsIGV4YW1wbGUsIHsgc2luZ2xlOiB0cnVlLCBvdmVycmlkZTogb3B0aW9ucy5vdmVycmlkZSB9KTtcbiAgICB9XG5cbiAgICBleHRlcm5hbChtZXRob2QsIGRlc2NyaXB0aW9uKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBBc3NlcnQoIWRlc2NyaXB0aW9uLCAnQ2Fubm90IGNvbWJpbmUgb3B0aW9ucyB3aXRoIGRlc2NyaXB0aW9uJyk7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IG1ldGhvZC5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZC5tZXRob2Q7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJywgJ01ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgQXNzZXJ0KGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRpb24gJiYgdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdleHRlcm5hbHMnLCB7IG1ldGhvZCwgZGVzY3JpcHRpb24gfSwgeyBzaW5nbGU6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgZmFpbG92ZXIodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdCgnZmFpbG92ZXInLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZm9yYmlkZGVuKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdmb3JiaWRkZW4nKTtcbiAgICB9XG5cbiAgICBpZChpZCkge1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaWQnLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBpZCA9PT0gJ3N0cmluZycsICdpZCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICBBc3NlcnQoL15bXlxcLl0rJC8udGVzdChpZCksICdpZCBjYW5ub3QgY29udGFpbiBwZXJpb2QgY2hhcmFjdGVyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpZCcsIGlkKTtcbiAgICB9XG5cbiAgICBpbnZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX2ludmFsaWRzJyk7XG4gICAgfVxuXG4gICAgbGFiZWwobmFtZSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ0xhYmVsIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2xhYmVsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgbWV0YShtZXRhKSB7XG5cbiAgICAgICAgQXNzZXJ0KG1ldGEgIT09IHVuZGVmaW5lZCwgJ01ldGEgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignbWV0YXMnLCBtZXRhLCB7IHNpbmdsZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBub3RlKC4uLm5vdGVzKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5vdGVzLmxlbmd0aCwgJ01pc3Npbmcgbm90ZXMnKTtcbiAgICAgICAgZm9yIChjb25zdCBub3RlIG9mIG5vdGVzKSB7XG4gICAgICAgICAgICBBc3NlcnQobm90ZSAmJiB0eXBlb2Ygbm90ZSA9PT0gJ3N0cmluZycsICdOb3RlcyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ25vdGVzJywgbm90ZXMpO1xuICAgIH1cblxuICAgIG9ubHkobW9kZSA9IHRydWUpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGUgPT09ICdib29sZWFuJywgJ0ludmFsaWQgbW9kZTonLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ29ubHknLCBtb2RlKTtcbiAgICB9XG5cbiAgICBvcHRpb25hbCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgnb3B0aW9uYWwnKTtcbiAgICB9XG5cbiAgICBwcmVmcyhwcmVmcykge1xuXG4gICAgICAgIEFzc2VydChwcmVmcywgJ01pc3NpbmcgcHJlZmVyZW5jZXMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmNvbnRleHQgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBjb250ZXh0Jyk7XG4gICAgICAgIEFzc2VydChwcmVmcy5leHRlcm5hbHMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBleHRlcm5hbHMnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLndhcm5pbmdzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgd2FybmluZ3MnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmRlYnVnID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgZGVidWcnKTtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHByZWZzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwcmVzZW5jZShtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHByZXNlbmNlIG1vZGUnLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3ByZXNlbmNlJywgbW9kZSk7XG4gICAgfVxuXG4gICAgcmF3KGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBlbmFibGVkID8gJ3JhdycgOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJlc3VsdChtb2RlKSB7XG5cbiAgICAgICAgQXNzZXJ0KFsncmF3JywgJ3N0cmlwJ10uaW5jbHVkZXMobW9kZSksICdVbmtub3duIHJlc3VsdCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdyZXN1bHQnLCBtb2RlKTtcbiAgICB9XG5cbiAgICByZXF1aXJlZCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZSgncmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBzdHJpY3QoZW5hYmxlZCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBjb252ZXJ0ID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiAhZW5hYmxlZDtcbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhvYmouX3ByZWZlcmVuY2VzLCB7IGNvbnZlcnQgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc3RyaXAoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIGVuYWJsZWQgPyAnc3RyaXAnIDogdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICB0YWcoLi4udGFncykge1xuXG4gICAgICAgIEFzc2VydCh0YWdzLmxlbmd0aCwgJ01pc3NpbmcgdGFncycpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgICAgICBBc3NlcnQodGFnICYmIHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnLCAnVGFncyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ3RhZ3MnLCB0YWdzKTtcbiAgICB9XG5cbiAgICB1bml0KG5hbWUpIHtcblxuICAgICAgICBBc3NlcnQobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycsICdVbml0IG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3VuaXQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmFsbG93KC4uLnZhbHVlcyk7XG4gICAgICAgIG9iai4kX3NldEZsYWcoJ29ubHknLCAhIW9iai5fdmFsaWRzLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB3aGVuKGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoIW9iai4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtcy53aGVucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2hlbiA9IENvbXBpbGUud2hlbihvYmosIGNvbmRpdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghWydhbnknLCAnbGluayddLmluY2x1ZGVzKG9iai50eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHdoZW4uaXMgPyBbd2hlbl0gOiB3aGVuLnN3aXRjaDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25kaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFpdGVtLnRoZW4gfHwgaXRlbS50aGVuLnR5cGUgPT09ICdhbnknIHx8IGl0ZW0udGhlbi50eXBlID09PSBvYmoudHlwZSwgJ0Nhbm5vdCBjb21iaW5lJywgb2JqLnR5cGUsICd3aXRoJywgaXRlbS50aGVuICYmIGl0ZW0udGhlbi50eXBlKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIWl0ZW0ub3RoZXJ3aXNlIHx8IGl0ZW0ub3RoZXJ3aXNlLnR5cGUgPT09ICdhbnknIHx8IGl0ZW0ub3RoZXJ3aXNlLnR5cGUgPT09IG9iai50eXBlLCAnQ2Fubm90IGNvbWJpbmUnLCBvYmoudHlwZSwgJ3dpdGgnLCBpdGVtLm90aGVyd2lzZSAmJiBpdGVtLm90aGVyd2lzZS50eXBlKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVybXMud2hlbnMucHVzaCh3aGVuKTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXJzXG5cbiAgICBjYWNoZShjYWNoZSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc2V0IGNhY2hpbmcgaW5zaWRlIGEgcnVsZXNldCcpO1xuICAgICAgICBBc3NlcnQoIXRoaXMuX2NhY2hlLCAnQ2Fubm90IG92ZXJyaWRlIHNjaGVtYSBjYWNoZScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9jYWNoZSA9IGNhY2hlIHx8IENhY2hlLnByb3ZpZGVyLnByb3Zpc2lvbigpO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3NpZ24ob2JqKTtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzb3VyY2UpLCAnSW52YWxpZCBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICdhbnknIHx8IHNvdXJjZS50eXBlID09PSAnYW55JyB8fCBzb3VyY2UudHlwZSA9PT0gdGhpcy50eXBlLCAnQ2Fubm90IG1lcmdlIHR5cGUnLCB0aGlzLnR5cGUsICd3aXRoIGFub3RoZXIgdHlwZTonLCBzb3VyY2UudHlwZSk7XG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgY29uY2F0ZW5hdGUgb250byBhIHNjaGVtYSB3aXRoIG9wZW4gcnVsZXNldCcpO1xuICAgICAgICBBc3NlcnQoIXNvdXJjZS5faW5SdWxlc2V0KCksICdDYW5ub3QgY29uY2F0ZW5hdGUgYSBzY2hlbWEgd2l0aCBvcGVuIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdhbnknICYmXG4gICAgICAgICAgICBzb3VyY2UudHlwZSAhPT0gJ2FueScpIHtcblxuICAgICAgICAgICAgLy8gQ2hhbmdlIG9iaiB0byBtYXRjaCBzb3VyY2UgdHlwZVxuXG4gICAgICAgICAgICBjb25zdCB0bXBPYmogPSBzb3VyY2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAndHlwZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wT2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iaiA9IHRtcE9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5faWRzLmNvbmNhdChzb3VyY2UuX2lkcyk7XG4gICAgICAgIG9iai5fcmVmcy5yZWdpc3Rlcihzb3VyY2UsIFJlZi50b1NpYmxpbmcpO1xuXG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBvYmouX3ByZWZlcmVuY2VzID8gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHNvdXJjZS5fcHJlZmVyZW5jZXMpIDogc291cmNlLl9wcmVmZXJlbmNlcztcbiAgICAgICAgb2JqLl92YWxpZHMgPSBWYWx1ZXMubWVyZ2Uob2JqLl92YWxpZHMsIHNvdXJjZS5fdmFsaWRzLCBzb3VyY2UuX2ludmFsaWRzKTtcbiAgICAgICAgb2JqLl9pbnZhbGlkcyA9IFZhbHVlcy5tZXJnZShvYmouX2ludmFsaWRzLCBzb3VyY2UuX2ludmFsaWRzLCBzb3VyY2UuX3ZhbGlkcyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuaXF1ZSBydWxlcyBwcmVzZW50IGluIHNvdXJjZVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3VyY2UuX3NpbmdsZVJ1bGVzLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKG9iai5fc2luZ2xlUnVsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9ydWxlcyA9IG9iai5fcnVsZXMuZmlsdGVyKCh0YXJnZXQpID0+IHRhcmdldC5rZWVwIHx8IHRhcmdldC5uYW1lICE9PSBuYW1lKTtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1bGVzXG5cbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIHNvdXJjZS5fcnVsZXMpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlLl9kZWZpbml0aW9uLnJ1bGVzW3Rlc3QubWV0aG9kXS5tdWx0aSkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHRlc3QubmFtZSwgdGVzdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5fcnVsZXMucHVzaCh0ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZsYWdzXG5cbiAgICAgICAgaWYgKG9iai5fZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgIHNvdXJjZS5fZmxhZ3MuZW1wdHkpIHtcblxuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IG9iai5fZmxhZ3MuZW1wdHkuY29uY2F0KHNvdXJjZS5fZmxhZ3MuZW1wdHkpO1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2UuX2ZsYWdzLmVtcHR5KSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gc291cmNlLl9mbGFncy5lbXB0eTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgc291cmNlLl9mbGFncyk7XG4gICAgICAgICAgICBkZWxldGUgZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBNZXJnZShvYmouX2ZsYWdzLCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlcm1zXG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlLiRfdGVybXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1zID0gc291cmNlLiRfdGVybXNba2V5XTtcbiAgICAgICAgICAgIGlmICghdGVybXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IHRlcm1zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW9iai4kX3Rlcm1zW2tleV0pIHtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gdGVybXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLiRfdGVybXNba2V5XSA9IG9iai4kX3Rlcm1zW2tleV0uY29uY2F0KHRlcm1zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNpbmdcblxuICAgICAgICBpZiAodGhpcy4kX3Jvb3QuX3RyYWNlcikge1xuICAgICAgICAgICAgdGhpcy4kX3Jvb3QuX3RyYWNlci5fY29tYmluZShvYmosIFt0aGlzLCBzb3VyY2VdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlYnVpbGRcblxuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIGV4dGVuZChvcHRpb25zKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFvcHRpb25zLmJhc2UsICdDYW5ub3QgZXh0ZW5kIHR5cGUgd2l0aCBhbm90aGVyIGJhc2UnKTtcblxuICAgICAgICByZXR1cm4gRXh0ZW5kLnR5cGUodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZXh0cmFjdChwYXRoKSB7XG5cbiAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5faWRzLnJlYWNoKHBhdGgpO1xuICAgIH1cblxuICAgIGZvcmsocGF0aHMsIGFkanVzdGVyKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBmb3JrIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBmb3IgKGxldCBwYXRoIG9mIFtdLmNvbmNhdChwYXRocykpIHtcbiAgICAgICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIG9iaiA9IG9iai5faWRzLmZvcmsocGF0aCwgYWRqdXN0ZXIsIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBydWxlKG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWZpbml0aW9uO1xuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBPYmplY3Qua2V5cyhkZWYubW9kaWZpZXJzKSk7XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IGZhbHNlLCAnQ2Fubm90IGFwcGx5IHJ1bGVzIHRvIGVtcHR5IHJ1bGVzZXQgb3IgdGhlIGxhc3QgcnVsZSBhZGRlZCBkb2VzIG5vdCBzdXBwb3J0IHJ1bGUgcHJvcGVydGllcycpO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuJF90ZW1wLnJ1bGVzZXQgPT09IG51bGwgPyB0aGlzLl9ydWxlcy5sZW5ndGggLSAxIDogdGhpcy4kX3RlbXAucnVsZXNldDtcbiAgICAgICAgQXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLl9ydWxlcy5sZW5ndGgsICdDYW5ub3QgYXBwbHkgcnVsZXMgdG8gZW1wdHkgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBvYmouX3J1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG9iai5fcnVsZXNbaV07XG4gICAgICAgICAgICBjb25zdCBydWxlID0gQ2xvbmUob3JpZ2luYWwpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGRlZi5tb2RpZmllcnNbbmFtZV0ocnVsZSwgb3B0aW9uc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJ1bGUubmFtZSA9PT0gb3JpZ2luYWwubmFtZSwgJ0Nhbm5vdCBjaGFuZ2UgcnVsZSBuYW1lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai5fcnVsZXNbaV0gPSBydWxlO1xuXG4gICAgICAgICAgICBpZiAob2JqLl9zaW5nbGVSdWxlcy5nZXQocnVsZS5uYW1lKSA9PT0gb3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgZ2V0IHJ1bGVzZXQoKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzdGFydCBhIG5ldyBydWxlc2V0IHdpdGhvdXQgY2xvc2luZyB0aGUgcHJldmlvdXMgb25lJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBvYmouX3J1bGVzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBnZXQgJCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5ydWxlc2V0O1xuICAgIH1cblxuICAgIHRhaWxvcih0YXJnZXRzKSB7XG5cbiAgICAgICAgdGFyZ2V0cyA9IFtdLmNvbmNhdCh0YXJnZXRzKTtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHRhaWxvciBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXM7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuXG4gICAgICAgIGlmICh0aGlzLiRfdGVybXMuYWx0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyB0YXJnZXQsIGFkanVzdGVyIH0gb2YgdGhpcy4kX3Rlcm1zLmFsdGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBhZGp1c3RlcihvYmopO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKG9iaiksICdBbHRlcmF0aW9uIGFkanVzdGVyIGZvcicsIHRhcmdldCwgJ2ZhaWxlZCB0byByZXR1cm4gYSBzY2hlbWEgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqLiRfbW9kaWZ5KHsgZWFjaDogKGl0ZW0pID0+IGl0ZW0udGFpbG9yKHRhcmdldHMpLCByZWY6IGZhbHNlIH0pO1xuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICB0cmFjZXIoKSB7XG5cbiAgICAgICAgcmV0dXJuIFRyYWNlLmxvY2F0aW9uID8gVHJhY2UubG9jYXRpb24odGhpcykgOiB0aGlzOyAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICB9XG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IuZW50cnkodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhbGlkYXRlQXN5bmModmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gVmFsaWRhdG9yLmVudHJ5QXN5bmModmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIEV4dGVuc2lvbnNcblxuICAgICRfYWRkUnVsZShvcHRpb25zKSB7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHJ1bGVcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubmFtZSAmJiB0eXBlb2Ygb3B0aW9ucy5uYW1lID09PSAnc3RyaW5nJywgJ0ludmFsaWQgcnVsZSBuYW1lJyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgQXNzZXJ0KGtleVswXSAhPT0gJ18nLCAnQ2Fubm90IHNldCBwcml2YXRlIHJ1bGUgcHJvcGVydGllcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcnVsZSA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgcnVsZS5fcmVzb2x2ZSA9IFtdO1xuICAgICAgICBydWxlLm1ldGhvZCA9IHJ1bGUubWV0aG9kIHx8IHJ1bGUubmFtZTtcblxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm1ldGhvZF07XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBydWxlLmFyZ3M7XG5cbiAgICAgICAgQXNzZXJ0KGRlZmluaXRpb24sICdVbmtub3duIHJ1bGUnLCBydWxlLm1ldGhvZCk7XG5cbiAgICAgICAgLy8gQXJnc1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgQXNzZXJ0KE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gMSB8fCBPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggPT09IHRoaXMuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5uYW1lXS5hcmdzLmxlbmd0aCwgJ0ludmFsaWQgcnVsZSBkZWZpbml0aW9uIGZvcicsIHRoaXMudHlwZSwgcnVsZS5uYW1lKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXJncykge1xuICAgICAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhcmdzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uLmFyZ3NCeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBkZWZpbml0aW9uLmFyZ3NCeU5hbWUuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyLnJlZiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmlzUmVzb2x2YWJsZShhcmcpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuX3Jlc29sdmUucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSByZXNvbHZlci5ub3JtYWxpemUoYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBhcmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlci5hc3NlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IENvbW1vbi52YWxpZGF0ZUFyZyhhcmcsIGtleSwgcmVzb2x2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCghZXJyb3IsIGVycm9yLCAnb3IgcmVmZXJlbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBhcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmlxdWUgcnVsZXNcblxuICAgICAgICBpZiAoIWRlZmluaXRpb24ubXVsdGkpIHtcbiAgICAgICAgICAgIG9iai5fcnVsZVJlbW92ZShydWxlLm5hbWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQocnVsZS5uYW1lLCBydWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouJF90ZW1wLnJ1bGVzZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24ucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIG9iai5fcnVsZXMudW5zaGlmdChydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5fcnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgJF9jb21waWxlKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBDb21waWxlLnNjaGVtYSh0aGlzLiRfcm9vdCwgc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAkX2NyZWF0ZUVycm9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgc3RhdGUsIHByZWZzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBjb25zdCBmbGFncyA9IG9wdGlvbnMuZmxhZ3MgIT09IGZhbHNlID8gdGhpcy5fZmxhZ3MgOiB7fTtcbiAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBvcHRpb25zLm1lc3NhZ2VzID8gTWVzc2FnZXMubWVyZ2UodGhpcy5fZGVmaW5pdGlvbi5tZXNzYWdlcywgb3B0aW9ucy5tZXNzYWdlcykgOiB0aGlzLl9kZWZpbml0aW9uLm1lc3NhZ2VzO1xuICAgICAgICByZXR1cm4gbmV3IEVycm9ycy5SZXBvcnQoY29kZSwgdmFsdWUsIGxvY2FsLCBmbGFncywgbWVzc2FnZXMsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgJF9nZXRGbGFnKG5hbWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3NbbmFtZV07XG4gICAgfVxuXG4gICAgJF9nZXRSdWxlKG5hbWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fc2luZ2xlUnVsZXMuZ2V0KG5hbWUpO1xuICAgIH1cblxuICAgICRfbWFwTGFiZWxzKHBhdGgpIHtcblxuICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHMubGFiZWxzKHBhdGgpO1xuICAgIH1cblxuICAgICRfbWF0Y2godmFsdWUsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzKSB7XG5cbiAgICAgICAgcHJlZnMgPSBPYmplY3QuYXNzaWduKHt9LCBwcmVmcyk7ICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgIHByZWZzLmFib3J0RWFybHkgPSB0cnVlO1xuICAgICAgICBwcmVmcy5fZXh0ZXJuYWxzID0gZmFsc2U7XG5cbiAgICAgICAgc3RhdGUuc25hcHNob3QoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gIVZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZSwgdGhpcywgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMpLmVycm9ycztcbiAgICAgICAgc3RhdGUucmVzdG9yZSgpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgJF9tb2RpZnkob3B0aW9ucykge1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnZWFjaCcsICdvbmNlJywgJ3JlZicsICdzY2hlbWEnXSk7XG4gICAgICAgIHJldHVybiBNb2RpZnkuc2NoZW1hKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgfVxuXG4gICAgJF9tdXRhdGVSZWJ1aWxkKCkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgYWRkIHRoaXMgcnVsZSBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgdGhpcy5fcmVmcy5yZXNldCgpO1xuICAgICAgICB0aGlzLl9pZHMucmVzZXQoKTtcblxuICAgICAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHsgc291cmNlLCBuYW1lLCBwYXRoLCBrZXkgfSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBmYW1pbHkgPSB0aGlzLl9kZWZpbml0aW9uW3NvdXJjZV1bbmFtZV0gJiYgdGhpcy5fZGVmaW5pdGlvbltzb3VyY2VdW25hbWVdLnJlZ2lzdGVyO1xuICAgICAgICAgICAgaWYgKGZhbWlseSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRfbXV0YXRlUmVnaXN0ZXIoaXRlbSwgeyBmYW1pbHksIGtleSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLiRfbW9kaWZ5KHsgZWFjaCB9KTtcblxuICAgICAgICBpZiAodGhpcy5fZGVmaW5pdGlvbi5yZWJ1aWxkKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZpbml0aW9uLnJlYnVpbGQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgICRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hLCB7IGZhbWlseSwga2V5IH0gPSB7fSkge1xuXG4gICAgICAgIHRoaXMuX3JlZnMucmVnaXN0ZXIoc2NoZW1hLCBmYW1pbHkpO1xuICAgICAgICB0aGlzLl9pZHMucmVnaXN0ZXIoc2NoZW1hLCB7IGtleSB9KTtcbiAgICB9XG5cbiAgICAkX3Byb3BlcnR5KG5hbWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbi5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIH1cblxuICAgICRfcmVhY2gocGF0aCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pZHMucmVhY2gocGF0aCk7XG4gICAgfVxuXG4gICAgJF9yb290UmVmZXJlbmNlcygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVmcy5yb290cygpO1xuICAgIH1cblxuICAgICRfc2V0RmxhZyhuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KG5hbWVbMF0gPT09ICdfJyB8fCAhdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3Qgc2V0IGZsYWcgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IGZsYWcgPSB0aGlzLl9kZWZpbml0aW9uLmZsYWdzW25hbWVdIHx8IHt9O1xuICAgICAgICBpZiAoRGVlcEVxdWFsKHZhbHVlLCBmbGFnLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChEZWVwRXF1YWwodmFsdWUsIHRoaXMuX2ZsYWdzW25hbWVdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSBvcHRpb25zLmNsb25lICE9PSBmYWxzZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX2ZsYWdzW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVbMF0gIT09ICdfJykge1xuICAgICAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgICRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IudmFsaWRhdGUodmFsdWUsIHRoaXMsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWxzXG5cbiAgICBfYXNzaWduKHRhcmdldCkge1xuXG4gICAgICAgIHRhcmdldC50eXBlID0gdGhpcy50eXBlO1xuXG4gICAgICAgIHRhcmdldC4kX3Jvb3QgPSB0aGlzLiRfcm9vdDtcblxuICAgICAgICB0YXJnZXQuJF90ZW1wID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy4kX3RlbXApO1xuICAgICAgICB0YXJnZXQuJF90ZW1wLndoZW5zID0ge307XG5cbiAgICAgICAgdGFyZ2V0Ll9pZHMgPSB0aGlzLl9pZHMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9wcmVmZXJlbmNlcyA9IHRoaXMuX3ByZWZlcmVuY2VzO1xuICAgICAgICB0YXJnZXQuX3ZhbGlkcyA9IHRoaXMuX3ZhbGlkcyAmJiB0aGlzLl92YWxpZHMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9pbnZhbGlkcyA9IHRoaXMuX2ludmFsaWRzICYmIHRoaXMuX2ludmFsaWRzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fcnVsZXMgPSB0aGlzLl9ydWxlcy5zbGljZSgpO1xuICAgICAgICB0YXJnZXQuX3NpbmdsZVJ1bGVzID0gQ2xvbmUodGhpcy5fc2luZ2xlUnVsZXMsIHsgc2hhbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgdGFyZ2V0Ll9yZWZzID0gdGhpcy5fcmVmcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX2ZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZmxhZ3MpO1xuICAgICAgICB0YXJnZXQuX2NhY2hlID0gbnVsbDtcblxuICAgICAgICB0YXJnZXQuJF90ZXJtcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLiRfdGVybXMpIHtcbiAgICAgICAgICAgIHRhcmdldC4kX3Rlcm1zW2tleV0gPSB0aGlzLiRfdGVybXNba2V5XSA/IHRoaXMuJF90ZXJtc1trZXldLnNsaWNlKCkgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0LiRfc3VwZXIgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBpbiB0aGlzLiRfc3VwZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC4kX3N1cGVyW292ZXJyaWRlXSA9IHRoaXMuX3N1cGVyW292ZXJyaWRlXS5iaW5kKHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIF9kZWZhdWx0KGZsYWcsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCAnbGl0ZXJhbCcpO1xuXG4gICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnTWlzc2luZycsIGZsYWcsICd2YWx1ZScpO1xuICAgICAgICBBc3NlcnQodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8ICFvcHRpb25zLmxpdGVyYWwsICdPbmx5IGZ1bmN0aW9uIHZhbHVlIHN1cHBvcnRzIGxpdGVyYWwgb3B0aW9uJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5saXRlcmFsKSB7XG5cbiAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgIFtDb21tb24uc3ltYm9scy5saXRlcmFsXTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsaXRlcmFsOiB2YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuJF9zZXRGbGFnKGZsYWcsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGlmICghdGhpcy4kX3Rlcm1zLndoZW5zKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IHRoaXMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbGxlY3QgbWF0Y2hpbmcgd2hlbnNcblxuICAgICAgICBjb25zdCB3aGVucyA9IFtdO1xuICAgICAgICBjb25zdCBpZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLiRfdGVybXMud2hlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHdoZW4gPSB0aGlzLiRfdGVybXMud2hlbnNbaV07XG5cbiAgICAgICAgICAgIGlmICh3aGVuLmNvbmNhdCkge1xuICAgICAgICAgICAgICAgIHdoZW5zLnB1c2god2hlbi5jb25jYXQpO1xuICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2l9LmNvbmNhdGApO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IHdoZW4ucmVmID8gd2hlbi5yZWYucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSA6IHZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdGVzdHMgPSB3aGVuLmlzID8gW3doZW5dIDogd2hlbi5zd2l0Y2g7XG4gICAgICAgICAgICBjb25zdCBiZWZvcmUgPSBpZHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRlc3RzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpcywgdGhlbiwgb3RoZXJ3aXNlIH0gPSB0ZXN0c1tqXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VJZCA9IGAke2l9JHt3aGVuLnN3aXRjaCA/ICcuJyArIGogOiAnJ31gO1xuICAgICAgICAgICAgICAgIGlmIChpcy4kX21hdGNoKGlucHV0LCBzdGF0ZS5uZXN0KGlzLCBgJHtiYXNlSWR9LmlzYCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBgJHtiYXNlSWR9LnRoZW5gXSwgc3RhdGUuYW5jZXN0b3JzLCBzdGF0ZS5zY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hOiBnZW5lcmF0ZWQsIGlkIH0gPSB0aGVuLl9nZW5lcmF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlbnMucHVzaChnZW5lcmF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7YmFzZUlkfS50aGVuJHtpZCA/IGAoJHtpZH0pYCA6ICcnfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgYCR7YmFzZUlkfS5vdGhlcndpc2VgXSwgc3RhdGUuYW5jZXN0b3JzLCBzdGF0ZS5zY2hlbWFzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWE6IGdlbmVyYXRlZCwgaWQgfSA9IG90aGVyd2lzZS5fZ2VuZXJhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgd2hlbnMucHVzaChnZW5lcmF0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtiYXNlSWR9Lm90aGVyd2lzZSR7aWQgPyBgKCR7aWR9KWAgOiAnJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod2hlbi5icmVhayAmJlxuICAgICAgICAgICAgICAgIGlkcy5sZW5ndGggPiBiZWZvcmUpIHsgICAgICAgICAgLy8gU29tZXRoaW5nIG1hdGNoZWRcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FjaGVcblxuICAgICAgICBjb25zdCBpZCA9IGlkcy5qb2luKCcsICcpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICdydWxlJywgJ3doZW4nLCBpZCk7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiB0aGlzIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlLm1haW5zdGF5LnRyYWNlci5hY3RpdmUgJiZcbiAgICAgICAgICAgIHRoaXMuJF90ZW1wLndoZW5zW2lkXSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IHRoaXMuJF90ZW1wLndoZW5zW2lkXSwgaWQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGR5bmFtaWMgc2NoZW1hXG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXM7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgICAgICAgaWYgKHRoaXMuX2RlZmluaXRpb24uZ2VuZXJhdGUpIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuX2RlZmluaXRpb24uZ2VuZXJhdGUodGhpcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSB3aGVuc1xuXG4gICAgICAgIGZvciAoY29uc3Qgd2hlbiBvZiB3aGVucykge1xuICAgICAgICAgICAgb2JqID0gb2JqLmNvbmNhdCh3aGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNpbmdcblxuICAgICAgICBpZiAodGhpcy4kX3Jvb3QuX3RyYWNlcikge1xuICAgICAgICAgICAgdGhpcy4kX3Jvb3QuX3RyYWNlci5fY29tYmluZShvYmosIFt0aGlzLCAuLi53aGVuc10pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FjaGUgcmVzdWx0XG5cbiAgICAgICAgdGhpcy4kX3RlbXAud2hlbnNbaWRdID0gb2JqO1xuICAgICAgICByZXR1cm4geyBzY2hlbWE6IG9iaiwgaWQgfTtcbiAgICB9XG5cbiAgICBfaW5uZXIodHlwZSwgdmFsdWVzLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCBgQ2Fubm90IHNldCAke3R5cGV9IGluc2lkZSBhIHJ1bGVzZXRgKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGlmICghb2JqLiRfdGVybXNbdHlwZV0gfHxcbiAgICAgICAgICAgIG9wdGlvbnMub3ZlcnJpZGUpIHtcblxuICAgICAgICAgICAgb2JqLiRfdGVybXNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnNpbmdsZSkge1xuICAgICAgICAgICAgb2JqLiRfdGVybXNbdHlwZV0ucHVzaCh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLiRfdGVybXNbdHlwZV0ucHVzaCguLi52YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2luUnVsZXNldCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3RlbXAucnVsZXNldCAhPT0gbnVsbCAmJiB0aGlzLiRfdGVtcC5ydWxlc2V0ICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBfcnVsZVJlbW92ZShuYW1lLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3NpbmdsZVJ1bGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSBvcHRpb25zLmNsb25lICE9PSBmYWxzZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXM7XG5cbiAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5kZWxldGUobmFtZSk7XG5cbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmouX3J1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0ID0gb2JqLl9ydWxlc1tpXTtcbiAgICAgICAgICAgIGlmICh0ZXN0Lm5hbWUgPT09IG5hbWUgJiZcbiAgICAgICAgICAgICAgICAhdGVzdC5rZWVwKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqLl9pblJ1bGVzZXQoKSAmJlxuICAgICAgICAgICAgICAgICAgICBpIDwgb2JqLiRfdGVtcC5ydWxlc2V0KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLS1vYmouJF90ZW1wLnJ1bGVzZXQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2godGVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX3J1bGVzID0gZmlsdGVyZWQ7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX3ZhbHVlcyh2YWx1ZXMsIGtleSkge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywga2V5LnNsaWNlKDEsIC0xKSk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGNvbnN0IG92ZXJyaWRlID0gdmFsdWVzWzBdID09PSBDb21tb24uc3ltYm9scy5vdmVycmlkZTtcbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuc2xpY2UoMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9ialtrZXldICYmXG4gICAgICAgICAgICB2YWx1ZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIG9ialtrZXldID0gbmV3IFZhbHVlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlcy5sZW5ndGggPyBuZXcgVmFsdWVzKCkgOiBudWxsO1xuICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvYmpba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgb2JqW2tleV0ub3ZlcnJpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIGFsbG93L3ZhbGlkL2ludmFsaWQgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGUsICdPdmVycmlkZSBtdXN0IGJlIHRoZSBmaXJzdCB2YWx1ZScpO1xuXG4gICAgICAgICAgICBjb25zdCBvdGhlciA9IGtleSA9PT0gJ19pbnZhbGlkcycgPyAnX3ZhbGlkcycgOiAnX2ludmFsaWRzJztcbiAgICAgICAgICAgIGlmIChvYmpbb3RoZXJdKSB7XG4gICAgICAgICAgICAgICAgb2JqW290aGVyXS5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICghb2JqW290aGVyXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGtleSA9PT0gJ192YWxpZHMnIHx8ICFvYmouX2ZsYWdzLm9ubHksICdTZXR0aW5nIGludmFsaWQgdmFsdWUnLCB2YWx1ZSwgJ2xlYXZlcyBzY2hlbWEgcmVqZWN0aW5nIGFsbCB2YWx1ZXMgZHVlIHRvIHByZXZpb3VzIHZhbGlkIHJ1bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqW290aGVyXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmpba2V5XS5hZGQodmFsdWUsIG9iai5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmlzSW1tdXRhYmxlID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBIb2VrIGZyb20gZGVlcCBjbG9uaW5nIHNjaGVtYSBvYmplY3RzXG5cblxuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlW0NvbW1vbi5zeW1ib2xzLmFueV0gPSB7XG4gICAgdmVyc2lvbjogQ29tbW9uLnZlcnNpb24sXG4gICAgY29tcGlsZTogQ29tcGlsZS5jb21waWxlLFxuICAgIHJvb3Q6ICckX3Jvb3QnXG59O1xuXG5cbi8vIEFsaWFzZXNcblxuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmRlbnkgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5kaXNhbGxvdyA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5pbnZhbGlkO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmVxdWFsID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnZhbGlkO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmV4aXN0ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLnJlcXVpcmVkO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLm5vdCA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5pbnZhbGlkO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLm9wdGlvbnMgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUucHJlZnM7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUucHJlZmVyZW5jZXMgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUucHJlZnM7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkJhc2UoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1heDogMTAwMCxcbiAgICBzdXBwb3J0ZWQ6IG5ldyBTZXQoWyd1bmRlZmluZWQnLCAnYm9vbGVhbicsICdudW1iZXInLCAnc3RyaW5nJ10pXG59O1xuXG5cbmV4cG9ydHMucHJvdmlkZXIgPSB7XG5cbiAgICBwcm92aXNpb24ob3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkNhY2hlKG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuLy8gTGVhc3QgUmVjZW50bHkgVXNlZCAoTFJVKSBDYWNoZVxuXG5pbnRlcm5hbHMuQ2FjaGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ21heCddKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubWF4ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5tYXggJiYgb3B0aW9ucy5tYXggPiAwICYmIGlzRmluaXRlKG9wdGlvbnMubWF4KSwgJ0ludmFsaWQgbWF4IGNhY2hlIHNpemUnKTtcblxuICAgICAgICB0aGlzLl9tYXggPSBvcHRpb25zLm1heCB8fCBpbnRlcm5hbHMubWF4O1xuXG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcCBvZiBub2RlcyBieSBrZXlcbiAgICAgICAgdGhpcy5fbGlzdCA9IG5ldyBpbnRlcm5hbHMuTGlzdCgpOyAgICAgICAgICAgICAgLy8gTGlzdCBvZiBub2RlcyAobW9zdCByZWNlbnRseSB1c2VkIGluIGhlYWQpXG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gICAgfVxuXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoa2V5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxzLnN1cHBvcnRlZC5oYXModHlwZW9mIGtleSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9saXN0LmZpcnN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHRoaXMuX2xpc3QudW5zaGlmdCh7IGtleSwgdmFsdWUgfSk7XG4gICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBub2RlKTtcbiAgICAgICAgdGhpcy5fY29tcGFjdCgpO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcblxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdC5maXJzdChub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBDbG9uZShub2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jb21wYWN0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXAuc2l6ZSA+IHRoaXMuX21heCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2xpc3QucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKG5vZGUua2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkxpc3QgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIH1cblxuICAgIHVuc2hpZnQobm9kZSkge1xuXG4gICAgICAgIG5vZGUubmV4dCA9IG51bGw7XG4gICAgICAgIG5vZGUucHJldiA9IHRoaXMuaGVhZDtcblxuICAgICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQubmV4dCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuXG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZmlyc3Qobm9kZSkge1xuXG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZShub2RlKTtcbiAgICAgICAgdGhpcy51bnNoaWZ0KG5vZGUpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKHRoaXMudGFpbCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZShub2RlKSB7XG5cbiAgICAgICAgY29uc3QgeyBuZXh0LCBwcmV2IH0gPSBub2RlO1xuXG4gICAgICAgIG5leHQucHJldiA9IHByZXY7XG5cbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IEFzc2VydEVycm9yID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXJyb3InKTtcblxuY29uc3QgUGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5cbmxldCBNZXNzYWdlcztcbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBpc29EYXRlOiAvXig/OlstK11cXGR7Mn0pPyg/OlxcZHs0fSg/IVxcZHsyfVxcYikpKD86KC0/KSg/Oig/OjBbMS05XXwxWzAtMl0pKD86XFwxKD86WzEyXVxcZHwwWzEtOV18M1swMV0pKT98Vyg/OlswLTRdXFxkfDVbMC0yXSkoPzotP1sxLTddKT98KD86MDBbMS05XXwwWzEtOV1cXGR8WzEyXVxcZHsyfXwzKD86WzAtNV1cXGR8NlsxLTZdKSkpKD8hW1RdJHxbVF1bXFxkXStaJCkoPzpbVFxcc10oPzooPzooPzpbMDFdXFxkfDJbMC0zXSkoPzooOj8pWzAtNV1cXGQpP3wyNFxcOj8wMCkoPzpbLixdXFxkKyg/ITopKT8pKD86XFwyWzAtNV1cXGQoPzpbLixdXFxkKyk/KT8oPzpbWl18KD86WystXSkoPzpbMDFdXFxkfDJbMC0zXSkoPzo6P1swLTVdXFxkKT8pPyk/KT8kL1xufTtcblxuXG5leHBvcnRzLnZlcnNpb24gPSBQa2cudmVyc2lvbjtcblxuXG5leHBvcnRzLmRlZmF1bHRzID0ge1xuICAgIGFib3J0RWFybHk6IHRydWUsXG4gICAgYWxsb3dVbmtub3duOiBmYWxzZSxcbiAgICBjYWNoZTogdHJ1ZSxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIGNvbnZlcnQ6IHRydWUsXG4gICAgZGF0ZUZvcm1hdDogJ2lzbycsXG4gICAgZXJyb3JzOiB7XG4gICAgICAgIGVzY2FwZUh0bWw6IGZhbHNlLFxuICAgICAgICBsYWJlbDogJ3BhdGgnLFxuICAgICAgICBsYW5ndWFnZTogbnVsbCxcbiAgICAgICAgcmVuZGVyOiB0cnVlLFxuICAgICAgICBzdGFjazogZmFsc2UsXG4gICAgICAgIHdyYXBBcnJheXM6IHRydWVcbiAgICB9LFxuICAgIGV4dGVybmFsczogdHJ1ZSxcbiAgICBtZXNzYWdlczoge30sXG4gICAgbm9uRW51bWVyYWJsZXM6IGZhbHNlLFxuICAgIG5vRGVmYXVsdHM6IGZhbHNlLFxuICAgIHByZXNlbmNlOiAnb3B0aW9uYWwnLFxuICAgIHNraXBGdW5jdGlvbnM6IGZhbHNlLFxuICAgIHN0cmlwVW5rbm93bjogZmFsc2UsXG4gICAgd2FybmluZ3M6IGZhbHNlXG59O1xuXG5cbmV4cG9ydHMuc3ltYm9scyA9IHtcbiAgICBhbnk6IFN5bWJvbC5mb3IoJ0BoYXBpL2pvaS9zY2hlbWEnKSwgICAgICAgICAgICAvLyBVc2VkIHRvIGludGVybmFsbHkgaWRlbnRpZnkgYW55LWJhc2VkIHR5cGVzIChzaGFyZWQgd2l0aCBvdGhlciBqb2kgdmVyc2lvbnMpXG4gICAgYXJyYXlTaW5nbGU6IFN5bWJvbCgnYXJyYXlTaW5nbGUnKSxcbiAgICBkZWVwRGVmYXVsdDogU3ltYm9sKCdkZWVwRGVmYXVsdCcpLFxuICAgIGxpdGVyYWw6IFN5bWJvbCgnbGl0ZXJhbCcpLFxuICAgIG92ZXJyaWRlOiBTeW1ib2woJ292ZXJyaWRlJyksXG4gICAgcHJlZnM6IFN5bWJvbCgncHJlZnMnKSxcbiAgICByZWY6IFN5bWJvbCgncmVmJyksXG4gICAgdmFsdWVzOiBTeW1ib2woJ3ZhbHVlcycpLFxuICAgIHRlbXBsYXRlOiBTeW1ib2woJ3RlbXBsYXRlJylcbn07XG5cblxuZXhwb3J0cy5hc3NlcnRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIGtleXMsIG5hbWUgPSAnT3B0aW9ucycpIHtcblxuICAgIEFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShvcHRpb25zKSwgJ09wdGlvbnMgbXVzdCBiZSBvZiB0eXBlIG9iamVjdCcpO1xuICAgIGNvbnN0IHVua25vd25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrKSA9PiAha2V5cy5pbmNsdWRlcyhrKSk7XG4gICAgQXNzZXJ0KHVua25vd25LZXlzLmxlbmd0aCA9PT0gMCwgYCR7bmFtZX0gY29udGFpbiB1bmtub3duIGtleXM6ICR7dW5rbm93bktleXN9YCk7XG59O1xuXG5cbmV4cG9ydHMuY2hlY2tQcmVmZXJlbmNlcyA9IGZ1bmN0aW9uIChwcmVmcykge1xuXG4gICAgU2NoZW1hcyA9IFNjaGVtYXMgfHwgcmVxdWlyZSgnLi9zY2hlbWFzJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBTY2hlbWFzLnByZWZlcmVuY2VzLnZhbGlkYXRlKHByZWZzKTtcblxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydEVycm9yKFtyZXN1bHQuZXJyb3IuZGV0YWlsc1swXS5tZXNzYWdlXSk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYiwgb3BlcmF0b3IpIHtcblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPSc6IHJldHVybiBhID09PSBiO1xuICAgICAgICBjYXNlICc+JzogcmV0dXJuIGEgPiBiO1xuICAgICAgICBjYXNlICc8JzogcmV0dXJuIGEgPCBiO1xuICAgICAgICBjYXNlICc+PSc6IHJldHVybiBhID49IGI7XG4gICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIGEgPD0gYjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufTtcblxuXG5leHBvcnRzLmlzSXNvRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmlzb0RhdGUudGVzdChkYXRlKTtcbn07XG5cblxuZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy5pc1Jlc29sdmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialtleHBvcnRzLnN5bWJvbHMucmVmXSB8fCBvYmpbZXhwb3J0cy5zeW1ib2xzLnRlbXBsYXRlXTtcbn07XG5cblxuZXhwb3J0cy5pc1NjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hICYmIHNjaGVtYVtleHBvcnRzLnN5bWJvbHMuYW55XTtcbiAgICBpZiAoIWFueSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgQXNzZXJ0KG9wdGlvbnMubGVnYWN5IHx8IGFueS52ZXJzaW9uID09PSBleHBvcnRzLnZlcnNpb24sICdDYW5ub3QgbWl4IGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBqb2kgc2NoZW1hcycpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5leHBvcnRzLmlzVmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgcmV0dXJuIG9ialtleHBvcnRzLnN5bWJvbHMudmFsdWVzXTtcbn07XG5cblxuZXhwb3J0cy5saW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAwO1xufTtcblxuXG5leHBvcnRzLnByZWZlcmVuY2VzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cbiAgICBNZXNzYWdlcyA9IE1lc3NhZ2VzIHx8IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgICBzb3VyY2UgPSBzb3VyY2UgfHwge307XG5cbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQsIHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZS5lcnJvcnMgJiZcbiAgICAgICAgdGFyZ2V0LmVycm9ycykge1xuXG4gICAgICAgIG1lcmdlZC5lcnJvcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQuZXJyb3JzLCBzb3VyY2UuZXJyb3JzKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlLm1lc3NhZ2VzKSB7XG4gICAgICAgIG1lcmdlZC5tZXNzYWdlcyA9IE1lc3NhZ2VzLmNvbXBpbGUoc291cmNlLm1lc3NhZ2VzLCB0YXJnZXQubWVzc2FnZXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSBtZXJnZWRbZXhwb3J0cy5zeW1ib2xzLnByZWZzXTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufTtcblxuXG5leHBvcnRzLnRyeVdpdGhQYXRoID0gZnVuY3Rpb24gKGZuLCBrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVyci5wYXRoID0ga2V5ICsgJy4nICsgZXJyLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnIucGF0aCA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZCkge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLnBhdGh9KWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnZhbGlkYXRlQXJnID0gZnVuY3Rpb24gKHZhbHVlLCBsYWJlbCwgeyBhc3NlcnQsIG1lc3NhZ2UgfSkge1xuXG4gICAgaWYgKGV4cG9ydHMuaXNTY2hlbWEoYXNzZXJ0KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhc3NlcnQudmFsaWRhdGUodmFsdWUpO1xuICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYXNzZXJ0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbGFiZWwgPyBgJHtsYWJlbH0gJHttZXNzYWdlfWAgOiBtZXNzYWdlO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy52ZXJpZnlGbGF0ID0gZnVuY3Rpb24gKGFyZ3MsIG1ldGhvZCkge1xuXG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICBBc3NlcnQoIUFycmF5LmlzQXJyYXkoYXJnKSwgJ01ldGhvZCBubyBsb25nZXIgYWNjZXB0cyBhcnJheSBhcmd1bWVudHM6JywgbWV0aG9kKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5zY2hlbWEgPSBmdW5jdGlvbiAoSm9pLCBjb25maWcsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhcHBlbmRQYXRoJywgJ292ZXJyaWRlJ10pO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zY2hlbWEoSm9pLCBjb25maWcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFwcGVuZFBhdGggJiZcbiAgICAgICAgICAgIGVyci5wYXRoICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgJHtlcnIubWVzc2FnZX0gKCR7ZXJyLnBhdGh9KWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hID0gZnVuY3Rpb24gKEpvaSwgY29uZmlnLCBvcHRpb25zKSB7XG5cbiAgICBBc3NlcnQoY29uZmlnICE9PSB1bmRlZmluZWQsICdJbnZhbGlkIHVuZGVmaW5lZCBzY2hlbWEnKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgQXNzZXJ0KGNvbmZpZy5sZW5ndGgsICdJbnZhbGlkIGVtcHR5IGFycmF5IHNjaGVtYScpO1xuXG4gICAgICAgIGlmIChjb25maWcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb25maWcgPSBjb25maWdbMF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZCA9IChiYXNlLCAuLi52YWx1ZXMpID0+IHtcblxuICAgICAgICBpZiAob3B0aW9ucy5vdmVycmlkZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlLnZhbGlkKEpvaS5vdmVycmlkZSwgLi4udmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYXNlLnZhbGlkKC4uLnZhbHVlcyk7XG4gICAgfTtcblxuICAgIGlmIChpbnRlcm5hbHMuc2ltcGxlKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gSm9pLmN1c3RvbShjb25maWcpO1xuICAgIH1cblxuICAgIEFzc2VydCh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JywgJ0ludmFsaWQgc2NoZW1hIGNvbnRlbnQ6JywgdHlwZW9mIGNvbmZpZyk7XG5cbiAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2ksIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShjb25maWcpKSB7XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5zaW1wbGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSm9pLmFsdGVybmF0aXZlcygpLnRyeSguLi5jb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgLi4uY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiBKb2kuc3RyaW5nKCkucmVnZXgoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLmRhdGUoKSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBBc3NlcnQoT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbmZpZykgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSksICdTY2hlbWEgY2FuIG9ubHkgY29udGFpbiBwbGFpbiBvYmplY3RzJyk7XG5cbiAgICByZXR1cm4gSm9pLm9iamVjdCgpLmtleXMoY29uZmlnKTtcbn07XG5cblxuZXhwb3J0cy5yZWYgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiBSZWYuaXNSZWYoaWQpID8gaWQgOiBSZWYuY3JlYXRlKGlkLCBvcHRpb25zKTtcbn07XG5cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKHJvb3QsIHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2xlZ2FjeSddKTtcblxuICAgIC8vIENvbXBpbGVkIGJ5IGFueSBzdXBwb3J0ZWQgdmVyc2lvblxuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hICYmIHNjaGVtYVtDb21tb24uc3ltYm9scy5hbnldO1xuICAgIGlmIChhbnkpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMubGVnYWN5IHx8IGFueS52ZXJzaW9uID09PSBDb21tb24udmVyc2lvbiwgJ0Nhbm5vdCBtaXggZGlmZmVyZW50IHZlcnNpb25zIG9mIGpvaSBzY2hlbWFzJyk7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgLy8gVW5jb21waWxlZCByb290XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgIW9wdGlvbnMubGVnYWN5KSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc2NoZW1hKHJvb3QsIHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pOyAgICAgICAgICAvLyBXaWxsIGVycm9yIGlmIHNjaGVtYSBjb250YWlucyBvdGhlciB2ZXJzaW9uc1xuICAgIH1cblxuICAgIC8vIFNjYW4gc2NoZW1hIGZvciBjb21waWxlZCBwYXJ0c1xuXG4gICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhzY2hlbWEpO1xuICAgIGlmICghY29tcGlsZXIpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuc2NoZW1hKHJvb3QsIHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb21waWxlci5jb21waWxlKGNvbXBpbGVyLnJvb3QsIHNjaGVtYSk7XG59O1xuXG5cbmludGVybmFscy53YWxrID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhpdGVtKTtcbiAgICAgICAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21waWxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGFueSA9IHNjaGVtYVtDb21tb24uc3ltYm9scy5hbnldO1xuICAgIGlmIChhbnkpIHtcbiAgICAgICAgcmV0dXJuIHsgcm9vdDogc2NoZW1hW2FueS5yb290XSwgY29tcGlsZTogYW55LmNvbXBpbGUgfTtcbiAgICB9XG5cbiAgICBBc3NlcnQoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNjaGVtYSkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih7fSksICdTY2hlbWEgY2FuIG9ubHkgY29udGFpbiBwbGFpbiBvYmplY3RzJyk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgY29tcGlsZXIgPSBpbnRlcm5hbHMud2FsayhzY2hlbWFba2V5XSk7XG4gICAgICAgIGlmIChjb21waWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5zaW1wbGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCBbJ2Jvb2xlYW4nLCAnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSk7XG59O1xuXG5cbmV4cG9ydHMud2hlbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBBc3NlcnQoY29uZGl0aW9uICYmIHR5cGVvZiBjb25kaXRpb24gPT09ICdvYmplY3QnLCAnTWlzc2luZyBvcHRpb25zJyk7XG5cbiAgICAgICAgb3B0aW9ucyA9IGNvbmRpdGlvbjtcbiAgICAgICAgY29uZGl0aW9uID0gUmVmLmNyZWF0ZSgnLicpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHN3aXRjaDogb3B0aW9ucyB9O1xuICAgIH1cblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaXMnLCAnbm90JywgJ3RoZW4nLCAnb3RoZXJ3aXNlJywgJ3N3aXRjaCcsICdicmVhayddKTtcblxuICAgIC8vIFNjaGVtYSBjb25kaXRpb25cblxuICAgIGlmIChDb21tb24uaXNTY2hlbWEoY29uZGl0aW9uKSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnXCJpc1wiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCwgJ1wibm90XCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLnN3aXRjaCA9PT0gdW5kZWZpbmVkLCAnXCJzd2l0Y2hcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmRpdGlvbihzY2hlbWEsIHsgaXM6IGNvbmRpdGlvbiwgdGhlbjogb3B0aW9ucy50aGVuLCBvdGhlcndpc2U6IG9wdGlvbnMub3RoZXJ3aXNlLCBicmVhazogb3B0aW9ucy5icmVhayB9KTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgY29uZGl0aW9uXG5cbiAgICBBc3NlcnQoUmVmLmlzUmVmKGNvbmRpdGlvbikgfHwgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ3N0cmluZycsICdJbnZhbGlkIGNvbmRpdGlvbjonLCBjb25kaXRpb24pO1xuICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwiaXNcIiB3aXRoIFwibm90XCInKTtcblxuICAgIGlmIChvcHRpb25zLnN3aXRjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBydWxlID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMubm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJ1bGUgPSB7IGlzOiBvcHRpb25zLm5vdCwgdGhlbjogb3B0aW9ucy5vdGhlcndpc2UsIG90aGVyd2lzZTogb3B0aW9ucy50aGVuLCBicmVhazogb3B0aW9ucy5icmVhayB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzID0gcnVsZS5pcyAhPT0gdW5kZWZpbmVkID8gc2NoZW1hLiRfY29tcGlsZShydWxlLmlzKSA6IHNjaGVtYS4kX3Jvb3QuaW52YWxpZChudWxsLCBmYWxzZSwgMCwgJycpLnJlcXVpcmVkKCk7XG4gICAgICAgIEFzc2VydChydWxlLnRoZW4gIT09IHVuZGVmaW5lZCB8fCBydWxlLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkLCAnb3B0aW9ucyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIFwidGhlblwiLCBcIm90aGVyd2lzZVwiLCBvciBcInN3aXRjaFwiJyk7XG4gICAgICAgIEFzc2VydChydWxlLmJyZWFrID09PSB1bmRlZmluZWQgfHwgcnVsZS50aGVuID09PSB1bmRlZmluZWQgfHwgcnVsZS5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IHRoZW4sIG90aGVyd2lzZSwgYW5kIGJyZWFrIGFsbCB0b2dldGhlcicpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmlzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFSZWYuaXNSZWYob3B0aW9ucy5pcykgJiZcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEob3B0aW9ucy5pcykpIHtcblxuICAgICAgICAgICAgaXMgPSBpcy5yZXF1aXJlZCgpOyAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgcmVxdWlyZWQgaWYgdGhpcyB3YXNuJ3QgYWxyZWFkeSBhIHNjaGVtYSBvciBhIHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jb25kaXRpb24oc2NoZW1hLCB7IHJlZjogZXhwb3J0cy5yZWYoY29uZGl0aW9uKSwgaXMsIHRoZW46IHJ1bGUudGhlbiwgb3RoZXJ3aXNlOiBydWxlLm90aGVyd2lzZSwgYnJlYWs6IHJ1bGUuYnJlYWsgfSk7XG4gICAgfVxuXG4gICAgLy8gU3dpdGNoIHN0YXRlbWVudFxuXG4gICAgQXNzZXJ0KEFycmF5LmlzQXJyYXkob3B0aW9ucy5zd2l0Y2gpLCAnXCJzd2l0Y2hcIiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMuaXMgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcImlzXCInKTtcbiAgICBBc3NlcnQob3B0aW9ucy5ub3QgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjb21iaW5lIFwic3dpdGNoXCIgd2l0aCBcIm5vdFwiJyk7XG4gICAgQXNzZXJ0KG9wdGlvbnMudGhlbiA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwidGhlblwiJyk7XG5cbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICByZWY6IGV4cG9ydHMucmVmKGNvbmRpdGlvbiksXG4gICAgICAgIHN3aXRjaDogW10sXG4gICAgICAgIGJyZWFrOiBvcHRpb25zLmJyZWFrXG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5zd2l0Y2gubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdGVzdCA9IG9wdGlvbnMuc3dpdGNoW2ldO1xuICAgICAgICBjb25zdCBsYXN0ID0gaSA9PT0gb3B0aW9ucy5zd2l0Y2gubGVuZ3RoIC0gMTtcblxuICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyh0ZXN0LCBsYXN0ID8gWydpcycsICd0aGVuJywgJ290aGVyd2lzZSddIDogWydpcycsICd0aGVuJ10pO1xuXG4gICAgICAgIEFzc2VydCh0ZXN0LmlzICE9PSB1bmRlZmluZWQsICdTd2l0Y2ggc3RhdGVtZW50IG1pc3NpbmcgXCJpc1wiJyk7XG4gICAgICAgIEFzc2VydCh0ZXN0LnRoZW4gIT09IHVuZGVmaW5lZCwgJ1N3aXRjaCBzdGF0ZW1lbnQgbWlzc2luZyBcInRoZW5cIicpO1xuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICBpczogc2NoZW1hLiRfY29tcGlsZSh0ZXN0LmlzKSxcbiAgICAgICAgICAgIHRoZW46IHNjaGVtYS4kX2NvbXBpbGUodGVzdC50aGVuKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghUmVmLmlzUmVmKHRlc3QuaXMpICYmXG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKHRlc3QuaXMpKSB7XG5cbiAgICAgICAgICAgIGl0ZW0uaXMgPSBpdGVtLmlzLnJlcXVpcmVkKCk7ICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJlcXVpcmVkIGlmIHRoaXMgd2Fzbid0IGFscmVhZHkgYSBzY2hlbWEgb3IgYSByZWZcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5vdGhlcndpc2UgPT09IHVuZGVmaW5lZCB8fCB0ZXN0Lm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgXCJvdGhlcndpc2VcIiBpbnNpZGUgYW5kIG91dHNpZGUgYSBcInN3aXRjaFwiJyk7XG4gICAgICAgICAgICBjb25zdCBvdGhlcndpc2UgPSBvcHRpb25zLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5vdGhlcndpc2UgOiB0ZXN0Lm90aGVyd2lzZTtcbiAgICAgICAgICAgIGlmIChvdGhlcndpc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydChydWxlLmJyZWFrID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSBib3RoIG90aGVyd2lzZSBhbmQgYnJlYWsnKTtcbiAgICAgICAgICAgICAgICBpdGVtLm90aGVyd2lzZSA9IHNjaGVtYS4kX2NvbXBpbGUob3RoZXJ3aXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bGUuc3dpdGNoLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGU7XG59O1xuXG5cbmludGVybmFscy5jb25kaXRpb24gPSBmdW5jdGlvbiAoc2NoZW1hLCBjb25kaXRpb24pIHtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIFsndGhlbicsICdvdGhlcndpc2UnXSkge1xuICAgICAgICBpZiAoY29uZGl0aW9uW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmRpdGlvbltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uZGl0aW9uW2tleV0gPSBzY2hlbWEuJF9jb21waWxlKGNvbmRpdGlvbltrZXldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb25kaXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgYW5ub3RhdGlvbnM6IFN5bWJvbCgnYW5ub3RhdGlvbnMnKVxufTtcblxuXG5leHBvcnRzLlJlcG9ydCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgZmxhZ3MsIG1lc3NhZ2VzLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5wcmVmcyA9IHByZWZzO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gbnVsbDtcblxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWwgfHwge307XG4gICAgICAgIHRoaXMubG9jYWwubGFiZWwgPSBleHBvcnRzLmxhYmVsKHRoaXMuZmxhZ3MsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMsIHRoaXMubWVzc2FnZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0aGlzLmxvY2FsLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG5cbiAgICAgICAgICAgIHRoaXMubG9jYWwudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmtleSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZmxhZ3MubGFiZWwgJiZcbiAgICAgICAgICAgIHRoaXMucGF0aC5sZW5ndGggPT09IDApIHtcblxuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5fdGVtcGxhdGUodGhpcy50ZW1wbGF0ZSwgJ3Jvb3QnKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsLmxhYmVsID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmNvZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnByZWZzLmVycm9ycy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMuX3RlbXBsYXRlKHRoaXMudGVtcGxhdGUpIHx8XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSh0aGlzLnByZWZzLm1lc3NhZ2VzKSB8fFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUodGhpcy5tZXNzYWdlcyk7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgRXJyb3IgY29kZSBcIiR7Y29kZX1cIiBpcyBub3QgZGVmaW5lZCwgeW91ciBjdXN0b20gdHlwZSBpcyBtaXNzaW5nIHRoZSBjb3JyZWN0IG1lc3NhZ2VzIGRlZmluaXRpb25gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVuZGVyIGFuZCBjYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0ZW1wbGF0ZS5yZW5kZXIodGhpcy52YWx1ZSwgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcywgdGhpcy5sb2NhbCwgeyBlcnJvcnM6IHRoaXMucHJlZnMuZXJyb3JzLCBtZXNzYWdlczogW3RoaXMucHJlZnMubWVzc2FnZXMsIHRoaXMubWVzc2FnZXNdIH0pO1xuICAgICAgICBpZiAoIXRoaXMucHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UucmVwbGFjZSgvXlwiXCIgLywgJycpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgX3RlbXBsYXRlKG1lc3NhZ2VzLCBjb2RlKSB7XG5cbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudGVtcGxhdGUodGhpcy52YWx1ZSwgbWVzc2FnZXMsIGNvZGUgfHwgdGhpcy5jb2RlLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdvYmplY3QnKSB7ICAgICAgICAgIC8vIEV4Y2x1ZGUgYXJyYXkgc2luZ2xlIHBhdGggc2VnbWVudFxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSAnLic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsICs9IHNlZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYWJlbCArPSBgWyR7c2VnbWVudH1dYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcbn07XG5cblxuZXhwb3J0cy50ZW1wbGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZXMsIGNvZGUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIHJldHVybiBjb2RlICE9PSAncm9vdCcgPyBtZXNzYWdlcyA6IG51bGw7XG4gICAgfVxuXG4gICAgbGV0IGxhbmcgPSBwcmVmcy5lcnJvcnMubGFuZ3VhZ2U7XG4gICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUobGFuZykpIHtcbiAgICAgICAgbGFuZyA9IGxhbmcucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICBpZiAobGFuZyAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXSAmJlxuICAgICAgICBtZXNzYWdlc1tsYW5nXVtjb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzW2xhbmddW2NvZGVdO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlc1tjb2RlXTtcbn07XG5cblxuZXhwb3J0cy5sYWJlbCA9IGZ1bmN0aW9uIChmbGFncywgc3RhdGUsIHByZWZzLCBtZXNzYWdlcykge1xuXG4gICAgaWYgKGZsYWdzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBmbGFncy5sYWJlbDtcbiAgICB9XG5cbiAgICBpZiAoIXByZWZzLmVycm9ycy5sYWJlbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBzdGF0ZS5wYXRoO1xuICAgIGlmIChwcmVmcy5lcnJvcnMubGFiZWwgPT09ICdrZXknICYmXG4gICAgICAgIHN0YXRlLnBhdGgubGVuZ3RoID4gMSkge1xuXG4gICAgICAgIHBhdGggPSBzdGF0ZS5wYXRoLnNsaWNlKC0xKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5wYXRoKHBhdGgpIHx8XG4gICAgICAgIGV4cG9ydHMudGVtcGxhdGUobnVsbCwgcHJlZnMubWVzc2FnZXMsICdyb290Jywgc3RhdGUsIHByZWZzKSB8fFxuICAgICAgICBtZXNzYWdlcyAmJiBleHBvcnRzLnRlbXBsYXRlKG51bGwsIG1lc3NhZ2VzLCAncm9vdCcsIHN0YXRlLCBwcmVmcykgfHxcbiAgICAgICAgJ3ZhbHVlJztcbn07XG5cblxuZXhwb3J0cy5wcm9jZXNzID0gZnVuY3Rpb24gKGVycm9ycywgb3JpZ2luYWwsIHByZWZzKSB7XG5cbiAgICBpZiAoIWVycm9ycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB7IG92ZXJyaWRlLCBtZXNzYWdlLCBkZXRhaWxzIH0gPSBleHBvcnRzLmRldGFpbHMoZXJyb3JzKTtcbiAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5lcnJvcnMuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcbiAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgZGV0YWlscywgb3JpZ2luYWwpO1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIHJldHVybiB2YWxpZGF0aW9uRXJyb3I7XG59O1xuXG5cbmV4cG9ydHMuZGV0YWlscyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgbGV0IG1lc3NhZ2VzID0gW107XG4gICAgY29uc3QgZGV0YWlscyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGVycm9ycykge1xuXG4gICAgICAgIC8vIE92ZXJyaWRlXG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcnJpZGU6IGl0ZW0gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG5cbiAgICAgICAgICAgIGRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnb3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHsgZXJyb3I6IGl0ZW0gfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVwb3J0XG5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgICBkZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aC5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ICE9PSAnb2JqZWN0JyksXG4gICAgICAgICAgICB0eXBlOiBpdGVtLmNvZGUsXG4gICAgICAgICAgICBjb250ZXh0OiBpdGVtLmxvY2FsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIG1lc3NhZ2VzID0gWy4uLm5ldyBTZXQobWVzc2FnZXMpXTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlcy5qb2luKCcuICcpLCBkZXRhaWxzIH07XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCkge1xuXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbCA9IG9yaWdpbmFsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cblxuICAgIGFubm90YXRlKHN0cmlwQ29sb3JDb2Rlcykge1xuXG4gICAgICAgIGlmICghdGhpcy5fb3JpZ2luYWwgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLl9vcmlnaW5hbCAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGV0YWlsc1swXS5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVkRmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzMxbSc7XG4gICAgICAgIGNvbnN0IHJlZEJnRXNjYXBlID0gc3RyaXBDb2xvckNvZGVzID8gJycgOiAnXFx1MDAxYls0MW0nO1xuICAgICAgICBjb25zdCBlbmRDb2xvciA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMG0nO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IENsb25lKHRoaXMuX29yaWdpbmFsKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kZXRhaWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7ICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIHRvIHByb2Nlc3MgZGVlcGVzdCBjaGlsZCBmaXJzdFxuICAgICAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuZGV0YWlsc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBlcnJvci5wYXRoO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBvYmo7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWcgPSBwYXRoW2pdO1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jbG9uZSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGpvaSBzY2hlbWFzIGFyZSBub3QgY2xvbmVkIGJ5IGhvZWssIHdlIGhhdmUgdG8gdGFrZSB0aGlzIGV4dHJhIHN0ZXBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaiArIDEgPCBwYXRoLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygbm9kZVtzZWddICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlW3NlZ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZBbm5vdGF0aW9ucyA9IG5vZGVbaW50ZXJuYWxzLmFubm90YXRpb25zXSB8fCB7IGVycm9yczoge30sIG1pc3Npbmc6IHt9IH07XG4gICAgICAgICAgICAgICAgICAgIG5vZGVbaW50ZXJuYWxzLmFubm90YXRpb25zXSA9IHJlZkFubm90YXRpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2VnIHx8IGVycm9yLmNvbnRleHQua2V5O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlW3NlZ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSA9IHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLm1pc3NpbmdbY2FjaGVLZXldID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVwbGFjZXJzID0ge1xuICAgICAgICAgICAga2V5OiAvX1xcJGtleVxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIi9nLFxuICAgICAgICAgICAgbWlzc2luZzogL1wiX1xcJG1pc3NcXCRfKFtefF0rKVxcfChcXGQrKV9cXCRlbmRcXCRfXCI6IFwiX19taXNzaW5nX19cIi9nLFxuICAgICAgICAgICAgYXJyYXlJbmRleDogL1xccypcIl9cXCRpZHhcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIsP1xcbiguKikvZyxcbiAgICAgICAgICAgIHNwZWNpYWxzOiAvXCJcXFsoTmFOfFN5bWJvbC4qfC0/SW5maW5pdHl8ZnVuY3Rpb24uKnxcXCguKildXCIvZ1xuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBtZXNzYWdlID0gaW50ZXJuYWxzLnNhZmVTdHJpbmdpZnkob2JqLCAyKVxuICAgICAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLmtleSwgKCQwLCAkMSkgPT4gYFwiICR7cmVkRmdFc2NhcGV9WyR7JDF9XSR7ZW5kQ29sb3J9YClcbiAgICAgICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5taXNzaW5nLCAoJDAsICQxLCAkMikgPT4gYCR7cmVkQmdFc2NhcGV9XCIkeyQxfVwiJHtlbmRDb2xvcn0ke3JlZEZnRXNjYXBlfSBbJHskMn1dOiAtLSBtaXNzaW5nIC0tJHtlbmRDb2xvcn1gKVxuICAgICAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLmFycmF5SW5kZXgsICgkMCwgJDEsICQyKSA9PiBgXFxuJHskMn0gJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLnNwZWNpYWxzLCAoJDAsICQxKSA9PiAkMSk7XG5cbiAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuJHtyZWRGZ0VzY2FwZX1gO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZXRhaWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBpICsgMTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcblske3Bvc31dICR7dGhpcy5kZXRhaWxzW2ldLm1lc3NhZ2V9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgZW5kQ29sb3I7XG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLlZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUuaXNKb2kgPSB0cnVlO1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG5cblxuLy8gSW5zcGlyZWQgYnkganNvbi1zdHJpbmdpZnktc2FmZVxuXG5pbnRlcm5hbHMuc2FmZVN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmosIHNwYWNlcykge1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgaW50ZXJuYWxzLnNlcmlhbGl6ZXIoKSwgc3BhY2VzKTtcbn07XG5cblxuaW50ZXJuYWxzLnNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICAgIGNvbnN0IGN5Y2xlUmVwbGFjZXIgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuXG4gICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH5dJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH4uJyArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oJy4nKSArICddJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKH50aGlzUG9zKSB7XG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzW3RoaXNQb3NdID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3ljbGVSZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gdmFsdWVbaW50ZXJuYWxzLmFubm90YXRpb25zXTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0ZWQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuZXJyb3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2goYF8kaWR4JF8ke2Fubm90YXRpb25zLmVycm9yc1tpXS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYW5ub3RhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlcnJvcktleSBpbiBhbm5vdGF0aW9ucy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2Ake2Vycm9yS2V5fV8ka2V5JF8ke2Fubm90YXRpb25zLmVycm9yc1tlcnJvcktleV0uc29ydCgpLmpvaW4oJywgJyl9XyRlbmQkX2BdID0gdmFsdWVbZXJyb3JLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbZXJyb3JLZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtaXNzaW5nS2V5IGluIGFubm90YXRpb25zLm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2BfJG1pc3MkXyR7bWlzc2luZ0tleX18JHthbm5vdGF0aW9ucy5taXNzaW5nW21pc3NpbmdLZXldfV8kZW5kJF9gXSA9ICdfX21pc3NpbmdfXyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gLUluZmluaXR5IHx8XG4gICAgICAgICAgICBOdW1iZXIuaXNOYU4odmFsdWUpIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgcmV0dXJuICdbJyArIHZhbHVlLnRvU3RyaW5nKCkgKyAnXSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKGZyb20sIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGJhc2UgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJvbSk7XG4gICAgY29uc3QgcHJvdG90eXBlID0gQ2xvbmUoYmFzZSk7XG4gICAgY29uc3Qgc2NoZW1hID0gZnJvbS5fYXNzaWduKE9iamVjdC5jcmVhdGUocHJvdG90eXBlKSk7XG4gICAgY29uc3QgZGVmID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICBkZWxldGUgZGVmLmJhc2U7XG5cbiAgICBwcm90b3R5cGUuX2RlZmluaXRpb24gPSBkZWY7XG5cbiAgICBjb25zdCBwYXJlbnQgPSBiYXNlLl9kZWZpbml0aW9uIHx8IHt9O1xuICAgIGRlZi5tZXNzYWdlcyA9IE1lc3NhZ2VzLm1lcmdlKHBhcmVudC5tZXNzYWdlcywgZGVmLm1lc3NhZ2VzKTtcbiAgICBkZWYucHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5wcm9wZXJ0aWVzLCBkZWYucHJvcGVydGllcyk7XG5cbiAgICAvLyBUeXBlXG5cbiAgICBzY2hlbWEudHlwZSA9IGRlZi50eXBlO1xuXG4gICAgLy8gRmxhZ3NcblxuICAgIGRlZi5mbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5mbGFncywgZGVmLmZsYWdzKTtcblxuICAgIC8vIFRlcm1zXG5cbiAgICBjb25zdCB0ZXJtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC50ZXJtcyk7XG4gICAgaWYgKGRlZi50ZXJtcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLnRlcm1zKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgb3duIHRlcm1zXG4gICAgICAgICAgICBjb25zdCB0ZXJtID0gZGVmLnRlcm1zW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYS4kX3Rlcm1zW25hbWVdID09PSB1bmRlZmluZWQsICdJbnZhbGlkIHRlcm0gb3ZlcnJpZGUgZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgc2NoZW1hLiRfdGVybXNbbmFtZV0gPSB0ZXJtLmluaXQ7XG4gICAgICAgICAgICB0ZXJtc1tuYW1lXSA9IHRlcm07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYudGVybXMgPSB0ZXJtcztcblxuICAgIC8vIENvbnN0cnVjdG9yIGFyZ3VtZW50c1xuXG4gICAgaWYgKCFkZWYuYXJncykge1xuICAgICAgICBkZWYuYXJncyA9IHBhcmVudC5hcmdzO1xuICAgIH1cblxuICAgIC8vIFByZXBhcmVcblxuICAgIGRlZi5wcmVwYXJlID0gaW50ZXJuYWxzLnByZXBhcmUoZGVmLnByZXBhcmUsIHBhcmVudC5wcmVwYXJlKTtcblxuICAgIC8vIENvZXJjZVxuXG4gICAgaWYgKGRlZi5jb2VyY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWYuY29lcmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWYuY29lcmNlID0geyBtZXRob2Q6IGRlZi5jb2VyY2UgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWYuY29lcmNlLmZyb20gJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KGRlZi5jb2VyY2UuZnJvbSkpIHtcblxuICAgICAgICAgICAgZGVmLmNvZXJjZSA9IHsgbWV0aG9kOiBkZWYuY29lcmNlLm1ldGhvZCwgZnJvbTogW10uY29uY2F0KGRlZi5jb2VyY2UuZnJvbSkgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5jb2VyY2UgPSBpbnRlcm5hbHMuY29lcmNlKGRlZi5jb2VyY2UsIHBhcmVudC5jb2VyY2UpO1xuXG4gICAgLy8gVmFsaWRhdGVcblxuICAgIGRlZi52YWxpZGF0ZSA9IGludGVybmFscy52YWxpZGF0ZShkZWYudmFsaWRhdGUsIHBhcmVudC52YWxpZGF0ZSk7XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgY29uc3QgcnVsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQucnVsZXMpO1xuICAgIGlmIChkZWYucnVsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi5ydWxlcykge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IGRlZi5ydWxlc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgcnVsZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJ1bGUgZGVmaW5pdGlvbiBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGxldCBtZXRob2QgPSBydWxlLm1ldGhvZDtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUobmFtZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydCghcHJvdG90eXBlW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBwcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCghcnVsZXNbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgcnVsZXNbbmFtZV0gPSBydWxlO1xuXG4gICAgICAgICAgICBpZiAocnVsZS5hbGlhcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzZXMgPSBbXS5jb25jYXQocnVsZS5hbGlhcyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvdHlwZVthbGlhc10gPSBydWxlLm1ldGhvZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBydWxlLmFyZ3NCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgcnVsZS5hcmdzID0gcnVsZS5hcmdzLm1hcCgoYXJnKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB7IG5hbWU6IGFyZyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFydWxlLmFyZ3NCeU5hbWUuaGFzKGFyZy5uYW1lKSwgJ0R1cGxpY2F0ZWQgYXJndW1lbnQgbmFtZScsIGFyZy5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGFyZy5hc3NlcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcuYXNzZXJ0ID0gYXJnLmFzc2VydC5zdHJpY3QoKS5sYWJlbChhcmcubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBydWxlLmFyZ3NCeU5hbWUuc2V0KGFyZy5uYW1lLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLnJ1bGVzID0gcnVsZXM7XG5cbiAgICAvLyBNb2RpZmllcnNcblxuICAgIGNvbnN0IG1vZGlmaWVycyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5tb2RpZmllcnMpO1xuICAgIGlmIChkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXByb3RvdHlwZVtuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVyID0gZGVmLm1vZGlmaWVyc1tuYW1lXTtcbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbW9kaWZpZXIgPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIG1vZGlmaWVyIGRlZmluaXRpb24gZm9yJywgZGVmLnR5cGUsIG5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSBmdW5jdGlvbiAoYXJnKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydWxlKHsgW25hbWVdOiBhcmcgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBwcm90b3R5cGVbbmFtZV0gPSBtZXRob2Q7XG4gICAgICAgICAgICBtb2RpZmllcnNbbmFtZV0gPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG5cbiAgICAvLyBPdmVycmlkZXNcblxuICAgIGlmIChkZWYub3ZlcnJpZGVzKSB7XG4gICAgICAgIHByb3RvdHlwZS5fc3VwZXIgPSBiYXNlO1xuICAgICAgICBzY2hlbWEuJF9zdXBlciA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG92ZXJyaWRlIGluIGRlZi5vdmVycmlkZXMpIHtcbiAgICAgICAgICAgIEFzc2VydChiYXNlW292ZXJyaWRlXSwgJ0Nhbm5vdCBvdmVycmlkZSBtaXNzaW5nJywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgc2NoZW1hLiRfc3VwZXJbb3ZlcnJpZGVdID0gYmFzZVtvdmVycmlkZV0uYmluZChzY2hlbWEpO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm90b3R5cGUsIGRlZi5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIC8vIENhc3RzXG5cbiAgICBkZWYuY2FzdCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5jYXN0LCBkZWYuY2FzdCk7XG5cbiAgICAvLyBNYW5pZmVzdFxuXG4gICAgY29uc3QgbWFuaWZlc3QgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQubWFuaWZlc3QsIGRlZi5tYW5pZmVzdCk7XG4gICAgbWFuaWZlc3QuYnVpbGQgPSBpbnRlcm5hbHMuYnVpbGQoZGVmLm1hbmlmZXN0ICYmIGRlZi5tYW5pZmVzdC5idWlsZCwgcGFyZW50Lm1hbmlmZXN0ICYmIHBhcmVudC5tYW5pZmVzdC5idWlsZCk7XG4gICAgZGVmLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG5cbiAgICAvLyBSZWJ1aWxkXG5cbiAgICBkZWYucmVidWlsZCA9IGludGVybmFscy5yZWJ1aWxkKGRlZi5yZWJ1aWxkLCBwYXJlbnQucmVidWlsZCk7XG5cbiAgICByZXR1cm4gc2NoZW1hO1xufTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5idWlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudChjaGlsZChvYmosIGRlc2MpLCBkZXNjKTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuY29lcmNlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogY2hpbGQuZnJvbSAmJiBwYXJlbnQuZnJvbSA/IFsuLi5uZXcgU2V0KFsuLi5jaGlsZC5mcm9tLCAuLi5wYXJlbnQuZnJvbV0pXSA6IG51bGwsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICBsZXQgY29lcmNlZDtcbiAgICAgICAgICAgIGlmICghcGFyZW50LmZyb20gfHxcbiAgICAgICAgICAgICAgICBwYXJlbnQuZnJvbS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICBjb2VyY2VkID0gcGFyZW50Lm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvZXJjZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2VyY2VkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvZXJjZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoaWxkLmZyb20gfHxcbiAgICAgICAgICAgICAgICBjaGlsZC5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG93biA9IGNoaWxkLm1ldGhvZCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICAgICAgaWYgKG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3duO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvZXJjZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucHJlcGFyZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCBwcmVwYXJlZCA9IGNoaWxkKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKHByZXBhcmVkKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWQuZXJyb3JzIHx8XG4gICAgICAgICAgICAgICAgcHJlcGFyZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHByZXBhcmVkLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudCh2YWx1ZSwgaGVscGVycykgfHwgcHJlcGFyZWQ7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnJlYnVpbGQgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgICAgIHBhcmVudChzY2hlbWEpO1xuICAgICAgICBjaGlsZChzY2hlbWEpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJlbnQodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycyAmJlxuICAgICAgICAgICAgICAgICghQXJyYXkuaXNBcnJheShyZXN1bHQuZXJyb3JzKSB8fCByZXN1bHQuZXJyb3JzLmxlbmd0aCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkKHZhbHVlLCBoZWxwZXJzKSB8fCByZXN1bHQ7XG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDYWNoZSA9IHJlcXVpcmUoJy4vY2FjaGUnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbmNvbnN0IE1hbmlmZXN0ID0gcmVxdWlyZSgnLi9tYW5pZmVzdCcpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5cbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB0eXBlczoge1xuICAgICAgICBhbHRlcm5hdGl2ZXM6IHJlcXVpcmUoJy4vdHlwZXMvYWx0ZXJuYXRpdmVzJyksXG4gICAgICAgIGFueTogcmVxdWlyZSgnLi90eXBlcy9hbnknKSxcbiAgICAgICAgYXJyYXk6IHJlcXVpcmUoJy4vdHlwZXMvYXJyYXknKSxcbiAgICAgICAgYm9vbGVhbjogcmVxdWlyZSgnLi90eXBlcy9ib29sZWFuJyksXG4gICAgICAgIGRhdGU6IHJlcXVpcmUoJy4vdHlwZXMvZGF0ZScpLFxuICAgICAgICBmdW5jdGlvbjogcmVxdWlyZSgnLi90eXBlcy9mdW5jdGlvbicpLFxuICAgICAgICBsaW5rOiByZXF1aXJlKCcuL3R5cGVzL2xpbmsnKSxcbiAgICAgICAgbnVtYmVyOiByZXF1aXJlKCcuL3R5cGVzL251bWJlcicpLFxuICAgICAgICBvYmplY3Q6IHJlcXVpcmUoJy4vdHlwZXMvb2JqZWN0JyksXG4gICAgICAgIHN0cmluZzogcmVxdWlyZSgnLi90eXBlcy9zdHJpbmcnKSxcbiAgICAgICAgc3ltYm9sOiByZXF1aXJlKCcuL3R5cGVzL3N5bWJvbCcpXG4gICAgfVxufTtcblxuXG5pZiAoQnVmZmVyKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICBpbnRlcm5hbHMudHlwZXMuYmluYXJ5ID0gcmVxdWlyZSgnLi90eXBlcy9iaW5hcnknKTtcbn1cblxuXG5pbnRlcm5hbHMucm9vdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IHJvb3QgPSB7XG4gICAgICAgIF90eXBlczogbmV3IFNldChPYmplY3Qua2V5cyhpbnRlcm5hbHMudHlwZXMpKVxuICAgIH07XG5cbiAgICAvLyBUeXBlc1xuXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHJvb3QuX3R5cGVzKSB7XG4gICAgICAgIHJvb3RbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICBBc3NlcnQoIWFyZ3MubGVuZ3RoIHx8IFsnYWx0ZXJuYXRpdmVzJywgJ2xpbmsnLCAnb2JqZWN0J10uaW5jbHVkZXModHlwZSksICdUaGUnLCB0eXBlLCAndHlwZSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgaW50ZXJuYWxzLnR5cGVzW3R5cGVdLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dHNcblxuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIFsnYWxsb3cnLCAnY3VzdG9tJywgJ2Rpc2FsbG93JywgJ2VxdWFsJywgJ2V4aXN0JywgJ2ZvcmJpZGRlbicsICdpbnZhbGlkJywgJ25vdCcsICdvbmx5JywgJ29wdGlvbmFsJywgJ29wdGlvbnMnLCAncHJlZnMnLCAncHJlZmVyZW5jZXMnLCAncmVxdWlyZWQnLCAnc3RyaXAnLCAndmFsaWQnLCAnd2hlbiddKSB7XG4gICAgICAgIHJvb3RbbWV0aG9kXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFueSgpW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kc1xuXG4gICAgT2JqZWN0LmFzc2lnbihyb290LCBpbnRlcm5hbHMubWV0aG9kcyk7XG5cbiAgICAvLyBBbGlhc2VzXG5cbiAgICByb290LmFsdCA9IHJvb3QuYWx0ZXJuYXRpdmVzO1xuICAgIHJvb3QuYm9vbCA9IHJvb3QuYm9vbGVhbjtcbiAgICByb290LmZ1bmMgPSByb290LmZ1bmN0aW9uO1xuICAgIHJvb3QueCA9IHJvb3QuZXhwcmVzc2lvbjtcblxuICAgIC8vIFRyYWNlXG5cbiAgICBpZiAoVHJhY2Uuc2V0dXApIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgVHJhY2Uuc2V0dXAocm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5cbmludGVybmFscy5tZXRob2RzID0ge1xuXG4gICAgVmFsaWRhdGlvbkVycm9yOiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yLFxuICAgIHZlcnNpb246IENvbW1vbi52ZXJzaW9uLFxuICAgIGNhY2hlOiBDYWNoZS5wcm92aWRlcixcblxuICAgIGFzc2VydCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCB0cnVlLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgYXR0ZW1wdCh2YWx1ZSwgc2NoZW1hLCAuLi5hcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hc3NlcnQodmFsdWUsIHNjaGVtYSwgZmFsc2UsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBidWlsZChkZXNjKSB7XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBNYW5pZmVzdC5idWlsZCA9PT0gJ2Z1bmN0aW9uJywgJ01hbmlmZXN0IGZ1bmN0aW9uYWxpdHkgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE1hbmlmZXN0LmJ1aWxkKHRoaXMsIGRlc2MpO1xuICAgIH0sXG5cbiAgICBjaGVja1ByZWZlcmVuY2VzKHByZWZzKSB7XG5cbiAgICAgICAgQ29tbW9uLmNoZWNrUHJlZmVyZW5jZXMocHJlZnMpO1xuICAgIH0sXG5cbiAgICBjb21waWxlKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBDb21waWxlLmNvbXBpbGUodGhpcywgc2NoZW1hLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZGVmYXVsdHMobW9kaWZpZXIpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1vZGlmaWVyID09PSAnZnVuY3Rpb24nLCAnbW9kaWZpZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgY29uc3Qgam9pID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBqb2kuX3R5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBtb2RpZmllcihqb2lbdHlwZV0oKSk7XG4gICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSksICdtb2RpZmllciBtdXN0IHJldHVybiBhIHZhbGlkIHNjaGVtYSBvYmplY3QnKTtcblxuICAgICAgICAgICAgam9pW3R5cGVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUodGhpcywgc2NoZW1hLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH0sXG5cbiAgICBleHByZXNzaW9uKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBleHRlbmQoLi4uZXh0ZW5zaW9ucykge1xuXG4gICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KGV4dGVuc2lvbnMsICdleHRlbmQnKTtcblxuICAgICAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgICAgICBBc3NlcnQoZXh0ZW5zaW9ucy5sZW5ndGgsICdZb3UgbmVlZCB0byBwcm92aWRlIGF0IGxlYXN0IG9uZSBleHRlbnNpb24nKTtcbiAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9ucywgU2NoZW1hcy5leHRlbnNpb25zKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgam9pLl90eXBlcyA9IG5ldyBTZXQoam9pLl90eXBlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgZXh0ZW5zaW9uIG9mIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uKGpvaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0KGV4dGVuc2lvbiwgU2NoZW1hcy5leHRlbnNpb24pO1xuXG4gICAgICAgICAgICBBc3NlcnQoam9pW2V4dGVuc2lvbi50eXBlXSA9PT0gdW5kZWZpbmVkIHx8IGpvaS5fdHlwZXMuaGFzKGV4dGVuc2lvbi50eXBlKSwgJ0Nhbm5vdCBvdmVycmlkZSBuYW1lJywgZXh0ZW5zaW9uLnR5cGUpO1xuXG4gICAgICAgICAgICBjb25zdCBiYXNlID0gZXh0ZW5zaW9uLmJhc2UgfHwgdGhpcy5hbnkoKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IEV4dGVuZC50eXBlKGJhc2UsIGV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgIGpvaS5fdHlwZXMuYWRkKGV4dGVuc2lvbi50eXBlKTtcbiAgICAgICAgICAgIGpvaVtleHRlbnNpb24udHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfSxcblxuICAgIGlzRXhwcmVzc2lvbjogVGVtcGxhdGUuaXNUZW1wbGF0ZSxcbiAgICBpc1JlZjogUmVmLmlzUmVmLFxuICAgIGlzU2NoZW1hOiBDb21tb24uaXNTY2hlbWEsXG5cbiAgICBpbiguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIFJlZi5pbiguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgb3ZlcnJpZGU6IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlLFxuXG4gICAgcmVmKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmNyZWF0ZSguLi5hcmdzKTtcbiAgICB9LFxuXG4gICAgdHlwZXMoKSB7XG5cbiAgICAgICAgY29uc3QgdHlwZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMuX3R5cGVzKSB7XG4gICAgICAgICAgICB0eXBlc1t0eXBlXSA9IHRoaXNbdHlwZV0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmFzc2VydCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBhbm5vdGF0ZSwgYXJncyAvKiBbbWVzc2FnZV0sIFtvcHRpb25zXSAqLykge1xuXG4gICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgPyBhcmdzWzBdIDogbnVsbDtcbiAgICBjb25zdCBvcHRpb25zID0gbWVzc2FnZSA/IGFyZ3NbMV0gOiBhcmdzWzBdO1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSwgQ29tbW9uLnByZWZlcmVuY2VzKHsgZXJyb3JzOiB7IHN0YWNrOiB0cnVlIH0gfSwgb3B0aW9ucyB8fCB7fSkpO1xuXG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgYW5ub3RhdGUgPSBhbm5vdGF0ZSAmJiB0eXBlb2YgZXJyb3IuYW5ub3RhdGUgPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3QgZGlzcGxheSA9IGFubm90YXRlID8gZXJyb3IuYW5ub3RhdGUoKSA6IGVycm9yLm1lc3NhZ2U7XG5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuVmFsaWRhdGlvbkVycm9yID09PSBmYWxzZSkge1xuICAgICAgICBlcnJvciA9IENsb25lKGVycm9yKTtcbiAgICB9XG5cbiAgICBlcnJvci5tZXNzYWdlID0gbWVzc2FnZSA/IGAke21lc3NhZ2V9ICR7ZGlzcGxheX1gIDogZGlzcGxheTtcbiAgICB0aHJvdyBlcnJvcjtcbn07XG5cblxuaW50ZXJuYWxzLmdlbmVyYXRlID0gZnVuY3Rpb24gKHJvb3QsIHNjaGVtYSwgYXJncykge1xuXG4gICAgQXNzZXJ0KHJvb3QsICdNdXN0IGJlIGludm9rZWQgb24gYSBKb2kgaW5zdGFuY2UuJyk7XG5cbiAgICBzY2hlbWEuJF9yb290ID0gcm9vdDtcblxuICAgIGlmICghc2NoZW1hLl9kZWZpbml0aW9uLmFyZ3MgfHxcbiAgICAgICAgIWFyZ3MubGVuZ3RoKSB7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NoZW1hLl9kZWZpbml0aW9uLmFyZ3Moc2NoZW1hLCAuLi5hcmdzKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMucm9vdCgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IE1lc3NhZ2VzID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG5sZXQgU2NoZW1hcztcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmRlc2NyaWJlID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuXG4gICAgLy8gVHlwZVxuXG4gICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAgdHlwZTogc2NoZW1hLnR5cGUsXG4gICAgICAgIGZsYWdzOiB7fSxcbiAgICAgICAgcnVsZXM6IFtdXG4gICAgfTtcblxuICAgIC8vIEZsYWdzXG5cbiAgICBmb3IgKGNvbnN0IGZsYWcgaW4gc2NoZW1hLl9mbGFncykge1xuICAgICAgICBpZiAoZmxhZ1swXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICBkZXNjLmZsYWdzW2ZsYWddID0gaW50ZXJuYWxzLmRlc2NyaWJlKHNjaGVtYS5fZmxhZ3NbZmxhZ10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFPYmplY3Qua2V5cyhkZXNjLmZsYWdzKS5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGRlc2MuZmxhZ3M7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyZW5jZXNcblxuICAgIGlmIChzY2hlbWEuX3ByZWZlcmVuY2VzKSB7XG4gICAgICAgIGRlc2MucHJlZmVyZW5jZXMgPSBDbG9uZShzY2hlbWEuX3ByZWZlcmVuY2VzLCB7IHNoYWxsb3c6IFsnbWVzc2FnZXMnXSB9KTtcbiAgICAgICAgZGVsZXRlIGRlc2MucHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdO1xuICAgICAgICBpZiAoZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcykge1xuICAgICAgICAgICAgZGVzYy5wcmVmZXJlbmNlcy5tZXNzYWdlcyA9IE1lc3NhZ2VzLmRlY29tcGlsZShkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsbG93IC8gSW52YWxpZFxuXG4gICAgaWYgKHNjaGVtYS5fdmFsaWRzKSB7XG4gICAgICAgIGRlc2MuYWxsb3cgPSBzY2hlbWEuX3ZhbGlkcy5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIGlmIChzY2hlbWEuX2ludmFsaWRzKSB7XG4gICAgICAgIGRlc2MuaW52YWxpZCA9IHNjaGVtYS5faW52YWxpZHMuZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvLyBSdWxlc1xuXG4gICAgZm9yIChjb25zdCBydWxlIG9mIHNjaGVtYS5fcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZURlZiA9IGRlZi5ydWxlc1tydWxlLm5hbWVdO1xuICAgICAgICBpZiAocnVsZURlZi5tYW5pZmVzdCA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7IG5hbWU6IHJ1bGUubmFtZSB9O1xuXG4gICAgICAgIGZvciAoY29uc3QgY3VzdG9tIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIGlmIChydWxlW2N1c3RvbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1bY3VzdG9tXSA9IGludGVybmFscy5kZXNjcmliZShydWxlW2N1c3RvbV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgaXRlbS5hcmdzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSBydWxlLmFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnb3B0aW9ucycgJiZcbiAgICAgICAgICAgICAgICAgICAgIU9iamVjdC5rZXlzKGFyZykubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaXRlbS5hcmdzW2tleV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUoYXJnLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGl0ZW0uYXJncykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0ZW0uYXJncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2MucnVsZXMucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2MucnVsZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGV0ZSBkZXNjLnJ1bGVzO1xuICAgIH1cblxuICAgIC8vIFRlcm1zIChtdXN0IGJlIGxhc3QgdG8gdmVyaWZ5IG5vIG5hbWUgY29uZmxpY3RzKVxuXG4gICAgZm9yIChjb25zdCB0ZXJtIGluIHNjaGVtYS4kX3Rlcm1zKSB7XG4gICAgICAgIGlmICh0ZXJtWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KCFkZXNjW3Rlcm1dLCAnQ2Fubm90IGRlc2NyaWJlIHNjaGVtYSBkdWUgdG8gaW50ZXJuYWwgbmFtZSBjb25mbGljdCB3aXRoJywgdGVybSk7XG5cbiAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuJF90ZXJtc1t0ZXJtXTtcbiAgICAgICAgaWYgKCFpdGVtcykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmIChpdGVtcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IFsuLi5pdGVtcy5lbnRyaWVzKCldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChDb21tb24uaXNWYWx1ZXMoaXRlbXMpKSB7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0gaXRlbXMuZGVzY3JpYmUoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KGRlZi50ZXJtc1t0ZXJtXSwgJ1Rlcm0nLCB0ZXJtLCAnbWlzc2luZyBjb25maWd1cmF0aW9uJyk7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gZGVmLnRlcm1zW3Rlcm1dLm1hbmlmZXN0O1xuICAgICAgICBjb25zdCBtYXBwZWQgPSB0eXBlb2YgbWFuaWZlc3QgPT09ICdvYmplY3QnO1xuICAgICAgICBpZiAoIWl0ZW1zLmxlbmd0aCAmJlxuICAgICAgICAgICAgIW1hcHBlZCkge1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaW50ZXJuYWxzLmRlc2NyaWJlKGl0ZW0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hcHBlZFxuXG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IG1hbmlmZXN0Lm1hcHBlZDtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgZGVzY1t0ZXJtXVtpdGVtW3RvXV0gPSBpdGVtW2Zyb21dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZVxuXG4gICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIEFzc2VydChub3JtYWxpemVkLmxlbmd0aCA9PT0gMSwgJ1Rlcm0nLCB0ZXJtLCAnY29udGFpbnMgbW9yZSB0aGFuIG9uZSBpdGVtJyk7XG4gICAgICAgICAgICBkZXNjW3Rlcm1dID0gbm9ybWFsaXplZFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXlcblxuICAgICAgICBkZXNjW3Rlcm1dID0gbm9ybWFsaXplZDtcbiAgICB9XG5cbiAgICBpbnRlcm5hbHMudmFsaWRhdGUoc2NoZW1hLiRfcm9vdCwgZGVzYyk7XG4gICAgcmV0dXJuIGRlc2M7XG59O1xuXG5cbmludGVybmFscy5kZXNjcmliZSA9IGZ1bmN0aW9uIChpdGVtLCBvcHRpb25zID0ge30pIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBpdGVtLm1hcChpbnRlcm5hbHMuZGVzY3JpYmUpO1xuICAgIH1cblxuICAgIGlmIChpdGVtID09PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4geyBzcGVjaWFsOiAnZGVlcCcgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIHJldHVybiBDbG9uZShpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgIHJldHVybiB7IGJ1ZmZlcjogaXRlbS50b1N0cmluZygnYmluYXJ5JykgfTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9JU09TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZ2V4Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZ2V4OiBpdGVtLnRvU3RyaW5nKCkgfTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbVtDb21tb24uc3ltYm9scy5saXRlcmFsXSkge1xuICAgICAgICByZXR1cm4geyBmdW5jdGlvbjogaXRlbS5saXRlcmFsIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVtLmRlc2NyaWJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ3JlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmRlc2NyaWJlKCkucmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZW0uZGVzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaXRlbSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW1ba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaW50ZXJuYWxzLmRlc2NyaWJlKHZhbHVlLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgIH1cblxuICAgIHJldHVybiBub3JtYWxpemVkO1xufTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGpvaSwgZGVzYykge1xuXG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBpbnRlcm5hbHMuQnVpbGRlcihqb2kpO1xuICAgIHJldHVybiBidWlsZGVyLnBhcnNlKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuQnVpbGRlciA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGpvaSkge1xuXG4gICAgICAgIHRoaXMuam9pID0gam9pO1xuICAgIH1cblxuICAgIHBhcnNlKGRlc2MpIHtcblxuICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGUodGhpcy5qb2ksIGRlc2MpO1xuXG4gICAgICAgIC8vIFR5cGVcblxuICAgICAgICBsZXQgc2NoZW1hID0gdGhpcy5qb2lbZGVzYy50eXBlXSgpO1xuICAgICAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG5cbiAgICAgICAgLy8gRmxhZ3NcblxuICAgICAgICBpZiAoZGVzYy5mbGFncykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmbGFnIGluIGRlc2MuZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0ZXIgPSBkZWYuZmxhZ3NbZmxhZ10gJiYgZGVmLmZsYWdzW2ZsYWddLnNldHRlciB8fCBmbGFnO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygc2NoZW1hW3NldHRlcl0gPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIGZsYWcnLCBmbGFnLCAnZm9yIHR5cGUnLCBkZXNjLnR5cGUpO1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVtzZXR0ZXJdKHRoaXMuYnVpbGQoZGVzYy5mbGFnc1tmbGFnXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlZmVyZW5jZXNcblxuICAgICAgICBpZiAoZGVzYy5wcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnByZWZlcmVuY2VzKHRoaXMuYnVpbGQoZGVzYy5wcmVmZXJlbmNlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxsb3cgLyBJbnZhbGlkXG5cbiAgICAgICAgaWYgKGRlc2MuYWxsb3cpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5hbGxvdyguLi50aGlzLmJ1aWxkKGRlc2MuYWxsb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLmludmFsaWQpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5pbnZhbGlkKC4uLnRoaXMuYnVpbGQoZGVzYy5pbnZhbGlkKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdWxlc1xuXG4gICAgICAgIGlmIChkZXNjLnJ1bGVzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZGVzYy5ydWxlcykge1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygc2NoZW1hW3J1bGUubmFtZV0gPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIHJ1bGUnLCBydWxlLm5hbWUsICdmb3IgdHlwZScsIGRlc2MudHlwZSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWlsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWx0W2tleV0gPSB0aGlzLmJ1aWxkKHJ1bGUuYXJnc1trZXldLCB7IGFzc2lnbjoga2V5IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGJ1aWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGRlZi5ydWxlc1tydWxlLm5hbWVdLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5cy5sZW5ndGggPD0gZGVmaW5pdGlvbi5sZW5ndGgsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yJywgZGVzYy50eXBlLCBydWxlLm5hbWUsICcoZXhwZWN0ZWQgdXAgdG8nLCBkZWZpbml0aW9uLmxlbmd0aCwgJywgZm91bmQnLCBrZXlzLmxlbmd0aCwgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBuYW1lIH0gb2YgZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChidWlsdFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5cy5sZW5ndGggPT09IDEsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yJywgZGVzYy50eXBlLCBydWxlLm5hbWUsICcoZXhwZWN0ZWQgdXAgdG8gMSwgZm91bmQnLCBrZXlzLmxlbmd0aCwgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChidWlsdFtrZXlzWzBdXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseVxuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hW3J1bGUubmFtZV0oLi4uYXJncyk7XG5cbiAgICAgICAgICAgICAgICAvLyBSdWxlc2V0XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjdXN0b20gaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVsZVtjdXN0b21dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbY3VzdG9tXSA9IHRoaXMuYnVpbGQocnVsZVtjdXN0b21dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLnJ1bGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVybXNcblxuICAgICAgICBjb25zdCB0ZXJtcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICBpZiAoWydhbGxvdycsICdmbGFncycsICdpbnZhbGlkJywgJ3doZW5zJywgJ3ByZWZlcmVuY2VzJywgJ3J1bGVzJywgJ3R5cGUnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydChkZWYudGVybXNba2V5XSwgJ1Rlcm0nLCBrZXksICdtaXNzaW5nIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gZGVmLnRlcm1zW2tleV0ubWFuaWZlc3Q7XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NjaGVtYScpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gZGVzY1trZXldLm1hcCgoaXRlbSkgPT4gdGhpcy5wYXJzZShpdGVtKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3ZhbHVlcycpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gZGVzY1trZXldLm1hcCgoaXRlbSkgPT4gdGhpcy5idWlsZChpdGVtKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYW5pZmVzdCA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICB0ZXJtc1trZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1hbmlmZXN0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVzY1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZGVzY1trZXldW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB0ZXJtc1trZXldW25hbWVdID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRlcm1zW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy53aGVucykge1xuICAgICAgICAgICAgdGVybXMud2hlbnMgPSBkZXNjLndoZW5zLm1hcCgod2hlbikgPT4gdGhpcy5idWlsZCh3aGVuKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlbWEgPSBkZWYubWFuaWZlc3QuYnVpbGQoc2NoZW1hLCB0ZXJtcyk7XG4gICAgICAgIHNjaGVtYS4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIGJ1aWxkKGRlc2MsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmIChkZXNjID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlc2MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYy5tYXAoKGl0ZW0pID0+IHRoaXMuYnVpbGQoaXRlbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdvcHRpb25zJykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVnZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnJlZ2V4KGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVmJykge1xuICAgICAgICAgICAgcmV0dXJuIFJlZi5idWlsZChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgZGVzYyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlc2MpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKGRlc2MuYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KEJ1ZmZlciwgJ0J1ZmZlcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyICYmIEJ1ZmZlci5mcm9tKGRlc2MuYnVmZmVyLCAnYmluYXJ5Jyk7ICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF06IHRydWUsIGxpdGVyYWw6IGRlc2MuZnVuY3Rpb24gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2Mub3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWYuYnVpbGQoZGVzYy5yZWYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZWdleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVnZXgoZGVzYy5yZWdleCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnNwZWNpYWwpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoWydkZWVwJ10uaW5jbHVkZXMoZGVzYy5zcGVjaWFsKSwgJ1Vua25vd24gc3BlY2lhbCB2YWx1ZScsIGRlc2Muc3BlY2lhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDbG9uZShkZXNjLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZS5idWlsZChkZXNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0gdGhpcy5idWlsZChkZXNjW2tleV0sIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5yZWdleCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIGNvbnN0IGVuZCA9IHN0cmluZy5sYXN0SW5kZXhPZignLycpO1xuICAgIGNvbnN0IGV4cCA9IHN0cmluZy5zbGljZSgxLCBlbmQpO1xuICAgIGNvbnN0IGZsYWdzID0gc3RyaW5nLnNsaWNlKGVuZCArIDEpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGV4cCwgZmxhZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoam9pLCBkZXNjKSB7XG5cbiAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgIGpvaS5hc3NlcnQoZGVzYywgU2NoZW1hcy5kZXNjcmlwdGlvbik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKG1lc3NhZ2VzLCB0YXJnZXQpIHtcblxuICAgIC8vIFNpbmdsZSB2YWx1ZSBzdHJpbmcgKCdwbGFpbiBlcnJvciBtZXNzYWdlJywgJ3RlbXBsYXRlIHtlcnJvcn0gbWVzc2FnZScpXG5cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VzID09PSAnc3RyaW5nJykge1xuICAgICAgICBBc3NlcnQoIXRhcmdldCwgJ0Nhbm5vdCBzZXQgc2luZ2xlIG1lc3NhZ2Ugc3RyaW5nJyk7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUobWVzc2FnZXMpO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSB0ZW1wbGF0ZVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZXMpKSB7XG4gICAgICAgIEFzc2VydCghdGFyZ2V0LCAnQ2Fubm90IHNldCBzaW5nbGUgbWVzc2FnZSB0ZW1wbGF0ZScpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2VzID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlcyksICdJbnZhbGlkIG1lc3NhZ2Ugb3B0aW9ucycpO1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0ID8gQ2xvbmUodGFyZ2V0KSA6IHt9O1xuXG4gICAgZm9yIChsZXQgY29kZSBpbiBtZXNzYWdlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBuZXcgVGVtcGxhdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlKSwgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlKTtcblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB0YXJnZXRbbGFuZ3VhZ2VdIHx8IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShsb2NhbGl6ZWQpKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGxvY2FsaXplZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSwgJ2luJywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IG5ldyBUZW1wbGF0ZShsb2NhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblxuZXhwb3J0cy5kZWNvbXBpbGUgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcblxuICAgIC8vIEJ5IGVycm9yIGNvZGUgeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0ge307XG4gICAgZm9yIChsZXQgY29kZSBpbiBtZXNzYWdlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZXNbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290Jykge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2UuZGVzY3JpYmUoeyBjb21wYWN0OiB0cnVlIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZC5kZXNjcmliZSh7IGNvbXBhY3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKGJhc2UsIGV4dGVuZGVkKSB7XG5cbiAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuY29tcGlsZShleHRlbmRlZCk7XG4gICAgfVxuXG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgc3RyaW5nXG5cbiAgICBpZiAodHlwZW9mIGV4dGVuZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgdmFsdWUgdGVtcGxhdGVcblxuICAgIGlmIChUZW1wbGF0ZS5pc1RlbXBsYXRlKGV4dGVuZGVkKSkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kZWQ7XG4gICAgfVxuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBDbG9uZShiYXNlKTtcblxuICAgIGZvciAobGV0IGNvZGUgaW4gZXh0ZW5kZWQpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV4dGVuZGVkW2NvZGVdO1xuXG4gICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobWVzc2FnZSkpIHtcblxuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbmV3IFRlbXBsYXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCeSBsYW5ndWFnZSB7IGVuZ2xpc2g6IHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH0gfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkobWVzc2FnZSksICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSk7XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0gdGFyZ2V0W2xhbmd1YWdlXSB8fCB7fTtcblxuICAgICAgICBmb3IgKGNvZGUgaW4gbWVzc2FnZSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxpemVkID0gbWVzc2FnZVtjb2RlXTtcblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLmlzVGVtcGxhdGUobG9jYWxpemVkKSkge1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IGxvY2FsaXplZDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBsb2NhbGl6ZWQgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUsICdpbicsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBuZXcgVGVtcGxhdGUobG9jYWxpemVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuXG5leHBvcnRzLklkcyA9IGludGVybmFscy5JZHMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl9ieUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ieUtleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBjbG9uZSA9IG5ldyBpbnRlcm5hbHMuSWRzKCk7XG4gICAgICAgIGNsb25lLl9ieUlkID0gbmV3IE1hcCh0aGlzLl9ieUlkKTtcbiAgICAgICAgY2xvbmUuX2J5S2V5ID0gbmV3IE1hcCh0aGlzLl9ieUtleSk7XG4gICAgICAgIGNsb25lLl9zY2hlbWFDaGFpbiA9IHRoaXMuX3NjaGVtYUNoYWluO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIGlmIChzb3VyY2UuX3NjaGVtYUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgdmFsdWVdIG9mIHNvdXJjZS5fYnlJZC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGlkKSwgJ1NjaGVtYSBpZCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBrZXk6JywgaWQpO1xuICAgICAgICAgICAgdGhpcy5fYnlJZC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNvdXJjZS5fYnlLZXkuZW50cmllcygpKSB7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5SWQuaGFzKGtleSksICdTY2hlbWEga2V5IGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGlkOicsIGtleSk7XG4gICAgICAgICAgICB0aGlzLl9ieUtleS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3JrKHBhdGgsIGFkanVzdGVyLCByb290KSB7XG5cbiAgICAgICAgY29uc3QgY2hhaW4gPSB0aGlzLl9jb2xsZWN0KHBhdGgpO1xuICAgICAgICBjaGFpbi5wdXNoKHsgc2NoZW1hOiByb290IH0pO1xuICAgICAgICBjb25zdCB0YWlsID0gY2hhaW4uc2hpZnQoKTtcbiAgICAgICAgbGV0IGFkanVzdGVkID0geyBpZDogdGFpbC5pZCwgc2NoZW1hOiBhZGp1c3Rlcih0YWlsLnNjaGVtYSkgfTtcblxuICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKGFkanVzdGVkLnNjaGVtYSksICdhZGp1c3RlciBmdW5jdGlvbiBmYWlsZWQgdG8gcmV0dXJuIGEgam9pIHNjaGVtYSB0eXBlJyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGNoYWluKSB7XG4gICAgICAgICAgICBhZGp1c3RlZCA9IHsgaWQ6IG5vZGUuaWQsIHNjaGVtYTogaW50ZXJuYWxzLmZvcmsobm9kZS5zY2hlbWEsIGFkanVzdGVkLmlkLCBhZGp1c3RlZC5zY2hlbWEpIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWRqdXN0ZWQuc2NoZW1hO1xuICAgIH1cblxuICAgIGxhYmVscyhwYXRoLCBiZWhpbmQgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgYmVoaW5kID0gWy4uLmJlaGluZCwgbm9kZS5zY2hlbWEuX2ZsYWdzLmxhYmVsIHx8IGN1cnJlbnRdO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVoaW5kLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLmxhYmVscyhmb3J3YXJkLCBiZWhpbmQpO1xuICAgIH1cblxuICAgIHJlYWNoKHBhdGgsIGJlaGluZCA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIEFzc2VydChub2RlLCAnU2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gcGF0aCcsIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKSk7XG5cbiAgICAgICAgY29uc3QgZm9yd2FyZCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnNjaGVtYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlLnNjaGVtYS5faWRzLnJlYWNoKGZvcndhcmQsIFsuLi5iZWhpbmQsIGN1cnJlbnRdKTtcbiAgICB9XG5cbiAgICByZWdpc3RlcihzY2hlbWEsIHsga2V5IH0gPSB7fSkge1xuXG4gICAgICAgIGlmICghc2NoZW1hIHx8XG4gICAgICAgICAgICAhQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Byb3BlcnR5KCdzY2hlbWFDaGFpbicpIHx8XG4gICAgICAgICAgICBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4pIHtcblxuICAgICAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaWQgPSBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fYnlJZC5nZXQoaWQpO1xuICAgICAgICAgICAgQXNzZXJ0KCFleGlzdGluZyB8fCBleGlzdGluZy5zY2hlbWEgPT09IHNjaGVtYSwgJ0Nhbm5vdCBhZGQgZGlmZmVyZW50IHNjaGVtYXMgd2l0aCB0aGUgc2FtZSBpZDonLCBpZCk7XG4gICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2J5S2V5LmhhcyhpZCksICdTY2hlbWEgaWQgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcga2V5OicsIGlkKTtcblxuICAgICAgICAgICAgdGhpcy5fYnlJZC5zZXQoaWQsIHsgc2NoZW1hLCBpZCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGtleSksICdTY2hlbWEgYWxyZWFkeSBjb250YWlucyBrZXk6Jywga2V5KTtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlJZC5oYXMoa2V5KSwgJ1NjaGVtYSBrZXkgY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgaWQ6Jywga2V5KTtcblxuICAgICAgICAgICAgdGhpcy5fYnlLZXkuc2V0KGtleSwgeyBzY2hlbWEsIGlkOiBrZXkgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLl9ieUlkID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ieUtleSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2NoZW1hQ2hhaW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfY29sbGVjdChwYXRoLCBiZWhpbmQgPSBbXSwgbm9kZXMgPSBbXSkge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXRoWzBdO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ2V0KGN1cnJlbnQpO1xuICAgICAgICBBc3NlcnQobm9kZSwgJ1NjaGVtYSBkb2VzIG5vdCBjb250YWluIHBhdGgnLCBbLi4uYmVoaW5kLCAuLi5wYXRoXS5qb2luKCcuJykpO1xuXG4gICAgICAgIG5vZGVzID0gW25vZGUsIC4uLm5vZGVzXTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMuX2NvbGxlY3QoZm9yd2FyZCwgWy4uLmJlaGluZCwgY3VycmVudF0sIG5vZGVzKTtcbiAgICB9XG5cbiAgICBfZ2V0KGlkKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5SWQuZ2V0KGlkKSB8fCB0aGlzLl9ieUtleS5nZXQoaWQpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZvcmsgPSBmdW5jdGlvbiAoc2NoZW1hLCBpZCwgcmVwbGFjZW1lbnQpIHtcblxuICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgeyBrZXkgfSkgPT4ge1xuXG4gICAgICAgIGlmIChpZCA9PT0gKGl0ZW0uX2ZsYWdzLmlkIHx8IGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvYmogPSBleHBvcnRzLnNjaGVtYShzY2hlbWEsIHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xufTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdGlvbnMpIHtcblxuICAgIGxldCBvYmo7XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLl9mbGFncykge1xuICAgICAgICBpZiAobmFtZVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHNjaGVtYS5fZmxhZ3NbbmFtZV0sIHsgc291cmNlOiAnZmxhZ3MnLCBuYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIG9iai5fZmxhZ3NbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS5fcnVsZXNbaV07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHJ1bGUuYXJncywgeyBzb3VyY2U6ICdydWxlcycsIG5hbWU6IHJ1bGUubmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIHJ1bGUpO1xuICAgICAgICAgICAgY2xvbmUuYXJncyA9IHJlc3VsdDtcbiAgICAgICAgICAgIG9iai5fcnVsZXNbaV0gPSBjbG9uZTtcblxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdVbmlxdWUgPSBvYmouX3NpbmdsZVJ1bGVzLmdldChydWxlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVW5pcXVlID09PSBydWxlKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQocnVsZS5uYW1lLCBjbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2NoZW1hLiRfdGVybXMpIHtcbiAgICAgICAgaWYgKG5hbWVbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihzY2hlbWEuJF90ZXJtc1tuYW1lXSwgeyBzb3VyY2U6ICd0ZXJtcycsIG5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgb2JqLiRfdGVybXNbbmFtZV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xufTtcblxuXG5pbnRlcm5hbHMuc2NhbiA9IGZ1bmN0aW9uIChpdGVtLCBzb3VyY2UsIG9wdGlvbnMsIF9wYXRoLCBfa2V5KSB7XG5cbiAgICBjb25zdCBwYXRoID0gX3BhdGggfHwgW107XG5cbiAgICBpZiAoaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNsb25lO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBzb3VyY2Uuc291cmNlID09PSAndGVybXMnICYmIHNvdXJjZS5uYW1lID09PSAna2V5cycgJiYgaXRlbVtpXS5rZXk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihpdGVtW2ldLCBzb3VyY2UsIG9wdGlvbnMsIFtpLCAuLi5wYXRoXSwga2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNsb25lID0gY2xvbmUgfHwgaXRlbS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNsb25lW2ldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNjaGVtYSAhPT0gZmFsc2UgJiYgQ29tbW9uLmlzU2NoZW1hKGl0ZW0pIHx8XG4gICAgICAgIG9wdGlvbnMucmVmICE9PSBmYWxzZSAmJiBSZWYuaXNSZWYoaXRlbSkpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb25zLmVhY2goaXRlbSwgeyAuLi5zb3VyY2UsIHBhdGgsIGtleTogX2tleSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgICAgIGlmIChrZXlbMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuc2NhbihpdGVtW2tleV0sIHNvdXJjZSwgb3B0aW9ucywgW2tleSwgLi4ucGF0aF0sIF9rZXkpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsb25lID0gY2xvbmUgfHwgT2JqZWN0LmFzc2lnbih7fSwgaXRlbSk7XG4gICAgICAgICAgICBjbG9uZVtrZXldID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbmxldCBUZW1wbGF0ZTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc3ltYm9sOiBTeW1ib2woJ3JlZicpLCAgICAgIC8vIFVzZWQgdG8gaW50ZXJuYWxseSBpZGVudGlmeSByZWZlcmVuY2VzIChzaGFyZWQgd2l0aCBvdGhlciBqb2kgdmVyc2lvbnMpXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgYWRqdXN0OiBudWxsLFxuICAgICAgICBpbjogZmFsc2UsXG4gICAgICAgIGl0ZXJhYmxlczogbnVsbCxcbiAgICAgICAgbWFwOiBudWxsLFxuICAgICAgICBzZXBhcmF0b3I6ICcuJyxcbiAgICAgICAgdHlwZTogJ3ZhbHVlJ1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIEFzc2VydCh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgJ0ludmFsaWQgcmVmZXJlbmNlIGtleTonLCBrZXkpO1xuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWRqdXN0JywgJ2FuY2VzdG9yJywgJ2luJywgJ2l0ZXJhYmxlcycsICdtYXAnLCAncHJlZml4JywgJ3NlcGFyYXRvciddKTtcbiAgICBBc3NlcnQoIW9wdGlvbnMucHJlZml4IHx8IHR5cGVvZiBvcHRpb25zLnByZWZpeCA9PT0gJ29iamVjdCcsICdvcHRpb25zLnByZWZpeCBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG5cbiAgICBjb25zdCByZWYgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIGRlbGV0ZSByZWYucHJlZml4O1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gcmVmLnNlcGFyYXRvcjtcbiAgICBjb25zdCBjb250ZXh0ID0gaW50ZXJuYWxzLmNvbnRleHQoa2V5LCBzZXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICByZWYudHlwZSA9IGNvbnRleHQudHlwZTtcbiAgICBrZXkgPSBjb250ZXh0LmtleTtcblxuICAgIGlmIChyZWYudHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICBpZiAoY29udGV4dC5yb290KSB7XG4gICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCBrZXlbMF0gIT09IHNlcGFyYXRvciwgJ0Nhbm5vdCBzcGVjaWZ5IHJlbGF0aXZlIHBhdGggd2l0aCByb290IHByZWZpeCcpO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gJ3Jvb3QnO1xuICAgICAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlcGFyYXRvciAmJlxuICAgICAgICAgICAgc2VwYXJhdG9yID09PSBrZXkpIHtcblxuICAgICAgICAgICAga2V5ID0gbnVsbDtcbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVmLmFuY2VzdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXNlcGFyYXRvciB8fCAha2V5IHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IGNvbWJpbmUgcHJlZml4IHdpdGggYW5jZXN0b3Igb3B0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbYW5jZXN0b3IsIHNsaWNlXSA9IGludGVybmFscy5hbmNlc3RvcihrZXksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5zbGljZShzbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gYW5jZXN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWYucGF0aCA9IHNlcGFyYXRvciA/IChrZXkgPT09IG51bGwgPyBbXSA6IGtleS5zcGxpdChzZXBhcmF0b3IpKSA6IFtrZXldO1xuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHJlZik7XG59O1xuXG5cbmV4cG9ydHMuaW4gPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBleHBvcnRzLmNyZWF0ZShrZXksIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgaW46IHRydWUgfSkpO1xufTtcblxuXG5leHBvcnRzLmlzUmVmID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgcmV0dXJuIHJlZiA/ICEhcmVmW0NvbW1vbi5zeW1ib2xzLnJlZl0gOiBmYWxzZTtcbn07XG5cblxuaW50ZXJuYWxzLlJlZiA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnSW52YWxpZCByZWZlcmVuY2UgY29uc3RydWN0aW9uJyk7XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFtcbiAgICAgICAgICAgICdhZGp1c3QnLCAnYW5jZXN0b3InLCAnaW4nLCAnaXRlcmFibGVzJywgJ21hcCcsICdwYXRoJywgJ3NlcGFyYXRvcicsICd0eXBlJywgICAgLy8gQ29waWVkXG4gICAgICAgICAgICAnZGVwdGgnLCAna2V5JywgJ3Jvb3QnLCAnZGlzcGxheScgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRkZW5cbiAgICAgICAgXSk7XG5cbiAgICAgICAgQXNzZXJ0KFtmYWxzZSwgdW5kZWZpbmVkXS5pbmNsdWRlcyhvcHRpb25zLnNlcGFyYXRvcikgfHwgdHlwZW9mIG9wdGlvbnMuc2VwYXJhdG9yID09PSAnc3RyaW5nJyAmJiBvcHRpb25zLnNlcGFyYXRvci5sZW5ndGggPT09IDEsICdJbnZhbGlkIHNlcGFyYXRvcicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYWRqdXN0IHx8IHR5cGVvZiBvcHRpb25zLmFkanVzdCA9PT0gJ2Z1bmN0aW9uJywgJ29wdGlvbnMuYWRqdXN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXApLCAnb3B0aW9ucy5tYXAgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMubWFwIHx8ICFvcHRpb25zLmFkanVzdCwgJ0Nhbm5vdCBzZXQgYm90aCBtYXAgYW5kIGFkanVzdCBvcHRpb25zJyk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIEFzc2VydCh0aGlzLnR5cGUgPT09ICd2YWx1ZScgfHwgdGhpcy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkLCAnTm9uLXZhbHVlIHJlZmVyZW5jZXMgY2Fubm90IHJlZmVyZW5jZSBhbmNlc3RvcnMnKTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm1hcCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCh0aGlzLm1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlcHRoID0gdGhpcy5wYXRoLmxlbmd0aDtcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnBhdGgubGVuZ3RoID8gdGhpcy5wYXRoLmpvaW4odGhpcy5zZXBhcmF0b3IpIDogbnVsbDtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5wYXRoWzBdO1xuXG4gICAgICAgIHRoaXMudXBkYXRlRGlzcGxheSgpO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5pbiB8fCBvcHRpb25zLmluLCAnSW52YWxpZCBpbigpIHJlZmVyZW5jZSB1c2FnZScpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwcmVmcy5jb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShsb2NhbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3N0YXRlLmFuY2VzdG9ycy5sZW5ndGggLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMuYW5jZXN0b3IgPD0gc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCwgJ0ludmFsaWQgcmVmZXJlbmNlIGV4Y2VlZHMgdGhlIHNjaGVtYSByb290OicsIHRoaXMuZGlzcGxheSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHN0YXRlLmFuY2VzdG9yc1t0aGlzLmFuY2VzdG9yIC0gMV0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfcmVzb2x2ZSh0YXJnZXQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHJlc29sdmVkO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnNoYWRvdyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5zaGFkb3cgIT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHJlc29sdmVkID0gc3RhdGUubWFpbnN0YXkuc2hhZG93LmdldCh0aGlzLmFic29sdXRlKHN0YXRlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSBSZWFjaCh0YXJnZXQsIHRoaXMucGF0aCwgeyBpdGVyYWJsZXM6IHRoaXMuaXRlcmFibGVzLCBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hZGp1c3QpIHtcbiAgICAgICAgICAgIHJlc29sdmVkID0gdGhpcy5hZGp1c3QocmVzb2x2ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWQgPSB0aGlzLm1hcC5nZXQocmVzb2x2ZWQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSBtYXBwZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUubWFpbnN0YXkpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5yZXNvbHZlKHN0YXRlLCB0aGlzLCByZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheTtcbiAgICB9XG5cbiAgICBhYnNvbHV0ZShzdGF0ZSkge1xuXG4gICAgICAgIHJldHVybiBbLi4uc3RhdGUucGF0aC5zbGljZSgwLCAtdGhpcy5hbmNlc3RvciksIC4uLnRoaXMucGF0aF07XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKHRoaXMpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IHJlZiA9IHsgcGF0aDogdGhpcy5wYXRoIH07XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmVmLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgcmVmLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgdGhpcy5hbmNlc3RvciAhPT0gMSkge1xuXG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSB0aGlzLmFuY2VzdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWFwKSB7XG4gICAgICAgICAgICByZWYubWFwID0gWy4uLnRoaXMubWFwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsnYWRqdXN0JywgJ2l0ZXJhYmxlcyddKSB7XG4gICAgICAgICAgICBpZiAodGhpc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmW2tleV0gPSB0aGlzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlZi5pbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyByZWYgfTtcbiAgICB9XG5cbiAgICB1cGRhdGVEaXNwbGF5KCkge1xuXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5ICE9PSBudWxsID8gdGhpcy5rZXkgOiAnJztcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke3RoaXMudHlwZX06JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5hbmNlc3Rvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke3RoaXMuc2VwYXJhdG9yfSR7a2V5fWA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNlc3RvciA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOnJvb3Q6JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7a2V5IHx8ICcuLid9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxlYWQgPSBuZXcgQXJyYXkodGhpcy5hbmNlc3RvciArIDEpLmZpbGwodGhpcy5zZXBhcmF0b3IpLmpvaW4oJycpO1xuICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7bGVhZH0ke2tleSB8fCAnJ31gO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlJlZi5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMucmVmXSA9IHRydWU7XG5cblxuZXhwb3J0cy5idWlsZCA9IGZ1bmN0aW9uIChkZXNjKSB7XG5cbiAgICBkZXNjID0gT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJuYWxzLmRlZmF1bHRzLCBkZXNjKTtcbiAgICBpZiAoZGVzYy50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgIGRlc2MuYW5jZXN0b3IgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIGRlc2MuYW5jZXN0b3IgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlJlZihkZXNjKTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbnRleHQgPSBmdW5jdGlvbiAoa2V5LCBzZXBhcmF0b3IsIHByZWZpeCA9IHt9KSB7XG5cbiAgICBrZXkgPSBrZXkudHJpbSgpO1xuXG4gICAgY29uc3QgZ2xvYmFscCA9IHByZWZpeC5nbG9iYWwgPT09IHVuZGVmaW5lZCA/ICckJyA6IHByZWZpeC5nbG9iYWw7XG4gICAgaWYgKGdsb2JhbHAgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICBrZXkuc3RhcnRzV2l0aChnbG9iYWxwKSkge1xuXG4gICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGdsb2JhbHAubGVuZ3RoKSwgdHlwZTogJ2dsb2JhbCcgfTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbCA9IHByZWZpeC5sb2NhbCA9PT0gdW5kZWZpbmVkID8gJyMnIDogcHJlZml4LmxvY2FsO1xuICAgIGlmIChsb2NhbCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgIGtleS5zdGFydHNXaXRoKGxvY2FsKSkge1xuXG4gICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKGxvY2FsLmxlbmd0aCksIHR5cGU6ICdsb2NhbCcgfTtcbiAgICB9XG5cbiAgICBjb25zdCByb290ID0gcHJlZml4LnJvb3QgPT09IHVuZGVmaW5lZCA/ICcvJyA6IHByZWZpeC5yb290O1xuICAgIGlmIChyb290ICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgocm9vdCkpIHtcblxuICAgICAgICByZXR1cm4geyBrZXk6IGtleS5zbGljZShyb290Lmxlbmd0aCksIHR5cGU6ICd2YWx1ZScsIHJvb3Q6IHRydWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBrZXksIHR5cGU6ICd2YWx1ZScgfTtcbn07XG5cblxuaW50ZXJuYWxzLmFuY2VzdG9yID0gZnVuY3Rpb24gKGtleSwgc2VwYXJhdG9yKSB7XG5cbiAgICBpZiAoIXNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gWzEsIDBdOyAgICAgICAgICAgICAgLy8gJ2FfYicgLT4gMSAocGFyZW50KVxuICAgIH1cblxuICAgIGlmIChrZXlbMF0gIT09IHNlcGFyYXRvcikgeyAgICAgLy8gJ2EuYicgLT4gMSAocGFyZW50KVxuICAgICAgICByZXR1cm4gWzEsIDBdO1xuICAgIH1cblxuICAgIGlmIChrZXlbMV0gIT09IHNlcGFyYXRvcikgeyAgICAgLy8gJy5hLmInIC0+IDAgKHNlbGYpXG4gICAgICAgIHJldHVybiBbMCwgMV07XG4gICAgfVxuXG4gICAgbGV0IGkgPSAyO1xuICAgIHdoaWxlIChrZXlbaV0gPT09IHNlcGFyYXRvcikge1xuICAgICAgICArK2k7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtpIC0gMSwgaV07ICAgICAgICAgICAgICAvLyAnLi4uYS5iLicgLT4gMiAoZ3JhbmRwYXJlbnQpXG59O1xuXG5cbmV4cG9ydHMudG9TaWJsaW5nID0gMDtcblxuZXhwb3J0cy50b1BhcmVudCA9IDE7XG5cblxuZXhwb3J0cy5NYW5hZ2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5yZWZzID0gW107ICAgICAgICAgICAgICAgICAgICAgLy8gMDogW3NlbGYgcmVmc10sIDE6IFtwYXJlbnQgcmVmc10sIDI6IFtncmFuZHBhcmVudCByZWZzXSwgLi4uXG4gICAgfVxuXG4gICAgcmVnaXN0ZXIoc291cmNlLCB0YXJnZXQpIHtcblxuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBleHBvcnRzLnRvUGFyZW50IDogdGFyZ2V0O1xuXG4gICAgICAgIC8vIEFycmF5XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2Ygc291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlcihyZWYsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNjaGVtYVxuXG4gICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZS5fcmVmcy5yZWZzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uYW5jZXN0b3IgLSB0YXJnZXQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZnMucHVzaCh7IGFuY2VzdG9yOiBpdGVtLmFuY2VzdG9yIC0gdGFyZ2V0LCByb290OiBpdGVtLnJvb3QgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoZXhwb3J0cy5pc1JlZihzb3VyY2UpICYmXG4gICAgICAgICAgICBzb3VyY2UudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgc291cmNlLmFuY2VzdG9yIC0gdGFyZ2V0ID49IDApIHtcblxuICAgICAgICAgICAgdGhpcy5yZWZzLnB1c2goeyBhbmNlc3Rvcjogc291cmNlLmFuY2VzdG9yIC0gdGFyZ2V0LCByb290OiBzb3VyY2Uucm9vdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbXBsYXRlXG5cbiAgICAgICAgVGVtcGxhdGUgPSBUZW1wbGF0ZSB8fCByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbiAgICAgICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUoc291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcihzb3VyY2UucmVmcygpLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IGV4cG9ydHMuTWFuYWdlcigpO1xuICAgICAgICBjb3B5LnJlZnMgPSBDbG9uZSh0aGlzLnJlZnMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcblxuICAgICAgICB0aGlzLnJlZnMgPSBbXTtcbiAgICB9XG5cbiAgICByb290cygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5yZWZzLmZpbHRlcigocmVmKSA9PiAhcmVmLmFuY2VzdG9yKS5tYXAoKHJlZikgPT4gcmVmLnJvb3QpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEpvaSA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBQcmVmZXJlbmNlc1xuXG5leHBvcnRzLnByZWZlcmVuY2VzID0gSm9pLm9iamVjdCh7XG4gICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgIGFib3J0RWFybHk6IEpvaS5ib29sZWFuKCksXG4gICAgY2FjaGU6IEpvaS5ib29sZWFuKCksXG4gICAgY29udGV4dDogSm9pLm9iamVjdCgpLFxuICAgIGNvbnZlcnQ6IEpvaS5ib29sZWFuKCksXG4gICAgZGF0ZUZvcm1hdDogSm9pLnZhbGlkKCdkYXRlJywgJ2lzbycsICdzdHJpbmcnLCAndGltZScsICd1dGMnKSxcbiAgICBkZWJ1ZzogSm9pLmJvb2xlYW4oKSxcbiAgICBlcnJvcnM6IHtcbiAgICAgICAgZXNjYXBlSHRtbDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbGFiZWw6IEpvaS52YWxpZCgncGF0aCcsICdrZXknLCBmYWxzZSksXG4gICAgICAgIGxhbmd1YWdlOiBbXG4gICAgICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgICAgICBKb2kub2JqZWN0KCkucmVmKClcbiAgICAgICAgXSxcbiAgICAgICAgcmVuZGVyOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBzdGFjazogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgd3JhcEFycmF5czogSm9pLmJvb2xlYW4oKVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgIG1lc3NhZ2VzOiBKb2kub2JqZWN0KCksXG4gICAgbm9EZWZhdWx0czogSm9pLmJvb2xlYW4oKSxcbiAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICBwcmVzZW5jZTogSm9pLnZhbGlkKCdyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nKSxcbiAgICBza2lwRnVuY3Rpb25zOiBKb2kuYm9vbGVhbigpLFxuICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgb2JqZWN0czogSm9pLmJvb2xlYW4oKVxuICAgIH0pXG4gICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAuYWxsb3codHJ1ZSwgZmFsc2UpLFxuICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG4vLyBFeHRlbnNpb25zXG5cbmludGVybmFscy5uYW1lUnggPSAvXlthLXpBLVowLTldKyQvO1xuXG5cbmludGVybmFscy5ydWxlID0gSm9pLm9iamVjdCh7XG4gICAgYWxpYXM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpKS5zaW5nbGUoKSxcbiAgICBhcmdzOiBKb2kuYXJyYXkoKS5pdGVtcyhcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IEpvaS5zdHJpbmcoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICByZWY6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBhc3NlcnQ6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICAgICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICAgICAgICAgIEpvaS5vYmplY3QoKS5zY2hlbWEoKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAuY29uZGl0aW9uYWwoJ3JlZicsIHsgaXM6IHRydWUsIHRoZW46IEpvaS5yZXF1aXJlZCgpIH0pLFxuICAgICAgICAgICAgbm9ybWFsaXplOiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IEpvaS5zdHJpbmcoKS53aGVuKCdhc3NlcnQnLCB7IGlzOiBKb2kuZnVuY3Rpb24oKSwgdGhlbjogSm9pLnJlcXVpcmVkKCkgfSlcbiAgICAgICAgfSlcbiAgICApLFxuICAgIGNvbnZlcnQ6IEpvaS5ib29sZWFuKCksXG4gICAgbWFuaWZlc3Q6IEpvaS5ib29sZWFuKCksXG4gICAgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5hbGxvdyhmYWxzZSksXG4gICAgbXVsdGk6IEpvaS5ib29sZWFuKCksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpXG59KTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbiA9IEpvaS5vYmplY3Qoe1xuICAgIHR5cGU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuXG4gICAgYXJnczogSm9pLmZ1bmN0aW9uKCksXG4gICAgYmFzZTogSm9pLm9iamVjdCgpLnNjaGVtYSgpLFxuICAgIGNvZXJjZTogW1xuICAgICAgICBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICAgICAgSm9pLm9iamVjdCh7IG1ldGhvZDogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMykucmVxdWlyZWQoKSwgZnJvbTogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSB9KVxuICAgIF0sXG4gICAgZmxhZ3M6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5vYmplY3Qoe1xuICAgICAgICBzZXR0ZXI6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpXG4gICAgfSkpLFxuICAgIG1hbmlmZXN0OiB7XG4gICAgICAgIGJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgyKVxuICAgIH0sXG4gICAgbWVzc2FnZXM6IFtKb2kub2JqZWN0KCksIEpvaS5zdHJpbmcoKV0sXG4gICAgbW9kaWZpZXJzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKS5taW5Bcml0eSgxKS5tYXhBcml0eSgyKSksXG4gICAgb3ZlcnJpZGVzOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kuZnVuY3Rpb24oKSksXG4gICAgcHJlcGFyZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMyksXG4gICAgcmVidWlsZDogSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSksXG4gICAgcnVsZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIGludGVybmFscy5ydWxlKSxcbiAgICB0ZXJtczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIGluaXQ6IEpvaS5hcnJheSgpLmFsbG93KG51bGwpLnJlcXVpcmVkKCksXG4gICAgICAgIG1hbmlmZXN0OiBKb2kub2JqZWN0KCkucGF0dGVybigvLisvLCBbXG4gICAgICAgICAgICBKb2kudmFsaWQoJ3NjaGVtYScsICdzaW5nbGUnKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG1hcHBlZDogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgICAgICAgICB0bzogSm9pLnN0cmluZygpLnJlcXVpcmVkKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgXSlcbiAgICB9KSksXG4gICAgdmFsaWRhdGU6IEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpXG59KVxuICAgIC5zdHJpY3QoKTtcblxuXG5leHBvcnRzLmV4dGVuc2lvbnMgPSBKb2kuYXJyYXkoKS5pdGVtcyhKb2kub2JqZWN0KCksIEpvaS5mdW5jdGlvbigpLmFyaXR5KDEpKS5zdHJpY3QoKTtcblxuXG4vLyBNYW5pZmVzdFxuXG5pbnRlcm5hbHMuZGVzYyA9IHtcblxuICAgIGJ1ZmZlcjogSm9pLm9iamVjdCh7XG4gICAgICAgIGJ1ZmZlcjogSm9pLnN0cmluZygpXG4gICAgfSksXG5cbiAgICBmdW5jOiBKb2kub2JqZWN0KHtcbiAgICAgICAgZnVuY3Rpb246IEpvaS5mdW5jdGlvbigpLnJlcXVpcmVkKCksXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxpdGVyYWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0pLFxuXG4gICAgb3ZlcnJpZGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBvdmVycmlkZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVmOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IEpvaS52YWxpZCgndmFsdWUnLCAnZ2xvYmFsJywgJ2xvY2FsJyksXG4gICAgICAgICAgICBwYXRoOiBKb2kuYXJyYXkoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgc2VwYXJhdG9yOiBKb2kuc3RyaW5nKCkubGVuZ3RoKDEpLmFsbG93KGZhbHNlKSxcbiAgICAgICAgICAgIGFuY2VzdG9yOiBKb2kubnVtYmVyKCkubWluKDApLmludGVnZXIoKS5hbGxvdygncm9vdCcpLFxuICAgICAgICAgICAgbWFwOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuYXJyYXkoKS5sZW5ndGgoMikpLm1pbigxKSxcbiAgICAgICAgICAgIGFkanVzdDogSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICBpdGVyYWJsZXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBpbjogSm9pLmJvb2xlYW4oKVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHJlZ2V4OiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVnZXg6IEpvaS5zdHJpbmcoKS5taW4oMylcbiAgICB9KSxcblxuICAgIHNwZWNpYWw6IEpvaS5vYmplY3Qoe1xuICAgICAgICBzcGVjaWFsOiBKb2kudmFsaWQoJ2RlZXAnKS5yZXF1aXJlZCgpXG4gICAgfSksXG5cbiAgICB0ZW1wbGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHRlbXBsYXRlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpXG4gICAgfSksXG5cbiAgICB2YWx1ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHZhbHVlOiBKb2kuYWx0ZXJuYXRpdmVzKFtKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpXSkucmVxdWlyZWQoKVxuICAgIH0pXG59O1xuXG5cbmludGVybmFscy5kZXNjLmVudGl0eSA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5saW5rKCcuLi4nKSksXG4gICAgSm9pLmJvb2xlYW4oKSxcbiAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICBKb2kubnVtYmVyKCksXG4gICAgSm9pLnN0cmluZygpLFxuICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICBpbnRlcm5hbHMuZGVzYy5zcGVjaWFsLFxuICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgIGludGVybmFscy5kZXNjLnZhbHVlLFxuICAgIEpvaS5saW5rKCcvJylcbl0pO1xuXG5cbmludGVybmFscy5kZXNjLnZhbHVlcyA9IEpvaS5hcnJheSgpXG4gICAgLml0ZW1zKFxuICAgICAgICBudWxsLFxuICAgICAgICBKb2kuYm9vbGVhbigpLFxuICAgICAgICBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgSm9pLm51bWJlcigpLmFsbG93KEluZmluaXR5LCAtSW5maW5pdHkpLFxuICAgICAgICBKb2kuc3RyaW5nKCkuYWxsb3coJycpLFxuICAgICAgICBKb2kuc3ltYm9sKCksXG4gICAgICAgIGludGVybmFscy5kZXNjLmJ1ZmZlcixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuZnVuYyxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2Mub3ZlcnJpZGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnJlZixcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVnZXgsXG4gICAgICAgIGludGVybmFscy5kZXNjLnRlbXBsYXRlLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy52YWx1ZVxuICAgICk7XG5cblxuaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMgPSBKb2kub2JqZWN0KClcbiAgICAucGF0dGVybigvLisvLCBbXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtKb2kuc3RyaW5nKCksIGludGVybmFscy5kZXNjLnRlbXBsYXRlXSlcbiAgICBdKTtcblxuXG5leHBvcnRzLmRlc2NyaXB0aW9uID0gSm9pLm9iamVjdCh7XG4gICAgdHlwZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgZmxhZ3M6IEpvaS5vYmplY3Qoe1xuICAgICAgICBjYXN0OiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGRlZmF1bHQ6IEpvaS5hbnkoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZW1wdHk6IEpvaS5saW5rKCcvJyksXG4gICAgICAgIGZhaWxvdmVyOiBpbnRlcm5hbHMuZGVzYy5lbnRpdHksXG4gICAgICAgIGlkOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIGxhYmVsOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG9ubHk6IHRydWUsXG4gICAgICAgIHByZXNlbmNlOiBbJ29wdGlvbmFsJywgJ3JlcXVpcmVkJywgJ2ZvcmJpZGRlbiddLFxuICAgICAgICByZXN1bHQ6IFsncmF3JywgJ3N0cmlwJ10sXG4gICAgICAgIHN0cmlwOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB1bml0OiBKb2kuc3RyaW5nKClcbiAgICB9KVxuICAgICAgICAudW5rbm93bigpLFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgIGFsbG93VW5rbm93bjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgYWJvcnRFYXJseTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgY2FjaGU6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGNvbnZlcnQ6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGRhdGVGb3JtYXQ6IFsnZGF0ZScsICdpc28nLCAnc3RyaW5nJywgJ3RpbWUnLCAndXRjJ10sXG4gICAgICAgIGVycm9yczoge1xuICAgICAgICAgICAgZXNjYXBlSHRtbDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIGxhYmVsOiBbJ3BhdGgnLCAna2V5J10sXG4gICAgICAgICAgICBsYW5ndWFnZTogW1xuICAgICAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZGVzYy5yZWZcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB3cmFwQXJyYXlzOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0sXG4gICAgICAgIGV4dGVybmFsczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZXM6IGludGVybmFscy5kZXNjLm1lc3NhZ2VzLFxuICAgICAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBub25FbnVtZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgcHJlc2VuY2U6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHNraXBGdW5jdGlvbnM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0cmlwVW5rbm93bjogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBhcnJheXM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBvYmplY3RzOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3IoJ2FycmF5cycsICdvYmplY3RzJylcbiAgICAgICAgICAgIC5hbGxvdyh0cnVlLCBmYWxzZSksXG4gICAgICAgIHdhcm5pbmdzOiBKb2kuYm9vbGVhbigpXG4gICAgfSxcbiAgICBhbGxvdzogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIGludmFsaWQ6IGludGVybmFscy5kZXNjLnZhbHVlcyxcbiAgICBydWxlczogSm9pLmFycmF5KCkubWluKDEpLml0ZW1zKHtcbiAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgIGFyZ3M6IEpvaS5vYmplY3QoKS5taW4oMSksXG4gICAgICAgIGtlZXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGludGVybmFscy5kZXNjLm1lc3NhZ2VzXG4gICAgICAgIF0sXG4gICAgICAgIHdhcm46IEpvaS5ib29sZWFuKClcbiAgICB9KSxcblxuICAgIC8vIFRlcm1zXG5cbiAgICBrZXlzOiBKb2kub2JqZWN0KCkucGF0dGVybigvLiovLCBKb2kubGluaygnLycpKSxcbiAgICBsaW5rOiBpbnRlcm5hbHMuZGVzYy5yZWZcbn0pXG4gICAgLnBhdHRlcm4oL15bYS16XVxcdyokLywgSm9pLmFueSgpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB2YWx1ZTogU3ltYm9sKCd2YWx1ZScpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlN0YXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocGF0aCwgYW5jZXN0b3JzLCBzdGF0ZSkge1xuXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuYW5jZXN0b3JzID0gYW5jZXN0b3JzOyAgICAgICAgICAgICAgICAgLy8gW3BhcmVudCwgLi4uLCByb290XVxuXG4gICAgICAgIHRoaXMubWFpbnN0YXkgPSBzdGF0ZS5tYWluc3RheTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gc3RhdGUuc2NoZW1hczsgICAgICAgICAgICAgICAvLyBbY3VycmVudCwgLi4uLCByb290XVxuICAgICAgICB0aGlzLmRlYnVnID0gbnVsbDtcbiAgICB9XG5cbiAgICBsb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMgPSBudWxsLCBzY2hlbWEgPSBudWxsKSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgaW50ZXJuYWxzLlN0YXRlKHBhdGgsIGFuY2VzdG9ycywgdGhpcyk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAmJlxuICAgICAgICAgICAgc3RhdGUuc2NoZW1hcykge1xuXG4gICAgICAgICAgICBzdGF0ZS5zY2hlbWFzID0gW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIG5lc3Qoc2NoZW1hLCBkZWJ1Zykge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IGludGVybmFscy5TdGF0ZSh0aGlzLnBhdGgsIHRoaXMuYW5jZXN0b3JzLCB0aGlzKTtcbiAgICAgICAgc3RhdGUuc2NoZW1hcyA9IHN0YXRlLnNjaGVtYXMgJiYgW2ludGVybmFscy5zY2hlbWFzKHNjaGVtYSksIC4uLnN0YXRlLnNjaGVtYXNdO1xuICAgICAgICBzdGF0ZS5kZWJ1ZyA9IGRlYnVnO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgc2hhZG93KHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICB0aGlzLm1haW5zdGF5LnNoYWRvdyA9IHRoaXMubWFpbnN0YXkuc2hhZG93IHx8IG5ldyBpbnRlcm5hbHMuU2hhZG93KCk7XG4gICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93LnNldCh0aGlzLnBhdGgsIHZhbHVlLCByZWFzb24pO1xuICAgIH1cblxuICAgIHNuYXBzaG90KCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSBDbG9uZSh0aGlzLm1haW5zdGF5LnNoYWRvdy5ub2RlKHRoaXMucGF0aCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcblxuICAgICAgICBpZiAodGhpcy5tYWluc3RheS5zaGFkb3cpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93Lm92ZXJyaWRlKHRoaXMucGF0aCwgdGhpcy5fc25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWFzID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShzY2hlbWEpKSB7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYSB9O1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5TaGFkb3cgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLl92YWx1ZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHNldChwYXRoLCB2YWx1ZSwgcmVhc29uKSB7XG5cbiAgICAgICAgaWYgKCFwYXRoLmxlbmd0aCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHN0b3JlIHJvb3QgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFzb24gPT09ICdzdHJpcCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7ICAgICAgICAvLyBDYW5ub3Qgc3RvcmUgc3RyaXBwZWQgYXJyYXkgdmFsdWVzIChkdWUgdG8gc2hpZnQpXG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IHRoaXMuX3ZhbHVlcyB8fCBuZXcgTWFwKCk7XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl92YWx1ZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuZ2V0KHNlZ21lbnQpO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBub2RlLnNldChzZWdtZW50LCBuZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlW2ludGVybmFscy52YWx1ZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQocGF0aCkge1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGUocGF0aCk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZVtpbnRlcm5hbHMudmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbm9kZShwYXRoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjaCh0aGlzLl92YWx1ZXMsIHBhdGgsIHsgaXRlcmFibGVzOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG92ZXJyaWRlKHBhdGgsIG5vZGUpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICBjb25zdCBvd24gPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IFJlYWNoKHRoaXMuX3ZhbHVlcywgcGFyZW50cywgeyBpdGVyYWJsZXM6IHRydWUgfSk7XG5cbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudC5zZXQob3duLCBub2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5kZWxldGUob3duKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgRXNjYXBlSHRtbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZUh0bWwnKTtcbmNvbnN0IEZvcm11bGEgPSByZXF1aXJlKCdAaGFwaS9mb3JtdWxhJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc3ltYm9sOiBTeW1ib2woJ3RlbXBsYXRlJyksXG5cbiAgICBvcGVuczogbmV3IEFycmF5KDEwMDApLmpvaW4oJ1xcdTAwMDAnKSxcbiAgICBjbG9zZXM6IG5ldyBBcnJheSgxMDAwKS5qb2luKCdcXHUwMDAxJyksXG5cbiAgICBkYXRlRm9ybWF0OiB7XG4gICAgICAgIGRhdGU6IERhdGUucHJvdG90eXBlLnRvRGF0ZVN0cmluZyxcbiAgICAgICAgaXNvOiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyxcbiAgICAgICAgc3RyaW5nOiBEYXRlLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICAgICAgdGltZTogRGF0ZS5wcm90b3R5cGUudG9UaW1lU3RyaW5nLFxuICAgICAgICB1dGM6IERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nXG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBpbnRlcm5hbHMuVGVtcGxhdGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycsICdUZW1wbGF0ZSBzb3VyY2UgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICBBc3NlcnQoIXNvdXJjZS5pbmNsdWRlcygnXFx1MDAwMCcpICYmICFzb3VyY2UuaW5jbHVkZXMoJ1xcdTAwMDEnKSwgJ1RlbXBsYXRlIHNvdXJjZSBjYW5ub3QgY29udGFpbiByZXNlcnZlZCBjb250cm9sIGNoYXJhY3RlcnMnKTtcblxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHNvdXJjZTtcblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gQ2xvbmUob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fcGFyc2UoKTtcbiAgICB9XG5cbiAgICBfcGFyc2UoKSB7XG5cbiAgICAgICAgLy8gJ3RleHQge3Jhd30ge3tyZWZ9fSBcXFxce3tpZ25vcmV9fSB7e2lnbm9yZVxcXFx9fSB7e2lnbm9yZSB7e2lnbm9yZX0nXG5cbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmNvZGUgZXNjYXBlZCBcXFxce3t7e3tcblxuICAgICAgICBjb25zdCBlbmNvZGVkID0gaW50ZXJuYWxzLmVuY29kZSh0aGlzLnNvdXJjZSk7XG5cbiAgICAgICAgLy8gU3BsaXQgb24gZmlyc3QgeyBpbiBlYWNoIHNldFxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gaW50ZXJuYWxzLnNwbGl0KGVuY29kZWQpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgcGFydHNcblxuICAgICAgICBsZXQgcmVmcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgY29uc3QgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChoZWFkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gcGFydFswXSAhPT0gJ3snO1xuICAgICAgICAgICAgY29uc3QgZW5kZXIgPSByYXcgPyAnfScgOiAnfX0nO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGFydC5pbmRleE9mKGVuZGVyKTtcbiAgICAgICAgICAgIGlmIChlbmQgPT09IC0xIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBub24tbWF0Y2hpbmcgY2xvc2luZ1xuICAgICAgICAgICAgICAgIHBhcnRbMV0gPT09ICd7JykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG1vcmUgdGhhbiB0d28ge1xuXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goYHske2ludGVybmFscy5kZWNvZGUocGFydCl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlID0gcGFydC5zbGljZShyYXcgPyAwIDogMSwgZW5kKTtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWMgPSB0aGlzLl9yZWYoaW50ZXJuYWxzLmRlY29kZSh2YXJpYWJsZSksIHJhdyk7XG4gICAgICAgICAgICBwcm9jZXNzZWQucHVzaChkeW5hbWljKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZHluYW1pYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHBhcnQuc2xpY2UoZW5kICsgZW5kZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkLnB1c2goaW50ZXJuYWxzLmRlY29kZShyZXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSBwcm9jZXNzZWQuam9pbignJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IHByb2Nlc3NlZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGF0ZShkYXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZUZvcm1hdFtwcmVmcy5kYXRlRm9ybWF0XS5jYWxsKGRhdGUpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0dGluZ3MgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29tcGFjdCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZXNjID0geyB0ZW1wbGF0ZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cblxuICAgIHN0YXRpYyBidWlsZChkZXNjKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuVGVtcGxhdGUoZGVzYy50ZW1wbGF0ZSwgZGVzYy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICBpc0R5bmFtaWMoKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzVGVtcGxhdGUodGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUgPyAhIXRlbXBsYXRlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJlZnMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2goLi4ucGFydC5yZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZzO1xuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFydCh0aGlzLl90ZW1wbGF0ZVswXSwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIHt9IC8qXSAqLyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwpO1xuICAgIH1cblxuICAgIF9wYXJ0KHBhcnQsIC4uLmFyZ3MpIHtcblxuICAgICAgICBpZiAocGFydC5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0LnJlZi5yZXNvbHZlKC4uLmFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnQuZm9ybXVsYS5ldmFsdWF0ZShhcmdzKTtcbiAgICB9XG5cbiAgICByZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSB0aGlzLl9wYXJ0KHBhcnQsIC8qIGNvbnRleHQgLT4gWyovIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zIC8qXSAqLyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gaW50ZXJuYWxzLnN0cmluZ2lmeShyZW5kZXJlZCwgcHJlZnMsIG9wdGlvbnMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFydC5yYXcgfHwgKG9wdGlvbnMuZXJyb3JzICYmIG9wdGlvbnMuZXJyb3JzLmVzY2FwZUh0bWwpID09PSBmYWxzZSA/IHN0cmluZyA6IEVzY2FwZUh0bWwoc3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICBfcmVmKGNvbnRlbnQsIHJhdykge1xuXG4gICAgICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gKHZhcmlhYmxlKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IFJlZi5jcmVhdGUodmFyaWFibGUsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgIHJlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgcmV0dXJuIChjb250ZXh0KSA9PiByZWYucmVzb2x2ZSguLi5jb250ZXh0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGZvcm11bGEgPSBuZXcgRm9ybXVsYShjb250ZW50LCB7IHJlZmVyZW5jZSwgZnVuY3Rpb25zOiBpbnRlcm5hbHMuZnVuY3Rpb25zLCBjb25zdGFudHM6IGludGVybmFscy5jb25zdGFudHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgSW52YWxpZCB0ZW1wbGF0ZSB2YXJpYWJsZSBcIiR7Y29udGVudH1cIiBmYWlscyBkdWUgdG86ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb3JtdWxhLnNpbmdsZSkge1xuICAgICAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlLnR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVmOiByZWZzWzBdLCByYXcsIHJlZnMgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5zdHJpbmdpZnkoZm9ybXVsYS5zaW5nbGUudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZm9ybXVsYSwgcmF3LCByZWZzIH07XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlRlbXBsYXRlLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy50ZW1wbGF0ZV0gPSB0cnVlO1xuaW50ZXJuYWxzLlRlbXBsYXRlLnByb3RvdHlwZS5pc0ltbXV0YWJsZSA9IHRydWU7ICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIEhvZWsgZnJvbSBkZWVwIGNsb25pbmcgc2NoZW1hIG9iamVjdHNcblxuXG5pbnRlcm5hbHMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICAucmVwbGFjZSgvXFxcXChcXHsrKS9nLCAoJDAsICQxKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMub3BlbnMuc2xpY2UoMCwgJDEubGVuZ3RoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFx9KykvZywgKCQwLCAkMSkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNsb3Nlcy5zbGljZSgwLCAkMS5sZW5ndGgpO1xuICAgICAgICB9KTtcbn07XG5cblxuaW50ZXJuYWxzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHJldHVybiBzdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoL1xcdTAwMDAvZywgJ3snKVxuICAgICAgICAucmVwbGFjZSgvXFx1MDAwMS9nLCAnfScpO1xufTtcblxuXG5pbnRlcm5hbHMuc3BsaXQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGxldCBjdXJyZW50ID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaGFyID0gc3RyaW5nW2ldO1xuXG4gICAgICAgIGlmIChjaGFyID09PSAneycpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gJyc7XG4gICAgICAgICAgICB3aGlsZSAoaSArIDEgPCBzdHJpbmcubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgc3RyaW5nW2kgKyAxXSA9PT0gJ3snKSB7XG5cbiAgICAgICAgICAgICAgICBuZXh0ICs9ICd7JztcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRzLnB1c2goY3VycmVudCk7XG4gICAgcmV0dXJuIHBhcnRzO1xufTtcblxuXG5pbnRlcm5hbHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHZhbHVlLCBwcmVmcywgb3B0aW9ucykge1xuXG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuVGVtcGxhdGUuZGF0ZSh2YWx1ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHN5bV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKGAke2tleS50b1N0cmluZygpfSAtPiAke3N5bS50b1N0cmluZygpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBwYWlycztcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGxldCBwYXJ0aWFsID0gJyc7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIHBhcnRpYWwgPSBwYXJ0aWFsICsgKHBhcnRpYWwubGVuZ3RoID8gJywgJyA6ICcnKSArIGludGVybmFscy5zdHJpbmdpZnkoaXRlbSwgcHJlZnMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zLndyYXBBcnJheXMgPyAnWycgKyBwYXJ0aWFsICsgJ10nIDogcGFydGlhbDtcbn07XG5cblxuaW50ZXJuYWxzLmNvbnN0YW50cyA9IHtcblxuICAgIHRydWU6IHRydWUsXG4gICAgZmFsc2U6IGZhbHNlLFxuICAgIG51bGw6IG51bGwsXG5cbiAgICBzZWNvbmQ6IDEwMDAsXG4gICAgbWludXRlOiA2MCAqIDEwMDAsXG4gICAgaG91cjogNjAgKiA2MCAqIDEwMDAsXG4gICAgZGF5OiAyNCAqIDYwICogNjAgKiAxMDAwXG59O1xuXG5cbmludGVybmFscy5mdW5jdGlvbnMgPSB7XG5cbiAgICBpZihjb25kaXRpb24sIHRoZW4sIG90aGVyd2lzZSkge1xuXG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyB0aGVuIDogb3RoZXJ3aXNlO1xuICAgIH0sXG5cbiAgICBtc2coY29kZSkge1xuXG4gICAgICAgIGNvbnN0IFt2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9uc10gPSB0aGlzO1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXM7XG4gICAgICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gRXJyb3JzLnRlbXBsYXRlKHZhbHVlLCBtZXNzYWdlc1swXSwgY29kZSwgc3RhdGUsIHByZWZzKSB8fCBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzFdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVuZGVyKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgbnVtYmVyKHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuY29uc3QgUGlucG9pbnQgPSByZXF1aXJlKCdAaGFwaS9waW5wb2ludCcpO1xuXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb2Rlczoge1xuICAgICAgICBlcnJvcjogMSxcbiAgICAgICAgcGFzczogMixcbiAgICAgICAgZnVsbDogM1xuICAgIH0sXG4gICAgbGFiZWxzOiB7XG4gICAgICAgIDA6ICduZXZlciB1c2VkJyxcbiAgICAgICAgMTogJ2Fsd2F5cyBlcnJvcicsXG4gICAgICAgIDI6ICdhbHdheXMgcGFzcydcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuc2V0dXAgPSBmdW5jdGlvbiAocm9vdCkge1xuXG4gICAgY29uc3QgdHJhY2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gcm9vdC5fdHJhY2VyIHx8IG5ldyBpbnRlcm5hbHMuVHJhY2VyKCk7XG4gICAgICAgIHJldHVybiByb290Ll90cmFjZXI7XG4gICAgfTtcblxuICAgIHJvb3QudHJhY2UgPSB0cmFjZTtcbiAgICByb290W1N5bWJvbC5mb3IoJ0BoYXBpL2xhYi9jb3ZlcmFnZS9pbml0aWFsaXplJyldID0gdHJhY2U7XG5cbiAgICByb290LnVudHJhY2UgPSAoKSA9PiB7XG5cbiAgICAgICAgcm9vdC5fdHJhY2VyID0gbnVsbDtcbiAgICB9O1xufTtcblxuXG5leHBvcnRzLmxvY2F0aW9uID0gZnVuY3Rpb24gKHNjaGVtYSkge1xuXG4gICAgcmV0dXJuIHNjaGVtYS4kX3NldEZsYWcoJ190cmFjZXJMb2NhdGlvbicsIFBpbnBvaW50LmxvY2F0aW9uKDIpKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhc2UudHJhY2VyKCksIGNhbGxlclxufTtcblxuXG5pbnRlcm5hbHMuVHJhY2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gJ0pvaSc7XG4gICAgICAgIHRoaXMuX3NjaGVtYXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgX3JlZ2lzdGVyKHNjaGVtYSkge1xuXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5fc2NoZW1hcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmcuc3RvcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdG9yZSA9IG5ldyBpbnRlcm5hbHMuU3RvcmUoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgeyBmaWxlbmFtZSwgbGluZSB9ID0gc2NoZW1hLl9mbGFncy5fdHJhY2VyTG9jYXRpb24gfHwgUGlucG9pbnQubG9jYXRpb24oNSk7ICAgLy8gaW50ZXJuYWxzLnRyYWNlcigpLCBpbnRlcm5hbHMuZW50cnkoKSwgZXhwb3J0cy5lbnRyeSgpLCB2YWxpZGF0ZSgpLCBjYWxsZXJcbiAgICAgICAgdGhpcy5fc2NoZW1hcy5zZXQoc2NoZW1hLCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9KTtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN0b3JlLl9jb21iaW5lKG1lcmdlZCwgc291cmNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBvcnQoZmlsZSkge1xuXG4gICAgICAgIGNvbnN0IGNvdmVyYWdlID0gW107XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHJlZ2lzdGVyZWQgc2NoZW1hXG5cbiAgICAgICAgZm9yIChjb25zdCB7IGZpbGVuYW1lLCBsaW5lLCBzdG9yZSB9IG9mIHRoaXMuX3NjaGVtYXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChmaWxlICYmXG4gICAgICAgICAgICAgICAgZmlsZSAhPT0gZmlsZW5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcm9jZXNzIHN1YiBzY2hlbWFzIG9mIHRoZSByZWdpc3RlcmVkIHJvb3RcblxuICAgICAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2tpcHBlZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtzY2hlbWEsIGxvZ10gb2Ygc3RvcmUuX3NvdXJjZXMuZW50cmllcygpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBzdWIgc2NoZW1hIHBhcmVudCBza2lwcGVkXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLnN1Yihsb2cucGF0aHMsIHNraXBwZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHN1YiBzY2hlbWEgcmVhY2hlZFxuXG4gICAgICAgICAgICAgICAgaWYgKCFsb2cuZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogJ25ldmVyIHJlYWNoZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHM6IFsuLi5sb2cucGF0aHNdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQucHVzaCguLi5sb2cucGF0aHMpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB2YWx1ZXNcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbJ3ZhbGlkJywgJ2ludmFsaWQnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBzY2hlbWFbYF8ke3R5cGV9c2BdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KHNldC5fdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IG5ldyBTZXQoc2V0Ll9yZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHZhbHVlLCByZWYgfSBvZiBsb2dbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuc2l6ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmcy5zaXplKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBbLi4udmFsdWVzLCAuLi5bLi4ucmVmc10ubWFwKChyZWYpID0+IHJlZi5kaXNwbGF5KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogYCR7dHlwZX1zYFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBydWxlcyBzdGF0dXNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gc2NoZW1hLl9ydWxlcy5tYXAoKHJ1bGUpID0+IHJ1bGUubmFtZSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsnZGVmYXVsdCcsICdmYWlsb3ZlciddKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gaW50ZXJuYWxzLmxhYmVsc1tsb2cucnVsZVtuYW1lXSB8fCAwXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0geyBydWxlOiBuYW1lLCBzdGF0dXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cucGF0aHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcG9ydC5wYXRocyA9IFsuLi5sb2cucGF0aHNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFNjaGVtYSBtaXNzaW5nIHRlc3RzIGZvciAke21pc3NpbmcubWFwKGludGVybmFscy5tZXNzYWdlKS5qb2luKCcsICcpfWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3ZlcmFnZS5sZW5ndGggPyBjb3ZlcmFnZSA6IG51bGw7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuU3RvcmUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcblxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgIC8vIHNjaGVtYSAtPiB7IHBhdGhzLCBlbnRyeSwgcnVsZSwgdmFsaWQsIGludmFsaWQgfVxuICAgICAgICB0aGlzLl9jb21ib3MgPSBuZXcgTWFwKCk7ICAgICAgICAgICAvLyBtZXJnZWQgLT4gW3NvdXJjZXNdXG4gICAgICAgIHRoaXMuX3NjYW4oc2NoZW1hKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhzdGF0ZSwgc291cmNlLCBuYW1lLCByZXN1bHQpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1ZyAmJiBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKHsgdHlwZTogc291cmNlLCBuYW1lLCByZXN1bHQsIHBhdGg6IHN0YXRlLnBhdGggfSk7XG4gICAgfVxuXG4gICAgZW50cnkoc2NoZW1hLCBzdGF0ZSkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiAnZW50cnknIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nLmVudHJ5ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZmlsdGVyKHNjaGVtYSwgc3RhdGUsIHNvdXJjZSwgdmFsdWUpIHtcblxuICAgICAgICBpbnRlcm5hbHMuZGVidWcoc3RhdGUsIHsgdHlwZTogc291cmNlLCAuLi52YWx1ZSB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdLmFkZCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxvZyhzY2hlbWEsIHN0YXRlLCBzb3VyY2UsIG5hbWUsIHJlc3VsdCkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiBzb3VyY2UsIG5hbWUsIHJlc3VsdDogcmVzdWx0ID09PSAnZnVsbCcgPyAncGFzcycgOiByZXN1bHQgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSA9IGxvZ1tzb3VyY2VdW25hbWVdIHx8IDA7XG4gICAgICAgICAgICBsb2dbc291cmNlXVtuYW1lXSB8PSBpbnRlcm5hbHMuY29kZXNbcmVzdWx0XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShzdGF0ZSwgcmVmLCB0bykge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvZyA9IHsgdHlwZTogJ3Jlc29sdmUnLCByZWY6IHJlZi5kaXNwbGF5LCB0bywgcGF0aDogc3RhdGUucGF0aCB9O1xuICAgICAgICBzdGF0ZS5tYWluc3RheS5kZWJ1Zy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgdmFsdWUoc3RhdGUsIGJ5LCBmcm9tLCB0bywgbmFtZSkge1xuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkuZGVidWcgfHxcbiAgICAgICAgICAgIERlZXBFcXVhbChmcm9tLCB0bykpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9nID0geyB0eXBlOiAndmFsdWUnLCBieSwgZnJvbSwgdG8sIHBhdGg6IHN0YXRlLnBhdGggfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGxvZy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICBfcmVjb3JkKHNjaGVtYSwgZWFjaCkge1xuXG4gICAgICAgIGNvbnN0IGxvZyA9IHRoaXMuX3NvdXJjZXMuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChsb2cpIHtcbiAgICAgICAgICAgIGVhY2gobG9nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSB0aGlzLl9jb21ib3MuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZChzb3VyY2UsIGVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NjYW4oc2NoZW1hLCBfcGF0aCkge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgICAgICBsZXQgbG9nID0gdGhpcy5fc291cmNlcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKCFsb2cpIHtcbiAgICAgICAgICAgIGxvZyA9IHtcbiAgICAgICAgICAgICAgICBwYXRoczogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGVudHJ5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydWxlOiB7fSxcbiAgICAgICAgICAgICAgICB2YWxpZDogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIGludmFsaWQ6IG5ldyBTZXQoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5zZXQoc2NoZW1hLCBsb2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2cucGF0aHMuYWRkKHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChzdWIsIHNvdXJjZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IGludGVybmFscy5pZChzdWIsIHNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2FuKHN1YiwgcGF0aC5jb25jYXQoc3ViSWQpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzY2hlbWEuJF9tb2RpZnkoeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIF9jb21iaW5lKG1lcmdlZCwgc291cmNlcykge1xuXG4gICAgICAgIHRoaXMuX2NvbWJvcy5zZXQobWVyZ2VkLCBzb3VyY2VzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tZXNzYWdlID0gZnVuY3Rpb24gKGl0ZW0pIHtcblxuICAgIGNvbnN0IHBhdGggPSBpdGVtLnBhdGhzID8gRXJyb3JzLnBhdGgoaXRlbS5wYXRoc1swXSkgKyAoaXRlbS5ydWxlID8gJzonIDogJycpIDogJyc7XG4gICAgcmV0dXJuIGAke3BhdGh9JHtpdGVtLnJ1bGUgfHwgJyd9ICgke2l0ZW0uc3RhdHVzfSlgO1xufTtcblxuXG5pbnRlcm5hbHMuaWQgPSBmdW5jdGlvbiAoc2NoZW1hLCB7IHNvdXJjZSwgbmFtZSwgcGF0aCwga2V5IH0pIHtcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmlkKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuX2ZsYWdzLmlkO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBuYW1lID0gYEAke25hbWV9YDtcblxuICAgIGlmIChzb3VyY2UgPT09ICd0ZXJtcycpIHtcbiAgICAgICAgcmV0dXJuIFtuYW1lLCBwYXRoW01hdGgubWluKHBhdGgubGVuZ3RoIC0gMSwgMSldXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cblxuaW50ZXJuYWxzLnN1YiA9IGZ1bmN0aW9uIChwYXRocywgc2tpcHBlZCkge1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2tpcCBvZiBza2lwcGVkKSB7XG4gICAgICAgICAgICBpZiAoRGVlcEVxdWFsKHBhdGguc2xpY2UoMCwgc2tpcC5sZW5ndGgpLCBza2lwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuZGVidWcgPSBmdW5jdGlvbiAoc3RhdGUsIGV2ZW50KSB7XG5cbiAgICBpZiAoc3RhdGUubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgZXZlbnQucGF0aCA9IHN0YXRlLmRlYnVnID8gWy4uLnN0YXRlLnBhdGgsIHN0YXRlLmRlYnVnXSA6IHN0YXRlLnBhdGg7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2goZXZlbnQpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FsdGVybmF0aXZlcycsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG1hdGNoOiB7IGRlZmF1bHQ6ICdhbnknIH0gICAgICAgICAgICAgICAgIC8vICdhbnknLCAnb25lJywgJ2FsbCdcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBtYXRjaGVzOiB7IGluaXQ6IFtdLCByZWdpc3RlcjogUmVmLnRvU2libGluZyB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCAuLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWFzWzBdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY2hlbWEudHJ5KC4uLnNjaGVtYXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hcyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSA9IGhlbHBlcnM7XG5cbiAgICAgICAgLy8gTWF0Y2ggYWxsIG9yIG9uZVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgaGl0cyA9IDA7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlZDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLm5lc3QoaXRlbS5zY2hlbWEsIGBtYXRjaC4ke2l9YCk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5zY2hlbWEuJF92YWxpZGF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICArK2hpdHM7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaGl0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5tYXRjaCA9PT0gJ29uZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGl0cyA9PT0gMSA/IHsgdmFsdWU6IG1hdGNoZWQgfSA6IHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLm9uZScpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoaXRzID09PSBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aCA/IHsgdmFsdWUgfSA6IHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLmFsbCcpIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXRjaCBhbnlcblxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcblxuICAgICAgICAgICAgLy8gVHJ5XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5uZXN0KGl0ZW0uc2NoZW1hLCBgbWF0Y2guJHtpfWApO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uc2NoZW1hLiRfdmFsaWRhdGUodmFsdWUsIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHNjaGVtYTogaXRlbS5zY2hlbWEsIHJlcG9ydHM6IHJlc3VsdC5lcnJvcnMgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbmRpdGlvbmFsXG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaXRlbS5yZWYgPyBpdGVtLnJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIDogdmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IGl0ZW0uaXMgPyBbaXRlbV0gOiBpdGVtLnN3aXRjaDtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXN0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzLCB0aGVuLCBvdGhlcndpc2UgfSA9IHRlc3Q7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGBtYXRjaC4ke2l9JHtpdGVtLnN3aXRjaCA/ICcuJyArIGogOiAnJ31gO1xuICAgICAgICAgICAgICAgIGlmICghaXMuJF9tYXRjaChpbnB1dCwgc3RhdGUubmVzdChpcywgYCR7aWR9LmlzYCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXJ3aXNlLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3Qob3RoZXJ3aXNlLCBgJHtpZH0ub3RoZXJ3aXNlYCksIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGVuLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3QodGhlbiwgYCR7aWR9LnRoZW5gKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXJyb3JzKGVycm9ycywgaGVscGVycyk7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29uZGl0aW9uYWw6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9mbGFncy5tYXRjaCwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCB0aGlzLl9mbGFncy5tYXRjaCwgJ3dpdGggY29uZGl0aW9uYWwgcnVsZScpO1xuICAgICAgICAgICAgICAgIEFzc2VydChvcHRpb25zLmJyZWFrID09PSB1bmRlZmluZWQsICdDYW5ub3QgdXNlIGJyZWFrIG9wdGlvbiB3aXRoIGFsdGVybmF0aXZlcyBjb25kaXRpb25hbCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBDb21waWxlLndoZW4ob2JqLCBjb25kaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSBtYXRjaC5pcyA/IFttYXRjaF0gOiBtYXRjaC5zd2l0Y2g7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGhlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5vdGhlcndpc2UpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqLiRfc2V0RmxhZygnX2VuZGVkU3dpdGNoJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXRjaDoge1xuICAgICAgICAgICAgbWV0aG9kKG1vZGUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2FueScsICdvbmUnLCAnYWxsJ10uaW5jbHVkZXMobW9kZSksICdJbnZhbGlkIGFsdGVybmF0aXZlcyBtYXRjaCBtb2RlJywgbW9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobW9kZSAhPT0gJ2FueScpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0aGlzLiRfdGVybXMubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KG1hdGNoLnNjaGVtYSwgJ0Nhbm5vdCBjb21iaW5lIG1hdGNoIG1vZGUnLCBtb2RlLCAnd2l0aCBjb25kaXRpb25hbCBydWxlcycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdtYXRjaCcsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChzY2hlbWFzLmxlbmd0aCwgJ01pc3NpbmcgYWx0ZXJuYXRpdmUgc2NoZW1hcycpO1xuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICd0cnknKTtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy5fZmxhZ3MuX2VuZGVkU3dpdGNoLCAnVW5yZWFjaGFibGUgY29uZGl0aW9uJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXRjaGVzLnB1c2goeyBzY2hlbWE6IG9iai4kX2NvbXBpbGUoc2NoZW1hKSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG92ZXJyaWRlczoge1xuXG4gICAgICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX3N1cGVyLmxhYmVsKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtLCBzb3VyY2UpID0+IChzb3VyY2UucGF0aFswXSAhPT0gJ2lzJyA/IGl0ZW0ubGFiZWwobmFtZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgcmV0dXJuIG9iai4kX21vZGlmeSh7IGVhY2gsIHJlZjogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICAvLyBGbGFnIHdoZW4gYW4gYWx0ZXJuYXRpdmUgdHlwZSBpcyBhbiBhcnJheVxuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGl0ZW0pICYmXG4gICAgICAgICAgICAgICAgaXRlbS50eXBlID09PSAnYXJyYXknKSB7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEuJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNjaGVtYS4kX21vZGlmeSh7IGVhY2ggfSk7XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYSwgcmVmLCBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UgfSA9IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoudHJ5KHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uZGl0aW9uYWwocmVmLCB7IGlzLCB0aGVuLCBub3QsIG90aGVyd2lzZSwgc3dpdGNoOiBtYXRjaC5zd2l0Y2ggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uZGl0aW9uYWwoaXMsIHsgdGhlbiwgb3RoZXJ3aXNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhbHRlcm5hdGl2ZXMuYWxsJzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IG1hdGNoIGFsbCBvZiB0aGUgcmVxdWlyZWQgdHlwZXMnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLmFueSc6ICdcInt7I2xhYmVsfX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLm1hdGNoJzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMub25lJzogJ1wie3sjbGFiZWx9fVwiIG1hdGNoZXMgbW9yZSB0aGFuIG9uZSBhbGxvd2VkIHR5cGUnLFxuICAgICAgICAnYWx0ZXJuYXRpdmVzLnR5cGVzJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgb25lIG9mIHt7I3R5cGVzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZXJyb3JzID0gZnVuY3Rpb24gKGZhaWx1cmVzLCB7IGVycm9yLCBzdGF0ZSB9KSB7XG5cbiAgICAvLyBOb3RoaW5nIG1hdGNoZWQgZHVlIHRvIHR5cGUgY3JpdGVyaWEgcnVsZXNcblxuICAgIGlmICghZmFpbHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5hbnknKSB9O1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBlcnJvclxuXG4gICAgaWYgKGZhaWx1cmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGZhaWx1cmVzWzBdLnJlcG9ydHMgfTtcbiAgICB9XG5cbiAgICAvLyBBbmFseXplIHJlYXNvbnNcblxuICAgIGNvbnN0IHZhbGlkcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb21wbGV4ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHsgcmVwb3J0cywgc2NoZW1hIH0gb2YgZmFpbHVyZXMpIHtcblxuICAgICAgICAvLyBNdWx0aXBsZSBlcnJvcnMgKCFhYm9ydEVhcmx5KVxuXG4gICAgICAgIGlmIChyZXBvcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gZXJyb3JcblxuICAgICAgICBjb25zdCByZXBvcnQgPSByZXBvcnRzWzBdO1xuICAgICAgICBpZiAocmVwb3J0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMudW5tYXRjaGVkKGZhaWx1cmVzLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcm5hbCBvYmplY3Qgb3IgYXJyYXkgZXJyb3JcblxuICAgICAgICBpZiAocmVwb3J0LnN0YXRlLnBhdGgubGVuZ3RoICE9PSBzdGF0ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29tcGxleC5wdXNoKHsgdHlwZTogc2NoZW1hLnR5cGUsIHJlcG9ydCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRzXG5cbiAgICAgICAgaWYgKHJlcG9ydC5jb2RlID09PSAnYW55Lm9ubHknKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkIG9mIHJlcG9ydC5sb2NhbC52YWxpZHMpIHtcbiAgICAgICAgICAgICAgICB2YWxpZHMuYWRkKHZhbGlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCYXNlIHR5cGVcblxuICAgICAgICBjb25zdCBbdHlwZSwgY29kZV0gPSByZXBvcnQuY29kZS5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoY29kZSAhPT0gJ2Jhc2UnKSB7XG4gICAgICAgICAgICBjb21wbGV4LnB1c2goeyB0eXBlOiBzY2hlbWEudHlwZSwgcmVwb3J0IH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YWxpZHMuYWRkKHR5cGUpO1xuICAgIH1cblxuICAgIC8vIEFsbCBlcnJvcnMgYXJlIGJhc2UgdHlwZXMgb3IgdmFsaWRzXG5cbiAgICBpZiAoIWNvbXBsZXgubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy50eXBlcycsIHsgdHlwZXM6IFsuLi52YWxpZHNdIH0pIH07XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIGNvbXBsZXggZXJyb3JcblxuICAgIGlmIChjb21wbGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGNvbXBsZXhbMF0ucmVwb3J0IH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy51bm1hdGNoZWQoZmFpbHVyZXMsIGVycm9yKTtcbn07XG5cblxuaW50ZXJuYWxzLnVubWF0Y2hlZCA9IGZ1bmN0aW9uIChmYWlsdXJlcywgZXJyb3IpIHtcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICBlcnJvcnMucHVzaCguLi5mYWlsdXJlLnJlcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FsdGVybmF0aXZlcy5tYXRjaCcsIEVycm9ycy5kZXRhaWxzKGVycm9ycywgeyBvdmVycmlkZTogZmFsc2UgfSkpIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuLi9tZXNzYWdlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FueScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIG9ubHk6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGFsdGVyYXRpb25zOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgZXhhbXBsZXM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBleHRlcm5hbHM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBtZXRhczogeyBpbml0OiBbXSB9LFxuICAgICAgICBub3RlczogeyBpbml0OiBbXSB9LFxuICAgICAgICBzaGFyZWQ6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICB0YWdzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIHdoZW5zOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGN1c3RvbToge1xuICAgICAgICAgICAgbWV0aG9kKG1ldGhvZCwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydChkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGRlc2NyaXB0aW9uICYmIHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2N1c3RvbScsIGFyZ3M6IHsgbWV0aG9kLCBkZXNjcmlwdGlvbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG1ldGhvZCB9KSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYW55LmN1c3RvbScsIHsgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydtZXRob2QnLCAnZGVzY3JpcHRpb24nXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWVzc2FnZXM6IHtcbiAgICAgICAgICAgIG1ldGhvZChtZXNzYWdlcykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZnMoeyBtZXNzYWdlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaGFyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzY2hlbWEpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSAmJiBzY2hlbWEuX2ZsYWdzLmlkLCAnU2NoZW1hIG11c3QgYmUgYSBzY2hlbWEgd2l0aCBhbiBpZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnNoYXJlZCA9IG9iai4kX3Rlcm1zLnNoYXJlZCB8fCBbXTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5zaGFyZWQucHVzaChzY2hlbWEpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuaW5nOiB7XG4gICAgICAgICAgICBtZXRob2QoY29kZSwgbG9jYWwpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChjb2RlICYmIHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJywgJ0ludmFsaWQgd2FybmluZyBjb2RlJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnd2FybmluZycsIGFyZ3M6IHsgY29kZSwgbG9jYWwgfSwgd2FybjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBjb2RlLCBsb2NhbCB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihjb2RlLCBsb2NhbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb2RlJywgJ2xvY2FsJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1vZGlmaWVyczoge1xuXG4gICAgICAgIGtlZXAocnVsZSwgZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgcnVsZS5rZWVwID0gZW5hYmxlZDtcbiAgICAgICAgfSxcblxuICAgICAgICBtZXNzYWdlKHJ1bGUsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgcnVsZS5tZXNzYWdlID0gTWVzc2FnZXMuY29tcGlsZShtZXNzYWdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB3YXJuKHJ1bGUsIGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgIHJ1bGUud2FybiA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGRlc2Nba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2V4YW1wbGVzJywgJ2V4dGVybmFscycsICdtZXRhcycsICdub3RlcycsICd0YWdzJ10uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2tleS5zbGljZSgwLCAtMSldKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdhbHRlcmF0aW9ucycpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWx0ZXIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVyW3RhcmdldF0gPSBhZGp1c3RlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5hbHRlcihhbHRlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICd3aGVucycpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVmLCBpcywgbm90LCB0aGVuLCBvdGhlcndpc2UsIGNvbmNhdCB9ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uY2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLmNvbmNhdChjb25jYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLndoZW4ocmVmLCB7IGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSwgc3dpdGNoOiB2YWx1ZS5zd2l0Y2gsIGJyZWFrOiB2YWx1ZS5icmVhayB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai53aGVuKGlzLCB7IHRoZW4sIG90aGVyd2lzZSwgYnJlYWs6IHZhbHVlLmJyZWFrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5zaGFyZWQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhbnkuY3VzdG9tJzogJ1wie3sjbGFiZWx9fVwiIGZhaWxlZCBjdXN0b20gdmFsaWRhdGlvbiBiZWNhdXNlIHt7I2Vycm9yLm1lc3NhZ2V9fScsXG4gICAgICAgICdhbnkuZGVmYXVsdCc6ICdcInt7I2xhYmVsfX1cIiB0aHJldyBhbiBlcnJvciB3aGVuIHJ1bm5pbmcgZGVmYXVsdCBtZXRob2QnLFxuICAgICAgICAnYW55LmZhaWxvdmVyJzogJ1wie3sjbGFiZWx9fVwiIHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBmYWlsb3ZlciBtZXRob2QnLFxuICAgICAgICAnYW55LmludmFsaWQnOiAnXCJ7eyNsYWJlbH19XCIgY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZScsXG4gICAgICAgICdhbnkub25seSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIHtpZigjdmFsaWRzLmxlbmd0aCA9PSAxLCBcIlwiLCBcIm9uZSBvZiBcIil9e3sjdmFsaWRzfX0nLFxuICAgICAgICAnYW55LnJlZic6ICdcInt7I2xhYmVsfX1cIiB7eyNhcmd9fSByZWZlcmVuY2VzIFwie3sjcmVmfX1cIiB3aGljaCB7eyNyZWFzb259fScsXG4gICAgICAgICdhbnkucmVxdWlyZWQnOiAnXCJ7eyNsYWJlbH19XCIgaXMgcmVxdWlyZWQnLFxuICAgICAgICAnYW55LnVua25vd24nOiAnXCJ7eyNsYWJlbH19XCIgaXMgbm90IGFsbG93ZWQnXG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdhcnJheScsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNpbmdsZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICBzcGFyc2U6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGl0ZW1zOiB7IGluaXQ6IFtdLCBtYW5pZmVzdDogJ3NjaGVtYScgfSxcbiAgICAgICAgb3JkZXJlZDogeyBpbml0OiBbXSwgbWFuaWZlc3Q6ICdzY2hlbWEnIH0sXG5cbiAgICAgICAgX2V4Y2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX2luY2x1c2lvbnM6IHsgaW5pdDogW10gfSxcbiAgICAgICAgX3JlcXVpcmVkczogeyBpbml0OiBbXSB9XG4gICAgfSxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnb2JqZWN0JyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHNjaGVtYS4kX2dldFJ1bGUoJ3NvcnQnKTtcbiAgICAgICAgICAgIGlmICghc29ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIHNvcnQuYXJncy5vcHRpb25zLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLnNpbmdsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpbmdsZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgc2luZ2xlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHNpbmdsZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVycm9yKCdhcnJheS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfZ2V0UnVsZSgnaXRlbXMnKSAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKSB9OyAgICAgICAgLy8gQ2xvbmUgdGhlIGFycmF5IHNvIHRoYXQgd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGhhczoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy4kX2NvbXBpbGUoc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaGFzJywgYXJnczogeyBzY2hlbWEgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgc3RhdGUsIHByZWZzLCBlcnJvciB9LCB7IHNjaGVtYTogaGFzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIGFuY2VzdG9ycywgaGFzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcy4kX21hdGNoKHZhbHVlW2ldLCBsb2NhbFN0YXRlLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5MYWJlbCA9IGhhcy5fZmxhZ3MubGFiZWw7XG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5MYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5Lmhhc0tub3duJywgeyBwYXR0ZXJuTGFiZWwgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5oYXNVbmtub3duJywgbnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICdpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLml0ZW1zLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRzID0gc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWRzID0gc2NoZW1hLiRfdGVybXMub3JkZXJlZC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluY2x1c2lvbnMgPSBbLi4uc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMsIC4uLnJlcXVpcmVkc107XG5cbiAgICAgICAgICAgICAgICBjb25zdCB3YXNBcnJheSA9ICF2YWx1ZVtDb21tb24uc3ltYm9scy5hcnJheVNpbmdsZV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBpbCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gd2FzQXJyYXkgPyBpIDogbmV3IE51bWJlcihpKTsgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IFsuLi5zdGF0ZS5wYXRoLCBrZXldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYXJzZVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGNsdXNpb25zXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXhjbHVzaW9uIG9mIHNjaGVtYS4kX3Rlcm1zLl9leGNsdXNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4Y2x1c2lvbi4kX21hdGNoKGl0ZW0sIHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgZXhjbHVzaW9uKSwgcHJlZnMsIHsgcHJlc2VuY2U6ICdpZ25vcmUnIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5leGNsdWRlcycsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9yZGVyZWRcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMub3JkZXJlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkID0gb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBvcmRlcmVkLiRfdmFsaWRhdGUoaXRlbSwgc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBvcmRlcmVkKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJlZC5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJiByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLiRfdGVybXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5Lm9yZGVyZWRMZW5ndGgnLCB7IHBvczogaSwgbGltaXQ6IHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQubGVuZ3RoIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgIC8vIE5vIHJlYXNvbiB0byBjb250aW51ZSBzaW5jZSB0aGVyZSBhcmUgbm8gb3RoZXIgcnVsZXMgdG8gdmFsaWRhdGUgb3RoZXIgdGhhbiBhcnJheS5vcmRlcmVkTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXF1aXJlZHNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZENoZWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgamwgPSByZXF1aXJlZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIHJlcXVpcmVkc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHJlcXVpcmVkc1tqXS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQ2hlY2tzW2pdID0gcmVzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShyZXF1aXJlZHMsIGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWpsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVzaW9uc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwVW5rbm93biA9IHByZWZzLnN0cmlwVW5rbm93biAmJiAhIXByZWZzLnN0cmlwVW5rbm93bi5hcnJheXMgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgamwgPSBpbmNsdXNpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmNsdXNpb24gb2YgaW5jbHVzaW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCByZS1ydW5uaW5nIHJlcXVpcmVkcyB0aGF0IGFscmVhZHkgZGlkbid0IG1hdGNoIGluIHRoZSBwcmV2aW91cyBsb29wXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NoZWNrID0gcmVxdWlyZWRzLmluZGV4T2YoaW5jbHVzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NoZWNrICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcXVpcmVkQ2hlY2tzW3ByZXZpb3VzQ2hlY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgaW5jbHVzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBpbmNsdXNpb24uJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNsdXNpb24uX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghc2NoZW1hLl9mbGFncy5zcGFyc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBlcnJvciBpZiBvbmx5IG9uZSBpbmNsdXNpb24gZGVmaW5lZFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoamwgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc1ZhbGlkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5pbmNsdWRlcycsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbE9yZGVyZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IHZhbHVlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcHJpb3JpdHk6IHRydWUsXG4gICAgICAgICAgICBtYW5pZmVzdDogZmFsc2VcbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc9JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5sZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdhcnJheS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9yZGVyZWQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChzY2hlbWFzLCAnb3JkZXJlZCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiB0aGlzLiRfY29tcGlsZShzY2hlbWFzW2ldKSwgaSwgeyBhcHBlbmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBvYmopO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5vcmRlcmVkLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzaW5nbGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF2YWx1ZSB8fCAhdGhpcy5fZmxhZ3MuX2FycmF5SXRlbXMsICdDYW5ub3Qgc3BlY2lmeSBzaW5nbGUgcnVsZSB3aGVuIGFycmF5IGhhcyBhcnJheSBpdGVtcycpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdzaW5nbGUnLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc29ydDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydieScsICdvcmRlciddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogb3B0aW9ucy5vcmRlciB8fCAnYXNjZW5kaW5nJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieSkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5ieSA9IENvbXBpbGUucmVmKG9wdGlvbnMuYnksIHsgYW5jZXN0b3I6IDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghc2V0dGluZ3MuYnkuYW5jZXN0b3IsICdDYW5ub3Qgc29ydCBieSBhbmNlc3RvcicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdzb3J0JywgYXJnczogeyBvcHRpb25zOiBzZXR0aW5ncyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYSB9LCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogc29ydGVkLCBlcnJvcnMgfSA9IGludGVybmFscy5zb3J0KHNjaGVtYSwgdmFsdWUsIG9wdGlvbnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlW2ldICE9PSBzb3J0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuc29ydCcsIHsgb3JkZXI6IG9wdGlvbnMub3JkZXIsIGJ5OiBvcHRpb25zLmJ5ID8gb3B0aW9ucy5ieS5rZXkgOiAndmFsdWUnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzcGFyc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3Muc3BhcnNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB2YWx1ZSA/IHRoaXMuY2xvbmUoKSA6IHRoaXMuJF9hZGRSdWxlKCdpdGVtcycpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9zZXRGbGFnKCdzcGFyc2UnLCB2YWx1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5pcXVlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29tcGFyYXRvciwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoIWNvbXBhcmF0b3IgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdzdHJpbmcnLCAnY29tcGFyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2lnbm9yZVVuZGVmaW5lZCcsICdzZXBhcmF0b3InXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0geyBuYW1lOiAndW5pcXVlJywgYXJnczogeyBvcHRpb25zLCBjb21wYXJhdG9yIH0gfTtcblxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IENvbW1vbi5kZWZhdWx0KG9wdGlvbnMuc2VwYXJhdG9yLCAnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5wYXRoID0gc2VwYXJhdG9yID8gY29tcGFyYXRvci5zcGxpdChzZXBhcmF0b3IpIDogW2NvbXBhcmF0b3JdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZShydWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzdGF0ZSwgZXJyb3IsIHNjaGVtYSB9LCB7IGNvbXBhcmF0b3I6IHJhdywgb3B0aW9ucyB9LCB7IGNvbXBhcmF0b3IsIHBhdGggfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZzogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbjogbmV3IE1hcCgpLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b206IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlID0gY29tcGFyYXRvciB8fCBEZWVwRXF1YWw7XG4gICAgICAgICAgICAgICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwYXRoID8gUmVhY2godmFsdWVbaV0sIHBhdGgpIDogdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZHMgPSBjb21wYXJhdG9yID8gZm91bmQuY3VzdG9tIDogZm91bmRbdHlwZW9mIGl0ZW1dO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQocmVjb3JkcywgJ0ZhaWxlZCB0byBmaW5kIHVuaXF1ZSBtYXAgY29udGFpbmVyIGZvciB0eXBlJywgdHlwZW9mIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gcmVjb3Jkcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghKGN1cnJlbnQgPSBlbnRyaWVzLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGN1cnJlbnQudmFsdWVbMF0sIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlUG9zOiBjdXJyZW50LnZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtjdXJyZW50LnZhbHVlWzFdXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkcy5zZXQoaXRlbSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCFpZ25vcmVVbmRlZmluZWQgfHwgaXRlbSAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZHNbaXRlbV0gIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IHJlY29yZHNbaXRlbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVWYWx1ZTogdmFsdWVbcmVjb3Jkc1tpdGVtXV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5wYXRoID0gcmF3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgaV0sIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS51bmlxdWUnLCBjb250ZXh0LCBsb2NhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb21wYXJhdG9yJywgJ29wdGlvbnMnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgIGZyb206IEFycmF5LmlzQXJyYXksXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX2luY2x1c2lvbnMgPSBbXTtcbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMgPSBbXTtcbiAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcyA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBzY2hlbWEuJF90ZXJtcy5pdGVtcykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9yZXF1aXJlZHMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9leGNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLm9yZGVyZWQpIHtcbiAgICAgICAgICAgIGludGVybmFscy52YWxpZGF0ZVNpbmdsZSh0eXBlLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLml0ZW1zKC4uLmRlc2MuaXRlbXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5vcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLm9yZGVyZWQoLi4uZGVzYy5vcmRlcmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYXJyYXkuYmFzZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGFuIGFycmF5JyxcbiAgICAgICAgJ2FycmF5LmV4Y2x1ZGVzJzogJ1wie3sjbGFiZWx9fVwiIGNvbnRhaW5zIGFuIGV4Y2x1ZGVkIHZhbHVlJyxcbiAgICAgICAgJ2FycmF5Lmhhc0tub3duJzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoIGZvciB0eXBlIFwieyNwYXR0ZXJuTGFiZWx9XCInLFxuICAgICAgICAnYXJyYXkuaGFzVW5rbm93bic6ICdcInt7I2xhYmVsfX1cIiBkb2VzIG5vdCBjb250YWluIGF0IGxlYXN0IG9uZSByZXF1aXJlZCBtYXRjaCcsXG4gICAgICAgICdhcnJheS5pbmNsdWRlcyc6ICdcInt7I2xhYmVsfX1cIiBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIGFsbG93ZWQgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnOiAnXCJ7eyNsYWJlbH19XCIgZG9lcyBub3QgY29udGFpbiB7eyNrbm93bk1pc3Nlc319IGFuZCB7eyN1bmtub3duTWlzc2VzfX0gb3RoZXIgcmVxdWlyZWQgdmFsdWUocyknLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEtub3ducyc6ICdcInt7I2xhYmVsfX1cIiBkb2VzIG5vdCBjb250YWluIHt7I2tub3duTWlzc2VzfX0nLFxuICAgICAgICAnYXJyYXkuaW5jbHVkZXNSZXF1aXJlZFVua25vd25zJzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IGNvbnRhaW4ge3sjdW5rbm93bk1pc3Nlc319IHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgJ2FycmF5Lmxlbmd0aCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGNvbnRhaW4ge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5tYXgnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBjb250YWluIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm1pbic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5vcmRlcmVkTGVuZ3RoJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgY29udGFpbiBhdCBtb3N0IHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkuc29ydCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIHNvcnRlZCBpbiB7I29yZGVyfSBvcmRlciBieSB7eyNieX19JyxcbiAgICAgICAgJ2FycmF5LnNvcnQubWlzbWF0Y2hpbmcnOiAnXCJ7eyNsYWJlbH19XCIgY2Fubm90IGJlIHNvcnRlZCBkdWUgdG8gbWlzbWF0Y2hpbmcgdHlwZXMnLFxuICAgICAgICAnYXJyYXkuc29ydC51bnN1cHBvcnRlZCc6ICdcInt7I2xhYmVsfX1cIiBjYW5ub3QgYmUgc29ydGVkIGR1ZSB0byB1bnN1cHBvcnRlZCB0eXBlIHsjdHlwZX0nLFxuICAgICAgICAnYXJyYXkuc3BhcnNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3Qgbm90IGJlIGEgc3BhcnNlIGFycmF5IGl0ZW0nLFxuICAgICAgICAnYXJyYXkudW5pcXVlJzogJ1wie3sjbGFiZWx9fVwiIGNvbnRhaW5zIGEgZHVwbGljYXRlIHZhbHVlJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qga25vd25NaXNzZXMgPSBbXTtcbiAgICBsZXQgdW5rbm93bk1pc3NlcyA9IDA7XG4gICAgZm9yIChjb25zdCByZXF1aXJlZCBvZiByZXF1aXJlZHMpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSByZXF1aXJlZC5fZmxhZ3MubGFiZWw7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAga25vd25NaXNzZXMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICArK3Vua25vd25NaXNzZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa25vd25NaXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh1bmtub3duTWlzc2VzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZEJvdGgnLCB2YWx1ZSwgeyBrbm93bk1pc3NlcywgdW5rbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJywgdmFsdWUsIHsga25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnLCB2YWx1ZSwgeyB1bmtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZpbGxPcmRlcmVkRXJyb3JzID0gZnVuY3Rpb24gKHNjaGVtYSwgZXJyb3JzLCBvcmRlcmVkcywgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3QgcmVxdWlyZWRPcmRlcmVkcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBvcmRlcmVkIG9mIG9yZGVyZWRzKSB7XG4gICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmVxdWlyZWRPcmRlcmVkcy5wdXNoKG9yZGVyZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVpcmVkT3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgIGludGVybmFscy5maWxsTWlzc2VkRXJyb3JzKHNjaGVtYSwgZXJyb3JzLCByZXF1aXJlZE9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5mYXN0U3BsaWNlID0gZnVuY3Rpb24gKGFyciwgaSkge1xuXG4gICAgbGV0IHBvcyA9IGk7XG4gICAgd2hpbGUgKHBvcyA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgYXJyW3BvcysrXSA9IGFycltwb3NdO1xuICAgIH1cblxuICAgIC0tYXJyLmxlbmd0aDtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlID0gZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuXG4gICAgaWYgKHR5cGUudHlwZSA9PT0gJ2FycmF5JyB8fFxuICAgICAgICB0eXBlLl9mbGFncy5fYXJyYXlJdGVtcykge1xuXG4gICAgICAgIEFzc2VydCghb2JqLl9mbGFncy5zaW5nbGUsICdDYW5ub3Qgc3BlY2lmeSBhcnJheSBpdGVtIHdpdGggc2luZ2xlIHJ1bGUgZW5hYmxlZCcpO1xuICAgICAgICBvYmouJF9zZXRGbGFnKCdfYXJyYXlJdGVtcycsIHRydWUsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNvcnQgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc2V0dGluZ3MsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgY29uc3Qgb3JkZXIgPSBzZXR0aW5ncy5vcmRlciA9PT0gJ2FzY2VuZGluZycgPyAxIDogLTE7XG4gICAgY29uc3QgYUZpcnN0ID0gLTEgKiBvcmRlcjtcbiAgICBjb25zdCBiRmlyc3QgPSBvcmRlcjtcblxuICAgIGNvbnN0IHNvcnQgPSAoYSwgYikgPT4ge1xuXG4gICAgICAgIGxldCBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUoYSwgYiwgYUZpcnN0LCBiRmlyc3QpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYnkpIHtcbiAgICAgICAgICAgIGEgPSBzZXR0aW5ncy5ieS5yZXNvbHZlKGEsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBiID0gc2V0dGluZ3MuYnkucmVzb2x2ZShiLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tcGFyZSA9IGludGVybmFscy5jb21wYXJlKGEsIGIsIGFGaXJzdCwgYkZpcnN0KTtcbiAgICAgICAgaWYgKGNvbXBhcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhO1xuICAgICAgICBpZiAodHlwZSAhPT0gdHlwZW9mIGIpIHtcbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0Lm1pc21hdGNoaW5nJywgdmFsdWUsIG51bGwsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgIHRocm93IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5zb3J0LnVuc3VwcG9ydGVkJywgdmFsdWUsIHsgdHlwZSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEgLSBiKSAqIG9yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgPCBiID8gYUZpcnN0IDogYkZpcnN0O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUuc2xpY2UoKS5zb3J0KHNvcnQpIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnIgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIsIGFGaXJzdCwgYkZpcnN0KSB7XG5cbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAxOyAgICAgICAgICAgLy8gQWx3YXlzIGxhc3QgcmVnYXJkbGVzcyBvZiBzb3J0IG9yZGVyXG4gICAgfVxuXG4gICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gLTE7ICAgICAgICAgICAvLyBBbHdheXMgbGFzdCByZWdhcmRsZXNzIG9mIHNvcnQgb3JkZXJcbiAgICB9XG5cbiAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgIH1cblxuICAgIGlmIChiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhRmlyc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYmluYXJ5JyxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiAnc3RyaW5nJyxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSB9KSB7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IEJ1ZmZlci5mcm9tKHZhbHVlLCBzY2hlbWEuX2ZsYWdzLmVuY29kaW5nKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZUVycikgeyB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2JpbmFyeS5iYXNlJykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBlbmNvZGluZzoge1xuICAgICAgICAgICAgbWV0aG9kKGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2VuY29kaW5nJywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2JpbmFyeS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSksXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2JpbmFyeS5iYXNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcnLFxuICAgICAgICAnYmluYXJ5Lmxlbmd0aCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIHt7I2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICAnYmluYXJ5Lm1heCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGJ5dGVzJyxcbiAgICAgICAgJ2JpbmFyeS5taW4nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhdCBsZWFzdCB7eyNsaW1pdH19IGJ5dGVzJ1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgVmFsdWVzID0gcmVxdWlyZSgnLi4vdmFsdWVzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLmlzQm9vbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBzZW5zaXRpdmU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGZhbHN5OiB7XG4gICAgICAgICAgICBpbml0OiBudWxsLFxuICAgICAgICAgICAgbWFuaWZlc3Q6ICd2YWx1ZXMnXG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJ1dGh5OiB7XG4gICAgICAgICAgICBpbml0OiBudWxsLFxuICAgICAgICAgICAgbWFuaWZlc3Q6ICd2YWx1ZXMnXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlKHZhbHVlLCB7IHNjaGVtYSB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlID8gdmFsdWUgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFsdWUgPSBub3JtYWxpemVkID09PSAndHJ1ZScgPyB0cnVlIDogKG5vcm1hbGl6ZWQgPT09ICdmYWxzZScgPyBmYWxzZSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdmFsdWUgPSBzY2hlbWEuJF90ZXJtcy50cnV0aHkgJiYgc2NoZW1hLiRfdGVybXMudHJ1dGh5Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgIXNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlKSB8fFxuICAgICAgICAgICAgICAgIChzY2hlbWEuJF90ZXJtcy5mYWxzeSAmJiBzY2hlbWEuJF90ZXJtcy5mYWxzeS5oYXModmFsdWUsIG51bGwsIG51bGwsICFzY2hlbWEuX2ZsYWdzLnNlbnNpdGl2ZSkgPyBmYWxzZSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdib29sZWFuLmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIHRydXRoeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnZhbHVlcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAndHJ1dGh5Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMudHJ1dGh5ID0gb2JqLiRfdGVybXMudHJ1dGh5IHx8IG5ldyBWYWx1ZXMoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgdHJ1dGh5IHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnRydXRoeS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmFsc3k6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi52YWx1ZXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHZhbHVlcywgJ2ZhbHN5Jyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuZmFsc3kgPSBvYmouJF90ZXJtcy5mYWxzeSB8fCBuZXcgVmFsdWVzKCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIGZhbHN5IHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmZhbHN5LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZW5zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdzZW5zaXRpdmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzQm9vbCxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNCb29sLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MudHJ1dGh5KSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLnRydXRoeSguLi5kZXNjLnRydXRoeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmZhbHN5KSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLmZhbHN5KC4uLmRlc2MuZmFsc3kpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdib29sZWFuLmJhc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIGJvb2xlYW4nXG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4uL3RlbXBsYXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLmlzRGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdkYXRlJyxcblxuICAgIGNvZXJjZToge1xuICAgICAgICBmcm9tOiBbJ251bWJlcicsICdzdHJpbmcnXSxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSB9KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpbnRlcm5hbHMucGFyc2UodmFsdWUsIHNjaGVtYS5fZmxhZ3MuZm9ybWF0KSB8fCB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHByZWZzIH0pIHtcblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmXG4gICAgICAgICAgICAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmb3JtYXQgPSBzY2hlbWEuX2ZsYWdzLmZvcm1hdDtcblxuICAgICAgICBpZiAoIXByZWZzLmNvbnZlcnQgfHxcbiAgICAgICAgICAgICFmb3JtYXQgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2RhdGUuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignZGF0ZS5mb3JtYXQnLCB7IGZvcm1hdCB9KSB9O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbXBhcmU6IHtcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBkYXRlIH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSBkYXRlID09PSAnbm93JyA/IERhdGUubm93KCkgOiBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUuZ2V0VGltZSgpLCB0bywgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZGF0ZS4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5kYXRlLCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplOiAoZGF0ZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZSA9PT0gJ25vdycgPyBkYXRlIDogaW50ZXJuYWxzLnBhcnNlKGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IChkYXRlKSA9PiBkYXRlICE9PSBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBoYXZlIGEgdmFsaWQgZGF0ZSBmb3JtYXQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgbWV0aG9kKGZvcm1hdCkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnaXNvJywgJ2phdmFzY3JpcHQnLCAndW5peCddLmluY2x1ZGVzKGZvcm1hdCksICdVbmtub3duIGRhdGUgZm9ybWF0JywgZm9ybWF0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZm9ybWF0JywgZm9ybWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBncmVhdGVyOiB7XG4gICAgICAgICAgICBtZXRob2QoZGF0ZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2dyZWF0ZXInLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoJ2lzbycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlc3M6IHtcbiAgICAgICAgICAgIG1ldGhvZChkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVzcycsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc8JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJz49JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0aW1lc3RhbXA6IHtcbiAgICAgICAgICAgIG1ldGhvZCh0eXBlID0gJ2phdmFzY3JpcHQnKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydqYXZhc2NyaXB0JywgJ3VuaXgnXS5pbmNsdWRlcyh0eXBlKSwgJ1widHlwZVwiIG11c3QgYmUgb25lIG9mIFwiamF2YXNjcmlwdCwgdW5peFwiJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBudW1iZXI6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0RhdGUsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNEYXRlLFxuICAgICAgICAgICAgdG8odmFsdWUsIHsgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlLmRhdGUodmFsdWUsIHByZWZzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnZGF0ZS5iYXNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgaW4ge21zZyhcImRhdGUuZm9ybWF0LlwiICsgI2Zvcm1hdCkgfHwgI2Zvcm1hdH0gZm9ybWF0JyxcbiAgICAgICAgJ2RhdGUuZ3JlYXRlcic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcInt7I2xpbWl0fX1cIicsXG4gICAgICAgICdkYXRlLmxlc3MnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBsZXNzIHRoYW4gXCJ7eyNsaW1pdH19XCInLFxuICAgICAgICAnZGF0ZS5tYXgnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gXCJ7eyNsaW1pdH19XCInLFxuICAgICAgICAnZGF0ZS5taW4nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBsYXJnZXIgdGhhbiBvciBlcXVhbCB0byBcInt7I2xpbWl0fX1cIicsXG5cbiAgICAgICAgLy8gTWVzc2FnZXMgdXNlZCBpbiBkYXRlLmZvcm1hdFxuXG4gICAgICAgICdkYXRlLmZvcm1hdC5pc28nOiAnSVNPIDg2MDEgZGF0ZScsXG4gICAgICAgICdkYXRlLmZvcm1hdC5qYXZhc2NyaXB0JzogJ3RpbWVzdGFtcCBvciBudW1iZXIgb2YgbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LnVuaXgnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBzZWNvbmRzJ1xuICAgIH1cbn0pO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLnBhcnNlID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAgICAgIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkpIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoL15cXHMqJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gSVNPXG5cbiAgICBpZiAoZm9ybWF0ID09PSAnaXNvJykge1xuICAgICAgICBpZiAoIUNvbW1vbi5pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgbnVtYmVyIHN0cmluZ1xuXG4gICAgY29uc3Qgb3JpZ2luYWwgPSB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAvXlsrLV0/XFxkKyhcXC5cXGQrKT8kLy50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gVGltZXN0YW1wXG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqYXZhc2NyaXB0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKDEgKiB2YWx1ZSk7ICAgICAgICAvLyBDYXN0aW5nIHRvIG51bWJlclxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3VuaXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMTAwMCAqIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBsYWluXG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUodmFsdWUpO1xufTtcblxuXG5pbnRlcm5hbHMuZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBLZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBLZXlzLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlb2Y6ICdmdW5jdGlvbidcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgYXJpdHk6IHtcbiAgICAgICAgICAgIG1ldGhvZChuKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+PSAwLCAnbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2FyaXR5JywgYXJnczogeyBuIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24uYXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnY2xhc3MnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKCgvXlxccypjbGFzc1xccy8pLnRlc3QodmFsdWUudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5jbGFzcycsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluQXJpdHk6IHtcbiAgICAgICAgICAgIG1ldGhvZChuKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobikgJiYgbiA+IDAsICduIG11c3QgYmUgYSBzdHJpY3QgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbkFyaXR5JywgYXJnczogeyBuIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5taW5Bcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXhBcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4QXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1heEFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdmdW5jdGlvbi5hcml0eSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGhhdmUgYW4gYXJpdHkgb2Yge3sjbn19JyxcbiAgICAgICAgJ2Z1bmN0aW9uLmNsYXNzJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBjbGFzcycsXG4gICAgICAgICdmdW5jdGlvbi5tYXhBcml0eSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGhhdmUgYW4gYXJpdHkgbGVzc2VyIG9yIGVxdWFsIHRvIHt7I259fScsXG4gICAgICAgICdmdW5jdGlvbi5taW5Bcml0eSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGhhdmUgYW4gYXJpdHkgZ3JlYXRlciBvciBlcXVhbCB0byB7eyNufX0nXG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFwcGx5VG9EZWZhdWx0cyA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2FwcGx5VG9EZWZhdWx0cycpO1xuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBUb3BvID0gcmVxdWlyZSgnQGhhcGkvdG9wbycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi9yZWYnKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcmVuYW1lRGVmYXVsdHM6IHtcbiAgICAgICAgYWxpYXM6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9sZCB2YWx1ZSBpbiBwbGFjZVxuICAgICAgICBtdWx0aXBsZTogZmFsc2UsICAgICAgICAgICAgICAgIC8vIEFsbG93IHJlbmFtaW5nIG11bHRpcGxlIGtleXMgaW50byB0aGUgc2FtZSB0YXJnZXRcbiAgICAgICAgb3ZlcnJpZGU6IGZhbHNlICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZXMgYW4gZXhpc3Rpbmcga2V5XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ19rZXlzJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZW9mOiAnb2JqZWN0J1xuICAgIH0sXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHVua25vd246IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIGRlcGVuZGVuY2llczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGtleXM6IHsgaW5pdDogbnVsbCwgbWFuaWZlc3Q6IHsgbWFwcGVkOiB7IGZyb206ICdzY2hlbWEnLCB0bzogJ2tleScgfSB9IH0sXG4gICAgICAgIHBhdHRlcm5zOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAgcmVuYW1lczogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIGtleXMpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLmtleXMoa2V5cyk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSBzY2hlbWEuJF9wcm9wZXJ0eSgndHlwZW9mJykgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdvYmplY3QuYmFzZScsIHsgdHlwZTogc2NoZW1hLiRfcHJvcGVydHkoJ3R5cGVvZicpIH0pIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTa2lwIGlmIHRoZXJlIGFyZSBubyBvdGhlciBydWxlcyB0byB0ZXN0XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF90ZXJtcy5yZW5hbWVzICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMua2V5cyAmJiAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaGFsbG93IGNsb25lIHZhbHVlXG5cbiAgICAgICAgdmFsdWUgPSBpbnRlcm5hbHMuY2xvbmUodmFsdWUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICAgICAgLy8gUmVuYW1lIGtleXNcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMucmVuYW1lcyAmJlxuICAgICAgICAgICAgIWludGVybmFscy5yZW5hbWUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBlcnJvcnMpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFueXRoaW5nIGFsbG93ZWRcblxuICAgICAgICBpZiAoIXNjaGVtYS4kX3Rlcm1zLmtleXMgJiYgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgYWxsb3dzIGFueSBrZXlzXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lZCBrZXlzXG5cbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGtleV0sIGFuY2VzdG9ycywgY2hpbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoaWxkLnNjaGVtYS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXN1bHQuZXJyb3JzIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQuc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID09PSB1bmRlZmluZWQgJiYgaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5rbm93biBrZXlzXG5cbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVhcmx5ID0gaW50ZXJuYWxzLnVua25vd24oc2NoZW1hLCB2YWx1ZSwgdW5wcm9jZXNzZWQsIGVycm9ycywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGlmIChlYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYXJseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIGRlcGVuZGVuY2llc1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZGVwIG9mIHNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGlmIChkZXAua2V5ICYmXG4gICAgICAgICAgICAgICAgICAgIGRlcC5rZXkucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGZhaWxlZCA9IGludGVybmFscy5kZXBlbmRlbmNpZXNbZGVwLnJlbF0oc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoZmFpbGVkLmNvZGUsIHZhbHVlLCBmYWlsZWQuY29udGV4dCwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlcG9ydCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgYW5kOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICdhbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnYW5kJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFwcGVuZDoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMoc2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhc3NlcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICAgICAgICAgIGlmICghVGVtcGxhdGUuaXNUZW1wbGF0ZShzdWJqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICBzdWJqZWN0ID0gQ29tcGlsZS5yZWYoc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycsICdNZXNzYWdlIG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXNzZXJ0JywgYXJnczogeyBzdWJqZWN0LCBzY2hlbWEsIG1lc3NhZ2UgfSB9KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzdWJqZWN0KTtcbiAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IsIHByZWZzLCBzdGF0ZSB9LCB7IHN1YmplY3QsIHNjaGVtYSwgbWVzc2FnZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhYm91dCA9IHN1YmplY3QucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gUmVmLmlzUmVmKHN1YmplY3QpID8gc3ViamVjdC5hYnNvbHV0ZShzdGF0ZSkgOiBbXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLiRfbWF0Y2goYWJvdXQsIHN0YXRlLmxvY2FsaXplKHBhdGgsIFt2YWx1ZSwgLi4uc3RhdGUuYW5jZXN0b3JzXSwgc2NoZW1hKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ29iamVjdC5hc3NlcnQnLCB7IHN1YmplY3QsIG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydzdWJqZWN0JywgJ3NjaGVtYScsICdtZXNzYWdlJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluc3RhbmNlOiB7XG4gICAgICAgICAgICBtZXRob2QoY29uc3RydWN0b3IsIG5hbWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicsICdjb25zdHJ1Y3RvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaW5zdGFuY2UnLCBhcmdzOiB7IGNvbnN0cnVjdG9yLCBuYW1lIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgY29uc3RydWN0b3IsIG5hbWUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QuaW5zdGFuY2UnLCB7IHR5cGU6IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnY29uc3RydWN0b3InLCAnbmFtZSddXG4gICAgICAgIH0sXG5cbiAgICAgICAga2V5czoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnLCAnT2JqZWN0IHNjaGVtYSBtdXN0IGJlIGEgdmFsaWQgb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ09iamVjdCBzY2hlbWEgY2Fubm90IGJlIGEgam9pIHNjaGVtYScpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFsbFxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5rZXlzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoKSB7ICAgICAgICAgICAgIC8vIEFsbG93IG5vbmVcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMua2V5cyA9IG9iai4kX3Rlcm1zLmtleXMgPyBvYmouJF90ZXJtcy5rZXlzLmZpbHRlcigoY2hpbGQpID0+ICFzY2hlbWEuaGFzT3duUHJvcGVydHkoY2hpbGQua2V5KSkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gb2JqLiRfdGVybXMua2V5cy5wdXNoKHsga2V5LCBzY2hlbWE6IHRoaXMuJF9jb21waWxlKHNjaGVtYVtrZXldKSB9KSwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5saW1pdCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5hbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ25hbmQnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnbmFuZCcsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnb3InKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3hvcjoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAnb3hvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVnRXhwID0gcGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLiRfY29tcGlsZShwYXR0ZXJuLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYSAhPT0gdW5kZWZpbmVkLCAnSW52YWxpZCBydWxlJyk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydmYWxsdGhyb3VnaCcsICdtYXRjaGVzJ10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCghcGF0dGVybi5mbGFncy5pbmNsdWRlcygnZycpICYmICFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCd5JyksICdwYXR0ZXJuIHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuJF9jb21waWxlKHNjaGVtYSwgeyBhcHBlbmRQYXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnBhdHRlcm5zID0gb2JqLiRfdGVybXMucGF0dGVybnMgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0geyBbaXNSZWdFeHAgPyAncmVnZXgnIDogJ3NjaGVtYSddOiBwYXR0ZXJuLCBydWxlOiBzY2hlbWEgfTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gdGhpcy4kX2NvbXBpbGUob3B0aW9ucy5tYXRjaGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXRjaGVzLnR5cGUgIT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5tYXRjaGVzID0gY29uZmlnLm1hdGNoZXMuJF9yb290LmFycmF5KCkuaXRlbXMoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoY29uZmlnLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmZhbGx0aHJvdWdoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5mYWxsdGhyb3VnaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucGF0dGVybnMucHVzaChjb25maWcpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncmVmJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChSZWYuaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnJlZlR5cGUnLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmFtZToge1xuICAgICAgICAgICAgbWV0aG9kKGZyb20sIHRvLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZnJvbSA9PT0gJ3N0cmluZycgfHwgZnJvbSBpbnN0YW5jZW9mIFJlZ0V4cCwgJ1JlbmFtZSBtaXNzaW5nIHRoZSBmcm9tIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHwgdG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSwgJ0ludmFsaWQgcmVuYW1lIHRvIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHRvICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSBrZXkgdG8gc2FtZSBuYW1lOicsIGZyb20pO1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGlhcycsICdpZ25vcmVVbmRlZmluZWQnLCAnb3ZlcnJpZGUnLCAnbXVsdGlwbGUnXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5yZW5hbWVzID0gb2JqLiRfdGVybXMucmVuYW1lcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbmFtZSBvZiBvYmouJF90ZXJtcy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChyZW5hbWUuZnJvbSAhPT0gZnJvbSwgJ0Nhbm5vdCByZW5hbWUgdGhlIHNhbWUga2V5IG11bHRpcGxlIHRpbWVzJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRvIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIodG8pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlbmFtZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBBcHBseVRvRGVmYXVsdHMoaW50ZXJuYWxzLnJlbmFtZURlZmF1bHRzLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIG1ldGhvZCh0eXBlID0gJ2FueScpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdzY2hlbWEnLCBhcmdzOiB7IHR5cGUgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyB0eXBlIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlID09PSAnYW55JyB8fCB2YWx1ZS50eXBlID09PSB0eXBlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LnNjaGVtYScsIHsgdHlwZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmtub3duOiB7XG4gICAgICAgICAgICBtZXRob2QoYWxsb3cpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5rbm93bicsIGFsbG93ICE9PSBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2l0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGtleSwgcGVlcnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICd3aXRoJywga2V5LCBwZWVycywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd2l0aG91dDoge1xuICAgICAgICAgICAgbWV0aG9kKGtleSwgcGVlcnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICd3aXRob3V0Jywga2V5LCBwZWVycywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgeG9yOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICd4b3InKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGVwZW5kZW5jeSh0aGlzLCAneG9yJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG92ZXJyaWRlczoge1xuXG4gICAgICAgIGRlZmF1bHQodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kX3N1cGVyLmRlZmF1bHQodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlYnVpbGQoc2NoZW1hKSB7XG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcG8gPSBuZXcgVG9wbygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBzY2hlbWEuJF90ZXJtcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRvcG8uYWRkKGNoaWxkLCB7IGFmdGVyOiBjaGlsZC5zY2hlbWEuJF9yb290UmVmZXJlbmNlcygpLCBncm91cDogY2hpbGQua2V5IH0pLCBjaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY2hlbWEuJF90ZXJtcy5rZXlzID0gbmV3IGludGVybmFscy5LZXlzKC4uLnRvcG8ubm9kZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmtleXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoua2V5cyhkZXNjLmtleXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVsLCBrZXkgPSBudWxsLCBwZWVycywgb3B0aW9ucyB9IG9mIGRlc2MuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGludGVybmFscy5kZXBlbmRlbmN5KG9iaiwgcmVsLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHJlZ2V4LCBzY2hlbWEsIHJ1bGUsIGZhbGx0aHJvdWdoLCBtYXRjaGVzIH0gb2YgZGVzYy5wYXR0ZXJucykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucGF0dGVybihyZWdleCB8fCBzY2hlbWEsIHJ1bGUsIHsgZmFsbHRocm91Z2gsIG1hdGNoZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGZyb20sIHRvLCBvcHRpb25zIH0gb2YgZGVzYy5yZW5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5yZW5hbWUoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnb2JqZWN0LmFuZCc6ICdcInt7I2xhYmVsfX1cIiBjb250YWlucyB7eyNwcmVzZW50V2l0aExhYmVsc319IHdpdGhvdXQgaXRzIHJlcXVpcmVkIHBlZXJzIHt7I21pc3NpbmdXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LmFzc2VydCc6ICdcInt7I2xhYmVsfX1cIiBpcyBpbnZhbGlkIGJlY2F1c2Uge2lmKCNzdWJqZWN0LmtleSwgYFwiYCArICNzdWJqZWN0LmtleSArIGBcIiBmYWlsZWQgdG8gYCArICgjbWVzc2FnZSB8fCBcInBhc3MgdGhlIGFzc2VydGlvbiB0ZXN0XCIpLCAjbWVzc2FnZSB8fCBcInRoZSBhc3NlcnRpb24gZmFpbGVkXCIpfScsXG4gICAgICAgICdvYmplY3QuYmFzZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIG9mIHR5cGUge3sjdHlwZX19JyxcbiAgICAgICAgJ29iamVjdC5pbnN0YW5jZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFwie3sjdHlwZX19XCInLFxuICAgICAgICAnb2JqZWN0Lmxlbmd0aCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGhhdmUge3sjbGltaXR9fSBrZXl7aWYoI2xpbWl0ID09IDEsIFwiXCIsIFwic1wiKX0nLFxuICAgICAgICAnb2JqZWN0Lm1heCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taW4nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBoYXZlIGF0IGxlYXN0IHt7I2xpbWl0fX0ga2V5e2lmKCNsaW1pdCA9PSAxLCBcIlwiLCBcInNcIil9JyxcbiAgICAgICAgJ29iamVjdC5taXNzaW5nJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgb2Yge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0Lm5hbmQnOiAnXCJ7eyNtYWluV2l0aExhYmVsfX1cIiBtdXN0IG5vdCBleGlzdCBzaW11bHRhbmVvdXNseSB3aXRoIHt7I3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgJ29iamVjdC5veG9yJzogJ1wie3sjbGFiZWx9fVwiIGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBvcHRpb25hbCBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0LnBhdHRlcm4ubWF0Y2gnOiAnXCJ7eyNsYWJlbH19XCIga2V5cyBmYWlsZWQgdG8gbWF0Y2ggcGF0dGVybiByZXF1aXJlbWVudHMnLFxuICAgICAgICAnb2JqZWN0LnJlZlR5cGUnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIEpvaSByZWZlcmVuY2UnLFxuICAgICAgICAnb2JqZWN0LnJlbmFtZS5tdWx0aXBsZSc6ICdcInt7I2xhYmVsfX1cIiBjYW5ub3QgcmVuYW1lIFwie3sjZnJvbX19XCIgYmVjYXVzZSBtdWx0aXBsZSByZW5hbWVzIGFyZSBkaXNhYmxlZCBhbmQgYW5vdGhlciBrZXkgd2FzIGFscmVhZHkgcmVuYW1lZCB0byBcInt7I3RvfX1cIicsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm92ZXJyaWRlJzogJ1wie3sjbGFiZWx9fVwiIGNhbm5vdCByZW5hbWUgXCJ7eyNmcm9tfX1cIiBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQgXCJ7eyN0b319XCIgZXhpc3RzJyxcbiAgICAgICAgJ29iamVjdC5zY2hlbWEnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIEpvaSBzY2hlbWEgb2Yge3sjdHlwZX19IHR5cGUnLFxuICAgICAgICAnb2JqZWN0LnVua25vd24nOiAnXCJ7eyNsYWJlbH19XCIgaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICAnb2JqZWN0LndpdGgnOiAnXCJ7eyNtYWluV2l0aExhYmVsfX1cIiBtaXNzaW5nIHJlcXVpcmVkIHBlZXIgXCJ7eyNwZWVyV2l0aExhYmVsfX1cIicsXG4gICAgICAgICdvYmplY3Qud2l0aG91dCc6ICdcInt7I21haW5XaXRoTGFiZWx9fVwiIGNvbmZsaWN0IHdpdGggZm9yYmlkZGVuIHBlZXIgXCJ7eyNwZWVyV2l0aExhYmVsfX1cIicsXG4gICAgICAgICdvYmplY3QueG9yJzogJ1wie3sjbGFiZWx9fVwiIGNvbnRhaW5zIGEgY29uZmxpY3QgYmV0d2VlbiBleGNsdXNpdmUgcGVlcnMge3sjcGVlcnNXaXRoTGFiZWxzfX0nXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuY2xvbmUgPSBmdW5jdGlvbiAodmFsdWUsIHByZWZzKSB7XG5cbiAgICAvLyBPYmplY3RcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChwcmVmcy5ub25FbnVtZXJhYmxlcykge1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKHZhbHVlLCB7IHNoYWxsb3c6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oY2xvbmUsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9uXG5cbiAgICBjb25zdCBjbG9uZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBjbG9uZS5wcm90b3R5cGUgPSBDbG9uZSh2YWx1ZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwgJ25hbWUnLCB7IHZhbHVlOiB2YWx1ZS5uYW1lLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbGVuZ3RoJywgeyB2YWx1ZTogdmFsdWUubGVuZ3RoLCB3cml0YWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgIHJldHVybiBjbG9uZTtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY3kgPSBmdW5jdGlvbiAoc2NoZW1hLCByZWwsIGtleSwgcGVlcnMsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChrZXkgPT09IG51bGwgfHwgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycsIHJlbCwgJ2tleSBtdXN0IGJlIGEgc3RyaW5ncycpO1xuXG4gICAgLy8gRXh0cmFjdCBvcHRpb25zIGZyb20gcGVlcnMgYXJyYXlcblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gcGVlcnMubGVuZ3RoID4gMSAmJiB0eXBlb2YgcGVlcnNbcGVlcnMubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gcGVlcnMucG9wKCkgOiB7fTtcbiAgICB9XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3NlcGFyYXRvciddKTtcblxuICAgIHBlZXJzID0gW10uY29uY2F0KHBlZXJzKTtcblxuICAgIC8vIENhc3QgcGVlciBwYXRoc1xuXG4gICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBlZXIgb2YgcGVlcnMpIHtcbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBwZWVyID09PSAnc3RyaW5nJywgcmVsLCAncGVlcnMgbXVzdCBiZSBhIHN0cmluZyBvciBhIHJlZmVyZW5jZScpO1xuICAgICAgICBwYXRocy5wdXNoKENvbXBpbGUucmVmKHBlZXIsIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCB9KSk7XG4gICAgfVxuXG4gICAgLy8gQ2FzdCBrZXlcblxuICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAga2V5ID0gQ29tcGlsZS5yZWYoa2V5LCB7IHNlcGFyYXRvciwgYW5jZXN0b3I6IDAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJ1bGVcblxuICAgIGNvbnN0IG9iaiA9IHNjaGVtYS5jbG9uZSgpO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcyA9IG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcyB8fCBbXTtcbiAgICBvYmouJF90ZXJtcy5kZXBlbmRlbmNpZXMucHVzaChuZXcgaW50ZXJuYWxzLkRlcGVuZGVuY3kocmVsLCBrZXksIHBhdGhzLCBwZWVycykpO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5kZXBlbmRlbmNpZXMgPSB7XG5cbiAgICBhbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBkZXAucGVlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGggIT09IGNvdW50ICYmXG4gICAgICAgICAgICBwcmVzZW50Lmxlbmd0aCAhPT0gY291bnQpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LmFuZCcsXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW50LFxuICAgICAgICAgICAgICAgICAgICBwcmVzZW50V2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHByZXNlbnQpLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLFxuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIG1pc3NpbmcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBuYW5kKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCAhPT0gZGVwLnBlZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWFpbiA9IGRlcC5wYXRoc1swXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZGVwLnBhdGhzLnNsaWNlKDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogJ29iamVjdC5uYW5kJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBtYWluLFxuICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBtYWluKSxcbiAgICAgICAgICAgICAgICBwZWVyczogdmFsdWVzLFxuICAgICAgICAgICAgICAgIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHZhbHVlcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6ICdvYmplY3QubWlzc2luZycsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgcGVlcnM6IGRlcC5wYXRocyxcbiAgICAgICAgICAgICAgICBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIG94b3Ioc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcmVzZW50Lmxlbmd0aCB8fFxuICAgICAgICAgICAgcHJlc2VudC5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnM6IGRlcC5wYXRocywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKSB9O1xuICAgICAgICBjb250ZXh0LnByZXNlbnQgPSBwcmVzZW50O1xuICAgICAgICBjb250ZXh0LnByZXNlbnRXaXRoTGFiZWxzID0gaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHByZXNlbnQpO1xuICAgICAgICByZXR1cm4geyBjb2RlOiAnb2JqZWN0Lm94b3InLCBjb250ZXh0IH07XG4gICAgfSxcblxuICAgIHdpdGgoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC53aXRoJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZGVwLmtleS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLmtleS5rZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcjogcGVlci5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcGVlci5rZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdpdGhvdXQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogJ29iamVjdC53aXRob3V0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbjogZGVwLmtleS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLmtleS5rZXkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVlcjogcGVlci5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcGVlci5rZXkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHhvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7IHBlZXJzOiBkZXAucGF0aHMsIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocykgfTtcbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2RlOiAnb2JqZWN0Lm1pc3NpbmcnLCBjb250ZXh0IH07XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnByZXNlbnQgPSBwcmVzZW50O1xuICAgICAgICBjb250ZXh0LnByZXNlbnRXaXRoTGFiZWxzID0gaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIHByZXNlbnQpO1xuICAgICAgICByZXR1cm4geyBjb2RlOiAnb2JqZWN0LnhvcicsIGNvbnRleHQgfTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5rZXlzVG9MYWJlbHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBrZXlzKSB7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoKGtleSkgPT4gc2NoZW1hLiRfbWFwTGFiZWxzKGtleSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5cyk7XG59O1xuXG5cbmludGVybmFscy5yZW5hbWUgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzLCBlcnJvcnMpIHtcblxuICAgIGNvbnN0IHJlbmFtZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHJlbmFtZSBvZiBzY2hlbWEuJF90ZXJtcy5yZW5hbWVzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHR5cGVvZiByZW5hbWUuZnJvbSAhPT0gJ3N0cmluZyc7XG5cbiAgICAgICAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZW5hbWUuZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAodmFsdWVbcmVuYW1lLmZyb21dICE9PSB1bmRlZmluZWQgfHwgIXJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCkpIHtcblxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChyZW5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBmcm9tIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2Zyb21dID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lLm9wdGlvbnMuaWdub3JlVW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IHJlbmFtZS50bykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHJlbmFtZS5mcm9tLmV4ZWMoZnJvbSk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBmcm9tLCB0bzogcmVuYW1lLnRvLCBtYXRjaCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IG1hdGNoLmZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBtYXRjaC50bztcbiAgICAgICAgICAgIGlmICh0byBpbnN0YW5jZW9mIFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdG8gPSB0by5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbWF0Y2gubWF0Y2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5tdWx0aXBsZSAmJlxuICAgICAgICAgICAgICAgIHJlbmFtZWRbdG9dKSB7XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5tdWx0aXBsZScsIHZhbHVlLCB7IGZyb20sIHRvLCBwYXR0ZXJuIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHRvKSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWUub3B0aW9ucy5vdmVycmlkZSAmJlxuICAgICAgICAgICAgICAgICFyZW5hbWVkW3RvXSkge1xuXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUub3ZlcnJpZGUnLCB2YWx1ZSwgeyBmcm9tLCB0bywgcGF0dGVybiB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWVbZnJvbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVt0b107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVt0b10gPSB2YWx1ZVtmcm9tXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuYW1lZFt0b10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmludGVybmFscy51bmtub3duID0gZnVuY3Rpb24gKHNjaGVtYSwgdmFsdWUsIHVucHJvY2Vzc2VkLCBlcnJvcnMsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zKSB7XG4gICAgICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5tYXAoKHBhdHRlcm4pID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBbLi4uc3RhdGUucGF0aCwga2V5XTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5yZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4ucmVnZXgudGVzdChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZGVidWcoc3RhdGUsICdydWxlJywgYHBhdHRlcm4uJHtpfWAsIG1hdGNoID8gJ3Bhc3MnIDogJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uc2NoZW1hLiRfbWF0Y2goa2V5LCBzdGF0ZS5uZXN0KHBhdHRlcm4uc2NoZW1hLCBgcGF0dGVybi4ke2l9YCksIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIHsgc2NoZW1hOiBwYXR0ZXJuLnJ1bGUsIGtleSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXR0ZXJuLnJ1bGUuJF92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc1tpXS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdHRlcm4uZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcGF0dGVybiBtYXRjaGVzIHJ1bGVzXG5cbiAgICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cG0gPSBzY2hlbWEuJF90ZXJtcy5wYXR0ZXJuc1tpXS5tYXRjaGVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShzdGF0ZS5wYXRoLCBhbmNlc3RvcnMsIHN0cG0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN0cG0uJF92YWxpZGF0ZShtYXRjaCwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBFcnJvcnMuZGV0YWlscyhyZXN1bHQuZXJyb3JzLCB7IG92ZXJyaWRlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucGF0dGVybi5tYXRjaCcsIHZhbHVlLCBkZXRhaWxzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5wcm9jZXNzZWQuc2l6ZSB8fFxuICAgICAgICAhc2NoZW1hLiRfdGVybXMua2V5cyAmJiAhc2NoZW1hLiRfdGVybXMucGF0dGVybnMpIHsgICAgIC8vIElmIG5vIGtleXMgb3IgcGF0dGVybnMgc3BlY2lmaWVkLCB1bmtub3duIGtleXMgYWxsb3dlZFxuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuc3RyaXBVbmtub3duICYmICFzY2hlbWEuX2ZsYWdzLnVua25vd24gfHxcbiAgICAgICAgcHJlZnMuc2tpcEZ1bmN0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHN0cmlwVW5rbm93biA9IHByZWZzLnN0cmlwVW5rbm93biA/IChwcmVmcy5zdHJpcFVua25vd24gPT09IHRydWUgPyB0cnVlIDogISFwcmVmcy5zdHJpcFVua25vd24ub2JqZWN0cykgOiBmYWxzZTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvcmJpZFVua25vd24gPSAhQ29tbW9uLmRlZmF1bHQoc2NoZW1hLl9mbGFncy51bmtub3duLCBwcmVmcy5hbGxvd1Vua25vd24pO1xuICAgIGlmIChmb3JiaWRVbmtub3duKSB7XG4gICAgICAgIGZvciAoY29uc3QgdW5wcm9jZXNzZWRLZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwgdW5wcm9jZXNzZWRLZXldLCBbXSk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnVua25vd24nLCB2YWx1ZVt1bnByb2Nlc3NlZEtleV0sIHsgY2hpbGQ6IHVucHJvY2Vzc2VkS2V5IH0sIGxvY2FsU3RhdGUsIHByZWZzLCB7IGZsYWdzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5EZXBlbmRlbmN5ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocmVsLCBrZXksIHBlZXJzLCBwYXRocykge1xuXG4gICAgICAgIHRoaXMucmVsID0gcmVsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5wZWVycyA9IHBlZXJzO1xuICAgICAgICB0aGlzLnBhdGhzID0gcGF0aHM7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzYyA9IHtcbiAgICAgICAgICAgIHJlbDogdGhpcy5yZWwsXG4gICAgICAgICAgICBwZWVyczogdGhpcy5wYXRoc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLmtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVzYy5rZXkgPSB0aGlzLmtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICAgICAgZGVzYy5vcHRpb25zID0geyBzZXBhcmF0b3I6IHRoaXMucGVlcnNbMF0uc2VwYXJhdG9yIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzYztcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5LZXlzID0gY2xhc3MgZXh0ZW5kcyBBcnJheSB7XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zbGljZSgpO1xuXG4gICAgICAgIGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBrZXlzLnNldChyZXN1bHRbaV0ua2V5LCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGl0ZW0ua2V5O1xuICAgICAgICAgICAgY29uc3QgcG9zID0ga2V5cy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtwb3NdID0geyBrZXksIHNjaGVtYTogcmVzdWx0W3Bvc10uc2NoZW1hLmNvbmNhdChpdGVtLnNjaGVtYSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnbGluaycsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHNjaGVtYUNoYWluOiB0cnVlXG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgbGluazogeyBpbml0OiBudWxsLCBtYW5pZmVzdDogJ3NpbmdsZScsIHJlZ2lzdGVyOiBmYWxzZSB9XG4gICAgfSxcblxuICAgIGFyZ3Moc2NoZW1hLCByZWYpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLnJlZihyZWYpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgQXNzZXJ0KHNjaGVtYS4kX3Rlcm1zLmxpbmssICdVbmluaXRpYWxpemVkIGxpbmsgc2NoZW1hJyk7XG5cbiAgICAgICAgY29uc3QgbGlua2VkID0gaW50ZXJuYWxzLmdlbmVyYXRlKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHNjaGVtYS4kX3Rlcm1zLmxpbmtbMF0ucmVmO1xuICAgICAgICByZXR1cm4gbGlua2VkLiRfdmFsaWRhdGUodmFsdWUsIHN0YXRlLm5lc3QobGlua2VkLCBgbGluazoke3JlZi5kaXNwbGF5fToke2xpbmtlZC50eXBlfWApLCBwcmVmcyk7XG4gICAgfSxcblxuICAgIGdlbmVyYXRlKHNjaGVtYSwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIG1ldGhvZChyZWYpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghdGhpcy4kX3Rlcm1zLmxpbmssICdDYW5ub3QgcmVpbml0aWFsaXplIHNjaGVtYScpO1xuXG4gICAgICAgICAgICAgICAgcmVmID0gQ29tcGlsZS5yZWYocmVmKTtcblxuICAgICAgICAgICAgICAgIEFzc2VydChyZWYudHlwZSA9PT0gJ3ZhbHVlJyB8fCByZWYudHlwZSA9PT0gJ2xvY2FsJywgJ0ludmFsaWQgcmVmZXJlbmNlIHR5cGU6JywgcmVmLnR5cGUpO1xuICAgICAgICAgICAgICAgIEFzc2VydChyZWYudHlwZSA9PT0gJ2xvY2FsJyB8fCByZWYuYW5jZXN0b3IgPT09ICdyb290JyB8fCByZWYuYW5jZXN0b3IgPiAwLCAnTGluayBjYW5ub3QgcmVmZXJlbmNlIGl0c2VsZicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmxpbmsgPSBbeyByZWYgfV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWxhdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3JlbGF0aXZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgICAgICBBc3NlcnQodGhpcy4kX3Rlcm1zLmxpbmssICdVbmluaXRpYWxpemVkIGxpbmsgc2NoZW1hJyk7XG4gICAgICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSksICdJbnZhbGlkIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgICAgIEFzc2VydChzb3VyY2UudHlwZSAhPT0gJ2xpbmsnLCAnQ2Fubm90IG1lcmdlIHR5cGUgbGluayB3aXRoIGFub3RoZXIgbGluaycpO1xuXG4gICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy53aGVucyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouJF90ZXJtcy53aGVucy5wdXNoKHsgY29uY2F0OiBzb3VyY2UgfSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1hbmlmZXN0OiB7XG5cbiAgICAgICAgYnVpbGQob2JqLCBkZXNjKSB7XG5cbiAgICAgICAgICAgIEFzc2VydChkZXNjLmxpbmssICdJbnZhbGlkIGxpbmsgZGVzY3JpcHRpb24gbWlzc2luZyBsaW5rJyk7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnJlZihkZXNjLmxpbmspO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBsZXQgbGlua2VkID0gc3RhdGUubWFpbnN0YXkubGlua3MuZ2V0KHNjaGVtYSk7XG4gICAgaWYgKGxpbmtlZCkge1xuICAgICAgICByZXR1cm4gbGlua2VkLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG4gICAgfVxuXG4gICAgY29uc3QgcmVmID0gc2NoZW1hLiRfdGVybXMubGlua1swXS5yZWY7XG4gICAgY29uc3QgeyBwZXJzcGVjdGl2ZSwgcGF0aCB9ID0gaW50ZXJuYWxzLnBlcnNwZWN0aXZlKHJlZiwgc3RhdGUpO1xuICAgIGludGVybmFscy5hc3NlcnQocGVyc3BlY3RpdmUsICd3aGljaCBpcyBvdXRzaWRlIG9mIHNjaGVtYSBib3VuZGFyaWVzJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICB0cnkge1xuICAgICAgICBsaW5rZWQgPSBwYXRoLmxlbmd0aCA/IHBlcnNwZWN0aXZlLiRfcmVhY2gocGF0aCkgOiBwZXJzcGVjdGl2ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGlnbm9yZUVycikge1xuICAgICAgICBpbnRlcm5hbHMuYXNzZXJ0KGZhbHNlLCAndG8gbm9uLWV4aXN0aW5nIHNjaGVtYScsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIGludGVybmFscy5hc3NlcnQobGlua2VkLnR5cGUgIT09ICdsaW5rJywgJ3doaWNoIGlzIGFub3RoZXIgbGluaycsIHJlZiwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnJlbGF0aXZlKSB7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmxpbmtzLnNldChzY2hlbWEsIGxpbmtlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmtlZC5fZ2VuZXJhdGUodmFsdWUsIHN0YXRlLCBwcmVmcykuc2NoZW1hO1xufTtcblxuXG5pbnRlcm5hbHMucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAocmVmLCBzdGF0ZSkge1xuXG4gICAgaWYgKHJlZi50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBzY2hlbWEsIGtleSB9IG9mIHN0YXRlLnNjaGVtYXMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGcm9tIHBhcmVudCB0byByb290XG4gICAgICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS5fZmxhZ3MuaWQgfHwga2V5O1xuICAgICAgICAgICAgaWYgKGlkID09PSByZWYucGF0aFswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzY2hlbWEsIHBhdGg6IHJlZi5wYXRoLnNsaWNlKDEpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5zaGFyZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNoYXJlZCBvZiBzY2hlbWEuJF90ZXJtcy5zaGFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXJlZC5fZmxhZ3MuaWQgPT09IHJlZi5wYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc2hhcmVkLCBwYXRoOiByZWYucGF0aC5zbGljZSgxKSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IG51bGwsIHBhdGg6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAocmVmLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHN0YXRlLnNjaGVtYXNbc3RhdGUuc2NoZW1hcy5sZW5ndGggLSAxXS5zY2hlbWEsIHBhdGg6IHJlZi5wYXRoIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHN0YXRlLnNjaGVtYXNbcmVmLmFuY2VzdG9yXSAmJiBzdGF0ZS5zY2hlbWFzW3JlZi5hbmNlc3Rvcl0uc2NoZW1hLCBwYXRoOiByZWYucGF0aCB9O1xufTtcblxuXG5pbnRlcm5hbHMuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgbWVzc2FnZSwgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgaWYgKGNvbmRpdGlvbikgeyAgICAgICAgICAgICAgICAvLyBNYW51YWwgY2hlY2sgdG8gYXZvaWQgZ2VuZXJhdGluZyBlcnJvciBtZXNzYWdlIG9uIHN1Y2Nlc3NcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEFzc2VydChmYWxzZSwgYFwiJHtFcnJvcnMubGFiZWwoc2NoZW1hLl9mbGFncywgc3RhdGUsIHByZWZzKX1cIiBjb250YWlucyBsaW5rIHJlZmVyZW5jZSBcIiR7cmVmLmRpc3BsYXl9XCIgJHttZXNzYWdlfWApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbnVtYmVyUng6IC9eXFxzKlsrLV0/KD86KD86XFxkKyg/OlxcLlxcZCopPyl8KD86XFwuXFxkKykpKD86ZShbKy1dP1xcZCspKT9cXHMqJC9pLFxuICAgIHByZWNpc2lvblJ4OiAvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnbnVtYmVyJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgdW5zYWZlOiB7IGRlZmF1bHQ6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChpbnRlcm5hbHMubnVtYmVyUngpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUpIH07XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQudmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSAwOyAgICAgICAgICAgLy8gLTBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnVuc2FmZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvZS9pKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RlZCA9IGludGVybmFscy5ub3JtYWxpemVFeHBvbmVudChgJHtyZXN1bHQudmFsdWUgLyBNYXRoLnBvdygxMCwgbWF0Y2hlc1sxXSl9ZSR7bWF0Y2hlc1sxXX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdGVkICE9PSBpbnRlcm5hbHMubm9ybWFsaXplRXhwb25lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZyA9IHJlc3VsdC52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKC9lL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZyAhPT0gaW50ZXJuYWxzLm5vcm1hbGl6ZURlY2ltYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAtSW5maW5pdHkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ251bWJlci5pbmZpbml0eScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUNvbW1vbi5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdudW1iZXIuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlIH07XG5cbiAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gMDsgICAgICAgICAgIC8vIC0wXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcnVsZS5hcmdzLmxpbWl0KTsgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgY29uY2VwdHVhbGx5IGVxdWl2YWxlbnQgdG8gdXNpbmcgdG9GaXhlZCBidXQgaXQgc2hvdWxkIGJlIG11Y2ggZmFzdGVyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyZXN1bHQudmFsdWUgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnVuc2FmZSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgdmFsdWUgPCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUikpIHtcblxuICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IGVycm9yKCdudW1iZXIudW5zYWZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGNvbXBhcmU6IHtcbiAgICAgICAgICAgIG1ldGhvZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZSwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2xpbWl0JyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6IENvbW1vbi5pc051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ211c3QgYmUgYSBudW1iZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIGdyZWF0ZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2dyZWF0ZXInLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz4nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGludGVnZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaW50ZWdlcicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC50cnVuYyh2YWx1ZSkgLSB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5pbnRlZ2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVzczoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVzcycsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG11bHRpcGxlOiB7XG4gICAgICAgICAgICBtZXRob2QoYmFzZSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ211bHRpcGxlJywgYXJnczogeyBiYXNlIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgYmFzZSB9LCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJSBiYXNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogb3B0aW9ucy5hcmdzLmJhc2UsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdiYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQ6ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBuZWdhdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbignbmVnYXRpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwb3J0OiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3BvcnQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlIDw9IDY1NTM1KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIucG9ydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvc2l0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKCdwb3NpdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHByZWNpc2lvbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpLCAnbGltaXQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAncHJlY2lzaW9uJywgYXJnczogeyBsaW1pdCB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlcyA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2goaW50ZXJuYWxzLnByZWNpc2lvblJ4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNpbWFscyA9IE1hdGgubWF4KChwbGFjZXNbMV0gPyBwbGFjZXNbMV0ubGVuZ3RoIDogMCkgLSAocGxhY2VzWzJdID8gcGFyc2VJbnQocGxhY2VzWzJdLCAxMCkgOiAwKSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRlY2ltYWxzIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLnByZWNpc2lvbicsIHsgbGltaXQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBzaWduOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2lnbikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnbmVnYXRpdmUnLCAncG9zaXRpdmUnXS5pbmNsdWRlcyhzaWduKSwgJ0ludmFsaWQgc2lnbicsIHNpZ24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NpZ24nLCBhcmdzOiB7IHNpZ24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBzaWduIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChzaWduID09PSAnbmVnYXRpdmUnICYmIHZhbHVlIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICBzaWduID09PSAncG9zaXRpdmUnICYmIHZhbHVlID4gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihgbnVtYmVyLiR7c2lnbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bnNhZmU6IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicsICdlbmFibGVkIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Vuc2FmZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgc3RyaW5nOiB7XG4gICAgICAgICAgICBmcm9tOiAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ251bWJlci5iYXNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLmdyZWF0ZXInOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBncmVhdGVyIHRoYW4ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIuaW5maW5pdHknOiAnXCJ7eyNsYWJlbH19XCIgY2Fubm90IGJlIGluZmluaXR5JyxcbiAgICAgICAgJ251bWJlci5pbnRlZ2VyJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICAgICdudW1iZXIubGVzcyc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGxlc3MgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tYXgnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIubWluJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgbGFyZ2VyIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fScsXG4gICAgICAgICdudW1iZXIubXVsdGlwbGUnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIG11bHRpcGxlIG9mIHt7I211bHRpcGxlfX0nLFxuICAgICAgICAnbnVtYmVyLm5lZ2F0aXZlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBuZWdhdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnBvcnQnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIHBvcnQnLFxuICAgICAgICAnbnVtYmVyLnBvc2l0aXZlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInLFxuICAgICAgICAnbnVtYmVyLnByZWNpc2lvbic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGhhdmUgbm8gbW9yZSB0aGFuIHt7I2xpbWl0fX0gZGVjaW1hbCBwbGFjZXMnLFxuICAgICAgICAnbnVtYmVyLnVuc2FmZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgc2FmZSBudW1iZXInXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMubm9ybWFsaXplRXhwb25lbnQgPSBmdW5jdGlvbiAoc3RyKSB7XG5cbiAgICByZXR1cm4gc3RyXG4gICAgICAgIC5yZXBsYWNlKC9FLywgJ2UnKVxuICAgICAgICAucmVwbGFjZSgvXFwuKFxcZCpbMS05XSk/MCtlLywgJy4kMWUnKVxuICAgICAgICAucmVwbGFjZSgvXFwuZS8sICdlJylcbiAgICAgICAgLnJlcGxhY2UoL2VcXCsvLCAnZScpXG4gICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9eKC0/KTArKFsxLTldKS8sICckMSQyJyk7XG59O1xuXG5cbmludGVybmFscy5ub3JtYWxpemVEZWNpbWFsID0gZnVuY3Rpb24gKHN0cikge1xuXG4gICAgc3RyID0gc3RyXG4gICAgICAgIC5yZXBsYWNlKC9eXFwrLywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXC4wKyQvLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pXFwuKFteXFwuXSopJC8sICckMTAuJDInKVxuICAgICAgICAucmVwbGFjZSgvXigtPykwKyhbMS05XSkvLCAnJDEkMicpO1xuXG4gICAgaWYgKHN0ci5pbmNsdWRlcygnLicpICYmXG4gICAgICAgIHN0ci5lbmRzV2l0aCgnMCcpKSB7XG5cbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLzArJC8sICcnKTtcbiAgICB9XG5cbiAgICBpZiAoc3RyID09PSAnLTAnKSB7XG4gICAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXMuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdvYmplY3QnLFxuXG4gICAgY2FzdDoge1xuICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hcChPYmplY3QuZW50cmllcyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRG9tYWluID0gcmVxdWlyZSgnQGhhcGkvYWRkcmVzcy9saWIvZG9tYWluJyk7XG5jb25zdCBFbWFpbCA9IHJlcXVpcmUoJ0BoYXBpL2FkZHJlc3MvbGliL2VtYWlsJyk7XG5jb25zdCBFc2NhcGVSZWdleCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZVJlZ2V4Jyk7XG5jb25zdCBUbGRzID0gcmVxdWlyZSgnQGhhcGkvYWRkcmVzcy9saWIvdGxkcycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xuXG5jb25zdCBJcCA9IHJlcXVpcmUoJy4vaXAnKTtcbmNvbnN0IFVyaSA9IHJlcXVpcmUoJy4vdXJpJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHRsZHM6IFRsZHMgaW5zdGFuY2VvZiBTZXQgPyB7IHRsZHM6IHsgYWxsb3c6IFRsZHMsIGRlbnk6IG51bGwgfSB9IDogZmFsc2UsICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICBiYXNlNjRSZWdleDoge1xuICAgICAgICAvLyBwYWRkaW5nUmVxdWlyZWRcbiAgICAgICAgdHJ1ZToge1xuICAgICAgICAgICAgLy8gdXJsU2FmZVxuICAgICAgICAgICAgdHJ1ZTogL14oPzpbXFx3XFwtXXsyfVtcXHdcXC1dezJ9KSooPzpbXFx3XFwtXXsyfT09fFtcXHdcXC1dezN9PSk/JC8sXG4gICAgICAgICAgICBmYWxzZTogL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfT09fFtBLVphLXowLTkrXFwvXXszfT0pPyQvXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlOiB7XG4gICAgICAgICAgICB0cnVlOiAvXig/OltcXHdcXC1dezJ9W1xcd1xcLV17Mn0pKig/OltcXHdcXC1dezJ9KD09KT98W1xcd1xcLV17M309Pyk/JC8sXG4gICAgICAgICAgICBmYWxzZTogL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfSg9PSk/fFtBLVphLXowLTkrXFwvXXszfT0/KT8kL1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkYXRhVXJpUmVnZXg6IHtcbiAgICAgICAgZm9ybWF0OiAvXmRhdGE6W1xcdysuLV0rXFwvW1xcdysuLV0rOygoY2hhcnNldD1bXFx3LV0rfGJhc2U2NCksKT8oLiopJC8sXG4gICAgICAgIGJhc2U2NDoge1xuICAgICAgICAgICAgLy8gcGFkZGluZ1JlcXVpcmVkXG4gICAgICAgICAgICB0cnVlOiAvXig/OltBLVphLXowLTkrXFwvXXs0fSkqKD86W0EtWmEtejAtOStcXC9dezJ9PT18W0EtWmEtejAtOStcXC9dezN9PSk/JC8sXG4gICAgICAgICAgICBmYWxzZTogL14oPzpbQS1aYS16MC05K1xcL117NH0pKig/OltBLVphLXowLTkrXFwvXXsyfSg9PSk/fFtBLVphLXowLTkrXFwvXXszfT0/KT8kL1xuICAgICAgICB9XG4gICAgfSxcbiAgICBoZXhSZWdleDogL15bYS1mMC05XSskL2ksXG4gICAgaG9zdFJlZ2V4OiAvXigoW2EtekEtWjAtOV18W2EtekEtWjAtOV1bYS16QS1aMC05XFwtXSpbYS16QS1aMC05XSlcXC4pKihbQS1aYS16MC05XXxbQS1aYS16MC05XVtBLVphLXowLTlcXC1dKltBLVphLXowLTldKSQvLFxuICAgIGlwUmVnZXg6IElwLmNyZWF0ZUlwUmVnZXgoWydpcHY0JywgJ2lwdjYnLCAnaXB2ZnV0dXJlJ10sICdvcHRpb25hbCcpLFxuICAgIGlzb0R1cmF0aW9uUmVnZXg6IC9eUCg/ISQpKFxcZCtZKT8oXFxkK00pPyhcXGQrVyk/KFxcZCtEKT8oVCg/PVxcZCkoXFxkK0gpPyhcXGQrTSk/KFxcZCtTKT8pPyQvLFxuXG4gICAgZ3VpZEJyYWNrZXRzOiB7XG4gICAgICAgICd7JzogJ30nLCAnWyc6ICddJywgJygnOiAnKScsICcnOiAnJ1xuICAgIH0sXG4gICAgZ3VpZFZlcnNpb25zOiB7XG4gICAgICAgIHV1aWR2MTogJzEnLFxuICAgICAgICB1dWlkdjI6ICcyJyxcbiAgICAgICAgdXVpZHYzOiAnMycsXG4gICAgICAgIHV1aWR2NDogJzQnLFxuICAgICAgICB1dWlkdjU6ICc1J1xuICAgIH0sXG5cbiAgICBjaWRyUHJlc2VuY2VzOiBbJ3JlcXVpcmVkJywgJ29wdGlvbmFsJywgJ2ZvcmJpZGRlbiddLFxuICAgIG5vcm1hbGl6YXRpb25Gb3JtczogWydORkMnLCAnTkZEJywgJ05GS0MnLCAnTkZLRCddXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnc3RyaW5nJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHsgZGVmYXVsdDogZmFsc2UgfSxcbiAgICAgICAgdHJ1bmNhdGU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIHJlcGxhY2VtZW50czogeyBpbml0OiBudWxsIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemUgPSBzY2hlbWEuJF9nZXRSdWxlKCdub3JtYWxpemUnKTtcbiAgICAgICAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm5vcm1hbGl6ZShub3JtYWxpemUuYXJncy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FzaW5nID0gc2NoZW1hLiRfZ2V0UnVsZSgnY2FzZScpO1xuICAgICAgICAgICAgaWYgKGNhc2luZykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY2FzaW5nLmFyZ3MuZGlyZWN0aW9uID09PSAndXBwZXInID8gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSA6IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHRyaW0gPSBzY2hlbWEuJF9nZXRSdWxlKCd0cmltJyk7XG4gICAgICAgICAgICBpZiAodHJpbSAmJlxuICAgICAgICAgICAgICAgIHRyaW0uYXJncy5lbmFibGVkKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVwbGFjZW1lbnQgb2Ygc2NoZW1hLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZXBsYWNlbWVudC5wYXR0ZXJuLCByZXBsYWNlbWVudC5yZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBoZXggPSBzY2hlbWEuJF9nZXRSdWxlKCdoZXgnKTtcbiAgICAgICAgICAgIGlmIChoZXggJiZcbiAgICAgICAgICAgICAgICBoZXguYXJncy5vcHRpb25zLmJ5dGVBbGlnbmVkICYmXG4gICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX2dldFJ1bGUoJ2lzb0RhdGUnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzbyA9IGludGVybmFscy5pc29EYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXNvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MudHJ1bmNhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgnbWF4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbWl0ID0gcnVsZS5hcmdzLmxpbWl0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0ID0gbGltaXQucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQ29tbW9uLmxpbWl0KGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVmJywgbGltaXQsIHsgcmVmOiBydWxlLmFyZ3MubGltaXQsIGFyZzogJ2xpbWl0JywgcmVhc29uOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInIH0sIHN0YXRlLCBwcmVmcykgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzdHJpbmcuYmFzZScpIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3RyaW5nLmVtcHR5JykgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIGFscGhhbnVtOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2FscGhhbnVtJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICgvXlthLXpBLVowLTldKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmFscGhhbnVtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmFzZTY0OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3BhZGRpbmdSZXF1aXJlZCcsICd1cmxTYWZlJ10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgdXJsU2FmZTogZmFsc2UsIHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICdib29sZWFuJywgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMudXJsU2FmZSA9PT0gJ2Jvb2xlYW4nLCAndXJsU2FmZSBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdiYXNlNjQnLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gaW50ZXJuYWxzLmJhc2U2NFJlZ2V4W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXVtvcHRpb25zLnVybFNhZmVdO1xuICAgICAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5iYXNlNjQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydsb3dlcicsICd1cHBlciddLmluY2x1ZGVzKGRpcmVjdGlvbiksICdJbnZhbGlkIGNhc2U6JywgZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdjYXNlJywgYXJnczogeyBkaXJlY3Rpb24gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBkaXJlY3Rpb24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2xvd2VyJyAmJiB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSB8fFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd1cHBlcicgJiYgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoYHN0cmluZy4ke2RpcmVjdGlvbn1jYXNlYCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWRpdENhcmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnY3JlZGl0Q2FyZCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbXVsID0gMTtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhciA9IHZhbHVlLmNoYXJBdChpKSAqIG11bDtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgKGNoYXIgLSAoY2hhciA+IDkpICogOSk7XG4gICAgICAgICAgICAgICAgICAgIG11bCA9IG11bCBeIDM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHN1bSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgc3VtICUgMTAgPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5jcmVkaXRDYXJkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGF0YVVyaToge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydwYWRkaW5nUmVxdWlyZWQnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyBwYWRkaW5nUmVxdWlyZWQ6IHRydWUsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSAnYm9vbGVhbicsICdwYWRkaW5nUmVxdWlyZWQgbXVzdCBiZSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZGF0YVVyaScsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKGludGVybmFscy5kYXRhVXJpUmVnZXguZm9ybWF0KTtcblxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlc1syXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMl0gIT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjRyZWdleCA9IGludGVybmFscy5kYXRhVXJpUmVnZXguYmFzZTY0W29wdGlvbnMucGFkZGluZ1JlcXVpcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2U2NHJlZ2V4LnRlc3QobWF0Y2hlc1szXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZGF0YVVyaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvbWFpbjoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dVbmljb2RlJywgJ21pbkRvbWFpblNlZ21lbnRzJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZG9tYWluJywgYXJnczogeyBvcHRpb25zIH0sIGFkZHJlc3MgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHsgYWRkcmVzcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoRG9tYWluLmlzVmFsaWQodmFsdWUsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRvbWFpbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGVtYWlsOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93VW5pY29kZScsICdpZ25vcmVMZW5ndGgnLCAnbWluRG9tYWluU2VnbWVudHMnLCAnbXVsdGlwbGUnLCAnc2VwYXJhdG9yJywgJ3RsZHMnXSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMubXVsdGlwbGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5tdWx0aXBsZSA9PT0gJ2Jvb2xlYW4nLCAnbXVsdGlwbGUgb3B0aW9uIG11c3QgYmUgYW4gYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYFxcXFxzKlske29wdGlvbnMuc2VwYXJhdG9yID8gRXNjYXBlUmVnZXgob3B0aW9ucy5zZXBhcmF0b3IpIDogJywnfV1cXFxccypgKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdlbWFpbCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0sIHsgcmVnZXgsIGFkZHJlc3MgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZW1haWxzID0gb3B0aW9ucy5tdWx0aXBsZSA/IHZhbHVlLnNwbGl0KHJlZ2V4KSA6IFt2YWx1ZV07XG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVtYWlsIG9mIGVtYWlscykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUVtYWlsLmlzVmFsaWQoZW1haWwsIGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkcy5wdXNoKGVtYWlsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW52YWxpZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmVtYWlsJywgeyB2YWx1ZSwgaW52YWxpZHMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3VpZDoge1xuICAgICAgICAgICAgYWxpYXM6ICd1dWlkJyxcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsndmVyc2lvbiddKTtcblxuICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9uTnVtYmVycyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IFtdLmNvbmNhdChvcHRpb25zLnZlcnNpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2ZXJzaW9ucy5sZW5ndGggPj0gMSwgJ3ZlcnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFsaWQgdmVyc2lvbiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVyc2lvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uTnVtYmVyID0gaW50ZXJuYWxzLmd1aWRWZXJzaW9uc1t2ZXJzaW9uLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZlcnNpb25OdW1iZXIsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoaW50ZXJuYWxzLmd1aWRWZXJzaW9ucykuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXNldC5oYXModmVyc2lvbk51bWJlciksICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IG5vdCBiZSBhIGR1cGxpY2F0ZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uTnVtYmVycyArPSB2ZXJzaW9uTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0LmFkZCh2ZXJzaW9uTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXihbXFxcXFt7XFxcXChdPylbMC05QS1GXXs4fShbOi1dPylbMC05QS1GXXs0fVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzIHx8ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzID8gJzg5QUInIDogJzAtOUEtRid9XVswLTlBLUZdezN9XFxcXDI/WzAtOUEtRl17MTJ9KFtcXFxcXX1cXFxcKV0/KSRgLCAnaScpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2d1aWQnLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHsgcmVnZXggfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZ3VpZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hdGNoaW5nIGJyYWNlc1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5ndWlkQnJhY2tldHNbcmVzdWx0c1sxXV0gIT09IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmd1aWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGV4OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2J5dGVBbGlnbmVkJ10pO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgYnl0ZUFsaWduZWQ6IGZhbHNlLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLmJ5dGVBbGlnbmVkID09PSAnYm9vbGVhbicsICdieXRlQWxpZ25lZCBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdoZXgnLCBhcmdzOiB7IG9wdGlvbnMgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmhleFJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaGV4Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZUFsaWduZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUubGVuZ3RoICUgMiAhPT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaGV4QWxpZ24nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaG9zdG5hbWU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaG9zdG5hbWUnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSAyNTUgJiYgaW50ZXJuYWxzLmhvc3RSZWdleC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuaXBSZWdleC50ZXN0KHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmhvc3RuYW1lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZW5zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnaW5zZW5zaXRpdmUnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpcDoge1xuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydjaWRyJywgJ3ZlcnNpb24nXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXG5cbiAgICAgICAgICAgICAgICBsZXQgcmVnZXggPSBpbnRlcm5hbHMuaXBSZWdleDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaWRyKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5jaWRyID09PSAnc3RyaW5nJywgJ2NpZHIgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNpZHIgPSBvcHRpb25zLmNpZHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLmNpZHJQcmVzZW5jZXMuaW5jbHVkZXMob3B0aW9ucy5jaWRyKSwgJ2NpZHIgbXVzdCBiZSBvbmUgb2YgJyArIGludGVybmFscy5jaWRyUHJlc2VuY2VzLmpvaW4oJywgJykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy52ZXJzaW9uICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNpZHIgIT09ICdvcHRpb25hbCcpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBJcC5jcmVhdGVJcFJlZ2V4KFsnaXB2NCcsICdpcHY2JywgJ2lwdmZ1dHVyZSddLCBvcHRpb25zLmNpZHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNpZHIgPSAnb3B0aW9uYWwnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9ucztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnZlcnNpb24gPSBbb3B0aW9ucy52ZXJzaW9uXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChvcHRpb25zLnZlcnNpb24ubGVuZ3RoID49IDEsICd2ZXJzaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZlcnNpb24gc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLnZlcnNpb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJywgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQoSXAudmVyc2lvbnNbdmVyc2lvbl0sICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIG9uZSBvZiAnICsgT2JqZWN0LmtleXMoSXAudmVyc2lvbnMpLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb25zID0gQXJyYXkuZnJvbShuZXcgU2V0KHZlcnNpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gSXAuY3JlYXRlSXBSZWdleCh2ZXJzaW9ucywgb3B0aW9ucy5jaWRyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnaXAnLCBhcmdzOiB7IG9wdGlvbnMgfSwgdmVyc2lvbnMsIHJlZ2V4IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyB2ZXJzaW9ucywgcmVnZXggfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pcFZlcnNpb24nLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIsIHZlcnNpb246IHZlcnNpb25zIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaXAnLCB7IHZhbHVlLCBjaWRyOiBvcHRpb25zLmNpZHIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvRGF0ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpc29EYXRlJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5pc29EYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcuaXNvRGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzb0R1cmF0aW9uOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2lzb0R1cmF0aW9uJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaXNvRHVyYXRpb25SZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pc29EdXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ2xlbmd0aCcsIGxpbWl0LCAnPScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCwgZW5jb2RpbmcgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlciAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoOyAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZShsZW5ndGgsIGxpbWl0LCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuJyArIG5hbWUsIHsgbGltaXQ6IGFyZ3MubGltaXQsIHZhbHVlLCBlbmNvZGluZyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAnZW5jb2RpbmcnXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgbG93ZXJjYXNlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXNlKCdsb3dlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0LCBlbmNvZGluZykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5sZW5ndGgodGhpcywgJ21heCcsIGxpbWl0LCAnPD0nLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydsaW1pdCcsICdlbmNvZGluZyddXG4gICAgICAgIH0sXG5cbiAgICAgICAgbWluOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbWluJywgbGltaXQsICc+PScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2xpbWl0JywgJ2VuY29kaW5nJ11cbiAgICAgICAgfSxcblxuICAgICAgICBub3JtYWxpemU6IHtcbiAgICAgICAgICAgIG1ldGhvZChmb3JtID0gJ05GQycpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmluY2x1ZGVzKGZvcm0pLCAnbm9ybWFsaXphdGlvbiBmb3JtIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMubm9ybWFsaXphdGlvbkZvcm1zLmpvaW4oJywgJykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ25vcm1hbGl6ZScsIGFyZ3M6IHsgZm9ybSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0sIHsgZm9ybSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHZhbHVlLm5vcm1hbGl6ZShmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdzdHJpbmcubm9ybWFsaXplJywgeyB2YWx1ZSwgZm9ybSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0dGVybjoge1xuICAgICAgICAgICAgYWxpYXM6ICdyZWdleCcsXG4gICAgICAgICAgICBtZXRob2QocmVnZXgsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwLCAncmVnZXggbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ2cnKSAmJiAhcmVnZXguZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3JlZ2V4IHNob3VsZCBub3QgdXNlIGdsb2JhbCBvciBzdGlja3kgbW9kZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0geyBuYW1lOiBvcHRpb25zIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpbnZlcnQnLCAnbmFtZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IFsnc3RyaW5nLnBhdHRlcm4nLCBvcHRpb25zLmludmVydCA/ICcuaW52ZXJ0JyA6ICcnLCBvcHRpb25zLm5hbWUgPyAnLm5hbWUnIDogJy5iYXNlJ10uam9pbignJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3BhdHRlcm4nLCBhcmdzOiB7IHJlZ2V4LCBvcHRpb25zIH0sIGVycm9yQ29kZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyByZWdleCwgb3B0aW9ucyB9LCB7IGVycm9yQ29kZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuTWF0Y2ggPSByZWdleC50ZXN0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuTWF0Y2ggXiBvcHRpb25zLmludmVydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoZXJyb3JDb2RlLCB7IG5hbWU6IG9wdGlvbnMubmFtZSwgcmVnZXgsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsncmVnZXgnLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICByZXBsYWNlOiB7XG4gICAgICAgICAgICBtZXRob2QocGF0dGVybiwgcmVwbGFjZW1lbnQpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAoRXNjYXBlUmVnZXgocGF0dGVybiksICdnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAsICdwYXR0ZXJuIG11c3QgYmUgYSBSZWdFeHAnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHJlcGxhY2VtZW50ID09PSAnc3RyaW5nJywgJ3JlcGxhY2VtZW50IG11c3QgYmUgYSBTdHJpbmcnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlcGxhY2VtZW50cy5wdXNoKHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0b2tlbjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCd0b2tlbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoL15cXHcrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudG9rZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB0cmltOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3RyaW0nLCBhcmdzOiB7IGVuYWJsZWQgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBlbmFibGVkIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICghZW5hYmxlZCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdmFsdWUudHJpbSgpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudHJpbScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICB0cnVuY2F0ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndHJ1bmNhdGUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cHBlcmNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhc2UoJ3VwcGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsbG93UmVsYXRpdmUnLCAnYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzJywgJ2RvbWFpbicsICdyZWxhdGl2ZU9ubHknLCAnc2NoZW1lJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdW5rbm93bk9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKGtleSkgPT4gIVsnc2NoZW1lJywgJ2FsbG93UmVsYXRpdmUnLCAncmVsYXRpdmVPbmx5JywgJ2FsbG93UXVlcnlTcXVhcmVCcmFja2V0cycsICdkb21haW4nXS5pbmNsdWRlcyhrZXkpKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodW5rbm93bk9wdGlvbnMubGVuZ3RoID09PSAwLCBgb3B0aW9ucyBjb250YWluIHVua25vd24ga2V5czogJHt1bmtub3duT3B0aW9uc31gKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLmRvbWFpbiwgWydhbGxvd1VuaWNvZGUnLCAnbWluRG9tYWluU2VnbWVudHMnLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IFVyaS5jcmVhdGVSZWdleChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW4gPSBvcHRpb25zLmRvbWFpbiA/IGludGVybmFscy5hZGRyZXNzT3B0aW9ucyhvcHRpb25zLmRvbWFpbikgOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICd1cmknLCBhcmdzOiB7IG9wdGlvbnMgfSwgcmVnZXgsIGRvbWFpbiB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBvcHRpb25zIH0sIHsgcmVnZXgsIGRvbWFpbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoWydodHRwOi8nLCAnaHR0cHM6LyddLmluY2x1ZGVzKHZhbHVlKSkgeyAgICAgICAgICAgIC8vIHNjaGVtZTovIGlzIHRlY2huaWNhbGx5IHZhbGlkIGJ1dCBtYWtlcyBubyBzZW5zZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFEb21haW4uaXNWYWxpZChtYXRjaFsxXSwgZG9tYWluKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmRvbWFpbicsIHsgdmFsdWU6IG1hdGNoWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlT25seSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaVJlbGF0aXZlT25seScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLnVyaUN1c3RvbVNjaGVtZScsIHsgc2NoZW1lOiByZWdleC5zY2hlbWUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IHBhdHRlcm4sIHJlcGxhY2VtZW50IH0gb2YgZGVzYy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnc3RyaW5nLmFscGhhbnVtJzogJ1wie3sjbGFiZWx9fVwiIG11c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuYmFzZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5iYXNlNjQnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIGJhc2U2NCBzdHJpbmcnLFxuICAgICAgICAnc3RyaW5nLmNyZWRpdENhcmQnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIGNyZWRpdCBjYXJkJyxcbiAgICAgICAgJ3N0cmluZy5kYXRhVXJpJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCBkYXRhVXJpIHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuZG9tYWluJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgY29udGFpbiBhIHZhbGlkIGRvbWFpbiBuYW1lJyxcbiAgICAgICAgJ3N0cmluZy5lbWFpbCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICAgICAgICAnc3RyaW5nLmVtcHR5JzogJ1wie3sjbGFiZWx9fVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGVtcHR5JyxcbiAgICAgICAgJ3N0cmluZy5ndWlkJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCBHVUlEJyxcbiAgICAgICAgJ3N0cmluZy5oZXgnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBvbmx5IGNvbnRhaW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcuaGV4QWxpZ24nOiAnXCJ7eyNsYWJlbH19XCIgaGV4IGRlY29kZWQgcmVwcmVzZW50YXRpb24gbXVzdCBiZSBieXRlIGFsaWduZWQnLFxuICAgICAgICAnc3RyaW5nLmhvc3RuYW1lJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCBob3N0bmFtZScsXG4gICAgICAgICdzdHJpbmcuaXAnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pcFZlcnNpb24nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgb2Ygb25lIG9mIHRoZSBmb2xsb3dpbmcgdmVyc2lvbnMge3sjdmVyc2lvbn19IHdpdGggYSB7eyNjaWRyfX0gQ0lEUicsXG4gICAgICAgICdzdHJpbmcuaXNvRGF0ZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGluIGlzbyBmb3JtYXQnLFxuICAgICAgICAnc3RyaW5nLmlzb0R1cmF0aW9uJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCBJU08gODYwMSBkdXJhdGlvbicsXG4gICAgICAgICdzdHJpbmcubGVuZ3RoJzogJ1wie3sjbGFiZWx9fVwiIGxlbmd0aCBtdXN0IGJlIHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5sb3dlcmNhc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBvbmx5IGNvbnRhaW4gbG93ZXJjYXNlIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLm1heCc6ICdcInt7I2xhYmVsfX1cIiBsZW5ndGggbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLm1pbic6ICdcInt7I2xhYmVsfX1cIiBsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCB7eyNsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgICdzdHJpbmcubm9ybWFsaXplJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgdW5pY29kZSBub3JtYWxpemVkIGluIHRoZSB7eyNmb3JtfX0gZm9ybScsXG4gICAgICAgICdzdHJpbmcudG9rZW4nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBhbmQgdW5kZXJzY29yZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmJhc2UnOiAnXCJ7eyNsYWJlbH19XCIgd2l0aCB2YWx1ZSBcIntbLl19XCIgZmFpbHMgdG8gbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm46IHt7I3JlZ2V4fX0nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4ubmFtZSc6ICdcInt7I2xhYmVsfX1cIiB3aXRoIHZhbHVlIFwie1suXX1cIiBmYWlscyB0byBtYXRjaCB0aGUge3sjbmFtZX19IHBhdHRlcm4nLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4uaW52ZXJ0LmJhc2UnOiAnXCJ7eyNsYWJlbH19XCIgd2l0aCB2YWx1ZSBcIntbLl19XCIgbWF0Y2hlcyB0aGUgaW52ZXJ0ZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQubmFtZSc6ICdcInt7I2xhYmVsfX1cIiB3aXRoIHZhbHVlIFwie1suXX1cIiBtYXRjaGVzIHRoZSBpbnZlcnRlZCB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudHJpbSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IG5vdCBoYXZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZScsXG4gICAgICAgICdzdHJpbmcudXJpJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCB1cmknLFxuICAgICAgICAnc3RyaW5nLnVyaUN1c3RvbVNjaGVtZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgdmFsaWQgdXJpIHdpdGggYSBzY2hlbWUgbWF0Y2hpbmcgdGhlIHt7I3NjaGVtZX19IHBhdHRlcm4nLFxuICAgICAgICAnc3RyaW5nLnVyaVJlbGF0aXZlT25seSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgdmFsaWQgcmVsYXRpdmUgdXJpJyxcbiAgICAgICAgJ3N0cmluZy51cHBlcmNhc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBvbmx5IGNvbnRhaW4gdXBwZXJjYXNlIGNoYXJhY3RlcnMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYWRkcmVzc09wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8vIG1pbkRvbWFpblNlZ21lbnRzXG5cbiAgICBBc3NlcnQob3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMpICYmIG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPiAwLCAnbWluRG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgIC8vIHRsZHNcblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMgPT09IHRydWUgfHxcbiAgICAgICAgb3B0aW9ucy50bGRzID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICBBc3NlcnQoaW50ZXJuYWxzLnRsZHMsICdCdWlsdC1pbiBUTEQgbGlzdCBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgaW50ZXJuYWxzLnRsZHMpO1xuICAgIH1cblxuICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy50bGRzID09PSAnb2JqZWN0JywgJ3RsZHMgbXVzdCBiZSB0cnVlLCBmYWxzZSwgb3IgYW4gb2JqZWN0Jyk7XG5cbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy50bGRzLmRlbnk7XG4gICAgaWYgKGRlbnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVueSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgZGVueTogbmV3IFNldChkZW55KSB9IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5kZW55IGluc3RhbmNlb2YgU2V0LCAndGxkcy5kZW55IG11c3QgYmUgYW4gYXJyYXksIFNldCwgb3IgYm9vbGVhbicpO1xuICAgICAgICBBc3NlcnQoIW9wdGlvbnMudGxkcy5hbGxvdywgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggdGxkcy5hbGxvdyBhbmQgdGxkcy5kZW55IGxpc3RzJyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy50bGRzLmFsbG93O1xuICAgIGlmICghYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ID09PSB0cnVlKSB7XG4gICAgICAgIEFzc2VydChpbnRlcm5hbHMudGxkcywgJ0J1aWx0LWluIFRMRCBsaXN0IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBpbnRlcm5hbHMudGxkcyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYWxsb3cpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHRsZHM6IHsgYWxsb3c6IG5ldyBTZXQoYWxsb3cpIH0gfSk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KG9wdGlvbnMudGxkcy5hbGxvdyBpbnN0YW5jZW9mIFNldCwgJ3RsZHMuYWxsb3cgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG5cbmludGVybmFscy5pc29EYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBpZiAoIUNvbW1vbi5pc0lzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufTtcblxuXG5pbnRlcm5hbHMubGVuZ3RoID0gZnVuY3Rpb24gKHNjaGVtYSwgbmFtZSwgbGltaXQsIG9wZXJhdG9yLCBlbmNvZGluZykge1xuXG4gICAgQXNzZXJ0KCFlbmNvZGluZyB8fCBCdWZmZXIgJiYgQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpLCAnSW52YWxpZCBlbmNvZGluZzonLCBlbmNvZGluZyk7ICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG5cbiAgICByZXR1cm4gc2NoZW1hLiRfYWRkUnVsZSh7IG5hbWUsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQsIGVuY29kaW5nIH0sIG9wZXJhdG9yIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXJpID0gcmVxdWlyZSgnLi91cmknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNpZHJzID0ge1xuICAgIGlwdjQ6IHtcbiAgICAgICAgcmVxdWlyZWQ6ICdcXFxcLyg/OicgKyBVcmkuaXB2NENpZHIgKyAnKScsXG4gICAgICAgIG9wdGlvbmFsOiAnKD86XFxcXC8oPzonICsgVXJpLmlwdjRDaWRyICsgJykpPycsXG4gICAgICAgIGZvcmJpZGRlbjogJydcbiAgICB9LFxuICAgIGlwdjY6IHtcbiAgICAgICAgcmVxdWlyZWQ6ICdcXFxcLycgKyBVcmkuaXB2NkNpZHIsXG4gICAgICAgIG9wdGlvbmFsOiAnKD86XFxcXC8nICsgVXJpLmlwdjZDaWRyICsgJyk/JyxcbiAgICAgICAgZm9yYmlkZGVuOiAnJ1xuICAgIH0sXG4gICAgaXB2ZnV0dXJlOiB7XG4gICAgICAgIHJlcXVpcmVkOiAnXFxcXC8nICsgVXJpLmlwdjZDaWRyLFxuICAgICAgICBvcHRpb25hbDogJyg/OlxcXFwvJyArIFVyaS5pcHY2Q2lkciArICcpPycsXG4gICAgICAgIGZvcmJpZGRlbjogJydcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMudmVyc2lvbnMgPSB7XG4gICAgaXB2NDogVXJpLmlwdjRhZGRyZXNzLFxuICAgIGlwdjY6IFVyaS5pcHY2YWRkcmVzcyxcbiAgICBpcHZmdXR1cmU6IFVyaS5pcHZGdXR1cmVcbn07XG5cblxuZXhwb3J0cy5jcmVhdGVJcFJlZ2V4ID0gZnVuY3Rpb24gKHZlcnNpb25zLCBjaWRyKSB7XG5cbiAgICBjb25zdCBwYXJ0cyA9IHZlcnNpb25zLm1hcCgodmVyc2lvbikgPT4gZXhwb3J0cy52ZXJzaW9uc1t2ZXJzaW9uXSArIGV4cG9ydHMuY2lkcnNbdmVyc2lvbl1bY2lkcl0pO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKCdeKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBFc2NhcGVSZWdleCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2VzY2FwZVJlZ2V4Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgcmZjMzk4NiA9IHt9O1xuXG4gICAgY29uc3QgaGV4RGlnaXQgPSAnXFxcXGRBLUZhLWYnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSEVYRElHID0gRElHSVQgLyBcIkFcIiAvIFwiQlwiIC8gXCJDXCIgLyBcIkRcIiAvIFwiRVwiIC8gXCJGXCJcbiAgICBjb25zdCBoZXhEaWdpdE9ubHkgPSAnWycgKyBoZXhEaWdpdCArICddJztcblxuICAgIGNvbnN0IHVucmVzZXJ2ZWQgPSAnXFxcXHctXFxcXC5+JzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5yZXNlcnZlZCA9IEFMUEhBIC8gRElHSVQgLyBcIi1cIiAvIFwiLlwiIC8gXCJfXCIgLyBcIn5cIlxuICAgIGNvbnN0IHN1YkRlbGltcyA9ICchXFxcXCQmXFwnXFxcXChcXFxcKVxcXFwqXFxcXCssOz0nOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Yi1kZWxpbXMgPSBcIiFcIiAvIFwiJFwiIC8gXCImXCIgLyBcIidcIiAvIFwiKFwiIC8gXCIpXCIgLyBcIipcIiAvIFwiK1wiIC8gXCIsXCIgLyBcIjtcIiAvIFwiPVwiXG4gICAgY29uc3QgcGN0RW5jb2RlZCA9ICclJyArIGhleERpZ2l0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBjdC1lbmNvZGVkID0gXCIlXCIgSEVYRElHIEhFWERJR1xuICAgIGNvbnN0IHBjaGFyID0gdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnOkAnOyAgICAgICAgICAgICAgICAgICAvLyBwY2hhciA9IHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiAvIFwiQFwiXG4gICAgY29uc3QgcGNoYXJPbmx5ID0gJ1snICsgcGNoYXIgKyAnXSc7XG4gICAgY29uc3QgZGVjT2N0ZWN0ID0gJyg/OjB7MCwyfVxcXFxkfDA/WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKSc7ICAgICAvLyBkZWMtb2N0ZXQgPSBESUdJVCAvICV4MzEtMzkgRElHSVQgLyBcIjFcIiAyRElHSVQgLyBcIjJcIiAleDMwLTM0IERJR0lUIC8gXCIyNVwiICV4MzAtMzUgIDsgMC05IC8gMTAtOTkgLyAxMDAtMTk5IC8gMjAwLTI0OSAvIDI1MC0yNTVcblxuICAgIHJmYzM5ODYuaXB2NGFkZHJlc3MgPSAnKD86JyArIGRlY09jdGVjdCArICdcXFxcLil7M30nICsgZGVjT2N0ZWN0OyAgICAgICAgICAgIC8vIElQdjRhZGRyZXNzID0gZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0XG5cbiAgICAvKlxuICAgICAgICBoMTYgPSAxKjRIRVhESUcgOyAxNiBiaXRzIG9mIGFkZHJlc3MgcmVwcmVzZW50ZWQgaW4gaGV4YWRlY2ltYWxcbiAgICAgICAgbHMzMiA9ICggaDE2IFwiOlwiIGgxNiApIC8gSVB2NGFkZHJlc3MgOyBsZWFzdC1zaWduaWZpY2FudCAzMiBiaXRzIG9mIGFkZHJlc3NcbiAgICAgICAgSVB2NmFkZHJlc3MgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICA2KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAgICAgICAgICAgICAgIGgxNiBdIFwiOjpcIiA0KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqMSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiIDMoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjMoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICBoMTYgXCI6XCIgICBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqNCggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICAgICAgICAgICAgICAgICAgLyBbICo2KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCJcbiAgICAqL1xuXG4gICAgY29uc3QgaDE2ID0gaGV4RGlnaXRPbmx5ICsgJ3sxLDR9JztcbiAgICBjb25zdCBsczMyID0gJyg/OicgKyBoMTYgKyAnOicgKyBoMTYgKyAnfCcgKyByZmMzOTg2LmlwdjRhZGRyZXNzICsgJyknO1xuICAgIGNvbnN0IElQdjZTaXhIZXggPSAnKD86JyArIGgxNiArICc6KXs2fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZGaXZlSGV4ID0gJzo6KD86JyArIGgxNiArICc6KXs1fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZGb3VySGV4ID0gJyg/OicgKyBoMTYgKyAnKT86Oig/OicgKyBoMTYgKyAnOil7NH0nICsgbHMzMjtcbiAgICBjb25zdCBJUHY2VGhyZWVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDF9JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXszfScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZUd29IZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDJ9JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXsyfScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZPbmVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDN9JyArIGgxNiArICcpPzo6JyArIGgxNiArICc6JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXggPSAnKD86KD86JyArIGgxNiArICc6KXswLDR9JyArIGgxNiArICcpPzo6JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXgyID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw1fScgKyBoMTYgKyAnKT86OicgKyBoMTY7XG4gICAgY29uc3QgSVB2Nk5vbmVIZXgzID0gJyg/Oig/OicgKyBoMTYgKyAnOil7MCw2fScgKyBoMTYgKyAnKT86Oic7XG5cbiAgICByZmMzOTg2LmlwdjRDaWRyID0gJ1xcXFxkfFsxLTJdXFxcXGR8M1swLTJdJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElQdjQgY2lkciA9IERJR0lUIC8gJXgzMS0zMiBESUdJVCAvIFwiM1wiICV4MzAtMzIgIDsgMC05IC8gMTAtMjkgLyAzMC0zMlxuICAgIHJmYzM5ODYuaXB2NkNpZHIgPSAnKD86MHswLDJ9XFxcXGR8MD9bMS05XVxcXFxkfDFbMDFdXFxcXGR8MTJbMC04XSknOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJUHY2IGNpZHIgPSBESUdJVCAvICV4MzEtMzkgRElHSVQgLyBcIjFcIiAleDAtMSBESUdJVCAvIFwiMTJcIiAleDAtODsgICAwLTkgLyAxMC05OSAvIDEwMC0xMTkgLyAxMjAtMTI4XG4gICAgcmZjMzk4Ni5pcHY2YWRkcmVzcyA9ICcoPzonICsgSVB2NlNpeEhleCArICd8JyArIElQdjZGaXZlSGV4ICsgJ3wnICsgSVB2NkZvdXJIZXggKyAnfCcgKyBJUHY2VGhyZWVIZXggKyAnfCcgKyBJUHY2VHdvSGV4ICsgJ3wnICsgSVB2Nk9uZUhleCArICd8JyArIElQdjZOb25lSGV4ICsgJ3wnICsgSVB2Nk5vbmVIZXgyICsgJ3wnICsgSVB2Nk5vbmVIZXgzICsgJyknO1xuICAgIHJmYzM5ODYuaXB2RnV0dXJlID0gJ3YnICsgaGV4RGlnaXRPbmx5ICsgJytcXFxcLlsnICsgdW5yZXNlcnZlZCArIHN1YkRlbGltcyArICc6XSsnOyAgICAgIC8vIElQdkZ1dHVyZSA9IFwidlwiIDEqSEVYRElHIFwiLlwiIDEqKCB1bnJlc2VydmVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIClcblxuICAgIHJmYzM5ODYuc2NoZW1lID0gJ1thLXpBLVpdW2EtekEtWlxcXFxkKy1cXFxcLl0qJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NoZW1lID0gQUxQSEEgKiggQUxQSEEgLyBESUdJVCAvIFwiK1wiIC8gXCItXCIgLyBcIi5cIiApXG4gICAgcmZjMzk4Ni5zY2hlbWVSZWdleCA9IG5ldyBSZWdFeHAocmZjMzk4Ni5zY2hlbWUpO1xuXG4gICAgY29uc3QgdXNlcmluZm8gPSAnWycgKyB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICc6XSonOyAgICAgICAgICAgICAgICAgICAgIC8vIHVzZXJpbmZvID0gKiggdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIClcbiAgICBjb25zdCBJUExpdGVyYWwgPSAnXFxcXFsoPzonICsgcmZjMzk4Ni5pcHY2YWRkcmVzcyArICd8JyArIHJmYzM5ODYuaXB2RnV0dXJlICsgJylcXFxcXSc7ICAgIC8vIElQLWxpdGVyYWwgPSBcIltcIiAoIElQdjZhZGRyZXNzIC8gSVB2RnV0dXJlICApIFwiXVwiXG4gICAgY29uc3QgcmVnTmFtZSA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJ117MSwyNTV9JzsgICAgICAgICAgICAgICAgIC8vIHJlZy1uYW1lID0gKiggdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyApXG4gICAgY29uc3QgaG9zdCA9ICcoPzonICsgSVBMaXRlcmFsICsgJ3wnICsgcmZjMzk4Ni5pcHY0YWRkcmVzcyArICd8JyArIHJlZ05hbWUgKyAnKSc7ICAgICAgIC8vIGhvc3QgPSBJUC1saXRlcmFsIC8gSVB2NGFkZHJlc3MgLyByZWctbmFtZVxuICAgIGNvbnN0IHBvcnQgPSAnXFxcXGQqJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvcnQgPSAqRElHSVRcbiAgICBjb25zdCBhdXRob3JpdHkgPSAnKD86JyArIHVzZXJpbmZvICsgJ0ApPycgKyBob3N0ICsgJyg/OjonICsgcG9ydCArICcpPyc7ICAgICAgICAgICAgICAgLy8gYXV0aG9yaXR5ICAgPSBbIHVzZXJpbmZvIFwiQFwiIF0gaG9zdCBbIFwiOlwiIHBvcnQgXVxuICAgIGNvbnN0IGF1dGhvcml0eUNhcHR1cmUgPSAnKD86JyArIHVzZXJpbmZvICsgJ0ApPygnICsgaG9zdCArICcpKD86OicgKyBwb3J0ICsgJyk/JztcblxuICAgIC8qXG4gICAgICAgIHNlZ21lbnQgICAgICAgPSAqcGNoYXJcbiAgICAgICAgc2VnbWVudC1ueiAgICA9IDEqcGNoYXJcbiAgICAgICAgcGF0aCAgICAgICAgICA9IHBhdGgtYWJlbXB0eSAgICA7IGJlZ2lucyB3aXRoIFwiL1wiICd8JyBpcyBlbXB0eVxuICAgICAgICAgICAgICAgICAgICAvIHBhdGgtYWJzb2x1dGUgICA7IGJlZ2lucyB3aXRoIFwiL1wiIGJ1dCBub3QgXCIvL1wiXG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1ub3NjaGVtZSAgIDsgYmVnaW5zIHdpdGggYSBub24tY29sb24gc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAvIHBhdGgtcm9vdGxlc3MgICA7IGJlZ2lucyB3aXRoIGEgc2VnbWVudFxuICAgICAgICAgICAgICAgICAgICAvIHBhdGgtZW1wdHkgICAgICA7IHplcm8gY2hhcmFjdGVyc1xuICAgICAgICBwYXRoLWFiZW1wdHkgID0gKiggXCIvXCIgc2VnbWVudCApXG4gICAgICAgIHBhdGgtYWJzb2x1dGUgPSBcIi9cIiBbIHNlZ21lbnQtbnogKiggXCIvXCIgc2VnbWVudCApIF1cbiAgICAgICAgcGF0aC1yb290bGVzcyA9IHNlZ21lbnQtbnogKiggXCIvXCIgc2VnbWVudCApXG4gICAgKi9cblxuICAgIGNvbnN0IHNlZ21lbnQgPSBwY2hhck9ubHkgKyAnKic7XG4gICAgY29uc3Qgc2VnbWVudE56ID0gcGNoYXJPbmx5ICsgJysnO1xuICAgIGNvbnN0IHNlZ21lbnROek5jID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnQCcgKyAnXSsnO1xuICAgIGNvbnN0IHBhdGhFbXB0eSA9ICcnO1xuICAgIGNvbnN0IHBhdGhBYkVtcHR5ID0gJyg/OlxcXFwvJyArIHNlZ21lbnQgKyAnKSonO1xuICAgIGNvbnN0IHBhdGhBYnNvbHV0ZSA9ICdcXFxcLyg/OicgKyBzZWdtZW50TnogKyBwYXRoQWJFbXB0eSArICcpPyc7XG4gICAgY29uc3QgcGF0aFJvb3RsZXNzID0gc2VnbWVudE56ICsgcGF0aEFiRW1wdHk7XG4gICAgY29uc3QgcGF0aE5vU2NoZW1lID0gc2VnbWVudE56TmMgKyBwYXRoQWJFbXB0eTtcbiAgICBjb25zdCBwYXRoQWJOb0F1dGhvcml0eSA9ICcoPzpcXFxcL1xcXFwvXFxcXC8nICsgc2VnbWVudCArIHBhdGhBYkVtcHR5ICsgJyknOyAgICAgLy8gVXNlZCBieSBmaWxlOi8vL1xuXG4gICAgLy8gaGllci1wYXJ0ID0gXCIvL1wiIGF1dGhvcml0eSBwYXRoXG5cbiAgICByZmMzOTg2LmhpZXJQYXJ0ID0gJyg/OicgKyAnKD86XFxcXC9cXFxcLycgKyBhdXRob3JpdHkgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhSb290bGVzcyArICd8JyArIHBhdGhBYk5vQXV0aG9yaXR5ICsgJyknO1xuICAgIHJmYzM5ODYuaGllclBhcnRDYXB0dXJlID0gJyg/OicgKyAnKD86XFxcXC9cXFxcLycgKyBhdXRob3JpdHlDYXB0dXJlICsgcGF0aEFiRW1wdHkgKyAnKScgKyAnfCcgKyBwYXRoQWJzb2x1dGUgKyAnfCcgKyBwYXRoUm9vdGxlc3MgKyAnKSc7XG5cbiAgICAvLyByZWxhdGl2ZS1wYXJ0ID0gXCIvL1wiIGF1dGhvcml0eSBwYXRoLWFiZW1wdHkgLyBwYXRoLWFic29sdXRlIC8gcGF0aC1ub3NjaGVtZSAvIHBhdGgtZW1wdHlcblxuICAgIHJmYzM5ODYucmVsYXRpdmVSZWYgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aE5vU2NoZW1lICsgJ3wnICsgcGF0aEVtcHR5ICsgJyknO1xuXG4gICAgLy8gcXVlcnkgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuICAgIC8vIHF1ZXJ5ID0gKiggcGNoYXIgLyBcIltcIiAvIFwiXVwiIC8gXCIvXCIgLyBcIj9cIiApXG5cbiAgICByZmMzOTg2LnF1ZXJ5ID0gJ1snICsgcGNoYXIgKyAnXFxcXC9cXFxcP10qKD89I3wkKSc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRmluaXNoIG1hdGNoaW5nIGVpdGhlciBhdCB0aGUgZnJhZ21lbnQgcGFydCAnfCcgZW5kIG9mIHRoZSBsaW5lLlxuICAgIHJmYzM5ODYucXVlcnlXaXRoU3F1YXJlQnJhY2tldHMgPSAnWycgKyBwY2hhciArICdcXFxcW1xcXFxdXFxcXC9cXFxcP10qKD89I3wkKSc7XG5cbiAgICAvLyBmcmFnbWVudCA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG5cbiAgICByZmMzOTg2LmZyYWdtZW50ID0gJ1snICsgcGNoYXIgKyAnXFxcXC9cXFxcP10qJztcblxuICAgIHJldHVybiByZmMzOTg2O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBpbnRlcm5hbHMucmZjMzk4NiA9IGludGVybmFscy5nZW5lcmF0ZSgpO1xuXG5cbmludGVybmFscy5jcmVhdGVSZWdleCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBjb25zdCByZmMgPSBpbnRlcm5hbHMucmZjMzk4NjtcblxuICAgIC8vIENvbnN0cnVjdCBleHByZXNzaW9uXG5cbiAgICBjb25zdCBxdWVyeSA9IG9wdGlvbnMuYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzID8gcmZjLnF1ZXJ5V2l0aFNxdWFyZUJyYWNrZXRzIDogcmZjLnF1ZXJ5O1xuICAgIGNvbnN0IHN1ZmZpeCA9ICcoPzpcXFxcPycgKyBxdWVyeSArICcpPycgKyAnKD86IycgKyByZmMuZnJhZ21lbnQgKyAnKT8kJztcblxuICAgIC8vIHJlbGF0aXZlLXJlZiA9IHJlbGF0aXZlLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuXG4gICAgaWYgKG9wdGlvbnMucmVsYXRpdmVPbmx5KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHJmYy5yZWxhdGl2ZVJlZiArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIHNjaGVtZXNcblxuICAgIGxldCBjdXN0b21TY2hlbWUgPSAnJztcbiAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBvcHRpb25zLnNjaGVtZSA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLnNjaGVtZSksICdzY2hlbWUgbXVzdCBiZSBhIFJlZ0V4cCwgU3RyaW5nLCBvciBBcnJheScpO1xuXG4gICAgICAgIGNvbnN0IHNjaGVtZXMgPSBbXS5jb25jYXQob3B0aW9ucy5zY2hlbWUpO1xuICAgICAgICBBc3NlcnQoc2NoZW1lcy5sZW5ndGggPj0gMSwgJ3NjaGVtZSBtdXN0IGhhdmUgYXQgbGVhc3QgMSBzY2hlbWUgc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgYXJyYXkgaW50byBhIHN0cmluZyB0byBiZSB1c2VkIHRvIG1hdGNoIHRoZSBzY2hlbWVzXG5cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IHNjaGVtZXNbaV07XG4gICAgICAgICAgICBBc3NlcnQoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwIHx8IHR5cGVvZiBzY2hlbWUgPT09ICdzdHJpbmcnLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgUmVnRXhwIG9yIFN0cmluZycpO1xuXG4gICAgICAgICAgICBpZiAoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHNjaGVtZS5zb3VyY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQocmZjLnNjaGVtZVJlZ2V4LnRlc3Qoc2NoZW1lKSwgJ3NjaGVtZSBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHZhbGlkIHNjaGVtZScpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnMucHVzaChFc2NhcGVSZWdleChzY2hlbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1c3RvbVNjaGVtZSA9IHNlbGVjdGlvbnMuam9pbignfCcpO1xuICAgIH1cblxuICAgIC8vIFVSSSA9IHNjaGVtZSBcIjpcIiBoaWVyLXBhcnQgWyBcIj9cIiBxdWVyeSBdIFsgXCIjXCIgZnJhZ21lbnQgXVxuXG4gICAgY29uc3Qgc2NoZW1lID0gY3VzdG9tU2NoZW1lID8gJyg/OicgKyBjdXN0b21TY2hlbWUgKyAnKScgOiByZmMuc2NoZW1lO1xuICAgIGNvbnN0IGFic29sdXRlID0gJyg/OicgKyBzY2hlbWUgKyAnOicgKyAob3B0aW9ucy5kb21haW4gPyByZmMuaGllclBhcnRDYXB0dXJlIDogcmZjLmhpZXJQYXJ0KSArICcpJztcbiAgICBjb25zdCBwcmVmaXggPSBvcHRpb25zLmFsbG93UmVsYXRpdmUgPyAnKD86JyArIGFic29sdXRlICsgJ3wnICsgcmZjLnJlbGF0aXZlUmVmICsgJyknIDogYWJzb2x1dGU7XG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArIHN1ZmZpeCk7XG4gICAgcmVnZXguc2NoZW1lID0gY3VzdG9tU2NoZW1lO1xuICAgIHJldHVybiByZWdleDtcbn07XG5cblxuaW50ZXJuYWxzLnVyaVJlZ2V4ID0gaW50ZXJuYWxzLmNyZWF0ZVJlZ2V4KHt9KTtcblxuXG5leHBvcnRzLmNyZWF0ZVJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKG9wdGlvbnMuc2NoZW1lIHx8XG4gICAgICAgIG9wdGlvbnMuYWxsb3dSZWxhdGl2ZSB8fFxuICAgICAgICBvcHRpb25zLnJlbGF0aXZlT25seSB8fFxuICAgICAgICBvcHRpb25zLmFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyB8fFxuICAgICAgICBvcHRpb25zLmRvbWFpbikge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY3JlYXRlUmVnZXgob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy51cmlSZWdleDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5NYXAgPSBjbGFzcyBleHRlbmRzIE1hcCB7XG5cbiAgICBzbGljZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5NYXAodGhpcyk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ3N5bWJvbCcsXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIG1hcDogeyBpbml0OiBuZXcgaW50ZXJuYWxzLk1hcCgpIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICAgICAgY29uc3QgbG9va3VwID0gc2NoZW1hLiRfdGVybXMubWFwLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsb29rdXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc2NoZW1hLl9mbGFncy5vbmx5IHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N5bWJvbC5tYXAnLCB7IG1hcDogc2NoZW1hLiRfdGVybXMubWFwIH0pIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3ltYm9sLmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgbWV0aG9kKGl0ZXJhYmxlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlcmFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZXJhYmxlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0LmVudHJpZXMoaXRlcmFibGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEFzc2VydChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdLCAnSXRlcmFibGUgbXVzdCBiZSBhbiBpdGVyYWJsZSBvciBvYmplY3QnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChlbnRyeSAmJiBlbnRyeVtTeW1ib2wuaXRlcmF0b3JdLCAnRW50cnkgbXVzdCBiZSBhbiBpdGVyYWJsZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBlbnRyeTtcblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGtleSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Yga2V5ICE9PSAnc3ltYm9sJywgJ0tleSBtdXN0IG5vdCBiZSBvZiB0eXBlIG9iamVjdCwgZnVuY3Rpb24sIG9yIFN5bWJvbCcpO1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJywgJ1ZhbHVlIG11c3QgYmUgYSBTeW1ib2wnKTtcblxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzeW1ib2xzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmoudmFsaWQoLi4uc3ltYm9scyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWFwKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gb2JqLm1hcChkZXNjLm1hcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ3N5bWJvbC5iYXNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBzeW1ib2wnLFxuICAgICAgICAnc3ltYm9sLm1hcCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIG9uZSBvZiB7eyNtYXB9fSdcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBJZ25vcmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9pZ25vcmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBTdGF0ZSA9IHJlcXVpcmUoJy4vc3RhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgcmVzdWx0OiBTeW1ib2woJ3Jlc3VsdCcpXG59O1xuXG5cbmV4cG9ydHMuZW50cnkgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgQXNzZXJ0KHByZWZzLndhcm5pbmdzID09PSB1bmRlZmluZWQsICdDYW5ub3Qgb3ZlcnJpZGUgd2FybmluZ3MgcHJlZmVyZW5jZSBpbiBzeW5jaHJvbm91cyB2YWxpZGF0aW9uJyk7XG4gICAgICAgIHNldHRpbmdzID0gQ29tbW9uLnByZWZlcmVuY2VzKENvbW1vbi5kZWZhdWx0cywgcHJlZnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5lbnRyeSh2YWx1ZSwgc2NoZW1hLCBzZXR0aW5ncyk7XG4gICAgQXNzZXJ0KCFyZXN1bHQubWFpbnN0YXkuZXh0ZXJuYWxzLmxlbmd0aCwgJ1NjaGVtYSB3aXRoIGV4dGVybmFsIHJ1bGVzIG11c3QgdXNlIHZhbGlkYXRlQXN5bmMoKScpO1xuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcblxuICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgb3V0Y29tZS5lcnJvciA9IHJlc3VsdC5lcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lm1haW5zdGF5Lndhcm5pbmdzLmxlbmd0aCkge1xuICAgICAgICBvdXRjb21lLndhcm5pbmcgPSBFcnJvcnMuZGV0YWlscyhyZXN1bHQubWFpbnN0YXkud2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQubWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IHJlc3VsdC5tYWluc3RheS5kZWJ1ZztcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Y29tZTtcbn07XG5cblxuZXhwb3J0cy5lbnRyeUFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKHByZWZzKSB7XG4gICAgICAgIHNldHRpbmdzID0gQ29tbW9uLnByZWZlcmVuY2VzKENvbW1vbi5kZWZhdWx0cywgcHJlZnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5lbnRyeSh2YWx1ZSwgc2NoZW1hLCBzZXR0aW5ncyk7XG4gICAgY29uc3QgbWFpbnN0YXkgPSByZXN1bHQubWFpbnN0YXk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvci5kZWJ1ZyA9IG1haW5zdGF5LmRlYnVnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5leHRlcm5hbHMubGVuZ3RoKSB7XG4gICAgICAgIGxldCByb290ID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kLCBwYXRoLCBsYWJlbCB9IG9mIG1haW5zdGF5LmV4dGVybmFscykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSByb290O1xuICAgICAgICAgICAgbGV0IGtleTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQ7XG5cbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBSZWFjaChyb290LCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudFtrZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IG1ldGhvZChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID09PSBub2RlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRba2V5XSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICs9IGAgKCR7bGFiZWx9KWA7ICAgICAgIC8vIENoYW5nZSBtZXNzYWdlIHRvIGluY2x1ZGUgcGF0aFxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHJvb3Q7XG4gICAgfVxuXG4gICAgaWYgKCFzZXR0aW5ncy53YXJuaW5ncyAmJlxuICAgICAgICAhc2V0dGluZ3MuZGVidWcpIHtcblxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IG91dGNvbWUgPSB7IHZhbHVlOiByZXN1bHQudmFsdWUgfTtcbiAgICBpZiAobWFpbnN0YXkud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG91dGNvbWUud2FybmluZyA9IEVycm9ycy5kZXRhaWxzKG1haW5zdGF5Lndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAobWFpbnN0YXkuZGVidWcpIHtcbiAgICAgICAgb3V0Y29tZS5kZWJ1ZyA9IG1haW5zdGF5LmRlYnVnO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5pbnRlcm5hbHMuZW50cnkgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIC8vIFByZXBhcmUgc3RhdGVcblxuICAgIGNvbnN0IHsgdHJhY2VyLCBjbGVhbnVwIH0gPSBpbnRlcm5hbHMudHJhY2VyKHNjaGVtYSwgcHJlZnMpO1xuICAgIGNvbnN0IGRlYnVnID0gcHJlZnMuZGVidWcgPyBbXSA6IG51bGw7XG4gICAgY29uc3QgbGlua3MgPSBzY2hlbWEuX2lkcy5fc2NoZW1hQ2hhaW4gPyBuZXcgTWFwKCkgOiBudWxsO1xuICAgIGNvbnN0IG1haW5zdGF5ID0geyBleHRlcm5hbHM6IFtdLCB3YXJuaW5nczogW10sIHRyYWNlciwgZGVidWcsIGxpbmtzIH07XG4gICAgY29uc3Qgc2NoZW1hcyA9IHNjaGVtYS5faWRzLl9zY2hlbWFDaGFpbiA/IFt7IHNjaGVtYSB9XSA6IG51bGw7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoW10sIFtdLCB7IG1haW5zdGF5LCBzY2hlbWFzIH0pO1xuXG4gICAgLy8gVmFsaWRhdGUgdmFsdWVcblxuICAgIGNvbnN0IHJlc3VsdCA9IGV4cG9ydHMudmFsaWRhdGUodmFsdWUsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIC8vIFByb2Nlc3MgdmFsdWUgYW5kIGVycm9yc1xuXG4gICAgaWYgKGNsZWFudXApIHtcbiAgICAgICAgc2NoZW1hLiRfcm9vdC51bnRyYWNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3IgPSBFcnJvcnMucHJvY2VzcyhyZXN1bHQuZXJyb3JzLCB2YWx1ZSwgcHJlZnMpO1xuICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQudmFsdWUsIGVycm9yLCBtYWluc3RheSB9O1xufTtcblxuXG5pbnRlcm5hbHMudHJhY2VyID0gZnVuY3Rpb24gKHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGlmIChzY2hlbWEuJF9yb290Ll90cmFjZXIpIHtcbiAgICAgICAgcmV0dXJuIHsgdHJhY2VyOiBzY2hlbWEuJF9yb290Ll90cmFjZXIuX3JlZ2lzdGVyKHNjaGVtYSkgfTtcbiAgICB9XG5cbiAgICBpZiAocHJlZnMuZGVidWcpIHtcbiAgICAgICAgQXNzZXJ0KHNjaGVtYS4kX3Jvb3QudHJhY2UsICdEZWJ1ZyBtb2RlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgcmV0dXJuIHsgdHJhY2VyOiBzY2hlbWEuJF9yb290LnRyYWNlKCkuX3JlZ2lzdGVyKHNjaGVtYSksIGNsZWFudXA6IHRydWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmFjZXI6IGludGVybmFscy5pZ25vcmUgfTtcbn07XG5cblxuZXhwb3J0cy52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcyA9IHt9KSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgc3RhdGUgYW5kIHNldHRpbmdzXG5cbiAgICBpZiAoc2NoZW1hLl9wcmVmZXJlbmNlcykge1xuICAgICAgICBwcmVmcyA9IGludGVybmFscy5wcmVmcyhzY2hlbWEsIHByZWZzKTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZVxuXG4gICAgaWYgKHNjaGVtYS5fY2FjaGUgJiZcbiAgICAgICAgcHJlZnMuY2FjaGUpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX2NhY2hlLmdldCh2YWx1ZSk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3ZhbGlkYXRlJywgJ2NhY2hlZCcsICEhcmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhlbHBlcnNcblxuICAgIGNvbnN0IGNyZWF0ZUVycm9yID0gKGNvZGUsIGxvY2FsLCBsb2NhbFN0YXRlKSA9PiBzY2hlbWEuJF9jcmVhdGVFcnJvcihjb2RlLCB2YWx1ZSwgbG9jYWwsIGxvY2FsU3RhdGUgfHwgc3RhdGUsIHByZWZzKTtcbiAgICBjb25zdCBoZWxwZXJzID0ge1xuICAgICAgICBvcmlnaW5hbDogdmFsdWUsXG4gICAgICAgIHByZWZzLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IsXG4gICAgICAgIHdhcm46IChjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkgPT4gc3RhdGUubWFpbnN0YXkud2FybmluZ3MucHVzaChjcmVhdGVFcnJvcihjb2RlLCBsb2NhbCwgbG9jYWxTdGF0ZSkpLFxuICAgICAgICBtZXNzYWdlOiAobWVzc2FnZXMsIGxvY2FsKSA9PiBzY2hlbWEuJF9jcmVhdGVFcnJvcignY3VzdG9tJywgdmFsdWUsIGxvY2FsLCBzdGF0ZSwgcHJlZnMsIHsgbWVzc2FnZXMgfSlcbiAgICB9O1xuXG4gICAgLy8gUHJlcGFyZVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmVudHJ5KHNjaGVtYSwgc3RhdGUpO1xuXG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl9kZWZpbml0aW9uO1xuICAgIGlmIChkZWYucHJlcGFyZSAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHByZWZzLmNvbnZlcnQpIHtcblxuICAgICAgICBjb25zdCBwcmVwYXJlZCA9IGRlZi5wcmVwYXJlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKHByZXBhcmVkKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdwcmVwYXJlJywgdmFsdWUsIHByZXBhcmVkLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHByZXBhcmVkLnZhbHVlLCBbXS5jb25jYXQocHJlcGFyZWQuZXJyb3JzKSwgaGVscGVycyk7ICAgICAgICAgLy8gUHJlcGFyZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcHJlcGFyZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlIGNvZXJjaW9uXG5cbiAgICBpZiAoZGVmLmNvZXJjZSAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHByZWZzLmNvbnZlcnQgJiZcbiAgICAgICAgKCFkZWYuY29lcmNlLmZyb20gfHwgZGVmLmNvZXJjZS5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpKSB7XG5cbiAgICAgICAgY29uc3QgY29lcmNlZCA9IGRlZi5jb2VyY2UubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGNvZXJjZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2NvZXJjZWQnLCB2YWx1ZSwgY29lcmNlZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY29lcmNlZC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKGNvZXJjZWQudmFsdWUsIFtdLmNvbmNhdChjb2VyY2VkLmVycm9ycyksIGhlbHBlcnMpOyAgICAgICAgICAgLy8gQ29lcmNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBjb2VyY2VkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1wdHkgdmFsdWVcblxuICAgIGNvbnN0IGVtcHR5ID0gc2NoZW1hLl9mbGFncy5lbXB0eTtcbiAgICBpZiAoZW1wdHkgJiZcbiAgICAgICAgZW1wdHkuJF9tYXRjaChpbnRlcm5hbHMudHJpbSh2YWx1ZSwgc2NoZW1hKSwgc3RhdGUubmVzdChlbXB0eSksIENvbW1vbi5kZWZhdWx0cykpIHtcblxuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdlbXB0eScsIHZhbHVlLCB1bmRlZmluZWQpO1xuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBQcmVzZW5jZSByZXF1aXJlbWVudHMgKHJlcXVpcmVkLCBvcHRpb25hbCwgZm9yYmlkZGVuKVxuXG4gICAgY29uc3QgcHJlc2VuY2UgPSBvdmVycmlkZXMucHJlc2VuY2UgfHwgc2NoZW1hLl9mbGFncy5wcmVzZW5jZSB8fCAoc2NoZW1hLl9mbGFncy5fZW5kZWRTd2l0Y2ggPyAnaWdub3JlJyA6IHByZWZzLnByZXNlbmNlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkucmVxdWlyZWQnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy5kZWZhdWx0ICE9PSBDb21tb24uc3ltYm9scy5kZWVwRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIHt9KTtcbiAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnVua25vd24nLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKV0sIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIC8vIEFsbG93ZWQgdmFsdWVzXG5cbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgIGlmIChzY2hlbWEuX3ZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5fdmFsaWRzLmdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBzY2hlbWEuX2ZsYWdzLmluc2Vuc2l0aXZlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAocHJlZnMuY29udmVydCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ZhbGlkcycsIHZhbHVlLCBtYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtYXRjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAndmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBudWxsLCBoZWxwZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm9ubHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkub25seScsIHZhbHVlLCB7IHZhbGlkczogc2NoZW1hLl92YWxpZHMudmFsdWVzKHsgZGlzcGxheTogdHJ1ZSB9KSB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbcmVwb3J0XSwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZW5pZWQgdmFsdWVzXG5cbiAgICBpZiAoc2NoZW1hLl9pbnZhbGlkcykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHNjaGVtYS5faW52YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5maWx0ZXIoc2NoZW1hLCBzdGF0ZSwgJ2ludmFsaWQnLCBtYXRjaCk7XG4gICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LmludmFsaWQnLCB2YWx1ZSwgeyBpbnZhbGlkczogc2NoZW1hLl9pbnZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJhc2UgdHlwZVxuXG4gICAgaWYgKGRlZi52YWxpZGF0ZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gZGVmLnZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Jhc2UnLCB2YWx1ZSwgYmFzZS52YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShiYXNlLmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLmJhc2UuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTsgICAgICAgICAgLy8gQmFzZSBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGVzdHNcblxuICAgIGlmICghc2NoZW1hLl9ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnJ1bGVzKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBmdW5jdGlvbiAodmFsdWUsIGVycm9ycywgaGVscGVycykge1xuXG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWEuX3J1bGVzKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBzY2hlbWEuX2RlZmluaXRpb24ucnVsZXNbcnVsZS5tZXRob2RdO1xuXG4gICAgICAgIC8vIFNraXAgcnVsZXMgdGhhdCBhcmUgYWxzbyBhcHBsaWVkIGluIGNvZXJjZSBzdGVwXG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uY29udmVydCAmJlxuICAgICAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZnVsbCcpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNvbHZlIHJlZmVyZW5jZXNcblxuICAgICAgICBsZXQgcmV0O1xuICAgICAgICBsZXQgYXJncyA9IHJ1bGUuYXJncztcbiAgICAgICAgaWYgKHJ1bGUuX3Jlc29sdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcmdzID0gT2JqZWN0LmFzc2lnbih7fSwgYXJncyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoYWxsb3cgY29weVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcnVsZS5fcmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gZGVmaW5pdGlvbi5hcmdzQnlOYW1lLmdldChrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBhcmdzW2tleV0ucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gcmVzb2x2ZXIubm9ybWFsaXplID8gcmVzb2x2ZXIubm9ybWFsaXplKHJlc29sdmVkKSA6IHJlc29sdmVkO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW52YWxpZCA9IENvbW1vbi52YWxpZGF0ZUFyZyhub3JtYWxpemVkLCBudWxsLCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCByZXNvbHZlZCwgeyBhcmc6IGtleSwgcmVmOiBhcmdzW2tleV0sIHJlYXNvbjogaW52YWxpZCB9LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzW2tleV0gPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVzdCBydWxlXG5cbiAgICAgICAgcmV0ID0gcmV0IHx8IGRlZmluaXRpb24udmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIGFyZ3MsIHJ1bGUpOyAgICAgICAgICAgLy8gVXNlIHJldCBpZiBhbHJlYWR5IHNldCB0byByZWZlcmVuY2UgZXJyb3JcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMucnVsZShyZXQsIHJ1bGUpO1xuICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ2Vycm9yJyk7XG5cbiAgICAgICAgICAgIGlmIChydWxlLndhcm4pIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIHJlc3VsdC5lcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdwYXNzJyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdydWxlJywgdmFsdWUsIHJlc3VsdC52YWx1ZSwgcnVsZS5uYW1lKTtcbiAgICAgICAgICAgIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJ1bGUgPSBmdW5jdGlvbiAocmV0LCBydWxlKSB7XG5cbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCkge1xuICAgICAgICBpbnRlcm5hbHMuZXJyb3IocmV0LCBydWxlKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBbcmV0XSwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXQpICYmXG4gICAgICAgIChyZXRbMF0gaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0IHx8IHJldFswXSBpbnN0YW5jZW9mIEVycm9yKSkge1xuXG4gICAgICAgIHJldC5mb3JFYWNoKChyZXBvcnQpID0+IGludGVybmFscy5lcnJvcihyZXBvcnQsIHJ1bGUpKTtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiByZXQsIHZhbHVlOiBudWxsIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZXJyb3JzOiBudWxsLCB2YWx1ZTogcmV0IH07XG59O1xuXG5cbmludGVybmFscy5lcnJvciA9IGZ1bmN0aW9uIChyZXBvcnQsIHJ1bGUpIHtcblxuICAgIGlmIChydWxlLm1lc3NhZ2UpIHtcbiAgICAgICAgcmVwb3J0Ll9zZXRUZW1wbGF0ZShydWxlLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXBvcnQ7XG59O1xuXG5cbmludGVybmFscy5maW5hbGl6ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgY29uc3QgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgIC8vIEZhaWxvdmVyIHZhbHVlXG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmYWlsb3ZlciA9IGludGVybmFscy5kZWZhdWx0KCdmYWlsb3ZlcicsIHVuZGVmaW5lZCwgZXJyb3JzLCBoZWxwZXJzKTtcbiAgICAgICAgaWYgKGZhaWxvdmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2ZhaWxvdmVyJywgdmFsdWUsIGZhaWxvdmVyKTtcbiAgICAgICAgICAgIHZhbHVlID0gZmFpbG92ZXI7XG4gICAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVycm9yIG92ZXJyaWRlXG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCAmJlxuICAgICAgICBzY2hlbWEuX2ZsYWdzLmVycm9yKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuX2ZsYWdzLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBzY2hlbWEuX2ZsYWdzLmVycm9yKGVycm9ycyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IFtlcnJvcnNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgICAgICAgICAgICAgIEFzc2VydChlcnJvciBpbnN0YW5jZW9mIEVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3JzLlJlcG9ydCwgJ2Vycm9yKCkgbXVzdCByZXR1cm4gYW4gRXJyb3Igb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMgPSBbc2NoZW1hLl9mbGFncy5lcnJvcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0ZWQgPSBpbnRlcm5hbHMuZGVmYXVsdCgnZGVmYXVsdCcsIHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdkZWZhdWx0JywgdmFsdWUsIGRlZmF1bHRlZCk7XG4gICAgICAgIHZhbHVlID0gZGVmYXVsdGVkO1xuICAgIH1cblxuICAgIC8vIENhc3RcblxuICAgIGlmIChzY2hlbWEuX2ZsYWdzLmNhc3QgJiZcbiAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIGNvbnN0IGNhc3RlciA9IHNjaGVtYS5fZGVmaW5pdGlvbi5jYXN0W3NjaGVtYS5fZmxhZ3MuY2FzdF07XG4gICAgICAgIGlmIChjYXN0ZXIuZnJvbSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhc3RlZCA9IGNhc3Rlci50byh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIudmFsdWUoc3RhdGUsICdjYXN0JywgdmFsdWUsIGNhc3RlZCwgc2NoZW1hLl9mbGFncy5jYXN0KTtcbiAgICAgICAgICAgIHZhbHVlID0gY2FzdGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0ZXJuYWxzXG5cbiAgICBpZiAoc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLmV4dGVybmFscyAmJlxuICAgICAgICBwcmVmcy5fZXh0ZXJuYWxzICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZWQgZm9yIG1hdGNoaW5nXG5cbiAgICAgICAgZm9yIChjb25zdCB7IG1ldGhvZCB9IG9mIHNjaGVtYS4kX3Rlcm1zLmV4dGVybmFscykge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkuZXh0ZXJuYWxzLnB1c2goeyBtZXRob2QsIHBhdGg6IHN0YXRlLnBhdGgsIGxhYmVsOiBFcnJvcnMubGFiZWwoc2NoZW1hLl9mbGFncywgc3RhdGUsIHByZWZzKSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc3VsdFxuXG4gICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogbnVsbCB9O1xuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MucmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHNjaGVtYS5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnID8gdW5kZWZpbmVkIDogLyogcmF3ICovIGhlbHBlcnMub3JpZ2luYWw7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQsIHZhbHVlLCByZXN1bHQudmFsdWUpO1xuICAgICAgICBzdGF0ZS5zaGFkb3codmFsdWUsIHNjaGVtYS5fZmxhZ3MucmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZVxuXG4gICAgaWYgKHNjaGVtYS5fY2FjaGUgJiZcbiAgICAgICAgcHJlZnMuY2FjaGUgIT09IGZhbHNlICYmXG4gICAgICAgICFzY2hlbWEuX3JlZnMubGVuZ3RoKSB7XG5cbiAgICAgICAgc2NoZW1hLl9jYWNoZS5zZXQoaGVscGVycy5vcmlnaW5hbCwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5pbnRlcm5hbHMucHJlZnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgY29uc3QgaXNEZWZhdWx0T3B0aW9ucyA9IHByZWZzID09PSBDb21tb24uZGVmYXVsdHM7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiZcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10pIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgfVxuXG4gICAgcHJlZnMgPSBDb21tb24ucHJlZmVyZW5jZXMocHJlZnMsIHNjaGVtYS5fcHJlZmVyZW5jZXMpO1xuICAgIGlmIChpc0RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHNjaGVtYS5fcHJlZmVyZW5jZXNbQ29tbW9uLnN5bWJvbHMucHJlZnNdID0gcHJlZnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZzO1xufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChmbGFnLCB2YWx1ZSwgZXJyb3JzLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5fZmxhZ3NbZmxhZ107XG4gICAgaWYgKHByZWZzLm5vRGVmYXVsdHMgfHxcbiAgICAgICAgc291cmNlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIGZsYWcsICdmdWxsJyk7XG5cbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBzb3VyY2UubGVuZ3RoID4gMCA/IFtDbG9uZShzdGF0ZS5hbmNlc3RvcnNbMF0pLCBwcmVmc10gOiBbXTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcihgYW55LiR7ZmxhZ31gLCBudWxsLCB7IGVycm9yOiBlcnIgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UubGl0ZXJhbDtcbiAgICB9XG5cbiAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ2xvbmUoc291cmNlKTtcbn07XG5cblxuaW50ZXJuYWxzLnRyaW0gPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSkge1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRyaW0gPSBzY2hlbWEuJF9nZXRSdWxlKCd0cmltJyk7XG4gICAgaWYgKCF0cmltIHx8XG4gICAgICAgICF0cmltLmFyZ3MuZW5hYmxlZCkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xufTtcblxuXG5pbnRlcm5hbHMuaWdub3JlID0ge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGVidWc6IElnbm9yZSxcbiAgICBlbnRyeTogSWdub3JlLFxuICAgIGZpbHRlcjogSWdub3JlLFxuICAgIGxvZzogSWdub3JlLFxuICAgIHJlc29sdmU6IElnbm9yZSxcbiAgICB2YWx1ZTogSWdub3JlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IERlZXBFcXVhbCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlZhbHVlcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHZhbHVlcywgcmVmcykge1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBTZXQodmFsdWVzKTtcbiAgICAgICAgdGhpcy5fcmVmcyA9IG5ldyBTZXQocmVmcyk7XG4gICAgICAgIHRoaXMuX2xvd2VyY2FzZSA9IGludGVybmFscy5sb3dlcmNhc2VzKHZhbHVlcyk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcnJpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMuc2l6ZSArIHRoaXMuX3JlZnMuc2l6ZTtcbiAgICB9XG5cbiAgICBhZGQodmFsdWUsIHJlZnMpIHtcblxuICAgICAgICAvLyBSZWZlcmVuY2VcblxuICAgICAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVmcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVmcy5hZGQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZnMpIHsgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwcGVkIGluIGEgbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5yZWdpc3Rlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZVxuXG4gICAgICAgIGlmICghdGhpcy5oYXModmFsdWUsIG51bGwsIG51bGwsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVzLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLnNldCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHJlbW92ZSkge1xuXG4gICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgaW50ZXJuYWxzLlZhbHVlcygpO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnNvdXJjZS5fdmFsdWVzLCAuLi5zb3VyY2UuX3JlZnNdKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmFkZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4ucmVtb3ZlLl92YWx1ZXMsIC4uLnJlbW92ZS5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggPyB0YXJnZXQgOiBudWxsO1xuICAgIH1cblxuICAgIHJlbW92ZSh2YWx1ZSkge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVmcy5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsdWVcblxuICAgICAgICB0aGlzLl92YWx1ZXMuZGVsZXRlKHZhbHVlKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fbG93ZXJjYXNlLmRlbGV0ZSh2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhcyh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKTtcbiAgICB9XG5cbiAgICBnZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICBpZiAoIXRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW1wbGUgbWF0Y2hcblxuICAgICAgICBpZiAodGhpcy5fdmFsdWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlIGluc2Vuc2l0aXZlIHN0cmluZyBtYXRjaFxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB2YWx1ZSAmJlxuICAgICAgICAgICAgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICAgICAgY29uc3QgZm91bmQgPSB0aGlzLl9sb3dlcmNhc2UuZ2V0KHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZvdW5kIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3JlZnMuc2l6ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYmplY3RzXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZmVyZW5jZXNcblxuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIHRoaXMuX3JlZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgaW46IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSAhcmVmLmluIHx8IHR5cGVvZiByZXNvbHZlZCAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBbcmVzb2x2ZWRdXG4gICAgICAgICAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShyZXNvbHZlZCkgPyByZXNvbHZlZCA6IE9iamVjdC5rZXlzKHJlc29sdmVkKTtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZW5zaXRpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbSwgcmVmIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoRGVlcEVxdWFsKGl0ZW0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCByZWYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvdmVycmlkZSgpIHtcblxuICAgICAgICB0aGlzLl9vdmVycmlkZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFsdWVzKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5kaXNwbGF5KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgWy4uLnRoaXMuX3ZhbHVlcywgLi4udGhpcy5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKFsuLi50aGlzLl92YWx1ZXMsIC4uLnRoaXMuX3JlZnNdKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgaW50ZXJuYWxzLlZhbHVlcyh0aGlzLl92YWx1ZXMsIHRoaXMuX3JlZnMpO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIEFzc2VydCghc291cmNlLl9vdmVycmlkZSwgJ0Nhbm5vdCBjb25jYXQgb3ZlcnJpZGUgc2V0IG9mIHZhbHVlcycpO1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBpbnRlcm5hbHMuVmFsdWVzKFsuLi50aGlzLl92YWx1ZXMsIC4uLnNvdXJjZS5fdmFsdWVzXSwgWy4uLnRoaXMuX3JlZnMsIC4uLnNvdXJjZS5fcmVmc10pO1xuICAgICAgICBzZXQuX292ZXJyaWRlID0gdGhpcy5fb3ZlcnJpZGU7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9vdmVycmlkZSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHsgb3ZlcnJpZGU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3ZhbHVlcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB7IHZhbHVlIH0gOiB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMuX3JlZnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaCh2YWx1ZS5kZXNjcmliZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMudmFsdWVzXSA9IHRydWU7XG5cblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZS5zbGljZSA9IGludGVybmFscy5WYWx1ZXMucHJvdG90eXBlLmNsb25lO1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmxvd2VyY2FzZXMgPSBmdW5jdGlvbiAoZnJvbSkge1xuXG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgaWYgKGZyb20pIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBmcm9tKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBNaW1lRGIgPSByZXF1aXJlKCdtaW1lLWRiL2RiLmpzb24nKTsgICAgICAgICAgLy8gTG9hZCBKU09OIGZpbGUgdG8gcHJldmVudCBsb2FkaW5nIG9yIGV4ZWN1dGluZyBjb2RlXG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLmNvbXByZXNzaWJsZVJ4ID0gL150ZXh0XFwvfFxcK2pzb24kfFxcK3RleHQkfFxcK3htbCQvO1xuXG5cbmludGVybmFscy5jb21waWxlID0gZnVuY3Rpb24gKG92ZXJyaWRlKSB7XG5cbiAgICBjb25zdCBkYiA9IEhvZWsuY2xvbmUoTWltZURiKTtcbiAgICBIb2VrLm1lcmdlKGRiLCBvdmVycmlkZSwgeyBudWxsT3ZlcnJpZGU6IHRydWUsIG1lcmdlQXJyYXlzOiBmYWxzZSB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgYnlUeXBlOiBkYixcbiAgICAgICAgYnlFeHRlbnNpb246IHt9XG4gICAgfTtcblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZXN1bHQuYnlUeXBlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IG1pbWUgPSByZXN1bHQuYnlUeXBlW3R5cGVdO1xuICAgICAgICBtaW1lLnR5cGUgPSBtaW1lLnR5cGUgfHwgdHlwZTtcbiAgICAgICAgbWltZS5zb3VyY2UgPSBtaW1lLnNvdXJjZSB8fCAnbWltZS1kYic7XG4gICAgICAgIG1pbWUuZXh0ZW5zaW9ucyA9IG1pbWUuZXh0ZW5zaW9ucyB8fCBbXTtcbiAgICAgICAgbWltZS5jb21wcmVzc2libGUgPSAobWltZS5jb21wcmVzc2libGUgIT09IHVuZGVmaW5lZCA/IG1pbWUuY29tcHJlc3NpYmxlIDogaW50ZXJuYWxzLmNvbXByZXNzaWJsZVJ4LnRlc3QodHlwZSkpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KCFtaW1lLnByZWRpY2F0ZSB8fCB0eXBlb2YgbWltZS5wcmVkaWNhdGUgPT09ICdmdW5jdGlvbicsICdwcmVkaWNhdGUgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWltZS5leHRlbnNpb25zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSBtaW1lLmV4dGVuc2lvbnNbal07XG4gICAgICAgICAgICByZXN1bHQuYnlFeHRlbnNpb25bZXh0XSA9IG1pbWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1pbW9zIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbnMub3ZlcnJpZGUgPyBpbnRlcm5hbHMuY29tcGlsZShvcHRpb25zLm92ZXJyaWRlKSA6IGludGVybmFscy5iYXNlO1xuICAgICAgICB0aGlzLl9ieVR5cGUgPSByZXN1bHQuYnlUeXBlO1xuICAgICAgICB0aGlzLl9ieUV4dGVuc2lvbiA9IHJlc3VsdC5ieUV4dGVuc2lvbjtcbiAgICB9XG5cbiAgICBwYXRoKHBhdGgpIHtcblxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBQYXRoLmV4dG5hbWUocGF0aCkuc2xpY2UoMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbWltZSA9IHRoaXMuX2J5RXh0ZW5zaW9uW2V4dGVuc2lvbl0gfHwge307XG5cbiAgICAgICAgaWYgKG1pbWUucHJlZGljYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWltZS5wcmVkaWNhdGUoSG9lay5jbG9uZShtaW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWltZTtcbiAgICB9XG5cbiAgICB0eXBlKHR5cGUpIHtcblxuICAgICAgICB0eXBlID0gdHlwZS5zcGxpdCgnOycsIDEpWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgbWltZSA9IHRoaXMuX2J5VHlwZVt0eXBlXTtcbiAgICAgICAgaWYgKCFtaW1lKSB7XG4gICAgICAgICAgICBtaW1lID0ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgc291cmNlOiAnbWltb3MnLFxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbXByZXNzaWJsZTogaW50ZXJuYWxzLmNvbXByZXNzaWJsZVJ4LnRlc3QodHlwZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX2J5VHlwZVt0eXBlXSA9IG1pbWU7XG4gICAgICAgICAgICByZXR1cm4gbWltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW1lLnByZWRpY2F0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pbWUucHJlZGljYXRlKEhvZWsuY2xvbmUobWltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1pbWU7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuYmFzZSA9IGludGVybmFscy5jb21waWxlKCk7ICAgICAgIC8vIFByZXZlbnRzIGFuIGV4cGVuc2l2ZSBjb3B5IG9uIGVhY2ggY29uc3RydWN0b3Igd2hlbiBubyBjdXN0b21pemF0aW9uIGlzIG5lZWRlZFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IFZpc2UgPSByZXF1aXJlKCdAaGFwaS92aXNlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jb21waWxlID0gZnVuY3Rpb24gKG5lZWRsZSkge1xuXG4gICAgSG9lay5hc3NlcnQobmVlZGxlICYmIG5lZWRsZS5sZW5ndGgsICdNaXNzaW5nIG5lZWRsZScpO1xuICAgIEhvZWsuYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihuZWVkbGUpLCAnTmVlZGxlIG11c3QgYmUgYSBidWZmZXInKTtcblxuICAgIGNvbnN0IHByb2ZpbGUgPSB7XG4gICAgICAgIHZhbHVlOiBuZWVkbGUsXG4gICAgICAgIGxhc3RQb3M6IG5lZWRsZS5sZW5ndGggLSAxLFxuICAgICAgICBsYXN0OiBuZWVkbGVbbmVlZGxlLmxlbmd0aCAtIDFdLFxuICAgICAgICBsZW5ndGg6IG5lZWRsZS5sZW5ndGgsXG4gICAgICAgIGJhZENoYXJTaGlmdDogQnVmZmVyLmFsbG9jKDI1NikgICAgICAgICAgICAgICAgICAvLyBMb29rdXAgdGFibGUgb2YgaG93IG1hbnkgY2hhcmFjdGVycyBjYW4gYmUgc2tpcHBlZCBmb3IgZWFjaCBtYXRjaFxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gICAgICAgIHByb2ZpbGUuYmFkQ2hhclNoaWZ0W2ldID0gcHJvZmlsZS5sZW5ndGg7ICAgICAgIC8vIERlZmF1bHRzIHRvIHRoZSBmdWxsIGxlbmd0aCBvZiB0aGUgbmVlZGxlXG4gICAgfVxuXG4gICAgY29uc3QgbGFzdCA9IHByb2ZpbGUubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3Q7ICsraSkgeyAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBuZWVkbGUgKHNraXAgbGFzdCBzaW5jZSBpdHMgcG9zaXRpb24gaXMgYWxyZWFkeSB0aGUgZGVmYXVsdClcbiAgICAgICAgcHJvZmlsZS5iYWRDaGFyU2hpZnRbcHJvZmlsZS52YWx1ZVtpXV0gPSBsYXN0IC0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvZmlsZTtcbn07XG5cblxuZXhwb3J0cy5ob3JzcG9vbCA9IGZ1bmN0aW9uIChoYXlzdGFjaywgbmVlZGxlLCBzdGFydCkge1xuXG4gICAgSG9lay5hc3NlcnQoaGF5c3RhY2ssICdNaXNzaW5nIGhheXN0YWNrJyk7XG5cbiAgICBuZWVkbGUgPSAobmVlZGxlLmJhZENoYXJTaGlmdCA/IG5lZWRsZSA6IGV4cG9ydHMuY29tcGlsZShuZWVkbGUpKTtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlLmxlbmd0aDspIHsgICAgICAgLy8gSGFzIGVub3VnaCByb29tIHRvIGZpdCB0aGUgZW50aXJlIG5lZWRsZVxuICAgICAgICBjb25zdCBsYXN0Q2hhciA9IGhheXN0YWNrLnJlYWRVSW50OChpICsgbmVlZGxlLmxhc3RQb3MpO1xuICAgICAgICBpZiAobGFzdENoYXIgPT09IG5lZWRsZS5sYXN0ICYmXG4gICAgICAgICAgICBpbnRlcm5hbHMuc3RhcnRzV2l0aChoYXlzdGFjaywgbmVlZGxlLCBpKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gbmVlZGxlLmJhZENoYXJTaGlmdFtsYXN0Q2hhcl07ICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBuZXh0IHBvc3NpYmxlIHBvc2l0aW9uIGJhc2VkIG9uIGxhc3QgY2hhcmFjdGVyIGxvY2F0aW9uIGluIG5lZWRsZVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG5cblxuaW50ZXJuYWxzLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoaGF5c3RhY2ssIG5lZWRsZSwgcG9zKSB7XG5cbiAgICBpZiAoaGF5c3RhY2suc3RhcnRzV2l0aCkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2suc3RhcnRzV2l0aChuZWVkbGUudmFsdWUsIHBvcywgbmVlZGxlLmxhc3RQb3MpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVlZGxlLmxhc3RQb3M7ICsraSkge1xuICAgICAgICBpZiAobmVlZGxlLnZhbHVlW2ldICE9PSBoYXlzdGFjay5yZWFkVUludDgocG9zICsgaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5leHBvcnRzLmFsbCA9IGZ1bmN0aW9uIChoYXlzdGFjaywgbmVlZGxlLCBzdGFydCkge1xuXG4gICAgbmVlZGxlID0gZXhwb3J0cy5jb21waWxlKG5lZWRsZSk7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuXG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSAhPT0gLTEgJiYgaSA8IGhheXN0YWNrLmxlbmd0aDspIHtcblxuICAgICAgICBpID0gZXhwb3J0cy5ob3JzcG9vbChoYXlzdGFjaywgbmVlZGxlLCBpKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICBtYXRjaGVzLnB1c2goaSk7XG4gICAgICAgICAgICBpICs9IG5lZWRsZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlcztcbn07XG5cblxuaW50ZXJuYWxzLl9pbmRleE9mID0gZnVuY3Rpb24gKGhheXN0YWNrLCBuZWVkbGUpIHtcblxuICAgIEhvZWsuYXNzZXJ0KGhheXN0YWNrLCAnTWlzc2luZyBoYXlzdGFjaycpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlLmxlbmd0aDsgKytpKSB7ICAgICAgIC8vIEhhcyBlbm91Z2ggcm9vbSB0byBmaXQgdGhlIGVudGlyZSBuZWVkbGVcbiAgICAgICAgaWYgKGhheXN0YWNrLnN0YXJ0c1dpdGgobmVlZGxlLnZhbHVlLCBpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59O1xuXG5cbmV4cG9ydHMuU3RyZWFtID0gaW50ZXJuYWxzLlN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtLldyaXRhYmxlIHtcblxuICAgIGNvbnN0cnVjdG9yKG5lZWRsZSkge1xuXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5uZWVkbGUobmVlZGxlKTtcbiAgICAgICAgdGhpcy5faGF5c3RhY2sgPSBuZXcgVmlzZSgpO1xuICAgICAgICB0aGlzLl9pbmRleE9mID0gdGhpcy5fbmVlZGxlLmxlbmd0aCA+IDIgPyBleHBvcnRzLmhvcnNwb29sIDogaW50ZXJuYWxzLl9pbmRleE9mO1xuXG4gICAgICAgIHRoaXMub24oJ2ZpbmlzaCcsICgpID0+IHtcblxuICAgICAgICAgICAgLy8gRmx1c2ggb3V0IHRoZSByZW1haW5kZXJcblxuICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gdGhpcy5faGF5c3RhY2suY2h1bmtzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnaGF5c3RhY2snLCBjaHVua3NbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKTsgICAgIC8vIEdpdmUgcGVuZGluZyBldmVudHMgYSBjaGFuY2UgdG8gZmlyZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZWVkbGUobmVlZGxlKSB7XG5cbiAgICAgICAgdGhpcy5fbmVlZGxlID0gZXhwb3J0cy5jb21waWxlKG5lZWRsZSk7XG4gICAgfVxuXG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgbmV4dCkge1xuXG4gICAgICAgIHRoaXMuX2hheXN0YWNrLnB1c2goY2h1bmspO1xuXG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMuX2luZGV4T2YodGhpcy5faGF5c3RhY2ssIHRoaXMuX25lZWRsZSk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gLTEgJiZcbiAgICAgICAgICAgIGNodW5rLmxlbmd0aCA+PSB0aGlzLl9uZWVkbGUubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoKHRoaXMuX2hheXN0YWNrLmxlbmd0aCAtIGNodW5rLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobWF0Y2ggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9mbHVzaChtYXRjaCk7XG4gICAgICAgICAgICB0aGlzLl9oYXlzdGFjay5zaGlmdCh0aGlzLl9uZWVkbGUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbmVlZGxlJyk7XG5cbiAgICAgICAgICAgIG1hdGNoID0gdGhpcy5faW5kZXhPZih0aGlzLl9oYXlzdGFjaywgdGhpcy5fbmVlZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oYXlzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdENoZWNrZWQgPSB0aGlzLl9oYXlzdGFjay5sZW5ndGggLSB0aGlzLl9uZWVkbGUubGVuZ3RoICsgMTsgICAgICAgLy8gTm90IGVub3VnaCBzcGFjZSBmb3IgSG9yc3Bvb2xcbiAgICAgICAgICAgIGxldCBpID0gbm90Q2hlY2tlZDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdGhpcy5faGF5c3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGF5c3RhY2suc3RhcnRzV2l0aCh0aGlzLl9uZWVkbGUudmFsdWUsIGksIHRoaXMuX2hheXN0YWNrLmxlbmd0aCAtIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZmx1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cblxuICAgIF9mbHVzaChwb3MpIHtcblxuICAgICAgICBjb25zdCBjaHVua3MgPSB0aGlzLl9oYXlzdGFjay5zaGlmdChwb3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdoYXlzdGFjaycsIGNodW5rc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmbHVzaCgpIHtcblxuICAgICAgICBjb25zdCBjaHVua3MgPSB0aGlzLl9oYXlzdGFjay5zaGlmdCh0aGlzLl9oYXlzdGFjay5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdoYXlzdGFjaycsIGNodW5rc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgQjY0ID0gcmVxdWlyZSgnQGhhcGkvYjY0Jyk7XG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQ29udGVudCA9IHJlcXVpcmUoJ0BoYXBpL2NvbnRlbnQnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBOaWdlbCA9IHJlcXVpcmUoJ0BoYXBpL25pZ2VsJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLypcbiAgICBSRkMgMjA0NiAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjA0NilcblxuICAgIG11bHRpcGFydC1ib2R5ID0gW3ByZWFtYmxlIENSTEZdXG4gICAgICAgICAgICAgICAgICAgIGRhc2gtYm91bmRhcnkgKiggU1BBQ0UgLyBIVEFCICkgQ1JMRiBib2R5LXBhcnRcbiAgICAgICAgICAgICAgICAgICAgKiggQ1JMRiBkYXNoLWJvdW5kYXJ5ICooIFNQQUNFIC8gSFRBQiApIENSTEYgYm9keS1wYXJ0IClcbiAgICAgICAgICAgICAgICAgICAgQ1JMRiBkYXNoLWJvdW5kYXJ5IFwiLS1cIiAqKCBTUEFDRSAvIEhUQUIgKVxuICAgICAgICAgICAgICAgICAgICBbQ1JMRiBlcGlsb2d1ZV1cblxuICAgIGJvdW5kYXJ5ICAgICAgID0gMCo2OTxiY2hhcnM+IGJjaGFyc25vc3BhY2VcbiAgICBiY2hhcnMgICAgICAgICA9IGJjaGFyc25vc3BhY2UgLyBcIiBcIlxuICAgIGJjaGFyc25vc3BhY2UgID0gRElHSVQgLyBBTFBIQSAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIiAvIFwiK1wiIC8gXCJfXCIgLyBcIixcIiAvIFwiLVwiIC8gXCIuXCIgLyBcIi9cIiAvIFwiOlwiIC8gXCI9XCIgLyBcIj9cIlxuICAgIGRhc2gtYm91bmRhcnkgID0gXCItLVwiIGJvdW5kYXJ5XG5cbiAgICBwcmVhbWJsZSAgICAgICA9IGRpc2NhcmQtdGV4dFxuICAgIGVwaWxvZ3VlICAgICAgID0gZGlzY2FyZC10ZXh0XG4gICAgZGlzY2FyZC10ZXh0ICAgPSAqKCp0ZXh0IENSTEYpICp0ZXh0XG5cbiAgICBib2R5LXBhcnQgICAgICA9IE1JTUUtcGFydC1oZWFkZXJzIFtDUkxGICpPQ1RFVF1cbiAgICBPQ1RFVCAgICAgICAgICA9IDxhbnkgMC0yNTUgb2N0ZXQgdmFsdWU+XG5cbiAgICBTUEFDRSAgICAgICAgICA9IDMyXG4gICAgSFRBQiAgICAgICAgICAgPSA5XG4gICAgQ1JMRiAgICAgICAgICAgPSAxMyAxMFxuKi9cblxuXG5pbnRlcm5hbHMuc3RhdGUgPSB7XG4gICAgcHJlYW1ibGU6IDAsICAgICAgICAgICAgICAgIC8vIFVudGlsIHRoZSBmaXJzdCBib3VuZGFyeSBpcyByZWNlaXZlZFxuICAgIGJvdW5kYXJ5OiAxLCAgICAgICAgICAgICAgICAvLyBBZnRlciBhIGJvdW5kYXJ5LCB3YWl0aW5nIGZvciBmaXJzdCBsaW5lIHdpdGggb3B0aW9uYWwgbGluZWFyLXdoaXRlc3BhY2VcbiAgICBoZWFkZXI6IDIsICAgICAgICAgICAgICAgICAgLy8gUmVjZWl2aW5nIHBhcnQgaGVhZGVyc1xuICAgIHBheWxvYWQ6IDMsICAgICAgICAgICAgICAgICAvLyBSZWNlaXZpbmcgcGFydCBwYXlsb2FkXG4gICAgZXBpbG9ndWU6IDRcbn07XG5cblxuaW50ZXJuYWxzLmRlZmF1bHRzID0ge1xuICAgIG1heEJ5dGVzOiBJbmZpbml0eVxufTtcblxuXG5leHBvcnRzLkRpc3BlbnNlciA9IGludGVybmFscy5EaXNwZW5zZXIgPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5Xcml0YWJsZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zICE9PSBudWxsICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX2JvdW5kYXJ5ID0gc2V0dGluZ3MuYm91bmRhcnk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gaW50ZXJuYWxzLnN0YXRlLnByZWFtYmxlO1xuICAgICAgICB0aGlzLl9oZWxkID0gJyc7XG5cbiAgICAgICAgdGhpcy5fc3RyZWFtID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLl9uYW1lID0gJyc7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdIZWFkZXIgPSAnJztcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl9ieXRlcyA9IDA7XG4gICAgICAgIHRoaXMuX21heEJ5dGVzID0gc2V0dGluZ3MubWF4Qnl0ZXM7XG5cbiAgICAgICAgdGhpcy5fcGFydHMgPSBuZXcgTmlnZWwuU3RyZWFtKEJ1ZmZlci5mcm9tKCctLScgKyBzZXR0aW5ncy5ib3VuZGFyeSkpO1xuICAgICAgICB0aGlzLl9saW5lcyA9IG5ldyBOaWdlbC5TdHJlYW0oQnVmZmVyLmZyb20oJ1xcclxcbicpKTtcblxuICAgICAgICB0aGlzLl9wYXJ0cy5vbignbmVlZGxlJywgKCkgPT4gdGhpcy5fb25QYXJ0RW5kKCkpO1xuICAgICAgICB0aGlzLl9wYXJ0cy5vbignaGF5c3RhY2snLCAoY2h1bmspID0+IHRoaXMuX29uUGFydChjaHVuaykpO1xuICAgICAgICB0aGlzLl9saW5lcy5vbignbmVlZGxlJywgKCkgPT4gdGhpcy5fb25MaW5lRW5kKCkpO1xuICAgICAgICB0aGlzLl9saW5lcy5vbignaGF5c3RhY2snLCAoY2h1bmspID0+IHRoaXMuX29uTGluZShjaHVuaykpO1xuICAgICAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHRoaXMuX3BhcnRzLmVuZCgpKTtcbiAgICAgICAgdGhpcy5fcGFydHMub25jZSgnY2xvc2UnLCAoKSA9PiB0aGlzLl9saW5lcy5lbmQoKSk7XG5cbiAgICAgICAgbGV0IHBpcGVyID0gbnVsbDtcbiAgICAgICAgbGV0IGZpbmlzaCA9IChlcnIpID0+IHtcblxuICAgICAgICAgICAgaWYgKHBpcGVyKSB7XG4gICAgICAgICAgICAgICAgcGlwZXIucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvblJlcURhdGEpO1xuICAgICAgICAgICAgICAgIHBpcGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGZpbmlzaCk7XG4gICAgICAgICAgICAgICAgcGlwZXIucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0ZWQnLCBvblJlcUFib3J0ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0KGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2Nsb3NlJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZmluaXNoID0gSG9lay5vbmNlKGZpbmlzaCk7XG5cbiAgICAgICAgdGhpcy5fbGluZXMub25jZSgnY2xvc2UnLCAoKSA9PiB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gaW50ZXJuYWxzLnN0YXRlLmVwaWxvZ3VlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hlbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnZXBpbG9ndWUnLCB0aGlzLl9oZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVsZCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSBpbnRlcm5hbHMuc3RhdGUuYm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hlbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWJvcnQoQm9vbS5iYWRSZXF1ZXN0KCdNaXNzaW5nIGVuZCBib3VuZGFyeScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faGVsZCAhPT0gJy0tJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydChCb29tLmJhZFJlcXVlc3QoJ09ubHkgd2hpdGUgc3BhY2UgYWxsb3dlZCBhZnRlciBib3VuZGFyeSBhdCBlbmQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnQoQm9vbS5iYWRSZXF1ZXN0KCdJbmNvbXBsZXRlIG11bHRpcGFydCBwYXlsb2FkJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmluaXNoKTsgICAgICAgICAgICAgICAgICAvLyBHaXZlIHBlbmRpbmcgZXZlbnRzIGEgY2hhbmNlIHRvIGZpcmVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgb25SZXFBYm9ydGVkID0gKCkgPT4ge1xuXG4gICAgICAgICAgICBmaW5pc2goQm9vbS5iYWRSZXF1ZXN0KCdDbGllbnQgcmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uUmVxRGF0YSA9IChkYXRhKSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMuX2J5dGVzICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnl0ZXMgPiB0aGlzLl9tYXhCeXRlcykge1xuICAgICAgICAgICAgICAgIGZpbmlzaChCb29tLmVudGl0eVRvb0xhcmdlKCdNYXhpbXVtIHNpemUgZXhjZWVkZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vbmNlKCdwaXBlJywgKHJlcSkgPT4ge1xuXG4gICAgICAgICAgICBwaXBlciA9IHJlcTtcbiAgICAgICAgICAgIHJlcS5vbignZGF0YScsIG9uUmVxRGF0YSk7XG4gICAgICAgICAgICByZXEub25jZSgnZXJyb3InLCBmaW5pc2gpO1xuICAgICAgICAgICAgcmVxLm9uY2UoJ2Fib3J0ZWQnLCBvblJlcUFib3J0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5EaXNwZW5zZXIucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIGVuY29kaW5nLCBuZXh0KSB7XG5cbiAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJ0cy53cml0ZShidWZmZXIpO1xuICAgIHJldHVybiBuZXh0KCk7XG59O1xuXG5cbmludGVybmFscy5EaXNwZW5zZXIucHJvdG90eXBlLl9lbWl0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KC4uLmFyZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMuRGlzcGVuc2VyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG5cbiAgICB0aGlzLl9lbWl0KCdlcnJvcicsIGVycik7XG4gICAgdGhpcy5fZXJyb3IgPSBlcnI7XG59O1xuXG5cbmludGVybmFscy5EaXNwZW5zZXIucHJvdG90eXBlLl9vblBhcnRFbmQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9saW5lcy5mbHVzaCgpO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBpbnRlcm5hbHMuc3RhdGUucHJlYW1ibGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9oZWxkLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWxkW2xhc3RdICE9PSAnXFxuJyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX2hlbGRbbGFzdCAtIDFdICE9PSAnXFxyJykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0KEJvb20uYmFkUmVxdWVzdCgnUHJlYW1ibGUgbWlzc2luZyBDUkxGIHRlcm1pbmF0b3InKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3ByZWFtYmxlJywgdGhpcy5faGVsZC5zbGljZSgwLCAtMikpO1xuICAgICAgICAgICAgdGhpcy5faGVsZCA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcGFydHMubmVlZGxlKEJ1ZmZlci5mcm9tKCdcXHJcXG4tLScgKyB0aGlzLl9ib3VuZGFyeSkpOyAgICAgICAgICAgICAgICAgICAgICAvLyBDUkxGIG5vIGxvbmdlciBvcHRpb25hbFxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gaW50ZXJuYWxzLnN0YXRlLmJvdW5kYXJ5O1xuXG4gICAgaWYgKHRoaXMuX3N0cmVhbSkge1xuICAgICAgICB0aGlzLl9zdHJlYW0uZW5kKCk7XG4gICAgICAgIHRoaXMuX3N0cmVhbSA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX25hbWUpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnZmllbGQnLCB0aGlzLl9uYW1lLCB0aGlzLl9oZWxkKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9ICcnO1xuICAgICAgICB0aGlzLl9oZWxkID0gJyc7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuRGlzcGVuc2VyLnByb3RvdHlwZS5fb25QYXJ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IGludGVybmFscy5zdGF0ZS5wcmVhbWJsZSkge1xuICAgICAgICB0aGlzLl9oZWxkID0gdGhpcy5faGVsZCArIGNodW5rLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSBpbnRlcm5hbHMuc3RhdGUucGF5bG9hZCkge1xuICAgICAgICBpZiAodGhpcy5fc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJlYW0ud3JpdGUoY2h1bmspOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJlYW0gcGF5bG9hZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGVsZCA9IHRoaXMuX2hlbGQgKyBjaHVuay50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9saW5lcy53cml0ZShjaHVuayk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGJvdW5kYXJ5XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuRGlzcGVuc2VyLnByb3RvdHlwZS5fb25MaW5lRW5kID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQm91bmRhcnkgd2hpdGVzcGFjZVxuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBpbnRlcm5hbHMuc3RhdGUuYm91bmRhcnkpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlbGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlbGQgPSB0aGlzLl9oZWxkLnJlcGxhY2UoL1tcXHQgXS9nLCAnJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmltKCkgcmVtb3ZlcyBuZXcgbGluZXNcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hlbGQgPT09ICctLScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBpbnRlcm5hbHMuc3RhdGUuZXBpbG9ndWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hlbGQgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0KEJvb20uYmFkUmVxdWVzdCgnT25seSB3aGl0ZSBzcGFjZSBhbGxvd2VkIGFmdGVyIGJvdW5kYXJ5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBpbnRlcm5hbHMuc3RhdGUuaGVhZGVyO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQYXJ0IGhlYWRlcnNcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gaW50ZXJuYWxzLnN0YXRlLmhlYWRlcikge1xuXG4gICAgICAgIC8vIEhlYWRlclxuXG4gICAgICAgIGlmICh0aGlzLl9oZWxkKSB7XG5cbiAgICAgICAgICAgIC8vIEhlYWRlciBjb250aW51YXRpb25cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlbGRbMF0gPT09ICcgJyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuX2hlbGRbMF0gPT09ICdcXHQnKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0KEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBoZWFkZXIgY29udGludWF0aW9uIHdpdGhvdXQgdmFsaWQgZGVjbGFyYXRpb24gb24gcHJldmlvdXMgbGluZScpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nSGVhZGVyID0gdGhpcy5fcGVuZGluZ0hlYWRlciArICcgJyArIHRoaXMuX2hlbGQuc2xpY2UoMSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBEcm9wIHRhYlxuICAgICAgICAgICAgICAgIHRoaXMuX2hlbGQgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IG9mIG5ldyBoZWFkZXJcblxuICAgICAgICAgICAgdGhpcy5fZmx1c2hIZWFkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdIZWFkZXIgPSB0aGlzLl9oZWxkO1xuICAgICAgICAgICAgdGhpcy5faGVsZCA9ICcnO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgb2YgaGVhZGVyc1xuXG4gICAgICAgIHRoaXMuX2ZsdXNoSGVhZGVyKCk7XG5cbiAgICAgICAgdGhpcy5fc3RhdGUgPSBpbnRlcm5hbHMuc3RhdGUucGF5bG9hZDtcblxuICAgICAgICBsZXQgZGlzcG9zaXRpb247XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRpc3Bvc2l0aW9uID0gQ29udGVudC5kaXNwb3NpdGlvbih0aGlzLl9oZWFkZXJzWydjb250ZW50LWRpc3Bvc2l0aW9uJ10pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydChlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpc3Bvc2l0aW9uLmZpbGVuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0uUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZmVyRW5jb2RpbmcgPSB0aGlzLl9oZWFkZXJzWydjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJ107XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2ZlckVuY29kaW5nICYmXG4gICAgICAgICAgICAgICAgdHJhbnNmZXJFbmNvZGluZy50b0xvd2VyQ2FzZSgpID09PSAnYmFzZTY0Jykge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtID0gbmV3IEI2NC5EZWNvZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RyZWFtLm5hbWUgPSBkaXNwb3NpdGlvbi5uYW1lO1xuICAgICAgICAgICAgc3RyZWFtLmZpbGVuYW1lID0gZGlzcG9zaXRpb24uZmlsZW5hbWU7XG4gICAgICAgICAgICBzdHJlYW0uaGVhZGVycyA9IHRoaXMuX2hlYWRlcnM7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdwYXJ0Jywgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSBkaXNwb3NpdGlvbi5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGluZXMuZmx1c2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEVwaWxvZ3VlXG5cbiAgICB0aGlzLl9oZWxkID0gdGhpcy5faGVsZCArICdcXHJcXG4nOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXQgdGhlIG5ldyBsaW5lIGJhY2tcbn07XG5cblxuaW50ZXJuYWxzLkRpc3BlbnNlci5wcm90b3R5cGUuX29uTGluZSA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgaWYgKHRoaXMuX3N0cmVhbSkge1xuICAgICAgICB0aGlzLl9zdHJlYW0ud3JpdGUoY2h1bmspOyAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJlYW0gcGF5bG9hZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5faGVsZCA9IHRoaXMuX2hlbGQgKyBjaHVuay50b1N0cmluZygpOyAgICAgICAgICAgICAgICAgLy8gUmVhZGluZyBoZWFkZXIgb3IgZmllbGRcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5EaXNwZW5zZXIucHJvdG90eXBlLl9mbHVzaEhlYWRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICghdGhpcy5fcGVuZGluZ0hlYWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VwID0gdGhpcy5fcGVuZGluZ0hlYWRlci5pbmRleE9mKCc6Jyk7XG5cbiAgICBpZiAoc2VwID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnQoQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGhlYWRlciBtaXNzaW5nIGNvbG9uIHNlcGFyYXRvcicpKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnQoQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGhlYWRlciBtaXNzaW5nIGZpZWxkIG5hbWUnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5faGVhZGVyc1t0aGlzLl9wZW5kaW5nSGVhZGVyLnNsaWNlKDAsIHNlcCkudG9Mb3dlckNhc2UoKV0gPSB0aGlzLl9wZW5kaW5nSGVhZGVyLnNsaWNlKHNlcCArIDEpLnRyaW0oKTtcbiAgICB0aGlzLl9wZW5kaW5nSGVhZGVyID0gJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmxvY2F0aW9uID0gZnVuY3Rpb24gKGRlcHRoID0gMCkge1xuXG4gICAgY29uc3Qgb3JpZyA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gKGlnbm9yZSwgc3RhY2spID0+IHN0YWNrO1xuXG4gICAgY29uc3QgY2FwdHVyZSA9IHt9O1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGNhcHR1cmUsIHRoaXMpO1xuICAgIGNvbnN0IGxpbmUgPSBjYXB0dXJlLnN0YWNrW2RlcHRoICsgMV07XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG9yaWc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlbmFtZTogbGluZS5nZXRGaWxlTmFtZSgpLFxuICAgICAgICBsaW5lOiBsaW5lLmdldExpbmVOdW1iZXIoKVxuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHNjaGVtYToge1xuICAgICAgICBiYXNlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIG5hbWU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgY2xvbmU6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICB0YWdzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgc3ByZWFkOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgY2hhbm5lbHM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCkudW5pcXVlKCkubWluKDEpXG4gICAgICAgIH0pXG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hLmV2ZW50ID0gaW50ZXJuYWxzLnNjaGVtYS5iYXNlLmtleXMoe1xuICAgIHNoYXJlZDogSm9pLmJvb2xlYW4oKVxufSk7XG5cblxuaW50ZXJuYWxzLnNjaGVtYS5saXN0ZW5lciA9IGludGVybmFscy5zY2hlbWEuZXZlbnQua2V5cyh7XG4gICAgbGlzdGVuZXI6IEpvaS5mdW5jKCkucmVxdWlyZWQoKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgY291bnQ6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDEpLFxuICAgIGZpbHRlcjoge1xuICAgICAgICB0YWdzOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLnVuaXF1ZSgpLm1pbigxKS5yZXF1aXJlZCgpLFxuICAgICAgICBhbGw6IEpvaS5ib29sZWFuKClcbiAgICB9XG59KTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuUG9kaXVtID0gZnVuY3Rpb24gKGV2ZW50cywgb3B0aW9ucykge1xuXG4gICAgLy8gVXNlIGRlc2NyaXB0aXZlIG5hbWVzIHRvIGF2b2lkIGNvbmZsaWN0IHdoZW4gaW5oZXJpdGVkXG5cbiAgICB0aGlzLl9ldmVudExpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fbm90aWZpY2F0aW9uc1F1ZXVlID0gW107XG4gICAgdGhpcy5fZXZlbnRzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX3NvdXJjZVBvZGl1bXMgPSBbXTtcblxuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KGV2ZW50cywgb3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUG9kaXVtLmRlY29yYXRlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cbiAgICBpbnRlcm5hbHMuUG9kaXVtLmNhbGwodGFyZ2V0LCBudWxsKTtcblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZS5fZXZlbnRMaXN0ZW5lcnMpLmZvckVhY2goKG5hbWUpID0+IHtcblxuICAgICAgICB0YXJnZXQuX2V2ZW50TGlzdGVuZXJzW25hbWVdID0ge1xuICAgICAgICAgICAgaGFuZGxlcnM6IG51bGwsXG4gICAgICAgICAgICBmbGFnczogc291cmNlLl9ldmVudExpc3RlbmVyc1tuYW1lXS5mbGFnc1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuUG9kaXVtLnZhbGlkYXRlID0gZnVuY3Rpb24gKGV2ZW50cykge1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuICAgIFtdLmNvbmNhdChldmVudHMpLmZvckVhY2goKGV2ZW50KSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGV2ZW50ID0geyBuYW1lOiBldmVudCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKEpvaS5hdHRlbXB0KGV2ZW50LCBpbnRlcm5hbHMuc2NoZW1hLmV2ZW50LCAnSW52YWxpZCBldmVudCBvcHRpb25zJykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0ucHJvdG90eXBlLnJlZ2lzdGVyRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRzLCBvcHRpb25zID0ge30pIHtcblxuICAgIGV2ZW50cyA9IEhvZWsuZmxhdHRlbihbXS5jb25jYXQoZXZlbnRzKSk7XG4gICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG5cbiAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgaW50ZXJuYWxzLlBvZGl1bSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJQb2RpdW0oZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGV2ZW50ID0geyBuYW1lOiBldmVudCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudmFsaWRhdGUgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIGV2ZW50ID0gSm9pLmF0dGVtcHQoZXZlbnQsIGludGVybmFscy5zY2hlbWEuZXZlbnQsICdJbnZhbGlkIGV2ZW50IG9wdGlvbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5hbWUgPSBldmVudC5uYW1lO1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGV2ZW50LnNoYXJlZCwgYEV2ZW50ICR7bmFtZX0gZXhpc3RzYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXSA9IHsgaGFuZGxlcnM6IG51bGwsIGZsYWdzOiBldmVudCB9O1xuICAgICAgICB0aGlzLl9zb3VyY2VQb2RpdW1zLmZvckVhY2goKHBvZGl1bSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIXBvZGl1bS5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBwb2RpdW0uX2V2ZW50TGlzdGVuZXJzW25hbWVdID0geyBoYW5kbGVyczogbnVsbCwgZmxhZ3M6IGV2ZW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuUG9kaXVtLnByb3RvdHlwZS5yZWdpc3RlclBvZGl1bSA9IGZ1bmN0aW9uIChwb2RpdW1zKSB7XG5cbiAgICBbXS5jb25jYXQocG9kaXVtcykuZm9yRWFjaCgocG9kaXVtKSA9PiB7XG5cbiAgICAgICAgaWYgKHBvZGl1bS5fc291cmNlUG9kaXVtcy5pbmRleE9mKHRoaXMpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9kaXVtLl9zb3VyY2VQb2RpdW1zLnB1c2godGhpcyk7XG4gICAgICAgIE9iamVjdC5rZXlzKHBvZGl1bS5fZXZlbnRMaXN0ZW5lcnMpLmZvckVhY2goKG5hbWUpID0+IHtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdID0geyBoYW5kbGVyczogbnVsbCwgZmxhZ3M6IHBvZGl1bS5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0uZmxhZ3MgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0ucHJvdG90eXBlLmVtaXQgPSBhc3luYyBmdW5jdGlvbiAoY3JpdGVyaWEsIGRhdGEsIF9nZW5lcmF0ZWQpIHtcblxuICAgIGNyaXRlcmlhID0gaW50ZXJuYWxzLmNyaXRlcmlhKGNyaXRlcmlhKTtcblxuICAgIGNvbnN0IG5hbWUgPSBjcml0ZXJpYS5uYW1lO1xuICAgIEhvZWsuYXNzZXJ0KG5hbWUsICdDcml0ZXJpYSBtaXNzaW5nIGV2ZW50IG5hbWUnKTtcblxuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV07XG4gICAgSG9lay5hc3NlcnQoZXZlbnQsIGBVbmtub3duIGV2ZW50ICR7bmFtZX1gKTtcbiAgICBIb2VrLmFzc2VydCghY3JpdGVyaWEuY2hhbm5lbCB8fCB0eXBlb2YgY3JpdGVyaWEuY2hhbm5lbCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIGNoYW5uZWwgbmFtZScpO1xuICAgIEhvZWsuYXNzZXJ0KCFjcml0ZXJpYS5jaGFubmVsIHx8ICFldmVudC5mbGFncy5jaGFubmVscyB8fCBldmVudC5mbGFncy5jaGFubmVscy5pbmRleE9mKGNyaXRlcmlhLmNoYW5uZWwpICE9PSAtMSwgYFVua25vd24gJHtjcml0ZXJpYS5jaGFubmVsfSBjaGFubmVsYCk7XG4gICAgSG9lay5hc3NlcnQoIWV2ZW50LmZsYWdzLnNwcmVhZCB8fCBBcnJheS5pc0FycmF5KGRhdGEpIHx8IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nLCAnRGF0YSBtdXN0IGJlIGFuIGFycmF5IGZvciBzcHJlYWQgZXZlbnQnKTtcblxuICAgIGlmICghZXZlbnQuaGFuZGxlcnMgJiZcbiAgICAgICAgIXRoaXMuX3NvdXJjZVBvZGl1bXMubGVuZ3RoKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3JpdGVyaWEudGFncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY3JpdGVyaWEudGFncyA9IFtjcml0ZXJpYS50YWdzXTtcbiAgICB9XG5cbiAgICBpZiAoY3JpdGVyaWEudGFncyAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGNyaXRlcmlhLnRhZ3MpKSB7XG5cbiAgICAgICAgLy8gTWFwIGFycmF5IHRvIG9iamVjdFxuXG4gICAgICAgIGNvbnN0IHRhZ3MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgY3JpdGVyaWEudGFncykge1xuICAgICAgICAgICAgdGFnc1t0YWddID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNyaXRlcmlhLnRhZ3MgPSB0YWdzO1xuICAgIH1cblxuICAgIGlmIChldmVudC5oYW5kbGVycykge1xuICAgICAgICBjb25zdCBwcm9jZXNzaW5nID0gW107XG5cbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBldmVudC5oYW5kbGVycy5zbGljZSgpOyAgICAgICAgICAgICAgICAvLyBDbG9uZSBpbiBjYXNlIGhhbmRsZXJzIGFyZSBjaGFuZ2VkIGJ5IGxpc3RlbmVyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbaV07XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmNoYW5uZWxzICYmXG4gICAgICAgICAgICAgICAgKCFjcml0ZXJpYS5jaGFubmVsIHx8IGhhbmRsZXIuY2hhbm5lbHMuaW5kZXhPZihjcml0ZXJpYS5jaGFubmVsKSA9PT0gLTEpKSB7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIuZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjcml0ZXJpYS50YWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gSG9lay5pbnRlcnNlY3QoY3JpdGVyaWEudGFncywgaGFuZGxlci5maWx0ZXIudGFncywgeyBmaXJzdDogIWhhbmRsZXIuZmlsdGVyLmFsbCB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoIHx8XG4gICAgICAgICAgICAgICAgICAgIChoYW5kbGVyLmZpbHRlci5hbGwgJiYgbWF0Y2gubGVuZ3RoICE9PSBoYW5kbGVyLmZpbHRlci50YWdzLmxlbmd0aCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYW5kbGVyLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgLS1oYW5kbGVyLmNvdW50O1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmNvdW50IDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMucmVtb3ZlSGFuZGxlcih0aGlzLCBjcml0ZXJpYS5uYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghX2dlbmVyYXRlZCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YSgpO1xuICAgICAgICAgICAgICAgIF9nZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGUgPSAoaW50ZXJuYWxzLmZsYWcoJ2Nsb25lJywgaGFuZGxlciwgZXZlbnQpID8gSG9lay5jbG9uZShkYXRhKSA6IGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IChpbnRlcm5hbHMuZmxhZygnc3ByZWFkJywgaGFuZGxlciwgZXZlbnQpICYmIEFycmF5LmlzQXJyYXkodXBkYXRlKSA/IHVwZGF0ZSA6IFt1cGRhdGVdKTtcblxuICAgICAgICAgICAgaWYgKGludGVybmFscy5mbGFnKCd0YWdzJywgaGFuZGxlciwgZXZlbnQpICYmXG4gICAgICAgICAgICAgICAgY3JpdGVyaWEudGFncykge1xuXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKGNyaXRlcmlhLnRhZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChoYW5kbGVyLmNvbnRleHQgPyBoYW5kbGVyLmxpc3RlbmVyLmFwcGx5KGhhbmRsZXIuY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLnB1c2goUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb2Nlc3NpbmcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZVBvZGl1bXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBvZGl1bXMgPSB0aGlzLl9zb3VyY2VQb2RpdW1zLnNsaWNlKCk7ICAgICAgICAgLy8gQ2xvbmUgaW4gY2FzZSBtb2RpZmllZCB3aGlsZSBwcm9jZXNzaW5nXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHBvZGl1bXMubWFwKChwb2RpdW0pID0+IHBvZGl1bS5lbWl0KGNyaXRlcmlhLCBkYXRhLCBfZ2VuZXJhdGVkKSkpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlBvZGl1bS5wcm90b3R5cGUub24gPSBpbnRlcm5hbHMuUG9kaXVtLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChjcml0ZXJpYSwgbGlzdGVuZXIsIGNvbnRleHQpIHtcblxuICAgIGNyaXRlcmlhID0gaW50ZXJuYWxzLmNyaXRlcmlhKGNyaXRlcmlhKTtcbiAgICBjcml0ZXJpYS5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIGNyaXRlcmlhLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgaWYgKGNyaXRlcmlhLmZpbHRlciAmJlxuICAgICAgICAodHlwZW9mIGNyaXRlcmlhLmZpbHRlciA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShjcml0ZXJpYS5maWx0ZXIpKSkge1xuXG4gICAgICAgIGNyaXRlcmlhLmZpbHRlciA9IHsgdGFnczogY3JpdGVyaWEuZmlsdGVyIH07XG4gICAgfVxuXG4gICAgY3JpdGVyaWEgPSBKb2kuYXR0ZW1wdChjcml0ZXJpYSwgaW50ZXJuYWxzLnNjaGVtYS5saXN0ZW5lciwgJ0ludmFsaWQgZXZlbnQgbGlzdGVuZXIgb3B0aW9ucycpO1xuXG4gICAgY29uc3QgbmFtZSA9IGNyaXRlcmlhLm5hbWU7XG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXTtcbiAgICBIb2VrLmFzc2VydChldmVudCwgYFVua25vd24gZXZlbnQgJHtuYW1lfWApO1xuICAgIEhvZWsuYXNzZXJ0KCFjcml0ZXJpYS5jaGFubmVscyB8fCAhZXZlbnQuZmxhZ3MuY2hhbm5lbHMgfHwgSG9lay5pbnRlcnNlY3QoZXZlbnQuZmxhZ3MuY2hhbm5lbHMsIGNyaXRlcmlhLmNoYW5uZWxzKS5sZW5ndGggPT09IGNyaXRlcmlhLmNoYW5uZWxzLmxlbmd0aCwgYFVua25vd24gZXZlbnQgY2hhbm5lbHMgJHtjcml0ZXJpYS5jaGFubmVscyAmJiBjcml0ZXJpYS5jaGFubmVscy5qb2luKCcsICcpfWApO1xuXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0uaGFuZGxlcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycyB8fCBbXTtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycy5wdXNoKGNyaXRlcmlhKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG5pbnRlcm5hbHMuUG9kaXVtLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBsaXN0ZW5lciwgY29udGV4dCkge1xuXG4gICAgY3JpdGVyaWEgPSBPYmplY3QuYXNzaWduKGludGVybmFscy5jcml0ZXJpYShjcml0ZXJpYSksIHsgY291bnQ6IDEgfSk7XG5cbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oY3JpdGVyaWEsIGxpc3RlbmVyLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHRoaXMub24oY3JpdGVyaWEsICguLi5hcmdzKSA9PiByZXNvbHZlKGFyZ3MpLCBjb250ZXh0KSk7XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXSwgYFVua25vd24gZXZlbnQgJHtuYW1lfWApO1xuICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJywgJ0xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycztcbiAgICBpZiAoIWhhbmRsZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcmVkID0gaGFuZGxlcnMuZmlsdGVyKChoYW5kbGVyKSA9PiBoYW5kbGVyLmxpc3RlbmVyICE9PSBsaXN0ZW5lcik7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0uaGFuZGxlcnMgPSAoZmlsdGVyZWQubGVuZ3RoID8gZmlsdGVyZWQgOiBudWxsKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuaW50ZXJuYWxzLlBvZGl1bS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgIEhvZWsuYXNzZXJ0KHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLCBgVW5rbm93biBldmVudCAke25hbWV9YCk7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0uaGFuZGxlcnMgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG5pbnRlcm5hbHMuUG9kaXVtLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgSG9lay5hc3NlcnQodGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0sIGBVbmtub3duIGV2ZW50ICR7bmFtZX1gKTtcbiAgICByZXR1cm4gISF0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycztcbn07XG5cblxuaW50ZXJuYWxzLnJlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZW1pdHRlciwgbmFtZSwgaGFuZGxlcikge1xuXG4gICAgY29uc3QgaGFuZGxlcnMgPSBlbWl0dGVyLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycztcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGhhbmRsZXJzLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gaGFuZGxlcik7XG4gICAgZW1pdHRlci5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0uaGFuZGxlcnMgPSAoZmlsdGVyZWQubGVuZ3RoID8gZmlsdGVyZWQgOiBudWxsKTtcbn07XG5cblxuaW50ZXJuYWxzLmNyaXRlcmlhID0gZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG5cbiAgICByZXR1cm4gKHR5cGVvZiBjcml0ZXJpYSA9PT0gJ3N0cmluZycgPyB7IG5hbWU6IGNyaXRlcmlhIH0gOiBIb2VrLmNsb25lKGNyaXRlcmlhKSk7XG59O1xuXG5cbmludGVybmFscy5mbGFnID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIsIGV2ZW50KSB7XG5cbiAgICByZXR1cm4gKGhhbmRsZXJbbmFtZV0gIT09IHVuZGVmaW5lZCA/IGhhbmRsZXJbbmFtZV0gOiBldmVudC5mbGFnc1tuYW1lXSkgfHwgZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5cbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcbmNvbnN0IFJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpO1xuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5vcHRpb25zID0gSm9pLm9iamVjdCgpLmtleXMoe1xuICAgIHVybDogSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgSm9pLm9iamVjdCgpLmtleXMoe1xuICAgICAgICAgICAgcHJvdG9jb2w6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIGhvc3RuYW1lOiBKb2kuc3RyaW5nKCksXG4gICAgICAgICAgICBwb3J0OiBKb2kuYW55KCksXG4gICAgICAgICAgICBwYXRobmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICBxdWVyeTogSm9pLmFueSgpXG4gICAgICAgIH0pXG4gICAgXSlcbiAgICAgICAgLnJlcXVpcmVkKCksXG4gICAgaGVhZGVyczogSm9pLm9iamVjdCgpLFxuICAgIHBheWxvYWQ6IEpvaS5hbnkoKSxcbiAgICBzaW11bGF0ZToge1xuICAgICAgICBlbmQ6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHNwbGl0OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBlcnJvcjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgY2xvc2U6IEpvaS5ib29sZWFuKClcbiAgICB9LFxuICAgIGF1dGhvcml0eTogSm9pLnN0cmluZygpLFxuICAgIHJlbW90ZUFkZHJlc3M6IEpvaS5zdHJpbmcoKSxcbiAgICBtZXRob2Q6IEpvaS5zdHJpbmcoKSxcbiAgICB2YWxpZGF0ZTogSm9pLmJvb2xlYW4oKVxufSk7XG5cblxuZXhwb3J0cy5pbmplY3QgPSBmdW5jdGlvbiAoZGlzcGF0Y2hGdW5jLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyA/IHsgdXJsOiBvcHRpb25zIH0gOiBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGRpc3BhdGNoRnVuYyA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgZGlzcGF0Y2ggZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIEpvaS5hc3NlcnQob3B0aW9ucywgaW50ZXJuYWxzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcmVxID0gbmV3IFJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBSZXNwb25zZShyZXEsIHJlc29sdmUpO1xuXG4gICAgICAgIHJlcS5wcmVwYXJlKCgpID0+IGRpc3BhdGNoRnVuYyhyZXEsIHJlcykpO1xuICAgIH0pO1xufTtcblxuXG5leHBvcnRzLmlzSW5qZWN0aW9uID0gZnVuY3Rpb24gKG9iaikge1xuXG4gICAgcmV0dXJuICEhb2JqW1N5bWJvbHMuaW5qZWN0aW9uXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgVXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuL3N5bWJvbHMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuUmVxdWVzdCA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtLlJlYWRhYmxlIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIC8vIG9wdGlvbnM6IG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBoZWFkZXJzLCByZW1vdGVBZGRyZXNzXG5cbiAgICAgICAgbGV0IHVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVybCA9IFVybC5mb3JtYXQodXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVyaSA9IFVybC5wYXJzZSh1cmwpO1xuICAgICAgICB0aGlzLnVybCA9IHVyaS5wYXRoO1xuXG4gICAgICAgIHRoaXMuaHR0cFZlcnNpb24gPSAnMS4xJztcbiAgICAgICAgdGhpcy5tZXRob2QgPSAob3B0aW9ucy5tZXRob2QgPyBvcHRpb25zLm1ldGhvZC50b1VwcGVyQ2FzZSgpIDogJ0dFVCcpO1xuXG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1tmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlcnNbZmllbGRdO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmhlYWRlcnNbJ3VzZXItYWdlbnQnXSA9IHRoaXMuaGVhZGVyc1sndXNlci1hZ2VudCddIHx8ICdzaG90JztcblxuICAgICAgICBjb25zdCBob3N0SGVhZGVyRnJvbVVyaSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHVyaS5wb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVyaS5ob3N0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXJpLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVyaS5ob3N0bmFtZSArICh1cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gJzo0NDMnIDogJzo4MCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmhlYWRlcnMuaG9zdCA9IHRoaXMuaGVhZGVycy5ob3N0IHx8IGhvc3RIZWFkZXJGcm9tVXJpKCkgfHwgb3B0aW9ucy5hdXRob3JpdHkgfHwgJ2xvY2FsaG9zdDo4MCc7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogb3B0aW9ucy5yZW1vdGVBZGRyZXNzIHx8ICcxMjcuMC4wLjEnXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHBheWxvYWQgPSBvcHRpb25zLnBheWxvYWQgfHwgbnVsbDtcbiAgICAgICAgaWYgKHBheWxvYWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBwYXlsb2FkICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgIShwYXlsb2FkIGluc3RhbmNlb2YgU3RyZWFtKSAmJlxuICAgICAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSkge1xuXG4gICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIGNvbnRlbnQtbGVuZ3RoIGZvciB0aGUgY29ycmVzcG9uZGluZyBwYXlsb2FkIGlmIG5vbmUgc2V0XG5cbiAgICAgICAgaWYgKHBheWxvYWQgJiZcbiAgICAgICAgICAgICEocGF5bG9hZCBpbnN0YW5jZW9mIFN0cmVhbSkgJiZcbiAgICAgICAgICAgICF0aGlzLmhlYWRlcnMuaGFzT3duUHJvcGVydHkoJ2NvbnRlbnQtbGVuZ3RoJykpIHtcblxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gKEJ1ZmZlci5pc0J1ZmZlcihwYXlsb2FkKSA/IHBheWxvYWQubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgocGF5bG9hZCkpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgX3Nob3QgbmFtZXNwYWNlIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIE5vZGVcblxuICAgICAgICB0aGlzLl9zaG90ID0ge1xuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIGlzRG9uZTogZmFsc2UsXG4gICAgICAgICAgICBzaW11bGF0ZTogb3B0aW9ucy5zaW11bGF0ZSB8fCB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHByZXBhcmUobmV4dCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG90LnBheWxvYWQgaW5zdGFuY2VvZiBTdHJlYW0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG5cbiAgICAgICAgdGhpcy5fc2hvdC5wYXlsb2FkLm9uKCdkYXRhJywgKGNodW5rKSA9PiBjaHVua3MucHVzaChCdWZmZXIuZnJvbShjaHVuaykpKTtcblxuICAgICAgICB0aGlzLl9zaG90LnBheWxvYWQub24oJ2VuZCcsICgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IHRoaXMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSB8fCBwYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3Nob3QucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfcmVhZChzaXplKSB7XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3QuaXNEb25lKSB7XG4gICAgICAgICAgICAgICAgLyogJGxhYjpjb3ZlcmFnZTpvZmYkICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3Quc2ltdWxhdGUuZW5kICE9PSBmYWxzZSkgeyAgICAgICAgLy8gJ2VuZCcgZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qICRsYWI6Y292ZXJhZ2U6b24kICovXG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3Nob3QuaXNEb25lID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3QucGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG90LnNpbXVsYXRlLnNwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9zaG90LnBheWxvYWQuc2xpY2UoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2godGhpcy5fc2hvdC5wYXlsb2FkLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9zaG90LnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3Quc2ltdWxhdGUuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdTaW11bGF0ZWQnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG90LnNpbXVsYXRlLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdC5zaW11bGF0ZS5lbmQgIT09IGZhbHNlKSB7ICAgICAgICAvLyAnZW5kJyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuXG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVxdWVzdC5wcm90b3R5cGVbU3ltYm9scy5pbmplY3Rpb25dID0gdHJ1ZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi9zeW1ib2xzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBIdHRwLlNlcnZlclJlc3BvbnNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlcSwgb25FbmQpIHtcblxuICAgICAgICBzdXBlcih7IG1ldGhvZDogcmVxLm1ldGhvZCwgaHR0cFZlcnNpb25NYWpvcjogMSwgaHR0cFZlcnNpb25NaW5vcjogMSB9KTtcbiAgICAgICAgdGhpcy5fc2hvdCA9IHsgaGVhZGVyczogbnVsbCwgdHJhaWxlcnM6IHt9LCBwYXlsb2FkQ2h1bmtzOiBbXSB9O1xuICAgICAgICB0aGlzLmFzc2lnblNvY2tldChpbnRlcm5hbHMubnVsbFNvY2tldCgpKTtcblxuICAgICAgICB0aGlzLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgcmVzID0gaW50ZXJuYWxzLnBheWxvYWQodGhpcyk7XG4gICAgICAgICAgICByZXMucmF3LnJlcSA9IHJlcTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gb25FbmQocmVzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHdyaXRlSGVhZCguLi5hcmdzKSB7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgaGVhZGVycyBvYmplY3QgaWYgb25lIHdhcyBwcm92aWRlZC4gSWYgYSBoZWFkZXJzIG9iamVjdCBpcyBwcmVzZW50LCBjYWxsIHNldEhlYWRlcigpXG4gICAgICAgIC8vIG9uIHRoZSBmaXJzdCB2YWxpZCBoZWFkZXIsIGFuZCB0aGVuIGJyZWFrIG91dCBvZiB0aGUgbG9vcCBhbmQgY2FsbCB3cml0ZUhlYWQoKS4gQnkgY2FsbGluZ1xuICAgICAgICAvLyBzZXRIZWFkZXIoKSwgTm9kZSB3aWxsIG1hdGVyaWFsaXplIGEgaGVhZGVycyBvYmplY3QuXG5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnICYmIGhlYWRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlck5hbWVzID0gT2JqZWN0LmtleXMoaGVhZGVycyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVyTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gaGVhZGVyTmFtZXNbaV07XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhlYWRlcihuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChpZ25vcmVFcnIpIHt9IC8vIExldCB0aGUgcmVhbCB3cml0ZUhlYWQoKSBoYW5kbGUgZXJyb3JzLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIud3JpdGVIZWFkKC4uLmFyZ3MpO1xuXG4gICAgICAgIHRoaXMuX3Nob3QuaGVhZGVycyA9IHRoaXMuZ2V0SGVhZGVycygpO1xuXG4gICAgICAgIC8vIEFkZCByYXcgaGVhZGVyc1xuXG4gICAgICAgIFsnRGF0ZScsICdDb25uZWN0aW9uJywgJ1RyYW5zZmVyLUVuY29kaW5nJ10uZm9yRWFjaCgobmFtZSkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxyXFxcXG4nICsgbmFtZSArICc6IChbXlxcXFxyXSopXFxcXHJcXFxcbicpO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLl9oZWFkZXIubWF0Y2gocmVnZXgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvdC5oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBmaWVsZFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB3cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblxuICAgICAgICBzdXBlci53cml0ZShkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgICB0aGlzLl9zaG90LnBheWxvYWRDaHVua3MucHVzaChCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgYWx3YXlzIHJldHVybnMgZmFsc2Ugd2hlbiBkaXNjb25uZWN0ZWRcbiAgICB9XG5cbiAgICBlbmQoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuZW5kKGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuXG4gICAgfVxuXG4gICAgYWRkVHJhaWxlcnModHJhaWxlcnMpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0cmFpbGVycykge1xuICAgICAgICAgICAgdGhpcy5fc2hvdC50cmFpbGVyc1trZXkudG9Mb3dlckNhc2UoKS50cmltKCldID0gdHJhaWxlcnNba2V5XS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlJlc3BvbnNlLnByb3RvdHlwZVtTeW1ib2xzLmluamVjdGlvbl0gPSB0cnVlO1xuXG5cbmludGVybmFscy5wYXlsb2FkID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICAvLyBQcmVwYXJlIHJlc3BvbnNlIG9iamVjdFxuXG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgICByYXc6IHtcbiAgICAgICAgICAgIHJlczogcmVzcG9uc2VcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuX3Nob3QuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzTWVzc2FnZSxcbiAgICAgICAgdHJhaWxlcnM6IHt9XG4gICAgfTtcblxuICAgIC8vIFByZXBhcmUgcGF5bG9hZCBhbmQgdHJhaWxlcnNcblxuICAgIGNvbnN0IHJhd0J1ZmZlciA9IEJ1ZmZlci5jb25jYXQocmVzcG9uc2UuX3Nob3QucGF5bG9hZENodW5rcyk7XG4gICAgcmVzLnJhd1BheWxvYWQgPSByYXdCdWZmZXI7XG4gICAgcmVzLnBheWxvYWQgPSByYXdCdWZmZXIudG9TdHJpbmcoKTtcbiAgICByZXMudHJhaWxlcnMgPSByZXNwb25zZS5fc2hvdC50cmFpbGVycztcblxuICAgIHJldHVybiByZXM7XG59O1xuXG5cbi8vIFRocm93cyBhd2F5IGFsbCB3cml0dGVuIGRhdGEgdG8gcHJldmVudCByZXNwb25zZSBmcm9tIGJ1ZmZlcmluZyBwYXlsb2FkXG5cbmludGVybmFscy5udWxsU29ja2V0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBTdHJlYW0uV3JpdGFibGUoe1xuICAgICAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuaW5qZWN0aW9uID0gU3ltYm9sKCdpbmplY3Rpb24nKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtYXhMZW5ndGg6IDI1NixcbiAgICB3aWxkY2FyZHM6IFsneCcsICdYJywgJyonXSxcbiAgICBhbnk6IFN5bWJvbCgnYW55Jylcbn07XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTptYWpvciAgICAgICAgIDI6bWlub3IgICAgICAgICAzOnBhdGNoICAgICAgICAgIDQ6cHJlcmVsZWFzZSAgNTpidWlsZFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBICAgICAgICAgYUIgICAgQyAgICAgICAgIGNEICAgIEUgICAgICAgICBlRiAgICAgRyAgICAgZ2YgSCAgICBJICBpaCBkIGJcbmludGVybmFscy52ZXJzaW9uUnggPSAvXlxccypbdlZdPyhcXGQrfFt4WCpdKSg/OlxcLihcXGQrfFt4WCpdKSg/OlxcLihcXGQrfFt4WCpdKSg/OlxcLT8oW14rXSspKT8oPzpcXCsoLispKT8pPyk/XFxzKiQvO1xuXG5pbnRlcm5hbHMuc3RyaWN0ID0ge1xuICAgIHRva2VuUng6IC9eWy1cXGRBLVphLXpdKyg/OlxcLlstXFxkQS1aYS16XSspKiQvLFxuICAgIG51bWJlclJ4OiAvXigoPzowKXwoPzpbMS05XVxcZCopKSQvXG59O1xuXG5cbmV4cG9ydHMudmVyc2lvbiA9IGZ1bmN0aW9uICh2ZXJzaW9uLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5WZXJzaW9uKHZlcnNpb24sIG9wdGlvbnMpO1xufTtcblxuXG5leHBvcnRzLnJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5SYW5nZShyYW5nZSk7XG59O1xuXG5cbmV4cG9ydHMubWF0Y2ggPSBmdW5jdGlvbiAodmVyc2lvbiwgcmFuZ2UpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLnJhbmdlKHJhbmdlKS5tYXRjaCh2ZXJzaW9uKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlZlcnNpb24gPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh2ZXJzaW9uLCAnTWlzc2luZyB2ZXJzaW9uIGFyZ3VtZW50Jyk7XG5cbiAgICAgICAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBpbnRlcm5hbHMuVmVyc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3B5KHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2UodmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZvcm1hdCgpO1xuICAgIH1cblxuICAgIF9jb3B5KHZlcnNpb24pIHtcblxuICAgICAgICB0aGlzLm1ham9yID0gdmVyc2lvbi5tYWpvciA9PT0gdW5kZWZpbmVkID8gaW50ZXJuYWxzLmFueSA6IHZlcnNpb24ubWFqb3I7XG4gICAgICAgIHRoaXMubWlub3IgPSB2ZXJzaW9uLm1pbm9yID09PSB1bmRlZmluZWQgPyBpbnRlcm5hbHMuYW55IDogdmVyc2lvbi5taW5vcjtcbiAgICAgICAgdGhpcy5wYXRjaCA9IHZlcnNpb24ucGF0Y2ggPT09IHVuZGVmaW5lZCA/IGludGVybmFscy5hbnkgOiB2ZXJzaW9uLnBhdGNoO1xuICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSB2ZXJzaW9uLnByZXJlbGVhc2UgfHwgW107XG4gICAgICAgIHRoaXMuYnVpbGQgPSB2ZXJzaW9uLmJ1aWxkIHx8IFtdO1xuICAgIH1cblxuICAgIF9wYXJzZSh2ZXJzaW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAnVmVyc2lvbiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHZlcnNpb24ubGVuZ3RoIDw9IGludGVybmFscy5tYXhMZW5ndGgsICdWZXJzaW9uIHN0cmluZyB0b28gbG9uZycpO1xuXG4gICAgICAgIGNvbnN0IG1hdGNoID0gdmVyc2lvbi5tYXRjaChpbnRlcm5hbHMudmVyc2lvblJ4KTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb24gc3RyaW5nIGZvcm1hdDogJHt2ZXJzaW9ufWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYWpvciA9IGludGVybmFscy5WZXJzaW9uLl9udW1iZXIobWF0Y2hbMV0sICdtYWpvcicsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1pbm9yID0gaW50ZXJuYWxzLlZlcnNpb24uX251bWJlcihtYXRjaFsyXSB8fCAneCcsICdtaW5vcicsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnBhdGNoID0gaW50ZXJuYWxzLlZlcnNpb24uX251bWJlcihtYXRjaFszXSB8fCAneCcsICdwYXRjaCcsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IGludGVybmFscy5WZXJzaW9uLl9zdWIobWF0Y2hbNF0sICdwcmVyZWxlYXNlJywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYnVpbGQgPSBpbnRlcm5hbHMuVmVyc2lvbi5fc3ViKG1hdGNoWzVdLCAnYnVpbGQnLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX251bWJlcihzdHJpbmcsIHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmIChpbnRlcm5hbHMud2lsZGNhcmRzLmluY2x1ZGVzKHN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuYW55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChzdHJpbmcubWF0Y2goaW50ZXJuYWxzLnN0cmljdC5udW1iZXJSeCksICdWYWx1ZSBtdXN0IGJlIDAgb3IgYSBudW1iZXIgd2l0aG91dCBhIGxlYWRpbmcgemVybzonLCBzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgICAgICAgSG9lay5hc3NlcnQodmFsdWUgPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsICdWYWx1ZSBtdXN0IGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gbWF4IHNhZmUgaW50ZWdlcjonLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgc3RhdGljIF9zdWIoc3RyaW5nLCBzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAoIXN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChzdHJpbmcubWF0Y2goaW50ZXJuYWxzLnN0cmljdC50b2tlblJ4KSwgJ1ZhbHVlIGNhbiBvbmx5IGNvbnRhaW4gZG90LXNlcGFyYXRlZCBoeXBoZW5zLCBkaWdpdHMsIGEteiBvciBBLVo6Jywgc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN1YnMgPSBbXTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZW1wdHkgJHtzb3VyY2V9IHNlZ21lbnRgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3Vicy5wdXNoKHBhcnQubWF0Y2goL15cXGQrJC8pID8gaW50ZXJuYWxzLlZlcnNpb24uX251bWJlcihwYXJ0LCBzb3VyY2UsIHsgc3RyaWN0OiBvcHRpb25zLnN0cmljdCB9KSA6IHBhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnM7XG4gICAgfVxuXG4gICAgZm9ybWF0KCkge1xuXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IGAke2ludGVybmFscy5kb3QodGhpcy5tYWpvcil9LiR7aW50ZXJuYWxzLmRvdCh0aGlzLm1pbm9yKX0uJHtpbnRlcm5hbHMuZG90KHRoaXMucGF0Y2gpfSR7aW50ZXJuYWxzLnRva2VuKHRoaXMucHJlcmVsZWFzZSwgJy0nKX0ke2ludGVybmFscy50b2tlbih0aGlzLmJ1aWxkLCAnKycpfWA7XG4gICAgICAgIHRoaXMuZG90cyA9IFt0aGlzLm1ham9yLCB0aGlzLm1pbm9yLCB0aGlzLnBhdGNoXTtcbiAgICAgICAgdGhpcy53aWxkY2FyZCA9IHRoaXMubWFqb3IgPT09IGludGVybmFscy5hbnkgJiYgdGhpcy5taW5vciA9PT0gaW50ZXJuYWxzLmFueSAmJiB0aGlzLnBhdGNoID09PSBpbnRlcm5hbHMuYW55ICYmICF0aGlzLnByZXJlbGVhc2UubGVuZ3RoO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgfVxuXG4gICAgY29tcGFyZSh0bywgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuVmVyc2lvbi5jb21wYXJlKHRoaXMsIHRvLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29tcGFyZShhLCBiLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBsZXQgYUZpcnN0ID0gLTE7XG4gICAgICAgIGxldCBiRmlyc3QgPSAxO1xuXG4gICAgICAgIGEgPSBleHBvcnRzLnZlcnNpb24oYSwgb3B0aW9ucyk7XG4gICAgICAgIGIgPSBleHBvcnRzLnZlcnNpb24oYiwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gTWFyayBpbmNvbXBhdGlibGUgcHJlcmVsZWFzZXNcblxuICAgICAgICBpZiAob3B0aW9ucy5yYW5nZSAmJlxuICAgICAgICAgICAgYS5wcmVyZWxlYXNlLmxlbmd0aCAmJlxuICAgICAgICAgICAgKGEubWFqb3IgIT09IGIubWFqb3IgfHwgYS5taW5vciAhPT0gYi5taW5vciB8fCBhLnBhdGNoICE9PSBiLnBhdGNoIHx8ICFiLnByZXJlbGVhc2UubGVuZ3RoKSkge1xuXG4gICAgICAgICAgICBhRmlyc3QgPSAtMjtcbiAgICAgICAgICAgIGJGaXJzdCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIHZlcnNpb25zXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGF2ID0gYS5kb3RzW2ldO1xuICAgICAgICAgICAgY29uc3QgYnYgPSBiLmRvdHNbaV07XG5cbiAgICAgICAgICAgIGlmIChhdiA9PT0gYnYgfHxcbiAgICAgICAgICAgICAgICBhdiA9PT0gaW50ZXJuYWxzLmFueSB8fCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2lsZGNhcmQgaXMgZXF1YWwgdG8gZXZlcnl0aGluZ1xuICAgICAgICAgICAgICAgIGJ2ID09PSBpbnRlcm5hbHMuYW55KSB7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGF2IC0gYnYgPCAwID8gYUZpcnN0IDogYkZpcnN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBwcmVyZWxlYXNlXG5cbiAgICAgICAgaWYgKCFhLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICAhYi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghIWEucHJlcmVsZWFzZS5sZW5ndGggIT09ICEhYi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChhLnByZXJlbGVhc2UubGVuZ3RoID8gYUZpcnN0IDogYkZpcnN0KTsgICAgICAgICAvLyBwcmVyZWxlYXNlIDwgbm9uZVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhaSA9IGEucHJlcmVsZWFzZVtpXTtcbiAgICAgICAgICAgIGNvbnN0IGJpID0gYi5wcmVyZWxlYXNlW2ldO1xuXG4gICAgICAgICAgICBpZiAoYWkgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGJpID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWkgPT09IGJpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFGaXJzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYkZpcnN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBhbiA9IE51bWJlci5pc0Zpbml0ZShhaSk7XG4gICAgICAgICAgICBjb25zdCBibiA9IE51bWJlci5pc0Zpbml0ZShiaSk7XG5cbiAgICAgICAgICAgIGlmIChhbiAhPT0gYm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW4gPyBhRmlyc3QgOiBiRmlyc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoYSA8IGIgPyBhRmlyc3QgOiBiRmlyc3QpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZG90ID0gKHYpID0+IHtcblxuICAgIHJldHVybiAodiA9PT0gaW50ZXJuYWxzLmFueSA/ICd4JyA6IHYpO1xufTtcblxuXG5pbnRlcm5hbHMudG9rZW4gPSAodiwgcHJlZml4KSA9PiB7XG5cbiAgICBpZiAoIXYubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gYCR7cHJlZml4fSR7di5qb2luKCcuJyl9YDtcbn07XG5cblxuaW50ZXJuYWxzLlJhbmdlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocmFuZ2UsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICB0aGlzLl9hbnl0aGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vciA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBbYW5kLCBhbmQsIC4uLiwgYWN0aXZlXVxuICAgICAgICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuXG4gICAgICAgIGlmIChyYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBhdHRlcm4ocmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYW5vdGhlcigpO1xuICAgIH1cblxuICAgIF9hbm90aGVyKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlIHx8XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUucnVsZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHsgcnVsZXM6IFtdIH07XG4gICAgICAgICAgICB0aGlzLl9vci5wdXNoKHRoaXMuX2FjdGl2ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfcnVsZShvcGVyYXRvciwgdmVyc2lvbikge1xuXG4gICAgICAgIHZlcnNpb24gPSBleHBvcnRzLnZlcnNpb24odmVyc2lvbiwgdGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgICAgIGNvbnN0IGNvbXBhcmUgPSBpbnRlcm5hbHMub3BlcmF0b3Iob3BlcmF0b3IpO1xuICAgICAgICB0aGlzLl9hY3RpdmUucnVsZXMucHVzaCh7IGNvbXBhcmUsIHZlcnNpb24sIG9wZXJhdG9yIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldCBvcigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYW5vdGhlcigpO1xuICAgIH1cblxuICAgIGVxdWFsKHZlcnNpb24pIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZSgnPScsIHZlcnNpb24pO1xuICAgIH1cblxuICAgIGFib3ZlKHZlcnNpb24pIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZSgnPicsIHZlcnNpb24pO1xuICAgIH1cblxuICAgIGJlbG93KHZlcnNpb24pIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZSgnPCcsIHZlcnNpb24pO1xuICAgIH1cblxuICAgIGJldHdlZW4oZnJvbSwgdG8pIHtcblxuICAgICAgICB0aGlzLl9ydWxlKCc+PScsIGZyb20pO1xuICAgICAgICB0aGlzLl9ydWxlKCc8PScsIHRvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbWlub3IodmVyc2lvbikgeyAgICAgICAgLy8gfjEuMi4zXG5cbiAgICAgICAgLy8gbWlub3IoMi41LjcpICAgICAtPiAgICAgIDIuNS43IDw9IFggPCAyLjYuMFxuICAgICAgICAvLyBtaW5vcigyLjUueCkgICAgIC0+ICAgICAgMi41LjAgPD0gWCA8IDIuNi4wXG4gICAgICAgIC8vIG1pbm9yKDIueC54KSAgICAgLT4gICAgICAyLjAuMCA8PSBYIDwgMy4wLjBcblxuICAgICAgICB2ZXJzaW9uID0gZXhwb3J0cy52ZXJzaW9uKHZlcnNpb24sIHRoaXMuX3NldHRpbmdzKTtcblxuICAgICAgICBpZiAodmVyc2lvbi5tYWpvciA9PT0gaW50ZXJuYWxzLmFueSkge1xuICAgICAgICAgICAgdGhpcy5fcnVsZSgnPScsIHZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ydWxlKCc+PScsIHZlcnNpb24pO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uLm1pbm9yID09PSBpbnRlcm5hbHMuYW55KSB7XG4gICAgICAgICAgICB0aGlzLl9ydWxlKCc8JywgeyBtYWpvcjogdmVyc2lvbi5tYWpvciArIDEsIG1pbm9yOiAwLCBwYXRjaDogMCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bGUoJzwnLCB7IG1ham9yOiB2ZXJzaW9uLm1ham9yLCBtaW5vcjogdmVyc2lvbi5taW5vciArIDEsIHBhdGNoOiAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29tcGF0aWJsZSh2ZXJzaW9uKSB7ICAgICAgIC8vIF4xLjIuM1xuXG4gICAgICAgIC8vIGNvbXBhdGlibGUoMi41LjcpICAgICAtPiAgICAgIDIuNS43IDw9IFggPCAzLjAuMFxuICAgICAgICAvLyBjb21wYXRpYmxlKDIueC54KSAgICAgLT4gICAgICAyLjAuMCA8PSBYIDwgMy4wLjBcbiAgICAgICAgLy8gY29tcGF0aWJsZSgwLjEueCkgICAgIC0+ICAgICAgMC4xLjAgPD0gWCA8IDAuMi4wXG5cbiAgICAgICAgdmVyc2lvbiA9IGV4cG9ydHMudmVyc2lvbih2ZXJzaW9uLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPT09IGludGVybmFscy5hbnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bGUoJz0nLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcnVsZSgnPj0nLCB2ZXJzaW9uKTtcblxuICAgICAgICBpZiAodmVyc2lvbi5tYWpvciA9PT0gMCAmJlxuICAgICAgICAgICAgdmVyc2lvbi5taW5vciAhPT0gaW50ZXJuYWxzLmFueSkge1xuXG4gICAgICAgICAgICBpZiAodmVyc2lvbi5taW5vciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bGUoJzwnLCB7IG1ham9yOiAwLCBtaW5vcjogMCwgcGF0Y2g6IHZlcnNpb24ucGF0Y2ggKyAxIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVsZSgnPCcsIHsgbWFqb3I6IDAsIG1pbm9yOiB2ZXJzaW9uLm1pbm9yICsgMSwgcGF0Y2g6IDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ydWxlKCc8JywgeyBtYWpvcjogdmVyc2lvbi5tYWpvciArIDEsIG1pbm9yOiAwLCBwYXRjaDogMCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHBhdHRlcm4ocmFuZ2UpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcGF0dGVybihyYW5nZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmFuZ2U6IFwiJHtyYW5nZX1cIiBiZWNhdXNlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3BhdHRlcm4ocmFuZ2UpIHtcblxuICAgICAgICBpZiAocmFuZ2UgPT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9hbnl0aGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gaW50ZXJuYWxzLm5vcm1hbGl6ZShyYW5nZSk7XG4gICAgICAgIGNvbnN0IG9ycyA9IG5vcm1hbGl6ZWQuc3BsaXQoL1xccypcXHxcXHxcXHMqLyk7XG4gICAgICAgIGZvciAoY29uc3QgY29uZGl0aW9uIG9mIG9ycykge1xuICAgICAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbnl0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9hbm90aGVyKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFuZHMgPSBjb25kaXRpb24uc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYW5kIG9mIGFuZHMpIHtcblxuICAgICAgICAgICAgICAgIC8vIEh5cGhlbiByYW5nZVxuXG4gICAgICAgICAgICAgICAgY29uc3QgaHlwaGVuID0gYW5kLmluZGV4T2YoJ0AnKTsgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IFwiIC0gXCJcbiAgICAgICAgICAgICAgICBpZiAoaHlwaGVuICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gYW5kLnNsaWNlKDAsIGh5cGhlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gYW5kLnNsaWNlKGh5cGhlbiArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJldHdlZW4oZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQcmVmaXhcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYW5kLm1hdGNoKC9eKFxcXnx+fDxcXD18PlxcPXw8fD58XFw9KT8oLispJC8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IGV4cG9ydHMudmVyc2lvbihwYXJ0c1syXSwgdGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb24ud2lsZGNhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW55dGhpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGlsZGVcblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ34nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlub3IodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhcmV0XG5cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBhdGlibGUodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE9uZSBzaWRlZCByYW5nZVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3J1bGUob3BlcmF0b3IsIHZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBWZXJzaW9uXG5cbiAgICAgICAgICAgICAgICB0aGlzLmVxdWFsKHZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWF0Y2godmVyc2lvbikge1xuXG4gICAgICAgIHZlcnNpb24gPSBleHBvcnRzLnZlcnNpb24odmVyc2lvbiwgdGhpcy5fc2V0dGluZ3MpOyAgICAgICAvLyBBbHdheXMgcGFyc2UgdG8gdmFsaWRhdGVcblxuICAgICAgICBpZiAodGhpcy5fYW55dGhpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAhdmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgeyBydWxlcyB9IG9mIHRoaXMuX29yKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IDA7XG4gICAgICAgICAgICBsZXQgZXhjbHVkZXMgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wYXJlID0gdmVyc2lvbi5jb21wYXJlKHJ1bGUudmVyc2lvbiwgT2JqZWN0LmFzc2lnbih0aGlzLl9zZXR0aW5ncywgeyByYW5nZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZSA9IE1hdGguYWJzKGNvbXBhcmUpID09PSAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuY29tcGFyZS5pbmNsdWRlcyhjb21wYXJlIC8gKGV4Y2x1ZGUgPyAyIDogMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICsrbWF0Y2hlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrZXhjbHVkZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT09IHJ1bGVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVzIDwgbWF0Y2hlcykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FueXRoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJyonO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcnVsZXMgfSBvZiB0aGlzLl9vcikge1xuICAgICAgICAgICAgaWYgKCFydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKGAke3J1bGUub3BlcmF0b3IgIT09ICc9JyA/IHJ1bGUub3BlcmF0b3IgOiAnJ30ke3J1bGUudmVyc2lvbi52ZXJzaW9ufWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHJpbmcgKz0gKHN0cmluZyA/ICd8fCcgOiAnJykgKyBjb25kaXRpb25zLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMub3BlcmF0b3IgPSBmdW5jdGlvbiAoY29tcGFyZSkge1xuXG4gICAgc3dpdGNoIChjb21wYXJlKSB7XG4gICAgICAgIGNhc2UgJz0nOiByZXR1cm4gWzBdO1xuICAgICAgICBjYXNlICc+JzogcmV0dXJuIFsxXTtcbiAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gWzAsIDFdO1xuICAgICAgICBjYXNlICc8JzogcmV0dXJuIFstMV07XG4gICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIFswLCAtMV07XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMubm9ybWFsaXplID0gZnVuY3Rpb24gKHJhbmdlKSB7XG5cbiAgICByZXR1cm4gcmFuZ2VcbiAgICAgICAgLnJlcGxhY2UoLyBcXC0gL2csICdAJykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmFuZ2UgdG8gZXhjbHVkZWQgc3ltYm9sXG4gICAgICAgIC5yZXBsYWNlKC9+Pi9nLCAnficpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IG5wbSBvcGVyYXRvclxuICAgICAgICAucmVwbGFjZSgvKFxcXnx+fDxcXD18PlxcPXw8fD58XFw9KVxccyooW15cXHNdKykvZywgKCQwLCAkMSwgJDIpID0+IGAkeyQxfSR7JDJ9YCk7ICAgIC8vIFNwYWNlIGJldHdlZW4gb3BlcmF0b3IgYW5kIHZlcnNpb25cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgQm91cm5lID0gcmVxdWlyZSgnQGhhcGkvYm91cm5lJyk7XG5jb25zdCBDcnlwdGlsZXMgPSByZXF1aXJlKCdAaGFwaS9jcnlwdGlsZXMnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBJcm9uID0gcmVxdWlyZSgnQGhhcGkvaXJvbicpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLnNjaGVtYSA9IEpvaS5vYmplY3Qoe1xuICAgIHN0cmljdEhlYWRlcjogSm9pLmJvb2xlYW4oKSxcbiAgICBpZ25vcmVFcnJvcnM6IEpvaS5ib29sZWFuKCksXG4gICAgaXNTZWN1cmU6IEpvaS5ib29sZWFuKCksXG4gICAgaXNIdHRwT25seTogSm9pLmJvb2xlYW4oKSxcbiAgICBpc1NhbWVTaXRlOiBKb2kudmFsaWQoJ1N0cmljdCcsICdMYXgnKS5hbGxvdyhmYWxzZSksXG4gICAgcGF0aDogSm9pLnN0cmluZygpLmFsbG93KG51bGwpLFxuICAgIGRvbWFpbjogSm9pLnN0cmluZygpLmFsbG93KG51bGwpLFxuICAgIHR0bDogSm9pLm51bWJlcigpLmFsbG93KG51bGwpLFxuICAgIGVuY29kaW5nOiBKb2kuc3RyaW5nKCkudmFsaWQoJ2Jhc2U2NGpzb24nLCAnYmFzZTY0JywgJ2Zvcm0nLCAnaXJvbicsICdub25lJyksXG4gICAgc2lnbjogSm9pLm9iamVjdCh7XG4gICAgICAgIHBhc3N3b3JkOiBbSm9pLnN0cmluZygpLCBKb2kuYmluYXJ5KCksIEpvaS5vYmplY3QoKV0sXG4gICAgICAgIGludGVncml0eTogSm9pLm9iamVjdCgpXG4gICAgfSksXG4gICAgaXJvbjogSm9pLm9iamVjdCgpLFxuICAgIHBhc3N3b3JkOiBbSm9pLnN0cmluZygpLCBKb2kuYmluYXJ5KCksIEpvaS5vYmplY3QoKV0sXG5cbiAgICAvLyBVc2VkIGJ5IGhhcGlcblxuICAgIGNsZWFySW52YWxpZDogSm9pLmJvb2xlYW4oKSxcbiAgICBhdXRvVmFsdWU6IEpvaS5hbnkoKSxcbiAgICBwYXNzVGhyb3VnaDogSm9pLmJvb2xlYW4oKVxufSk7XG5cblxuaW50ZXJuYWxzLmRlZmF1bHRzID0ge1xuICAgIHN0cmljdEhlYWRlcjogdHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVpcmUgYW4gUkZDIDYyNjUgY29tcGxpYW50IGhlYWRlciBmb3JtYXRcbiAgICBpZ25vcmVFcnJvcnM6IGZhbHNlLFxuICAgIGlzU2VjdXJlOiB0cnVlLFxuICAgIGlzSHR0cE9ubHk6IHRydWUsXG4gICAgaXNTYW1lU2l0ZTogJ1N0cmljdCcsXG4gICAgcGF0aDogbnVsbCxcbiAgICBkb21haW46IG51bGwsXG4gICAgdHRsOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTVNlY3MsIDAgbWVhbnMgcmVtb3ZlXG4gICAgZW5jb2Rpbmc6ICdub25lJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW9uczogJ2Jhc2U2NGpzb24nLCAnYmFzZTY0JywgJ2Zvcm0nLCAnaXJvbicsICdub25lJ1xufTtcblxuXG5leHBvcnRzLkRlZmluaXRpb25zID0gaW50ZXJuYWxzLkRlZmluaXRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIHRoaXMuc2V0dGluZ3MgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xuICAgIEpvaS5hc3NlcnQodGhpcy5zZXR0aW5ncywgaW50ZXJuYWxzLnNjaGVtYSwgJ0ludmFsaWQgc3RhdGUgZGVmaW5pdGlvbiBkZWZhdWx0cycpO1xuXG4gICAgdGhpcy5jb29raWVzID0ge307XG4gICAgdGhpcy5uYW1lcyA9IFtdO1xufTtcblxuXG5pbnRlcm5hbHMuRGVmaW5pdGlvbnMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG5cbiAgICBIb2VrLmFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ0ludmFsaWQgbmFtZScpO1xuICAgIEhvZWsuYXNzZXJ0KCF0aGlzLmNvb2tpZXNbbmFtZV0sICdTdGF0ZSBhbHJlYWR5IGRlZmluZWQ6JywgbmFtZSk7XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKHRoaXMuc2V0dGluZ3MsIG9wdGlvbnMgfHwge30sIHsgbnVsbE92ZXJyaWRlOiB0cnVlIH0pO1xuICAgIEpvaS5hc3NlcnQoc2V0dGluZ3MsIGludGVybmFscy5zY2hlbWEsICdJbnZhbGlkIHN0YXRlIGRlZmluaXRpb246ICcgKyBuYW1lKTtcblxuICAgIHRoaXMuY29va2llc1tuYW1lXSA9IHNldHRpbmdzO1xuICAgIHRoaXMubmFtZXMucHVzaChuYW1lKTtcbn07XG5cblxuaW50ZXJuYWxzLmVtcHR5ID0gbmV3IGludGVybmFscy5EZWZpbml0aW9ucygpO1xuXG5cbi8vIEhlYWRlciBmb3JtYXRcblxuLy8gICAgICAgICAgICAgICAgICAgICAgMTogbmFtZSAgICAgICAgICAgICAgICAyOiBxdW90ZWQgIDM6IHZhbHVlXG5pbnRlcm5hbHMucGFyc2VSeCA9IC9cXHMqKFtePVxcc10qKVxccyo9XFxzKig/Oig/OlwiKFteXFxcIl0qKVwiKXwoW15cXDtdKikpKD86KD86O1xccyopfCQpL2c7XG5cbmludGVybmFscy52YWxpZGF0ZVJ4ID0ge1xuICAgIG5hbWVSeDoge1xuICAgICAgICBzdHJpY3Q6IC9eW15cXHgwMC1cXHgyMFxcKFxcKTw+QFxcLDtcXDpcXFxcXCJcXC9cXFtcXF1cXD9cXD1cXHtcXH1cXHg3Rl0rJC8sXG4gICAgICAgIGxvb3NlOiAvXltePVxcc10qJC9cbiAgICB9LFxuICAgIHZhbHVlUng6IHtcbiAgICAgICAgc3RyaWN0OiAvXlteXFx4MDAtXFx4MjBcXFwiXFwsXFw7XFxcXFxceDdGXSokLyxcbiAgICAgICAgbG9vc2U6IC9eKD86XCIoW15cXFwiXSopXCIpfCg/OlteXFw7XSopJC9cbiAgICB9LFxuICAgIGRvbWFpblJ4OiAvXlxcLj9bYS16XFxkXSsoPzooPzpbYS16XFxkXSopfCg/OlthLXpcXGRcXC1dKlthLXpcXGRdKSkoPzpcXC5bYS16XFxkXSsoPzooPzpbYS16XFxkXSopfCg/OlthLXpcXGRcXC1dKlthLXpcXGRdKSkpKiQvLFxuICAgIGRvbWFpbkxhYmVsTGVuUng6IC9eXFwuP1thLXpcXGRcXC1dezEsNjN9KD86XFwuW2EtelxcZFxcLV17MSw2M30pKiQvLFxuICAgIHBhdGhSeDogL15cXC9bXlxceDAwLVxceDFGXFw7XSokL1xufTtcblxuLy8gICAgICAgICAgICAgICAgICAgICAgMTogbmFtZSAgICAgICAgIDI6IHZhbHVlXG5pbnRlcm5hbHMucGFpcnNSeCA9IC9cXHMqKFtePVxcc10qKVxccyo9XFxzKihbXlxcO10qKSg/Oig/OjtcXHMqKXwkKS9nO1xuXG5cbmludGVybmFscy5EZWZpbml0aW9ucy5wcm90b3R5cGUucGFyc2UgPSBhc3luYyBmdW5jdGlvbiAoY29va2llcykge1xuXG4gICAgY29uc3Qgc3RhdGUgPSB7fTtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGNvbnN0IHZlcmlmeSA9IGNvb2tpZXMucmVwbGFjZShpbnRlcm5hbHMucGFyc2VSeCwgKCQwLCAkMSwgJDIsICQzKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbmFtZSA9ICQxO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICQyIHx8ICQzIHx8ICcnO1xuXG4gICAgICAgIGlmIChzdGF0ZVtuYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlW25hbWVdID0gW3N0YXRlW25hbWVdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGVbbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcblxuICAgIC8vIFZhbGlkYXRlIGNvb2tpZSBoZWFkZXIgc3ludGF4XG5cbiAgICBjb25zdCBmYWlsZWQgPSBbXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZXJyb3JzXG5cbiAgICBpZiAodmVyaWZ5ICE9PSAnJykge1xuICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuaWdub3JlRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29va2llIGhlYWRlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmFpbGVkLnB1c2goeyBzZXR0aW5nczogdGhpcy5zZXR0aW5ncywgcmVhc29uOiBgSGVhZGVyIGNvbnRhaW5zIHVuZXhwZWN0ZWQgc3ludGF4OiAke3ZlcmlmeX1gIH0pO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXJyb3JzXG5cbiAgICBjb25zdCBlcnJvcmVkID0gW107ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmlnbm9yZWQgZXJyb3JzXG4gICAgY29uc3QgcmVjb3JkID0gKHJlYXNvbiwgbmFtZSwgdmFsdWUsIGRlZmluaXRpb24pID0+IHtcblxuICAgICAgICBjb25zdCBkZXRhaWxzID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgc2V0dGluZ3M6IGRlZmluaXRpb24sXG4gICAgICAgICAgICByZWFzb246IHR5cGVvZiByZWFzb24gPT09ICdzdHJpbmcnID8gcmVhc29uIDogcmVhc29uLm1lc3NhZ2VcbiAgICAgICAgfTtcblxuICAgICAgICBmYWlsZWQucHVzaChkZXRhaWxzKTtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uLmlnbm9yZUVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JlZC5wdXNoKGRldGFpbHMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBhcnNlIGNvb2tpZXNcblxuICAgIGNvbnN0IHBhcnNlZCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YXRlW25hbWVdO1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5jb29raWVzW25hbWVdIHx8IHRoaXMuc2V0dGluZ3M7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgY29va2llXG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uc3RyaWN0SGVhZGVyKSB7XG4gICAgICAgICAgICBjb25zdCByZWFzb24gPSBpbnRlcm5hbHMudmFsaWRhdGUobmFtZSwgc3RhdGUpO1xuICAgICAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIHJlY29yZChyZWFzb24sIG5hbWUsIHZhbHVlLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGNvb2tpZSBmb3JtYXRcblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5lbmNvZGluZyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBwYXJzZWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIHZhbHVlXG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnNpZ25lZCA9IGF3YWl0IGludGVybmFscy51bnNpZ24obmFtZSwgdmFsdWUsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGludGVybmFscy5kZWNvZGUodW5zaWduZWQsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIHBhcnNlZFtuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgICAgICByZWNvcmQoZXJyLCBuYW1lLCB2YWx1ZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXlcblxuICAgICAgICBjb25zdCBhcnJheVJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gdmFsdWVbal07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5zaWduZWQgPSBhd2FpdCBpbnRlcm5hbHMudW5zaWduKG5hbWUsIGFycmF5VmFsdWUsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGludGVybmFscy5kZWNvZGUodW5zaWduZWQsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIGFycmF5UmVzdWx0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgICAgICByZWNvcmQoZXJyLCBuYW1lLCB2YWx1ZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJzZWRbbmFtZV0gPSBhcnJheVJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3JlZC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29va2llIHZhbHVlJywgZXJyb3JlZCk7XG4gICAgICAgIGVycm9yLnN0YXRlcyA9IHBhcnNlZDtcbiAgICAgICAgZXJyb3IuZmFpbGVkID0gZmFpbGVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4geyBzdGF0ZXM6IHBhcnNlZCwgZmFpbGVkIH07XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGF0ZSkge1xuXG4gICAgaWYgKCFuYW1lLm1hdGNoKGludGVybmFscy52YWxpZGF0ZVJ4Lm5hbWVSeC5zdHJpY3QpKSB7XG4gICAgICAgIHJldHVybiAnSW52YWxpZCBjb29raWUgbmFtZSc7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWVzID0gW10uY29uY2F0KHN0YXRlW25hbWVdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIXZhbHVlc1tpXS5tYXRjaChpbnRlcm5hbHMudmFsaWRhdGVSeC52YWx1ZVJ4LnN0cmljdCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCBjb29raWUgdmFsdWUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5tYWNQcmVmaXggPSAnaGFwaS5zaWduZWQuY29va2llLjEnO1xuXG5cbmludGVybmFscy51bnNpZ24gPSBhc3luYyBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGRlZmluaXRpb24pIHtcblxuICAgIGlmICghZGVmaW5pdGlvbi5zaWduKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSB2YWx1ZS5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnTWlzc2luZyBzaWduYXR1cmUgc2VwYXJhdG9yJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5zaWduZWQgPSB2YWx1ZS5zbGljZSgwLCBwb3MpO1xuICAgIGNvbnN0IHNpZyA9IHZhbHVlLnNsaWNlKHBvcyArIDEpO1xuXG4gICAgaWYgKCFzaWcpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdNaXNzaW5nIHNpZ25hdHVyZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ1BhcnRzID0gc2lnLnNwbGl0KCcqJyk7XG4gICAgaWYgKHNpZ1BhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgc2lnbmF0dXJlIGZvcm1hdCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGhtYWNTYWx0ID0gc2lnUGFydHNbMF07XG4gICAgY29uc3QgaG1hYyA9IHNpZ1BhcnRzWzFdO1xuXG4gICAgY29uc3QgbWFjT3B0aW9ucyA9IEhvZWsuY2xvbmUoZGVmaW5pdGlvbi5zaWduLmludGVncml0eSB8fCBJcm9uLmRlZmF1bHRzLmludGVncml0eSk7XG4gICAgbWFjT3B0aW9ucy5zYWx0ID0gaG1hY1NhbHQ7XG4gICAgY29uc3QgbWFjID0gYXdhaXQgSXJvbi5obWFjV2l0aFBhc3N3b3JkKGRlZmluaXRpb24uc2lnbi5wYXNzd29yZCwgbWFjT3B0aW9ucywgW2ludGVybmFscy5tYWNQcmVmaXgsIG5hbWUsIHVuc2lnbmVkXS5qb2luKCdcXG4nKSk7XG4gICAgaWYgKCFDcnlwdGlsZXMuZml4ZWRUaW1lQ29tcGFyaXNvbihtYWMuZGlnZXN0LCBobWFjKSkge1xuICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgaG1hYyB2YWx1ZScpO1xuICAgIH1cblxuICAgIHJldHVybiB1bnNpZ25lZDtcbn07XG5cblxuaW50ZXJuYWxzLmRlY29kZSA9IGFzeW5jIGZ1bmN0aW9uICh2YWx1ZSwgZGVmaW5pdGlvbikge1xuXG4gICAgaWYgKCF2YWx1ZSAmJlxuICAgICAgICBkZWZpbml0aW9uLmVuY29kaW5nID09PSAnZm9ybScpIHtcblxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgSG9lay5hc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJywgJ0ludmFsaWQgc3RyaW5nJyk7XG5cbiAgICAvLyBFbmNvZGluZ3M6ICdiYXNlNjRqc29uJywgJ2Jhc2U2NCcsICdmb3JtJywgJ2lyb24nLCAnbm9uZSdcblxuICAgIGlmIChkZWZpbml0aW9uLmVuY29kaW5nID09PSAnaXJvbicpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IElyb24udW5zZWFsKHZhbHVlLCBkZWZpbml0aW9uLnBhc3N3b3JkLCBkZWZpbml0aW9uLmlyb24gfHwgSXJvbi5kZWZhdWx0cyk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmluaXRpb24uZW5jb2RpbmcgPT09ICdiYXNlNjRqc29uJykge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gKEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmFzZTY0JykpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCb3VybmUucGFyc2UoZGVjb2RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIEpTT04gcGF5bG9hZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmluaXRpb24uZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIHJldHVybiAoQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKSkudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIH1cblxuICAgIC8vIGVuY29kaW5nOiAnZm9ybSdcblxuICAgIHJldHVybiBRdWVyeXN0cmluZy5wYXJzZSh2YWx1ZSk7XG59O1xuXG5cbmludGVybmFscy5EZWZpbml0aW9ucy5wcm90b3R5cGUuZm9ybWF0ID0gYXN5bmMgZnVuY3Rpb24gKGNvb2tpZXMpIHtcblxuICAgIGlmICghY29va2llcyB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShjb29raWVzKSAmJiAhY29va2llcy5sZW5ndGgpKSB7XG5cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb29raWVzKSkge1xuICAgICAgICBjb29raWVzID0gW2Nvb2tpZXNdO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWRlciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29va2llcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb29raWUgPSBjb29raWVzW2ldO1xuXG4gICAgICAgIC8vIEFwcGx5IGRlZmluaXRpb24gdG8gbG9jYWwgY29uZmlndXJhdGlvblxuXG4gICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLmNvb2tpZXNbY29va2llLm5hbWVdIHx8IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb29raWUub3B0aW9ucyA/IEhvZWsuYXBwbHlUb0RlZmF1bHRzKGJhc2UsIGNvb2tpZS5vcHRpb25zLCB7IG51bGxPdmVycmlkZTogdHJ1ZSB9KSA6IGJhc2U7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgbmFtZVxuXG4gICAgICAgIGNvbnN0IG5hbWVSeCA9IChkZWZpbml0aW9uLnN0cmljdEhlYWRlciA/IGludGVybmFscy52YWxpZGF0ZVJ4Lm5hbWVSeC5zdHJpY3QgOiBpbnRlcm5hbHMudmFsaWRhdGVSeC5uYW1lUngubG9vc2UpO1xuICAgICAgICBpZiAoIW5hbWVSeC50ZXN0KGNvb2tpZS5uYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignSW52YWxpZCBjb29raWUgbmFtZTogJyArIGNvb2tpZS5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBhcmUgdmFsdWUgKGVuY29kZSwgc2lnbilcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4cG9ydHMucHJlcGFyZVZhbHVlKGNvb2tpZS5uYW1lLCBjb29raWUudmFsdWUsIGRlZmluaXRpb24pO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHByZXBhcmVkIHZhbHVlXG5cbiAgICAgICAgY29uc3QgdmFsdWVSeCA9IChkZWZpbml0aW9uLnN0cmljdEhlYWRlciA/IGludGVybmFscy52YWxpZGF0ZVJ4LnZhbHVlUnguc3RyaWN0IDogaW50ZXJuYWxzLnZhbGlkYXRlUngudmFsdWVSeC5sb29zZSk7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKHZhbHVlUngpKSkge1xuXG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdJbnZhbGlkIGNvb2tpZSB2YWx1ZTogJyArIGNvb2tpZS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25zdHJ1Y3QgY29va2llXG5cbiAgICAgICAgbGV0IHNlZ21lbnQgPSBjb29raWUubmFtZSArICc9JyArICh2YWx1ZSB8fCAnJyk7XG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24udHRsICE9PSBudWxsICYmXG4gICAgICAgICAgICBkZWZpbml0aW9uLnR0bCAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgLy8gQ2FuIGJlIHplcm9cblxuICAgICAgICAgICAgY29uc3QgZXhwaXJlcyA9IG5ldyBEYXRlKGRlZmluaXRpb24udHRsID8gRGF0ZS5ub3coKSArIGRlZmluaXRpb24udHRsIDogMCk7XG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudCArICc7IE1heC1BZ2U9JyArIE1hdGguZmxvb3IoZGVmaW5pdGlvbi50dGwgLyAxMDAwKSArICc7IEV4cGlyZXM9JyArIGV4cGlyZXMudG9VVENTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmlzU2VjdXJlKSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudCArICc7IFNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5pc0h0dHBPbmx5KSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudCArICc7IEh0dHBPbmx5JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmlzU2FtZVNpdGUpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50ICsgYDsgU2FtZVNpdGU9JHtkZWZpbml0aW9uLmlzU2FtZVNpdGV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmRvbWFpbikge1xuICAgICAgICAgICAgY29uc3QgZG9tYWluID0gZGVmaW5pdGlvbi5kb21haW4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICghZG9tYWluLm1hdGNoKGludGVybmFscy52YWxpZGF0ZVJ4LmRvbWFpbkxhYmVsTGVuUngpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignQ29va2llIGRvbWFpbiB0b28gbG9uZzogJyArIGRlZmluaXRpb24uZG9tYWluKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkb21haW4ubWF0Y2goaW50ZXJuYWxzLnZhbGlkYXRlUnguZG9tYWluUngpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignSW52YWxpZCBjb29raWUgZG9tYWluOiAnICsgZGVmaW5pdGlvbi5kb21haW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudCArICc7IERvbWFpbj0nICsgZG9tYWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24ucGF0aCkge1xuICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uLnBhdGgubWF0Y2goaW50ZXJuYWxzLnZhbGlkYXRlUngucGF0aFJ4KSkge1xuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0ludmFsaWQgY29va2llIHBhdGg6ICcgKyBkZWZpbml0aW9uLnBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudCArICc7IFBhdGg9JyArIGRlZmluaXRpb24ucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWRlci5wdXNoKHNlZ21lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXI7XG59O1xuXG5cbmV4cG9ydHMucHJlcGFyZVZhbHVlID0gYXN5bmMgZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICBIb2VrLmFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ01pc3Npbmcgb3IgaW52YWxpZCBvcHRpb25zJyk7XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gYXdhaXQgaW50ZXJuYWxzLmVuY29kZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IGF3YWl0IGludGVybmFscy5zaWduKG5hbWUsIGVuY29kZWQsIG9wdGlvbnMuc2lnbik7XG4gICAgICAgIHJldHVybiBzaWduZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignRmFpbGVkIHRvIGVuY29kZSBjb29raWUgKCcgKyBuYW1lICsgJykgdmFsdWU6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZW5jb2RlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAvLyBFbmNvZGluZ3M6ICdiYXNlNjRqc29uJywgJ2Jhc2U2NCcsICdmb3JtJywgJ2lyb24nLCAnbm9uZSdcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdub25lJykge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2lyb24nKSB7XG4gICAgICAgIHJldHVybiBJcm9uLnNlYWwodmFsdWUsIG9wdGlvbnMucGFzc3dvcmQsIG9wdGlvbnMuaXJvbiB8fCBJcm9uLmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgcmV0dXJuIChCdWZmZXIuZnJvbSh2YWx1ZSwgJ2JpbmFyeScpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiYXNlNjRqc29uJykge1xuICAgICAgICBjb25zdCBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChCdWZmZXIuZnJvbShzdHJpbmdpZmllZCwgJ2JpbmFyeScpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuXG4gICAgLy8gZW5jb2Rpbmc6ICdmb3JtJ1xuXG4gICAgcmV0dXJuIFF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh2YWx1ZSk7XG59O1xuXG5cbmludGVybmFscy5zaWduID0gYXN5bmMgZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAhb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBtYWMgPSBhd2FpdCBJcm9uLmhtYWNXaXRoUGFzc3dvcmQob3B0aW9ucy5wYXNzd29yZCwgb3B0aW9ucy5pbnRlZ3JpdHkgfHwgSXJvbi5kZWZhdWx0cy5pbnRlZ3JpdHksIFtpbnRlcm5hbHMubWFjUHJlZml4LCBuYW1lLCB2YWx1ZV0uam9pbignXFxuJykpO1xuICAgIGNvbnN0IHNpZ25lZCA9IHZhbHVlICsgJy4nICsgbWFjLnNhbHQgKyAnKicgKyBtYWMuZGlnZXN0O1xuICAgIHJldHVybiBzaWduZWQ7XG59O1xuXG5cbmludGVybmFscy5EZWZpbml0aW9ucy5wcm90b3R5cGUucGFzc1Rocm91Z2ggPSBmdW5jdGlvbiAoaGVhZGVyLCBmYWxsYmFjaykge1xuXG4gICAgaWYgKCF0aGlzLm5hbWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaGVhZGVyO1xuICAgIH1cblxuICAgIGNvbnN0IGV4Y2x1ZGUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZXNbaV07XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmNvb2tpZXNbbmFtZV07XG4gICAgICAgIGNvbnN0IHBhc3NDb29raWUgPSBkZWZpbml0aW9uLnBhc3NUaHJvdWdoICE9PSB1bmRlZmluZWQgPyBkZWZpbml0aW9uLnBhc3NUaHJvdWdoIDogZmFsbGJhY2s7XG4gICAgICAgIGlmICghcGFzc0Nvb2tpZSkge1xuICAgICAgICAgICAgZXhjbHVkZS5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZXhjbHVkZShoZWFkZXIsIGV4Y2x1ZGUpO1xufTtcblxuXG5leHBvcnRzLmV4Y2x1ZGUgPSBmdW5jdGlvbiAoY29va2llcywgZXhjbHVkZXMpIHtcblxuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjb25zdCB2ZXJpZnkgPSBjb29raWVzLnJlcGxhY2UoaW50ZXJuYWxzLnBhaXJzUngsICgkMCwgJDEsICQyKSA9PiB7XG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVzLmluZGV4T2YoJDEpID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKHJlc3VsdCA/ICc7JyA6ICcnKSArICQxICsgJz0nICsgJDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmVyaWZ5ID09PSAnJyA/IHJlc3VsdCA6IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb29raWUgaGVhZGVyJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBGcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBPcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBRdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IFpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VybmUgPSByZXF1aXJlKCdAaGFwaS9ib3VybmUnKTtcbmNvbnN0IENvbnRlbnQgPSByZXF1aXJlKCdAaGFwaS9jb250ZW50Jyk7XG5jb25zdCBGaWxlID0gcmVxdWlyZSgnQGhhcGkvZmlsZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IFBleiA9IHJlcXVpcmUoJ0BoYXBpL3BleicpO1xuY29uc3QgV3JlY2sgPSByZXF1aXJlKCdAaGFwaS93cmVjaycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBkZWNvZGVyczoge1xuICAgICAgICBnemlwOiAob3B0aW9ucykgPT4gWmxpYi5jcmVhdGVHdW56aXAob3B0aW9ucyksXG4gICAgICAgIGRlZmxhdGU6IChvcHRpb25zKSA9PiBabGliLmNyZWF0ZUluZmxhdGUob3B0aW9ucylcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMucGFyc2UgPSBhc3luYyBmdW5jdGlvbiAocmVxLCB0YXAsIG9wdGlvbnMpIHtcblxuICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMsICdNaXNzaW5nIG9wdGlvbnMnKTtcbiAgICBIb2VrLmFzc2VydChvcHRpb25zLnBhcnNlICE9PSB1bmRlZmluZWQsICdNaXNzaW5nIHBhcnNlIG9wdGlvbiBzZXR0aW5nJyk7XG4gICAgSG9lay5hc3NlcnQob3B0aW9ucy5vdXRwdXQgIT09IHVuZGVmaW5lZCwgJ01pc3Npbmcgb3V0cHV0IG9wdGlvbiBzZXR0aW5nJyk7XG5cbiAgICAvLyBDb250ZW50IHNpemVcblxuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSByZXEuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICBpZiAob3B0aW9ucy5tYXhCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGNvbnRlbnRMZW5ndGggJiZcbiAgICAgICAgcGFyc2VJbnQoY29udGVudExlbmd0aCwgMTApID4gb3B0aW9ucy5tYXhCeXRlcykge1xuXG4gICAgICAgIHRocm93IEJvb20uZW50aXR5VG9vTGFyZ2UoJ1BheWxvYWQgY29udGVudCBsZW5ndGggZ3JlYXRlciB0aGFuIG1heGltdW0gYWxsb3dlZDogJyArIG9wdGlvbnMubWF4Qnl0ZXMpO1xuICAgIH1cblxuICAgIC8vIENvbnRlbnQgdHlwZVxuXG4gICAgY29uc3QgY29udGVudFR5cGUgPSBDb250ZW50LnR5cGUob3B0aW9ucy5vdmVycmlkZSB8fCByZXEuaGVhZGVyc1snY29udGVudC10eXBlJ10gfHwgb3B0aW9ucy5kZWZhdWx0Q29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93ICYmXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93LmluZGV4T2YoY29udGVudFR5cGUubWltZSkgPT09IC0xKSB7XG5cbiAgICAgICAgICAgIHRocm93IEJvb20udW5zdXBwb3J0ZWRNZWRpYVR5cGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHsgbWltZTogY29udGVudFR5cGUubWltZSB9O1xuXG4gICAgICAgIC8vIFBhcnNlOiB0cnVlXG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXlsb2FkID0gYXdhaXQgaW50ZXJuYWxzLnBhcnNlKHJlcSwgdGFwLCBvcHRpb25zLCBjb250ZW50VHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2U6IGZhbHNlLCAnZ3VuemlwJ1xuXG4gICAgICAgIHBhcnNlZC5wYXlsb2FkID0gYXdhaXQgaW50ZXJuYWxzLnJhdyhyZXEsIHRhcCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyLm1pbWUgPSBjb250ZW50VHlwZS5taW1lO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucGFyc2UgPSBhc3luYyBmdW5jdGlvbiAocmVxLCB0YXAsIG9wdGlvbnMsIGNvbnRlbnRUeXBlKSB7XG5cbiAgICBjb25zdCBvdXRwdXQgPSBvcHRpb25zLm91dHB1dDsgICAgICAgIC8vIE91dHB1dDogJ2RhdGEnLCAnc3RyZWFtJywgJ2ZpbGUnXG4gICAgbGV0IHNvdXJjZSA9IGludGVybmFscy5kZWNvZGVyKHJlcSwgb3B0aW9ucyk7XG5cbiAgICAvLyBUYXAgcmVxdWVzdFxuXG4gICAgaWYgKHRhcCkge1xuICAgICAgICBzb3VyY2UgPSBpbnRlcm5hbHMucGlwZShzb3VyY2UsIHRhcCk7XG4gICAgfVxuXG4gICAgLy8gTXVsdGlwYXJ0XG5cbiAgICBpZiAoY29udGVudFR5cGUubWltZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm11bHRpcGFydCA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgdGhyb3cgQm9vbS51bnN1cHBvcnRlZE1lZGlhVHlwZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IGludGVybmFscy5tdWx0aXBhcnQocmVxLCBvcHRpb25zLCBzb3VyY2UsIGNvbnRlbnRUeXBlKTtcbiAgICB9XG5cbiAgICAvLyBPdXRwdXQ6ICdzdHJlYW0nXG5cbiAgICBpZiAob3V0cHV0ID09PSAnc3RyZWFtJykge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIC8vIE91dHB1dDogJ2ZpbGUnXG5cbiAgICBpZiAob3V0cHV0ID09PSAnZmlsZScpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IGludGVybmFscy53cml0ZUZpbGUocmVxLCBvcHRpb25zLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gZmlsZS5pdGVtO1xuICAgIH1cblxuICAgIC8vIE91dHB1dDogJ2RhdGEnXG5cbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgV3JlY2sucmVhZChzb3VyY2UsIHsgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LCBtYXhCeXRlczogb3B0aW9ucy5tYXhCeXRlcyB9KTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLm9iamVjdChvcHRpb25zLCBwYXlsb2FkLCBjb250ZW50VHlwZS5taW1lKTtcbn07XG5cblxuaW50ZXJuYWxzLmRlY29kZXIgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBzb3VyY2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddO1xuICAgIGNvbnN0IGRlY29kZXIgPSAob3B0aW9ucy5kZWNvZGVycyB8fCBpbnRlcm5hbHMuZGVjb2RlcnMpW2NvbnRlbnRFbmNvZGluZ107XG4gICAgaWYgKCFkZWNvZGVyKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2Rlck9wdGlvbnMgPSAob3B0aW9ucy5jb21wcmVzc2lvbiAmJiBvcHRpb25zLmNvbXByZXNzaW9uW2NvbnRlbnRFbmNvZGluZ10pIHx8IG51bGw7XG4gICAgY29uc3Qgc3RyZWFtID0gZGVjb2RlcihkZWNvZGVyT3B0aW9ucyk7XG5cbiAgICBjb25zdCBvcmlnID0gc3RyZWFtLmVtaXQ7XG4gICAgc3RyZWFtLmVtaXQgPSAoZXZlbnQsIC4uLmFyZ3MpID0+IHtcblxuICAgICAgICBpZiAoZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGNvbXByZXNzZWQgcGF5bG9hZCcsIGFyZ3NbMF0pXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcmlnLmNhbGwoc3RyZWFtLCBldmVudCwgLi4uYXJncyk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlcm5hbHMucGlwZShzb3VyY2UsIHN0cmVhbSk7XG59O1xuXG5cbmludGVybmFscy5yYXcgPSBhc3luYyBmdW5jdGlvbiAocmVxLCB0YXAsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IG91dHB1dCA9IG9wdGlvbnMub3V0cHV0OyAgICAgIC8vIE91dHB1dDogJ2RhdGEnLCAnc3RyZWFtJywgJ2ZpbGUnXG4gICAgbGV0IHNvdXJjZSA9IHJlcTtcblxuICAgIC8vIENvbnRlbnQtZW5jb2RpbmcgKG9wdGlvbmFsKVxuXG4gICAgaWYgKG9wdGlvbnMucGFyc2UgPT09ICdndW56aXAnKSB7XG4gICAgICAgIHNvdXJjZSA9IGludGVybmFscy5kZWNvZGVyKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgc291cmNlXG5cbiAgICBpZiAodGFwKSB7XG4gICAgICAgIHNvdXJjZSA9IGludGVybmFscy5waXBlKHNvdXJjZSwgdGFwKTtcbiAgICB9XG5cbiAgICAvLyBPdXRwdXQ6ICdzdHJlYW0nXG5cbiAgICBpZiAob3V0cHV0ID09PSAnc3RyZWFtJykge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIC8vIE91dHB1dDogJ2ZpbGUnXG5cbiAgICBpZiAob3V0cHV0ID09PSAnZmlsZScpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IGludGVybmFscy53cml0ZUZpbGUocmVxLCBvcHRpb25zLCBzb3VyY2UpO1xuICAgICAgICByZXR1cm4gZmlsZS5pdGVtO1xuICAgIH1cblxuICAgIC8vIE91dHB1dDogJ2RhdGEnXG5cbiAgICByZXR1cm4gYXdhaXQgV3JlY2sucmVhZChzb3VyY2UsIHsgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LCBtYXhCeXRlczogb3B0aW9ucy5tYXhCeXRlcyB9KTtcbn07XG5cblxuaW50ZXJuYWxzLm9iamVjdCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXlsb2FkLCBtaW1lKSB7XG5cbiAgICAvLyBCaW5hcnlcblxuICAgIGlmIChtaW1lID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICByZXR1cm4gKHBheWxvYWQubGVuZ3RoID8gcGF5bG9hZCA6IG51bGwpO1xuICAgIH1cblxuICAgIC8vIFRleHRcblxuICAgIGlmIChtaW1lLm1hdGNoKC9edGV4dFxcLy4rJC8pKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxuXG4gICAgLy8gSlNPTlxuXG4gICAgaWYgKC9eYXBwbGljYXRpb25cXC8oPzouK1xcKyk/anNvbiQvLnRlc3QobWltZSkpIHtcbiAgICAgICAgaWYgKCFwYXlsb2FkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJvdXJuZS5wYXJzZShwYXlsb2FkLnRvU3RyaW5nKCd1dGY4JyksIHsgcHJvdG9BY3Rpb246IG9wdGlvbnMucHJvdG9BY3Rpb24gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgcmVxdWVzdCBwYXlsb2FkIEpTT04gZm9ybWF0JywgZXJyKTtcbiAgICAgICAgICAgIGVycm9yLnJhdyA9IHBheWxvYWQ7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvcm0tZW5jb2RlZFxuXG4gICAgaWYgKG1pbWUgPT09ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlID0gKG9wdGlvbnMucXVlcnlzdHJpbmcgfHwgUXVlcnlzdHJpbmcucGFyc2UpO1xuICAgICAgICByZXR1cm4gKHBheWxvYWQubGVuZ3RoID8gcGFyc2UocGF5bG9hZC50b1N0cmluZygndXRmOCcpKSA6IHt9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IEJvb20udW5zdXBwb3J0ZWRNZWRpYVR5cGUoKTtcbiAgICBlcnJvci5yYXcgPSBwYXlsb2FkO1xuICAgIHRocm93IGVycm9yO1xufTtcblxuXG5pbnRlcm5hbHMubXVsdGlwYXJ0ID0gZnVuY3Rpb24gKHJlcSwgb3B0aW9ucywgc291cmNlLCBjb250ZW50VHlwZSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAvLyBTZXQgc3RyZWFtIHRpbWVvdXRcblxuICAgICAgICBjb25zdCBjbGllbnRUaW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0O1xuICAgICAgICBjb25zdCBjbGllbnRUaW1lb3V0SWQgPSAoY2xpZW50VGltZW91dCA/IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KEJvb20uY2xpZW50VGltZW91dCgpKSwgY2xpZW50VGltZW91dCkgOiBudWxsKTtcblxuICAgICAgICAvLyBDcmVhdGUgcGFyc2VyXG5cbiAgICAgICAgY29uc3QgZGlzcGVuc2VyT3B0aW9ucyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKGNvbnRlbnRUeXBlLCB7IG1heEJ5dGVzOiBvcHRpb25zLm1heEJ5dGVzIH0pO1xuICAgICAgICBjb25zdCBkaXNwZW5zZXIgPSBuZXcgUGV6LkRpc3BlbnNlcihkaXNwZW5zZXJPcHRpb25zKTtcblxuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4gcmVqZWN0KEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBtdWx0aXBhcnQgcGF5bG9hZCBmb3JtYXQnLCBlcnIpKTtcbiAgICAgICAgZGlzcGVuc2VyLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xuICAgICAgICBjb25zdCBwZW5kaW5nRmlsZXMgPSBbXTtcblxuICAgICAgICBjb25zdCBzZXQgPSAobmFtZSwgdmFsdWUpID0+IHtcblxuICAgICAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkYXRhW25hbWVdKSkge1xuICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhW25hbWVdID0gW2RhdGFbbmFtZV0sIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBmaW5hbGl6ZSA9IGFzeW5jICgpID0+IHtcblxuICAgICAgICAgICAgLy8gQ2xlYW4gdXBcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsaWVudFRpbWVvdXRJZCk7XG4gICAgICAgICAgICBkaXNwZW5zZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICBkaXNwZW5zZXIucmVtb3ZlTGlzdGVuZXIoJ3BhcnQnLCBvblBhcnQpO1xuICAgICAgICAgICAgZGlzcGVuc2VyLnJlbW92ZUxpc3RlbmVyKCdmaWVsZCcsIG9uRmllbGQpO1xuICAgICAgICAgICAgZGlzcGVuc2VyLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpO1xuXG4gICAgICAgICAgICAvLyBXYWl0IGZvciBmaWxlc1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocGVuZGluZ0ZpbGVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgaXRlbSwgbmFtZSB9IG9mIGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldChuYW1lLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IChvcHRpb25zLm11bHRpcGFydCA/IG9wdGlvbnMubXVsdGlwYXJ0Lm91dHB1dCA6IG9wdGlvbnMub3V0cHV0KTtcblxuICAgICAgICBjb25zdCBvblBhcnQgPSAocGFydCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAob3V0cHV0ID09PSAnZmlsZScpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0OiAnZmlsZSdcbiAgICAgICAgICAgICAgICBwZW5kaW5nRmlsZXMucHVzaChpbnRlcm5hbHMud3JpdGVGaWxlKHJlcSwgb3B0aW9ucywgcGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLnBhcnQocGFydCwgb3V0cHV0LCBzZXQsIG9wdGlvbnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0OiAnZGF0YScgLyAnc3RyZWFtJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGRpc3BlbnNlci5vbigncGFydCcsIG9uUGFydCk7XG5cbiAgICAgICAgY29uc3Qgb25GaWVsZCA9IChuYW1lLCB2YWx1ZSkgPT4gc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgZGlzcGVuc2VyLm9uKCdmaWVsZCcsIG9uRmllbGQpO1xuXG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiBmaW5hbGl6ZSgpO1xuICAgICAgICBkaXNwZW5zZXIub25jZSgnY2xvc2UnLCBvbkNsb3NlKTtcblxuICAgICAgICBzb3VyY2UucGlwZShkaXNwZW5zZXIpO1xuICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMud3JpdGVGaWxlID0gZnVuY3Rpb24gKHJlcSwgb3B0aW9ucywgc3RyZWFtKSB7XG5cbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHBhdGggPSBGaWxlLnVuaXF1ZUZpbGVuYW1lKG9wdGlvbnMudXBsb2FkcyB8fCBPcy50bXBkaXIoKSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBGcy5jcmVhdGVXcml0ZVN0cmVhbShwYXRoLCB7IGZsYWdzOiAnd3gnIH0pO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IGludGVybmFscy5Db3VudGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN0IGZpbmFsaXplID0gKGVycikgPT4ge1xuXG4gICAgICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0ZWQnLCBvbkFib3J0KTtcbiAgICAgICAgICAgIGZpbGUucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgZmluYWxpemUpO1xuICAgICAgICAgICAgZmlsZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBmaW5hbGl6ZSk7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0udW5waXBlKGNvdW50ZXIpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXIudW5waXBlKGZpbGUpO1xuXG4gICAgICAgICAgICAgICAgZmlsZS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgRnMudW5saW5rKHBhdGgsICgvKiBmc0VyciAqLykgPT4gcmVqZWN0KGVycikpOyAgICAgIC8vIElnbm9yZSB1bmxpbmsgZXJyb3JzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgaXRlbToge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBieXRlczogY291bnRlci5ieXRlc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChzdHJlYW0ubmFtZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVsdGlwYXJ0XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm5hbWUgPSBzdHJlYW0ubmFtZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuaXRlbS5maWxlbmFtZSA9IHN0cmVhbS5maWxlbmFtZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuaXRlbS5oZWFkZXJzID0gc3RyZWFtLmhlYWRlcnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmaWxlLm9uY2UoJ2Nsb3NlJywgZmluYWxpemUpO1xuICAgICAgICBmaWxlLm9uY2UoJ2Vycm9yJywgZmluYWxpemUpO1xuXG4gICAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiBmaW5hbGl6ZShCb29tLmJhZFJlcXVlc3QoJ0NsaWVudCBjb25uZWN0aW9uIGFib3J0ZWQnKSk7XG4gICAgICAgIHJlcS5vbmNlKCdhYm9ydGVkJywgb25BYm9ydCk7XG5cbiAgICAgICAgaW50ZXJuYWxzLnBpcGUoc3RyZWFtLCBjb3VudGVyKTtcbiAgICAgICAgaW50ZXJuYWxzLnBpcGUoY291bnRlciwgZmlsZSk7XG4gICAgfSk7XG5cbiAgICBwcm9taXNlLmNhdGNoKEhvZWsuaWdub3JlKTsgICAgIC8vIFByZXZlbnQgdHJpZ2dlcmluZyBub2RlJ3MgUHJvbWlzZVJlamVjdGlvbkhhbmRsZWRXYXJuaW5nXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5cbmludGVybmFscy5wYXJ0ID0gYXN5bmMgZnVuY3Rpb24gKHBhcnQsIG91dHB1dCwgc2V0LCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgV3JlY2sucmVhZChwYXJ0KTsgICAgICAgICAgICAgLy8gRXJyb3IgaGFuZGxlZCBieSBkaXNwZW5zZXIub25jZSgnZXJyb3InKVxuXG4gICAgaWYgKG91dHB1dCA9PT0gJ3N0cmVhbScpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91dHB1dDogJ3N0cmVhbSdcbiAgICAgICAgY29uc3QgaXRlbSA9IFdyZWNrLnRvUmVhZGFibGVTdHJlYW0ocGF5bG9hZCk7XG4gICAgICAgIGl0ZW0uaGFwaSA9IHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgaGVhZGVyczogcGFydC5oZWFkZXJzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHNldChwYXJ0Lm5hbWUsIGl0ZW0pO1xuICAgIH1cblxuICAgIGNvbnN0IGN0ID0gcGFydC5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnJzsgICAgICAvLyBPdXRwdXQ6ICdkYXRhJ1xuICAgIGNvbnN0IG1pbWUgPSBjdC5zcGxpdCgnOycpWzBdLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGFubm90YXRlID0gKHZhbHVlKSA9PiBzZXQocGFydC5uYW1lLCBvdXRwdXQgPT09ICdhbm5vdGF0ZWQnID8geyBmaWxlbmFtZTogcGFydC5maWxlbmFtZSwgaGVhZGVyczogcGFydC5oZWFkZXJzLCBwYXlsb2FkOiB2YWx1ZSB9IDogdmFsdWUpO1xuXG4gICAgaWYgKCFtaW1lKSB7XG4gICAgICAgIHJldHVybiBhbm5vdGF0ZShwYXlsb2FkKTtcbiAgICB9XG5cbiAgICBpZiAoIXBheWxvYWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBhbm5vdGF0ZSh7fSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gaW50ZXJuYWxzLm9iamVjdChvcHRpb25zLCBwYXlsb2FkLCBtaW1lKTtcbiAgICAgICAgYW5ub3RhdGUob2JqZWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBhbm5vdGF0ZShwYXlsb2FkKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5waXBlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG5cbiAgICBmcm9tLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuXG4gICAgICAgIGZyb20udW5waXBlKHRvKTtcbiAgICAgICAgdG8uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZyb20ucGlwZSh0byk7XG59O1xuXG5cbmludGVybmFscy5Db3VudGVyID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW0uVHJhbnNmb3JtIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy5fbWF4Qnl0ZXMgPSBvcHRpb25zLm1heEJ5dGVzO1xuICAgIH1cblxuICAgIF90cmFuc2Zvcm0oY2h1bmssIGVuY29kaW5nLCBuZXh0KSB7XG5cbiAgICAgICAgdGhpcy5ieXRlcyA9IHRoaXMuYnl0ZXMgKyBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21heEJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPiB0aGlzLl9tYXhCeXRlcykge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV4dChCb29tLmVudGl0eVRvb0xhcmdlKCdQYXlsb2FkIGNvbnRlbnQgbGVuZ3RoIGdyZWF0ZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQ6ICcgKyB0aGlzLl9tYXhCeXRlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHQobnVsbCwgY2h1bmspO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5UZWFtID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2luaXQob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgdGhpcy53b3JrID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbWVldGluZ3MgPSBvcHRpb25zLm1lZXRpbmdzIHx8IDE7XG4gICAgICAgIHRoaXMuX21lZXRpbmdzID0gbWVldGluZ3M7XG4gICAgICAgIHRoaXMuX2NvdW50ID0gbWVldGluZ3M7XG4gICAgICAgIHRoaXMuX25vdGVzID0gW107XG4gICAgfVxuXG4gICAgYXR0ZW5kKG5vdGUpIHtcblxuICAgICAgICBpZiAobm90ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0KG5vdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbm90ZXMucHVzaChub3RlKTtcblxuICAgICAgICBpZiAoLS10aGlzLl9jb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodGhpcy5fbWVldGluZ3MgPT09IDEgPyB0aGlzLl9ub3Rlc1swXSA6IHRoaXMuX25vdGVzKTtcbiAgICB9XG5cbiAgICBhc3luYyByZWdyb3VwKG9wdGlvbnMpIHtcblxuICAgICAgICBhd2FpdCB0aGlzLndvcms7XG5cbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVybmFscy5UZWFtLCB7XG4gICAgX19lc01vZHVsZToge1xuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0sXG4gICAgZGVmYXVsdDoge1xuICAgICAgICB2YWx1ZTogaW50ZXJuYWxzLlRlYW1cbiAgICB9LFxuICAgIFRlYW13b3JrOiB7XG4gICAgICAgIHZhbHVlOiBpbnRlcm5hbHMuVGVhbVxuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XHJcblxyXG5cclxuY29uc3QgaW50ZXJuYWxzID0ge307XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUb3BvIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuXHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLm5vZGVzID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgYWRkKG5vZGVzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgICAgICAvLyBWYWxpZGF0ZSBydWxlc1xyXG5cclxuICAgICAgICBjb25zdCBiZWZvcmUgPSBbXS5jb25jYXQob3B0aW9ucy5iZWZvcmUgfHwgW10pO1xyXG4gICAgICAgIGNvbnN0IGFmdGVyID0gW10uY29uY2F0KG9wdGlvbnMuYWZ0ZXIgfHwgW10pO1xyXG4gICAgICAgIGNvbnN0IGdyb3VwID0gb3B0aW9ucy5ncm91cCB8fCAnPyc7XHJcbiAgICAgICAgY29uc3Qgc29ydCA9IG9wdGlvbnMuc29ydCB8fCAwOyAgICAgICAgICAgICAgICAgICAvLyBVc2VkIGZvciBtZXJnaW5nIG9ubHlcclxuXHJcbiAgICAgICAgQXNzZXJ0KCFiZWZvcmUuaW5jbHVkZXMoZ3JvdXApLCBgSXRlbSBjYW5ub3QgY29tZSBiZWZvcmUgaXRzZWxmOiAke2dyb3VwfWApO1xyXG4gICAgICAgIEFzc2VydCghYmVmb3JlLmluY2x1ZGVzKCc/JyksICdJdGVtIGNhbm5vdCBjb21lIGJlZm9yZSB1bmFzc29jaWF0ZWQgaXRlbXMnKTtcclxuICAgICAgICBBc3NlcnQoIWFmdGVyLmluY2x1ZGVzKGdyb3VwKSwgYEl0ZW0gY2Fubm90IGNvbWUgYWZ0ZXIgaXRzZWxmOiAke2dyb3VwfWApO1xyXG4gICAgICAgIEFzc2VydCghYWZ0ZXIuaW5jbHVkZXMoJz8nKSwgJ0l0ZW0gY2Fubm90IGNvbWUgYWZ0ZXIgdW5hc3NvY2lhdGVkIGl0ZW1zJyk7XHJcblxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcclxuICAgICAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICBzZXE6IHRoaXMuX2l0ZW1zLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHNvcnQsXHJcbiAgICAgICAgICAgICAgICBiZWZvcmUsXHJcbiAgICAgICAgICAgICAgICBhZnRlcixcclxuICAgICAgICAgICAgICAgIGdyb3VwLFxyXG4gICAgICAgICAgICAgICAgbm9kZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluc2VydCBldmVudFxyXG5cclxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3NvcnQoKTtcclxuICAgICAgICBBc3NlcnQodmFsaWQsICdpdGVtJywgZ3JvdXAgIT09ICc/JyA/IGBhZGRlZCBpbnRvIGdyb3VwICR7Z3JvdXB9YCA6ICcnLCAnY3JlYXRlZCBhIGRlcGVuZGVuY2llcyBlcnJvcicpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcclxuICAgIH1cclxuXHJcbiAgICBtZXJnZShvdGhlcnMpIHtcclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG90aGVycykpIHtcclxuICAgICAgICAgICAgb3RoZXJzID0gW290aGVyc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyIG9mIG90aGVycykge1xyXG4gICAgICAgICAgICBpZiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvdGhlci5faXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pKTsgICAgICAvLyBTaGFsbG93IGNsb25lZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTb3J0IGl0ZW1zXHJcblxyXG4gICAgICAgIHRoaXMuX2l0ZW1zLnNvcnQoaW50ZXJuYWxzLm1lcmdlU29ydCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pdGVtc1tpXS5zZXEgPSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLl9zb3J0KCk7XHJcbiAgICAgICAgQXNzZXJ0KHZhbGlkLCAnbWVyZ2UgY3JlYXRlZCBhIGRlcGVuZGVuY2llcyBlcnJvcicpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcztcclxuICAgIH1cclxuXHJcbiAgICBfc29ydCgpIHtcclxuXHJcbiAgICAgICAgLy8gQ29uc3RydWN0IGdyYXBoXHJcblxyXG4gICAgICAgIGNvbnN0IGdyYXBoID0ge307XHJcbiAgICAgICAgY29uc3QgZ3JhcGhBZnRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAgICAgICAgICAgIC8vIEEgcHJvdG90eXBlIGNhbiBidW5nbGUgbG9va3VwcyB3LyBmYWxzZSBwb3NpdGl2ZXNcclxuICAgICAgICBjb25zdCBncm91cHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VxID0gaXRlbS5zZXE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVW5pcXVlIGFjcm9zcyBhbGwgaXRlbXNcclxuICAgICAgICAgICAgY29uc3QgZ3JvdXAgPSBpdGVtLmdyb3VwO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIEdyb3Vwc1xyXG5cclxuICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IGdyb3Vwc1tncm91cF0gfHwgW107XHJcbiAgICAgICAgICAgIGdyb3Vwc1tncm91cF0ucHVzaChzZXEpO1xyXG5cclxuICAgICAgICAgICAgLy8gQnVpbGQgaW50ZXJtZWRpYXJ5IGdyYXBoIHVzaW5nICdiZWZvcmUnXHJcblxyXG4gICAgICAgICAgICBncmFwaFtzZXFdID0gaXRlbS5iZWZvcmU7XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCBzZWNvbmQgaW50ZXJtZWRpYXJ5IGdyYXBoIHdpdGggJ2FmdGVyJ1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBhZnRlciBvZiBpdGVtLmFmdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaEFmdGVyc1thZnRlcl0gPSBncmFwaEFmdGVyc1thZnRlcl0gfHwgW107XHJcbiAgICAgICAgICAgICAgICBncmFwaEFmdGVyc1thZnRlcl0ucHVzaChzZXEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHBhbmQgaW50ZXJtZWRpYXJ5IGdyYXBoXHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBpbiBncmFwaCkge1xyXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZEdyb3VwcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBncmFwaE5vZGVJdGVtIGluIGdyYXBoW25vZGVdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IGdyYXBoW25vZGVdW2dyYXBoTm9kZUl0ZW1dO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IGdyb3Vwc1tncm91cF0gfHwgW107XHJcbiAgICAgICAgICAgICAgICBleHBhbmRlZEdyb3Vwcy5wdXNoKC4uLmdyb3Vwc1tncm91cF0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBncmFwaFtub2RlXSA9IGV4cGFuZGVkR3JvdXBzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTWVyZ2UgaW50ZXJtZWRpYXJ5IGdyYXBoIHVzaW5nIGdyYXBoQWZ0ZXJzIGludG8gZmluYWwgZ3JhcGhcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBncm91cCBpbiBncmFwaEFmdGVycykge1xyXG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2dyb3VwXSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGdyb3Vwc1tncm91cF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaFtub2RlXS5wdXNoKC4uLmdyYXBoQWZ0ZXJzW2dyb3VwXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbXBpbGUgYW5jZXN0b3JzXHJcblxyXG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IHt9O1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBpbiBncmFwaCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoW25vZGVdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBhbmNlc3RvcnNbY2hpbGRdID0gYW5jZXN0b3JzW2NoaWxkXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tjaGlsZF0ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVG9wbyBzb3J0XHJcblxyXG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSB7fTtcclxuICAgICAgICBjb25zdCBzb3J0ZWQgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraSkgeyAgICAgICAgICAvLyBMb29waW5nIHRocm91Z2ggaXRlbS5zZXEgdmFsdWVzIG91dCBvZiBvcmRlclxyXG4gICAgICAgICAgICBsZXQgbmV4dCA9IGk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5faXRlbXMubGVuZ3RoOyArK2opIHsgIC8vIEFzIGFib3ZlLCB0aGVzZSBhcmUgaXRlbS5zZXEgdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbal0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFuY2VzdG9yc1tqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvcnNbal0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNlZUNvdW50ID0gYW5jZXN0b3JzW2pdLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VlbkNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNob3VsZFNlZUNvdW50OyArK2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2l0ZWRbYW5jZXN0b3JzW2pdW2tdXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytzZWVuQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuQ291bnQgPT09IHNob3VsZFNlZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpdGVkW25leHRdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHNvcnRlZC5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc29ydGVkLmxlbmd0aCAhPT0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNlcUluZGV4ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgICAgIHNlcUluZGV4W2l0ZW0uc2VxXSA9IGl0ZW07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBzb3J0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkSXRlbSA9IHNlcUluZGV4W3ZhbHVlXTtcclxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHNvcnRlZEl0ZW0ubm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goc29ydGVkSXRlbSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5pbnRlcm5hbHMubWVyZ2VTb3J0ID0gKGEsIGIpID0+IHtcclxuXHJcbiAgICByZXR1cm4gYS5zb3J0ID09PSBiLnNvcnQgPyAwIDogKGEuc29ydCA8IGIuc29ydCA/IC0xIDogMSk7XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuVmlzZSA9IGZ1bmN0aW9uIChjaHVua3MpIHtcblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jaHVua3MgPSBbXTtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuXG4gICAgaWYgKGNodW5rcykge1xuICAgICAgICBjaHVua3MgPSBbXS5jb25jYXQoY2h1bmtzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChjaHVua3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuVmlzZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaykge1xuXG4gICAgSG9lay5hc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSwgJ0NodW5rIG11c3QgYmUgYSBidWZmZXInKTtcblxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICBsZW5ndGg6IGNodW5rLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0OiB0aGlzLmxlbmd0aCArIHRoaXMuX29mZnNldCxcbiAgICAgICAgaW5kZXg6IHRoaXMuX2NodW5rcy5sZW5ndGhcbiAgICB9O1xuXG4gICAgdGhpcy5fY2h1bmtzLnB1c2goaXRlbSk7XG4gICAgdGhpcy5sZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xufTtcblxuXG5pbnRlcm5hbHMuVmlzZS5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgcHJldk9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5fY2h1bmtBdChsZW5ndGgpO1xuXG4gICAgbGV0IGRyb3BUbyA9IHRoaXMuX2NodW5rcy5sZW5ndGg7XG4gICAgdGhpcy5fb2Zmc2V0ID0gMDtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICAgIGRyb3BUbyA9IGl0ZW0uY2h1bmsuaW5kZXg7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IGl0ZW0ub2Zmc2V0O1xuICAgIH1cblxuICAgIC8vIERyb3AgbG93ZXIgY2h1bmtzXG5cbiAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3BUbzsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChpID09PSAwICYmXG4gICAgICAgICAgICBwcmV2T2Zmc2V0KSB7XG5cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rLmRhdGEuc2xpY2UocHJldk9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmsuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb2Zmc2V0KSB7XG4gICAgICAgIGNodW5rcy5wdXNoKGl0ZW0uY2h1bmsuZGF0YS5zbGljZShkcm9wVG8gPyAwIDogcHJldk9mZnNldCwgdGhpcy5fb2Zmc2V0KSk7XG4gICAgfVxuXG4gICAgLy8gUmVjYWxjdWxhdGUgZXhpc3RpbmcgY2h1bmtzXG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbaV07XG4gICAgICAgIGNodW5rLm9mZnNldCA9IHRoaXMubGVuZ3RoLFxuICAgICAgICBjaHVuay5pbmRleCA9IGk7XG5cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoIC09IHRoaXMuX29mZnNldDtcblxuICAgIHJldHVybiBjaHVua3M7XG59O1xuXG5cbmludGVybmFscy5WaXNlLnByb3RvdHlwZS5hdCA9IGludGVybmFscy5WaXNlLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAocG9zKSB7XG5cbiAgICBjb25zdCBpdGVtID0gdGhpcy5fY2h1bmtBdChwb3MpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaHVuay5kYXRhW2l0ZW0ub2Zmc2V0XSA6IHVuZGVmaW5lZDtcbn07XG5cblxuaW50ZXJuYWxzLlZpc2UucHJvdG90eXBlLl9jaHVua0F0ID0gZnVuY3Rpb24gKHBvcykge1xuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcG9zID0gcG9zICsgdGhpcy5fb2Zmc2V0O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbaV07XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHBvcyAtIGNodW5rLm9mZnNldDtcbiAgICAgICAgaWYgKG9mZnNldCA8IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY2h1bmssIG9mZnNldCB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5WaXNlLnByb3RvdHlwZS5jaHVua3MgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzW2ldO1xuICAgICAgICBpZiAoaSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0KSB7XG5cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rLmRhdGEuc2xpY2UodGhpcy5fb2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuay5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaHVua3M7XG59O1xuXG5cbmludGVybmFscy5WaXNlLnByb3RvdHlwZS5zdGFydHNXaXRoID0gZnVuY3Rpb24gKHZhbHVlLCBwb3MsIGxlbmd0aCkge1xuXG4gICAgcG9zID0gcG9zIHx8IDA7XG5cbiAgICBsZW5ndGggPSBsZW5ndGggPyBNYXRoLm1pbih2YWx1ZS5sZW5ndGgsIGxlbmd0aCkgOiB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKHBvcyArIGxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZW5vdWdoIGxlbmd0aCB0byBmaXQgdmFsdWVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY2h1bmtBdChwb3MpO1xuICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBqID0gc3RhcnQuY2h1bmsuaW5kZXg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGogPCB0aGlzLl9jaHVua3MubGVuZ3RoICYmIGkgPCBsZW5ndGg7ICsraikge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tqXTtcblxuICAgICAgICBsZXQgayA9IChqID09PSBzdGFydC5jaHVuay5pbmRleCA/IHN0YXJ0Lm9mZnNldCA6IDApO1xuICAgICAgICBmb3IgKDsgayA8IGNodW5rLmxlbmd0aCAmJiBpIDwgbGVuZ3RoOyArK2ssICsraSkge1xuICAgICAgICAgICAgaWYgKGNodW5rLmRhdGFba10gIT09IHZhbHVlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IEh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBIdHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgWmxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdXJuZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdXJuZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgUGF5bG9hZCA9IHJlcXVpcmUoJy4vcGF5bG9hZCcpO1xuY29uc3QgUmVjb3JkZXIgPSByZXF1aXJlKCcuL3JlY29yZGVyJyk7XG5jb25zdCBUYXAgPSByZXF1aXJlKCcuL3RhcCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBqc29uUmVnZXg6IC9eYXBwbGljYXRpb25cXC8oW2EtejAtOS5dKlsrLV1qc29ufGpzb24pJC8sXG4gICAgc2hhbGxvd09wdGlvbnM6IFsnYWdlbnQnLCAnYWdlbnRzJywgJ2JlZm9yZVJlZGlyZWN0JywgJ2Rvd25zdHJlYW1SZXMnLCAncGF5bG9hZCcsICdyZWRpcmVjdGVkJ11cbn07XG5cblxuLy8gTmV3IGluc3RhbmNlIGlzIGV4cG9ydGVkIGFzIG1vZHVsZS5leHBvcnRzXG5cbmludGVybmFscy5DbGllbnQgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG5cbiAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5hZ2VudHMgfHwgKG9wdGlvbnMuYWdlbnRzLmh0dHBzICYmIG9wdGlvbnMuYWdlbnRzLmh0dHAgJiYgb3B0aW9ucy5hZ2VudHMuaHR0cHNBbGxvd1VuYXV0aG9yaXplZCksICdPcHRpb24gYWdlbnRzIG11c3QgaW5jbHVkZSBcImh0dHBcIiwgXCJodHRwc1wiLCBhbmQgXCJodHRwc0FsbG93VW5hdXRob3JpemVkXCInKTtcblxuICAgIHRoaXMuX2RlZmF1bHRzID0gSG9lay5jbG9uZShvcHRpb25zLCB7IHNoYWxsb3c6IGludGVybmFscy5zaGFsbG93T3B0aW9ucyB9KTtcblxuICAgIHRoaXMuYWdlbnRzID0gdGhpcy5fZGVmYXVsdHMuYWdlbnRzIHx8IHtcbiAgICAgICAgaHR0cHM6IG5ldyBIdHRwcy5BZ2VudCh7IG1heFNvY2tldHM6IEluZmluaXR5IH0pLFxuICAgICAgICBodHRwOiBuZXcgSHR0cC5BZ2VudCh7IG1heFNvY2tldHM6IEluZmluaXR5IH0pLFxuICAgICAgICBodHRwc0FsbG93VW5hdXRob3JpemVkOiBuZXcgSHR0cHMuQWdlbnQoeyBtYXhTb2NrZXRzOiBJbmZpbml0eSwgcmVqZWN0VW5hdXRob3JpemVkOiBmYWxzZSB9KVxuICAgIH07XG5cbiAgICBpZiAoIW9wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudHMuRXZlbnRFbWl0dGVyKCk7XG4gICAgdGhpcy5fZW1pdCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdCguLi5hcmdzKTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuQ2xpZW50LnByb3RvdHlwZS5kZWZhdWx0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBIb2VrLmFzc2VydChvcHRpb25zICYmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpLCAnb3B0aW9ucyBtdXN0IGJlIHByb3ZpZGVkIHRvIGRlZmF1bHRzJyk7XG5cbiAgICBvcHRpb25zID0gSG9lay5hcHBseVRvRGVmYXVsdHModGhpcy5fZGVmYXVsdHMsIG9wdGlvbnMsIHsgc2hhbGxvdzogaW50ZXJuYWxzLnNoYWxsb3dPcHRpb25zIH0pO1xuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkNsaWVudChvcHRpb25zKTtcbn07XG5cblxuLy8gYmFzZVVybCBuZWVkcyB0byBlbmQgaW4gYSB0cmFpbGluZyAvIGlmIGl0IGNvbnRhaW5zIHBhdGhzIHRoYXQgbmVlZCB0byBiZSBwcmVzZXJ2ZWRcbmludGVybmFscy5yZXNvbHZlVXJsID0gZnVuY3Rpb24gKGJhc2VVcmwsIHBhdGgpIHtcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgICByZXR1cm4gYmFzZVVybDtcbiAgICB9XG5cbiAgICAvLyBXaWxsIGRlZmF1bHQgdG8gcGF0aCBpZiBpdCdzIG5vdCBhIHJlbGF0aXZlIFVSTFxuICAgIGNvbnN0IHVybCA9IG5ldyBVcmwuVVJMKHBhdGgsIGJhc2VVcmwpO1xuICAgIHJldHVybiBVcmwuZm9ybWF0KHVybCk7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCB1cmwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKHRoaXMuX2RlZmF1bHRzLCBvcHRpb25zLCB7IHNoYWxsb3c6IGludGVybmFscy5zaGFsbG93T3B0aW9ucyB9KTtcblxuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLnBheWxvYWQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5wYXlsb2FkID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9ucy5wYXlsb2FkID09PSAnb2JqZWN0JywgJ29wdGlvbnMucGF5bG9hZCBtdXN0IGJlIGEgc3RyaW5nLCBhIEJ1ZmZlciwgYSBTdHJlYW0sIG9yIGFuIE9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCgob3B0aW9ucy5hZ2VudCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuYWdlbnQgPT09IG51bGwpIHx8ICh0eXBlb2Ygb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgIT09ICdib29sZWFuJyksICdvcHRpb25zLmFnZW50IGNhbm5vdCBiZSBzZXQgdG8gYW4gQWdlbnQgYXQgdGhlIHNhbWUgdGltZSBhcyBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCBpcyBzZXQnKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5iZWZvcmVSZWRpcmVjdCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuYmVmb3JlUmVkaXJlY3QgPT09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMuYmVmb3JlUmVkaXJlY3QgPT09ICdmdW5jdGlvbicsICdvcHRpb25zLmJlZm9yZVJlZGlyZWN0IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLnJlZGlyZWN0ZWQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnJlZGlyZWN0ZWQgPT09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMucmVkaXJlY3RlZCA9PT0gJ2Z1bmN0aW9uJywgJ29wdGlvbnMucmVkaXJlY3RlZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5ndW56aXAgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5ndW56aXAgPT09ICdib29sZWFuJyB8fCBvcHRpb25zLmd1bnppcCA9PT0gJ2ZvcmNlJywgJ29wdGlvbnMuZ3VuemlwIG11c3QgYmUgYSBib29sZWFuIG9yIFwiZm9yY2VcIicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYmVmb3JlUmVkaXJlY3QgPSBvcHRpb25zLmJlZm9yZVJlZGlyZWN0IHx8ICgocmVkaXJlY3RNZXRob2QsIHN0YXR1c0NvZGUsIGxvY2F0aW9uLCByZXNIZWFkZXJzLCByZWRpcmVjdE9wdGlvbnMsIG5leHQpID0+IG5leHQoKSk7XG5cbiAgICBpZiAob3B0aW9ucy5iYXNlVXJsKSB7XG4gICAgICAgIHVybCA9IGludGVybmFscy5yZXNvbHZlVXJsKG9wdGlvbnMuYmFzZVVybCwgdXJsKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuYmFzZVVybDtcbiAgICB9XG5cbiAgICBjb25zdCByZWxheSA9IHt9O1xuICAgIGNvbnN0IHJlcSA9IHRoaXMuX3JlcXVlc3QobWV0aG9kLCB1cmwsIG9wdGlvbnMsIHJlbGF5KTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIHJlbGF5LmNhbGxiYWNrID0gKGVyciwgcmVzKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHByb21pc2UucmVxID0gcmVxO1xuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuXG5pbnRlcm5hbHMuQ2xpZW50LnByb3RvdHlwZS5fcmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgb3B0aW9ucywgcmVsYXksIF90cmFjZSkge1xuXG4gICAgY29uc3QgdXJpID0ge307XG4gICAgaWYgKG9wdGlvbnMuc29ja2V0UGF0aCkge1xuICAgICAgICB1cmkuc29ja2V0UGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcblxuICAgICAgICBjb25zdCBwYXJzZWRVcmkgPSBuZXcgVXJsLlVSTCh1cmwsIGB1bml4Oi8vJHtvcHRpb25zLnNvY2tldFBhdGh9YCk7XG4gICAgICAgIGludGVybmFscy5hcHBseVVybFRvT3B0aW9ucyh1cmksIHtcbiAgICAgICAgICAgIC8vIFRoZSBob3N0IG11c3QgYmUgZW1wdHkgYWNjb3JkaW5nIHRvIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2I3NlY3Rpb24tMTQuMjNcbiAgICAgICAgICAgIGhvc3Q6ICcnLFxuICAgICAgICAgICAgcHJvdG9jb2w6ICdodHRwOicsXG4gICAgICAgICAgICBoYXNoOiBwYXJzZWRVcmkuaGFzaCxcbiAgICAgICAgICAgIHNlYXJjaDogcGFyc2VkVXJpLnNlYXJjaCxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogcGFyc2VkVXJpLnNlYXJjaFBhcmFtcyxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBwYXJzZWRVcmkucGF0aG5hbWUsXG4gICAgICAgICAgICBocmVmOiBwYXJzZWRVcmkuaHJlZlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVyaS5zZXRIb3N0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHBhcnNlZFVyaSA9IG5ldyBVcmwuVVJMKHVybCk7XG4gICAgICAgIGludGVybmFscy5hcHBseVVybFRvT3B0aW9ucyh1cmksIHBhcnNlZFVyaSk7XG4gICAgfVxuXG4gICAgdXJpLm1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHVyaS5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuXG4gICAgY29uc3QgaG9zdEhlYWRlciA9IGludGVybmFscy5maW5kSGVhZGVyKCdob3N0JywgdXJpLmhlYWRlcnMpO1xuXG4gICAgaWYgKCFob3N0SGVhZGVyKSB7XG4gICAgICAgIHVyaS5oZWFkZXJzLmhvc3QgPSB1cmkuaG9zdDtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNDb250ZW50TGVuZ3RoID0gaW50ZXJuYWxzLmZpbmRIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJywgdXJpLmhlYWRlcnMpICE9PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAob3B0aW9ucy5wYXlsb2FkICYmIHR5cGVvZiBvcHRpb25zLnBheWxvYWQgPT09ICdvYmplY3QnICYmICEob3B0aW9ucy5wYXlsb2FkIGluc3RhbmNlb2YgU3RyZWFtKSAmJiAhQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucGF5bG9hZCkpIHtcbiAgICAgICAgb3B0aW9ucy5wYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5wYXlsb2FkKTtcbiAgICAgICAgaWYgKCFpbnRlcm5hbHMuZmluZEhlYWRlcignY29udGVudC10eXBlJywgdXJpLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB1cmkuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ndW56aXAgJiZcbiAgICAgICAgaW50ZXJuYWxzLmZpbmRIZWFkZXIoJ2FjY2VwdC1lbmNvZGluZycsIHVyaS5oZWFkZXJzKSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgdXJpLmhlYWRlcnNbJ2FjY2VwdC1lbmNvZGluZyddID0gJ2d6aXAnO1xuICAgIH1cblxuICAgIGNvbnN0IHBheWxvYWRTdXBwb3J0ZWQgPSAodXJpLm1ldGhvZCAhPT0gJ0dFVCcgJiYgdXJpLm1ldGhvZCAhPT0gJ0hFQUQnICYmIG9wdGlvbnMucGF5bG9hZCAhPT0gbnVsbCAmJiBvcHRpb25zLnBheWxvYWQgIT09IHVuZGVmaW5lZCk7XG4gICAgaWYgKHBheWxvYWRTdXBwb3J0ZWQgJiZcbiAgICAgICAgKHR5cGVvZiBvcHRpb25zLnBheWxvYWQgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnBheWxvYWQpKSAmJlxuICAgICAgICAoIWhhc0NvbnRlbnRMZW5ndGgpKSB7XG5cbiAgICAgICAgdXJpLmhlYWRlcnMgPSBIb2VrLmNsb25lKHVyaS5oZWFkZXJzKTtcbiAgICAgICAgdXJpLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5wYXlsb2FkKSA/IG9wdGlvbnMucGF5bG9hZC5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aChvcHRpb25zLnBheWxvYWQpO1xuICAgIH1cblxuICAgIGxldCByZWRpcmVjdHMgPSAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncmVkaXJlY3RzJykgPyBvcHRpb25zLnJlZGlyZWN0cyA6IGZhbHNlKTsgICAgICAvLyBOZWVkZWQgdG8gYWxsb3cgMCBhcyB2YWxpZCB2YWx1ZSB3aGVuIHBhc3NlZCByZWN1cnNpdmVseVxuXG4gICAgX3RyYWNlID0gKF90cmFjZSB8fCBbXSk7XG4gICAgX3RyYWNlLnB1c2goeyBtZXRob2Q6IHVyaS5tZXRob2QsIHVybCB9KTtcblxuICAgIGNvbnN0IGNsaWVudCA9ICh1cmkucHJvdG9jb2wgPT09ICdodHRwczonID8gSHR0cHMgOiBIdHRwKTtcblxuICAgIGlmIChvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gdW5kZWZpbmVkICYmIHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgdXJpLmFnZW50ID0gb3B0aW9ucy5yZWplY3RVbmF1dGhvcml6ZWQgPyB0aGlzLmFnZW50cy5odHRwcyA6IHRoaXMuYWdlbnRzLmh0dHBzQWxsb3dVbmF1dGhvcml6ZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuYWdlbnQgfHwgb3B0aW9ucy5hZ2VudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdXJpLmFnZW50ID0gb3B0aW9ucy5hZ2VudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVyaS5hZ2VudCA9IHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyB0aGlzLmFnZW50cy5odHRwcyA6IHRoaXMuYWdlbnRzLmh0dHA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2VjdXJlUHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmkuc2VjdXJlUHJvdG9jb2wgPSBvcHRpb25zLnNlY3VyZVByb3RvY29sO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNpcGhlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cmkuY2lwaGVycyA9IG9wdGlvbnMuY2lwaGVycztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW1pdCkge1xuICAgICAgICB0aGlzLl9lbWl0KCdwcmVSZXF1ZXN0JywgdXJpLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVxID0gY2xpZW50LnJlcXVlc3QodXJpKTtcblxuICAgIGlmICh0aGlzLl9lbWl0KSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3JlcXVlc3QnLCByZXEpO1xuICAgIH1cblxuICAgIGxldCBzaGFkb3cgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIGNvcHkgb2YgdGhlIHN0cmVhbWVkIHJlcXVlc3QgcGF5bG9hZCB3aGVuIHJlZGlyZWN0cyBhcmUgZW5hYmxlZFxuICAgIGxldCB0aW1lb3V0SWQ7XG5cbiAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuXG4gICAgICAgIGVyci50cmFjZSA9IF90cmFjZTtcbiAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UoQm9vbS5iYWRHYXRld2F5KCdDbGllbnQgcmVxdWVzdCBlcnJvcicsIGVycikpO1xuICAgIH07XG5cbiAgICByZXEub25jZSgnZXJyb3InLCBvbkVycm9yKTtcblxuICAgIGNvbnN0IG9uUmVzcG9uc2UgPSAocmVzKSA9PiB7XG5cbiAgICAgICAgLy8gUGFzcy10aHJvdWdoIHJlc3BvbnNlXG5cbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICBjb25zdCByZWRpcmVjdE1ldGhvZCA9IGludGVybmFscy5yZWRpcmVjdE1ldGhvZChzdGF0dXNDb2RlLCB1cmkubWV0aG9kLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAocmVkaXJlY3RzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgIXJlZGlyZWN0TWV0aG9kKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hPbmNlKG51bGwsIHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWRpcmVjdGlvblxuXG4gICAgICAgIHJlcy5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKHJlZGlyZWN0cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UoQm9vbS5iYWRHYXRld2F5KCdNYXhpbXVtIHJlZGlyZWN0aW9ucyByZWFjaGVkJywgX3RyYWNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKCFsb2NhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UoQm9vbS5iYWRHYXRld2F5KCdSZWNlaXZlZCByZWRpcmVjdGlvbiB3aXRob3V0IGxvY2F0aW9uJywgX3RyYWNlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eaHR0cHM/Oi9pLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IFVybC5yZXNvbHZlKHVyaS5ocmVmLCBsb2NhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWRpcmVjdE9wdGlvbnMgPSBIb2VrLmNsb25lKG9wdGlvbnMsIHsgc2hhbGxvdzogaW50ZXJuYWxzLnNoYWxsb3dPcHRpb25zIH0pO1xuICAgICAgICByZWRpcmVjdE9wdGlvbnMucGF5bG9hZCA9IHNoYWRvdyB8fCBvcHRpb25zLnBheWxvYWQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hhZG93IG11c3QgYmUgcmVhZHkgYXQgdGhpcyBwb2ludCBpZiBzZXRcbiAgICAgICAgcmVkaXJlY3RPcHRpb25zLnJlZGlyZWN0cyA9IC0tcmVkaXJlY3RzO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zLmJlZm9yZVJlZGlyZWN0KHJlZGlyZWN0TWV0aG9kLCBzdGF0dXNDb2RlLCBsb2NhdGlvbiwgcmVzLmhlYWRlcnMsIHJlZGlyZWN0T3B0aW9ucywgKCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCByZWRpcmVjdFJlcSA9IHRoaXMuX3JlcXVlc3QocmVkaXJlY3RNZXRob2QsIGxvY2F0aW9uLCByZWRpcmVjdE9wdGlvbnMsIHsgY2FsbGJhY2s6IGZpbmlzaE9uY2UgfSwgX3RyYWNlKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVkaXJlY3RlZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVkaXJlY3RlZChzdGF0dXNDb2RlLCBsb2NhdGlvbiwgcmVkaXJlY3RSZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gUmVnaXN0ZXIgaGFuZGxlcnNcblxuICAgIGNvbnN0IGZpbmlzaCA9IChlcnIsIHJlcykgPT4ge1xuXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxLmFib3J0ID0gX2Fib3J0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBmdW5jdGlvbiB0byByZWxlYXNlIG1lbW9yeVxuICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoJ3Jlc3BvbnNlJywgb25SZXNwb25zZSk7XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgcmVxLm9uKCdlcnJvcicsIEhvZWsuaWdub3JlKTtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgICBpZiAodGhpcy5fZW1pdCkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgncmVzcG9uc2UnLCBlcnIsIHsgcmVxLCByZXMsIHN0YXJ0LCB1cmkgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVsYXkuY2FsbGJhY2soZXJyLCByZXMpO1xuICAgIH07XG5cbiAgICBjb25zdCBmaW5pc2hPbmNlID0gSG9lay5vbmNlKGZpbmlzaCk7XG5cbiAgICByZXEub25jZSgncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcblxuICAgIGlmIChvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiBmaW5pc2hPbmNlKEJvb20uZ2F0ZXdheVRpbWVvdXQoJ0NsaWVudCByZXF1ZXN0IHRpbWVvdXQnKSk7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIGFib3J0IG1ldGhvZCB0byBkZXRlY3QgZWFybHkgYWJvcnRzXG5cbiAgICBjb25zdCBfYWJvcnQgPSByZXEuYWJvcnQ7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgICByZXEuYWJvcnQgPSAoKSA9PiB7XG5cbiAgICAgICAgaWYgKCFhYm9ydGVkICYmICFyZXEucmVzICYmICFyZXEuc29ja2V0KSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIEZha2UgYW4gRUNPTk5SRVNFVCBlcnJvclxuXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ3NvY2tldCBoYW5nIHVwJyk7XG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdFQ09OTlJFU0VUJztcbiAgICAgICAgICAgICAgICBmaW5pc2hPbmNlKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBfYWJvcnQuY2FsbChyZXEpO1xuICAgIH07XG5cbiAgICAvLyBXcml0ZSBwYXlsb2FkXG5cbiAgICBpZiAocGF5bG9hZFN1cHBvcnRlZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5wYXlsb2FkIGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgICAgICBsZXQgc3RyZWFtID0gb3B0aW9ucy5wYXlsb2FkO1xuXG4gICAgICAgICAgICBpZiAocmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdG9yID0gbmV3IFRhcCgpO1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5vbmNlKCdmaW5pc2gnLCAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2hhZG93ID0gY29sbGVjdG9yLmNvbGxlY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHN0cmVhbSA9IG9wdGlvbnMucGF5bG9hZC5waXBlKGNvbGxlY3Rvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGludGVybmFscy5kZWZlclBpcGVVbnRpbFNvY2tldENvbm5lY3RzKHJlcSwgc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXE7XG4gICAgICAgIH1cblxuICAgICAgICByZXEud3JpdGUob3B0aW9ucy5wYXlsb2FkKTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGl6ZSByZXF1ZXN0XG5cbiAgICByZXEuZW5kKCk7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5cblxuaW50ZXJuYWxzLmRlZmVyUGlwZVVudGlsU29ja2V0Q29ubmVjdHMgPSBmdW5jdGlvbiAocmVxLCBzdHJlYW0pIHtcblxuICAgIGNvbnN0IG9uU29ja2V0ID0gKHNvY2tldCkgPT4ge1xuXG4gICAgICAgIGlmICghc29ja2V0LmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBvblNvY2tldENvbm5lY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvY2tldC5vbmNlKCdjb25uZWN0Jywgb25Tb2NrZXRDb25uZWN0KTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Tb2NrZXRDb25uZWN0ID0gKCkgPT4ge1xuXG4gICAgICAgIHN0cmVhbS5waXBlKHJlcSk7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvblN0cmVhbUVycm9yKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25TdHJlYW1FcnJvciA9IChlcnIpID0+IHtcblxuICAgICAgICByZXEuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH07XG5cbiAgICByZXEub25jZSgnc29ja2V0Jywgb25Tb2NrZXQpO1xuICAgIHN0cmVhbS5vbignZXJyb3InLCBvblN0cmVhbUVycm9yKTtcbn07XG5cblxuaW50ZXJuYWxzLnJlZGlyZWN0TWV0aG9kID0gZnVuY3Rpb24gKGNvZGUsIG1ldGhvZCwgb3B0aW9ucykge1xuXG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgMzAxOlxuICAgICAgICBjYXNlIDMwMjpcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnJlZGlyZWN0TWV0aG9kIHx8IG1ldGhvZDtcblxuICAgICAgICBjYXNlIDMwMzpcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZGlyZWN0MzAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdHRVQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDMwNzpcbiAgICAgICAgY2FzZSAzMDg6XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMuQ2xpZW50LnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHJlcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIHRoaXMuX3JlYWQocmVzLCBvcHRpb25zLCAoZXJyLCBwYXlsb2FkKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUocGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuQ2xpZW50LnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChyZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cbiAgICBvcHRpb25zID0gSG9lay5hcHBseVRvRGVmYXVsdHModGhpcy5fZGVmYXVsdHMsIG9wdGlvbnMsIHsgc2hhbGxvdzogaW50ZXJuYWxzLnNoYWxsb3dPcHRpb25zIH0pO1xuXG4gICAgLy8gRmluaXNoIG9uY2VcblxuICAgIGxldCBjbGllbnRUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgY29uc3QgZmluaXNoID0gKGVyciwgYnVmZmVyKSA9PiB7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KGNsaWVudFRpbWVvdXRJZCk7XG4gICAgICAgIHJlYWRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvblJlYWRlckVycm9yKTtcbiAgICAgICAgcmVhZGVyLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvblJlYWRlckZpbmlzaCk7XG4gICAgICAgIHJlcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvblJlc0Vycm9yKTtcbiAgICAgICAgcmVzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uUmVzQWJvcnRlZCk7XG4gICAgICAgIHJlcy5yZW1vdmVMaXN0ZW5lcignYWJvcnRlZCcsIG9uUmVzQWJvcnRlZCk7XG4gICAgICAgIHJlcy5vbignZXJyb3InLCBIb2VrLmlnbm9yZSk7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSBKU09OXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuanNvbiA9PT0gJ2ZvcmNlJykge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy50cnlQYXJzZUJ1ZmZlcihidWZmZXIsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vZGUgaXMgXCJzbWFydFwiLCBcInN0cmljdFwiIG9yIHRydWVcblxuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IChyZXMuaGVhZGVycyAmJiBpbnRlcm5hbHMuZmluZEhlYWRlcignY29udGVudC10eXBlJywgcmVzLmhlYWRlcnMpKSB8fCAnJztcbiAgICAgICAgY29uc3QgbWltZSA9IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKCFpbnRlcm5hbHMuanNvblJlZ2V4LnRlc3QobWltZSkpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmpzb24gPT09ICdzdHJpY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJvb20ubm90QWNjZXB0YWJsZSgnVGhlIGNvbnRlbnQtdHlwZSBpcyBub3QgSlNPTiBjb21wYXRpYmxlJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYnVmZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMudHJ5UGFyc2VCdWZmZXIoYnVmZmVyLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbmlzaE9uY2UgPSBIb2VrLm9uY2UoZmluaXNoKTtcblxuICAgIGNvbnN0IGNsaWVudFRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgaWYgKGNsaWVudFRpbWVvdXQgJiZcbiAgICAgICAgY2xpZW50VGltZW91dCA+IDApIHtcblxuICAgICAgICBjbGllbnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgZmluaXNoT25jZShCb29tLmNsaWVudFRpbWVvdXQoKSk7XG4gICAgICAgIH0sIGNsaWVudFRpbWVvdXQpO1xuICAgIH1cblxuICAgIC8vIEhhbmRlciBlcnJvcnNcblxuICAgIGNvbnN0IG9uUmVzRXJyb3IgPSAoZXJyKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UoZXJyLmlzQm9vbSA/IGVyciA6IEJvb20uaW50ZXJuYWwoJ1BheWxvYWQgc3RyZWFtIGVycm9yJywgZXJyKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uUmVzQWJvcnRlZCA9ICgpID0+IHtcblxuICAgICAgICAvLyBXb3JrYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzIwNjExXG4gICAgICAgIC8vIFRoaXMgaXMgY292ZXJlZCBpbiBub2RlIDEwXG4gICAgICAgIC8qICRsYWI6Y292ZXJhZ2U6b2ZmJCAqL1xuICAgICAgICBpZiAocmVzLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogJGxhYjpjb3ZlcmFnZTpvbiQgKi9cblxuICAgICAgICByZXR1cm4gZmluaXNoT25jZShCb29tLmludGVybmFsKCdQYXlsb2FkIHN0cmVhbSBjbG9zZWQgcHJlbWF0dXJlbHknKSk7XG4gICAgfTtcblxuICAgIHJlcy5vbmNlKCdlcnJvcicsIG9uUmVzRXJyb3IpO1xuICAgIHJlcy5vbmNlKCdjbG9zZScsIG9uUmVzQWJvcnRlZCk7XG4gICAgcmVzLm9uY2UoJ2Fib3J0ZWQnLCBvblJlc0Fib3J0ZWQpO1xuXG4gICAgLy8gUmVhZCBwYXlsb2FkXG5cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVjb3JkZXIoeyBtYXhCeXRlczogb3B0aW9ucy5tYXhCeXRlcyB9KTtcblxuICAgIGNvbnN0IG9uUmVhZGVyRXJyb3IgPSAoZXJyKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlcy5kZXN0cm95KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHWmlwIHN0cmVhbSBoYXMgbm8gZGVzdHJveSgpIG1ldGhvZFxuICAgICAgICAgICAgcmVzLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaW5pc2hPbmNlKGVycik7XG4gICAgfTtcblxuICAgIHJlYWRlci5vbmNlKCdlcnJvcicsIG9uUmVhZGVyRXJyb3IpO1xuXG4gICAgY29uc3Qgb25SZWFkZXJGaW5pc2ggPSAoKSA9PiB7XG5cbiAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UobnVsbCwgcmVhZGVyLmNvbGxlY3QoKSk7XG4gICAgfTtcblxuICAgIHJlYWRlci5vbmNlKCdmaW5pc2gnLCBvblJlYWRlckZpbmlzaCk7XG5cbiAgICBpZiAob3B0aW9ucy5ndW56aXApIHtcbiAgICAgICAgY29uc3QgY29udGVudEVuY29kaW5nID0gb3B0aW9ucy5ndW56aXAgPT09ICdmb3JjZScgP1xuICAgICAgICAgICAgJ2d6aXAnIDpcbiAgICAgICAgICAgIChyZXMuaGVhZGVycyAmJiBpbnRlcm5hbHMuZmluZEhlYWRlcignY29udGVudC1lbmNvZGluZycsIHJlcy5oZWFkZXJzKSkgfHwgJyc7XG5cbiAgICAgICAgaWYgKC9eKHgtKT9nemlwKFxccyosXFxzKmlkZW50aXR5KT8kLy50ZXN0KGNvbnRlbnRFbmNvZGluZykpIHtcbiAgICAgICAgICAgIGNvbnN0IGd1bnppcCA9IFpsaWIuY3JlYXRlR3VuemlwKCk7XG5cbiAgICAgICAgICAgIGd1bnppcC5vbmNlKCdlcnJvcicsIG9uUmVhZGVyRXJyb3IpO1xuXG4gICAgICAgICAgICByZXMucGlwZShndW56aXApLnBpcGUocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcy5waXBlKHJlYWRlcik7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLnRvUmVhZGFibGVTdHJlYW0gPSBmdW5jdGlvbiAocGF5bG9hZCwgZW5jb2RpbmcpIHtcblxuICAgIHJldHVybiBuZXcgUGF5bG9hZChwYXlsb2FkLCBlbmNvZGluZyk7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLnBhcnNlQ2FjaGVDb250cm9sID0gZnVuY3Rpb24gKGZpZWxkKSB7XG5cbiAgICAvKlxuICAgICAgICBDYWNoZS1Db250cm9sICAgPSAxI2NhY2hlLWRpcmVjdGl2ZVxuICAgICAgICBjYWNoZS1kaXJlY3RpdmUgPSB0b2tlbiBbIFwiPVwiICggdG9rZW4gLyBxdW90ZWQtc3RyaW5nICkgXVxuICAgICAgICB0b2tlbiAgICAgICAgICAgPSBbXlxceDAwLVxceDIwXFwoXFwpPD5AXFwsO1xcOlxcXFxcIlxcL1xcW1xcXVxcP1xcPVxce1xcfVxceDdGXStcbiAgICAgICAgcXVvdGVkLXN0cmluZyAgID0gXCIoPzpbXlwiXFxcXF18XFxcXC4pKlwiXG4gICAgKi9cblxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOiBkaXJlY3RpdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSAgIDI6IHRva2VuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM6IHF1b3RlZC1zdHJpbmdcbiAgICBjb25zdCByZWdleCA9IC8oPzpefCg/OlxccypcXCxcXHMqKSkoW15cXHgwMC1cXHgyMFxcKFxcKTw+QFxcLDtcXDpcXFxcXCJcXC9cXFtcXF1cXD9cXD1cXHtcXH1cXHg3Rl0rKSg/OlxcPSg/OihbXlxceDAwLVxceDIwXFwoXFwpPD5AXFwsO1xcOlxcXFxcIlxcL1xcW1xcXVxcP1xcPVxce1xcfVxceDdGXSspfCg/OlxcXCIoKD86W15cIlxcXFxdfFxcXFwuKSopXFxcIikpKT8vZztcblxuICAgIGNvbnN0IGhlYWRlciA9IHt9O1xuICAgIGNvbnN0IGVycm9yID0gZmllbGQucmVwbGFjZShyZWdleCwgKCQwLCAkMSwgJDIsICQzKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSAkMiB8fCAkMztcbiAgICAgICAgaGVhZGVyWyQxXSA9IHZhbHVlID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IHRydWU7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcblxuICAgIGlmIChoZWFkZXJbJ21heC1hZ2UnXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbWF4QWdlID0gcGFyc2VJbnQoaGVhZGVyWydtYXgtYWdlJ10sIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihtYXhBZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlclsnbWF4LWFnZSddID0gbWF4QWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHsgfVxuICAgIH1cblxuICAgIHJldHVybiAoZXJyb3IgPyBudWxsIDogaGVhZGVyKTtcbn07XG5cblxuLy8gU2hvcnRjdXRzXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiB0aGlzLl9zaG9ydGN1dCgnR0VUJywgdXJpLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiB0aGlzLl9zaG9ydGN1dCgnUE9TVCcsIHVyaSwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHRoaXMuX3Nob3J0Y3V0KCdQQVRDSCcsIHVyaSwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmksIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiB0aGlzLl9zaG9ydGN1dCgnUFVUJywgdXJpLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHRoaXMuX3Nob3J0Y3V0KCdERUxFVEUnLCB1cmksIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuQ2xpZW50LnByb3RvdHlwZS5fc2hvcnRjdXQgPSBhc3luYyBmdW5jdGlvbiAobWV0aG9kLCB1cmksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5yZXF1ZXN0KG1ldGhvZCwgdXJpLCBvcHRpb25zKTtcblxuICAgIGxldCBwYXlsb2FkO1xuICAgIHRyeSB7XG4gICAgICAgIHBheWxvYWQgPSBhd2FpdCB0aGlzLnJlYWQocmVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIuZGF0YSA9IGVyci5kYXRhIHx8IHt9O1xuICAgICAgICBlcnIuZGF0YS5yZXMgPSByZXM7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgPCA0MDApIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzLCBwYXlsb2FkIH07XG4gICAgfVxuXG4gICAgLy8gUmVzcG9uc2UgZXJyb3JcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGlzUmVzcG9uc2VFcnJvcjogdHJ1ZSxcbiAgICAgICAgaGVhZGVyczogcmVzLmhlYWRlcnMsXG4gICAgICAgIHJlcyxcbiAgICAgICAgcGF5bG9hZFxuICAgIH07XG5cbiAgICB0aHJvdyBuZXcgQm9vbShgUmVzcG9uc2UgRXJyb3I6ICR7cmVzLnN0YXR1c0NvZGV9ICR7cmVzLnN0YXR1c01lc3NhZ2V9YCwgeyBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSwgZGF0YSB9KTtcbn07XG5cblxuaW50ZXJuYWxzLnRyeVBhcnNlQnVmZmVyID0gZnVuY3Rpb24gKGJ1ZmZlciwgbmV4dCkge1xuXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5leHQobnVsbCwgbnVsbCk7XG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcGF5bG9hZCA9IEJvdXJuZS5wYXJzZShidWZmZXIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoQm9vbS5iYWRHYXRld2F5KGVyci5tZXNzYWdlLCB7IHBheWxvYWQ6IGJ1ZmZlciB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHQobnVsbCwgcGF5bG9hZCk7XG59O1xuXG5cbmludGVybmFscy5maW5kSGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWUsIGhlYWRlcnMpIHtcblxuICAgIGNvbnN0IGZvdW5kS2V5ID0gT2JqZWN0LmtleXMoaGVhZGVycylcbiAgICAgICAgLmZpbmQoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSk7XG5cbiAgICByZXR1cm4gZm91bmRLZXkgJiYgaGVhZGVyc1tmb3VuZEtleV07XG59O1xuXG5pbnRlcm5hbHMuYXBwbHlVcmxUb09wdGlvbnMgPSAob3B0aW9ucywgdXJsKSA9PiB7XG5cbiAgICBvcHRpb25zLmhvc3QgPSB1cmwuaG9zdDtcbiAgICBvcHRpb25zLm9yaWdpbiA9IHVybC5vcmlnaW47XG4gICAgb3B0aW9ucy5zZWFyY2hQYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgIG9wdGlvbnMucHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG4gICAgb3B0aW9ucy5ob3N0bmFtZSA9IHVybC5ob3N0bmFtZTtcbiAgICBvcHRpb25zLmhhc2ggPSB1cmwuaGFzaDtcbiAgICBvcHRpb25zLnNlYXJjaCA9IHVybC5zZWFyY2g7XG4gICAgb3B0aW9ucy5wYXRobmFtZSA9IHVybC5wYXRobmFtZTtcbiAgICBvcHRpb25zLnBhdGggPSBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNoIHx8ICcnfWA7XG4gICAgb3B0aW9ucy5ocmVmID0gdXJsLmhyZWY7XG4gICAgaWYgKHVybC5wb3J0ICE9PSAnJykge1xuICAgICAgICBvcHRpb25zLnBvcnQgPSBOdW1iZXIodXJsLnBvcnQpO1xuICAgIH1cblxuICAgIGlmICh1cmwudXNlcm5hbWUgfHwgdXJsLnBhc3N3b3JkKSB7XG4gICAgICAgIG9wdGlvbnMuYXV0aCA9IGAke3VybC51c2VybmFtZX06JHt1cmwucGFzc3dvcmR9YDtcbiAgICAgICAgb3B0aW9ucy51c2VybmFtZSA9IHVybC51c2VybmFtZTtcbiAgICAgICAgb3B0aW9ucy5wYXNzd29yZCA9IHVybC5wYXNzd29yZDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkNsaWVudCgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5QYXlsb2FkID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW0uUmVhZGFibGUge1xuXG4gICAgY29uc3RydWN0b3IocGF5bG9hZCwgZW5jb2RpbmcpIHtcblxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXS5jb25jYXQocGF5bG9hZCB8fCAnJyk7XG4gICAgICAgIGxldCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGRhdGFbaV07XG4gICAgICAgICAgICBzaXplID0gc2l6ZSArIGNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIGRhdGFbaV0gPSBCdWZmZXIuaXNCdWZmZXIoY2h1bmspID8gY2h1bmsgOiBCdWZmZXIuZnJvbShjaHVuayk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kYXRhID0gQnVmZmVyLmNvbmNhdChkYXRhLCBzaXplKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JztcbiAgICB9XG5cbiAgICBfcmVhZChzaXplKSB7XG5cbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX3Bvc2l0aW9uLCB0aGlzLl9wb3NpdGlvbiArIHNpemUpO1xuICAgICAgICB0aGlzLnB1c2goY2h1bmssIHRoaXMuX2VuY29kaW5nKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiArIGNodW5rLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5fcG9zaXRpb24gPj0gdGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlJlY29yZGVyID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW0uV3JpdGFibGUge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IG9wdGlvbnM7ICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2xvbmUgc2luY2UgY2FsbGVkIGludGVybmFsbHkgd2l0aCBuZXcgb2JqZWN0XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgbmV4dCkge1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1heEJ5dGVzICYmXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArIGNodW5rLmxlbmd0aCA+IHRoaXMuc2V0dGluZ3MubWF4Qnl0ZXMpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBCb29tLmVudGl0eVRvb0xhcmdlKCdQYXlsb2FkIGNvbnRlbnQgbGVuZ3RoIGdyZWF0ZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQ6ICcgKyB0aGlzLnNldHRpbmdzLm1heEJ5dGVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoICsgY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBjb2xsZWN0KCkge1xuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9ICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAwID8gQnVmZmVyLmFsbG9jKDApIDogKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDEgPyB0aGlzLmJ1ZmZlcnNbMF0gOiBCdWZmZXIuY29uY2F0KHRoaXMuYnVmZmVycywgdGhpcy5sZW5ndGgpKSk7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBheWxvYWQgPSByZXF1aXJlKCcuL3BheWxvYWQnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5UYXAgPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5UcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIG5leHQpIHtcblxuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgIG5leHQobnVsbCwgY2h1bmspO1xuICAgIH1cblxuICAgIGNvbGxlY3QoKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQYXlsb2FkKHRoaXMuYnVmZmVycyk7XG4gICAgfVxufTtcbiIsIi8vIEBmbG93XG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXkgPSAnX19nbG9iYWxfdW5pcXVlX2lkX18nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ2xvYmFsW2tleV0gPSAoZ2xvYmFsW2tleV0gfHwgMCkgKyAxO1xufTtcbiIsImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCByZXNvbHZlUGF0aG5hbWUgZnJvbSAncmVzb2x2ZS1wYXRobmFtZSc7XG5pbXBvcnQgdmFsdWVFcXVhbCBmcm9tICd2YWx1ZS1lcXVhbCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5cbmZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59XG5mdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufVxuZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBwYXRoLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwcmVmaXgudG9Mb3dlckNhc2UoKSkgPT09IDAgJiYgJy8/IycuaW5kZXhPZihwYXRoLmNoYXJBdChwcmVmaXgubGVuZ3RoKSkgIT09IC0xO1xufVxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkgPyBwYXRoLnN1YnN0cihwcmVmaXgubGVuZ3RoKSA6IHBhdGg7XG59XG5mdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufVxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIGhhc2hJbmRleCA9IHBhdGhuYW1lLmluZGV4T2YoJyMnKTtcblxuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuXG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogXCI/XCIgKyBzZWFyY2g7XG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb247XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gcmVzb2x2ZVBhdGhuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59XG5mdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgdmFsdWVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJykgOiB2b2lkIDA7XG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpIDogdm9pZCAwO1xuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuZnVuY3Rpb24gZ2V0Q29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPT09IC0xO1xufVxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5cbmZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn1cblxudmFyIFBvcFN0YXRlRXZlbnQgPSAncG9wc3RhdGUnO1xudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3RvcnkocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG5cbiAgIWNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgJ0Jyb3dzZXIgaGlzdG9yeSBuZWVkcyBhIERPTScpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IF9wcm9wcy5mb3JjZVJlZnJlc2gsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBfcHJvcHMkZm9yY2VSZWZyZXNoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRmb3JjZVJlZnJlc2gsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBfcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHZvaWQgMCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBfcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdm9pZCAwID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oaGlzdG9yeVN0YXRlKSB7XG4gICAgdmFyIF9yZWYgPSBoaXN0b3J5U3RhdGUgfHwge30sXG4gICAgICAgIGtleSA9IF9yZWYua2V5LFxuICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7XG5cbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpIDogdm9pZCAwO1xuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uOyAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldOyAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICB2YXIgbmV4dEtleXMgPSBhbGxLZXlzLnNsaWNlKDAsIHByZXZJbmRleCArIDEpO1xuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpIDogdm9pZCAwO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoe1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEpIGFsbEtleXNbcHJldkluZGV4XSA9IGxvY2F0aW9uLmtleTtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxICYmIGRlbHRhID09PSAxKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGJsb2NrKHByb21wdCkge1xuICAgIGlmIChwcm9tcHQgPT09IHZvaWQgMCkge1xuICAgICAgcHJvbXB0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG52YXIgSGFzaENoYW5nZUV2ZW50JDEgPSAnaGFzaGNoYW5nZSc7XG52YXIgSGFzaFBhdGhDb2RlcnMgPSB7XG4gIGhhc2hiYW5nOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGggOiAnIS8nICsgc3RyaXBMZWFkaW5nU2xhc2gocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IHN0cmlwTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9LFxuICBzbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyaXBIYXNoKHVybCkge1xuICB2YXIgaGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbn1cblxuZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uoc3RyaXBIYXNoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSArICcjJyArIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cblxuICAhY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKTtcbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gX3Byb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB2b2lkIDAgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBfcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdm9pZCAwID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuICBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKSA6IHZvaWQgMDtcbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH1cblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbCQkMShhLCBiKSB7XG4gICAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICAgIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkge1xuICAgICAgLy8gRW5zdXJlIHdlIGFsd2F5cyBoYXZlIGEgcHJvcGVybHktZW5jb2RlZCBoYXNoLlxuICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgbG9jYXRpb25zQXJlRXF1YWwkJDEocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09IGNyZWF0ZVBhdGgobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjsgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGZyb21Mb2NhdGlvbikpO1xuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9IC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuXG5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbY3JlYXRlUGF0aChpbml0aWFsTG9jYXRpb24pXTsgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICB2YXIgaHJlZiA9ICcnO1xuXG4gICAgaWYgKGJhc2VUYWcgJiYgYmFzZVRhZy5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkge1xuICAgICAgaHJlZiA9IHN0cmlwSGFzaCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWYgKyAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCArIDEpO1xuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJykgOiB2b2lkIDA7XG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoY2FuR29XaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJykgOiB2b2lkIDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEgJiYgZGVsdGEgPT09IDEpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCQxLCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEhhc2hDaGFuZ2VFdmVudCQxLCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gYmxvY2socHJvbXB0KSB7XG4gICAgaWYgKHByb21wdCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9tcHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuXG4gIHZhciBfcHJvcHMgPSBwcm9wcyxcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IF9wcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB2b2lkIDAgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBfcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdm9pZCAwID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gX3Byb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHZvaWQgMCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH1cblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pOyAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBjcmVhdGVQYXRoO1xuXG4gIGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuXG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIGhpc3RvcnkuZW50cmllc1toaXN0b3J5LmluZGV4XSA9IGxvY2F0aW9uO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChvaykge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNaW1pYyB0aGUgYmVoYXZpb3Igb2YgRE9NIGhpc3RvcmllcyBieVxuICAgICAgICAvLyBjYXVzaW5nIGEgcmVuZGVyIGFmdGVyIGEgY2FuY2VsbGVkIFBPUC5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2socHJvbXB0KSB7XG4gICAgaWYgKHByb21wdCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9tcHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBlbnRyaWVzLmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBlbnRyaWVzW2luZGV4XSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgZW50cmllczogZW50cmllcyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY2FuR286IGNhbkdvLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVNZW1vcnlIaXN0b3J5LCBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwsIHBhcnNlUGF0aCwgY3JlYXRlUGF0aCB9O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcblxuLy8gVGhpcyB3aWxsIGJlIGEgcHJvcGVyIGl0ZXJhYmxlICdNYXAnIGluIGVuZ2luZXMgdGhhdCBzdXBwb3J0IGl0LFxuLy8gb3IgYSBmYWtleS1mYWtlIFBzZXVkb01hcCBpbiBvbGRlciB2ZXJzaW9ucy5cbnZhciBNYXAgPSByZXF1aXJlKCdwc2V1ZG9tYXAnKVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xudmFyIFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcblxuLy8gdXNlIHN5bWJvbHMgaWYgcG9zc2libGUsIG90aGVyd2lzZSBqdXN0IF9wcm9wc1xudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvY2Vzcy5lbnYuX25vZGVMUlVDYWNoZUZvcmNlTm9TeW1ib2wgIT09ICcxJ1xudmFyIG1ha2VTeW1ib2xcbmlmIChoYXNTeW1ib2wpIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gU3ltYm9sKGtleSlcbiAgfVxufSBlbHNlIHtcbiAgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gJ18nICsga2V5XG4gIH1cbn1cblxudmFyIE1BWCA9IG1ha2VTeW1ib2woJ21heCcpXG52YXIgTEVOR1RIID0gbWFrZVN5bWJvbCgnbGVuZ3RoJylcbnZhciBMRU5HVEhfQ0FMQ1VMQVRPUiA9IG1ha2VTeW1ib2woJ2xlbmd0aENhbGN1bGF0b3InKVxudmFyIEFMTE9XX1NUQUxFID0gbWFrZVN5bWJvbCgnYWxsb3dTdGFsZScpXG52YXIgTUFYX0FHRSA9IG1ha2VTeW1ib2woJ21heEFnZScpXG52YXIgRElTUE9TRSA9IG1ha2VTeW1ib2woJ2Rpc3Bvc2UnKVxudmFyIE5PX0RJU1BPU0VfT05fU0VUID0gbWFrZVN5bWJvbCgnbm9EaXNwb3NlT25TZXQnKVxudmFyIExSVV9MSVNUID0gbWFrZVN5bWJvbCgnbHJ1TGlzdCcpXG52YXIgQ0FDSEUgPSBtYWtlU3ltYm9sKCdjYWNoZScpXG5cbmZ1bmN0aW9uIG5haXZlTGVuZ3RoICgpIHsgcmV0dXJuIDEgfVxuXG4vLyBscnVMaXN0IGlzIGEgeWFsbGlzdCB3aGVyZSB0aGUgaGVhZCBpcyB0aGUgeW91bmdlc3Rcbi8vIGl0ZW0sIGFuZCB0aGUgdGFpbCBpcyB0aGUgb2xkZXN0LiAgdGhlIGxpc3QgY29udGFpbnMgdGhlIEhpdFxuLy8gb2JqZWN0cyBhcyB0aGUgZW50cmllcy5cbi8vIEVhY2ggSGl0IG9iamVjdCBoYXMgYSByZWZlcmVuY2UgdG8gaXRzIFlhbGxpc3QuTm9kZS4gIFRoaXNcbi8vIG5ldmVyIGNoYW5nZXMuXG4vL1xuLy8gY2FjaGUgaXMgYSBNYXAgKG9yIFBzZXVkb01hcCkgdGhhdCBtYXRjaGVzIHRoZSBrZXlzIHRvXG4vLyB0aGUgWWFsbGlzdC5Ob2RlIG9iamVjdC5cbmZ1bmN0aW9uIExSVUNhY2hlIChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMUlVDYWNoZSkpIHtcbiAgICByZXR1cm4gbmV3IExSVUNhY2hlKG9wdGlvbnMpXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucyA9IHsgbWF4OiBvcHRpb25zIH1cbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXSA9IG9wdGlvbnMubWF4XG4gIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgaWYgKCFtYXggfHxcbiAgICAgICEodHlwZW9mIG1heCA9PT0gJ251bWJlcicpIHx8XG4gICAgICBtYXggPD0gMCkge1xuICAgIHRoaXNbTUFYXSA9IEluZmluaXR5XG4gIH1cblxuICB2YXIgbGMgPSBvcHRpb25zLmxlbmd0aCB8fCBuYWl2ZUxlbmd0aFxuICBpZiAodHlwZW9mIGxjICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgbGMgPSBuYWl2ZUxlbmd0aFxuICB9XG4gIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbGNcblxuICB0aGlzW0FMTE9XX1NUQUxFXSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgdGhpc1tNQVhfQUdFXSA9IG9wdGlvbnMubWF4QWdlIHx8IDBcbiAgdGhpc1tESVNQT1NFXSA9IG9wdGlvbnMuZGlzcG9zZVxuICB0aGlzW05PX0RJU1BPU0VfT05fU0VUXSA9IG9wdGlvbnMubm9EaXNwb3NlT25TZXQgfHwgZmFsc2VcbiAgdGhpcy5yZXNldCgpXG59XG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbWF4Jywge1xuICBzZXQ6IGZ1bmN0aW9uIChtTCkge1xuICAgIGlmICghbUwgfHwgISh0eXBlb2YgbUwgPT09ICdudW1iZXInKSB8fCBtTCA8PSAwKSB7XG4gICAgICBtTCA9IEluZmluaXR5XG4gICAgfVxuICAgIHRoaXNbTUFYXSA9IG1MXG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1tNQVhdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdhbGxvd1N0YWxlJywge1xuICBzZXQ6IGZ1bmN0aW9uIChhbGxvd1N0YWxlKSB7XG4gICAgdGhpc1tBTExPV19TVEFMRV0gPSAhIWFsbG93U3RhbGVcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbQUxMT1dfU1RBTEVdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdtYXhBZ2UnLCB7XG4gIHNldDogZnVuY3Rpb24gKG1BKSB7XG4gICAgaWYgKCFtQSB8fCAhKHR5cGVvZiBtQSA9PT0gJ251bWJlcicpIHx8IG1BIDwgMCkge1xuICAgICAgbUEgPSAwXG4gICAgfVxuICAgIHRoaXNbTUFYX0FHRV0gPSBtQVxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYX0FHRV1cbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZVxufSlcblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBsZW5ndGhDYWxjdWxhdG9yIGNoYW5nZXMuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbGVuZ3RoQ2FsY3VsYXRvcicsIHtcbiAgc2V0OiBmdW5jdGlvbiAobEMpIHtcbiAgICBpZiAodHlwZW9mIGxDICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBsQyA9IG5haXZlTGVuZ3RoXG4gICAgfVxuICAgIGlmIChsQyAhPT0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0pIHtcbiAgICAgIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdID0gbENcbiAgICAgIHRoaXNbTEVOR1RIXSA9IDBcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgICBoaXQubGVuZ3RoID0gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0oaGl0LnZhbHVlLCBoaXQua2V5KVxuICAgICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICAgICAgfSwgdGhpcylcbiAgICB9XG4gICAgdHJpbSh0aGlzKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdsZW5ndGgnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMRU5HVEhdIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsICdpdGVtQ291bnQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbkxSVUNhY2hlLnByb3RvdHlwZS5yZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgd2Fsa2VyID0gcHJldlxuICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdGVwIChzZWxmLCBmbiwgbm9kZSwgdGhpc3ApIHtcbiAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgIGRlbChzZWxmLCBub2RlKVxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIHtcbiAgICAgIGhpdCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuICBpZiAoaGl0KSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgaGl0LnZhbHVlLCBoaXQua2V5LCBzZWxmKVxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpc1tMUlVfTElTVF0uaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHRcbiAgICBmb3JFYWNoU3RlcCh0aGlzLCBmbiwgd2Fsa2VyLCB0aGlzcClcbiAgICB3YWxrZXIgPSBuZXh0XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsua2V5XG4gIH0sIHRoaXMpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXS50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsudmFsdWVcbiAgfSwgdGhpcylcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpc1tESVNQT1NFXSAmJlxuICAgICAgdGhpc1tMUlVfTElTVF0gJiZcbiAgICAgIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGhpdCkge1xuICAgICAgdGhpc1tESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfVxuXG4gIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gIHRoaXNbTFJVX0xJU1RdID0gbmV3IFlhbGxpc3QoKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gIHRoaXNbTEVOR1RIXSA9IDAgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICBpZiAoIWlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgdjogaGl0LnZhbHVlLFxuICAgICAgICBlOiBoaXQubm93ICsgKGhpdC5tYXhBZ2UgfHwgMClcbiAgICAgIH1cbiAgICB9XG4gIH0sIHRoaXMpLnRvQXJyYXkoKS5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICByZXR1cm4gaFxuICB9KVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcExydSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5MUlVDYWNoZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIChuLCBvcHRzKSB7XG4gIHZhciBzdHIgPSAnTFJVQ2FjaGUgeydcbiAgdmFyIGV4dHJhcyA9IGZhbHNlXG5cbiAgdmFyIGFzID0gdGhpc1tBTExPV19TVEFMRV1cbiAgaWYgKGFzKSB7XG4gICAgc3RyICs9ICdcXG4gIGFsbG93U3RhbGU6IHRydWUnXG4gICAgZXh0cmFzID0gdHJ1ZVxuICB9XG5cbiAgdmFyIG1heCA9IHRoaXNbTUFYXVxuICBpZiAobWF4ICYmIG1heCAhPT0gSW5maW5pdHkpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXg6ICcgKyB1dGlsLmluc3BlY3QobWF4LCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBtYXhBZ2UgPSB0aGlzW01BWF9BR0VdXG4gIGlmIChtYXhBZ2UpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBtYXhBZ2U6ICcgKyB1dGlsLmluc3BlY3QobWF4QWdlLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBsYyA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdXG4gIGlmIChsYyAmJiBsYyAhPT0gbmFpdmVMZW5ndGgpIHtcbiAgICBpZiAoZXh0cmFzKSB7XG4gICAgICBzdHIgKz0gJywnXG4gICAgfVxuICAgIHN0ciArPSAnXFxuICBsZW5ndGg6ICcgKyB1dGlsLmluc3BlY3QodGhpc1tMRU5HVEhdLCBvcHRzKVxuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBkaWRGaXJzdCA9IGZhbHNlXG4gIHRoaXNbTFJVX0xJU1RdLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoZGlkRmlyc3QpIHtcbiAgICAgIHN0ciArPSAnLFxcbiAgJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXh0cmFzKSB7XG4gICAgICAgIHN0ciArPSAnLFxcbidcbiAgICAgIH1cbiAgICAgIGRpZEZpcnN0ID0gdHJ1ZVxuICAgICAgc3RyICs9ICdcXG4gICdcbiAgICB9XG4gICAgdmFyIGtleSA9IHV0aWwuaW5zcGVjdChpdGVtLmtleSkuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgJylcbiAgICB2YXIgdmFsID0geyB2YWx1ZTogaXRlbS52YWx1ZSB9XG4gICAgaWYgKGl0ZW0ubWF4QWdlICE9PSBtYXhBZ2UpIHtcbiAgICAgIHZhbC5tYXhBZ2UgPSBpdGVtLm1heEFnZVxuICAgIH1cbiAgICBpZiAobGMgIT09IG5haXZlTGVuZ3RoKSB7XG4gICAgICB2YWwubGVuZ3RoID0gaXRlbS5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGlzU3RhbGUodGhpcywgaXRlbSkpIHtcbiAgICAgIHZhbC5zdGFsZSA9IHRydWVcbiAgICB9XG5cbiAgICB2YWwgPSB1dGlsLmluc3BlY3QodmFsLCBvcHRzKS5zcGxpdCgnXFxuJykuam9pbignXFxuICAnKVxuICAgIHN0ciArPSBrZXkgKyAnID0+ICcgKyB2YWxcbiAgfSlcblxuICBpZiAoZGlkRmlyc3QgfHwgZXh0cmFzKSB7XG4gICAgc3RyICs9ICdcXG4nXG4gIH1cbiAgc3RyICs9ICd9J1xuXG4gIHJldHVybiBzdHJcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXNbTUFYX0FHRV1cblxuICB2YXIgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgdmFyIGxlbiA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKHZhbHVlLCBrZXkpXG5cbiAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXNbTUFYXSkge1xuICAgICAgZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KVxuICAgIHZhciBpdGVtID0gbm9kZS52YWx1ZVxuXG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAvLyBzcGxpdCBvdXQgaW50byAyIGlmcyBmb3IgYmV0dGVyIGNvdmVyYWdlIHRyYWNraW5nXG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIGlmICghdGhpc1tOT19ESVNQT1NFX09OX1NFVF0pIHtcbiAgICAgICAgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaXRlbS5ub3cgPSBub3dcbiAgICBpdGVtLm1heEFnZSA9IG1heEFnZVxuICAgIGl0ZW0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aFxuICAgIGl0ZW0ubGVuZ3RoID0gbGVuXG4gICAgdGhpcy5nZXQoa2V5KVxuICAgIHRyaW0odGhpcylcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgdmFyIGhpdCA9IG5ldyBFbnRyeShrZXksIHZhbHVlLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gIGlmIChoaXQubGVuZ3RoID4gdGhpc1tNQVhdKSB7XG4gICAgaWYgKHRoaXNbRElTUE9TRV0pIHtcbiAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCB2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aFxuICB0aGlzW0xSVV9MSVNUXS51bnNoaWZ0KGhpdClcbiAgdGhpc1tDQUNIRV0uc2V0KGtleSwgdGhpc1tMUlVfTElTVF0uaGVhZClcbiAgdHJpbSh0aGlzKVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICBpZiAoIXRoaXNbQ0FDSEVdLmhhcyhrZXkpKSByZXR1cm4gZmFsc2VcbiAgdmFyIGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzW0xSVV9MSVNUXS50YWlsXG4gIGlmICghbm9kZSkgcmV0dXJuIG51bGxcbiAgZGVsKHRoaXMsIG5vZGUpXG4gIHJldHVybiBub2RlLnZhbHVlXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIC8vIHJlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KClcblxuICB2YXIgbm93ID0gRGF0ZS5ub3coKVxuICAvLyBBIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgdmFyIGhpdCA9IGFycltsXVxuICAgIHZhciBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgaWYgKGV4cGlyZXNBdCA9PT0gMCkge1xuICAgICAgLy8gdGhlIGl0ZW0gd2FzIGNyZWF0ZWQgd2l0aG91dCBleHBpcmF0aW9uIGluIGEgbm9uIGFnZWQgY2FjaGVcbiAgICAgIHRoaXMuc2V0KGhpdC5rLCBoaXQudilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heEFnZSA9IGV4cGlyZXNBdCAtIG5vd1xuICAgICAgLy8gZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBydW5lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpc1tDQUNIRV0uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGdldChzZWxmLCBrZXksIGZhbHNlKVxuICB9KVxufVxuXG5mdW5jdGlvbiBnZXQgKHNlbGYsIGtleSwgZG9Vc2UpIHtcbiAgdmFyIG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KVxuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIG5vZGUpXG4gICAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSBoaXQgPSB1bmRlZmluZWRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIHNlbGZbTFJVX0xJU1RdLnVuc2hpZnROb2RlKG5vZGUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoaXQpIGhpdCA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuZnVuY3Rpb24gaXNTdGFsZSAoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICghaGl0Lm1heEFnZSAmJiAhc2VsZltNQVhfQUdFXSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgc3RhbGUgPSBmYWxzZVxuICB2YXIgZGlmZiA9IERhdGUubm93KCkgLSBoaXQubm93XG4gIGlmIChoaXQubWF4QWdlKSB7XG4gICAgc3RhbGUgPSBkaWZmID4gaGl0Lm1heEFnZVxuICB9IGVsc2Uge1xuICAgIHN0YWxlID0gc2VsZltNQVhfQUdFXSAmJiAoZGlmZiA+IHNlbGZbTUFYX0FHRV0pXG4gIH1cbiAgcmV0dXJuIHN0YWxlXG59XG5cbmZ1bmN0aW9uIHRyaW0gKHNlbGYpIHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAodmFyIHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7XG4gICAgICBzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0gJiYgd2Fsa2VyICE9PSBudWxsOykge1xuICAgICAgLy8gV2Uga25vdyB0aGF0IHdlJ3JlIGFib3V0IHRvIGRlbGV0ZSB0aGlzIG9uZSwgYW5kIGFsc29cbiAgICAgIC8vIHdoYXQgdGhlIG5leHQgbGVhc3QgcmVjZW50bHkgdXNlZCBrZXkgd2lsbCBiZSwgc28ganVzdFxuICAgICAgLy8gZ28gYWhlYWQgYW5kIHNldCBpdCBub3cuXG4gICAgICB2YXIgcHJldiA9IHdhbGtlci5wcmV2XG4gICAgICBkZWwoc2VsZiwgd2Fsa2VyKVxuICAgICAgd2Fsa2VyID0gcHJldlxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWwgKHNlbGYsIG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChzZWxmW0RJU1BPU0VdKSB7XG4gICAgICBzZWxmW0RJU1BPU0VdKGhpdC5rZXksIGhpdC52YWx1ZSlcbiAgICB9XG4gICAgc2VsZltMRU5HVEhdIC09IGhpdC5sZW5ndGhcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSlcbiAgICBzZWxmW0xSVV9MSVNUXS5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cbn1cblxuLy8gY2xhc3N5LCBzaW5jZSBWOCBwcmVmZXJzIHByZWRpY3RhYmxlIG9iamVjdHMuXG5mdW5jdGlvbiBFbnRyeSAoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sZW5ndGggPSBsZW5ndGhcbiAgdGhpcy5ub3cgPSBub3dcbiAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBZYWxsaXN0XG5cbllhbGxpc3QuTm9kZSA9IE5vZGVcbllhbGxpc3QuY3JlYXRlID0gWWFsbGlzdFxuXG5mdW5jdGlvbiBZYWxsaXN0IChsaXN0KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIShzZWxmIGluc3RhbmNlb2YgWWFsbGlzdCkpIHtcbiAgICBzZWxmID0gbmV3IFlhbGxpc3QoKVxuICB9XG5cbiAgc2VsZi50YWlsID0gbnVsbFxuICBzZWxmLmhlYWQgPSBudWxsXG4gIHNlbGYubGVuZ3RoID0gMFxuXG4gIGlmIChsaXN0ICYmIHR5cGVvZiBsaXN0LmZvckVhY2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBsaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHNlbGYucHVzaChpdGVtKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNlbGYucHVzaChhcmd1bWVudHNbaV0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpXG4gIH1cblxuICB2YXIgbmV4dCA9IG5vZGUubmV4dFxuICB2YXIgcHJldiA9IG5vZGUucHJldlxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldlxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0XG4gIH1cblxuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gbmV4dFxuICB9XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBwcmV2XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS1cbiAgbm9kZS5uZXh0ID0gbnVsbFxuICBub2RlLnByZXYgPSBudWxsXG4gIG5vZGUubGlzdCA9IG51bGxcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5uZXh0ID0gaGVhZFxuICBpZiAoaGVhZCkge1xuICAgIGhlYWQucHJldiA9IG5vZGVcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IG5vZGVcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChub2RlLmxpc3QpIHtcbiAgICBub2RlLmxpc3QucmVtb3ZlTm9kZShub2RlKVxuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgbm9kZS5saXN0ID0gdGhpc1xuICBub2RlLnByZXYgPSB0YWlsXG4gIGlmICh0YWlsKSB7XG4gICAgdGFpbC5uZXh0ID0gbm9kZVxuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZVxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGVcbiAgfVxuICB0aGlzLmxlbmd0aCsrXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHB1c2godGhpcywgYXJndW1lbnRzW2ldKVxuICB9XG4gIHJldHVybiB0aGlzLmxlbmd0aFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB1bnNoaWZ0KHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLnRhaWwudmFsdWVcbiAgdGhpcy50YWlsID0gdGhpcy50YWlsLnByZXZcbiAgaWYgKHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbC5uZXh0ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdmFyIHJlcyA9IHRoaXMuaGVhZC52YWx1ZVxuICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dFxuICBpZiAodGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkLnByZXYgPSBudWxsXG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbFxuICB9XG4gIHRoaXMubGVuZ3RoLS1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLmdldFJldmVyc2UgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZVxuICB9XG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIHZhciByZXMgPSBuZXcgWWFsbGlzdCgpXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOykge1xuICAgIHJlcy5wdXNoKGZuLmNhbGwodGhpc3AsIHdhbGtlci52YWx1ZSwgdGhpcykpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLm1hcFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjY1xuICB2YXIgd2Fsa2VyID0gdGhpcy5oZWFkXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIGFjYyA9IGluaXRpYWxcbiAgfSBlbHNlIGlmICh0aGlzLmhlYWQpIHtcbiAgICB3YWxrZXIgPSB0aGlzLmhlYWQubmV4dFxuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBsaXN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMudGFpbFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy50YWlsKSB7XG4gICAgd2Fsa2VyID0gdGhpcy50YWlsLnByZXZcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBhY2MgPSBmbihhY2MsIHdhbGtlci52YWx1ZSwgaSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG5cbiAgcmV0dXJuIGFjY1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICB0byA9IHRvIHx8IHRoaXMubGVuZ3RoXG4gIGlmICh0byA8IDApIHtcbiAgICB0byArPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZyb20gPSBmcm9tIHx8IDBcbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSArPSB0aGlzLmxlbmd0aFxuICB9XG4gIHZhciByZXQgPSBuZXcgWWFsbGlzdCgpXG4gIGlmICh0byA8IGZyb20gfHwgdG8gPCAwKSB7XG4gICAgcmV0dXJuIHJldFxuICB9XG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gPSAwXG4gIH1cbiAgaWYgKHRvID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0byA9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gdG87IGktLSkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpID4gZnJvbTsgaS0tLCB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIGZvciAodmFyIHdhbGtlciA9IGhlYWQ7IHdhbGtlciAhPT0gbnVsbDsgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICB2YXIgcCA9IHdhbGtlci5wcmV2XG4gICAgd2Fsa2VyLnByZXYgPSB3YWxrZXIubmV4dFxuICAgIHdhbGtlci5uZXh0ID0gcFxuICB9XG4gIHRoaXMuaGVhZCA9IHRhaWxcbiAgdGhpcy50YWlsID0gaGVhZFxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBwdXNoIChzZWxmLCBpdGVtKSB7XG4gIHNlbGYudGFpbCA9IG5ldyBOb2RlKGl0ZW0sIHNlbGYudGFpbCwgbnVsbCwgc2VsZilcbiAgaWYgKCFzZWxmLmhlYWQpIHtcbiAgICBzZWxmLmhlYWQgPSBzZWxmLnRhaWxcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQgKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi5oZWFkID0gbmV3IE5vZGUoaXRlbSwgbnVsbCwgc2VsZi5oZWFkLCBzZWxmKVxuICBpZiAoIXNlbGYudGFpbCkge1xuICAgIHNlbGYudGFpbCA9IHNlbGYuaGVhZFxuICB9XG4gIHNlbGYubGVuZ3RoKytcbn1cblxuZnVuY3Rpb24gTm9kZSAodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vZGUpKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KVxuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdFxuICB0aGlzLnZhbHVlID0gdmFsdWVcblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IHRoaXNcbiAgICB0aGlzLnByZXYgPSBwcmV2XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmV2ID0gbnVsbFxuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSB0aGlzXG4gICAgdGhpcy5uZXh0ID0gbmV4dFxuICB9IGVsc2Uge1xuICAgIHRoaXMubmV4dCA9IG51bGxcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBndWQgZnJvbSAnZ3VkJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5cbnZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xuXG5mdW5jdGlvbiBvYmplY3RJcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyKHZhbHVlKSB7XG4gIHZhciBoYW5kbGVycyA9IFtdO1xuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbiBvbihoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIGggIT09IGhhbmRsZXI7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUsIGNoYW5nZWRCaXRzKSB7XG4gICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcih2YWx1ZSwgY2hhbmdlZEJpdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVhY3RDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgdmFyIF9Qcm92aWRlciRjaGlsZENvbnRleCwgX0NvbnN1bWVyJGNvbnRleHRUeXBlO1xuXG4gIHZhciBjb250ZXh0UHJvcCA9ICdfX2NyZWF0ZS1yZWFjdC1jb250ZXh0LScgKyBndWQoKSArICdfXyc7XG5cbiAgdmFyIFByb3ZpZGVyID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuZW1pdHRlciA9IGNyZWF0ZUV2ZW50RW1pdHRlcihfdGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltjb250ZXh0UHJvcF0gPSB0aGlzLmVtaXR0ZXIsIF9yZWY7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBuZXh0UHJvcHMudmFsdWUpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY2hhbmdlZEJpdHM7XG5cbiAgICAgICAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoKGNoYW5nZWRCaXRzICYgTUFYX1NJR05FRF8zMV9CSVRfSU5UKSA9PT0gY2hhbmdlZEJpdHMsICdjYWxjdWxhdGVDaGFuZ2VkQml0czogRXhwZWN0ZWQgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBhICcgKyAnMzEtYml0IGludGVnZXIuIEluc3RlYWQgcmVjZWl2ZWQ6ICcgKyBjaGFuZ2VkQml0cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhbmdlZEJpdHMgfD0gMDtcblxuICAgICAgICAgIGlmIChjaGFuZ2VkQml0cyAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnNldChuZXh0UHJvcHMudmFsdWUsIGNoYW5nZWRCaXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG5cbiAgICByZXR1cm4gUHJvdmlkZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBQcm92aWRlci5jaGlsZENvbnRleHRUeXBlcyA9IChfUHJvdmlkZXIkY2hpbGRDb250ZXggPSB7fSwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4W2NvbnRleHRQcm9wXSA9IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCwgX1Byb3ZpZGVyJGNoaWxkQ29udGV4KTtcblxuICB2YXIgQ29uc3VtZXIgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfQ29tcG9uZW50Mikge1xuICAgIF9pbmhlcml0c0xvb3NlKENvbnN1bWVyLCBfQ29tcG9uZW50Mik7XG5cbiAgICBmdW5jdGlvbiBDb25zdW1lcigpIHtcbiAgICAgIHZhciBfdGhpczI7XG5cbiAgICAgIF90aGlzMiA9IF9Db21wb25lbnQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzMi5zdGF0ZSA9IHtcbiAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICB9O1xuXG4gICAgICBfdGhpczIub25VcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUsIGNoYW5nZWRCaXRzKSB7XG4gICAgICAgIHZhciBvYnNlcnZlZEJpdHMgPSBfdGhpczIub2JzZXJ2ZWRCaXRzIHwgMDtcblxuICAgICAgICBpZiAoKG9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh7XG4gICAgICAgICAgICB2YWx1ZTogX3RoaXMyLmdldFZhbHVlKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzMjtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvMiA9IENvbnN1bWVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gbmV4dFByb3BzLm9ic2VydmVkQml0cztcbiAgICAgIHRoaXMub2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzID09PSB1bmRlZmluZWQgfHwgb2JzZXJ2ZWRCaXRzID09PSBudWxsID8gTUFYX1NJR05FRF8zMV9CSVRfSU5UIDogb2JzZXJ2ZWRCaXRzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLm9uKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gdGhpcy5wcm9wcy5vYnNlcnZlZEJpdHM7XG4gICAgICB0aGlzLm9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCA/IE1BWF9TSUdORURfMzFfQklUX0lOVCA6IG9ic2VydmVkQml0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5vZmYodGhpcy5vblVwZGF0ZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHRbY29udGV4dFByb3BdLmdldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ29uc3VtZXI7XG4gIH0oQ29tcG9uZW50KTtcblxuICBDb25zdW1lci5jb250ZXh0VHlwZXMgPSAoX0NvbnN1bWVyJGNvbnRleHRUeXBlID0ge30sIF9Db25zdW1lciRjb250ZXh0VHlwZVtjb250ZXh0UHJvcF0gPSBQcm9wVHlwZXMub2JqZWN0LCBfQ29uc3VtZXIkY29udGV4dFR5cGUpO1xuICByZXR1cm4ge1xuICAgIFByb3ZpZGVyOiBQcm92aWRlcixcbiAgICBDb25zdW1lcjogQ29uc3VtZXJcbiAgfTtcbn1cblxudmFyIGluZGV4ID0gUmVhY3QuY3JlYXRlQ29udGV4dCB8fCBjcmVhdGVSZWFjdENvbnRleHQ7XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsInZhciBpc2FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nXG4gIHZhciByZXNcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdXG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV1cbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoXG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XVxuICAgIHZhciBwcmVmaXggPSByZXNbMl1cbiAgICB2YXIgbmFtZSA9IHJlc1szXVxuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdXG4gICAgdmFyIGdyb3VwID0gcmVzWzVdXG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddXG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKVxuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KVxuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KVxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpXG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fVxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXVxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKVxuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXNcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlXG4gIHZhciByb3V0ZSA9ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KVxuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSdcblxuICAgICAga2V5cy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmVcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJylcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXJcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/J1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJ1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSdcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiaWYgKHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX25hbWUgPT09ICdwc2V1ZG9tYXAnICYmXG4gICAgcHJvY2Vzcy5lbnYubnBtX2xpZmVjeWNsZV9zY3JpcHQgPT09ICd0ZXN0JylcbiAgcHJvY2Vzcy5lbnYuVEVTVF9QU0VVRE9NQVAgPSAndHJ1ZSdcblxuaWYgKHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgIXByb2Nlc3MuZW52LlRFU1RfUFNFVURPTUFQKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTWFwXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcHNldWRvbWFwJylcbn1cbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxubW9kdWxlLmV4cG9ydHMgPSBQc2V1ZG9NYXBcblxuZnVuY3Rpb24gUHNldWRvTWFwIChzZXQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBzZXVkb01hcCkpIC8vIHdoeXl5eXl5eVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb25zdHJ1Y3RvciBQc2V1ZG9NYXAgcmVxdWlyZXMgJ25ldydcIilcblxuICB0aGlzLmNsZWFyKClcblxuICBpZiAoc2V0KSB7XG4gICAgaWYgKChzZXQgaW5zdGFuY2VvZiBQc2V1ZG9NYXApIHx8XG4gICAgICAgICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIHNldCBpbnN0YW5jZW9mIE1hcCkpXG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKVxuICAgICAgfSwgdGhpcylcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNldCkpXG4gICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAoa3YpIHtcbiAgICAgICAgdGhpcy5zZXQoa3ZbMF0sIGt2WzFdKVxuICAgICAgfSwgdGhpcylcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFyZ3VtZW50JylcbiAgfVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBPYmplY3Qua2V5cyh0aGlzLl9kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgIT09ICdzaXplJylcbiAgICAgIGZuLmNhbGwodGhpc3AsIHRoaXMuX2RhdGFba10udmFsdWUsIHRoaXMuX2RhdGFba10ua2V5KVxuICB9LCB0aGlzKVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrKSB7XG4gIHJldHVybiAhIWZpbmQodGhpcy5fZGF0YSwgaylcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaykge1xuICB2YXIgcmVzID0gZmluZCh0aGlzLl9kYXRhLCBrKVxuICByZXR1cm4gcmVzICYmIHJlcy52YWx1ZVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrLCB2KSB7XG4gIHNldCh0aGlzLl9kYXRhLCBrLCB2KVxufVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrKSB7XG4gIHZhciByZXMgPSBmaW5kKHRoaXMuX2RhdGEsIGspXG4gIGlmIChyZXMpIHtcbiAgICBkZWxldGUgdGhpcy5fZGF0YVtyZXMuX2luZGV4XVxuICAgIHRoaXMuX2RhdGEuc2l6ZS0tXG4gIH1cbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIGRhdGEuc2l6ZSA9IDBcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19kYXRhJywge1xuICAgIHZhbHVlOiBkYXRhLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFBzZXVkb01hcC5wcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5zaXplXG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKG4pIHt9LFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pXG5cblBzZXVkb01hcC5wcm90b3R5cGUudmFsdWVzID1cblBzZXVkb01hcC5wcm90b3R5cGUua2V5cyA9XG5Qc2V1ZG9NYXAucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3JzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyB2ZXJzaW9uJylcbn1cblxuLy8gRWl0aGVyIGlkZW50aWNhbCwgb3IgYm90aCBOYU5cbmZ1bmN0aW9uIHNhbWUgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSAhPT0gYSAmJiBiICE9PSBiXG59XG5cbmZ1bmN0aW9uIEVudHJ5IChrLCB2LCBpKSB7XG4gIHRoaXMua2V5ID0ga1xuICB0aGlzLnZhbHVlID0gdlxuICB0aGlzLl9pbmRleCA9IGlcbn1cblxuZnVuY3Rpb24gZmluZCAoZGF0YSwgaykge1xuICBmb3IgKHZhciBpID0gMCwgcyA9ICdfJyArIGssIGtleSA9IHM7XG4gICAgICAgaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgICAgIGtleSA9IHMgKyBpKyspIHtcbiAgICBpZiAoc2FtZShkYXRhW2tleV0ua2V5LCBrKSlcbiAgICAgIHJldHVybiBkYXRhW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQgKGRhdGEsIGssIHYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIHMgPSAnXycgKyBrLCBrZXkgPSBzO1xuICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICAgICBrZXkgPSBzICsgaSsrKSB7XG4gICAgaWYgKHNhbWUoZGF0YVtrZXldLmtleSwgaykpIHtcbiAgICAgIGRhdGFba2V5XS52YWx1ZSA9IHZcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBkYXRhLnNpemUrK1xuICBkYXRhW2tleV0gPSBuZXcgRW50cnkoaywgdiwga2V5KVxufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMS4wXG4gKiByZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4xMS4wJztcblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMgd2l0aFxuLy8gdGVtcGxhdGUgbGl0ZXJhbCBzdHJpbmdzLiBUaGUgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4vLyBkdXJpbmcgYnVpbGQuXG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG52YXIgd2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmdXaXRob3V0U3RhY2soY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gOCkge1xuICAgICAgLy8gQ2hlY2sgYmVmb3JlIHRoZSBjb25kaXRpb24gdG8gY2F0Y2ggdmlvbGF0aW9ucyBlYXJseS5cbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FybmluZ1dpdGhvdXRTdGFjaygpIGN1cnJlbnRseSBzdXBwb3J0cyBhdCBtb3N0IDggYXJndW1lbnRzLicpO1xuICAgIH1cblxuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgICAgfSk7XG4gICAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcblxuICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5lcnJvciwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbnZhciB3YXJuaW5nV2l0aG91dFN0YWNrJDEgPSB3YXJuaW5nV2l0aG91dFN0YWNrO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcblxudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG5cbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xuXG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOyAvLyBQcmV2ZW50IG5ld2VyIHJlbmRlcmVycyBmcm9tIFJURSB3aGVuIHVzZWQgd2l0aCBvbGRlciByZWFjdCBwYWNrYWdlIHZlcnNpb25zLlxuLy8gQ3VycmVudCBvd25lciBhbmQgZGlzcGF0Y2hlciB1c2VkIHRvIHNoYXJlIHRoZSBzYW1lIHJlZixcbi8vIGJ1dCBQUiAjMTQ1NDggc3BsaXQgdGhlbSBvdXQgdG8gYmV0dGVyIHN1cHBvcnQgdGhlIHJlYWN0LWRlYnVnLXRvb2xzIHBhY2thZ2UuXG5cbmlmICghUmVhY3RTaGFyZWRJbnRlcm5hbHMuaGFzT3duUHJvcGVydHkoJ1JlYWN0Q3VycmVudERpc3BhdGNoZXInKSkge1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbn1cblxuaWYgKCFSZWFjdFNoYXJlZEludGVybmFscy5oYXNPd25Qcm9wZXJ0eSgnUmVhY3RDdXJyZW50QmF0Y2hDb25maWcnKSkge1xuICBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgICBzdXNwZW5zZTogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IHdhcm5pbmdXaXRob3V0U3RhY2skMTtcblxue1xuICB3YXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3dhcm5pbmctYW5kLWludmFyaWFudC1hcmdzXG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEuYXBwbHkodm9pZCAwLCBbZmFsc2UsIGZvcm1hdCArICclcyddLmNvbmNhdChhcmdzLCBbc3RhY2tdKSk7XG4gIH07XG59XG5cbnZhciB3YXJuaW5nJDEgPSB3YXJuaW5nO1xuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5mdW5jdGlvbiByZWZpbmVSZXNvbHZlZExhenlDb21wb25lbnQobGF6eUNvbXBvbmVudCkge1xuICByZXR1cm4gbGF6eUNvbXBvbmVudC5fc3RhdHVzID09PSBSZXNvbHZlZCA/IGxhenlDb21wb25lbnQuX3Jlc3VsdCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplTGF6eUNvbXBvbmVudFR5cGUobGF6eUNvbXBvbmVudCkge1xuICBpZiAobGF6eUNvbXBvbmVudC5fc3RhdHVzID09PSBVbmluaXRpYWxpemVkKSB7XG4gICAgbGF6eUNvbXBvbmVudC5fc3RhdHVzID0gUGVuZGluZztcbiAgICB2YXIgY3RvciA9IGxhenlDb21wb25lbnQuX2N0b3I7XG4gICAgdmFyIHRoZW5hYmxlID0gY3RvcigpO1xuICAgIGxhenlDb21wb25lbnQuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdsYXp5OiBFeHBlY3RlZCB0aGUgcmVzdWx0IG9mIGEgZHluYW1pYyBpbXBvcnQoKSBjYWxsLiAnICsgJ0luc3RlYWQgcmVjZWl2ZWQ6ICVzXFxuXFxuWW91ciBjb2RlIHNob3VsZCBsb29rIGxpa2U6IFxcbiAgJyArIFwiY29uc3QgTXlDb21wb25lbnQgPSBsYXp5KCgpID0+IGltcG9ydCgnLi9NeUNvbXBvbmVudCcpKVwiLCBtb2R1bGVPYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhenlDb21wb25lbnQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICBsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgbGF6eUNvbXBvbmVudC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgcmV0dXJuICdDb250ZXh0LkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlID0gdHlwZTtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRUaGVuYWJsZSA9IHJlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudCh0aGVuYWJsZSk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUocmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cbnZhciBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodm9pZCAwLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayQxID0gbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrO1xuXG52YXIgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHZhciBzb3VyY2VJbmZvID0gJyc7XG5cbiAgaWYgKHNvdXJjZSkge1xuICAgIHZhciBwYXRoID0gc291cmNlLmZpbGVOYW1lO1xuICAgIHZhciBmaWxlTmFtZSA9IHBhdGgucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcblxuICAgIHtcbiAgICAgIC8vIEluIERFViwgaW5jbHVkZSBjb2RlIGZvciBhIGNvbW1vbiBzcGVjaWFsIGNhc2U6XG4gICAgICAvLyBwcmVmZXIgXCJmb2xkZXIvaW5kZXguanNcIiBpbnN0ZWFkIG9mIGp1c3QgXCJpbmRleC5qc1wiLlxuICAgICAgaWYgKC9eaW5kZXhcXC4vLnRlc3QoZmlsZU5hbWUpKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHBhdGgubWF0Y2goQkVGT1JFX1NMQVNIX1JFKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB2YXIgcGF0aEJlZm9yZVNsYXNoID0gbWF0Y2hbMV07XG5cbiAgICAgICAgICBpZiAocGF0aEJlZm9yZVNsYXNoKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGhCZWZvcmVTbGFzaC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmb2xkZXJOYW1lICsgJy8nICsgZmlsZU5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc291cmNlSW5mbyA9ICcgKGF0ICcgKyBmaWxlTmFtZSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknO1xuICB9IGVsc2UgaWYgKG93bmVyTmFtZSkge1xuICAgIHNvdXJjZUluZm8gPSAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKSc7XG4gIH1cblxuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIHNvdXJjZUluZm87XG59O1xuXG4vLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gYmVnaW4tcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZSByZWR1Y2VyczpcblxuIC8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG4gLy8gVG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgZGVidWdnZXIsIHdlXG4vLyByZXBsYXkgdGhlIGJlZ2luIHBoYXNlIG9mIGEgZmFpbGVkIGNvbXBvbmVudCBpbnNpZGUgaW52b2tlR3VhcmRlZENhbGxiYWNrLlxuXG4gLy8gV2FybiBhYm91dCBkZXByZWNhdGVkLCBhc3luYy11bnNhZmUgbGlmZWN5Y2xlczsgcmVsYXRlcyB0byBSRkMgIzY6XG5cbnZhciB3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyA9IHRydWU7IC8vIEdhdGhlciBhZHZhbmNlZCB0aW1pbmcgbWV0cmljcyBmb3IgUHJvZmlsZXIgc3VidHJlZXMuXG5cbiAvLyBUcmFjZSB3aGljaCBpbnRlcmFjdGlvbnMgdHJpZ2dlciBlYWNoIGNvbW1pdC5cblxuIC8vIFNTUiBleHBlcmltZW50c1xuXG52YXIgZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlciA9IGZhbHNlO1xuIC8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG4gLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbiAvLyBEaXNhYmxlIGphdmFzY3JpcHQ6IFVSTCBzdHJpbmdzIGluIGhyZWYgZm9yIFhTUyBwcm90ZWN0aW9uLlxuXG52YXIgZGlzYWJsZUphdmFTY3JpcHRVUkxzID0gZmFsc2U7IC8vIFJlYWN0IEZpcmU6IHByZXZlbnQgdGhlIHZhbHVlIGFuZCBjaGVja2VkIGF0dHJpYnV0ZXMgZnJvbSBzeW5jaW5nXG4vLyB3aXRoIHRoZWlyIHJlbGF0ZWQgRE9NIHByb3BlcnRpZXNcblxuIC8vIFRoZXNlIEFQSXMgd2lsbCBubyBsb25nZXIgYmUgXCJ1bnN0YWJsZVwiIGluIHRoZSB1cGNvbWluZyAxNi43IHJlbGVhc2UsXG4vLyBDb250cm9sIHRoaXMgYmVoYXZpb3Igd2l0aCBhIGZsYWcgdG8gc3VwcG9ydCAxNi42IG1pbm9yIHJlbGVhc2VzIGluIHRoZSBtZWFud2hpbGUuXG5cblxuIC8vIEV4cGVyaW1lbnRhbCBSZWFjdCBGbGFyZSBldmVudCBzeXN0ZW0gYW5kIGV2ZW50IGNvbXBvbmVudHMgc3VwcG9ydC5cblxudmFyIGVuYWJsZUZsYXJlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBIb3N0IENvbXBvbmVudCBzdXBwb3J0LlxuXG52YXIgZW5hYmxlRnVuZGFtZW50YWxBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIFNjb3BlIHN1cHBvcnQuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBOZXcgQVBJIGZvciBKU1ggdHJhbnNmb3JtcyB0byB0YXJnZXQgLSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG5cbiAvLyBXZSB3aWxsIGVuZm9yY2UgbW9ja2luZyBzY2hlZHVsZXIgd2l0aCBzY2hlZHVsZXIvdW5zdGFibGVfbW9jayBhdCBzb21lIHBvaW50LiAodjE3Pylcbi8vIFRpbGwgdGhlbiwgd2Ugd2FybiBhYm91dCB0aGUgbWlzc2luZyBtb2NrLCBidXQgc3RpbGwgZmFsbGJhY2sgdG8gYSBzeW5jIG1vZGUgY29tcGF0aWJsZSB2ZXJzaW9uXG5cbiAvLyBGb3IgdGVzdHMsIHdlIGZsdXNoIHN1c3BlbnNlIGZhbGxiYWNrcyBpbiBhbiBhY3Qgc2NvcGU7XG4vLyAqZXhjZXB0KiBpbiBzb21lIG9mIG91ciBvd24gdGVzdHMsIHdoZXJlIHdlIHRlc3QgaW5jcmVtZW50YWwgbG9hZGluZyBzdGF0ZXMuXG5cbiAvLyBBZGQgYSBjYWxsYmFjayBwcm9wZXJ0eSB0byBzdXNwZW5zZSB0byBub3RpZnkgd2hpY2ggcHJvbWlzZXMgYXJlIGN1cnJlbnRseVxuLy8gaW4gdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBhbGxvd3MgcmVwb3J0aW5nIGFuZCB0cmFjaW5nIG9mIHdoYXQgaXMgY2F1c2luZ1xuLy8gdGhlIHVzZXIgdG8gc2VlIGEgbG9hZGluZyBzdGF0ZS5cbi8vIEFsc28gYWxsb3dzIGh5ZHJhdGlvbiBjYWxsYmFja3MgdG8gZmlyZSB3aGVuIGEgZGVoeWRyYXRlZCBib3VuZGFyeSBnZXRzXG4vLyBoeWRyYXRlZCBvciBkZWxldGVkLlxuXG4gLy8gUGFydCBvZiB0aGUgc2ltcGxpZmljYXRpb24gb2YgUmVhY3QuY3JlYXRlRWxlbWVudCBzbyB3ZSBjYW4gZXZlbnR1YWxseSBtb3ZlXG4vLyBmcm9tIFJlYWN0LmNyZWF0ZUVsZW1lbnQgdG8gUmVhY3QuanN4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL2Jsb2IvY3JlYXRlbGVtZW50LXJmYy90ZXh0LzAwMDAtY3JlYXRlLWVsZW1lbnQtY2hhbmdlcy5tZFxuXG5cblxudmFyIGRpc2FibGVMZWdhY3lDb250ZXh0ID0gZmFsc2U7XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDE7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbn1cblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpIHtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcblxuICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29udGV4dFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbikge1xuICB7XG4gICAgY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCAnQ29tcG9uZW50JywgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLmdldEN1cnJlbnRTdGFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgZW5vdWdoIHNsb3RzIGluIHRoaXMgY29udGV4dCB0byBzdG9yZSB0aGlzIHRocmVhZElELFxuICAvLyBmaWxsIGl0IGluIHdpdGhvdXQgbGVhdmluZyBhbnkgaG9sZXMgdG8gZW5zdXJlIHRoYXQgdGhlIFZNIG9wdGltaXplc1xuICAvLyB0aGlzIGFzIG5vbi1ob2xleSBpbmRleCBwcm9wZXJ0aWVzLlxuICAvLyAoTm90ZTogSWYgYHJlYWN0YCBwYWNrYWdlIGlzIDwgMTYuNiwgX3RocmVhZENvdW50IGlzIHVuZGVmaW5lZC4pXG4gIGZvciAodmFyIGkgPSBjb250ZXh0Ll90aHJlYWRDb3VudCB8IDA7IGkgPD0gdGhyZWFkSUQ7IGkrKykge1xuICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGRlZmF1bHRWYWx1ZSB3aGljaCBtaWdodCBub3QgYmVcbiAgICAvLyB0cnVlIGlmIHdlJ3JlIHJlbmRlcmluZyBpbnNpZGUgYSBzZWNvbmRhcnkgcmVuZGVyZXIgYnV0IHRoZXkgYXJlXG4gICAgLy8gc2Vjb25kYXJ5IGJlY2F1c2UgdGhlc2UgdXNlIGNhc2VzIGFyZSB2ZXJ5IHJhcmUuXG4gICAgY29udGV4dFtpXSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBpICsgMTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbnRleHQodHlwZSwgY29udGV4dCwgdGhyZWFkSUQsIGlzQ2xhc3MpIHtcbiAgaWYgKGlzQ2xhc3MpIHtcbiAgICB2YXIgY29udGV4dFR5cGUgPSB0eXBlLmNvbnRleHRUeXBlO1xuXG4gICAge1xuICAgICAgaWYgKCdjb250ZXh0VHlwZScgaW4gdHlwZSkge1xuICAgICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuICAgICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXModHlwZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKHR5cGUpO1xuICAgICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0VHlwZSwgdGhyZWFkSUQpO1xuICAgICAgcmV0dXJuIGNvbnRleHRUeXBlW3RocmVhZElEXTtcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZUxlZ2FjeUNvbnRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gJyArICdVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hc2tlZENvbnRleHQgPSBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICBjaGVja0NvbnRleHRUeXBlcyh0eXBlLmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRpc2FibGVMZWdhY3lDb250ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgKyAnVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX21hc2tlZENvbnRleHQgPSBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICBjaGVja0NvbnRleHRUeXBlcyh0eXBlLmNvbnRleHRUeXBlcywgX21hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9tYXNrZWRDb250ZXh0O1xuICAgIH1cbiAgfVxufVxuXG4vLyBBbGxvY2F0ZXMgYSBuZXcgaW5kZXggZm9yIGVhY2ggcmVxdWVzdC4gVHJpZXMgdG8gc3RheSBhcyBjb21wYWN0IGFzIHBvc3NpYmxlIHNvIHRoYXQgdGhlc2Vcbi8vIGluZGljZXMgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIGEgdGlnaHRseSBwYWNrZWQgYXJyYXkuIEFzIG9wcG9zZWQgdG8gYmVpbmcgdXNlZCBpbiBhIE1hcC5cbi8vIFRoZSBmaXJzdCBhbGxvY2F0ZWQgaW5kZXggaXMgMS5cbnZhciBuZXh0QXZhaWxhYmxlVGhyZWFkSURzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbaV0gPSBpICsgMTtcbn1cblxubmV4dEF2YWlsYWJsZVRocmVhZElEc1sxNV0gPSAwO1xuXG5mdW5jdGlvbiBncm93VGhyZWFkQ291bnRBbmRSZXR1cm5OZXh0QXZhaWxhYmxlKCkge1xuICB2YXIgb2xkQXJyYXkgPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzO1xuICB2YXIgb2xkU2l6ZSA9IG9sZEFycmF5Lmxlbmd0aDtcbiAgdmFyIG5ld1NpemUgPSBvbGRTaXplICogMjtcblxuICBpZiAoIShuZXdTaXplIDw9IDB4MTAwMDApKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoXCJNYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IFJlYWN0IHJlbmRlcmVycyBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbm90IHByb3Blcmx5IGRlc3Ryb3lpbmcgdGhlIFJlYWRhYmxlIHByb3ZpZGVkIGJ5IFJlYWN0LiBFbnN1cmUgdGhhdCB5b3UgY2FsbCAuZGVzdHJveSgpIG9uIGl0IGlmIHlvdSBubyBsb25nZXIgd2FudCB0byByZWFkIGZyb20gaXQsIGFuZCBkaWQgbm90IHJlYWQgdG8gdGhlIGVuZC4gSWYgeW91IHVzZSAucGlwZSgpIHRoaXMgc2hvdWxkIGJlIGF1dG9tYXRpYy5cIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQxNkFycmF5KG5ld1NpemUpO1xuICBuZXdBcnJheS5zZXQob2xkQXJyYXkpO1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzID0gbmV3QXJyYXk7XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBvbGRTaXplICsgMTtcblxuICBmb3IgKHZhciBfaSA9IG9sZFNpemU7IF9pIDwgbmV3U2l6ZSAtIDE7IF9pKyspIHtcbiAgICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW19pXSA9IF9pICsgMTtcbiAgfVxuXG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbbmV3U2l6ZSAtIDFdID0gMDtcbiAgcmV0dXJuIG9sZFNpemU7XG59XG5cbmZ1bmN0aW9uIGFsbG9jVGhyZWFkSUQoKSB7XG4gIHZhciBuZXh0SUQgPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdO1xuXG4gIGlmIChuZXh0SUQgPT09IDApIHtcbiAgICByZXR1cm4gZ3Jvd1RocmVhZENvdW50QW5kUmV0dXJuTmV4dEF2YWlsYWJsZSgpO1xuICB9XG5cbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbbmV4dElEXTtcbiAgcmV0dXJuIG5leHRJRDtcbn1cbmZ1bmN0aW9uIGZyZWVUaHJlYWRJRChpZCkge1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW2lkXSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF07XG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBpZDtcbn1cblxuLy8gQSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4vLyBJdCBpcyBoYW5kbGVkIGJ5IFJlYWN0IHNlcGFyYXRlbHkgYW5kIHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG52YXIgUkVTRVJWRUQgPSAwOyAvLyBBIHNpbXBsZSBzdHJpbmcgYXR0cmlidXRlLlxuLy8gQXR0cmlidXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgd2hpdGVsaXN0IGFyZSBwcmVzdW1lZCB0byBoYXZlIHRoaXMgdHlwZS5cblxudmFyIFNUUklORyA9IDE7IC8vIEEgc3RyaW5nIGF0dHJpYnV0ZSB0aGF0IGFjY2VwdHMgYm9vbGVhbnMgaW4gUmVhY3QuIEluIEhUTUwsIHRoZXNlIGFyZSBjYWxsZWRcbi8vIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgd2l0aCBcInRydWVcIiBhbmQgXCJmYWxzZVwiIGFzIHBvc3NpYmxlIHZhbHVlcy5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwidHJ1ZVwiIHN0cmluZy5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcImZhbHNlXCIgc3RyaW5nLlxuXG52YXIgQk9PTEVBTklTSF9TVFJJTkcgPSAyOyAvLyBBIHJlYWwgYm9vbGVhbiBhdHRyaWJ1dGUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cblxudmFyIEJPT0xFQU4gPSAzOyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBwcmVzZW50IChzZXQgZWl0aGVyIHRvIGFuIGVtcHR5IHN0cmluZyBvciBpdHMgbmFtZSkuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgb21pdHRlZC5cbi8vIEZvciBhbnkgb3RoZXIgdmFsdWUsIHNob3VsZCBiZSBwcmVzZW50IHdpdGggdGhhdCB2YWx1ZS5cblxudmFyIE9WRVJMT0FERURfQk9PTEVBTiA9IDQ7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIE5VTUVSSUMgPSA1OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBQT1NJVElWRV9OVU1FUklDID0gNjtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaGFzT3duUHJvcGVydHkkMS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2FuaXRpemVVUkwgPSBzYW5pdGl6ZVVSTDtcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cblsnY2hpbGRyZW4nLCAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLCAvLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnLCAnaW5uZXJIVE1MJywgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLCAnc3R5bGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlKTtcbn0pOyAvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cblxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJywgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywgJ2Zvcm1Ob1ZhbGlkYXRlJywgJ2hpZGRlbicsICdsb29wJywgJ25vTW9kdWxlJywgJ25vVmFsaWRhdGUnLCAnb3BlbicsICdwbGF5c0lubGluZScsICdyZWFkT25seScsICdyZXF1aXJlZCcsICdyZXZlcnNlZCcsICdzY29wZWQnLCAnc2VhbWxlc3MnLCAvLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5cblsnY2FwdHVyZScsICdkb3dubG9hZCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuXG5bJ2NvbHMnLCAncm93cycsICdzaXplJywgJ3NwYW4nXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFBPU0lUSVZFX05VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlKTtcbn0pO1xudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xuXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07IC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIHdoaXRlbGlzdC5cbi8vIFNvbWUgb2YgdGhlc2UgYXR0cmlidXRlcyBjYW4gYmUgaGFyZCB0byBmaW5kLiBUaGlzIGxpc3Qgd2FzIGNyZWF0ZWQgYnlcbi8vIHNjcmFwcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5cblxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeGxpbmsgbmFtZXNwYWNlLlxuXG5bJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuXG5bJ3RhYkluZGV4JywgJ2Nyb3NzT3JpZ2luJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXR0cmlidXRlcyBhY2NlcHQgVVJMcy4gVGhlc2UgbXVzdCBub3QgYWxsb3cgamF2YXNjcmlwdDogVVJMUy5cbi8vIFRoZXNlIHdpbGwgYWxzbyBuZWVkIHRvIGFjY2VwdCBUcnVzdGVkIFR5cGVzIG9iamVjdCBpbiB0aGUgZnV0dXJlLlxuXG52YXIgeGxpbmtIcmVmID0gJ3hsaW5rSHJlZic7XG5wcm9wZXJ0aWVzW3hsaW5rSHJlZl0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKCd4bGlua0hyZWYnLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbid4bGluazpocmVmJywgJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCB0cnVlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUpO1xufSk7XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDIgPSBudWxsO1xuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59IC8vIEEgamF2YXNjcmlwdDogVVJMIGNhbiBjb250YWluIGxlYWRpbmcgQzAgY29udHJvbCBvciBcXHUwMDIwIFNQQUNFLFxuLy8gYW5kIGFueSBuZXdsaW5lIG9yIHRhYiBhcmUgZmlsdGVyZWQgb3V0IGFzIGlmIHRoZXkncmUgbm90IHBhcnQgb2YgdGhlIFVSTC5cbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmdcbi8vIFRhYiBvciBuZXdsaW5lIGFyZSBkZWZpbmVkIGFzIFxcclxcblxcdDpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNhc2NpaS10YWItb3ItbmV3bGluZVxuLy8gQSBDMCBjb250cm9sIGlzIGEgY29kZSBwb2ludCBpbiB0aGUgcmFuZ2UgXFx1MDAwMCBOVUxMIHRvIFxcdTAwMUZcbi8vIElORk9STUFUSU9OIFNFUEFSQVRPUiBPTkUsIGluY2x1c2l2ZTpcbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjMC1jb250cm9sLW9yLXNwYWNlXG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAgaWYgKGRpc2FibGVKYXZhU2NyaXB0VVJMcykge1xuICAgIGlmICghIWlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlJlYWN0IGhhcyBibG9ja2VkIGEgamF2YXNjcmlwdDogVVJMIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi5cIiArIChSZWFjdERlYnVnQ3VycmVudEZyYW1lJDIuZ2V0U3RhY2tBZGRlbmR1bSgpKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHRydWUgJiYgIWRpZFdhcm4gJiYgaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdCh1cmwpKSB7XG4gICAgZGlkV2FybiA9IHRydWU7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gIH1cbn1cblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG4vKipcbiAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBIVE1MIGVudGl0aWVzIGluIGEgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgSFRNTCBzdHJpbmcgdG8gZXNjYXBlIGZvciBsYXRlciBpbnNlcnRpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXg7XG4gIHZhciBsYXN0SW5kZXggPSAwO1xuXG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIC8vIFwiXG4gICAgICAgIGVzY2FwZSA9ICcmcXVvdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59IC8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yUm9vdCgpIHtcbiAgcmV0dXJuIFJPT1RfQVRUUklCVVRFX05BTUUgKyAnPVwiXCInO1xufVxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5zYW5pdGl6ZVVSTCkge1xuICAgICAgICB2YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICAgIHNhbml0aXplVVJMKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIGVtcHR5IHN0cmluZyBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgaXMkMSA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBpcyBhIHJlLXJlbmRlcmVkIGhvb2tcblxudmFyIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBkdXJpbmcgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyIHBhc3MuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIExhemlseSBjcmVhdGVkIG1hcCBvZiByZW5kZXItcGhhc2UgdXBkYXRlc1xuXG52YXIgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDsgLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuXG52YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1O1xudmFyIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlOyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG5mdW5jdGlvbiByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCkge1xuICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAhIWlzSW5Ib29rVXNlckNvZGVJbkRldiA/IHdhcm5pbmckMShmYWxzZSwgJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcnVsZXMtb2YtaG9va3MnKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzJDEobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvb2soKSB7XG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBpZiAoZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlSG9vaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICAgIGlzUmVSZW5kZXIgPSB0cnVlO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9PT0gbnVsbCkge1xuICAgICAgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IGNvbXBvbmVudElkZW50aXR5O1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfSAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG59XG5mdW5jdGlvbiBmaW5pc2hIb29rcyhDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbiwgcmVmT3JDb250ZXh0KSB7XG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgZnVuY3Rpb24gY29tcG9uZW50IHRvIHByZXZlbnQgaG9va3MgZnJvbVxuICAvLyBiZWluZyB1c2VkIGluIGNsYXNzZXMuXG4gIHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVXBkYXRlcyB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhleSBhcmUgc3RvcmVkIGluXG4gICAgLy8gdGhlIGByZW5kZXJQaGFzZVVwZGF0ZXNgIG1hcC4gQ2FsbCB0aGUgY29tcG9uZW50IGFnYWluLCByZXVzaW5nIHRoZVxuICAgIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9va3MgYW5kIGFwcGx5aW5nIHRoZSBhZGRpdGlvbmFsIHVwZGF0ZXMgb24gdG9wLiBLZWVwXG4gICAgLy8gcmVzdGFydGluZyB1bnRpbCBubyBtb3JlIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZC5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTsgLy8gU3RhcnQgb3ZlciBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcblxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHJlZk9yQ29udGV4dCk7XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xuICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gVGhlc2Ugd2VyZSByZXNldCBhYm92ZVxuICAvLyBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgLy8gbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgdmFyIHRocmVhZElEID0gY3VycmVudFRocmVhZElEO1xuICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuXG4gIHtcbiAgICAhIWlzSW5Ib29rVXNlckNvZGVJbkRldiA/IHdhcm5pbmckMShmYWxzZSwgJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHRbdGhyZWFkSURdO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gIH1cblxuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHZhciB0aHJlYWRJRCA9IGN1cnJlbnRUaHJlYWRJRDtcbiAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcbiAgcmV0dXJuIGNvbnRleHRbdGhyZWFkSURdO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gIH1cblxuICByZXR1cm4gdXNlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlciwgLy8gdXNlUmVkdWNlciBoYXMgYSBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBsYXp5IHVzZVN0YXRlIGluaXRpYWxpemVyc1xuICBpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHtcbiAgICBpZiAocmVkdWNlciAhPT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGlzUmVSZW5kZXIpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIC8vIGN1cnJlbnQgaG9vay5cbiAgICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWU7XG4gICAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5kZWxldGUocXVldWUpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgICBpZiAocmVkdWNlciA9PT0gYmFzaWNTdGF0ZVJlZHVjZXIpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYHVzZVN0YXRlYC5cbiAgICAgIGluaXRpYWxTdGF0ZSA9IHR5cGVvZiBpbml0aWFsQXJnID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbEFyZygpIDogaW5pdGlhbEFyZztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbFN0YXRlID0gaW5pdCAhPT0gdW5kZWZpbmVkID8gaW5pdChpbml0aWFsQXJnKSA6IGluaXRpYWxBcmc7XG4gICAgfVxuXG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbiAgICB2YXIgX3F1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlID0ge1xuICAgICAgbGFzdDogbnVsbCxcbiAgICAgIGRpc3BhdGNoOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBfZGlzcGF0Y2ggPSBfcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCwgX3F1ZXVlKTtcblxuICAgIHJldHVybiBbd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUsIF9kaXNwYXRjaF07XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTWVtbyhuZXh0Q3JlYXRlLCBkZXBzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHByZXZpb3VzUmVmID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZpb3VzUmVmID09PSBudWxsKSB7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICAgIH07XG5cbiAgICB7XG4gICAgICBPYmplY3Quc2VhbChyZWYpO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICAgIHJldHVybiByZWY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZpb3VzUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjcmVhdGUsIGlucHV0cykge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgfVxuXG4gIHdhcm5pbmckMShmYWxzZSwgJ3VzZUxheW91dEVmZmVjdCBkb2VzIG5vdGhpbmcgb24gdGhlIHNlcnZlciwgYmVjYXVzZSBpdHMgZWZmZWN0IGNhbm5vdCAnICsgXCJiZSBlbmNvZGVkIGludG8gdGhlIHNlcnZlciByZW5kZXJlcidzIG91dHB1dCBmb3JtYXQuIFRoaXMgd2lsbCBsZWFkIFwiICsgJ3RvIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgaW5pdGlhbCwgbm9uLWh5ZHJhdGVkIFVJIGFuZCB0aGUgaW50ZW5kZWQgJyArICdVSS4gVG8gYXZvaWQgdGhpcywgdXNlTGF5b3V0RWZmZWN0IHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gJyArICdjb21wb25lbnRzIHRoYXQgcmVuZGVyIGV4Y2x1c2l2ZWx5IG9uIHRoZSBjbGllbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdXNlbGF5b3V0ZWZmZWN0LXNzciBmb3IgY29tbW9uIGZpeGVzLicpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihjb21wb25lbnRJZGVudGl0eSwgcXVldWUsIGFjdGlvbikge1xuICBpZiAoIShudW1iZXJPZlJlUmVuZGVycyA8IFJFX1JFTkRFUl9MSU1JVCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihcIlRvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLlwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCkge1xuICAgIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuICAgIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgICAvLyBhbmQgYXBwbHkgdGhlIHN0YXNoZWQgdXBkYXRlcyBvbiB0b3Agb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICB3aGlsZSAobGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH1cbiAgfSBlbHNlIHsvLyBUaGlzIG1lYW5zIGFuIHVwZGF0ZSBoYXMgaGFwcGVuZWQgYWZ0ZXIgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBoYXNcbiAgICAvLyByZXR1cm5lZC4gT24gdGhlIHNlcnZlciB0aGlzIGlzIGEgbm8tb3AuIEluIFJlYWN0IEZpYmVyLCB0aGUgdXBkYXRlXG4gICAgLy8gd291bGQgYmUgc2NoZWR1bGVkIGZvciBhIGZ1dHVyZSByZW5kZXIuXG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgLy8gQ2FsbGJhY2tzIGFyZSBwYXNzZWQgYXMgdGhleSBhcmUgaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiB1c2VSZXNwb25kZXIocmVzcG9uZGVyLCBwcm9wcykge1xuICByZXR1cm4ge1xuICAgIHByb3BzOiBwcm9wcyxcbiAgICByZXNwb25kZXI6IHJlc3BvbmRlclxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBjb25maWcpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oY29uZmlnKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcblxuICB2YXIgc3RhcnRUcmFuc2l0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfTtcblxuICByZXR1cm4gW3N0YXJ0VHJhbnNpdGlvbiwgZmFsc2VdO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGN1cnJlbnRUaHJlYWRJRCA9IDA7XG5mdW5jdGlvbiBzZXRDdXJyZW50VGhyZWFkSUQodGhyZWFkSUQpIHtcbiAgY3VycmVudFRocmVhZElEID0gdGhyZWFkSUQ7XG59XG52YXIgRGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDb250ZXh0OiB1c2VDb250ZXh0LFxuICB1c2VNZW1vOiB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICB1c2VSZWY6IHVzZVJlZixcbiAgdXNlU3RhdGU6IHVzZVN0YXRlLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVzZUxheW91dEVmZmVjdCxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICAvLyB1c2VJbXBlcmF0aXZlSGFuZGxlIGlzIG5vdCBydW4gaW4gdGhlIHNlcnZlciBlbnZpcm9ubWVudFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBub29wLFxuICAvLyBFZmZlY3RzIGFyZSBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHVzZUVmZmVjdDogbm9vcCxcbiAgLy8gRGVidWdnaW5nIGVmZmVjdFxuICB1c2VEZWJ1Z1ZhbHVlOiBub29wLFxuICB1c2VSZXNwb25kZXI6IHVzZVJlc3BvbmRlcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdXNlVHJhbnNpdGlvbjogdXNlVHJhbnNpdGlvblxufTtcblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07IC8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cblxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfSAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cblxuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDMgPSBudWxsO1xudmFyIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzID0ge1xuICBjaGVja1Byb3BUeXBlczogbnVsbFxufTtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDMgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICB2YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgICBidXR0b246IHRydWUsXG4gICAgY2hlY2tib3g6IHRydWUsXG4gICAgaW1hZ2U6IHRydWUsXG4gICAgaGlkZGVuOiB0cnVlLFxuICAgIHJhZGlvOiB0cnVlLFxuICAgIHJlc2V0OiB0cnVlLFxuICAgIHN1Ym1pdDogdHJ1ZVxuICB9O1xuICB2YXIgcHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCB8fCBlbmFibGVGbGFyZUFQSSAmJiBwcm9wcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAocHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHNbcHJvcE5hbWVdID09IG51bGwgfHwgZW5hYmxlRmxhcmVBUEkgJiYgcHJvcHMubGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAgICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAgICovXG5cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMpIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMy5nZXRTdGFja0FkZGVuZHVtKTtcbiAgfTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG4vLyBvciBhZGQgc3RhY2sgYnkgZGVmYXVsdCB0byBpbnZhcmlhbnRzIHdoZXJlIHBvc3NpYmxlLlxuXG52YXIgSFRNTCA9ICdfX2h0bWwnO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkNCA9IG51bGw7XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQ0ID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cblxuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IodGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiArIChSZWFjdERlYnVnQ3VycmVudEZyYW1lJDQuZ2V0U3RhY2tBZGRlbmR1bSgpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgIShwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IHdhcm5pbmckMShmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHZvaWQgMDtcbiAgfVxuXG4gIGlmICghKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIiArIChSZWFjdERlYnVnQ3VycmVudEZyYW1lJDQuZ2V0U3RhY2tBZGRlbmR1bSgpKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGNvbHVtbnM6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkQXJlYTogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG5cblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTsgLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcblxuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovXG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgd2hpdGVsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcbiAgdmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nOyAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgY2FtZWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIC8vIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAgICAvLyAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gICAgLy8gaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICAgIGNhbWVsaXplKG5hbWUucmVwbGFjZShtc1BhdHRlcm4kMSwgJ21zLScpKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkRm9ySW5maW5pdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LicsIG5hbWUpO1xuICB9O1xuXG4gIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlJDEgPSB3YXJuVmFsaWRTdHlsZTtcblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eSQyLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJywgbmFtZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cblxuXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xuXG4vKipcbiAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICovXG5cblxuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICovXG5cblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG5cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG5cblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAqIG9ubHkgaW4gdHJ1ZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTsgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuXG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIHdoaXRlbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgKyAnUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgdHlwZW9mIHZhbHVlKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIG5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEOyAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4nLCBuYW1lLCBsb3dlckNhc2VkTmFtZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgY2FuVXNlRXZlbnRTeXN0ZW0pO1xuXG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvcicsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvcicsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKTtcbn1cblxudmFyIHRvQXJyYXkgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5OyAvLyBUaGlzIGlzIG9ubHkgdXNlZCBpbiBERVYuXG4vLyBFYWNoIGVudHJ5IGlzIGB0aGlzLnN0YWNrYCBmcm9tIGEgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXJlciBpbnN0YW5jZS5cbi8vIChUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBiZWNhdXNlIFJlYWN0RE9NU2VydmVyIGlzIHJlZW50cmFudCkuXG4vLyBFYWNoIHN0YWNrIGlzIGFuIGFycmF5IG9mIGZyYW1lcyB3aGljaCBtYXkgY29udGFpbiBuZXN0ZWQgc3RhY2tzIG9mIGVsZW1lbnRzLlxuXG52YXIgY3VycmVudERlYnVnU3RhY2tzID0gW107XG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IG51bGw7XG5cbnZhciBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJyc7XG59O1xuXG52YXIgZGVzY3JpYmVTdGFja0ZyYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHt9O1xuXG52YXIgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7fTtcblxudmFyIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnQpIHt9O1xuXG52YXIgcG9wQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG4gIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcyxcbiAgICAvKiBjYW5Vc2VFdmVudFN5c3RlbSAqL1xuICAgIGZhbHNlKTtcbiAgfTtcblxuICBkZXNjcmliZVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKTtcbiAgfTtcblxuICBwdXNoQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucHVzaChzdGFjayk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gV2UgYXJlIGVudGVyaW5nIGEgc2VydmVyIHJlbmRlcmVyLlxuICAgICAgLy8gUmVtZW1iZXIgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbDtcbiAgICB9XG4gIH07XG5cbiAgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2sgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIEZvciB0aGUgaW5uZXJtb3N0IGV4ZWN1dGluZyBSZWFjdERPTVNlcnZlciBjYWxsLFxuICAgIHZhciBzdGFjayA9IGN1cnJlbnREZWJ1Z1N0YWNrc1tjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoIC0gMV07IC8vIFRha2UgdGhlIGlubmVybW9zdCBleGVjdXRpbmcgZnJhbWUgKGUuZy4gPEZvbz4pLFxuXG4gICAgdmFyIGZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07IC8vIGFuZCByZWNvcmQgdGhhdCBpdCBoYXMgb25lIG1vcmUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggaXQuXG5cbiAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjay5wdXNoKGVsZW1lbnQpOyAvLyBXZSBvbmx5IG5lZWQgdGhpcyBiZWNhdXNlIHdlIHRhaWwtb3B0aW1pemUgc2luZ2xlLWVsZW1lbnRcbiAgICAvLyBjaGlsZHJlbiBhbmQgZGlyZWN0bHkgaGFuZGxlIHRoZW0gaW4gYW4gaW5uZXIgbG9vcCBpbnN0ZWFkIG9mXG4gICAgLy8gY3JlYXRpbmcgc2VwYXJhdGUgZnJhbWVzIGZvciB0aGVtLlxuICB9O1xuXG4gIHBvcEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnREZWJ1Z1N0YWNrcy5wb3AoKTtcblxuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBXZSBhcmUgZXhpdGluZyB0aGUgc2VydmVyIHJlbmRlcmVyLlxuICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgKGUuZy4gY2xpZW50KSBnbG9iYWwgc3RhY2sgaW1wbGVtZW50YXRpb24uXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IHByZXZHZXRDdXJyZW50U3RhY2tJbXBsO1xuICAgICAgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSByZW5kZXJpbmcuXG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBSZWFjdERPTVNlcnZlciBpcyByZWVudHJhbnQgc28gdGhlcmUgbWF5IGJlIG11bHRpcGxlIGNhbGxzIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgLy8gVGFrZSB0aGUgZnJhbWVzIGZyb20gdGhlIGlubmVybW9zdCBjYWxsIHdoaWNoIGlzIHRoZSBsYXN0IGluIHRoZSBhcnJheS5cblxuXG4gICAgdmFyIGZyYW1lcyA9IGN1cnJlbnREZWJ1Z1N0YWNrc1tjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoIC0gMV07XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEdvIHRocm91Z2ggZXZlcnkgZnJhbWUgaW4gdGhlIHN0YWNrIGZyb20gdGhlIGlubmVybW9zdCBvbmUuXG5cbiAgICBmb3IgKHZhciBpID0gZnJhbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZnJhbWUgPSBmcmFtZXNbaV07IC8vIEV2ZXJ5IGZyYW1lIG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBkZWJ1ZyBlbGVtZW50IHN0YWNrIGVudHJ5IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBzaW5nbGUtY2hpbGQgbmVzdGluZyBkb2Vzbid0IGNyZWF0ZSBtYXRlcmlhbGl6ZWQgZnJhbWVzLlxuICAgICAgLy8gSW5zdGVhZCBpdCB3b3VsZCBwdXNoIHRoZW0gdGhyb3VnaCBgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soKWAuXG5cbiAgICAgIHZhciBkZWJ1Z0VsZW1lbnRTdGFjayA9IGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrO1xuXG4gICAgICBmb3IgKHZhciBpaSA9IGRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCAtIDE7IGlpID49IDA7IGlpLS0pIHtcbiAgICAgICAgc3RhY2sgKz0gZGVzY3JpYmVTdGFja0ZyYW1lKGRlYnVnRWxlbWVudFN0YWNrW2lpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG52YXIgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZSA9IHt9O1xudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgbGlzdGluZzogdHJ1ZSxcbiAgcHJlOiB0cnVlLFxuICB0ZXh0YXJlYTogdHJ1ZVxufTsgLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcblxudmFyIHZhbGlkYXRlZFRhZ0NhY2hlID0ge307XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIXZhbGlkYXRlZFRhZ0NhY2hlLmhhc093blByb3BlcnR5KHRhZykpIHtcbiAgICBpZiAoIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbnZhciBzdHlsZU5hbWVDYWNoZSA9IHt9O1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgaWYgKHN0eWxlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICByZXR1cm4gc3R5bGVOYW1lQ2FjaGVbc3R5bGVOYW1lXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbiAgc3R5bGVOYW1lQ2FjaGVbc3R5bGVOYW1lXSA9IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclN0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgdmFyIGRlbGltaXRlciA9ICcnO1xuXG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG5cbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgKGlzQ3VzdG9tUHJvcGVydHkgPyBzdHlsZU5hbWUgOiBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkpICsgJzonO1xuICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiBnZXRDb21wb25lbnROYW1lKF9jb25zdHJ1Y3RvcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBnZXROb25DaGlsZHJlbklubmVyTWFya3VwKHByb3BzKSB7XG4gIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MLl9faHRtbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvbnRlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Ub3BMZXZlbENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoY2hpbGRyZW4pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjaGlsZHJlbjtcblxuICBpZiAoZWxlbWVudC50eXBlICE9PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgcmV0dXJuIFtlbGVtZW50XTtcbiAgfVxuXG4gIHZhciBmcmFnbWVudENoaWxkcmVuID0gZWxlbWVudC5wcm9wcy5jaGlsZHJlbjtcblxuICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGZyYWdtZW50Q2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZnJhZ21lbnRDaGlsZHJlbik7XG4gIH1cblxuICB2YXIgZnJhZ21lbnRDaGlsZEVsZW1lbnQgPSBmcmFnbWVudENoaWxkcmVuO1xuICByZXR1cm4gW2ZyYWdtZW50Q2hpbGRFbGVtZW50XTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNoaWxkICE9PSAnbnVtYmVyJykge1xuICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IG51bGwsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogbnVsbCxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiBudWxsXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVPcGVuVGFnTWFya3VwKHRhZ1ZlcmJhdGltLCB0YWdMb3dlcmNhc2UsIHByb3BzLCBuYW1lc3BhY2UsIG1ha2VTdGF0aWNNYXJrdXAsIGlzUm9vdEVsZW1lbnQpIHtcbiAgdmFyIHJldCA9ICc8JyArIHRhZ1ZlcmJhdGltO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocHJvcHMsIHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoZW5hYmxlRmxhcmVBUEkgJiYgcHJvcEtleSA9PT0gJ2xpc3RlbmVycycpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBwcm9wVmFsdWUgPSBjcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgbWFya3VwID0gbnVsbDtcblxuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0YWdMb3dlcmNhc2UsIHByb3BzKSkge1xuICAgICAgaWYgKCFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBtYXJrdXAgPSBjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAobWFya3VwKSB7XG4gICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgIH1cbiAgfSAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgLy8gYnl0ZXMuXG5cblxuICBpZiAobWFrZVN0YXRpY01hcmt1cCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoaXNSb290RWxlbWVudCkge1xuICAgIHJldCArPSAnICcgKyBjcmVhdGVNYXJrdXBGb3JSb290KCk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgdHlwZSkge1xuICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCcpICsgXCIoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoY2hpbGQsIGNvbnRleHQsIHRocmVhZElEKSB7XG4gIHdoaWxlIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAvLyBTYWZlIGJlY2F1c2Ugd2UganVzdCBjaGVja2VkIGl0J3MgYW4gZWxlbWVudC5cbiAgICB2YXIgZWxlbWVudCA9IGNoaWxkO1xuICAgIHZhciBDb21wb25lbnQgPSBlbGVtZW50LnR5cGU7XG5cbiAgICB7XG4gICAgICBwdXNoRWxlbWVudFRvRGVidWdTdGFjayhlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0NoaWxkKGVsZW1lbnQsIENvbXBvbmVudCk7XG4gIH0gLy8gRXh0cmEgY2xvc3VyZSBzbyBxdWV1ZSBhbmQgcmVwbGFjZSBjYW4gYmUgY2FwdHVyZWQgcHJvcGVybHlcblxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDaGlsZChlbGVtZW50LCBDb21wb25lbnQpIHtcbiAgICB2YXIgaXNDbGFzcyA9IHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gcHJvY2Vzc0NvbnRleHQoQ29tcG9uZW50LCBjb250ZXh0LCB0aHJlYWRJRCwgaXNDbGFzcyk7XG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHJlcGxhY2UgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRlciA9IHtcbiAgICAgIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICAgICAgcmVwbGFjZSA9IHRydWU7XG4gICAgICAgIHF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgICAgfSxcbiAgICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjdXJyZW50UGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXVlLnB1c2goY3VycmVudFBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW5zdDtcblxuICAgIGlmIChpc0NsYXNzKSB7XG4gICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcblxuICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaW5zdC5zdGF0ZSA9PT0gbnVsbCB8fCBpbnN0LnN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3Quc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuY2FsbChudWxsLCBlbGVtZW50LnByb3BzLCBpbnN0LnN0YXRlKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBfY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZVtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBfYXNzaWduKHt9LCBpbnN0LnN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICAgICAgcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgaW5zdCA9IENvbXBvbmVudChlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVyKTtcbiAgICAgIGluc3QgPSBmaW5pc2hIb29rcyhDb21wb25lbnQsIGVsZW1lbnQucHJvcHMsIGluc3QsIHB1YmxpY0NvbnRleHQpO1xuXG4gICAgICBpZiAoaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBpbnN0O1xuICAgICAgICB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgQ29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZTMsIF9jb21wb25lbnROYW1lMywgX2NvbXBvbmVudE5hbWUzKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lM10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5wcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuXG4gICAgaWYgKGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0LnN0YXRlID0gaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh3YXJuQWJvdXREZXByZWNhdGVkTGlmZWN5Y2xlcyAmJiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWU0ID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIC8vIGtlZXAgdGhpcyB3YXJuaW5nIGluIHN5bmMgd2l0aCBSZWFjdFN0cmljdE1vZGVXYXJuaW5nLmpzXG4gICAgICAgICAgICAgICdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgJyArICdvciB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfY29tcG9uZW50TmFtZTQpO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBhbnkgY29tcG9uZW50IHdpdGggdGhlIG5ldyBnRFNGUC5cblxuXG4gICAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgYW55IGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgZ0RTRlAuXG4gICAgICAgIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBvbGRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICB2YXIgb2xkUmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgICAgcmVwbGFjZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChvbGRSZXBsYWNlICYmIG9sZFF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGluc3Quc3RhdGUgPSBvbGRRdWV1ZVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gb2xkUmVwbGFjZSA/IG9sZFF1ZXVlWzBdIDogaW5zdC5zdGF0ZTtcbiAgICAgICAgICB2YXIgZG9udE11dGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gb2xkUmVwbGFjZSA/IDEgOiAwOyBpIDwgb2xkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gb2xkUXVldWVbaV07XG5cbiAgICAgICAgICAgIHZhciBfcGFydGlhbFN0YXRlID0gdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBlbGVtZW50LnByb3BzLCBwdWJsaWNDb250ZXh0KSA6IHBhcnRpYWw7XG5cbiAgICAgICAgICAgIGlmIChfcGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGRvbnRNdXRhdGUpIHtcbiAgICAgICAgICAgICAgICBkb250TXV0YXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlID0gX2Fzc2lnbih7fSwgbmV4dFN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfYXNzaWduKG5leHRTdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBpbnN0LnJlbmRlcigpO1xuXG4gICAge1xuICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQgJiYgaW5zdC5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgIGNoaWxkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgQ29tcG9uZW50KTtcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xuXG4gICAgaWYgKGRpc2FibGVMZWdhY3lDb250ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgICAgICBpZiAoY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIHVzZXMgdGhlIGxlZ2FjeSBjaGlsZENvbnRleHRUeXBlcyBBUEkgd2hpY2ggaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gJyArICdVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0LmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgX2NoaWxkQ29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX2NoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkQ29udGV4dCA9IGluc3QuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBfY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gX2Fzc2lnbih7fSwgY29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoaWxkOiBjaGlsZCxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH07XG59XG5cbnZhciBSZWFjdERPTVNlcnZlclJlbmRlcmVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogdHlwZSB0aGlzIG1vcmUgc3RyaWN0bHk6XG4gIC8vIERFVi1vbmx5XG4gIGZ1bmN0aW9uIFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoY2hpbGRyZW4sIG1ha2VTdGF0aWNNYXJrdXApIHtcbiAgICB2YXIgZmxhdENoaWxkcmVuID0gZmxhdHRlblRvcExldmVsQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIHZhciB0b3BGcmFtZSA9IHtcbiAgICAgIHR5cGU6IG51bGwsXG4gICAgICAvLyBBc3N1bWUgYWxsIHRyZWVzIHN0YXJ0IGluIHRoZSBIVE1MIG5hbWVzcGFjZSAobm90IHRvdGFsbHkgdHJ1ZSwgYnV0XG4gICAgICAvLyB0aGlzIGlzIHdoYXQgd2UgZGlkIGhpc3RvcmljYWxseSlcbiAgICAgIGRvbU5hbWVzcGFjZTogTmFtZXNwYWNlcy5odG1sLFxuICAgICAgY2hpbGRyZW46IGZsYXRDaGlsZHJlbixcbiAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICBjb250ZXh0OiBlbXB0eU9iamVjdCxcbiAgICAgIGZvb3RlcjogJydcbiAgICB9O1xuXG4gICAge1xuICAgICAgdG9wRnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnRocmVhZElEID0gYWxsb2NUaHJlYWRJRCgpO1xuICAgIHRoaXMuc3RhY2sgPSBbdG9wRnJhbWVdO1xuICAgIHRoaXMuZXhoYXVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgIHRoaXMubWFrZVN0YXRpY01hcmt1cCA9IG1ha2VTdGF0aWNNYXJrdXA7XG4gICAgdGhpcy5zdXNwZW5zZURlcHRoID0gMDsgLy8gQ29udGV4dCAobmV3IEFQSSlcblxuICAgIHRoaXMuY29udGV4dEluZGV4ID0gLTE7XG4gICAgdGhpcy5jb250ZXh0U3RhY2sgPSBbXTtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrID0gW107XG5cbiAgICB7XG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrID0gW107XG4gICAgfVxuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuZXhoYXVzdGVkKSB7XG4gICAgICB0aGlzLmV4aGF1c3RlZCA9IHRydWU7XG4gICAgICB0aGlzLmNsZWFyUHJvdmlkZXJzKCk7XG4gICAgICBmcmVlVGhyZWFkSUQodGhpcy50aHJlYWRJRCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBOb3RlOiBXZSB1c2UganVzdCB0d28gc3RhY2tzIHJlZ2FyZGxlc3Mgb2YgaG93IG1hbnkgY29udGV4dCBwcm92aWRlcnMgeW91IGhhdmUuXG4gICAqIFByb3ZpZGVycyBhcmUgYWx3YXlzIHBvcHBlZCBpbiB0aGUgcmV2ZXJzZSBvcmRlciB0byBob3cgdGhleSB3ZXJlIHB1c2hlZFxuICAgKiBzbyB3ZSBhbHdheXMga25vdyBvbiB0aGUgd2F5IGRvd24gd2hpY2ggcHJvdmlkZXIgeW91J2xsIGVuY291bnRlciBuZXh0IG9uIHRoZSB3YXkgdXAuXG4gICAqIE9uIHRoZSB3YXkgZG93biwgd2UgcHVzaCB0aGUgY3VycmVudCBwcm92aWRlciwgYW5kIGl0cyBjb250ZXh0IHZhbHVlICpiZWZvcmUqXG4gICAqIHdlIG11dGF0ZWQgaXQsIG9udG8gdGhlIHN0YWNrcy4gVGhlcmVmb3JlLCBvbiB0aGUgd2F5IHVwLCB3ZSBhbHdheXMga25vdyB3aGljaFxuICAgKiBwcm92aWRlciBuZWVkcyB0byBiZSBcInJlc3RvcmVkXCIgdG8gd2hpY2ggdmFsdWUuXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEyOTg1I2lzc3VlY29tbWVudC0zOTYzMDEyNDhcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucHVzaFByb3ZpZGVyID0gZnVuY3Rpb24gcHVzaFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gKyt0aGlzLmNvbnRleHRJbmRleDtcbiAgICB2YXIgY29udGV4dCA9IHByb3ZpZGVyLnR5cGUuX2NvbnRleHQ7XG4gICAgdmFyIHRocmVhZElEID0gdGhpcy50aHJlYWRJRDtcbiAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gY29udGV4dFt0aHJlYWRJRF07IC8vIFJlbWVtYmVyIHdoaWNoIHZhbHVlIHRvIHJlc3RvcmUgdGhpcyBjb250ZXh0IHRvIG9uIG91ciB3YXkgdXAuXG5cbiAgICB0aGlzLmNvbnRleHRTdGFja1tpbmRleF0gPSBjb250ZXh0O1xuICAgIHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdID0gcHJldmlvdXNWYWx1ZTtcblxuICAgIHtcbiAgICAgIC8vIE9ubHkgdXNlZCBmb3IgcHVzaC9wb3AgbWlzbWF0Y2ggd2FybmluZ3MuXG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSA9IHByb3ZpZGVyO1xuICAgIH0gLy8gTXV0YXRlIHRoZSBjdXJyZW50IHZhbHVlLlxuXG5cbiAgICBjb250ZXh0W3RocmVhZElEXSA9IHByb3ZpZGVyLnByb3BzLnZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5wb3BQcm92aWRlciA9IGZ1bmN0aW9uIHBvcFByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0SW5kZXg7XG5cbiAgICB7XG4gICAgICAhKGluZGV4ID4gLTEgJiYgcHJvdmlkZXIgPT09IHRoaXMuY29udGV4dFByb3ZpZGVyU3RhY2tbaW5kZXhdKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF07IC8vIFwiSGlkZVwiIHRoZXNlIG51bGwgYXNzaWdubWVudHMgZnJvbSBGbG93IGJ5IHVzaW5nIGBhbnlgXG4gICAgLy8gYmVjYXVzZSBjb25jZXB0dWFsbHkgdGhleSBhcmUgZGVsZXRpb25zLS1hcyBsb25nIGFzIHdlXG4gICAgLy8gcHJvbWlzZSB0byBuZXZlciBhY2Nlc3MgdmFsdWVzIGJleW9uZCBgdGhpcy5jb250ZXh0SW5kZXhgLlxuXG4gICAgdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAgICB7XG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0SW5kZXgtLTsgLy8gUmVzdG9yZSB0byB0aGUgcHJldmlvdXMgdmFsdWUgd2Ugc3RvcmVkIGFzIHdlIHdlcmUgd2Fsa2luZyBkb3duLlxuICAgIC8vIFdlJ3ZlIGFscmVhZHkgdmVyaWZpZWQgdGhhdCB0aGlzIGNvbnRleHQgaGFzIGJlZW4gZXhwYW5kZWQgdG8gYWNjb21tb2RhdGVcbiAgICAvLyB0aGlzIHRocmVhZCBpZCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBpdCBhZ2Fpbi5cblxuICAgIGNvbnRleHRbdGhpcy50aHJlYWRJRF0gPSBwcmV2aW91c1ZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5jbGVhclByb3ZpZGVycyA9IGZ1bmN0aW9uIGNsZWFyUHJvdmlkZXJzKCkge1xuICAgIC8vIFJlc3RvcmUgYW55IHJlbWFpbmluZyBwcm92aWRlcnMgb24gdGhlIHN0YWNrIHRvIHByZXZpb3VzIHZhbHVlc1xuICAgIGZvciAodmFyIGluZGV4ID0gdGhpcy5jb250ZXh0SW5kZXg7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdO1xuICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XTtcbiAgICAgIGNvbnRleHRbdGhpcy50aHJlYWRJRF0gPSBwcmV2aW91c1ZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVhZCA9IGZ1bmN0aW9uIHJlYWQoYnl0ZXMpIHtcbiAgICBpZiAodGhpcy5leGhhdXN0ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwcmV2VGhyZWFkSUQgPSBjdXJyZW50VGhyZWFkSUQ7XG4gICAgc2V0Q3VycmVudFRocmVhZElEKHRoaXMudGhyZWFkSUQpO1xuICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBEaXNwYXRjaGVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIE1hcmt1cCBnZW5lcmF0ZWQgd2l0aGluIDxTdXNwZW5zZT4gZW5kcyB1cCBidWZmZXJlZCB1bnRpbCB3ZSBrbm93XG4gICAgICAvLyBub3RoaW5nIGluIHRoYXQgYm91bmRhcnkgc3VzcGVuZGVkXG4gICAgICB2YXIgb3V0ID0gWycnXTtcbiAgICAgIHZhciBzdXNwZW5kZWQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKG91dFswXS5sZW5ndGggPCBieXRlcykge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLmV4aGF1c3RlZCA9IHRydWU7XG4gICAgICAgICAgZnJlZVRocmVhZElEKHRoaXMudGhyZWFkSUQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChzdXNwZW5kZWQgfHwgZnJhbWUuY2hpbGRJbmRleCA+PSBmcmFtZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZm9vdGVyID0gZnJhbWUuZm9vdGVyO1xuXG4gICAgICAgICAgaWYgKGZvb3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoZnJhbWUudHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgIT0gbnVsbCAmJiBmcmFtZS50eXBlLnR5cGUgIT0gbnVsbCAmJiBmcmFtZS50eXBlLnR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICAgIHZhciBwcm92aWRlciA9IGZyYW1lLnR5cGU7XG4gICAgICAgICAgICB0aGlzLnBvcFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lLnR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUpIHtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuc2VEZXB0aC0tO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlcmVkID0gb3V0LnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAoc3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHN1c3BlbmRlZCA9IGZhbHNlOyAvLyBJZiByZW5kZXJpbmcgd2FzIHN1c3BlbmRlZCBhdCB0aGlzIGJvdW5kYXJ5LCByZW5kZXIgdGhlIGZhbGxiYWNrRnJhbWVcblxuICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tGcmFtZSA9IGZyYW1lLmZhbGxiYWNrRnJhbWU7XG5cbiAgICAgICAgICAgICAgaWYgKCFmYWxsYmFja0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdERPTVNlcnZlciBkaWQgbm90IGZpbmQgYW4gaW50ZXJuYWwgZmFsbGJhY2sgZnJhbWUgZm9yIFN1c3BlbnNlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZhbGxiYWNrRnJhbWUpO1xuICAgICAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSAnPCEtLSQhLS0+JzsgLy8gU2tpcCBmbHVzaGluZyBvdXRwdXQgc2luY2Ugd2UncmUgc3dpdGNoaW5nIHRvIHRoZSBmYWxsYmFja1xuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gYnVmZmVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBGbHVzaCBvdXRwdXRcblxuXG4gICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gZm9vdGVyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gZnJhbWUuY2hpbGRyZW5bZnJhbWUuY2hpbGRJbmRleCsrXTtcbiAgICAgICAgdmFyIG91dEJ1ZmZlciA9ICcnO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBwdXNoQ3VycmVudERlYnVnU3RhY2sodGhpcy5zdGFjayk7IC8vIFdlJ3JlIHN0YXJ0aW5nIHdvcmsgb24gdGhpcyBmcmFtZSwgc28gcmVzZXQgaXRzIGlubmVyIHN0YWNrLlxuXG4gICAgICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0QnVmZmVyICs9IHRoaXMucmVuZGVyKGNoaWxkLCBmcmFtZS5jb250ZXh0LCBmcmFtZS5kb21OYW1lc3BhY2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwgJiYgdHlwZW9mIGVyci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICAgICAgICBpZiAoISh0aGlzLnN1c3BlbnNlRGVwdGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSBSZWFjdCBjb21wb25lbnQgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuXFxuQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byBwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3VzcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IFN1c3BlbnNlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwb3BDdXJyZW50RGVidWdTdGFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXQubGVuZ3RoIDw9IHRoaXMuc3VzcGVuc2VEZXB0aCkge1xuICAgICAgICAgIG91dC5wdXNoKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IG91dEJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dFswXTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICBzZXRDdXJyZW50VGhyZWFkSUQocHJldlRocmVhZElEKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjaGlsZCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHRleHQgPSAnJyArIGNoaWxkO1xuXG4gICAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYWtlU3RhdGljTWFya3VwKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSkge1xuICAgICAgICByZXR1cm4gJzwhLS0gLS0+JyArIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dENoaWxkO1xuXG4gICAgICB2YXIgX3Jlc29sdmUgPSByZXNvbHZlKGNoaWxkLCBjb250ZXh0LCB0aGlzLnRocmVhZElEKTtcblxuICAgICAgbmV4dENoaWxkID0gX3Jlc29sdmUuY2hpbGQ7XG4gICAgICBjb250ZXh0ID0gX3Jlc29sdmUuY29udGV4dDtcblxuICAgICAgaWYgKG5leHRDaGlsZCA9PT0gbnVsbCB8fCBuZXh0Q2hpbGQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gZWxzZSBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRDaGlsZCkpIHtcbiAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIG5leHRDaGlsZC4kJHR5cGVvZiAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ2F0Y2ggdW5leHBlY3RlZCBzcGVjaWFsIHR5cGVzIGVhcmx5LlxuICAgICAgICAgIHZhciAkJHR5cGVvZiA9IG5leHRDaGlsZC4kJHR5cGVvZjtcblxuICAgICAgICAgIGlmICghKCQkdHlwZW9mICE9PSBSRUFDVF9QT1JUQUxfVFlQRSkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJQb3J0YWxzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgc2VydmVyIHJlbmRlcmVyLiBSZW5kZXIgdGhlbSBjb25kaXRpb25hbGx5IHNvIHRoYXQgdGhleSBvbmx5IGFwcGVhciBvbiB0aGUgY2xpZW50IHJlbmRlci5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDYXRjaC1hbGwgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIGlmIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoKSBzdXBwb3J0cyBzb21lIG5ldyB0eXBlLlxuXG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBlbGVtZW50LWxpa2Ugb2JqZWN0IHR5cGU6IFwiICsgJCR0eXBlb2YudG9TdHJpbmcoKSArIFwiLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB0b0FycmF5KG5leHRDaGlsZCk7XG4gICAgICAgIHZhciBmcmFtZSA9IHtcbiAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgIGNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgfTtcblxuICAgICAgICB7XG4gICAgICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChmcmFtZSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gLy8gU2FmZSBiZWNhdXNlIHdlIGp1c3QgY2hlY2tlZCBpdCdzIGFuIGVsZW1lbnQuXG5cblxuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkO1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbmV4dEVsZW1lbnQudHlwZTtcblxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRE9NKG5leHRFbGVtZW50LCBjb250ZXh0LCBwYXJlbnROYW1lc3BhY2UpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGVsZW1lbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuID0gdG9BcnJheShuZXh0Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICB2YXIgX2ZyYW1lID0ge1xuICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW4sXG4gICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2ZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrID0gbmV4dENoaWxkLnByb3BzLmZhbGxiYWNrO1xuXG4gICAgICAgICAgICAgIGlmIChmYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gZmFsbGJhY2ssIHRoZW4gdGhpcyBqdXN0IGJlaGF2ZXMgYXMgYSBmcmFnbWVudC5cbiAgICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjMgPSB0b0FycmF5KG5leHRDaGlsZC5wcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lMyA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuMyxcbiAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUzLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTMpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBmYWxsYmFja0NoaWxkcmVuID0gdG9BcnJheShmYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4yID0gdG9BcnJheShuZXh0Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICAgIHZhciBmYWxsYmFja0ZyYW1lID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGZhbGxiYWNrQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJzwhLS0vJC0tPidcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTIgPSB7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tGcmFtZTogZmFsbGJhY2tGcmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBSRUFDVF9TVVNQRU5TRV9UWVBFLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuMixcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnPCEtLS8kLS0+J1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWUyLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tGcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTIpO1xuICAgICAgICAgICAgICB0aGlzLnN1c3BlbnNlRGVwdGgrKztcbiAgICAgICAgICAgICAgcmV0dXJuICc8IS0tJC0tPic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBTdXNwZW5zZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGVsZW1lbnRUeXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IG5leHRDaGlsZDtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjQ7XG5cbiAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gICAgICAgICAgICAgIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjQgPSBlbGVtZW50VHlwZS5yZW5kZXIoZWxlbWVudC5wcm9wcywgZWxlbWVudC5yZWYpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNCA9IGZpbmlzaEhvb2tzKGVsZW1lbnRUeXBlLnJlbmRlciwgZWxlbWVudC5wcm9wcywgX25leHRDaGlsZHJlbjQsIGVsZW1lbnQucmVmKTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjQgPSB0b0FycmF5KF9uZXh0Q2hpbGRyZW40KTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjQsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNC5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTQpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGVtZW50ID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjUgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChlbGVtZW50VHlwZS50eXBlLCBfYXNzaWduKHtcbiAgICAgICAgICAgICAgICByZWY6IF9lbGVtZW50LnJlZlxuICAgICAgICAgICAgICB9LCBfZWxlbWVudC5wcm9wcykpXTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjUsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTUpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIG5leHRQcm9wcyA9IHByb3ZpZGVyLnByb3BzO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNiA9IHRvQXJyYXkobmV4dFByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm92aWRlcixcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjYsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNi5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5wdXNoUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNik7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcmVhY3RDb250ZXh0ID0gbmV4dENoaWxkLnR5cGU7IC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAgICAgICAgICAgICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAgICAgICAgICAgICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgICAgICAgICAgICAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgICAgICAgICAgICAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgICAgICAgICAgICAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gICAgICAgICAgICAgIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWN0Q29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgICAgICAgICAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgICAgICAgICAgICAgIGlmIChyZWFjdENvbnRleHQgIT09IHJlYWN0Q29udGV4dC5Db25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVuZGVyaW5nIDxDb250ZXh0PiBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlYWN0Q29udGV4dCA9IHJlYWN0Q29udGV4dC5fY29udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgX25leHRQcm9wcyA9IG5leHRDaGlsZC5wcm9wcztcbiAgICAgICAgICAgICAgdmFyIHRocmVhZElEID0gdGhpcy50aHJlYWRJRDtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKHJlYWN0Q29udGV4dCwgdGhyZWFkSUQpO1xuICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gcmVhY3RDb250ZXh0W3RocmVhZElEXTtcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjcgPSB0b0FycmF5KF9uZXh0UHJvcHMuY2hpbGRyZW4obmV4dFZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTcgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogbmV4dENoaWxkLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuNyxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU3LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNyk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGVuYWJsZUZ1bmRhbWVudGFsQVBJKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZ1bmRhbWVudGFsSW1wbCA9IGVsZW1lbnRUeXBlLmltcGw7XG4gICAgICAgICAgICAgICAgdmFyIG9wZW4gPSBmdW5kYW1lbnRhbEltcGwuZ2V0U2VydmVyU2lkZVN0cmluZyhudWxsLCBuZXh0RWxlbWVudC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgdmFyIGdldFNlcnZlclNpZGVTdHJpbmdDbG9zZSA9IGZ1bmRhbWVudGFsSW1wbC5nZXRTZXJ2ZXJTaWRlU3RyaW5nQ2xvc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNsb3NlID0gZ2V0U2VydmVyU2lkZVN0cmluZ0Nsb3NlICE9PSB1bmRlZmluZWQgPyBnZXRTZXJ2ZXJTaWRlU3RyaW5nQ2xvc2UobnVsbCwgbmV4dEVsZW1lbnQucHJvcHMpIDogJyc7XG5cbiAgICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjggPSBmdW5kYW1lbnRhbEltcGwucmVjb25jaWxlQ2hpbGRyZW4gIT09IGZhbHNlID8gdG9BcnJheShuZXh0Q2hpbGQucHJvcHMuY2hpbGRyZW4pIDogW107XG5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lOCA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuOCxcbiAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgZm9vdGVyOiBjbG9zZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWU4LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcGVuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgdGhlIGZ1bmRhbWVudGFsIEFQSS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGVtZW50MiA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSBuZXh0Q2hpbGQudHlwZTsgLy8gQXR0ZW1wdCB0byBpbml0aWFsaXplIGxhenkgY29tcG9uZW50IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVcbiAgICAgICAgICAgICAgLy8gc3VzcGVuc2Ugc2VydmVyLXNpZGUgcmVuZGVyZXIgaXMgZW5hYmxlZCBzbyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgIC8vIHJlc29sdmVkIGNvbnN0cnVjdG9ycyBhcmUgc3VwcG9ydGVkLlxuXG4gICAgICAgICAgICAgIGluaXRpYWxpemVMYXp5Q29tcG9uZW50VHlwZShsYXp5Q29tcG9uZW50KTtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKGxhenlDb21wb25lbnQuX3N0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgUmVzb2x2ZWQ6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuOSA9IFtSZWFjdC5jcmVhdGVFbGVtZW50KGxhenlDb21wb25lbnQuX3Jlc3VsdCwgX2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgcmVmOiBfZWxlbWVudDIucmVmXG4gICAgICAgICAgICAgICAgICAgIH0sIF9lbGVtZW50Mi5wcm9wcykpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZTkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjksXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lOS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlIFJlamVjdGVkOlxuICAgICAgICAgICAgICAgICAgdGhyb3cgbGF6eUNvbXBvbmVudC5fcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgY2FzZSBQZW5kaW5nOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IGxhenktbG9hZGVkIGNvbXBvbmVudHMuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZW5hYmxlU2NvcGVBUEkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjEwID0gdG9BcnJheShuZXh0Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZTEwID0ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW4xMCxcbiAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUxMC5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUxMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgc2NvcGUgY29tcG9uZW50cy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAge1xuICAgICAgICB2YXIgb3duZXIgPSBuZXh0RWxlbWVudC5fb3duZXI7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyhlbGVtZW50VHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lcikgOiBudWxsO1xuXG4gICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICsgKGVsZW1lbnRUeXBlID09IG51bGwgPyBlbGVtZW50VHlwZSA6IHR5cGVvZiBlbGVtZW50VHlwZSkgKyBcIi5cIiArIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXJET00gPSBmdW5jdGlvbiByZW5kZXJET00oZWxlbWVudCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gICAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBuYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBOYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIG5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IE5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgICAgISh0YWcgPT09IGVsZW1lbnQudHlwZSkgPyB3YXJuaW5nJDEoZmFsc2UsICc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgZWxlbWVudC50eXBlKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICAgIHZhciBwcm9wcyA9IGVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnKSB7XG4gICAgICB7XG4gICAgICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSkge1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICAgIH0sIHByb3BzLCB7XG4gICAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICB2YWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgICAgICBjaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgICB7XG4gICAgICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlKSB7XG4gICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gICAgICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTsgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cblxuICAgICAgICB2YXIgdGV4dGFyZWFDaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIGlmICh0ZXh0YXJlYUNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRleHRhcmVhQ2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBpZiAoISh0ZXh0YXJlYUNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRhcmVhQ2hpbGRyZW4gPSB0ZXh0YXJlYUNoaWxkcmVuWzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgdGV4dGFyZWFDaGlsZHJlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGNoaWxkcmVuOiAnJyArIGluaXRpYWxWYWx1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB7XG4gICAgICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuXG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcblxuICAgICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLicsIHByb3BOYW1lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLicsIHByb3BOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSkge1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRTZWxlY3RWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICBwcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnb3B0aW9uJykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICAgIHZhciBzZWxlY3RWYWx1ZSA9IHRoaXMuY3VycmVudFNlbGVjdFZhbHVlO1xuICAgICAgdmFyIG9wdGlvbkNoaWxkcmVuID0gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSArICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gb3B0aW9uQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbal0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdGVkID0gJycgKyBzZWxlY3RWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcyA9IF9hc3NpZ24oe1xuICAgICAgICAgIHNlbGVjdGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgICAgICB9LCBwcm9wcywge1xuICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICBjaGlsZHJlbjogb3B0aW9uQ2hpbGRyZW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHByb3BzKTtcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpO1xuICAgIHZhciBvdXQgPSBjcmVhdGVPcGVuVGFnTWFya3VwKGVsZW1lbnQudHlwZSwgdGFnLCBwcm9wcywgbmFtZXNwYWNlLCB0aGlzLm1ha2VTdGF0aWNNYXJrdXAsIHRoaXMuc3RhY2subGVuZ3RoID09PSAxKTtcbiAgICB2YXIgZm9vdGVyID0gJyc7XG5cbiAgICBpZiAob21pdHRlZENsb3NlVGFncy5oYXNPd25Qcm9wZXJ0eSh0YWcpKSB7XG4gICAgICBvdXQgKz0gJy8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9ICc+JztcbiAgICAgIGZvb3RlciA9ICc8LycgKyBlbGVtZW50LnR5cGUgKyAnPic7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuO1xuICAgIHZhciBpbm5lck1hcmt1cCA9IGdldE5vbkNoaWxkcmVuSW5uZXJNYXJrdXAocHJvcHMpO1xuXG4gICAgaWYgKGlubmVyTWFya3VwICE9IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuID0gW107XG5cbiAgICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0YWddICYmIGlubmVyTWFya3VwLmNoYXJBdCgwKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgICAvLyBhIG5ld2xpbmUgc3BlY2lmaWNhbGx5IHRvIGdldCBlYXRlbiBieSB0aGUgcGFyc2VyLiAoQWx0ZXJuYXRlbHkgZm9yXG4gICAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwtcG9seWdsb3QvI25ld2xpbmVzLWluLXRleHRhcmVhLWFuZC1wcmU+XG4gICAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgICAgLy8gU2VlOiBQYXJzaW5nIG9mIFwidGV4dGFyZWFcIiBcImxpc3RpbmdcIiBhbmQgXCJwcmVcIiBlbGVtZW50c1xuICAgICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgICAgb3V0ICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICBvdXQgKz0gaW5uZXJNYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuID0gdG9BcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgdmFyIGZyYW1lID0ge1xuICAgICAgZG9tTmFtZXNwYWNlOiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIGVsZW1lbnQudHlwZSksXG4gICAgICB0eXBlOiB0YWcsXG4gICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGZvb3RlcjogZm9vdGVyXG4gICAgfTtcblxuICAgIHtcbiAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgfVxuXG4gICAgdGhpcy5zdGFjay5wdXNoKGZyYW1lKTtcbiAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIHJldHVybiBSZWFjdERPTVNlcnZlclJlbmRlcmVyO1xufSgpO1xuXG4vKipcbiAqIFJlbmRlciBhIFJlYWN0RWxlbWVudCB0byBpdHMgaW5pdGlhbCBIVE1MLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gdGhlXG4gKiBzZXJ2ZXIuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0cmluZ1xuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGVsZW1lbnQpIHtcbiAgdmFyIHJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgZmFsc2UpO1xuXG4gIHRyeSB7XG4gICAgdmFyIG1hcmt1cCA9IHJlbmRlcmVyLnJlYWQoSW5maW5pdHkpO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH0gZmluYWxseSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICB9XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gcmVuZGVyVG9TdHJpbmcsIGV4Y2VwdCB0aGlzIGRvZXNuJ3QgY3JlYXRlIGV4dHJhIERPTSBhdHRyaWJ1dGVzXG4gKiBzdWNoIGFzIGRhdGEtcmVhY3QtaWQgdGhhdCBSZWFjdCB1c2VzIGludGVybmFsbHkuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b3N0YXRpY21hcmt1cFxuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTWFya3VwKGVsZW1lbnQpIHtcbiAgdmFyIHJlbmRlcmVyID0gbmV3IFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoZWxlbWVudCwgdHJ1ZSk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbWFya3VwID0gcmVuZGVyZXIucmVhZChJbmZpbml0eSk7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSBmaW5hbGx5IHtcbiAgICByZW5kZXJlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWRhYmxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0sIF9SZWFkYWJsZSk7XG5cbiAgZnVuY3Rpb24gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCBtYWtlU3RhdGljTWFya3VwKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgLy8gQ2FsbHMgdGhlIHN0cmVhbS5SZWFkYWJsZShvcHRpb25zKSBjb25zdHJ1Y3Rvci4gQ29uc2lkZXIgZXhwb3NpbmcgYnVpbHQtaW5cbiAgICAvLyBmZWF0dXJlcyBsaWtlIGhpZ2hXYXRlck1hcmsgaW4gdGhlIGZ1dHVyZS5cbiAgICBfdGhpcyA9IF9SZWFkYWJsZS5jYWxsKHRoaXMsIHt9KSB8fCB0aGlzO1xuICAgIF90aGlzLnBhcnRpYWxSZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIG1ha2VTdGF0aWNNYXJrdXApO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2Rlc3Ryb3kgPSBmdW5jdGlvbiBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5wYXJ0aWFsUmVuZGVyZXIuZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG5cbiAgX3Byb3RvLl9yZWFkID0gZnVuY3Rpb24gX3JlYWQoc2l6ZSkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnB1c2godGhpcy5wYXJ0aWFsUmVuZGVyZXIucmVhZChzaXplKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW07XG59KHN0cmVhbS5SZWFkYWJsZSk7XG4vKipcbiAqIFJlbmRlciBhIFJlYWN0RWxlbWVudCB0byBpdHMgaW5pdGlhbCBIVE1MLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gdGhlXG4gKiBzZXJ2ZXIuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWRvbS1zZXJ2ZXIuaHRtbCNyZW5kZXJ0b25vZGVzdHJlYW1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbmRlclRvTm9kZVN0cmVhbShlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCBmYWxzZSk7XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gcmVuZGVyVG9Ob2RlU3RyZWFtLCBleGNlcHQgdGhpcyBkb2Vzbid0IGNyZWF0ZSBleHRyYSBET00gYXR0cmlidXRlc1xuICogc3VjaCBhcyBkYXRhLXJlYWN0LWlkIHRoYXQgUmVhY3QgdXNlcyBpbnRlcm5hbGx5LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdGF0aWNub2Rlc3RyZWFtXG4gKi9cblxuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtKGVsZW1lbnQsIHRydWUpO1xufVxuXG52YXIgUmVhY3RET01TZXJ2ZXJOb2RlID0ge1xuICByZW5kZXJUb1N0cmluZzogcmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiByZW5kZXJUb1N0YXRpY01hcmt1cCxcbiAgcmVuZGVyVG9Ob2RlU3RyZWFtOiByZW5kZXJUb05vZGVTdHJlYW0sXG4gIHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbTogcmVuZGVyVG9TdGF0aWNOb2RlU3RyZWFtLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb25cbn07XG5cbnZhciBSZWFjdERPTVNlcnZlck5vZGUkMSA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVNlcnZlck5vZGVcbn0pO1xuXG52YXIgUmVhY3RET01TZXJ2ZXIgPSAoIFJlYWN0RE9NU2VydmVyTm9kZSQxICYmIFJlYWN0RE9NU2VydmVyTm9kZSApIHx8IFJlYWN0RE9NU2VydmVyTm9kZSQxO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdFxuXG5cbnZhciBzZXJ2ZXJfbm9kZSA9IFJlYWN0RE9NU2VydmVyLmRlZmF1bHQgfHwgUmVhY3RET01TZXJ2ZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gc2VydmVyX25vZGU7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zZXJ2ZXIubm9kZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTEuMFxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSk7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHZvaWQgMCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2skMSA9IGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjaztcblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlO1xuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgeyBSb3V0ZXIsIF9fUm91dGVyQ29udGV4dCwgbWF0Y2hQYXRoIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmV4cG9ydCAqIGZyb20gJ3JlYWN0LXJvdXRlcic7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVMb2NhdGlvbiB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgSFRNTDUgaGlzdG9yeS5cbiAqL1xuXG52YXIgQnJvd3NlclJvdXRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShCcm93c2VyUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBCcm93c2VyUm91dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVCcm93c2VySGlzdG9yeShfdGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgICBoaXN0b3J5OiB0aGlzLmhpc3RvcnksXG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBCcm93c2VyUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBmb3JjZVJlZnJlc2g6IFByb3BUeXBlcy5ib29sLFxuICAgIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlclxuICB9O1xuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8QnJvd3NlclJvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgd2luZG93LmxvY2F0aW9uLmhhc2guXG4gKi9cblxudmFyIEhhc2hSb3V0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSGFzaFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSGFzaFJvdXRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGFzaEhpc3RvcnkoX3RoaXMucHJvcHMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBIYXNoUm91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSGFzaFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBIYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaGFzaFR5cGU6IFByb3BUeXBlcy5vbmVPZihbXCJoYXNoYmFuZ1wiLCBcIm5vc2xhc2hcIiwgXCJzbGFzaFwiXSlcbiAgfTtcblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPEhhc2hSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBIYXNoUm91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciByZXNvbHZlVG9Mb2NhdGlvbiA9IGZ1bmN0aW9uIHJlc29sdmVUb0xvY2F0aW9uKHRvLCBjdXJyZW50TG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJmdW5jdGlvblwiID8gdG8oY3VycmVudExvY2F0aW9uKSA6IHRvO1xufTtcbnZhciBub3JtYWxpemVUb0xvY2F0aW9uID0gZnVuY3Rpb24gbm9ybWFsaXplVG9Mb2NhdGlvbih0bywgY3VycmVudExvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBjcmVhdGVMb2NhdGlvbih0bywgbnVsbCwgbnVsbCwgY3VycmVudExvY2F0aW9uKSA6IHRvO1xufTtcblxudmFyIGZvcndhcmRSZWZTaGltID0gZnVuY3Rpb24gZm9yd2FyZFJlZlNoaW0oQykge1xuICByZXR1cm4gQztcbn07XG5cbnZhciBmb3J3YXJkUmVmID0gUmVhY3QuZm9yd2FyZFJlZjtcblxuaWYgKHR5cGVvZiBmb3J3YXJkUmVmID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIGZvcndhcmRSZWYgPSBmb3J3YXJkUmVmU2hpbTtcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhIShldmVudC5tZXRhS2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KTtcbn1cblxudmFyIExpbmtBbmNob3IgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmLCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIGlubmVyUmVmID0gX3JlZi5pbm5lclJlZixcbiAgICAgIG5hdmlnYXRlID0gX3JlZi5uYXZpZ2F0ZSxcbiAgICAgIF9vbkNsaWNrID0gX3JlZi5vbkNsaWNrLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImlubmVyUmVmXCIsIFwibmF2aWdhdGVcIiwgXCJvbkNsaWNrXCJdKTtcblxuICB2YXIgdGFyZ2V0ID0gcmVzdC50YXJnZXQ7XG5cbiAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoX29uQ2xpY2spIF9vbkNsaWNrKGV2ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgLy8gb25DbGljayBwcmV2ZW50ZWQgZGVmYXVsdFxuICAgICAgZXZlbnQuYnV0dG9uID09PSAwICYmICggLy8gaWdub3JlIGV2ZXJ5dGhpbmcgYnV0IGxlZnQgY2xpY2tzXG4gICAgICAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJiAvLyBsZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gaWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgbmF2aWdhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIFJlYWN0IDE1IGNvbXBhdFxuXG5cbiAgaWYgKGZvcndhcmRSZWZTaGltICE9PSBmb3J3YXJkUmVmKSB7XG4gICAgcHJvcHMucmVmID0gZm9yd2FyZGVkUmVmIHx8IGlubmVyUmVmO1xuICB9IGVsc2Uge1xuICAgIHByb3BzLnJlZiA9IGlubmVyUmVmO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHByb3BzKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIExpbmtBbmNob3IuZGlzcGxheU5hbWUgPSBcIkxpbmtBbmNob3JcIjtcbn1cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5cblxudmFyIExpbmsgPSBmb3J3YXJkUmVmKGZ1bmN0aW9uIChfcmVmMiwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBfcmVmMiRjb21wb25lbnQgPSBfcmVmMi5jb21wb25lbnQsXG4gICAgICBjb21wb25lbnQgPSBfcmVmMiRjb21wb25lbnQgPT09IHZvaWQgMCA/IExpbmtBbmNob3IgOiBfcmVmMiRjb21wb25lbnQsXG4gICAgICByZXBsYWNlID0gX3JlZjIucmVwbGFjZSxcbiAgICAgIHRvID0gX3JlZjIudG8sXG4gICAgICBpbm5lclJlZiA9IF9yZWYyLmlubmVyUmVmLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYyLCBbXCJjb21wb25lbnRcIiwgXCJyZXBsYWNlXCIsIFwidG9cIiwgXCJpbm5lclJlZlwiXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoX19Sb3V0ZXJDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8TGluaz4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICB2YXIgaGlzdG9yeSA9IGNvbnRleHQuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVUb0xvY2F0aW9uKHJlc29sdmVUb0xvY2F0aW9uKHRvLCBjb250ZXh0LmxvY2F0aW9uKSwgY29udGV4dC5sb2NhdGlvbik7XG4gICAgdmFyIGhyZWYgPSBsb2NhdGlvbiA/IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbikgOiBcIlwiO1xuXG4gICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGhyZWY6IGhyZWYsXG4gICAgICBuYXZpZ2F0ZTogZnVuY3Rpb24gbmF2aWdhdGUoKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlc29sdmVUb0xvY2F0aW9uKHRvLCBjb250ZXh0LmxvY2F0aW9uKTtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHJlcGxhY2UgPyBoaXN0b3J5LnJlcGxhY2UgOiBoaXN0b3J5LnB1c2g7XG4gICAgICAgIG1ldGhvZChsb2NhdGlvbik7XG4gICAgICB9XG4gICAgfSk7IC8vIFJlYWN0IDE1IGNvbXBhdFxuXG5cbiAgICBpZiAoZm9yd2FyZFJlZlNoaW0gIT09IGZvcndhcmRSZWYpIHtcbiAgICAgIHByb3BzLnJlZiA9IGZvcndhcmRlZFJlZiB8fCBpbm5lclJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMuaW5uZXJSZWYgPSBpbm5lclJlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcbiAgfSk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICB2YXIgdG9UeXBlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmZ1bmNdKTtcbiAgdmFyIHJlZlR5cGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiBQcm9wVHlwZXMuYW55XG4gIH0pXSk7XG4gIExpbmsuZGlzcGxheU5hbWUgPSBcIkxpbmtcIjtcbiAgTGluay5wcm9wVHlwZXMgPSB7XG4gICAgaW5uZXJSZWY6IHJlZlR5cGUsXG4gICAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcmVwbGFjZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRvOiB0b1R5cGUuaXNSZXF1aXJlZFxuICB9O1xufVxuXG52YXIgZm9yd2FyZFJlZlNoaW0kMSA9IGZ1bmN0aW9uIGZvcndhcmRSZWZTaGltKEMpIHtcbiAgcmV0dXJuIEM7XG59O1xuXG52YXIgZm9yd2FyZFJlZiQxID0gUmVhY3QuZm9yd2FyZFJlZjtcblxuaWYgKHR5cGVvZiBmb3J3YXJkUmVmJDEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgZm9yd2FyZFJlZiQxID0gZm9yd2FyZFJlZlNoaW0kMTtcbn1cblxuZnVuY3Rpb24gam9pbkNsYXNzbmFtZXMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjbGFzc25hbWVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGNsYXNzbmFtZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gY2xhc3NuYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gaTtcbiAgfSkuam9pbihcIiBcIik7XG59XG4vKipcbiAqIEEgPExpbms+IHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5cblxudmFyIE5hdkxpbmsgPSBmb3J3YXJkUmVmJDEoZnVuY3Rpb24gKF9yZWYsIGZvcndhcmRlZFJlZikge1xuICB2YXIgX3JlZiRhcmlhQ3VycmVudCA9IF9yZWZbXCJhcmlhLWN1cnJlbnRcIl0sXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWYkYXJpYUN1cnJlbnQgPT09IHZvaWQgMCA/IFwicGFnZVwiIDogX3JlZiRhcmlhQ3VycmVudCxcbiAgICAgIF9yZWYkYWN0aXZlQ2xhc3NOYW1lID0gX3JlZi5hY3RpdmVDbGFzc05hbWUsXG4gICAgICBhY3RpdmVDbGFzc05hbWUgPSBfcmVmJGFjdGl2ZUNsYXNzTmFtZSA9PT0gdm9pZCAwID8gXCJhY3RpdmVcIiA6IF9yZWYkYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgYWN0aXZlU3R5bGUgPSBfcmVmLmFjdGl2ZVN0eWxlLFxuICAgICAgY2xhc3NOYW1lUHJvcCA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgZXhhY3QgPSBfcmVmLmV4YWN0LFxuICAgICAgaXNBY3RpdmVQcm9wID0gX3JlZi5pc0FjdGl2ZSxcbiAgICAgIGxvY2F0aW9uUHJvcCA9IF9yZWYubG9jYXRpb24sXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIHN0eWxlUHJvcCA9IF9yZWYuc3R5bGUsXG4gICAgICB0byA9IF9yZWYudG8sXG4gICAgICBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiYXJpYS1jdXJyZW50XCIsIFwiYWN0aXZlQ2xhc3NOYW1lXCIsIFwiYWN0aXZlU3R5bGVcIiwgXCJjbGFzc05hbWVcIiwgXCJleGFjdFwiLCBcImlzQWN0aXZlXCIsIFwibG9jYXRpb25cIiwgXCJzdHJpY3RcIiwgXCJzdHlsZVwiLCBcInRvXCIsIFwiaW5uZXJSZWZcIl0pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KF9fUm91dGVyQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPE5hdkxpbms+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uUHJvcCB8fCBjb250ZXh0LmxvY2F0aW9uO1xuICAgIHZhciB0b0xvY2F0aW9uID0gbm9ybWFsaXplVG9Mb2NhdGlvbihyZXNvbHZlVG9Mb2NhdGlvbih0bywgY3VycmVudExvY2F0aW9uKSwgY3VycmVudExvY2F0aW9uKTtcbiAgICB2YXIgcGF0aCA9IHRvTG9jYXRpb24ucGF0aG5hbWU7IC8vIFJlZ2V4IHRha2VuIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9waWxsYXJqcy9wYXRoLXRvLXJlZ2V4cC9ibG9iL21hc3Rlci9pbmRleC5qcyNMMjAyXG5cbiAgICB2YXIgZXNjYXBlZFBhdGggPSBwYXRoICYmIHBhdGgucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xuICAgIHZhciBtYXRjaCA9IGVzY2FwZWRQYXRoID8gbWF0Y2hQYXRoKGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSwge1xuICAgICAgcGF0aDogZXNjYXBlZFBhdGgsXG4gICAgICBleGFjdDogZXhhY3QsXG4gICAgICBzdHJpY3Q6IHN0cmljdFxuICAgIH0pIDogbnVsbDtcbiAgICB2YXIgaXNBY3RpdmUgPSAhIShpc0FjdGl2ZVByb3AgPyBpc0FjdGl2ZVByb3AobWF0Y2gsIGN1cnJlbnRMb2NhdGlvbikgOiBtYXRjaCk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGlzQWN0aXZlID8gam9pbkNsYXNzbmFtZXMoY2xhc3NOYW1lUHJvcCwgYWN0aXZlQ2xhc3NOYW1lKSA6IGNsYXNzTmFtZVByb3A7XG4gICAgdmFyIHN0eWxlID0gaXNBY3RpdmUgPyBfZXh0ZW5kcyh7fSwgc3R5bGVQcm9wLCB7fSwgYWN0aXZlU3R5bGUpIDogc3R5bGVQcm9wO1xuXG4gICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogaXNBY3RpdmUgJiYgYXJpYUN1cnJlbnQgfHwgbnVsbCxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgdG86IHRvTG9jYXRpb25cbiAgICB9LCByZXN0KTsgLy8gUmVhY3QgMTUgY29tcGF0XG5cblxuICAgIGlmIChmb3J3YXJkUmVmU2hpbSQxICE9PSBmb3J3YXJkUmVmJDEpIHtcbiAgICAgIHByb3BzLnJlZiA9IGZvcndhcmRlZFJlZiB8fCBpbm5lclJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMuaW5uZXJSZWYgPSBpbm5lclJlZjtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rLCBwcm9wcyk7XG4gIH0pO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xuICB2YXIgYXJpYUN1cnJlbnRUeXBlID0gUHJvcFR5cGVzLm9uZU9mKFtcInBhZ2VcIiwgXCJzdGVwXCIsIFwibG9jYXRpb25cIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcInRydWVcIl0pO1xuICBOYXZMaW5rLnByb3BUeXBlcyA9IF9leHRlbmRzKHt9LCBMaW5rLnByb3BUeXBlcywge1xuICAgIFwiYXJpYS1jdXJyZW50XCI6IGFyaWFDdXJyZW50VHlwZSxcbiAgICBhY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpc0FjdGl2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdFxuICB9KTtcbn1cblxuZXhwb3J0IHsgQnJvd3NlclJvdXRlciwgSGFzaFJvdXRlciwgTGluaywgTmF2TGluayB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtcm91dGVyLWRvbS5qcy5tYXBcbiIsImltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsLCBjcmVhdGVQYXRoIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IGNyZWF0ZUNvbnRleHQgZnJvbSAnbWluaS1jcmVhdGUtcmVhY3QtY29udGV4dCc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCBwYXRoVG9SZWdleHAgZnJvbSAncGF0aC10by1yZWdleHAnO1xuaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuaW1wb3J0IGhvaXN0U3RhdGljcyBmcm9tICdob2lzdC1ub24tcmVhY3Qtc3RhdGljcyc7XG5cbi8vIFRPRE86IFJlcGxhY2Ugd2l0aCBSZWFjdC5jcmVhdGVDb250ZXh0IG9uY2Ugd2UgY2FuIGFzc3VtZSBSZWFjdCAxNitcblxudmFyIGNyZWF0ZU5hbWVkQ29udGV4dCA9IGZ1bmN0aW9uIGNyZWF0ZU5hbWVkQ29udGV4dChuYW1lKSB7XG4gIHZhciBjb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuICBjb250ZXh0LmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG52YXIgY29udGV4dCA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVOYW1lZENvbnRleHQoXCJSb3V0ZXJcIik7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHB1dHRpbmcgaGlzdG9yeSBvbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBSb3V0ZXIuY29tcHV0ZVJvb3RNYXRjaCA9IGZ1bmN0aW9uIGNvbXB1dGVSb290TWF0Y2gocGF0aG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICB1cmw6IFwiL1wiLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzRXhhY3Q6IHBhdGhuYW1lID09PSBcIi9cIlxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gUm91dGVyKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBsb2NhdGlvbjogcHJvcHMuaGlzdG9yeS5sb2NhdGlvblxuICAgIH07IC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLiBXZSBoYXZlIHRvIHN0YXJ0IGxpc3RlbmluZyBmb3IgbG9jYXRpb25cbiAgICAvLyBjaGFuZ2VzIGhlcmUgaW4gdGhlIGNvbnN0cnVjdG9yIGluIGNhc2UgdGhlcmUgYXJlIGFueSA8UmVkaXJlY3Q+c1xuICAgIC8vIG9uIHRoZSBpbml0aWFsIHJlbmRlci4gSWYgdGhlcmUgYXJlLCB0aGV5IHdpbGwgcmVwbGFjZS9wdXNoIHdoZW5cbiAgICAvLyB0aGV5IG1vdW50IGFuZCBzaW5jZSBjRE0gZmlyZXMgaW4gY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMsIHdlIG1heVxuICAgIC8vIGdldCBhIG5ldyBsb2NhdGlvbiBiZWZvcmUgdGhlIDxSb3V0ZXI+IGlzIG1vdW50ZWQuXG5cbiAgICBfdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgX3RoaXMuX3BlbmRpbmdMb2NhdGlvbiA9IG51bGw7XG5cbiAgICBpZiAoIXByb3BzLnN0YXRpY0NvbnRleHQpIHtcbiAgICAgIF90aGlzLnVubGlzdGVuID0gcHJvcHMuaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIGlmIChfdGhpcy5faXNNb3VudGVkKSB7XG4gICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX3BlbmRpbmdMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUm91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLl9pc01vdW50ZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdMb2NhdGlvbikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLl9wZW5kaW5nTG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy51bmxpc3RlbikgdGhpcy51bmxpc3RlbigpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfHwgbnVsbCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGhpc3Rvcnk6IHRoaXMucHJvcHMuaGlzdG9yeSxcbiAgICAgICAgbG9jYXRpb246IHRoaXMuc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG1hdGNoOiBSb3V0ZXIuY29tcHV0ZVJvb3RNYXRjaCh0aGlzLnN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lKSxcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5zdGF0aWNDb250ZXh0XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcocHJldlByb3BzLmhpc3RvcnkgPT09IHRoaXMucHJvcHMuaGlzdG9yeSwgXCJZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+XCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgc3RvcmVzIGxvY2F0aW9uIGluIG1lbW9yeS5cbiAqL1xuXG52YXIgTWVtb3J5Um91dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKE1lbW9yeVJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTWVtb3J5Um91dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KF90aGlzLnByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTWVtb3J5Um91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gTWVtb3J5Um91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgaW5pdGlhbEVudHJpZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgICBpbml0aWFsSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gICAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxuICB9O1xuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxNZW1vcnlSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBNZW1vcnlSb3V0ZXIgYXMgUm91dGVyIH1gLlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxudmFyIExpZmVjeWNsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShMaWZlY3ljbGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIExpZmVjeWNsZSgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTGlmZWN5Y2xlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbk1vdW50KSB0aGlzLnByb3BzLm9uTW91bnQuY2FsbCh0aGlzLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLm9uVXBkYXRlKSB0aGlzLnByb3BzLm9uVXBkYXRlLmNhbGwodGhpcywgdGhpcywgcHJldlByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHRoaXMucHJvcHMub25Vbm1vdW50LmNhbGwodGhpcywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gTGlmZWN5Y2xlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwcm9tcHRpbmcgdGhlIHVzZXIgYmVmb3JlIG5hdmlnYXRpbmcgYXdheSBmcm9tIGEgc2NyZWVuLlxuICovXG5cbmZ1bmN0aW9uIFByb21wdChfcmVmKSB7XG4gIHZhciBtZXNzYWdlID0gX3JlZi5tZXNzYWdlLFxuICAgICAgX3JlZiR3aGVuID0gX3JlZi53aGVuLFxuICAgICAgd2hlbiA9IF9yZWYkd2hlbiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkd2hlbjtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFByb21wdD4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBpZiAoIXdoZW4gfHwgY29udGV4dC5zdGF0aWNDb250ZXh0KSByZXR1cm4gbnVsbDtcbiAgICB2YXIgbWV0aG9kID0gY29udGV4dC5oaXN0b3J5LmJsb2NrO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpZmVjeWNsZSwge1xuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudChzZWxmKSB7XG4gICAgICAgIHNlbGYucmVsZWFzZSA9IG1ldGhvZChtZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZiwgcHJldlByb3BzKSB7XG4gICAgICAgIGlmIChwcmV2UHJvcHMubWVzc2FnZSAhPT0gbWVzc2FnZSkge1xuICAgICAgICAgIHNlbGYucmVsZWFzZSgpO1xuICAgICAgICAgIHNlbGYucmVsZWFzZSA9IG1ldGhvZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVW5tb3VudDogZnVuY3Rpb24gb25Vbm1vdW50KHNlbGYpIHtcbiAgICAgICAgc2VsZi5yZWxlYXNlKCk7XG4gICAgICB9LFxuICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgIH0pO1xuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICB2YXIgbWVzc2FnZVR5cGUgPSBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pO1xuICBQcm9tcHQucHJvcFR5cGVzID0ge1xuICAgIHdoZW46IFByb3BUeXBlcy5ib29sLFxuICAgIG1lc3NhZ2U6IG1lc3NhZ2VUeXBlLmlzUmVxdWlyZWRcbiAgfTtcbn1cblxudmFyIGNhY2hlID0ge307XG52YXIgY2FjaGVMaW1pdCA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQgPSAwO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0aChwYXRoKSB7XG4gIGlmIChjYWNoZVtwYXRoXSkgcmV0dXJuIGNhY2hlW3BhdGhdO1xuICB2YXIgZ2VuZXJhdG9yID0gcGF0aFRvUmVnZXhwLmNvbXBpbGUocGF0aCk7XG5cbiAgaWYgKGNhY2hlQ291bnQgPCBjYWNoZUxpbWl0KSB7XG4gICAgY2FjaGVbcGF0aF0gPSBnZW5lcmF0b3I7XG4gICAgY2FjaGVDb3VudCsrO1xuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRvcjtcbn1cbi8qKlxuICogUHVibGljIEFQSSBmb3IgZ2VuZXJhdGluZyBhIFVSTCBwYXRobmFtZSBmcm9tIGEgcGF0aCBhbmQgcGFyYW1ldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlUGF0aChwYXRoLCBwYXJhbXMpIHtcbiAgaWYgKHBhdGggPT09IHZvaWQgMCkge1xuICAgIHBhdGggPSBcIi9cIjtcbiAgfVxuXG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHBhdGggPT09IFwiL1wiID8gcGF0aCA6IGNvbXBpbGVQYXRoKHBhdGgpKHBhcmFtcywge1xuICAgIHByZXR0eTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgbmF2aWdhdGluZyBwcm9ncmFtbWF0aWNhbGx5IHdpdGggYSBjb21wb25lbnQuXG4gKi9cblxuZnVuY3Rpb24gUmVkaXJlY3QoX3JlZikge1xuICB2YXIgY29tcHV0ZWRNYXRjaCA9IF9yZWYuY29tcHV0ZWRNYXRjaCxcbiAgICAgIHRvID0gX3JlZi50byxcbiAgICAgIF9yZWYkcHVzaCA9IF9yZWYucHVzaCxcbiAgICAgIHB1c2ggPSBfcmVmJHB1c2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRwdXNoO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8UmVkaXJlY3Q+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGhpc3RvcnkgPSBjb250ZXh0Lmhpc3RvcnksXG4gICAgICAgIHN0YXRpY0NvbnRleHQgPSBjb250ZXh0LnN0YXRpY0NvbnRleHQ7XG4gICAgdmFyIG1ldGhvZCA9IHB1c2ggPyBoaXN0b3J5LnB1c2ggOiBoaXN0b3J5LnJlcGxhY2U7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oY29tcHV0ZWRNYXRjaCA/IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IGdlbmVyYXRlUGF0aCh0bywgY29tcHV0ZWRNYXRjaC5wYXJhbXMpIDogX2V4dGVuZHMoe30sIHRvLCB7XG4gICAgICBwYXRobmFtZTogZ2VuZXJhdGVQYXRoKHRvLnBhdGhuYW1lLCBjb21wdXRlZE1hdGNoLnBhcmFtcylcbiAgICB9KSA6IHRvKTsgLy8gV2hlbiByZW5kZXJpbmcgaW4gYSBzdGF0aWMgY29udGV4dCxcbiAgICAvLyBzZXQgdGhlIG5ldyBsb2NhdGlvbiBpbW1lZGlhdGVseS5cblxuICAgIGlmIChzdGF0aWNDb250ZXh0KSB7XG4gICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGlmZWN5Y2xlLCB7XG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZShzZWxmLCBwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHByZXZQcm9wcy50byk7XG5cbiAgICAgICAgaWYgKCFsb2NhdGlvbnNBcmVFcXVhbChwcmV2TG9jYXRpb24sIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICAgIGtleTogcHJldkxvY2F0aW9uLmtleVxuICAgICAgICB9KSkpIHtcbiAgICAgICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG86IHRvXG4gICAgfSk7XG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFJlZGlyZWN0LnByb3BUeXBlcyA9IHtcbiAgICBwdXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBmcm9tOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxuICB9O1xufVxuXG52YXIgY2FjaGUkMSA9IHt9O1xudmFyIGNhY2hlTGltaXQkMSA9IDEwMDAwO1xudmFyIGNhY2hlQ291bnQkMSA9IDA7XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoJDEocGF0aCwgb3B0aW9ucykge1xuICB2YXIgY2FjaGVLZXkgPSBcIlwiICsgb3B0aW9ucy5lbmQgKyBvcHRpb25zLnN0cmljdCArIG9wdGlvbnMuc2Vuc2l0aXZlO1xuICB2YXIgcGF0aENhY2hlID0gY2FjaGUkMVtjYWNoZUtleV0gfHwgKGNhY2hlJDFbY2FjaGVLZXldID0ge30pO1xuICBpZiAocGF0aENhY2hlW3BhdGhdKSByZXR1cm4gcGF0aENhY2hlW3BhdGhdO1xuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgcmVnZXhwID0gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHJlZ2V4cDogcmVnZXhwLFxuICAgIGtleXM6IGtleXNcbiAgfTtcblxuICBpZiAoY2FjaGVDb3VudCQxIDwgY2FjaGVMaW1pdCQxKSB7XG4gICAgcGF0aENhY2hlW3BhdGhdID0gcmVzdWx0O1xuICAgIGNhY2hlQ291bnQkMSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBVUkwgcGF0aG5hbWUgdG8gYSBwYXRoLlxuICovXG5cblxuZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBwYXRoOiBvcHRpb25zXG4gICAgfTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwYXRoID0gX29wdGlvbnMucGF0aCxcbiAgICAgIF9vcHRpb25zJGV4YWN0ID0gX29wdGlvbnMuZXhhY3QsXG4gICAgICBleGFjdCA9IF9vcHRpb25zJGV4YWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGV4YWN0LFxuICAgICAgX29wdGlvbnMkc3RyaWN0ID0gX29wdGlvbnMuc3RyaWN0LFxuICAgICAgc3RyaWN0ID0gX29wdGlvbnMkc3RyaWN0ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJHN0cmljdCxcbiAgICAgIF9vcHRpb25zJHNlbnNpdGl2ZSA9IF9vcHRpb25zLnNlbnNpdGl2ZSxcbiAgICAgIHNlbnNpdGl2ZSA9IF9vcHRpb25zJHNlbnNpdGl2ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzZW5zaXRpdmU7XG4gIHZhciBwYXRocyA9IFtdLmNvbmNhdChwYXRoKTtcbiAgcmV0dXJuIHBhdGhzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hlZCwgcGF0aCkge1xuICAgIGlmICghcGF0aCAmJiBwYXRoICE9PSBcIlwiKSByZXR1cm4gbnVsbDtcbiAgICBpZiAobWF0Y2hlZCkgcmV0dXJuIG1hdGNoZWQ7XG5cbiAgICB2YXIgX2NvbXBpbGVQYXRoID0gY29tcGlsZVBhdGgkMShwYXRoLCB7XG4gICAgICBlbmQ6IGV4YWN0LFxuICAgICAgc3RyaWN0OiBzdHJpY3QsXG4gICAgICBzZW5zaXRpdmU6IHNlbnNpdGl2ZVxuICAgIH0pLFxuICAgICAgICByZWdleHAgPSBfY29tcGlsZVBhdGgucmVnZXhwLFxuICAgICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhwYXRobmFtZSk7XG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgICB2YWx1ZXMgPSBtYXRjaC5zbGljZSgxKTtcbiAgICB2YXIgaXNFeGFjdCA9IHBhdGhuYW1lID09PSB1cmw7XG4gICAgaWYgKGV4YWN0ICYmICFpc0V4YWN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIC8vIHRoZSBwYXRoIHVzZWQgdG8gbWF0Y2hcbiAgICAgIHVybDogcGF0aCA9PT0gXCIvXCIgJiYgdXJsID09PSBcIlwiID8gXCIvXCIgOiB1cmwsXG4gICAgICAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICAgIGlzRXhhY3Q6IGlzRXhhY3QsXG4gICAgICAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICAgIHBhcmFtczoga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGtleSwgaW5kZXgpIHtcbiAgICAgICAgbWVtb1trZXkubmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgIH0sIHt9KVxuICAgIH07XG4gIH0sIG51bGwpO1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gZXZhbENoaWxkcmVuRGV2KGNoaWxkcmVuLCBwcm9wcywgcGF0aCkge1xuICB2YXIgdmFsdWUgPSBjaGlsZHJlbihwcm9wcyk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcodmFsdWUgIT09IHVuZGVmaW5lZCwgXCJZb3UgcmV0dXJuZWQgYHVuZGVmaW5lZGAgZnJvbSB0aGUgYGNoaWxkcmVuYCBmdW5jdGlvbiBvZiBcIiArIChcIjxSb3V0ZVwiICsgKHBhdGggPyBcIiBwYXRoPVxcXCJcIiArIHBhdGggKyBcIlxcXCJcIiA6IFwiXCIpICsgXCI+LCBidXQgeW91IFwiKSArIFwic2hvdWxkIGhhdmUgcmV0dXJuZWQgYSBSZWFjdCBlbGVtZW50IG9yIGBudWxsYFwiKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHZhbHVlIHx8IG51bGw7XG59XG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIHNpbmdsZSBwYXRoIGFuZCByZW5kZXJpbmcuXG4gKi9cblxuXG52YXIgUm91dGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUm91dGUsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlKCkge1xuICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSb3V0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQkMSkge1xuICAgICAgIWNvbnRleHQkMSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIGxvY2F0aW9uID0gX3RoaXMucHJvcHMubG9jYXRpb24gfHwgY29udGV4dCQxLmxvY2F0aW9uO1xuICAgICAgdmFyIG1hdGNoID0gX3RoaXMucHJvcHMuY29tcHV0ZWRNYXRjaCA/IF90aGlzLnByb3BzLmNvbXB1dGVkTWF0Y2ggLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG4gICAgICA6IF90aGlzLnByb3BzLnBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIF90aGlzLnByb3BzKSA6IGNvbnRleHQkMS5tYXRjaDtcblxuICAgICAgdmFyIHByb3BzID0gX2V4dGVuZHMoe30sIGNvbnRleHQkMSwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIG1hdGNoOiBtYXRjaFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IF90aGlzLnByb3BzLFxuICAgICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgY29tcG9uZW50ID0gX3RoaXMkcHJvcHMuY29tcG9uZW50LFxuICAgICAgICAgIHJlbmRlciA9IF90aGlzJHByb3BzLnJlbmRlcjsgLy8gUHJlYWN0IHVzZXMgYW4gZW1wdHkgYXJyYXkgYXMgY2hpbGRyZW4gYnlcbiAgICAgIC8vIGRlZmF1bHQsIHNvIHVzZSBudWxsIGlmIHRoYXQncyB0aGUgY2FzZS5cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHByb3BzXG4gICAgICB9LCBwcm9wcy5tYXRjaCA/IGNoaWxkcmVuID8gdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBldmFsQ2hpbGRyZW5EZXYoY2hpbGRyZW4sIHByb3BzLCBfdGhpcy5wcm9wcy5wYXRoKSA6IGNoaWxkcmVuKHByb3BzKSA6IGNoaWxkcmVuIDogY29tcG9uZW50ID8gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSA6IHJlbmRlciA/IHJlbmRlcihwcm9wcykgOiBudWxsIDogdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBldmFsQ2hpbGRyZW5EZXYoY2hpbGRyZW4sIHByb3BzLCBfdGhpcy5wcm9wcy5wYXRoKSA6IGNoaWxkcmVuKHByb3BzKSA6IG51bGwpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSb3V0ZS5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubm9kZV0pLFxuICAgIGNvbXBvbmVudDogZnVuY3Rpb24gY29tcG9uZW50KHByb3BzLCBwcm9wTmFtZSkge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSAmJiAhaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkludmFsaWQgcHJvcCAnY29tcG9uZW50JyBzdXBwbGllZCB0byAnUm91dGUnOiB0aGUgcHJvcCBpcyBub3QgYSB2YWxpZCBSZWFjdCBjb21wb25lbnRcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgbG9jYXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gICAgcGF0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyldKSxcbiAgICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIHNlbnNpdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbFxuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pICYmIHRoaXMucHJvcHMuY29tcG9uZW50KSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjb21wb25lbnQ+IHdpbGwgYmUgaWdub3JlZFwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pICYmIHRoaXMucHJvcHMucmVuZGVyKSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIHJlbmRlcj4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZFwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5jb21wb25lbnQgJiYgdGhpcy5wcm9wcy5yZW5kZXIpLCBcIllvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZFwiKSA6IHZvaWQgMDtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0aGlzLnByb3BzLmxvY2F0aW9uICYmICFwcmV2UHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISghdGhpcy5wcm9wcy5sb2NhdGlvbiAmJiBwcmV2UHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJykgOiB2b2lkIDA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIgPyBwYXRoIDogXCIvXCIgKyBwYXRoO1xufVxuXG5mdW5jdGlvbiBhZGRCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSkgKyBsb2NhdGlvbi5wYXRobmFtZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuICB2YXIgYmFzZSA9IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSk7XG4gIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2UpICE9PSAwKSByZXR1cm4gbG9jYXRpb247XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyKGJhc2UubGVuZ3RoKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVJMKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09IFwic3RyaW5nXCIgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufVxuXG5mdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBjYW5ub3QgJXMgd2l0aCA8U3RhdGljUm91dGVyPlwiLCBtZXRob2ROYW1lKSA6IGludmFyaWFudChmYWxzZSkgO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbi8qKlxuICogVGhlIHB1YmxpYyB0b3AtbGV2ZWwgQVBJIGZvciBhIFwic3RhdGljXCIgPFJvdXRlcj4sIHNvLWNhbGxlZCBiZWNhdXNlIGl0XG4gKiBjYW4ndCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnQgbG9jYXRpb24uIEluc3RlYWQsIGl0IGp1c3QgcmVjb3Jkc1xuICogbG9jYXRpb24gY2hhbmdlcyBpbiBhIGNvbnRleHQgb2JqZWN0LiBVc2VmdWwgbWFpbmx5IGluIHRlc3RpbmcgYW5kXG4gKiBzZXJ2ZXItcmVuZGVyaW5nIHNjZW5hcmlvcy5cbiAqL1xuXG5cbnZhciBTdGF0aWNSb3V0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3RhdGljUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdGF0aWNSb3V0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gX3RoaXMubmF2aWdhdGVUbyhsb2NhdGlvbiwgXCJQVVNIXCIpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVSZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gX3RoaXMubmF2aWdhdGVUbyhsb2NhdGlvbiwgXCJSRVBMQUNFXCIpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVMaXN0ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0YXRpY1JvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm5hdmlnYXRlVG8gPSBmdW5jdGlvbiBuYXZpZ2F0ZVRvKGxvY2F0aW9uLCBhY3Rpb24pIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBfdGhpcyRwcm9wcyRiYXNlbmFtZSA9IF90aGlzJHByb3BzLmJhc2VuYW1lLFxuICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzJGJhc2VuYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3RoaXMkcHJvcHMkYmFzZW5hbWUsXG4gICAgICAgIF90aGlzJHByb3BzJGNvbnRleHQgPSBfdGhpcyRwcm9wcy5jb250ZXh0LFxuICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMkY29udGV4dCA9PT0gdm9pZCAwID8ge30gOiBfdGhpcyRwcm9wcyRjb250ZXh0O1xuICAgIGNvbnRleHQuYWN0aW9uID0gYWN0aW9uO1xuICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBfdGhpcyRwcm9wczIkYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIuYmFzZW5hbWUsXG4gICAgICAgIGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyJGJhc2VuYW1lID09PSB2b2lkIDAgPyBcIlwiIDogX3RoaXMkcHJvcHMyJGJhc2VuYW1lLFxuICAgICAgICBfdGhpcyRwcm9wczIkY29udGV4dCA9IF90aGlzJHByb3BzMi5jb250ZXh0LFxuICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMyJGNvbnRleHQgPT09IHZvaWQgMCA/IHt9IDogX3RoaXMkcHJvcHMyJGNvbnRleHQsXG4gICAgICAgIF90aGlzJHByb3BzMiRsb2NhdGlvbiA9IF90aGlzJHByb3BzMi5sb2NhdGlvbixcbiAgICAgICAgbG9jYXRpb24gPSBfdGhpcyRwcm9wczIkbG9jYXRpb24gPT09IHZvaWQgMCA/IFwiL1wiIDogX3RoaXMkcHJvcHMyJGxvY2F0aW9uLFxuICAgICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMyLCBbXCJiYXNlbmFtZVwiLCBcImNvbnRleHRcIiwgXCJsb2NhdGlvblwiXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcbiAgICAgIGNyZWF0ZUhyZWY6IGZ1bmN0aW9uIGNyZWF0ZUhyZWYocGF0aCkge1xuICAgICAgICByZXR1cm4gYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lICsgY3JlYXRlVVJMKHBhdGgpKTtcbiAgICAgIH0sXG4gICAgICBhY3Rpb246IFwiUE9QXCIsXG4gICAgICBsb2NhdGlvbjogc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKSxcbiAgICAgIHB1c2g6IHRoaXMuaGFuZGxlUHVzaCxcbiAgICAgIHJlcGxhY2U6IHRoaXMuaGFuZGxlUmVwbGFjZSxcbiAgICAgIGdvOiBzdGF0aWNIYW5kbGVyKFwiZ29cIiksXG4gICAgICBnb0JhY2s6IHN0YXRpY0hhbmRsZXIoXCJnb0JhY2tcIiksXG4gICAgICBnb0ZvcndhcmQ6IHN0YXRpY0hhbmRsZXIoXCJnb0ZvcndhcmRcIiksXG4gICAgICBsaXN0ZW46IHRoaXMuaGFuZGxlTGlzdGVuLFxuICAgICAgYmxvY2s6IHRoaXMuaGFuZGxlQmxvY2tcbiAgICB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgIGhpc3Rvcnk6IGhpc3RvcnksXG4gICAgICBzdGF0aWNDb250ZXh0OiBjb250ZXh0XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBTdGF0aWNSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgU3RhdGljUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSlcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8U3RhdGljUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCBcIiArIFwidXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgU3RhdGljUm91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyB0aGUgZmlyc3QgPFJvdXRlPiB0aGF0IG1hdGNoZXMuXG4gKi9cblxudmFyIFN3aXRjaCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShTd2l0Y2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN3aXRjaCgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3dpdGNoLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxTd2l0Y2g+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICB2YXIgbG9jYXRpb24gPSBfdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCBjb250ZXh0LmxvY2F0aW9uO1xuICAgICAgdmFyIGVsZW1lbnQsIG1hdGNoOyAvLyBXZSB1c2UgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaCBpbnN0ZWFkIG9mIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoKS5maW5kKClcbiAgICAgIC8vIGhlcmUgYmVjYXVzZSB0b0FycmF5IGFkZHMga2V5cyB0byBhbGwgY2hpbGQgZWxlbWVudHMgYW5kIHdlIGRvIG5vdCB3YW50XG4gICAgICAvLyB0byB0cmlnZ2VyIGFuIHVubW91bnQvcmVtb3VudCBmb3IgdHdvIDxSb3V0ZT5zIHRoYXQgcmVuZGVyIHRoZSBzYW1lXG4gICAgICAvLyBjb21wb25lbnQgYXQgZGlmZmVyZW50IFVSTHMuXG5cbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goX3RoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCAmJiBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICBlbGVtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgdmFyIHBhdGggPSBjaGlsZC5wcm9wcy5wYXRoIHx8IGNoaWxkLnByb3BzLmZyb207XG4gICAgICAgICAgbWF0Y2ggPSBwYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCBfZXh0ZW5kcyh7fSwgY2hpbGQucHJvcHMsIHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgICB9KSkgOiBjb250ZXh0Lm1hdGNoO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYXRjaCA/IFJlYWN0LmNsb25lRWxlbWVudChlbGVtZW50LCB7XG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgY29tcHV0ZWRNYXRjaDogbWF0Y2hcbiAgICAgIH0pIDogbnVsbDtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gU3dpdGNoO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFN3aXRjaC5wcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMubG9jYXRpb24gJiYgIXByZXZQcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISghdGhpcy5wcm9wcy5sb2NhdGlvbiAmJiBwcmV2UHJvcHMubG9jYXRpb24pLCAnPFN3aXRjaD4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIEEgcHVibGljIGhpZ2hlci1vcmRlciBjb21wb25lbnQgdG8gYWNjZXNzIHRoZSBpbXBlcmF0aXZlIEFQSVxuICovXG5cbmZ1bmN0aW9uIHdpdGhSb3V0ZXIoQ29tcG9uZW50KSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IFwid2l0aFJvdXRlcihcIiArIChDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUpICsgXCIpXCI7XG5cbiAgdmFyIEMgPSBmdW5jdGlvbiBDKHByb3BzKSB7XG4gICAgdmFyIHdyYXBwZWRDb21wb25lbnRSZWYgPSBwcm9wcy53cmFwcGVkQ29tcG9uZW50UmVmLFxuICAgICAgICByZW1haW5pbmdQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJ3cmFwcGVkQ29tcG9uZW50UmVmXCJdKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFwiICsgZGlzcGxheU5hbWUgKyBcIiAvPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgcmVtYWluaW5nUHJvcHMsIGNvbnRleHQsIHtcbiAgICAgICAgcmVmOiB3cmFwcGVkQ29tcG9uZW50UmVmXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQy5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBDLldyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQ7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIEMucHJvcFR5cGVzID0ge1xuICAgICAgd3JhcHBlZENvbXBvbmVudFJlZjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaG9pc3RTdGF0aWNzKEMsIENvbXBvbmVudCk7XG59XG5cbnZhciB1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dDtcbmZ1bmN0aW9uIHVzZUhpc3RvcnkoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAhKHR5cGVvZiB1c2VDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHVzZSBSZWFjdCA+PSAxNi44IGluIG9yZGVyIHRvIHVzZSB1c2VIaXN0b3J5KClcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIHVzZUNvbnRleHQoY29udGV4dCkuaGlzdG9yeTtcbn1cbmZ1bmN0aW9uIHVzZUxvY2F0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgISh0eXBlb2YgdXNlQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCB1c2UgUmVhY3QgPj0gMTYuOCBpbiBvcmRlciB0byB1c2UgdXNlTG9jYXRpb24oKVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gdXNlQ29udGV4dChjb250ZXh0KS5sb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIHVzZVBhcmFtcygpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICEodHlwZW9mIHVzZUNvbnRleHQgPT09IFwiZnVuY3Rpb25cIikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgdXNlIFJlYWN0ID49IDE2LjggaW4gb3JkZXIgdG8gdXNlIHVzZVBhcmFtcygpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBtYXRjaCA9IHVzZUNvbnRleHQoY29udGV4dCkubWF0Y2g7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLnBhcmFtcyA6IHt9O1xufVxuZnVuY3Rpb24gdXNlUm91dGVNYXRjaChwYXRoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAhKHR5cGVvZiB1c2VDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHVzZSBSZWFjdCA+PSAxNi44IGluIG9yZGVyIHRvIHVzZSB1c2VSb3V0ZU1hdGNoKClcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIHBhdGggPyBtYXRjaFBhdGgodXNlTG9jYXRpb24oKS5wYXRobmFtZSwgcGF0aCkgOiB1c2VDb250ZXh0KGNvbnRleHQpLm1hdGNoO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIGdsb2JhbCA9IHdpbmRvdztcbiAgICB2YXIga2V5ID0gXCJfX3JlYWN0X3JvdXRlcl9idWlsZF9fXCI7XG4gICAgdmFyIGJ1aWxkTmFtZXMgPSB7XG4gICAgICBjanM6IFwiQ29tbW9uSlNcIixcbiAgICAgIGVzbTogXCJFUyBtb2R1bGVzXCIsXG4gICAgICB1bWQ6IFwiVU1EXCJcbiAgICB9O1xuXG4gICAgaWYgKGdsb2JhbFtrZXldICYmIGdsb2JhbFtrZXldICE9PSBcImVzbVwiKSB7XG4gICAgICB2YXIgaW5pdGlhbEJ1aWxkTmFtZSA9IGJ1aWxkTmFtZXNbZ2xvYmFsW2tleV1dO1xuICAgICAgdmFyIHNlY29uZGFyeUJ1aWxkTmFtZSA9IGJ1aWxkTmFtZXNbXCJlc21cIl07IC8vIFRPRE86IEFkZCBsaW5rIHRvIGFydGljbGUgdGhhdCBleHBsYWlucyBpbiBkZXRhaWwgaG93IHRvIGF2b2lkXG4gICAgICAvLyBsb2FkaW5nIDIgZGlmZmVyZW50IGJ1aWxkcy5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGFyZSBsb2FkaW5nIHRoZSBcIiArIHNlY29uZGFyeUJ1aWxkTmFtZSArIFwiIGJ1aWxkIG9mIFJlYWN0IFJvdXRlciBcIiArIChcIm9uIGEgcGFnZSB0aGF0IGlzIGFscmVhZHkgcnVubmluZyB0aGUgXCIgKyBpbml0aWFsQnVpbGROYW1lICsgXCIgXCIpICsgXCJidWlsZCwgc28gdGhpbmdzIHdvbid0IHdvcmsgcmlnaHQuXCIpO1xuICAgIH1cblxuICAgIGdsb2JhbFtrZXldID0gXCJlc21cIjtcbiAgfVxufVxuXG5leHBvcnQgeyBNZW1vcnlSb3V0ZXIsIFByb21wdCwgUmVkaXJlY3QsIFJvdXRlLCBSb3V0ZXIsIFN0YXRpY1JvdXRlciwgU3dpdGNoLCBjb250ZXh0IGFzIF9fUm91dGVyQ29udGV4dCwgZ2VuZXJhdGVQYXRoLCBtYXRjaFBhdGgsIHVzZUhpc3RvcnksIHVzZUxvY2F0aW9uLCB1c2VQYXJhbXMsIHVzZVJvdXRlTWF0Y2gsIHdpdGhSb3V0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJvdXRlci5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGU6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgY2FsbGVlOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgICByZW5kZXI6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZVxufTtcblxudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgICAnJCR0eXBlb2YnOiB0cnVlLFxuICAgIGNvbXBhcmU6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgVFlQRV9TVEFUSUNTID0ge307XG5UWVBFX1NUQVRJQ1NbUmVhY3RJcy5Gb3J3YXJkUmVmXSA9IEZPUldBUkRfUkVGX1NUQVRJQ1M7XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gICAgaWYgKFJlYWN0SXMuaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgICB9XG4gICAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcblxuICAgICAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICAgICAgdmFyIHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMS4wXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMTEuMCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxuXG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzIHdpdGhcbi8vIHRlbXBsYXRlIGxpdGVyYWwgc3RyaW5ncy4gVGhlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuLy8gZHVyaW5nIGJ1aWxkLlxuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xudmFyIGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2soY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh2b2lkIDAsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrJDEgPSBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2s7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG52YXIgd2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmdXaXRob3V0U3RhY2soY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gOCkge1xuICAgICAgLy8gQ2hlY2sgYmVmb3JlIHRoZSBjb25kaXRpb24gdG8gY2F0Y2ggdmlvbGF0aW9ucyBlYXJseS5cbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FybmluZ1dpdGhvdXRTdGFjaygpIGN1cnJlbnRseSBzdXBwb3J0cyBhdCBtb3N0IDggYXJndW1lbnRzLicpO1xuICAgIH1cblxuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgICAgfSk7XG4gICAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcblxuICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5lcnJvciwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbnZhciB3YXJuaW5nV2l0aG91dFN0YWNrJDEgPSB3YXJuaW5nV2l0aG91dFN0YWNrO1xuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihcInNldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHN1c3BlbnNlOiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBCRUZPUkVfU0xBU0hfUkUgPSAvXiguKilbXFxcXFxcL10vO1xudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgdmFyIHNvdXJjZUluZm8gPSAnJztcblxuICBpZiAoc291cmNlKSB7XG4gICAgdmFyIHBhdGggPSBzb3VyY2UuZmlsZU5hbWU7XG4gICAgdmFyIGZpbGVOYW1lID0gcGF0aC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuXG4gICAge1xuICAgICAgLy8gSW4gREVWLCBpbmNsdWRlIGNvZGUgZm9yIGEgY29tbW9uIHNwZWNpYWwgY2FzZTpcbiAgICAgIC8vIHByZWZlciBcImZvbGRlci9pbmRleC5qc1wiIGluc3RlYWQgb2YganVzdCBcImluZGV4LmpzXCIuXG4gICAgICBpZiAoL15pbmRleFxcLi8udGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcGF0aC5tYXRjaChCRUZPUkVfU0xBU0hfUkUpO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhciBwYXRoQmVmb3JlU2xhc2ggPSBtYXRjaFsxXTtcblxuICAgICAgICAgIGlmIChwYXRoQmVmb3JlU2xhc2gpIHtcbiAgICAgICAgICAgIHZhciBmb2xkZXJOYW1lID0gcGF0aEJlZm9yZVNsYXNoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG4gICAgICAgICAgICBmaWxlTmFtZSA9IGZvbGRlck5hbWUgKyAnLycgKyBmaWxlTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzb3VyY2VJbmZvID0gJyAoYXQgJyArIGZpbGVOYW1lICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKSc7XG4gIH0gZWxzZSBpZiAob3duZXJOYW1lKSB7XG4gICAgc291cmNlSW5mbyA9ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJztcbiAgfVxuXG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgc291cmNlSW5mbztcbn07XG5cbnZhciBSZXNvbHZlZCA9IDE7XG5cbmZ1bmN0aW9uIHJlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudChsYXp5Q29tcG9uZW50KSB7XG4gIHJldHVybiBsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPT09IFJlc29sdmVkID8gbGF6eUNvbXBvbmVudC5fcmVzdWx0IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgcmV0dXJuICdDb250ZXh0LkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRoZW5hYmxlID0gdHlwZTtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWRUaGVuYWJsZSA9IHJlZmluZVJlc29sdmVkTGF6eUNvbXBvbmVudCh0aGVuYWJsZSk7XG5cbiAgICAgICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUocmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIH1cbn1cblxue1xuICAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gQWRkIGFuIGV4dHJhIHRvcCBmcmFtZSB3aGlsZSBhbiBlbGVtZW50IGlzIGJlaW5nIHZhbGlkYXRlZFxuXG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQudHlwZSk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkpO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdFNoYXJlZEludGVybmFscywge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gd2FybmluZ1dpdGhvdXRTdGFjayQxO1xuXG57XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvd2FybmluZy1hbmQtaW52YXJpYW50LWFyZ3NcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMS5hcHBseSh2b2lkIDAsIFtmYWxzZSwgZm9ybWF0ICsgJyVzJ10uY29uY2F0KGFyZ3MsIFtzdGFja10pKTtcbiAgfTtcbn1cblxudmFyIHdhcm5pbmckMSA9IHdhcm5pbmc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuXG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICB9XG5cbiAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gIH1cblxuICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgIH1cbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAocmVmKSB7XG4gICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvcE5hbWU7IC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcblxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG5cbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7IC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmOyAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cblxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlOyAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcblxuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcblxuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG5cblxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuXG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcblxuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbiwgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgICFkaWRXYXJuQWJvdXRNYXBzID8gd2FybmluZyQxKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcpICsgXCIpLlwiICsgYWRkZW5kdW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfSAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuXG5cbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuXG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuXG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sIG51bGwpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgICEoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IG51bGwgfHwgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcblxuICB7XG4gICAgLy8gQSBzZXBhcmF0ZSBvYmplY3QsIGJ1dCBwcm94aWVzIGJhY2sgdG8gdGhlIG9yaWdpbmFsIGNvbnRleHQgb2JqZWN0IGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJdCBoYXMgYSBkaWZmZXJlbnQgJCR0eXBlb2YsIHNvIHdlIGNhbiBwcm9wZXJseVxuICAgIC8vIHdhcm4gZm9yIHRoZSBpbmNvcnJlY3QgdXNhZ2Ugb2YgQ29udGV4dCBhcyBhIENvbnN1bWVyLlxuICAgIHZhciBDb25zdW1lciA9IHtcbiAgICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgICBfY29udGV4dDogY29udGV4dCxcbiAgICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHNcbiAgICB9OyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDb25zdW1lciwge1xuICAgICAgUHJvdmlkZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlcikge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLlByb3ZpZGVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LlByb3ZpZGVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LlByb3ZpZGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfUHJvdmlkZXIpIHtcbiAgICAgICAgICBjb250ZXh0LlByb3ZpZGVyID0gX1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWUyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfY3VycmVudFZhbHVlMikge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBfY3VycmVudFZhbHVlMjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF90aHJlYWRDb3VudDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fdGhyZWFkQ291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF90aHJlYWRDb3VudCkge1xuICAgICAgICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gX3RocmVhZENvdW50O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgQ29uc3VtZXI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycykge1xuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVuZGVyaW5nIDxDb250ZXh0LkNvbnN1bWVyLkNvbnN1bWVyPiBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gJyArICdhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gcmVuZGVyIDxDb250ZXh0LkNvbnN1bWVyPiBpbnN0ZWFkPycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJvcGVydGllcyBiZWNhdXNlIGl0IGRvZXNuJ3QgdW5kZXJzdGFuZCBkZWZpbmVQcm9wZXJ0eVxuXG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9jdG9yOiBjdG9yLFxuICAgIC8vIFJlYWN0IHVzZXMgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzOyAvLyBNYXRjaCBwcm9kdWN0aW9uIGJlaGF2aW9yIG1vcmUgY2xvc2VseTpcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKCAvLyBEbyBub3Qgd2FybiBmb3IgMCBhcmd1bWVudHMgYmVjYXVzZSBpdCBjb3VsZCBiZSBkdWUgdG8gdXNhZ2Ugb2YgdGhlICdhcmd1bWVudHMnIG9iamVjdFxuICAgICAgcmVuZGVyLmxlbmd0aCA9PT0gMCB8fCByZW5kZXIubGVuZ3RoID09PSAyKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgICEocmVuZGVyLmRlZmF1bHRQcm9wcyA9PSBudWxsICYmIHJlbmRlci5wcm9wVHlwZXMgPT0gbnVsbCkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIG1lbW8odHlwZSwgY29tcGFyZSkge1xuICB7XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3Igb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG4xLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4yLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuMy4gWW91IG1pZ2h0IGhhdmUgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0IGluIHRoZSBzYW1lIGFwcFxcblNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcblxuICB7XG4gICAgISh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCkgPyB3YXJuaW5nJDEoZmFsc2UsICd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL2ZiLm1lL3J1bGVzLW9mLWhvb2tzJyA6ICcnKSA6IHZvaWQgMDsgLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG4gICAgaWYgKENvbnRleHQuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlYWxDb250ZXh0ID0gQ29udGV4dC5fY29udGV4dDsgLy8gRG9uJ3QgZGVkdXBsaWNhdGUgYmVjYXVzZSB0aGlzIGxlZ2l0aW1hdGVseSBjYXVzZXMgYnVnc1xuICAgICAgLy8gYW5kIG5vYm9keSBzaG91bGQgYmUgdXNpbmcgdGhpcyBpbiBleGlzdGluZyBjb2RlLlxuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBpbnB1dHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgaW5wdXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgaW5wdXRzKTtcbn1cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBpbnB1dHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgaW5wdXRzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBpbnB1dHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgaW5wdXRzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGlucHV0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGlucHV0cyk7XG59XG5mdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICAgIHJldHVybiBkaXNwYXRjaGVyLnVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgfVxufVxudmFyIGVtcHR5T2JqZWN0JDEgPSB7fTtcbmZ1bmN0aW9uIHVzZVJlc3BvbmRlcihyZXNwb25kZXIsIGxpc3RlbmVyUHJvcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAocmVzcG9uZGVyID09IG51bGwgfHwgcmVzcG9uZGVyLiQkdHlwZW9mICE9PSBSRUFDVF9SRVNQT05ERVJfVFlQRSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAndXNlUmVzcG9uZGVyOiBpbnZhbGlkIGZpcnN0IGFyZ3VtZW50LiBFeHBlY3RlZCBhbiBldmVudCByZXNwb25kZXIsIGJ1dCBpbnN0ZWFkIGdvdCAlcycsIHJlc3BvbmRlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVzcG9uZGVyKHJlc3BvbmRlciwgbGlzdGVuZXJQcm9wcyB8fCBlbXB0eU9iamVjdCQxKTtcbn1cbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oY29uZmlnKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlVHJhbnNpdGlvbihjb25maWcpO1xufVxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgY29uZmlnKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgY29uZmlnKTtcbn1cblxuZnVuY3Rpb24gd2l0aFN1c3BlbnNlQ29uZmlnKHNjb3BlLCBjb25maWcpIHtcbiAgdmFyIHByZXZpb3VzQ29uZmlnID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcuc3VzcGVuc2U7XG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnN1c3BlbnNlID0gY29uZmlnID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnO1xuXG4gIHRyeSB7XG4gICAgc2NvcGUoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy5zdXNwZW5zZSA9IHByZXZpb3VzQ29uZmlnO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cblxudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuICB9XG5cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgdmFyIHByb3BUeXBlcztcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKTtcbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgfSBlbHNlIGlmICh0eXBlLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBuYW1lIHx8ICdVbmtub3duJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcbiAgfVxuXG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwocHJvcHMsICdrZXknKSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0LmpzeDogU3ByZWFkaW5nIGEga2V5IHRvIEpTWCBpcyBhIGRlcHJlY2F0ZWQgcGF0dGVybi4gJyArICdFeHBsaWNpdGx5IHBhc3MgYSBrZXkgYWZ0ZXIgc3ByZWFkaW5nIHByb3BzIGluIHlvdXIgSlNYIGNhbGwuICcgKyAnRS5nLiA8Q29tcG9uZW50TmFtZSB7Li4ucHJvcHN9IGtleT17a2V5fSAvPicpO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICByZXR1cm4ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgZmFsc2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTsgLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIGZyb3plbk9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuICAgIHZhciB0ZXN0TWFwID0gbmV3IE1hcChbW2Zyb3plbk9iamVjdCwgbnVsbF1dKTtcbiAgICB2YXIgdGVzdFNldCA9IG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pOyAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgUm9sbHVwIHRvIG5vdCBjb25zaWRlciB0aGVzZSB1bnVzZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JvbGx1cC9yb2xsdXAvaXNzdWVzLzE3NzFcbiAgICAvLyBUT0RPOiB3ZSBjYW4gcmVtb3ZlIHRoZXNlIGlmIFJvbGx1cCBmaXhlcyB0aGUgYnVnLlxuXG4gICAgdGVzdE1hcC5zZXQoMCwgMCk7XG4gICAgdGVzdFNldC5hZGQoMCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuZGFtZW50YWxDb21wb25lbnQoaW1wbCkge1xuICAvLyBXZSB1c2UgcmVzcG9uZGVyIGFzIGEgTWFwIGtleSBsYXRlciBvbi4gV2hlbiB3ZSBoYXZlIGEgYmFkXG4gIC8vIHBvbHlmaWxsLCB0aGVuIHdlIGNhbid0IHVzZSBpdCBhcyBhIGtleSBhcyB0aGUgcG9seWZpbGwgdHJpZXNcbiAgLy8gdG8gYWRkIGEgcHJvcGVydHkgdG8gdGhlIG9iamVjdC5cbiAgaWYgKHRydWUgJiYgIWhhc0JhZE1hcFBvbHlmaWxsKSB7XG4gICAgT2JqZWN0LmZyZWV6ZShpbXBsKTtcbiAgfVxuXG4gIHZhciBmdW5kYW1hbnRhbENvbXBvbmVudCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSxcbiAgICBpbXBsOiBpbXBsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5mcmVlemUoZnVuZGFtYW50YWxDb21wb25lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmRhbWFudGFsQ29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudFJlc3BvbmRlcihkaXNwbGF5TmFtZSwgcmVzcG9uZGVyQ29uZmlnKSB7XG4gIHZhciBnZXRJbml0aWFsU3RhdGUgPSByZXNwb25kZXJDb25maWcuZ2V0SW5pdGlhbFN0YXRlLFxuICAgICAgb25FdmVudCA9IHJlc3BvbmRlckNvbmZpZy5vbkV2ZW50LFxuICAgICAgb25Nb3VudCA9IHJlc3BvbmRlckNvbmZpZy5vbk1vdW50LFxuICAgICAgb25Vbm1vdW50ID0gcmVzcG9uZGVyQ29uZmlnLm9uVW5tb3VudCxcbiAgICAgIG9uUm9vdEV2ZW50ID0gcmVzcG9uZGVyQ29uZmlnLm9uUm9vdEV2ZW50LFxuICAgICAgcm9vdEV2ZW50VHlwZXMgPSByZXNwb25kZXJDb25maWcucm9vdEV2ZW50VHlwZXMsXG4gICAgICB0YXJnZXRFdmVudFR5cGVzID0gcmVzcG9uZGVyQ29uZmlnLnRhcmdldEV2ZW50VHlwZXMsXG4gICAgICB0YXJnZXRQb3J0YWxQcm9wYWdhdGlvbiA9IHJlc3BvbmRlckNvbmZpZy50YXJnZXRQb3J0YWxQcm9wYWdhdGlvbjtcbiAgdmFyIGV2ZW50UmVzcG9uZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9SRVNQT05ERVJfVFlQRSxcbiAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiBnZXRJbml0aWFsU3RhdGUgfHwgbnVsbCxcbiAgICBvbkV2ZW50OiBvbkV2ZW50IHx8IG51bGwsXG4gICAgb25Nb3VudDogb25Nb3VudCB8fCBudWxsLFxuICAgIG9uUm9vdEV2ZW50OiBvblJvb3RFdmVudCB8fCBudWxsLFxuICAgIG9uVW5tb3VudDogb25Vbm1vdW50IHx8IG51bGwsXG4gICAgcm9vdEV2ZW50VHlwZXM6IHJvb3RFdmVudFR5cGVzIHx8IG51bGwsXG4gICAgdGFyZ2V0RXZlbnRUeXBlczogdGFyZ2V0RXZlbnRUeXBlcyB8fCBudWxsLFxuICAgIHRhcmdldFBvcnRhbFByb3BhZ2F0aW9uOiB0YXJnZXRQb3J0YWxQcm9wYWdhdGlvbiB8fCBmYWxzZVxuICB9OyAvLyBXZSB1c2UgcmVzcG9uZGVyIGFzIGEgTWFwIGtleSBsYXRlciBvbi4gV2hlbiB3ZSBoYXZlIGEgYmFkXG4gIC8vIHBvbHlmaWxsLCB0aGVuIHdlIGNhbid0IHVzZSBpdCBhcyBhIGtleSBhcyB0aGUgcG9seWZpbGwgdHJpZXNcbiAgLy8gdG8gYWRkIGEgcHJvcGVydHkgdG8gdGhlIG9iamVjdC5cblxuICBpZiAodHJ1ZSAmJiAhaGFzQmFkTWFwUG9seWZpbGwpIHtcbiAgICBPYmplY3QuZnJlZXplKGV2ZW50UmVzcG9uZGVyKTtcbiAgfVxuXG4gIHJldHVybiBldmVudFJlc3BvbmRlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NvcGUoKSB7XG4gIHZhciBzY29wZUNvbXBvbmVudCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfU0NPUEVfVFlQRVxuICB9O1xuXG4gIHtcbiAgICBPYmplY3QuZnJlZXplKHNjb3BlQ29tcG9uZW50KTtcbiAgfVxuXG4gIHJldHVybiBzY29wZUNvbXBvbmVudDtcbn1cblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG5cbiAvLyBJbiBzb21lIGNhc2VzLCBTdHJpY3RNb2RlIHNob3VsZCBhbHNvIGRvdWJsZS1yZW5kZXIgbGlmZWN5Y2xlcy5cbi8vIFRoaXMgY2FuIGJlIGNvbmZ1c2luZyBmb3IgdGVzdHMgdGhvdWdoLFxuLy8gQW5kIGl0IGNhbiBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIGluIHByb2R1Y3Rpb24uXG4vLyBUaGlzIGZlYXR1cmUgZmxhZyBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBiZWhhdmlvcjpcblxuIC8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuIC8vIFdhcm4gYWJvdXQgZGVwcmVjYXRlZCwgYXN5bmMtdW5zYWZlIGxpZmVjeWNsZXM7IHJlbGF0ZXMgdG8gUkZDICM2OlxuXG4gLy8gR2F0aGVyIGFkdmFuY2VkIHRpbWluZyBtZXRyaWNzIGZvciBQcm9maWxlciBzdWJ0cmVlcy5cblxuIC8vIFRyYWNlIHdoaWNoIGludGVyYWN0aW9ucyB0cmlnZ2VyIGVhY2ggY29tbWl0LlxuXG4gLy8gU1NSIGV4cGVyaW1lbnRzXG5cblxuIC8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG4gLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbiAvLyBEaXNhYmxlIGphdmFzY3JpcHQ6IFVSTCBzdHJpbmdzIGluIGhyZWYgZm9yIFhTUyBwcm90ZWN0aW9uLlxuXG4gLy8gUmVhY3QgRmlyZTogcHJldmVudCB0aGUgdmFsdWUgYW5kIGNoZWNrZWQgYXR0cmlidXRlcyBmcm9tIHN5bmNpbmdcbi8vIHdpdGggdGhlaXIgcmVsYXRlZCBET00gcHJvcGVydGllc1xuXG4gLy8gVGhlc2UgQVBJcyB3aWxsIG5vIGxvbmdlciBiZSBcInVuc3RhYmxlXCIgaW4gdGhlIHVwY29taW5nIDE2LjcgcmVsZWFzZSxcbi8vIENvbnRyb2wgdGhpcyBiZWhhdmlvciB3aXRoIGEgZmxhZyB0byBzdXBwb3J0IDE2LjYgbWlub3IgcmVsZWFzZXMgaW4gdGhlIG1lYW53aGlsZS5cblxudmFyIGV4cG9zZUNvbmN1cnJlbnRNb2RlQVBJcyA9IGZhbHNlO1xuIC8vIEV4cGVyaW1lbnRhbCBSZWFjdCBGbGFyZSBldmVudCBzeXN0ZW0gYW5kIGV2ZW50IGNvbXBvbmVudHMgc3VwcG9ydC5cblxudmFyIGVuYWJsZUZsYXJlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBIb3N0IENvbXBvbmVudCBzdXBwb3J0LlxuXG52YXIgZW5hYmxlRnVuZGFtZW50YWxBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIFNjb3BlIHN1cHBvcnQuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBOZXcgQVBJIGZvciBKU1ggdHJhbnNmb3JtcyB0byB0YXJnZXQgLSBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG5cbnZhciBlbmFibGVKU1hUcmFuc2Zvcm1BUEkgPSBmYWxzZTsgLy8gV2Ugd2lsbCBlbmZvcmNlIG1vY2tpbmcgc2NoZWR1bGVyIHdpdGggc2NoZWR1bGVyL3Vuc3RhYmxlX21vY2sgYXQgc29tZSBwb2ludC4gKHYxNz8pXG4vLyBUaWxsIHRoZW4sIHdlIHdhcm4gYWJvdXQgdGhlIG1pc3NpbmcgbW9jaywgYnV0IHN0aWxsIGZhbGxiYWNrIHRvIGEgc3luYyBtb2RlIGNvbXBhdGlibGUgdmVyc2lvblxuXG4gLy8gRm9yIHRlc3RzLCB3ZSBmbHVzaCBzdXNwZW5zZSBmYWxsYmFja3MgaW4gYW4gYWN0IHNjb3BlO1xuLy8gKmV4Y2VwdCogaW4gc29tZSBvZiBvdXIgb3duIHRlc3RzLCB3aGVyZSB3ZSB0ZXN0IGluY3JlbWVudGFsIGxvYWRpbmcgc3RhdGVzLlxuXG4gLy8gQWRkIGEgY2FsbGJhY2sgcHJvcGVydHkgdG8gc3VzcGVuc2UgdG8gbm90aWZ5IHdoaWNoIHByb21pc2VzIGFyZSBjdXJyZW50bHlcbi8vIGluIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgYWxsb3dzIHJlcG9ydGluZyBhbmQgdHJhY2luZyBvZiB3aGF0IGlzIGNhdXNpbmdcbi8vIHRoZSB1c2VyIHRvIHNlZSBhIGxvYWRpbmcgc3RhdGUuXG4vLyBBbHNvIGFsbG93cyBoeWRyYXRpb24gY2FsbGJhY2tzIHRvIGZpcmUgd2hlbiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgZ2V0c1xuLy8gaHlkcmF0ZWQgb3IgZGVsZXRlZC5cblxuIC8vIFBhcnQgb2YgdGhlIHNpbXBsaWZpY2F0aW9uIG9mIFJlYWN0LmNyZWF0ZUVsZW1lbnQgc28gd2UgY2FuIGV2ZW50dWFsbHkgbW92ZVxuLy8gZnJvbSBSZWFjdC5jcmVhdGVFbGVtZW50IHRvIFJlYWN0LmpzeFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9ibG9iL2NyZWF0ZWxlbWVudC1yZmMvdGV4dC8wMDAwLWNyZWF0ZS1lbGVtZW50LWNoYW5nZXMubWRcblxudmFyIFJlYWN0ID0ge1xuICBDaGlsZHJlbjoge1xuICAgIG1hcDogbWFwQ2hpbGRyZW4sXG4gICAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICAgIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG4gIGNyZWF0ZVJlZjogY3JlYXRlUmVmLFxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgY3JlYXRlQ29udGV4dDogY3JlYXRlQ29udGV4dCxcbiAgZm9yd2FyZFJlZjogZm9yd2FyZFJlZixcbiAgbGF6eTogbGF6eSxcbiAgbWVtbzogbWVtbyxcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0OiB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlRGVidWdWYWx1ZTogdXNlRGVidWdWYWx1ZSxcbiAgdXNlTGF5b3V0RWZmZWN0OiB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZU1lbW86IHVzZU1lbW8sXG4gIHVzZVJlZHVjZXI6IHVzZVJlZHVjZXIsXG4gIHVzZVJlZjogdXNlUmVmLFxuICB1c2VTdGF0ZTogdXNlU3RhdGUsXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBQcm9maWxlcjogUkVBQ1RfUFJPRklMRVJfVFlQRSxcbiAgU3RyaWN0TW9kZTogUkVBQ1RfU1RSSUNUX01PREVfVFlQRSxcbiAgU3VzcGVuc2U6IFJFQUNUX1NVU1BFTlNFX1RZUEUsXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IFJlYWN0U2hhcmVkSW50ZXJuYWxzXG59O1xuXG5pZiAoZXhwb3NlQ29uY3VycmVudE1vZGVBUElzKSB7XG4gIFJlYWN0LnVzZVRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uO1xuICBSZWFjdC51c2VEZWZlcnJlZFZhbHVlID0gdXNlRGVmZXJyZWRWYWx1ZTtcbiAgUmVhY3QuU3VzcGVuc2VMaXN0ID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICBSZWFjdC51bnN0YWJsZV93aXRoU3VzcGVuc2VDb25maWcgPSB3aXRoU3VzcGVuc2VDb25maWc7XG59XG5cbmlmIChlbmFibGVGbGFyZUFQSSkge1xuICBSZWFjdC51bnN0YWJsZV91c2VSZXNwb25kZXIgPSB1c2VSZXNwb25kZXI7XG4gIFJlYWN0LnVuc3RhYmxlX2NyZWF0ZVJlc3BvbmRlciA9IGNyZWF0ZUV2ZW50UmVzcG9uZGVyO1xufVxuXG5pZiAoZW5hYmxlRnVuZGFtZW50YWxBUEkpIHtcbiAgUmVhY3QudW5zdGFibGVfY3JlYXRlRnVuZGFtZW50YWwgPSBjcmVhdGVGdW5kYW1lbnRhbENvbXBvbmVudDtcbn1cblxuaWYgKGVuYWJsZVNjb3BlQVBJKSB7XG4gIFJlYWN0LnVuc3RhYmxlX2NyZWF0ZVNjb3BlID0gY3JlYXRlU2NvcGU7XG59IC8vIE5vdGU6IHNvbWUgQVBJcyBhcmUgYWRkZWQgd2l0aCBmZWF0dXJlIGZsYWdzLlxuLy8gTWFrZSBzdXJlIHRoYXQgc3RhYmxlIGJ1aWxkcyBmb3Igb3BlbiBzb3VyY2Vcbi8vIGRvbid0IG1vZGlmeSB0aGUgUmVhY3Qgb2JqZWN0IHRvIGF2b2lkIGRlb3B0cy5cbi8vIEFsc28gbGV0J3Mgbm90IGV4cG9zZSB0aGVpciBuYW1lcyBpbiBzdGFibGUgYnVpbGRzLlxuXG5cbmlmIChlbmFibGVKU1hUcmFuc2Zvcm1BUEkpIHtcbiAge1xuICAgIFJlYWN0LmpzeERFViA9IGpzeFdpdGhWYWxpZGF0aW9uO1xuICAgIFJlYWN0LmpzeCA9IGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYztcbiAgICBSZWFjdC5qc3hzID0ganN4V2l0aFZhbGlkYXRpb25TdGF0aWM7XG4gIH1cbn1cblxuXG5cbnZhciBSZWFjdCQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0XG59KTtcblxudmFyIFJlYWN0JDMgPSAoIFJlYWN0JDIgJiYgUmVhY3QgKSB8fCBSZWFjdCQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cblxuXG52YXIgcmVhY3QgPSBSZWFjdCQzLmRlZmF1bHQgfHwgUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdClcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGhuYW1lKSB7XG4gIHJldHVybiBwYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKSB7XG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIH1cblxuICBsaXN0LnBvcCgpO1xufVxuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIGhlYXZpbHkgb24gbm9kZSdzIHVybC5wYXJzZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHRvLCBmcm9tKSB7XG4gIGlmIChmcm9tID09PSB1bmRlZmluZWQpIGZyb20gPSAnJztcblxuICB2YXIgdG9QYXJ0cyA9ICh0byAmJiB0by5zcGxpdCgnLycpKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IChmcm9tICYmIGZyb20uc3BsaXQoJy8nKSkgfHwgW107XG5cbiAgdmFyIGlzVG9BYnMgPSB0byAmJiBpc0Fic29sdXRlKHRvKTtcbiAgdmFyIGlzRnJvbUFicyA9IGZyb20gJiYgaXNBYnNvbHV0ZShmcm9tKTtcbiAgdmFyIG11c3RFbmRBYnMgPSBpc1RvQWJzIHx8IGlzRnJvbUFicztcblxuICBpZiAodG8gJiYgaXNBYnNvbHV0ZSh0bykpIHtcbiAgICAvLyB0byBpcyBhYnNvbHV0ZVxuICAgIGZyb21QYXJ0cyA9IHRvUGFydHM7XG4gIH0gZWxzZSBpZiAodG9QYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyB0byBpcyByZWxhdGl2ZSwgZHJvcCB0aGUgZmlsZW5hbWVcbiAgICBmcm9tUGFydHMucG9wKCk7XG4gICAgZnJvbVBhcnRzID0gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKTtcbiAgfVxuXG4gIGlmICghZnJvbVBhcnRzLmxlbmd0aCkgcmV0dXJuICcvJztcblxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaDtcbiAgaWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdCA9IGZyb21QYXJ0c1tmcm9tUGFydHMubGVuZ3RoIC0gMV07XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nIHx8IGxhc3QgPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBmcm9tUGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gZnJvbVBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXVzdEVuZEFicykgZm9yICg7IHVwLS07IHVwKSBmcm9tUGFydHMudW5zaGlmdCgnLi4nKTtcblxuICBpZiAoXG4gICAgbXVzdEVuZEFicyAmJlxuICAgIGZyb21QYXJ0c1swXSAhPT0gJycgJiZcbiAgICAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKVxuICApXG4gICAgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lO1xuIiwidmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG52YXIgcHJlZml4ID0gJ0ludmFyaWFudCBmYWlsZWQnO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXggKyBcIjogXCIgKyAobWVzc2FnZSB8fCAnJykpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGludmFyaWFudDtcbiIsInZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFpc1Byb2R1Y3Rpb24pIHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBcIldhcm5pbmc6IFwiICsgbWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2Fybih0ZXh0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdGhyb3cgRXJyb3IodGV4dCk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB3YXJuaW5nO1xuIiwiZnVuY3Rpb24gdmFsdWVPZihvYmopIHtcbiAgcmV0dXJuIG9iai52YWx1ZU9mID8gb2JqLnZhbHVlT2YoKSA6IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKG9iaik7XG59XG5cbmZ1bmN0aW9uIHZhbHVlRXF1YWwoYSwgYikge1xuICAvLyBUZXN0IGZvciBzdHJpY3QgZXF1YWxpdHkgZmlyc3QuXG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICAvLyBPdGhlcndpc2UsIGlmIGVpdGhlciBvZiB0aGVtID09IG51bGwgdGhleSBhcmUgbm90IGVxdWFsLlxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIEFycmF5LmlzQXJyYXkoYikgJiZcbiAgICAgIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgICAgYS5ldmVyeShmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gdmFsdWVFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBiID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBhVmFsdWUgPSB2YWx1ZU9mKGEpO1xuICAgIHZhciBiVmFsdWUgPSB2YWx1ZU9mKGIpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCBhLCBiKSkuZXZlcnkoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlRXF1YWw7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmNvbnN0IEhvbWUgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxoMT5SZWFjdC1TU1IgQm9pbGVycGxhdGU8L2gxPlxuICAgICAgPHA+XG4gICAgICAgIFRoaXMgaXMgYSBtaW5pbWFsIFNTUiBib2lsZXJwbGF0ZSB3aXRoIFJlYWN0SlMsIE5vZGVKUywgSGFwaUpTLCBXZWJwYWNrLlxuICAgICAgPC9wPlxuICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBjb25zb2xlLmxvZyhcIkNsaWNrIFdvcmtzID09PSBIeWRyYXRlIFdvcmtzXCIpfT5cbiAgICAgICAgQ2xpY2sgIVxuICAgICAgPC9idXR0b24+XG4gICAgICA8cD5Vc2UgY29uc29sZSB0byB2YWxpZGF0ZSBFdmVudHMgLyBIeWRyYXRlIGlzIHdvcmtpbmcuLi4gPC9wPlxuICAgICAgPGgyPkZlYXR1cmVzICYgRXhhbXBsZXM6IDwvaDI+XG4gICAgICA8cD5cbiAgICAgICAgRXhhbXBsZSByb3V0aW5nOiA8YSBocmVmPVwiL3Rlc3RcIj5UZXN0PC9hPlxuICAgICAgPC9wPlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSG9tZTtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuY29uc3QgVGVzdCA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGgxPlJlYWN0LVNTUiBCb2lsZXJwbGF0ZTwvaDE+XG4gICAgICA8cD5UaGlzIGlzIGEgdGVzdCByb3V0ZS48L3A+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGNvbnNvbGUubG9nKFwiQ2xpY2sgV29ya3MgPT09IEh5ZHJhdGUgV29ya3NcIil9PkNsaWNrICE8L2J1dHRvbj5cbiAgICA8Lz5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRlc3Q7XG4iLCJpbXBvcnQgSG9tZSBmcm9tIFwiLi9wYWdlcy9Ib21lXCI7XG5pbXBvcnQgVGVzdCBmcm9tIFwiLi9wYWdlcy9UZXN0XCI7XG5cbmNvbnN0IHJvdXRlc0xpc3QgPSBbXG4gIHtcbiAgICBwYXRoOiBcIi90ZXN0XCIsXG4gICAgY29tcG9uZW50OiBUZXN0XG4gIH0sXG4gIHtcbiAgICBwYXRoOiBcIi9cIixcbiAgICBleGFjdDogdHJ1ZSxcbiAgICBjb21wb25lbnQ6IEhvbWVcbiAgfVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgcm91dGVzTGlzdDtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFN0YXRpY1JvdXRlciwgUm91dGUgfSBmcm9tIFwicmVhY3Qtcm91dGVyLWRvbVwiO1xuaW1wb3J0IHJvdXRlc0xpc3QgZnJvbSBcIi4uL2NsaWVudC9yb3V0ZXNcIjtcbmltcG9ydCB7IGNsaWVudFNjcmlwdHMsIHZlbmRvclNjcmlwdHMgfSBmcm9tIFwiLi91dGlsc1wiO1xuXG5leHBvcnQgZGVmYXVsdCByZXEgPT4ge1xuICByZXR1cm4gKFxuICAgIDxodG1sIGxhbmc9XCJlblwiPlxuICAgICAgPGhlYWQ+XG4gICAgICAgIDxtZXRhIGNoYXJTZXQ9XCJVVEYtOFwiIC8+XG4gICAgICAgIDx0aXRsZT5Cb2lsZXJwbGF0ZSAtIFNTUiB3aXRoIEhhcGlKUywgUmVhY3Q8L3RpdGxlPlxuICAgICAgPC9oZWFkPlxuICAgICAgPGJvZHk+XG4gICAgICAgIDxkaXYgaWQ9XCJhcHBcIj5cbiAgICAgICAgICA8U3RhdGljUm91dGVyIGxvY2F0aW9uPXtyZXEucGF0aH0gY29udGV4dD17e319PlxuICAgICAgICAgICAge3JvdXRlc0xpc3QubWFwKHJvdXRlID0+IChcbiAgICAgICAgICAgICAgPFJvdXRlIGtleT17cm91dGUucGF0aH0gey4uLnJvdXRlfSAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9TdGF0aWNSb3V0ZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7dmVuZG9yU2NyaXB0cy5tYXAoXG4gICAgICAgICAgc2NyaXB0UGF0aCA9PlxuICAgICAgICAgICAgc2NyaXB0UGF0aCAmJiA8c2NyaXB0IGtleT17c2NyaXB0UGF0aH0gc3JjPXtzY3JpcHRQYXRofSAvPlxuICAgICAgICApfVxuICAgICAgICB7Y2xpZW50U2NyaXB0cy5tYXAoXG4gICAgICAgICAgc2NyaXB0UGF0aCA9PlxuICAgICAgICAgICAgc2NyaXB0UGF0aCAmJiA8c2NyaXB0IGtleT17c2NyaXB0UGF0aH0gc3JjPXtzY3JpcHRQYXRofSAvPlxuICAgICAgICApfVxuICAgICAgPC9ib2R5PlxuICAgIDwvaHRtbD5cbiAgKTtcbn07XG4iLCJpbXBvcnQgSGFwaSBmcm9tIFwiQGhhcGkvaGFwaVwiO1xuaW1wb3J0IEluZXJ0IGZyb20gXCJAaGFwaS9pbmVydFwiO1xuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcyc7XG5cbmNvbnN0IGluaXQgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHNlcnZlciA9IEhhcGkuc2VydmVyKHtcbiAgICBwb3J0OiAzMDAwXG4gIH0pO1xuXG4gIGF3YWl0IHNlcnZlci5yZWdpc3RlcihJbmVydCk7XG4gIGF3YWl0IHNlcnZlci5yb3V0ZShyb3V0ZXMpO1xuICBhd2FpdCBzZXJ2ZXIuc3RhcnQoKTtcblxuICBjb25zb2xlLmxvZyhcIlxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgY29uc29sZS5sb2coXCIgIFNFUlZFUiB1cCBhbmQgcnVubmluZy4uLlwiKTtcbiAgY29uc29sZS5sb2coXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cIik7XG4gIGNvbnNvbGUuZGlyKHNlcnZlci5pbmZvKTtcbn07XG5cbnByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwgZXJyID0+IHtcbiAgY29uc29sZS5sb2coZXJyKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufSk7XG5cbmluaXQoKTsiLCJpbXBvcnQgeyByZW5kZXJUb1N0cmluZyB9IGZyb20gXCJyZWFjdC1kb20vc2VydmVyXCI7XG5pbXBvcnQgaHRtbFRlbXBsYXRlIGZyb20gJy4vaHRtbFRlbXBsYXRlJztcblxuY29uc3QgcmVhY3RIYW5kbGVyID0gKHJlcXVlc3QsIGgpID0+IHtcbiAgICByZXR1cm4gXCI8IURPQ1RZUEUgaHRtbD5cIityZW5kZXJUb1N0cmluZyhodG1sVGVtcGxhdGUocmVxdWVzdCkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcmVhY3RIYW5kbGVyOyIsImltcG9ydCByZWFjdEhhbmRsZXIgZnJvbSAnLi9yZWFjdEhhbmRsZXInO1xuZXhwb3J0IGRlZmF1bHQgW1xuICAvLyBTdGF0aWMgRmlsZXNcbiAge1xuICAgIHBhdGg6IFwiL3twYXJhbSp9XCIsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGNvbmZpZzoge1xuICAgICAgaGFuZGxlcjoge1xuICAgICAgICBkaXJlY3Rvcnk6IHtcbiAgICAgICAgICBwYXRoOiAnZGlzdCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBEZWZhdWx0IFJvdXRlXG4gIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgcGF0aDogXCIvXCIsXG4gICAgaGFuZGxlcjogcmVhY3RIYW5kbGVyXG4gIH0sXG4gIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgcGF0aDogXCIvdGVzdFwiLFxuICAgIGhhbmRsZXI6IHJlYWN0SGFuZGxlclxuICB9XG5dO1xuIiwiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jb25zdCBjbGllbnRTY3JpcHRzID0gZnMucmVhZGRpclN5bmMoJ2Rpc3QnLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcbiAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiAoL2NsaWVudC8pLnRlc3QoaXRlbSkpO1xuXG5jb25zdCB2ZW5kb3JTY3JpcHRzID0gZnMucmVhZGRpclN5bmMoJ2Rpc3QnLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcbiAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSAmJiAoL3ZlbmRvci8pLnRlc3QoaXRlbSkpO1xuXG5leHBvcnQge1xuICAgIGNsaWVudFNjcmlwdHMsXG4gICAgdmVuZG9yU2NyaXB0c1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImFzc2VydFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjcnlwdG9cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZXZlbnRzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibmV0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm9zXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInVybFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ1dGlsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInpsaWJcIik7Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDSkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BOzs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcG5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL3VCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdjlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ250QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JnQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDemRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDelpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3J3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzUwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDemFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3Q1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDemFBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzlrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBSUE7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN3ZJQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM09BO0FBQ0E7QUFDQSxhQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdlRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDanZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN3dFQTtBQUNBO0FBQ0EsYUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3J0QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNkQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQUE7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNaQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFIQTtBQU9BOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFEQTtBQU1BO0FBQ0E7QUFBQTtBQUFBO0FBREE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBTUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFEQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7QUN4QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNQQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFEQTtBQURBO0FBSEE7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBTUE7QUFDQTtBQUNBO0FBSEE7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7OztBQ05BOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7OztBQ0FBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=