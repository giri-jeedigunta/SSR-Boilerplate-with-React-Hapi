/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inheritsLoose; });
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inheritsLoose.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inheritsLoose.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

module.exports = _inheritsLoose;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@hapi/accept/lib/header.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/accept/lib/header.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


exports.selection = function (header, preferences, options) {

    const selections = exports.selections(header, preferences, options);
    return selections.length ? selections[0] : '';
};


exports.selections = function (header, preferences, options) {

    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');

    return internals.parse(header || '', preferences, options);
};


//      RFC 7231 Section 5.3.3 (https://tools.ietf.org/html/rfc7231#section-5.3.3)
//
//      Accept-Charset  = *( "," OWS ) ( ( charset / "*" ) [ weight ] ) *( OWS "," [ OWS ( ( charset / "*" ) [ weight ] ) ] )
//      charset         = token
//
//      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8


//      RFC 7231 Section 5.3.4 (https://tools.ietf.org/html/rfc7231#section-5.3.4)
//
//      Accept-Encoding = [ ( "," / ( codings [ weight ] ) ) *( OWS "," [ OWS ( codings [ weight ] ) ] ) ]
//      codings         = content-coding / "identity" / "*"
//      content-coding  = token
//
//      Accept-Encoding: compress, gzip
//      Accept-Encoding:
//      Accept-Encoding: *
//      Accept-Encoding: compress;q=0.5, gzip;q=1.0
//      Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0


//      RFC 7231 Section 5.3.5 (https://tools.ietf.org/html/rfc7231#section-5.3.5)
//
//      Accept-Language = *( "," OWS ) ( language-range [ weight ] ) *( OWS "," [ OWS ( language-range [ weight ] ) ] )
//      language-range  = ( 1*8ALPHA *( "-" 1*8alphanum ) ) / "*"   ; [RFC4647], Section 2.1
//      alphanum        = ALPHA / DIGIT
//
//       Accept-Language: da, en-gb;q=0.8, en;q=0.7


//      token           = 1*tchar
//      tchar           = "!" / "#" / "$" / "%" / "&" / "'" / "*"
//                        / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
//                        / DIGIT / ALPHA
//                        ; any VCHAR, except delimiters
//      OWS             = *( SP / HTAB )


//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)
//
//      The weight is normalized to a real number in the range 0 through 1,
//      where 0.001 is the least preferred and 1 is the most preferred; a
//      value of 0 means "not acceptable".  If no "q" parameter is present,
//      the default weight is 1.
//
//       weight = OWS ";" OWS "q=" qvalue
//       qvalue = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )


internals.parse = function (raw, preferences, options) {

    // Normalize header (remove spaces and tabs)

    const header = raw.replace(/[ \t]/g, '');

    // Normalize preferences

    const lowers = Object.create(null);
    if (preferences) {
        for (let i = 0; i < preferences.length; ++i) {
            const preference = preferences[i];
            lowers[preference.toLowerCase()] = { orig: preference, pos: i };
        }
    }

    // Parse selections

    const parts = header.split(',');
    const selections = [];
    const map = {};

    for (let i = 0; i < parts.length; ++i) {
        const part = parts[i];
        if (!part) {                            // Ignore empty parts or leading commas
            continue;
        }

        // Parse parameters

        const params = part.split(';');
        if (params.length > 2) {
            throw Boom.badRequest(`Invalid ${options.type} header`);
        }

        let token = params[0].toLowerCase();
        if (!token) {
            throw Boom.badRequest(`Invalid ${options.type} header`);
        }

        if (options.equivalents &&
            options.equivalents[token]) {

            token = options.equivalents[token];
        }

        const selection = {
            token,
            pos: i,
            q: 1,
            specificity: options.specificity ? token.split('-') : null
        };

        if (preferences &&
            lowers[token]) {

            selection.pref = lowers[token].pos;
        }

        map[selection.token] = selection;

        // Parse q=value

        if (params.length === 2) {
            const q = params[1];
            const [key, value] = q.split('=');

            if (!value ||
                (key !== 'q' && key !== 'Q')) {

                throw Boom.badRequest(`Invalid ${options.type} header`);
            }

            const score = parseFloat(value);
            if (score === 0) {
                continue;
            }

            if (Number.isFinite(score) &&
                score <= 1 &&
                score >= 0.001) {

                selection.q = score;
            }
        }

        selections.push(selection);             // Only add allowed selections (q !== 0)
    }

    // Sort selection based on q and then position in header

    selections.sort(internals.sort);

    // Extract tokens

    const values = selections.map((selection) => selection.token);

    if (options.default &&
        !map[options.default]) {

        values.push(options.default);
    }

    if (!preferences ||
        !preferences.length) {

        return values;
    }

    const preferred = [];
    for (const selection of values) {
        if (selection === '*') {
            for (const preference of Object.keys(lowers)) {
                if (!map[preference]) {
                    preferred.push(lowers[preference].orig);
                }
            }
        }
        else {
            const lower = selection.toLowerCase();
            if (lowers[lower]) {
                preferred.push(lowers[lower].orig);
            }
        }
    }

    return preferred;
};


internals.sort = function (a, b) {

    const aFirst = -1;
    const bFirst = 1;

    if (b.q !== a.q) {
        return b.q - a.q;
    }

    if (b.pref !== a.pref) {
        if (a.pref === undefined) {
            return bFirst;
        }

        if (b.pref === undefined) {
            return aFirst;
        }

        return a.pref - b.pref;
    }

    if (a.specificity &&
        a.specificity[0] === b.specificity[0] &&
        a.specificity.length !== b.specificity.length) {

        return b.specificity.length - a.specificity.length;
    }

    return a.pos - b.pos;
};


/***/ }),

/***/ "./node_modules/@hapi/accept/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/accept/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Header = __webpack_require__(/*! ./header */ "./node_modules/@hapi/accept/lib/header.js");
const Media = __webpack_require__(/*! ./media */ "./node_modules/@hapi/accept/lib/media.js");


const internals = {
    options: {
        charset: {
            type: 'accept-charset'
        },
        encoding: {
            type: 'accept-encoding',
            default: 'identity',
            equivalents: {
                'x-compress': 'compress',
                'x-gzip': 'gzip'
            }
        },
        language: {
            type: 'accept-language',
            specificity: true
        }
    }
};


for (const type in internals.options) {
    exports[type] = (header, preferences) => Header.selection(header, preferences, internals.options[type]);

    exports[`${type}s`] = (header, preferences) => Header.selections(header, preferences, internals.options[type]);
}


exports.mediaType = (header, preferences) => Media.selection(header, preferences);

exports.mediaTypes = (header, preferences) => Media.selections(header, preferences);


exports.parseAll = function (requestHeaders) {

    return {
        charsets: exports.charsets(requestHeaders['accept-charset']),
        encodings: exports.encodings(requestHeaders['accept-encoding']),
        languages: exports.languages(requestHeaders['accept-language']),
        mediaTypes: exports.mediaTypes(requestHeaders.accept)
    };
};


/***/ }),

/***/ "./node_modules/@hapi/accept/lib/media.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/accept/lib/media.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


exports.selection = function (header, preferences) {

    const selections = exports.selections(header, preferences);
    return selections.length ? selections[0] : '';
};


exports.selections = function (header, preferences) {

    Hoek.assert(!preferences || Array.isArray(preferences), 'Preferences must be an array');

    return internals.parse(header, preferences);
};


//      RFC 7231 Section 5.3.2 (https://tools.ietf.org/html/rfc7231#section-5.3.2)
//
//      Accept          = [ ( "," / ( media-range [ accept-params ] ) ) *( OWS "," [ OWS ( media-range [ accept-params ] ) ] ) ]
//      media-range     = ( "*/*" / ( type "/*" ) / ( type "/" subtype ) ) *( OWS ";" OWS parameter )
//      accept-params   = weight *accept-ext
//      accept-ext      = OWS ";" OWS token [ "=" ( token / quoted-string ) ]
//      type            = token
//      subtype         = token
//      parameter       = token "=" ( token / quoted-string )
//
//      quoted-string   = DQUOTE *( qdtext / quoted-pair ) DQUOTE
//      qdtext          = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text
//      obs-text        = %x80-FF
//      quoted-pair     = "\" ( HTAB / SP / VCHAR / obs-text )
//      VCHAR           = %x21-7E                                ; visible (printing) characters
//      token           = 1*tchar
//      tchar           = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA
//      OWS             = *( SP / HTAB )
//
//      Accept: audio/*; q=0.2, audio/basic
//      Accept: text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c
//      Accept: text/plain, application/json;q=0.5, text/html, */*; q = 0.1
//      Accept: text/plain, application/json;q=0.5, text/html, text/drop;q=0
//      Accept: text/*, text/plain, text/plain;format=flowed, */*
//      Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5


//      RFC 7231 Section 5.3.1 (https://tools.ietf.org/html/rfc7231#section-5.3.1)
//
//      The weight is normalized to a real number in the range 0 through 1,
//      where 0.001 is the least preferred and 1 is the most preferred; a
//      value of 0 means "not acceptable".  If no "q" parameter is present,
//      the default weight is 1.
//
//       weight = OWS ";" OWS "q=" qvalue
//       qvalue = ( "0" [ "." 0*3DIGIT ] ) / ( "1" [ "." 0*3("0") ] )


//                         */*        type/*                              type/subtype
internals.validMediaRx = /^(?:\*\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/\*)|(?:[\w\!#\$%&'\*\+\-\.\^`\|~]+\/[\w\!#\$%&'\*\+\-\.\^`\|~]+)$/;


internals.parse = function (raw, preferences) {

    // Normalize header (remove spaces and temporary remove quoted strings)

    const { header, quoted } = internals.normalize(raw);

    // Parse selections

    const parts = header.split(',');
    const selections = [];
    const map = {};

    for (let i = 0; i < parts.length; ++i) {
        const part = parts[i];
        if (!part) {                                    // Ignore empty parts or leading commas
            continue;
        }

        // Parse parameters

        const pairs = part.split(';');
        const token = pairs.shift().toLowerCase();

        if (!internals.validMediaRx.test(token)) {       // Ignore invalid types
            continue;
        }

        const selection = {
            token,
            params: {},
            exts: {},
            pos: i
        };

        // Parse key=value

        let target = 'params';
        for (const pair of pairs) {
            const kv = pair.split('=');
            if (kv.length !== 2 ||
                !kv[1]) {

                throw Boom.badRequest(`Invalid accept header`);
            }

            const key = kv[0];
            let value = kv[1];

            if (key === 'q' ||
                key === 'Q') {

                target = 'exts';

                value = parseFloat(value);
                if (!Number.isFinite(value) ||
                    value > 1 ||
                    (value < 0.001 && value !== 0)) {

                    value = 1;
                }

                selection.q = value;
            }
            else {
                if (value[0] === '"') {
                    value = `"${quoted[value]}"`;
                }

                selection[target][kv[0]] = value;
            }
        }

        const params = Object.keys(selection.params);
        selection.original = [''].concat(params.map((key) => `${key}=${selection.params[key]}`)).join(';');
        selection.specificity = params.length;

        if (selection.q === undefined) {     // Default no preference to q=1 (top preference)
            selection.q = 1;
        }

        const tparts = selection.token.split('/');
        selection.type = tparts[0];
        selection.subtype = tparts[1];

        map[selection.token] = selection;

        if (selection.q) {                   // Skip denied selections (q=0)
            selections.push(selection);
        }
    }

    // Sort selection based on q and then position in header

    selections.sort(internals.sort);

    return internals.preferences(map, selections, preferences);
};


internals.normalize = function (raw) {

    raw = raw || '*/*';

    const normalized = {
        header: raw,
        quoted: {}
    };

    if (raw.includes('"')) {
        let i = 0;
        normalized.header = raw.replace(/="([^"]*)"/g, ($0, $1) => {

            const key = '"' + ++i;
            normalized.quoted[key] = $1;
            return '=' + key;
        });
    }

    normalized.header = normalized.header.replace(/[ \t]/g, '');
    return normalized;
};


internals.sort = function (a, b) {

    // Sort by quality score

    if (b.q !== a.q) {
        return b.q - a.q;
    }

    // Sort by type

    if (a.type !== b.type) {
        return internals.innerSort(a, b, 'type');
    }

    // Sort by subtype

    if (a.subtype !== b.subtype) {
        return internals.innerSort(a, b, 'subtype');
    }

    // Sort by specificity

    if (a.specificity !== b.specificity) {
        return b.specificity - a.specificity;
    }

    return a.pos - b.pos;
};


internals.innerSort = function (a, b, key) {

    const aFirst = -1;
    const bFirst = 1;

    if (a[key] === '*') {
        return bFirst;
    }

    if (b[key] === '*') {
        return aFirst;
    }

    return a[key] < b[key] ? aFirst : bFirst;       // Group alphabetically
};


internals.preferences = function (map, selections, preferences) {

    // Return selections if no preferences

    if (!preferences ||
        !preferences.length) {

        return selections.map((selection) => selection.token + selection.original);
    }

    // Map wildcards and filter selections to preferences

    const lowers = Object.create(null);
    const flat = Object.create(null);
    let any = false;

    for (const preference of preferences) {
        const lower = preference.toLowerCase();
        flat[lower] = preference;
        const parts = lower.split('/');
        const type = parts[0];
        const subtype = parts[1];

        if (type === '*') {
            Hoek.assert(subtype === '*', 'Invalid media type preference contains wildcard type with a subtype');
            any = true;
            continue;
        }

        lowers[type] = lowers[type] || Object.create(null);
        lowers[type][subtype] = preference;
    }

    const preferred = [];
    for (const selection of selections) {
        const token = selection.token;
        const { type, subtype } = map[token];
        const subtypes = lowers[type];

        // */*

        if (type === '*') {
            for (const preference of Object.keys(flat)) {
                if (!map[preference]) {
                    preferred.push(flat[preference]);
                }
            }

            if (any) {
                preferred.push('*/*');
            }

            continue;
        }

        // any

        if (any) {
            preferred.push((flat[token] || token) + selection.original);
            continue;
        }

        // type/subtype

        if (subtype !== '*') {
            const pref = flat[token];
            if (pref ||
                (subtypes && subtypes['*'])) {

                preferred.push((pref || token) + selection.original);
            }

            continue;
        }

        // type/*

        if (subtypes) {
            for (const psub of Object.keys(subtypes)) {
                if (!map[`${type}/${psub}`]) {
                    preferred.push(subtypes[psub]);
                }
            }
        }
    }

    return preferred;
};


/***/ }),

/***/ "./node_modules/@hapi/address/lib/domain.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/address/lib/domain.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Url = __webpack_require__(/*! url */ "url");


const internals = {
    minDomainSegments: 2,
    nonAsciiRx: /[^\x00-\x7f]/,
    domainControlRx: /[\x00-\x20]/,                                                     // Control + space
    tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,
    URL: Url.URL || URL                                                                 // $lab:coverage:ignore$
};


exports.analyze = function (domain, options = {}) {

    if (typeof domain !== 'string') {
        throw new Error('Invalid input: domain must be a string');
    }

    if (!domain) {
        return { error: 'Domain must be a non-empty string' };
    }

    if (domain.length > 256) {
        return { error: 'Domain too long' };
    }

    const ascii = !internals.nonAsciiRx.test(domain);
    if (!ascii) {
        if (options.allowUnicode === false) {                                           // Defaults to true
            return { error: 'Domain contains forbidden Unicode characters' };
        }

        domain = domain.normalize('NFC');
    }

    if (internals.domainControlRx.test(domain)) {
        return { error: 'Domain contains invalid character' };
    }

    domain = internals.punycode(domain);

    // https://tools.ietf.org/html/rfc1035 section 2.3.1

    const minDomainSegments = options.minDomainSegments || internals.minDomainSegments;

    const segments = domain.split('.');
    if (segments.length < minDomainSegments) {
        return { error: 'Domain lacks the minimum required number of segments' };
    }

    const tlds = options.tlds;
    if (tlds) {
        const tld = segments[segments.length - 1].toLowerCase();
        if (tlds.deny && tlds.deny.has(tld) ||
            tlds.allow && !tlds.allow.has(tld)) {

            return { error: 'Domain uses forbidden TLD' };
        }
    }

    for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];

        if (!segment.length) {
            return { error: 'Domain contains empty dot-separated segment' };
        }

        if (segment.length > 63) {
            return { error: 'Domain contains dot-separated segment that is too long' };
        }

        if (i < segments.length - 1) {
            if (!internals.domainSegmentRx.test(segment)) {
                return { error: 'Domain contains invalid character' };
            }
        }
        else {
            if (!internals.tldSegmentRx.test(segment)) {
                return { error: 'Domain contains invalid tld character' };
            }
        }
    }
};


exports.isValid = function (domain, options) {

    return !exports.analyze(domain, options);
};


internals.punycode = function (domain) {

    try {
        return new internals.URL(`http://${domain}`).host;
    }
    catch (err) {
        return domain;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/address/lib/email.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/address/lib/email.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Util = __webpack_require__(/*! util */ "util");

const Domain = __webpack_require__(/*! ./domain */ "./node_modules/@hapi/address/lib/domain.js");


const internals = {
    nonAsciiRx: /[^\x00-\x7f]/,
    encoder: new (Util.TextEncoder || TextEncoder)()                                            // $lab:coverage:ignore$
};


exports.analyze = function (email, options) {

    return internals.email(email, options);
};


exports.isValid = function (email, options) {

    return !internals.email(email, options);
};


internals.email = function (email, options = {}) {

    if (typeof email !== 'string') {
        throw new Error('Invalid input: email must be a string');
    }

    if (!email) {
        return { error: 'Address must be a non-empty string' };
    }

    // Unicode

    const ascii = !internals.nonAsciiRx.test(email);
    if (!ascii) {
        if (options.allowUnicode === false) {                                                   // Defaults to true
            return { error: 'Address contains forbidden Unicode characters' };
        }

        email = email.normalize('NFC');
    }

    // Basic structure

    const parts = email.split('@');
    if (parts.length !== 2) {
        return { error: parts.length > 2 ? 'Address cannot contain more than one @ character' : 'Address must contain one @ character' };
    }

    const [local, domain] = parts;

    if (!local) {
        return { error: 'Address local part cannot be empty' };
    }

    if (!options.ignoreLength) {
        if (email.length > 254) {                                           // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3
            return { error: 'Address too long' };
        }

        if (internals.encoder.encode(local).length > 64) {                  // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1
            return { error: 'Address local part too long' };
        }
    }

    // Validate parts

    return internals.local(local, ascii) || Domain.analyze(domain, options);
};


internals.local = function (local, ascii) {

    const segments = local.split('.');
    for (const segment of segments) {
        if (!segment.length) {
            return { error: 'Address local part contains empty dot-separated segment' };
        }

        if (ascii) {
            if (!internals.atextRx.test(segment)) {
                return { error: 'Address local part contains invalid character' };
            }

            continue;
        }

        for (const char of segment) {
            if (internals.atextRx.test(char)) {
                continue;
            }

            const binary = internals.binary(char);
            if (!internals.atomRx.test(binary)) {
                return { error: 'Address local part contains invalid character' };
            }
        }
    }
};


internals.binary = function (char) {

    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join('');
};


/*
    From RFC 5321:

        Mailbox         =   Local-part "@" ( Domain / address-literal )

        Local-part      =   Dot-string / Quoted-string
        Dot-string      =   Atom *("."  Atom)
        Atom            =   1*atext
        atext           =   ALPHA / DIGIT / "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "/" / "=" / "?" / "^" / "_" / "`" / "{" / "|" / "}" / "~"

        Domain          =   sub-domain *("." sub-domain)
        sub-domain      =   Let-dig [Ldh-str]
        Let-dig         =   ALPHA / DIGIT
        Ldh-str         =   *( ALPHA / DIGIT / "-" ) Let-dig

        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z
        DIGIT           =   %x30-39                  ; 0-9

    From RFC 6531:

        sub-domain      =/  U-label
        atext           =/  UTF8-non-ascii

        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4

        UTF8-2          =   %xC2-DF UTF8-tail
        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /
                            %xE1-EC 2( UTF8-tail ) /
                            %xED %x80-9F UTF8-tail /
                            %xEE-EF 2( UTF8-tail )
        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /
                            %xF1-F3 3( UTF8-tail ) /
                            %xF4 %x80-8F 2( UTF8-tail )

        UTF8-tail       =   %x80-BF

    Note: The following are not supported:

        RFC 5321: address-literal, Quoted-string
        RFC 5322: obs-*, CFWS
*/


internals.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/;               // _ included in \w


internals.atomRx = new RegExp([

    //  %xC2-DF UTF8-tail
    '(?:[\\xc2-\\xdf][\\x80-\\xbf])',

    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )
    '(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})',

    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )
    '(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})'

].join('|'));


/***/ }),

/***/ "./node_modules/@hapi/address/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/address/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Domain = __webpack_require__(/*! ./domain */ "./node_modules/@hapi/address/lib/domain.js");
const Email = __webpack_require__(/*! ./email */ "./node_modules/@hapi/address/lib/email.js");
const Tlds = __webpack_require__(/*! ./tlds */ "./node_modules/@hapi/address/lib/tlds.js");


const internals = {
    defaultTlds: { allow: Tlds, deny: null }
};


module.exports = {
    domain: {
        analyze(domain, options) {

            options = internals.options(options);
            return Domain.analyze(domain, options);
        },

        isValid(domain, options) {

            options = internals.options(options);
            return Domain.isValid(domain, options);
        }
    },
    email: {
        analyze(email, options) {

            options = internals.options(options);
            return Email.analyze(email, options);
        },

        isValid(email, options) {

            options = internals.options(options);
            return Email.isValid(email, options);
        }
    }
};


internals.options = function (options) {

    if (!options) {
        return { tlds: internals.defaultTlds };
    }

    if (options.tlds === false) {                // Defaults to true
        return options;
    }

    if (!options.tlds ||
        options.tlds === true) {

        return Object.assign({}, options, { tlds: internals.defaultTlds });
    }

    if (typeof options.tlds !== 'object') {
        throw new Error('Invalid options: tlds must be a boolean or an object');
    }

    if (options.tlds.deny) {
        if (options.tlds.deny instanceof Set === false) {
            throw new Error('Invalid options: tlds.deny must be a Set object');
        }

        if (options.tlds.allow) {
            throw new Error('Invalid options: cannot specify both tlds.allow and tlds.deny lists');
        }

        return options;
    }

    if (options.tlds.allow === true) {
        return Object.assign({}, options, { tlds: internals.defaultTlds });
    }

    if (options.tlds.allow instanceof Set === false) {
        throw new Error('Invalid options: tlds.allow must be a Set object or true');
    }

    return options;
};


/***/ }),

/***/ "./node_modules/@hapi/address/lib/tlds.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/address/lib/tlds.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


// http://data.iana.org/TLD/tlds-alpha-by-domain.txt
// # Version 2019091902, Last Updated Fri Sep 20 07: 07: 02 2019 UTC


internals.tlds = [
    'AAA',
    'AARP',
    'ABARTH',
    'ABB',
    'ABBOTT',
    'ABBVIE',
    'ABC',
    'ABLE',
    'ABOGADO',
    'ABUDHABI',
    'AC',
    'ACADEMY',
    'ACCENTURE',
    'ACCOUNTANT',
    'ACCOUNTANTS',
    'ACO',
    'ACTOR',
    'AD',
    'ADAC',
    'ADS',
    'ADULT',
    'AE',
    'AEG',
    'AERO',
    'AETNA',
    'AF',
    'AFAMILYCOMPANY',
    'AFL',
    'AFRICA',
    'AG',
    'AGAKHAN',
    'AGENCY',
    'AI',
    'AIG',
    'AIGO',
    'AIRBUS',
    'AIRFORCE',
    'AIRTEL',
    'AKDN',
    'AL',
    'ALFAROMEO',
    'ALIBABA',
    'ALIPAY',
    'ALLFINANZ',
    'ALLSTATE',
    'ALLY',
    'ALSACE',
    'ALSTOM',
    'AM',
    'AMERICANEXPRESS',
    'AMERICANFAMILY',
    'AMEX',
    'AMFAM',
    'AMICA',
    'AMSTERDAM',
    'ANALYTICS',
    'ANDROID',
    'ANQUAN',
    'ANZ',
    'AO',
    'AOL',
    'APARTMENTS',
    'APP',
    'APPLE',
    'AQ',
    'AQUARELLE',
    'AR',
    'ARAB',
    'ARAMCO',
    'ARCHI',
    'ARMY',
    'ARPA',
    'ART',
    'ARTE',
    'AS',
    'ASDA',
    'ASIA',
    'ASSOCIATES',
    'AT',
    'ATHLETA',
    'ATTORNEY',
    'AU',
    'AUCTION',
    'AUDI',
    'AUDIBLE',
    'AUDIO',
    'AUSPOST',
    'AUTHOR',
    'AUTO',
    'AUTOS',
    'AVIANCA',
    'AW',
    'AWS',
    'AX',
    'AXA',
    'AZ',
    'AZURE',
    'BA',
    'BABY',
    'BAIDU',
    'BANAMEX',
    'BANANAREPUBLIC',
    'BAND',
    'BANK',
    'BAR',
    'BARCELONA',
    'BARCLAYCARD',
    'BARCLAYS',
    'BAREFOOT',
    'BARGAINS',
    'BASEBALL',
    'BASKETBALL',
    'BAUHAUS',
    'BAYERN',
    'BB',
    'BBC',
    'BBT',
    'BBVA',
    'BCG',
    'BCN',
    'BD',
    'BE',
    'BEATS',
    'BEAUTY',
    'BEER',
    'BENTLEY',
    'BERLIN',
    'BEST',
    'BESTBUY',
    'BET',
    'BF',
    'BG',
    'BH',
    'BHARTI',
    'BI',
    'BIBLE',
    'BID',
    'BIKE',
    'BING',
    'BINGO',
    'BIO',
    'BIZ',
    'BJ',
    'BLACK',
    'BLACKFRIDAY',
    'BLOCKBUSTER',
    'BLOG',
    'BLOOMBERG',
    'BLUE',
    'BM',
    'BMS',
    'BMW',
    'BN',
    'BNPPARIBAS',
    'BO',
    'BOATS',
    'BOEHRINGER',
    'BOFA',
    'BOM',
    'BOND',
    'BOO',
    'BOOK',
    'BOOKING',
    'BOSCH',
    'BOSTIK',
    'BOSTON',
    'BOT',
    'BOUTIQUE',
    'BOX',
    'BR',
    'BRADESCO',
    'BRIDGESTONE',
    'BROADWAY',
    'BROKER',
    'BROTHER',
    'BRUSSELS',
    'BS',
    'BT',
    'BUDAPEST',
    'BUGATTI',
    'BUILD',
    'BUILDERS',
    'BUSINESS',
    'BUY',
    'BUZZ',
    'BV',
    'BW',
    'BY',
    'BZ',
    'BZH',
    'CA',
    'CAB',
    'CAFE',
    'CAL',
    'CALL',
    'CALVINKLEIN',
    'CAM',
    'CAMERA',
    'CAMP',
    'CANCERRESEARCH',
    'CANON',
    'CAPETOWN',
    'CAPITAL',
    'CAPITALONE',
    'CAR',
    'CARAVAN',
    'CARDS',
    'CARE',
    'CAREER',
    'CAREERS',
    'CARS',
    'CARTIER',
    'CASA',
    'CASE',
    'CASEIH',
    'CASH',
    'CASINO',
    'CAT',
    'CATERING',
    'CATHOLIC',
    'CBA',
    'CBN',
    'CBRE',
    'CBS',
    'CC',
    'CD',
    'CEB',
    'CENTER',
    'CEO',
    'CERN',
    'CF',
    'CFA',
    'CFD',
    'CG',
    'CH',
    'CHANEL',
    'CHANNEL',
    'CHARITY',
    'CHASE',
    'CHAT',
    'CHEAP',
    'CHINTAI',
    'CHRISTMAS',
    'CHROME',
    'CHRYSLER',
    'CHURCH',
    'CI',
    'CIPRIANI',
    'CIRCLE',
    'CISCO',
    'CITADEL',
    'CITI',
    'CITIC',
    'CITY',
    'CITYEATS',
    'CK',
    'CL',
    'CLAIMS',
    'CLEANING',
    'CLICK',
    'CLINIC',
    'CLINIQUE',
    'CLOTHING',
    'CLOUD',
    'CLUB',
    'CLUBMED',
    'CM',
    'CN',
    'CO',
    'COACH',
    'CODES',
    'COFFEE',
    'COLLEGE',
    'COLOGNE',
    'COM',
    'COMCAST',
    'COMMBANK',
    'COMMUNITY',
    'COMPANY',
    'COMPARE',
    'COMPUTER',
    'COMSEC',
    'CONDOS',
    'CONSTRUCTION',
    'CONSULTING',
    'CONTACT',
    'CONTRACTORS',
    'COOKING',
    'COOKINGCHANNEL',
    'COOL',
    'COOP',
    'CORSICA',
    'COUNTRY',
    'COUPON',
    'COUPONS',
    'COURSES',
    'CR',
    'CREDIT',
    'CREDITCARD',
    'CREDITUNION',
    'CRICKET',
    'CROWN',
    'CRS',
    'CRUISE',
    'CRUISES',
    'CSC',
    'CU',
    'CUISINELLA',
    'CV',
    'CW',
    'CX',
    'CY',
    'CYMRU',
    'CYOU',
    'CZ',
    'DABUR',
    'DAD',
    'DANCE',
    'DATA',
    'DATE',
    'DATING',
    'DATSUN',
    'DAY',
    'DCLK',
    'DDS',
    'DE',
    'DEAL',
    'DEALER',
    'DEALS',
    'DEGREE',
    'DELIVERY',
    'DELL',
    'DELOITTE',
    'DELTA',
    'DEMOCRAT',
    'DENTAL',
    'DENTIST',
    'DESI',
    'DESIGN',
    'DEV',
    'DHL',
    'DIAMONDS',
    'DIET',
    'DIGITAL',
    'DIRECT',
    'DIRECTORY',
    'DISCOUNT',
    'DISCOVER',
    'DISH',
    'DIY',
    'DJ',
    'DK',
    'DM',
    'DNP',
    'DO',
    'DOCS',
    'DOCTOR',
    'DODGE',
    'DOG',
    'DOMAINS',
    'DOT',
    'DOWNLOAD',
    'DRIVE',
    'DTV',
    'DUBAI',
    'DUCK',
    'DUNLOP',
    'DUPONT',
    'DURBAN',
    'DVAG',
    'DVR',
    'DZ',
    'EARTH',
    'EAT',
    'EC',
    'ECO',
    'EDEKA',
    'EDU',
    'EDUCATION',
    'EE',
    'EG',
    'EMAIL',
    'EMERCK',
    'ENERGY',
    'ENGINEER',
    'ENGINEERING',
    'ENTERPRISES',
    'EPSON',
    'EQUIPMENT',
    'ER',
    'ERICSSON',
    'ERNI',
    'ES',
    'ESQ',
    'ESTATE',
    'ESURANCE',
    'ET',
    'ETISALAT',
    'EU',
    'EUROVISION',
    'EUS',
    'EVENTS',
    'EVERBANK',
    'EXCHANGE',
    'EXPERT',
    'EXPOSED',
    'EXPRESS',
    'EXTRASPACE',
    'FAGE',
    'FAIL',
    'FAIRWINDS',
    'FAITH',
    'FAMILY',
    'FAN',
    'FANS',
    'FARM',
    'FARMERS',
    'FASHION',
    'FAST',
    'FEDEX',
    'FEEDBACK',
    'FERRARI',
    'FERRERO',
    'FI',
    'FIAT',
    'FIDELITY',
    'FIDO',
    'FILM',
    'FINAL',
    'FINANCE',
    'FINANCIAL',
    'FIRE',
    'FIRESTONE',
    'FIRMDALE',
    'FISH',
    'FISHING',
    'FIT',
    'FITNESS',
    'FJ',
    'FK',
    'FLICKR',
    'FLIGHTS',
    'FLIR',
    'FLORIST',
    'FLOWERS',
    'FLY',
    'FM',
    'FO',
    'FOO',
    'FOOD',
    'FOODNETWORK',
    'FOOTBALL',
    'FORD',
    'FOREX',
    'FORSALE',
    'FORUM',
    'FOUNDATION',
    'FOX',
    'FR',
    'FREE',
    'FRESENIUS',
    'FRL',
    'FROGANS',
    'FRONTDOOR',
    'FRONTIER',
    'FTR',
    'FUJITSU',
    'FUJIXEROX',
    'FUN',
    'FUND',
    'FURNITURE',
    'FUTBOL',
    'FYI',
    'GA',
    'GAL',
    'GALLERY',
    'GALLO',
    'GALLUP',
    'GAME',
    'GAMES',
    'GAP',
    'GARDEN',
    'GAY',
    'GB',
    'GBIZ',
    'GD',
    'GDN',
    'GE',
    'GEA',
    'GENT',
    'GENTING',
    'GEORGE',
    'GF',
    'GG',
    'GGEE',
    'GH',
    'GI',
    'GIFT',
    'GIFTS',
    'GIVES',
    'GIVING',
    'GL',
    'GLADE',
    'GLASS',
    'GLE',
    'GLOBAL',
    'GLOBO',
    'GM',
    'GMAIL',
    'GMBH',
    'GMO',
    'GMX',
    'GN',
    'GODADDY',
    'GOLD',
    'GOLDPOINT',
    'GOLF',
    'GOO',
    'GOODYEAR',
    'GOOG',
    'GOOGLE',
    'GOP',
    'GOT',
    'GOV',
    'GP',
    'GQ',
    'GR',
    'GRAINGER',
    'GRAPHICS',
    'GRATIS',
    'GREEN',
    'GRIPE',
    'GROCERY',
    'GROUP',
    'GS',
    'GT',
    'GU',
    'GUARDIAN',
    'GUCCI',
    'GUGE',
    'GUIDE',
    'GUITARS',
    'GURU',
    'GW',
    'GY',
    'HAIR',
    'HAMBURG',
    'HANGOUT',
    'HAUS',
    'HBO',
    'HDFC',
    'HDFCBANK',
    'HEALTH',
    'HEALTHCARE',
    'HELP',
    'HELSINKI',
    'HERE',
    'HERMES',
    'HGTV',
    'HIPHOP',
    'HISAMITSU',
    'HITACHI',
    'HIV',
    'HK',
    'HKT',
    'HM',
    'HN',
    'HOCKEY',
    'HOLDINGS',
    'HOLIDAY',
    'HOMEDEPOT',
    'HOMEGOODS',
    'HOMES',
    'HOMESENSE',
    'HONDA',
    'HORSE',
    'HOSPITAL',
    'HOST',
    'HOSTING',
    'HOT',
    'HOTELES',
    'HOTELS',
    'HOTMAIL',
    'HOUSE',
    'HOW',
    'HR',
    'HSBC',
    'HT',
    'HU',
    'HUGHES',
    'HYATT',
    'HYUNDAI',
    'IBM',
    'ICBC',
    'ICE',
    'ICU',
    'ID',
    'IE',
    'IEEE',
    'IFM',
    'IKANO',
    'IL',
    'IM',
    'IMAMAT',
    'IMDB',
    'IMMO',
    'IMMOBILIEN',
    'IN',
    'INC',
    'INDUSTRIES',
    'INFINITI',
    'INFO',
    'ING',
    'INK',
    'INSTITUTE',
    'INSURANCE',
    'INSURE',
    'INT',
    'INTEL',
    'INTERNATIONAL',
    'INTUIT',
    'INVESTMENTS',
    'IO',
    'IPIRANGA',
    'IQ',
    'IR',
    'IRISH',
    'IS',
    'ISMAILI',
    'IST',
    'ISTANBUL',
    'IT',
    'ITAU',
    'ITV',
    'IVECO',
    'JAGUAR',
    'JAVA',
    'JCB',
    'JCP',
    'JE',
    'JEEP',
    'JETZT',
    'JEWELRY',
    'JIO',
    'JLL',
    'JM',
    'JMP',
    'JNJ',
    'JO',
    'JOBS',
    'JOBURG',
    'JOT',
    'JOY',
    'JP',
    'JPMORGAN',
    'JPRS',
    'JUEGOS',
    'JUNIPER',
    'KAUFEN',
    'KDDI',
    'KE',
    'KERRYHOTELS',
    'KERRYLOGISTICS',
    'KERRYPROPERTIES',
    'KFH',
    'KG',
    'KH',
    'KI',
    'KIA',
    'KIM',
    'KINDER',
    'KINDLE',
    'KITCHEN',
    'KIWI',
    'KM',
    'KN',
    'KOELN',
    'KOMATSU',
    'KOSHER',
    'KP',
    'KPMG',
    'KPN',
    'KR',
    'KRD',
    'KRED',
    'KUOKGROUP',
    'KW',
    'KY',
    'KYOTO',
    'KZ',
    'LA',
    'LACAIXA',
    'LADBROKES',
    'LAMBORGHINI',
    'LAMER',
    'LANCASTER',
    'LANCIA',
    'LANCOME',
    'LAND',
    'LANDROVER',
    'LANXESS',
    'LASALLE',
    'LAT',
    'LATINO',
    'LATROBE',
    'LAW',
    'LAWYER',
    'LB',
    'LC',
    'LDS',
    'LEASE',
    'LECLERC',
    'LEFRAK',
    'LEGAL',
    'LEGO',
    'LEXUS',
    'LGBT',
    'LI',
    'LIAISON',
    'LIDL',
    'LIFE',
    'LIFEINSURANCE',
    'LIFESTYLE',
    'LIGHTING',
    'LIKE',
    'LILLY',
    'LIMITED',
    'LIMO',
    'LINCOLN',
    'LINDE',
    'LINK',
    'LIPSY',
    'LIVE',
    'LIVING',
    'LIXIL',
    'LK',
    'LLC',
    'LOAN',
    'LOANS',
    'LOCKER',
    'LOCUS',
    'LOFT',
    'LOL',
    'LONDON',
    'LOTTE',
    'LOTTO',
    'LOVE',
    'LPL',
    'LPLFINANCIAL',
    'LR',
    'LS',
    'LT',
    'LTD',
    'LTDA',
    'LU',
    'LUNDBECK',
    'LUPIN',
    'LUXE',
    'LUXURY',
    'LV',
    'LY',
    'MA',
    'MACYS',
    'MADRID',
    'MAIF',
    'MAISON',
    'MAKEUP',
    'MAN',
    'MANAGEMENT',
    'MANGO',
    'MAP',
    'MARKET',
    'MARKETING',
    'MARKETS',
    'MARRIOTT',
    'MARSHALLS',
    'MASERATI',
    'MATTEL',
    'MBA',
    'MC',
    'MCKINSEY',
    'MD',
    'ME',
    'MED',
    'MEDIA',
    'MEET',
    'MELBOURNE',
    'MEME',
    'MEMORIAL',
    'MEN',
    'MENU',
    'MERCKMSD',
    'METLIFE',
    'MG',
    'MH',
    'MIAMI',
    'MICROSOFT',
    'MIL',
    'MINI',
    'MINT',
    'MIT',
    'MITSUBISHI',
    'MK',
    'ML',
    'MLB',
    'MLS',
    'MM',
    'MMA',
    'MN',
    'MO',
    'MOBI',
    'MOBILE',
    'MODA',
    'MOE',
    'MOI',
    'MOM',
    'MONASH',
    'MONEY',
    'MONSTER',
    'MOPAR',
    'MORMON',
    'MORTGAGE',
    'MOSCOW',
    'MOTO',
    'MOTORCYCLES',
    'MOV',
    'MOVIE',
    'MOVISTAR',
    'MP',
    'MQ',
    'MR',
    'MS',
    'MSD',
    'MT',
    'MTN',
    'MTR',
    'MU',
    'MUSEUM',
    'MUTUAL',
    'MV',
    'MW',
    'MX',
    'MY',
    'MZ',
    'NA',
    'NAB',
    'NADEX',
    'NAGOYA',
    'NAME',
    'NATIONWIDE',
    'NATURA',
    'NAVY',
    'NBA',
    'NC',
    'NE',
    'NEC',
    'NET',
    'NETBANK',
    'NETFLIX',
    'NETWORK',
    'NEUSTAR',
    'NEW',
    'NEWHOLLAND',
    'NEWS',
    'NEXT',
    'NEXTDIRECT',
    'NEXUS',
    'NF',
    'NFL',
    'NG',
    'NGO',
    'NHK',
    'NI',
    'NICO',
    'NIKE',
    'NIKON',
    'NINJA',
    'NISSAN',
    'NISSAY',
    'NL',
    'NO',
    'NOKIA',
    'NORTHWESTERNMUTUAL',
    'NORTON',
    'NOW',
    'NOWRUZ',
    'NOWTV',
    'NP',
    'NR',
    'NRA',
    'NRW',
    'NTT',
    'NU',
    'NYC',
    'NZ',
    'OBI',
    'OBSERVER',
    'OFF',
    'OFFICE',
    'OKINAWA',
    'OLAYAN',
    'OLAYANGROUP',
    'OLDNAVY',
    'OLLO',
    'OM',
    'OMEGA',
    'ONE',
    'ONG',
    'ONL',
    'ONLINE',
    'ONYOURSIDE',
    'OOO',
    'OPEN',
    'ORACLE',
    'ORANGE',
    'ORG',
    'ORGANIC',
    'ORIGINS',
    'OSAKA',
    'OTSUKA',
    'OTT',
    'OVH',
    'PA',
    'PAGE',
    'PANASONIC',
    'PARIS',
    'PARS',
    'PARTNERS',
    'PARTS',
    'PARTY',
    'PASSAGENS',
    'PAY',
    'PCCW',
    'PE',
    'PET',
    'PF',
    'PFIZER',
    'PG',
    'PH',
    'PHARMACY',
    'PHD',
    'PHILIPS',
    'PHONE',
    'PHOTO',
    'PHOTOGRAPHY',
    'PHOTOS',
    'PHYSIO',
    'PIAGET',
    'PICS',
    'PICTET',
    'PICTURES',
    'PID',
    'PIN',
    'PING',
    'PINK',
    'PIONEER',
    'PIZZA',
    'PK',
    'PL',
    'PLACE',
    'PLAY',
    'PLAYSTATION',
    'PLUMBING',
    'PLUS',
    'PM',
    'PN',
    'PNC',
    'POHL',
    'POKER',
    'POLITIE',
    'PORN',
    'POST',
    'PR',
    'PRAMERICA',
    'PRAXI',
    'PRESS',
    'PRIME',
    'PRO',
    'PROD',
    'PRODUCTIONS',
    'PROF',
    'PROGRESSIVE',
    'PROMO',
    'PROPERTIES',
    'PROPERTY',
    'PROTECTION',
    'PRU',
    'PRUDENTIAL',
    'PS',
    'PT',
    'PUB',
    'PW',
    'PWC',
    'PY',
    'QA',
    'QPON',
    'QUEBEC',
    'QUEST',
    'QVC',
    'RACING',
    'RADIO',
    'RAID',
    'RE',
    'READ',
    'REALESTATE',
    'REALTOR',
    'REALTY',
    'RECIPES',
    'RED',
    'REDSTONE',
    'REDUMBRELLA',
    'REHAB',
    'REISE',
    'REISEN',
    'REIT',
    'RELIANCE',
    'REN',
    'RENT',
    'RENTALS',
    'REPAIR',
    'REPORT',
    'REPUBLICAN',
    'REST',
    'RESTAURANT',
    'REVIEW',
    'REVIEWS',
    'REXROTH',
    'RICH',
    'RICHARDLI',
    'RICOH',
    'RIGHTATHOME',
    'RIL',
    'RIO',
    'RIP',
    'RMIT',
    'RO',
    'ROCHER',
    'ROCKS',
    'RODEO',
    'ROGERS',
    'ROOM',
    'RS',
    'RSVP',
    'RU',
    'RUGBY',
    'RUHR',
    'RUN',
    'RW',
    'RWE',
    'RYUKYU',
    'SA',
    'SAARLAND',
    'SAFE',
    'SAFETY',
    'SAKURA',
    'SALE',
    'SALON',
    'SAMSCLUB',
    'SAMSUNG',
    'SANDVIK',
    'SANDVIKCOROMANT',
    'SANOFI',
    'SAP',
    'SARL',
    'SAS',
    'SAVE',
    'SAXO',
    'SB',
    'SBI',
    'SBS',
    'SC',
    'SCA',
    'SCB',
    'SCHAEFFLER',
    'SCHMIDT',
    'SCHOLARSHIPS',
    'SCHOOL',
    'SCHULE',
    'SCHWARZ',
    'SCIENCE',
    'SCJOHNSON',
    'SCOR',
    'SCOT',
    'SD',
    'SE',
    'SEARCH',
    'SEAT',
    'SECURE',
    'SECURITY',
    'SEEK',
    'SELECT',
    'SENER',
    'SERVICES',
    'SES',
    'SEVEN',
    'SEW',
    'SEX',
    'SEXY',
    'SFR',
    'SG',
    'SH',
    'SHANGRILA',
    'SHARP',
    'SHAW',
    'SHELL',
    'SHIA',
    'SHIKSHA',
    'SHOES',
    'SHOP',
    'SHOPPING',
    'SHOUJI',
    'SHOW',
    'SHOWTIME',
    'SHRIRAM',
    'SI',
    'SILK',
    'SINA',
    'SINGLES',
    'SITE',
    'SJ',
    'SK',
    'SKI',
    'SKIN',
    'SKY',
    'SKYPE',
    'SL',
    'SLING',
    'SM',
    'SMART',
    'SMILE',
    'SN',
    'SNCF',
    'SO',
    'SOCCER',
    'SOCIAL',
    'SOFTBANK',
    'SOFTWARE',
    'SOHU',
    'SOLAR',
    'SOLUTIONS',
    'SONG',
    'SONY',
    'SOY',
    'SPACE',
    'SPORT',
    'SPOT',
    'SPREADBETTING',
    'SR',
    'SRL',
    'SRT',
    'SS',
    'ST',
    'STADA',
    'STAPLES',
    'STAR',
    'STATEBANK',
    'STATEFARM',
    'STC',
    'STCGROUP',
    'STOCKHOLM',
    'STORAGE',
    'STORE',
    'STREAM',
    'STUDIO',
    'STUDY',
    'STYLE',
    'SU',
    'SUCKS',
    'SUPPLIES',
    'SUPPLY',
    'SUPPORT',
    'SURF',
    'SURGERY',
    'SUZUKI',
    'SV',
    'SWATCH',
    'SWIFTCOVER',
    'SWISS',
    'SX',
    'SY',
    'SYDNEY',
    'SYMANTEC',
    'SYSTEMS',
    'SZ',
    'TAB',
    'TAIPEI',
    'TALK',
    'TAOBAO',
    'TARGET',
    'TATAMOTORS',
    'TATAR',
    'TATTOO',
    'TAX',
    'TAXI',
    'TC',
    'TCI',
    'TD',
    'TDK',
    'TEAM',
    'TECH',
    'TECHNOLOGY',
    'TEL',
    'TELEFONICA',
    'TEMASEK',
    'TENNIS',
    'TEVA',
    'TF',
    'TG',
    'TH',
    'THD',
    'THEATER',
    'THEATRE',
    'TIAA',
    'TICKETS',
    'TIENDA',
    'TIFFANY',
    'TIPS',
    'TIRES',
    'TIROL',
    'TJ',
    'TJMAXX',
    'TJX',
    'TK',
    'TKMAXX',
    'TL',
    'TM',
    'TMALL',
    'TN',
    'TO',
    'TODAY',
    'TOKYO',
    'TOOLS',
    'TOP',
    'TORAY',
    'TOSHIBA',
    'TOTAL',
    'TOURS',
    'TOWN',
    'TOYOTA',
    'TOYS',
    'TR',
    'TRADE',
    'TRADING',
    'TRAINING',
    'TRAVEL',
    'TRAVELCHANNEL',
    'TRAVELERS',
    'TRAVELERSINSURANCE',
    'TRUST',
    'TRV',
    'TT',
    'TUBE',
    'TUI',
    'TUNES',
    'TUSHU',
    'TV',
    'TVS',
    'TW',
    'TZ',
    'UA',
    'UBANK',
    'UBS',
    'UCONNECT',
    'UG',
    'UK',
    'UNICOM',
    'UNIVERSITY',
    'UNO',
    'UOL',
    'UPS',
    'US',
    'UY',
    'UZ',
    'VA',
    'VACATIONS',
    'VANA',
    'VANGUARD',
    'VC',
    'VE',
    'VEGAS',
    'VENTURES',
    'VERISIGN',
    'VERSICHERUNG',
    'VET',
    'VG',
    'VI',
    'VIAJES',
    'VIDEO',
    'VIG',
    'VIKING',
    'VILLAS',
    'VIN',
    'VIP',
    'VIRGIN',
    'VISA',
    'VISION',
    'VISTAPRINT',
    'VIVA',
    'VIVO',
    'VLAANDEREN',
    'VN',
    'VODKA',
    'VOLKSWAGEN',
    'VOLVO',
    'VOTE',
    'VOTING',
    'VOTO',
    'VOYAGE',
    'VU',
    'VUELOS',
    'WALES',
    'WALMART',
    'WALTER',
    'WANG',
    'WANGGOU',
    'WARMAN',
    'WATCH',
    'WATCHES',
    'WEATHER',
    'WEATHERCHANNEL',
    'WEBCAM',
    'WEBER',
    'WEBSITE',
    'WED',
    'WEDDING',
    'WEIBO',
    'WEIR',
    'WF',
    'WHOSWHO',
    'WIEN',
    'WIKI',
    'WILLIAMHILL',
    'WIN',
    'WINDOWS',
    'WINE',
    'WINNERS',
    'WME',
    'WOLTERSKLUWER',
    'WOODSIDE',
    'WORK',
    'WORKS',
    'WORLD',
    'WOW',
    'WS',
    'WTC',
    'WTF',
    'XBOX',
    'XEROX',
    'XFINITY',
    'XIHUAN',
    'XIN',
    'XN--11B4C3D',
    'XN--1CK2E1B',
    'XN--1QQW23A',
    'XN--2SCRJ9C',
    'XN--30RR7Y',
    'XN--3BST00M',
    'XN--3DS443G',
    'XN--3E0B707E',
    'XN--3HCRJ9C',
    'XN--3OQ18VL8PN36A',
    'XN--3PXU8K',
    'XN--42C2D9A',
    'XN--45BR5CYL',
    'XN--45BRJ9C',
    'XN--45Q11C',
    'XN--4GBRIM',
    'XN--54B7FTA0CC',
    'XN--55QW42G',
    'XN--55QX5D',
    'XN--5SU34J936BGSG',
    'XN--5TZM5G',
    'XN--6FRZ82G',
    'XN--6QQ986B3XL',
    'XN--80ADXHKS',
    'XN--80AO21A',
    'XN--80AQECDR1A',
    'XN--80ASEHDB',
    'XN--80ASWG',
    'XN--8Y0A063A',
    'XN--90A3AC',
    'XN--90AE',
    'XN--90AIS',
    'XN--9DBQ2A',
    'XN--9ET52U',
    'XN--9KRT00A',
    'XN--B4W605FERD',
    'XN--BCK1B9A5DRE4C',
    'XN--C1AVG',
    'XN--C2BR7G',
    'XN--CCK2B3B',
    'XN--CG4BKI',
    'XN--CLCHC0EA0B2G2A9GCD',
    'XN--CZR694B',
    'XN--CZRS0T',
    'XN--CZRU2D',
    'XN--D1ACJ3B',
    'XN--D1ALF',
    'XN--E1A4C',
    'XN--ECKVDTC9D',
    'XN--EFVY88H',
    'XN--ESTV75G',
    'XN--FCT429K',
    'XN--FHBEI',
    'XN--FIQ228C5HS',
    'XN--FIQ64B',
    'XN--FIQS8S',
    'XN--FIQZ9S',
    'XN--FJQ720A',
    'XN--FLW351E',
    'XN--FPCRJ9C3D',
    'XN--FZC2C9E2C',
    'XN--FZYS8D69UVGM',
    'XN--G2XX48C',
    'XN--GCKR3F0F',
    'XN--GECRJ9C',
    'XN--GK3AT1E',
    'XN--H2BREG3EVE',
    'XN--H2BRJ9C',
    'XN--H2BRJ9C8C',
    'XN--HXT814E',
    'XN--I1B6B1A6A2E',
    'XN--IMR513N',
    'XN--IO0A7I',
    'XN--J1AEF',
    'XN--J1AMH',
    'XN--J6W193G',
    'XN--JLQ61U9W7B',
    'XN--JVR189M',
    'XN--KCRX77D1X4A',
    'XN--KPRW13D',
    'XN--KPRY57D',
    'XN--KPU716F',
    'XN--KPUT3I',
    'XN--L1ACC',
    'XN--LGBBAT1AD8J',
    'XN--MGB9AWBF',
    'XN--MGBA3A3EJT',
    'XN--MGBA3A4F16A',
    'XN--MGBA7C0BBN0A',
    'XN--MGBAAKC7DVF',
    'XN--MGBAAM7A8H',
    'XN--MGBAB2BD',
    'XN--MGBAH1A3HJKRD',
    'XN--MGBAI9AZGQP6J',
    'XN--MGBAYH7GPA',
    'XN--MGBBH1A',
    'XN--MGBBH1A71E',
    'XN--MGBC0A9AZCG',
    'XN--MGBCA7DZDO',
    'XN--MGBERP4A5D4AR',
    'XN--MGBGU82A',
    'XN--MGBI4ECEXP',
    'XN--MGBPL2FH',
    'XN--MGBT3DHD',
    'XN--MGBTX2B',
    'XN--MGBX4CD0AB',
    'XN--MIX891F',
    'XN--MK1BU44C',
    'XN--MXTQ1M',
    'XN--NGBC5AZD',
    'XN--NGBE9E0A',
    'XN--NGBRX',
    'XN--NODE',
    'XN--NQV7F',
    'XN--NQV7FS00EMA',
    'XN--NYQY26A',
    'XN--O3CW4H',
    'XN--OGBPF8FL',
    'XN--OTU796D',
    'XN--P1ACF',
    'XN--P1AI',
    'XN--PBT977C',
    'XN--PGBS0DH',
    'XN--PSSY2U',
    'XN--Q9JYB4C',
    'XN--QCKA1PMC',
    'XN--QXA6A',
    'XN--QXAM',
    'XN--RHQV96G',
    'XN--ROVU88B',
    'XN--RVC1E0AM3E',
    'XN--S9BRJ9C',
    'XN--SES554G',
    'XN--T60B56A',
    'XN--TCKWE',
    'XN--TIQ49XQYJ',
    'XN--UNUP4Y',
    'XN--VERMGENSBERATER-CTB',
    'XN--VERMGENSBERATUNG-PWB',
    'XN--VHQUV',
    'XN--VUQ861B',
    'XN--W4R85EL8FHU5DNRA',
    'XN--W4RS40L',
    'XN--WGBH1C',
    'XN--WGBL6A',
    'XN--XHQ521B',
    'XN--XKC2AL3HYE2A',
    'XN--XKC2DL3A5EE0H',
    'XN--Y9A3AQ',
    'XN--YFRO4I67O',
    'XN--YGBI2AMMX',
    'XN--ZFR164B',
    'XXX',
    'XYZ',
    'YACHTS',
    'YAHOO',
    'YAMAXUN',
    'YANDEX',
    'YE',
    'YODOBASHI',
    'YOGA',
    'YOKOHAMA',
    'YOU',
    'YOUTUBE',
    'YT',
    'YUN',
    'ZA',
    'ZAPPOS',
    'ZARA',
    'ZERO',
    'ZIP',
    'ZM',
    'ZONE',
    'ZUERICH',
    'ZW'
];


// Keep as upper-case to make updating from source easier

module.exports = new Set(internals.tlds.map((tld) => tld.toLowerCase()));


/***/ }),

/***/ "./node_modules/@hapi/ammo/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/ammo/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


internals.Range = class {

    constructor(from, to) {

        this.from = from;
        this.to = to;
    }
};


exports.header = function (header, length) {

    // Parse header

    const parts = header.split('=');
    if (parts.length !== 2 ||
        parts[0] !== 'bytes') {

        return null;
    }

    const lastPos = length - 1;

    const result = [];
    const ranges = parts[1].match(/\d*\-\d*/g);

    // Handle headers with multiple ranges

    for (let i = 0; i < ranges.length; ++i) {
        let range = ranges[i];
        if (range.length === 1) {               // '-'
            return null;
        }

        let from;
        let to;
        range = range.split('-');
        if (range[0]) {
            from = parseInt(range[0], 10);
        }

        if (range[1]) {
            to = parseInt(range[1], 10);
            if (from !== undefined) {      // Can be 0
                // From-To
                if (to > lastPos) {
                    to = lastPos;
                }
            }
            else {
                // -To
                from = length - to;
                to = lastPos;
            }
        }
        else {
            // From-
            to = lastPos;
        }

        if (from > to) {
            return null;
        }

        result.push(new internals.Range(from, to));
    }

    if (result.length === 1) {
        return result;
    }

    // Sort and consolidate ranges

    result.sort((a, b) => a.from - b.from);

    const consolidated = [];
    for (let i = result.length - 1; i > 0; --i) {
        const current = result[i];
        const before = result[i - 1];
        if (current.from <= before.to + 1) {
            before.to = current.to;
        }
        else {
            consolidated.unshift(current);
        }
    }

    consolidated.unshift(result[0]);

    return consolidated;
};


exports.Stream = internals.Stream = class extends Stream.Transform {

    constructor(range) {

        if (!(range instanceof internals.Range)) {
            Hoek.assert(typeof range === 'object', 'Expected "range" object');

            const from = range.from || 0;
            Hoek.assert(typeof from === 'number', '"range.from" must be falsy, or a number');
            Hoek.assert(from === parseInt(from, 10) && from >= 0, '"range.from" must be a positive integer');

            const to = range.to || 0;
            Hoek.assert(typeof to === 'number', '"range.to" must be falsy, or a number');
            Hoek.assert(to === parseInt(to, 10) && to >= 0, '"range.to" must be a positive integer');

            Hoek.assert(to >= from, '"range.to" must be greater than or equal to "range.from"');

            range = new internals.Range(from, to);
        }

        super();

        this._range = range;
        this._next = 0;
    }

    processChunk(chunk) {

        // Read desired range from a stream

        const pos = this._next;
        this._next = this._next + chunk.length;

        if (this._next <= this._range.from ||       // Before range
            pos > this._range.to) {                 // After range

            return;
        }

        // Calc bounds of chunk to read

        const from = Math.max(0, this._range.from - pos);
        const to = Math.min(chunk.length, this._range.to - pos + 1);

        this.push(chunk.slice(from, to));
    }

    _transform(chunk, encoding, done) {

        try {
            this.processChunk(chunk);
        }
        catch (err) {
            return done(err);
        }

        return done();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/b64/lib/decoder.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/b64/lib/decoder.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    Decode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

const Stream = __webpack_require__(/*! stream */ "stream");


const internals = {
    decodeChars: [
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
        52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1,
        -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
        15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
        -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
        41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1
    ]
};


exports.decode = function (buffer) {

    const decodeChars = internals.decodeChars;
    const len = buffer.length;
    const allocated = Math.ceil(len / 4) * 3;
    const result = Buffer.alloc(allocated);

    let c1;
    let c2;
    let c3;
    let c4;
    let j = 0;

    for (let i = 0; i < len; ) {
        do {
            c1 = decodeChars[buffer[i++] & 0xff];
        }
        while (i < len && c1 === -1);

        if (c1 === -1) {
            break;
        }

        do {
            c2 = decodeChars[buffer[i++] & 0xff];
        }
        while (i < len && c2 === -1);

        if (c2 === -1) {
            break;
        }

        result[j++] = (c1 << 2) | ((c2 & 0x30) >> 4);

        do {
            c3 = buffer[i++] & 0xff;
            if (c3 === 61) {                        // =
                return result.slice(0, j);
            }

            c3 = decodeChars[c3];
        }
        while (i < len && c3 === -1);

        if (c3 === -1) {
            break;
        }

        result[j++] = ((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2);

        do {
            c4 = buffer[i++] & 0xff;
            if (c4 === 61) {                        // =
                return result.slice(0, j);
            }

            c4 = decodeChars[c4];
        }
        while (i < len && c4 === -1);

        if (c4 !== -1) {
            result[j++] = ((c3 & 0x03) << 6) | c4;
        }
    }

    return (j === allocated ? result : result.slice(0, j));
};


exports.Decoder = class Decoder extends Stream.Transform {
    constructor() {

        super();
        this._reminder = null;
    }

    _transform(chunk, encoding, callback) {

        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 4;
        if (remaining) {
            this._reminder = part.slice(part.length - remaining);
            part = part.slice(0, part.length - remaining);
        }
        else {
            this._reminder = null;
        }

        this.push(exports.decode(part));
        return callback();
    }

    _flush(callback) {

        if (this._reminder) {
            this.push(exports.decode(this._reminder));
        }

        return callback();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/b64/lib/encoder.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/b64/lib/encoder.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
    Encode functions adapted from:
    Version 1.0 12/25/99 Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
    http://www.onicos.com/staff/iz/amuse/javascript/expert/base64.txt
*/

const Stream = __webpack_require__(/*! stream */ "stream");


const internals = {};


exports.encode = function (buffer) {

    return Buffer.from(buffer.toString('base64'));
};


exports.Encoder = class Encoder extends Stream.Transform {
    constructor() {

        super();
        this._reminder = null;
    }

    _transform(chunk, encoding, callback) {

        let part = this._reminder ? Buffer.concat([this._reminder, chunk]) : chunk;
        const remaining = part.length % 3;
        if (remaining) {
            this._reminder = part.slice(part.length - remaining);
            part = part.slice(0, part.length - remaining);
        }
        else {
            this._reminder = null;
        }

        this.push(exports.encode(part));
        return callback();
    }

    _flush(callback) {

        if (this._reminder) {
            this.push(exports.encode(this._reminder));
        }

        return callback();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/b64/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/b64/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/@hapi/b64/lib/decoder.js");
const Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/@hapi/b64/lib/encoder.js");


exports.decode = Decoder.decode;

exports.encode = Encoder.encode;

exports.Decoder = Decoder.Decoder;

exports.Encoder = Encoder.Encoder;


// Base64url (RFC 4648) encode

exports.base64urlEncode = function (value, encoding) {

    Hoek.assert(typeof value === 'string' || Buffer.isBuffer(value), 'value must be string or buffer');
    const buf = (Buffer.isBuffer(value) ? value : Buffer.from(value, encoding || 'binary'));
    return buf.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
};


// Base64url (RFC 4648) decode

exports.base64urlDecode = function (value, encoding) {

    if (typeof value !== 'string') {

        throw new Error('Value not a string');
    }

    if (!/^[\w\-]*$/.test(value)) {

        throw new Error('Invalid character');
    }

    const buf = Buffer.from(value, 'base64');
    return (encoding === 'buffer' ? buf : buf.toString(encoding || 'binary'));
};


/***/ }),

/***/ "./node_modules/@hapi/boom/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/boom/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    codes: new Map([
        [100, 'Continue'],
        [101, 'Switching Protocols'],
        [102, 'Processing'],
        [200, 'OK'],
        [201, 'Created'],
        [202, 'Accepted'],
        [203, 'Non-Authoritative Information'],
        [204, 'No Content'],
        [205, 'Reset Content'],
        [206, 'Partial Content'],
        [207, 'Multi-Status'],
        [300, 'Multiple Choices'],
        [301, 'Moved Permanently'],
        [302, 'Moved Temporarily'],
        [303, 'See Other'],
        [304, 'Not Modified'],
        [305, 'Use Proxy'],
        [307, 'Temporary Redirect'],
        [400, 'Bad Request'],
        [401, 'Unauthorized'],
        [402, 'Payment Required'],
        [403, 'Forbidden'],
        [404, 'Not Found'],
        [405, 'Method Not Allowed'],
        [406, 'Not Acceptable'],
        [407, 'Proxy Authentication Required'],
        [408, 'Request Time-out'],
        [409, 'Conflict'],
        [410, 'Gone'],
        [411, 'Length Required'],
        [412, 'Precondition Failed'],
        [413, 'Request Entity Too Large'],
        [414, 'Request-URI Too Large'],
        [415, 'Unsupported Media Type'],
        [416, 'Requested Range Not Satisfiable'],
        [417, 'Expectation Failed'],
        [418, 'I\'m a teapot'],
        [422, 'Unprocessable Entity'],
        [423, 'Locked'],
        [424, 'Failed Dependency'],
        [425, 'Unordered Collection'],
        [426, 'Upgrade Required'],
        [428, 'Precondition Required'],
        [429, 'Too Many Requests'],
        [431, 'Request Header Fields Too Large'],
        [451, 'Unavailable For Legal Reasons'],
        [500, 'Internal Server Error'],
        [501, 'Not Implemented'],
        [502, 'Bad Gateway'],
        [503, 'Service Unavailable'],
        [504, 'Gateway Time-out'],
        [505, 'HTTP Version Not Supported'],
        [506, 'Variant Also Negotiates'],
        [507, 'Insufficient Storage'],
        [509, 'Bandwidth Limit Exceeded'],
        [510, 'Not Extended'],
        [511, 'Network Authentication Required']
    ])
};


module.exports = internals.Boom = class extends Error {

    constructor(message, options = {}) {

        if (message instanceof Error) {
            return internals.Boom.boomify(Hoek.clone(message), options);
        }

        const { statusCode = 500, data = null, ctor = internals.Boom } = options;
        const error = new Error(message ? message : undefined);         // Avoids settings null message
        Error.captureStackTrace(error, ctor);                           // Filter the stack to our external API
        error.data = data;
        const boom = internals.initialize(error, statusCode);

        Object.defineProperty(boom, 'typeof', { value: ctor });

        if (options.decorate) {
            Object.assign(boom, options.decorate);
        }

        return boom;
    }

    static [Symbol.hasInstance](instance) {

        return internals.Boom.isBoom(instance);
    }

    static isBoom(err) {

        return err instanceof Error && !!err.isBoom;
    }

    static boomify(err, options) {

        Hoek.assert(err instanceof Error, 'Cannot wrap non-Error object');

        options = options || {};

        if (options.data !== undefined) {
            err.data = options.data;
        }

        if (options.decorate) {
            Object.assign(err, options.decorate);
        }

        if (!err.isBoom) {
            return internals.initialize(err, options.statusCode || 500, options.message);
        }

        if (options.override === false ||                           // Defaults to true
            !options.statusCode && !options.message) {

            return err;
        }

        return internals.initialize(err, options.statusCode || err.output.statusCode, options.message);
    }

    // 4xx Client Errors

    static badRequest(message, data) {

        return new internals.Boom(message, { statusCode: 400, data, ctor: internals.Boom.badRequest });
    }

    static unauthorized(message, scheme, attributes) {          // Or (message, wwwAuthenticate[])

        const err = new internals.Boom(message, { statusCode: 401, ctor: internals.Boom.unauthorized });

        // function (message)

        if (!scheme) {
            return err;
        }

        // function (message, wwwAuthenticate[])

        if (typeof scheme !== 'string') {
            err.output.headers['WWW-Authenticate'] = scheme.join(', ');
            return err;
        }

        // function (message, scheme, attributes)

        let wwwAuthenticate = `${scheme} `;

        if (attributes ||
            message) {

            err.output.payload.attributes = {};
        }

        if (attributes) {
            if (typeof attributes === 'string') {
                wwwAuthenticate += Hoek.escapeHeaderAttribute(attributes);
                err.output.payload.attributes = attributes;
            }
            else {
                wwwAuthenticate += Object.keys(attributes).map((name) => {

                    let value = attributes[name];
                    if (value === null ||
                        value === undefined) {

                        value = '';
                    }

                    err.output.payload.attributes[name] = value;
                    return `${name}="${Hoek.escapeHeaderAttribute(value.toString())}"`;
                })
                    .join(', ');
            }
        }

        if (message) {
            if (attributes) {
                wwwAuthenticate += ', ';
            }

            wwwAuthenticate += `error="${Hoek.escapeHeaderAttribute(message)}"`;
            err.output.payload.attributes.error = message;
        }
        else {
            err.isMissing = true;
        }

        err.output.headers['WWW-Authenticate'] = wwwAuthenticate;
        return err;
    }

    static paymentRequired(message, data) {

        return new internals.Boom(message, { statusCode: 402, data, ctor: internals.Boom.paymentRequired });
    }

    static forbidden(message, data) {

        return new internals.Boom(message, { statusCode: 403, data, ctor: internals.Boom.forbidden });
    }

    static notFound(message, data) {

        return new internals.Boom(message, { statusCode: 404, data, ctor: internals.Boom.notFound });
    }

    static methodNotAllowed(message, data, allow) {

        const err = new internals.Boom(message, { statusCode: 405, data, ctor: internals.Boom.methodNotAllowed });

        if (typeof allow === 'string') {
            allow = [allow];
        }

        if (Array.isArray(allow)) {
            err.output.headers.Allow = allow.join(', ');
        }

        return err;
    }

    static notAcceptable(message, data) {

        return new internals.Boom(message, { statusCode: 406, data, ctor: internals.Boom.notAcceptable });
    }

    static proxyAuthRequired(message, data) {

        return new internals.Boom(message, { statusCode: 407, data, ctor: internals.Boom.proxyAuthRequired });
    }

    static clientTimeout(message, data) {

        return new internals.Boom(message, { statusCode: 408, data, ctor: internals.Boom.clientTimeout });
    }

    static conflict(message, data) {

        return new internals.Boom(message, { statusCode: 409, data, ctor: internals.Boom.conflict });
    }

    static resourceGone(message, data) {

        return new internals.Boom(message, { statusCode: 410, data, ctor: internals.Boom.resourceGone });
    }

    static lengthRequired(message, data) {

        return new internals.Boom(message, { statusCode: 411, data, ctor: internals.Boom.lengthRequired });
    }

    static preconditionFailed(message, data) {

        return new internals.Boom(message, { statusCode: 412, data, ctor: internals.Boom.preconditionFailed });
    }

    static entityTooLarge(message, data) {

        return new internals.Boom(message, { statusCode: 413, data, ctor: internals.Boom.entityTooLarge });
    }

    static uriTooLong(message, data) {

        return new internals.Boom(message, { statusCode: 414, data, ctor: internals.Boom.uriTooLong });
    }

    static unsupportedMediaType(message, data) {

        return new internals.Boom(message, { statusCode: 415, data, ctor: internals.Boom.unsupportedMediaType });
    }

    static rangeNotSatisfiable(message, data) {

        return new internals.Boom(message, { statusCode: 416, data, ctor: internals.Boom.rangeNotSatisfiable });
    }

    static expectationFailed(message, data) {

        return new internals.Boom(message, { statusCode: 417, data, ctor: internals.Boom.expectationFailed });
    }

    static teapot(message, data) {

        return new internals.Boom(message, { statusCode: 418, data, ctor: internals.Boom.teapot });
    }

    static badData(message, data) {

        return new internals.Boom(message, { statusCode: 422, data, ctor: internals.Boom.badData });
    }

    static locked(message, data) {

        return new internals.Boom(message, { statusCode: 423, data, ctor: internals.Boom.locked });
    }

    static failedDependency(message, data) {

        return new internals.Boom(message, { statusCode: 424, data, ctor: internals.Boom.failedDependency });
    }

    static preconditionRequired(message, data) {

        return new internals.Boom(message, { statusCode: 428, data, ctor: internals.Boom.preconditionRequired });
    }

    static tooManyRequests(message, data) {

        return new internals.Boom(message, { statusCode: 429, data, ctor: internals.Boom.tooManyRequests });
    }

    static illegal(message, data) {

        return new internals.Boom(message, { statusCode: 451, data, ctor: internals.Boom.illegal });
    }

    // 5xx Server Errors

    static internal(message, data, statusCode = 500) {

        return internals.serverError(message, data, statusCode, internals.Boom.internal);
    }

    static notImplemented(message, data) {

        return internals.serverError(message, data, 501, internals.Boom.notImplemented);
    }

    static badGateway(message, data) {

        return internals.serverError(message, data, 502, internals.Boom.badGateway);
    }

    static serverUnavailable(message, data) {

        return internals.serverError(message, data, 503, internals.Boom.serverUnavailable);
    }

    static gatewayTimeout(message, data) {

        return internals.serverError(message, data, 504, internals.Boom.gatewayTimeout);
    }

    static badImplementation(message, data) {

        const err = internals.serverError(message, data, 500, internals.Boom.badImplementation);
        err.isDeveloperError = true;
        return err;
    }
};


internals.Boom.default = internals.Boom;        // Support ES6 module import


internals.initialize = function (err, statusCode, message) {

    const numberCode = parseInt(statusCode, 10);
    Hoek.assert(!isNaN(numberCode) && numberCode >= 400, 'First argument must be a number (400+):', statusCode);

    err.isBoom = true;
    err.isServer = numberCode >= 500;

    if (!err.hasOwnProperty('data')) {
        err.data = null;
    }

    err.output = {
        statusCode: numberCode,
        payload: {},
        headers: {}
    };

    Object.defineProperty(err, 'reformat', { value: internals.reformat });

    if (!message &&
        !err.message) {

        err.reformat();
        message = err.output.payload.error;
    }

    if (message) {
        const props = Object.getOwnPropertyDescriptor(err, 'message') || Object.getOwnPropertyDescriptor(Object.getPrototypeOf(err), 'message');
        Hoek.assert(props.configurable && !props.get, 'The error is not compatible with boom');

        err.message = message + (err.message ? ': ' + err.message : '');
        err.output.payload.message = err.message;
    }

    err.reformat();
    return err;
};


internals.reformat = function (debug = false) {

    this.output.payload.statusCode = this.output.statusCode;
    this.output.payload.error = internals.codes.get(this.output.statusCode) || 'Unknown';

    if (this.output.statusCode === 500 && debug !== true) {
        this.output.payload.message = 'An internal server error occurred';              // Hide actual error from user
    }
    else if (this.message) {
        this.output.payload.message = this.message;
    }
};


internals.serverError = function (message, data, statusCode, ctor) {

    if (data instanceof Error &&
        !data.isBoom) {

        return internals.Boom.boomify(data, { statusCode, message });
    }

    return new internals.Boom(message, { statusCode, data, ctor });
};


/***/ }),

/***/ "./node_modules/@hapi/bounce/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/bounce/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! assert */ "assert");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    system: [

        // JavaScript

        EvalError,
        RangeError,
        ReferenceError,
        SyntaxError,
        TypeError,
        URIError,

        // Node

        Assert.AssertionError,

        // Hoek

        Hoek.Error
    ]
};


exports.rethrow = function (err, types, options = {}) {

    return internals.catch(err, types, options, true);
};


exports.ignore = function (err, types, options = {}) {

    return internals.catch(err, types, options, false);
};


internals.catch = function (err, types, options, match) {

    if (internals.match(err, types) !== match) {
        return;
    }

    // Error replacement

    if (options.override) {
        err = options.override;
    }

    // Error decorations

    if (options.decorate) {
        Object.assign(err, options.decorate);
    }

    if (options.return) {
        return err;
    }

    throw err;
};


exports.background = async function (operation, action = 'rethrow', types = 'system', options = {}) {

    try {
        if (typeof operation === 'function') {
            await operation();
        }
        else {
            await operation;
        }
    }
    catch (err) {
        exports[action](err, types, options);
    }
};


exports.isBoom = function (err) {

    return Boom.isBoom(err);
};


exports.isError = function (err) {

    return err instanceof Error;
};


exports.isSystem = function (err) {

    if (!err) {
        return false;
    }

    if (err.isBoom) {
        return false;
    }

    for (const system of internals.system) {
        if (err instanceof system) {
            return true;
        }
    }

    return false;
};


internals.rules = {
    system: exports.isSystem,
    boom: exports.isBoom
};


internals.match = function (err, types) {

    if (!types) {
        return true;
    }

    types = Array.isArray(types) ? types : [types];
    for (const type of types) {
        if (typeof type === 'string') {
            if (internals.rules[type](err)) {
                return true;
            }
        }
        else if (typeof type === 'object') {
            if (Hoek.contain(err, type, { deep: true, part: true })) {
                return true;
            }
        }
        else if (err instanceof type) {
            return true;
        }
    }

    return false;
};


/***/ }),

/***/ "./node_modules/@hapi/bourne/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/bourne/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



const internals = {
    suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
};


exports.parse = function (text, reviver, options) {

    // Normalize arguments

    if (!options) {
        if (reviver &&
            typeof reviver === 'object') {

            options = reviver;
            reviver = undefined;
        }
        else {
            options = {};
        }
    }

    // Parse normally, allowing exceptions

    const obj = JSON.parse(text, reviver);

    // options.protoAction: 'error' (default) / 'remove' / 'ignore'

    if (options.protoAction === 'ignore') {
        return obj;
    }

    // Ignore null and non-objects

    if (!obj ||
        typeof obj !== 'object') {

        return obj;
    }

    // Check original string for potential exploit

    if (!text.match(internals.suspectRx)) {
        return obj;
    }

    // Scan result for proto keys

    exports.scan(obj, options);

    return obj;
};


exports.scan = function (obj, options) {

    options = options || {};

    let next = [obj];

    while (next.length) {
        const nodes = next;
        next = [];

        for (const node of nodes) {
            if (Object.prototype.hasOwnProperty.call(node, '__proto__')) {      // Avoid calling node.hasOwnProperty directly
                if (options.protoAction !== 'remove') {
                    throw new SyntaxError('Object contains forbidden prototype property');
                }

                delete node.__proto__;
            }

            for (const key in node) {
                const value = node[key];
                if (value &&
                    typeof value === 'object') {

                    next.push(node[key]);
                }
            }
        }
    }
};


exports.safeParse = function (text, reviver) {

    try {
        return exports.parse(text, reviver);
    }
    catch (ignoreError) {
        return null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/call/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/call/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");

const Regex = __webpack_require__(/*! ./regex */ "./node_modules/@hapi/call/lib/regex.js");
const Segment = __webpack_require__(/*! ./segment */ "./node_modules/@hapi/call/lib/segment.js");


const internals = {
    pathRegex: Regex.generate(),
    defaults: {
        isCaseSensitive: true
    }
};


exports.Router = internals.Router = function (options) {

    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});

    this.routes = {};                               // Key: HTTP method or * for catch-all, value: sorted array of routes
    this.ids = {};                                  // Key: route id, value: record
    this.vhosts = null;                             // {} where Key: hostname, value: see this.routes

    this.specials = {
        badRequest: null,
        notFound: null,
        options: null
    };
};


internals.Router.prototype.add = function (config, route) {

    const method = config.method.toLowerCase();

    const vhost = config.vhost || '*';
    if (vhost !== '*') {
        this.vhosts = this.vhosts || {};
        this.vhosts[vhost] = this.vhosts[vhost] || {};
    }

    const table = (vhost === '*' ? this.routes : this.vhosts[vhost]);
    table[method] = table[method] || { routes: [], router: new Segment() };

    const analysis = config.analysis || this.analyze(config.path);
    const record = {
        path: config.path,
        route: route || config.path,
        segments: analysis.segments,
        params: analysis.params,
        fingerprint: analysis.fingerprint,
        settings: this.settings
    };

    // Add route

    table[method].router.add(analysis.segments, record);
    table[method].routes.push(record);
    table[method].routes.sort(internals.sort);

    const last = record.segments[record.segments.length - 1];
    if (last.empty) {
        table[method].router.add(analysis.segments.slice(0, -1), record);
    }

    if (config.id) {
        Hoek.assert(!this.ids[config.id], 'Route id', config.id, 'for path', config.path, 'conflicts with existing path', this.ids[config.id] && this.ids[config.id].path);
        this.ids[config.id] = record;
    }

    return record;
};


internals.Router.prototype.special = function (type, route) {

    Hoek.assert(Object.keys(this.specials).indexOf(type) !== -1, 'Unknown special route type:', type);

    this.specials[type] = { route };
};


internals.Router.prototype.route = function (method, path, hostname) {

    const segments = path.split('/').slice(1);

    const vhost = (this.vhosts && hostname && this.vhosts[hostname]);
    const route = (vhost && this._lookup(path, segments, vhost, method)) ||
        this._lookup(path, segments, this.routes, method) ||
        (method === 'head' && vhost && this._lookup(path, segments, vhost, 'get')) ||
        (method === 'head' && this._lookup(path, segments, this.routes, 'get')) ||
        (method === 'options' && this.specials.options) ||
        (vhost && this._lookup(path, segments, vhost, '*')) ||
        this._lookup(path, segments, this.routes, '*') ||
        this.specials.notFound || Boom.notFound();

    return route;
};


internals.Router.prototype._lookup = function (path, segments, table, method) {

    const set = table[method];
    if (!set) {
        return null;
    }

    const match = set.router.lookup(path, segments, this.settings);
    if (!match) {
        return null;
    }

    const assignments = {};
    const array = [];
    for (let i = 0; i < match.array.length; ++i) {
        const name = match.record.params[i];
        const value = internals.decode(match.array[i]);
        if (value.isBoom) {
            return this.specials.badRequest || value;
        }

        if (assignments[name] !== undefined) {
            assignments[name] = assignments[name] + '/' + value;
        }
        else {
            assignments[name] = value;
        }

        if (i + 1 === match.array.length ||                 // Only include the last segment of a multi-segment param
            name !== match.record.params[i + 1]) {

            array.push(assignments[name]);
        }
    }

    return { params: assignments, paramsArray: array, route: match.record.route };
};


internals.decode = function (value) {

    try {
        return decodeURIComponent(value);
    }
    catch (err) {
        return Boom.badRequest('Invalid request path');
    }
};


internals.Router.prototype.normalize = function (path) {

    if (path &&
        path.indexOf('%') !== -1) {

        // Uppercase %encoded values

        const uppercase = path.replace(/%[0-9a-fA-F][0-9a-fA-F]/g, (encoded) => encoded.toUpperCase());

        // Decode non-reserved path characters: a-z A-Z 0-9 _!$&'()*+,;=:@-.~
        // ! (%21) $ (%24) & (%26) ' (%27) ( (%28) ) (%29) * (%2A) + (%2B) , (%2C) - (%2D) . (%2E)
        // 0-9 (%30-39) : (%3A) ; (%3B) = (%3D)
        // @ (%40) A-Z (%41-5A) _ (%5F) a-z (%61-7A) ~ (%7E)

        const decoded = uppercase.replace(/%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g, (encoded) => String.fromCharCode(parseInt(encoded.substring(1), 16)));

        path = decoded;
    }

    // Normalize path segments

    if (path &&
        (path.indexOf('/.') !== -1 || path[0] === '.')) {

        const hasLeadingDash = path[0] === '/';
        const segments = path.split('/');
        const normalized = [];
        let segment;

        for (let i = 0; i < segments.length; ++i) {
            segment = segments[i];
            if (segment === '..') {
                normalized.pop();
            }
            else if (segment !== '.') {
                normalized.push(segment);
            }
        }

        if (segment === '.' ||
            segment === '..') {         // Add trailing slash when needed

            normalized.push('');
        }

        path = normalized.join('/');

        if (path[0] !== '/' &&
            hasLeadingDash) {

            path = '/' + path;
        }
    }

    return path;
};


internals.Router.prototype.analyze = function (path) {

    Hoek.assert(internals.pathRegex.validatePath.test(path), 'Invalid path:', path);
    Hoek.assert(!internals.pathRegex.validatePathEncoded.test(path), 'Path cannot contain encoded non-reserved path characters:', path);

    const pathParts = path.split('/');
    const segments = [];
    const params = [];
    const fingers = [];

    for (let i = 1; i < pathParts.length; ++i) {                            // Skip first empty segment
        let segment = pathParts[i];

        // Literal

        if (segment.indexOf('{') === -1) {
            segment = this.settings.isCaseSensitive ? segment : segment.toLowerCase();
            fingers.push(segment);
            segments.push({ literal: segment });
            continue;
        }

        // Parameter

        const parts = internals.parseParams(segment);
        if (parts.length === 1) {

            // Simple parameter

            const item = parts[0];
            Hoek.assert(params.indexOf(item.name) === -1, 'Cannot repeat the same parameter name:', item.name, 'in:', path);
            params.push(item.name);

            if (item.wilcard) {
                if (item.count) {
                    for (let j = 0; j < item.count; ++j) {
                        fingers.push('?');
                        segments.push({});
                        if (j) {
                            params.push(item.name);
                        }
                    }
                }
                else {
                    fingers.push('#');
                    segments.push({ wildcard: true });
                }
            }
            else {
                fingers.push('?');
                segments.push({ empty: item.empty });
            }
        }
        else {

            // Mixed parameter

            const seg = {
                length: parts.length,
                first: typeof parts[0] !== 'string',
                segments: []
            };

            let finger = '';
            let regex = '^';
            for (let j = 0; j < parts.length; ++j) {
                const part = parts[j];
                if (typeof part === 'string') {
                    finger = finger + part;
                    regex = regex + Hoek.escapeRegex(part);
                    seg.segments.push(part);
                }
                else {
                    Hoek.assert(params.indexOf(part.name) === -1, 'Cannot repeat the same parameter name:', part.name, 'in:', path);
                    params.push(part.name);

                    finger = finger + '?';
                    regex = regex + '(.' + (part.empty ? '*' : '+') + ')';
                }
            }

            seg.mixed = new RegExp(regex + '$', (!this.settings.isCaseSensitive ? 'i' : ''));
            fingers.push(finger);
            segments.push(seg);
        }
    }

    return {
        segments,
        fingerprint: '/' + fingers.join('/'),
        params
    };
};


internals.parseParams = function (segment) {

    const parts = [];
    segment.replace(internals.pathRegex.parseParam, (match, literal, name, wilcard, count, empty) => {

        if (literal) {
            parts.push(literal);
        }
        else {
            parts.push({
                name,
                wilcard: !!wilcard,
                count: count && parseInt(count, 10),
                empty: !!empty
            });
        }

        return '';
    });

    return parts;
};


internals.Router.prototype.table = function (host) {

    const result = [];
    const collect = (table) => {

        if (!table) {
            return;
        }

        Object.keys(table).forEach((method) => {

            table[method].routes.forEach((record) => {

                result.push(record.route);
            });
        });
    };

    if (this.vhosts) {
        const vhosts = host ? [].concat(host) : Object.keys(this.vhosts);
        for (let i = 0; i < vhosts.length; ++i) {
            collect(this.vhosts[vhosts[i]]);
        }
    }

    collect(this.routes);

    return result;
};


internals.sort = function (a, b) {

    const aFirst = -1;
    const bFirst = 1;

    const as = a.segments;
    const bs = b.segments;

    if (as.length !== bs.length) {
        return (as.length > bs.length ? bFirst : aFirst);
    }

    for (let i = 0; ; ++i) {
        if (as[i].literal) {
            if (bs[i].literal) {
                if (as[i].literal === bs[i].literal) {
                    continue;
                }

                return (as[i].literal > bs[i].literal ? bFirst : aFirst);
            }

            return aFirst;
        }

        if (bs[i].literal) {
            return bFirst;
        }

        return (as[i].wildcard ? bFirst : aFirst);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/call/lib/regex.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/call/lib/regex.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.generate = function () {

    /*
        /path/{param}/path/{param?}
        /path/{param*2}/path
        /path/{param*2}
        /path/x{param}x
        /{param*}
    */

    const empty = '(?:^\\/$)';

    const legalChars = '[\\w\\!\\$&\'\\(\\)\\*\\+\\,;\\=\\:@\\-\\.~]';
    const encoded = '%[A-F0-9]{2}';

    const literalChar = '(?:' + legalChars + '|' + encoded + ')';
    const literal = literalChar + '+';
    const literalOptional = literalChar + '*';

    const midParam = '(?:\\{\\w+(?:\\*[1-9]\\d*)?\\})';                               // {p}, {p*2}
    const endParam = '(?:\\/(?:\\{\\w+(?:(?:\\*(?:[1-9]\\d*)?)|(?:\\?))?\\})?)?';     // {p}, {p*2}, {p*}, {p?}

    const partialParam = '(?:\\{\\w+\\??\\})';                                        // {p}, {p?}
    const mixedParam = '(?:(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + '(?:' + literal + partialParam + ')+' + literalOptional + ')|(?:' + partialParam + literal + ')';

    const segmentContent = '(?:' + literal + '|' + midParam + '|' + mixedParam + ')';
    const segment = '\\/' + segmentContent;
    const segments = '(?:' + segment + ')*';

    const path = '(?:^' + segments + endParam + '$)';

    //                1:literal               2:name   3:*  4:count  5:?
    const parseParam = '(' + literal + ')|(?:\\{(\\w+)(?:(\\*)(\\d+)?)?(\\?)?\\})';

    const expressions = {
        parseParam: new RegExp(parseParam, 'g'),
        validatePath: new RegExp(empty + '|' + path),
        validatePathEncoded: /%(?:2[146-9A-E]|3[\dABD]|4[\dA-F]|5[\dAF]|6[1-9A-F]|7[\dAE])/g
    };

    return expressions;
};


/***/ }),

/***/ "./node_modules/@hapi/call/lib/segment.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/call/lib/segment.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports = module.exports = internals.Segment = function () {

    this._edge = null;              // { segment, record }
    this._fulls = null;             // { path: { segment, record }
    this._literals = null;          // { literal: { segment, <node> } }
    this._param = null;             // <node>
    this._mixed = null;             // [{ segment, <node> }]
    this._wildcard = null;          // { segment, record }
};


internals.Segment.prototype.add = function (segments, record) {

    /*
        { literal: 'x' }        -> x
        { empty: false }        -> {p}
        { wildcard: true }      -> {p*}
        { mixed: /regex/ }      -> a{p}b
    */

    const current = segments[0];
    const remaining = segments.slice(1);
    const isEdge = !remaining.length;

    const literals = [];
    let isLiteral = true;
    for (let i = 0; i < segments.length && isLiteral; ++i) {
        isLiteral = segments[i].literal !== undefined;
        literals.push(segments[i].literal);
    }

    if (isLiteral) {
        this._fulls = this._fulls || {};
        let literal = '/' + literals.join('/');
        if (!record.settings.isCaseSensitive) {
            literal = literal.toLowerCase();
        }

        Hoek.assert(!this._fulls[literal], 'New route', record.path, 'conflicts with existing', this._fulls[literal] && this._fulls[literal].record.path);
        this._fulls[literal] = { segment: current, record };
    }
    else if (current.literal !== undefined) {               // Can be empty string

        // Literal

        this._literals = this._literals || {};
        const currentLiteral = (record.settings.isCaseSensitive ? current.literal : current.literal.toLowerCase());
        this._literals[currentLiteral] = this._literals[currentLiteral] || new internals.Segment();
        this._literals[currentLiteral].add(remaining, record);
    }
    else if (current.wildcard) {

        // Wildcard

        Hoek.assert(!this._wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);
        Hoek.assert(!this._param || !this._param._wildcard, 'New route', record.path, 'conflicts with existing', this._param && this._param._wildcard && this._param._wildcard.record.path);
        this._wildcard = { segment: current, record };
    }
    else if (current.mixed) {

        // Mixed

        this._mixed = this._mixed || [];

        let mixed = this._mixedLookup(current);
        if (!mixed) {
            mixed = { segment: current, node: new internals.Segment() };
            this._mixed.push(mixed);
            this._mixed.sort(internals.mixed);
        }

        if (isEdge) {
            Hoek.assert(!mixed.node._edge, 'New route', record.path, 'conflicts with existing', mixed.node._edge && mixed.node._edge.record.path);
            mixed.node._edge = { segment: current, record };
        }
        else {
            mixed.node.add(remaining, record);
        }
    }
    else {

        // Parameter

        this._param = this._param || new internals.Segment();

        if (isEdge) {
            Hoek.assert(!this._param._edge, 'New route', record.path, 'conflicts with existing', this._param._edge && this._param._edge.record.path);
            this._param._edge = { segment: current, record };
        }
        else {
            Hoek.assert(!this._wildcard || !remaining[0].wildcard, 'New route', record.path, 'conflicts with existing', this._wildcard && this._wildcard.record.path);
            this._param.add(remaining, record);
        }
    }
};


internals.Segment.prototype._mixedLookup = function (segment) {

    for (let i = 0; i < this._mixed.length; ++i) {
        if (internals.mixed({ segment }, this._mixed[i]) === 0) {
            return this._mixed[i];
        }
    }

    return null;
};


internals.mixed = function (a, b) {

    const aFirst = -1;
    const bFirst = 1;

    const as = a.segment;
    const bs = b.segment;

    if (as.length !== bs.length) {
        return (as.length > bs.length ? aFirst : bFirst);
    }

    if (as.first !== bs.first) {
        return (as.first ? bFirst : aFirst);
    }

    for (let i = 0; i < as.segments.length; ++i) {
        const am = as.segments[i];
        const bm = bs.segments[i];

        if (am === bm) {
            continue;
        }

        if (am.length === bm.length) {
            return (am > bm ? bFirst : aFirst);
        }

        return (am.length < bm.length ? bFirst : aFirst);
    }

    return 0;
};


internals.Segment.prototype.lookup = function (path, segments, options) {

    let match = null;

    // Literal edge

    if (this._fulls) {
        match = this._fulls[options.isCaseSensitive ? path : path.toLowerCase()];
        if (match) {
            return { record: match.record, array: [] };
        }
    }

    // Literal node

    const current = segments[0];
    const nextPath = path.slice(current.length + 1);
    const remainder = (segments.length > 1 ? segments.slice(1) : null);

    if (this._literals) {
        const literal = options.isCaseSensitive ? current : current.toLowerCase();
        match = this._literals.hasOwnProperty(literal) && this._literals[literal];
        if (match) {
            const record = internals.deeper(match, nextPath, remainder, [], options);
            if (record) {
                return record;
            }
        }
    }

    // Mixed

    if (this._mixed) {
        for (let i = 0; i < this._mixed.length; ++i) {
            match = this._mixed[i];
            const params = current.match(match.segment.mixed);
            if (params) {
                const array = [];
                for (let j = 1; j < params.length; ++j) {
                    array.push(params[j]);
                }

                const record = internals.deeper(match.node, nextPath, remainder, array, options);
                if (record) {
                    return record;
                }
            }
        }
    }

    // Param

    if (this._param) {
        if (current ||
            (this._param._edge && this._param._edge.segment.empty)) {

            const record = internals.deeper(this._param, nextPath, remainder, [current], options);
            if (record) {
                return record;
            }
        }
    }

    // Wildcard

    if (this._wildcard) {
        return { record: this._wildcard.record, array: [path.slice(1)] };
    }

    return null;
};


internals.deeper = function (match, path, segments, array, options) {

    if (!segments) {
        if (match._edge) {
            return { record: match._edge.record, array };
        }

        if (match._wildcard) {
            return { record: match._wildcard.record, array };
        }
    }
    else {
        const result = match.lookup(path, segments, options);
        if (result) {
            return { record: result.record, array: array.concat(result.array) };
        }
    }

    return null;
};


/***/ }),

/***/ "./node_modules/@hapi/catbox-memory/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@hapi/catbox-memory/lib/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    maxTimer: 2147483647,   // 2 ^ 31 - 1
    entrySize: 144          // Approximate cache entry size without value: 144 bytes
};


internals.defaults = {
    maxByteSize: 100 * 1024 * 1024,          // 100MB
    minCleanupIntervalMsec: 1000,
    cloneBuffersOnGet: false
};


exports = module.exports = internals.Connection = class {

    constructor(options = {}) {

        Hoek.assert(this.constructor === internals.Connection, 'Memory cache client must be instantiated using new');
        Hoek.assert(options.maxByteSize === undefined || options.maxByteSize >= 0, 'Invalid cache maxByteSize value');
        Hoek.assert(options.allowMixedContent === undefined, 'allowMixedContent no longer supported');
        Hoek.assert(options.minCleanupIntervalMsec === undefined || options.minCleanupIntervalMsec < internals.maxTimer, 'Invalid cache minCleanupIntervalMsec value');
        Hoek.assert(options.cloneBuffersOnGet === undefined || typeof options.cloneBuffersOnGet === 'boolean', 'Invalid cloneBuffersOnGet value');

        this.settings = Hoek.applyToDefaults(internals.defaults, options);
        this.cache = null;

        this._timer = null;
        this._timerDue = null;
    }

    start() {

        if (!this.cache) {
            this.cache = new Map();
            this.byteSize = 0;
        }
    }

    _scheduleCleanup(msec) {

        const cleanup = () => {

            this._timer = null;
            this._timerDue = null;

            const now = Date.now();
            let next = Infinity;
            for (const [, segment] of this.cache) {
                for (const [id, envelope] of segment) {
                    const ttl = envelope.stored + envelope.ttl - now;
                    if (ttl <= 0) {
                        segment.delete(id);
                        this.byteSize -= envelope.byteSize;
                    }
                    else {
                        next = Math.min(next, ttl);
                    }
                }
            }

            if (next !== Infinity) {
                this._scheduleCleanup(next);
            }
        };

        const now = Date.now();
        const timeout = Math.min(Math.max(this.settings.minCleanupIntervalMsec, msec), internals.maxTimer);
        if (this._timer) {
            if (this._timerDue - now < msec) {
                return;
            }

            clearTimeout(this._timer);
        }

        this._timerDue = now + timeout;
        this._timer = setTimeout(cleanup, timeout);
    }

    stop() {

        clearTimeout(this._timer);
        this._timer = null;
        this._timerDue = null;

        this.cache = null;
        this.byteSize = 0;
    }

    isReady() {

        return !!this.cache;
    }

    validateSegmentName(name) {

        if (!name) {
            throw new Boom('Empty string');
        }

        if (name.indexOf('\u0000') !== -1) {
            throw new Boom('Includes null character');
        }

        return null;
    }

    get(key) {

        if (!this.cache) {
            throw new Boom('Connection not started');
        }

        const segment = this.cache.get(key.segment);
        if (!segment) {
            return null;
        }

        const envelope = segment.get(key.id);
        if (!envelope) {
            return null;
        }

        if (envelope.stored + envelope.ttl < Date.now()) {
            this.drop(key);
            return null;
        }

        let item = null;
        if (Buffer.isBuffer(envelope.item)) {
            item = envelope.item;
            if (this.settings.cloneBuffersOnGet) {
                const copy = Buffer.alloc(item.length);
                item.copy(copy);
                item = copy;
            }
        }
        else {
            try {
                item = JSON.parse(envelope.item);
            }
            catch (err) {
                throw new Boom('Bad value content');
            }
        }

        const result = {
            item,
            stored: envelope.stored,
            ttl: envelope.ttl
        };

        return result;
    }

    set(key, value, ttl) {

        if (!this.cache) {
            throw new Boom('Connection not started');
        }

        const envelope = new internals.MemoryCacheEntry(key, value, ttl);

        let segment = this.cache.get(key.segment);
        if (!segment) {
            segment = new Map();
            this.cache.set(key.segment, segment);
        }

        const cachedItem = segment.get(key.id);
        if (cachedItem) {
            this.byteSize -= cachedItem.byteSize;       // If the item existed, decrement the byteSize as the value could be different
        }

        if (this.settings.maxByteSize &&
            (this.byteSize + envelope.byteSize > this.settings.maxByteSize)) {

            throw new Boom('Cache size limit reached');
        }

        this._scheduleCleanup(ttl);
        segment.set(key.id, envelope);
        this.byteSize += envelope.byteSize;
    }

    drop(key) {

        if (!this.cache) {
            throw new Boom('Connection not started');
        }

        const segment = this.cache.get(key.segment);
        if (segment) {
            const item = segment.get(key.id);
            if (item) {
                this.byteSize -= item.byteSize;
                segment.delete(key.id);
            }
        }
    }
};


internals.MemoryCacheEntry = class {

    constructor(key, value, ttl) {

        let valueByteSize = 0;

        if (Buffer.isBuffer(value)) {
            this.item = Buffer.alloc(value.length);
            value.copy(this.item);                                  // Copy buffer to prevent value from changing while in the cache
            valueByteSize = this.item.length;
        }
        else {
            this.item = JSON.stringify(value);                      // stringify() to prevent value from changing while in the cache
            valueByteSize = Buffer.byteLength(this.item);
        }

        this.stored = Date.now();
        this.ttl = ttl;
        this.byteSize = internals.entrySize + valueByteSize + Buffer.byteLength(key.segment) + Buffer.byteLength(key.id);
        this.timeoutId = null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/client.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/client.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {
    validate: Symbol('validate')
};


internals.defaults = {
    partition: 'catbox'
};


module.exports = class {

    constructor(engine, options) {

        Hoek.assert(engine, 'Missing catbox client engine');
        Hoek.assert(typeof engine === 'object' || typeof engine === 'function', 'engine must be an engine object or engine prototype (function)');
        Hoek.assert(typeof engine === 'function' || !options, 'Can only specify options with function engine config');

        const settings = Object.assign({}, internals.defaults, options);
        Hoek.assert(settings.partition.match(/^[\w\-]+$/), 'Invalid partition name:' + settings.partition);

        this.connection = (typeof engine === 'object' ? engine : new engine(settings));
    }

    async start() {

        await this.connection.start();
    }

    async stop() {

        await this.connection.stop();
    }

    isReady() {

        return this.connection.isReady();
    }

    validateSegmentName(name) {

        return this.connection.validateSegmentName(name);
    }

    async get(key) {

        this[internals.validate](key, null);

        if (key === null) {
            return null;
        }

        const result = await this.connection.get(key);
        if (!result ||
            result.item === undefined ||
            result.item === null) {

            return null;                                                        // Not found
        }

        const now = Date.now();
        const expires = result.stored + result.ttl;
        const ttl = expires - now;
        if (ttl <= 0) {
            return null;                                                        // Expired
        }

        const cached = {
            item: result.item,
            stored: result.stored,
            ttl
        };

        return cached;                                                          // Valid
    }

    async set(key, value, ttl) {

        this[internals.validate](key);

        if (ttl <= 0) {
            return;                                                             // Not cachable (or bad rules)
        }

        await this.connection.set(key, value, ttl);
    }

    async drop(key) {

        this[internals.validate](key);

        await this.connection.drop(key);                                       // Always drop, regardless of caching rules
    }

    [internals.validate](key, allow = {}) {

        if (!this.isReady()) {
            throw Boom.internal('Disconnected');                                // Disconnected
        }

        const isValidKey = (key && typeof key.id === 'string' &&
                            key.segment && typeof key.segment === 'string');

        if (!isValidKey && key !== allow) {
            throw Boom.internal('Invalid key');
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Client = __webpack_require__(/*! ./client */ "./node_modules/@hapi/catbox/lib/client.js");
const Policy = __webpack_require__(/*! ./policy */ "./node_modules/@hapi/catbox/lib/policy.js");


const internals = {};


exports.Client = Client;


exports.Policy = exports.policy = Policy;


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/pending.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/pending.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = class {

    constructor(id, rule) {

        this.id = id;
        this.timeoutTimer = null;
        this.count = 1;
        this.rule = rule;

        this.promise = new Promise((resolve, reject) => {

            this.resolve = resolve;
            this.reject = reject;
        });
    }

    join() {

        ++this.count;
        return this.promise;
    }

    send(err, value, cached, report) {

        clearTimeout(this.timeoutTimer);

        if (err &&
            !cached) {

            this.reject(err);
            return;
        }

        if (!this.rule.getDecoratedValue) {
            this.resolve(value);
            return;
        }

        if (err) {
            report.error = err;
        }

        this.resolve({ value, cached, report });
    }

    setTimeout(fn, timeoutMs) {

        clearTimeout(this.timeoutTimer);
        this.timeoutTimer = setTimeout(fn, timeoutMs);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/catbox/lib/policy.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/catbox/lib/policy.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");

const Pending = __webpack_require__(/*! ./pending */ "./node_modules/@hapi/catbox/lib/pending.js");


const internals = {
    day: 24 * 60 * 60 * 1000,
    events: Podium.validate([
        { name: 'error', channels: ['generate', 'persist'] }
    ])
};


internals.schema = Joi.object({
    expiresIn: Joi.number().integer().min(1),
    expiresAt: Joi.string().regex(/^\d\d?\:\d\d$/),
    staleIn: [
        Joi.number().integer().min(1).when('expiresAt', { is: Joi.required(), then: Joi.number().max(86400000 - 1) }),       // One day - 1 (max is inclusive)
        Joi.func()
    ],
    staleTimeout: Joi.number().integer().min(1),
    generateFunc: Joi.func(),
    generateTimeout: Joi.number().integer().min(1).allow(false),
    generateOnReadError: Joi.boolean(),
    generateIgnoreWriteError: Joi.boolean(),
    dropOnError: Joi.boolean(),
    pendingGenerateTimeout: Joi.number().integer().min(1),
    getDecoratedValue: Joi.boolean().default(false),

    // Ignored external keys (hapi)

    privacy: Joi.any(),
    cache: Joi.any(),
    segment: Joi.any(),
    shared: Joi.any()
})
    .without('expiresIn', 'expiresAt')
    .with('staleIn', 'generateFunc')
    .with('generateOnReadError', 'generateFunc')
    .with('generateIgnoreWriteError', 'generateFunc')
    .with('dropOnError', 'generateFunc')
    .and('generateFunc', 'generateTimeout')
    .and('staleIn', 'staleTimeout');


exports = module.exports = internals.Policy = class {

    constructor(options, cache, segment) {

        this._events = null;
        this._cache = cache;
        this._pendings = new Map();                       // id -> Pending
        this._pendingGenerateCall = new Map();            // id -> timer
        this.rules(options);

        this.stats = {
            sets: 0,
            gets: 0,
            hits: 0,
            stales: 0,
            generates: 0,
            errors: 0
        };

        if (cache) {
            const nameErr = cache.validateSegmentName(segment);
            Hoek.assert(nameErr === null, 'Invalid segment name: ' + segment + (nameErr ? ' (' + nameErr.message + ')' : ''));

            this._segment = segment;
        }
    }

    get events() {

        if (!this._events) {
            this._events = new Podium(internals.events);
        }

        return this._events;
    }

    _error(source, error) {

        if (!this._events) {
            return;
        }

        this._events.emit({ name: 'error', channel: source }, { source, error });
    }

    rules(options) {

        this.rule = internals.Policy.compile(options, !!this._cache);
    }

    async get(key) {     // key: string or { id: 'id' }

        ++this.stats.gets;

        // Check if request is already pending

        const id = (key && typeof key === 'object') ? key.id : key;
        let pending = this._pendings.get(id);
        if (pending !== undefined) {
            return await pending.join();
        }

        pending = new Pending(id, this.rule);
        this._pendings.set(id, pending);

        try {
            await this._get(pending, key);
        }
        catch (err) {
            this._send(pending, err);               // Safeguard to ensure that the pending rejects on any processing errors
        }

        return pending.promise;
    }

    async _get(pending, key) {

        // Prepare report

        const report = {};

        // Lookup in cache

        const timer = new Hoek.Bench();

        let cached = null;
        if (this._cache) {
            try {
                cached = await this._cache.get({ segment: this._segment, id: pending.id });
            }
            catch (err) {
                report.error = err;
                ++this.stats.errors;
                this._error('persist', err);
            }
        }

        report.msec = timer.elapsed();

        if (cached) {
            report.stored = cached.stored;
            report.ttl = cached.ttl;
            const staleIn = typeof this.rule.staleIn === 'function' ? this.rule.staleIn(cached.stored, cached.ttl) : this.rule.staleIn;
            cached.isStale = (staleIn ? (Date.now() - cached.stored) >= staleIn : false);
            report.isStale = cached.isStale;

            if (cached.isStale) {
                ++this.stats.stales;
            }
        }

        // No generate method

        if (!this.rule.generateFunc ||
            (report.error && !this.rule.generateOnReadError)) {

            this._send(pending, report.error, cached ? cached.item : null, cached, report);
            return;
        }

        // Check if found and fresh

        if (cached &&
            !cached.isStale) {

            this._send(pending, null, cached.item, cached, report);
            return;
        }

        // Wait until generated or otherwise resolved

        await Promise.race([
            pending.promise,
            this._generate(pending, key, cached, report)
        ]);
    }

    _generate(pending, key, cached, report) {

        if (cached) {                                       // Must be stale

            // Set stale timeout

            cached.ttl = cached.ttl - this.rule.staleTimeout;       // Adjust TTL for when the timeout is invoked (staleTimeout must be valid if isStale is true)
        }

        if (cached &&
            cached.ttl > 0) {

            pending.setTimeout(() => this._send(pending, null, cached.item, cached, report), this.rule.staleTimeout);
        }
        else if (this.rule.generateTimeout) {

            // Set item generation timeout (when not in cache)

            pending.setTimeout(() => this._send(pending, Boom.serverUnavailable(), null, null, report), this.rule.generateTimeout);
        }

        // Check if a generate call is already in progress

        if (this._pendingGenerateCall.has(pending.id)) {
            return;
        }

        // Generate new value

        ++this.stats.generates;                                 // Record generation before call in case it times out

        if (this.rule.pendingGenerateTimeout) {
            const timeout = setTimeout(() => this._pendingGenerateCall.delete(pending.id), this.rule.pendingGenerateTimeout);
            this._pendingGenerateCall.set(pending.id, timeout);
        }

        return this._callGenerateFunc(pending, key, cached, report);
    }

    async _callGenerateFunc(pending, key, cached, report) {

        const flags = {};

        try {
            var value = await this.rule.generateFunc(key, flags);
        }
        catch (err) {
            var generateError = err;
            this._error('generate', err);
        }

        const pendingTimeout = this._pendingGenerateCall.get(pending.id);
        if (pendingTimeout) {
            clearTimeout(pendingTimeout);
            this._pendingGenerateCall.delete(pending.id);

            pending = this._pendings.get(pending.id) || pending;                    // Fetch latest - it might have changed
        }

        // Error (if dropOnError is not set to false) or not cached

        try {
            if (flags.ttl === 0 ||                                                  // null or undefined means use policy
                (generateError && this.rule.dropOnError)) {

                await this.drop(pending.id);                                        // Invalidate cache
            }
            else if (!generateError) {
                await this.set(pending.id, value, flags.ttl);                       // Replace stale cache copy with late-coming fresh copy
            }
        }
        catch (err) {
            var persistError = err;
            this._error('persist', err);
        }

        const error = generateError || (this.rule.generateIgnoreWriteError ? null : persistError);
        if (cached &&
            error &&
            !this.rule.dropOnError) {

            this._send(pending, error, cached.item, cached, report);
            return;
        }

        this._send(pending, error, value, null, report);                            // Ignored if stale value already returned
    }

    _send(pending, err, value, cached, report) {

        pending.send(err, value, cached, report);
        this._pendings.delete(pending.id);

        if (report && report.isStale !== undefined) {
            this.stats.hits = this.stats.hits + pending.count;
        }
    }

    async set(key, value, ttl) {

        ++this.stats.sets;

        if (!this._cache) {
            return;
        }

        ttl = ttl || internals.Policy.ttl(this.rule);
        const id = (key && typeof key === 'object') ? key.id : key;

        try {
            await this._cache.set({ segment: this._segment, id }, value, ttl);
        }
        catch (err) {
            ++this.stats.errors;
            throw err;
        }
    }

    async drop(key) {

        if (!this._cache) {
            return;
        }

        const id = (key && typeof key === 'object') ? key.id : key;

        try {
            await this._cache.drop({ segment: this._segment, id });
            return;
        }
        catch (err) {
            ++this.stats.errors;
            throw err;
        }
    }

    ttl(created) {

        return internals.Policy.ttl(this.rule, created);
    }

    isReady() {

        if (!this._cache) {
            return false;
        }

        return this._cache.connection.isReady();
    }

    static compile(options, serverSide) {

        /*
            {
                expiresIn: 30000,
                expiresAt: '13:00',
                generateFunc: (id, flags) => { throw err; } / { return result; } / { flags.ttl = ttl; return result; }
                generateTimeout: 500,
                generateOnReadError: true,
                generateIgnoreWriteError: true,
                staleIn: 20000,
                staleTimeout: 500,
                dropOnError: true,
                getDecoratedValue: false
            }
         */

        const rule = {};

        if (!options ||
            !Object.keys(options).length) {

            return rule;
        }

        // Validate rule

        options = Joi.attempt(options, internals.schema, 'Invalid cache policy configuration');

        const hasExpiresIn = options.expiresIn !== undefined && options.expiresIn !== null;
        const hasExpiresAt = options.expiresAt !== undefined && options.expiresAt !== null;

        Hoek.assert(!hasExpiresIn || !options.staleIn || typeof options.staleIn === 'function' || options.staleIn < options.expiresIn, 'staleIn must be less than expiresIn');
        Hoek.assert(!options.staleIn || serverSide, 'Cannot use stale options without server-side caching');
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || options.staleTimeout < options.expiresIn, 'staleTimeout must be less than expiresIn');
        Hoek.assert(!options.staleTimeout || !hasExpiresIn || typeof options.staleIn === 'function' || options.staleTimeout < (options.expiresIn - options.staleIn), 'staleTimeout must be less than the delta between expiresIn and staleIn');
        Hoek.assert(!options.staleTimeout || !options.pendingGenerateTimeout || options.staleTimeout < options.pendingGenerateTimeout, 'pendingGenerateTimeout must be greater than staleTimeout if specified');

        // Expiration

        if (hasExpiresAt) {

            // expiresAt

            const time = /^(\d\d?):(\d\d)$/.exec(options.expiresAt);
            rule.expiresAt = {
                hours: parseInt(time[1], 10),
                minutes: parseInt(time[2], 10)
            };
        }
        else {

            // expiresIn

            rule.expiresIn = options.expiresIn || 0;
        }

        // generateTimeout

        if (options.generateFunc) {
            rule.generateFunc = options.generateFunc;
            rule.generateTimeout = options.generateTimeout;

            // Stale

            if (options.staleIn) {
                rule.staleIn = options.staleIn;
                rule.staleTimeout = options.staleTimeout;
            }

            rule.dropOnError = options.dropOnError !== undefined ? options.dropOnError : true;                                          // Defaults to true
            rule.pendingGenerateTimeout = options.pendingGenerateTimeout !== undefined ? options.pendingGenerateTimeout : 0;            // Defaults to zero
        }

        rule.generateOnReadError = options.generateOnReadError !== undefined ? options.generateOnReadError : true;                      // Defaults to true
        rule.generateIgnoreWriteError = options.generateIgnoreWriteError !== undefined ? options.generateIgnoreWriteError : true;       // Defaults to true

        // Decorations

        rule.getDecoratedValue = options.getDecoratedValue;

        return rule;
    }

    static ttl(rule, created, now) {

        now = now || Date.now();
        created = created || now;
        const age = now - created;

        if (age < 0) {
            return 0;                                                                   // Created in the future, assume expired/bad
        }

        if (rule.expiresIn) {
            return Math.max(rule.expiresIn - age, 0);
        }

        if (rule.expiresAt) {
            if (age > internals.day) {                                                  // If the item was created more than a 24 hours ago
                return 0;
            }

            const expiresAt = new Date(created);                                        // Compare expiration time on the same day
            expiresAt.setHours(rule.expiresAt.hours);
            expiresAt.setMinutes(rule.expiresAt.minutes);
            expiresAt.setSeconds(0);
            expiresAt.setMilliseconds(0);
            let expires = expiresAt.getTime();

            if (expires <= created) {
                expires = expires + internals.day;                                     // Move to tomorrow
            }

            if (now >= expires) {                                                      // Expired
                return 0;
            }

            return expires - now;
        }

        return 0;                                                                       // No rule
    }
};


/***/ }),

/***/ "./node_modules/@hapi/content/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/content/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


/*
    RFC 7231 Section 3.1.1.1

    media-type = type "/" subtype *( OWS ";" OWS parameter )
    type       = token
    subtype    = token
    parameter  = token "=" ( token / quoted-string )
*/

//                             1: type/subtype    2: params
internals.contentTypeRegex = /^([^\/\s]+\/[^\s;]+)(.*)?$/;

//                                        1: "b"   2: b
internals.paramsRegex = /;\s*boundary=(?:"([^"]+)"|([^;"\s]+))/i;


exports.type = function (header) {

    if (!header) {
        throw Boom.badRequest('Invalid content-type header');
    }

    const match = header.match(internals.contentTypeRegex);
    if (!match) {
        throw Boom.badRequest('Invalid content-type header');
    }

    const result = {
        mime: match[1].toLowerCase()
    };

    if (result.mime.indexOf('multipart/') === 0) {
        const params = match[2];
        if (params) {
            const param = params.match(internals.paramsRegex);
            if (param) {
                result.boundary = param[1] || param[2];
            }
        }

        if (!result.boundary) {
            throw Boom.badRequest('Invalid content-type header: multipart missing boundary');
        }
    }

    return result;
};


/*
    RFC 6266 Section 4.1 (http://tools.ietf.org/html/rfc6266#section-4.1)

    content-disposition = "Content-Disposition" ":" disposition-type *( ";" disposition-parm )
    disposition-type    = "inline" | "attachment" | token                                           ; case-insensitive
    disposition-parm    = filename-parm | token [ "*" ] "=" ( token | quoted-string | ext-value)    ; ext-value defined in [RFC5987], Section 3.2

    Content-Disposition header field values with multiple instances of the same parameter name are invalid.

    Note that due to the rules for implied linear whitespace (Section 2.1 of [RFC2616]), OPTIONAL whitespace
    can appear between words (token or quoted-string) and separator characters.

    Furthermore, note that the format used for ext-value allows specifying a natural language (e.g., "en"); this is of limited use
    for filenames and is likely to be ignored by recipients.
*/


internals.contentDispositionRegex = /^\s*form-data\s*(?:;\s*(.+))?$/i;

//                                        1: name     2: *            3: ext-value                      4: quoted  5: token
internals.contentDispositionParamRegex = /([^\=\*\s]+)(\*)?\s*\=\s*(?:([^;'"\s]+\'[\w-]*\'[^;\s]+)|(?:\"([^"]*)\")|([^;\s]*))(?:\s*(?:;\s*)|$)/g;

exports.disposition = function (header) {

    if (!header) {
        throw Boom.badRequest('Missing content-disposition header');
    }

    const match = header.match(internals.contentDispositionRegex);
    if (!match) {
        throw Boom.badRequest('Invalid content-disposition header format');
    }

    const parameters = match[1];
    if (!parameters) {
        throw Boom.badRequest('Invalid content-disposition header missing parameters');
    }

    const result = {};
    parameters.replace(internals.contentDispositionParamRegex, ($0, $1, $2, $3, $4, $5) => {

        if ($2) {
            if (!$3) {
                throw Boom.badRequest('Invalid content-disposition header format includes invalid parameters');
            }

            try {
                result[$1] = decodeURIComponent($3.split('\'')[2]);
            }
            catch (err) {
                throw Boom.badRequest('Invalid content-disposition header format includes invalid parameters');
            }
        }
        else {
            result[$1] = $4 || $5 || '';
        }
    });

    if (!result.name) {
        throw Boom.badRequest('Invalid content-disposition header missing name parameter');
    }

    return result;
};


/***/ }),

/***/ "./node_modules/@hapi/cryptiles/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/cryptiles/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


// Generate a cryptographically strong pseudo-random data

exports.randomString = function (size) {

    const buffer = exports.randomBits((size + 1) * 6);
    const string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
    return string.slice(0, size);
};


// Return a random string of digits

exports.randomDigits = function (size) {

    const digits = [];

    let buffer = internals.random(size * 2);            // Provision twice the amount of bytes needed to increase chance of single pass
    let pos = 0;

    while (digits.length < size) {
        if (pos >= buffer.length) {
            buffer = internals.random(size * 2);
            pos = 0;
        }

        if (buffer[pos] < 250) {
            digits.push(buffer[pos] % 10);
        }

        ++pos;
    }

    return digits.join('');
};


// Generate a buffer of random bits

exports.randomBits = function (bits) {

    if (!bits ||
        bits < 0) {

        throw Boom.internal('Invalid random bits count');
    }

    const bytes = Math.ceil(bits / 8);
    return internals.random(bytes);
};


exports.fixedTimeComparison = function (a, b) {

    try {
        return Crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b));
    }
    catch (err) {
        return false;
    }
};


internals.random = function (bytes) {

    try {
        return Crypto.randomBytes(bytes);
    }
    catch (err) {
        throw Boom.internal('Failed generating random bits: ' + err.message);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/file/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/file/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");
const Path = __webpack_require__(/*! path */ "path");


const internals = {};


exports.uniqueFilename = function (path, extension) {

    if (extension) {
        extension = extension[0] !== '.' ? '.' + extension : extension;
    }
    else {
        extension = '';
    }

    path = Path.resolve(path);
    const name = [Date.now(), process.pid, Crypto.randomBytes(8).toString('hex')].join('-') + extension;
    return Path.join(path, name);
};


/***/ }),

/***/ "./node_modules/@hapi/formula/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/formula/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {
    operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],
    operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],
    operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],
    operatorsPrefix: ['!', 'n'],

    literals: {
        '"': '"',
        '`': '`',
        '\'': '\'',
        '[': ']'
    },

    numberRx: /^(?:[0-9]*\.?[0-9]*){1}$/,
    tokenRx: /^[\w\$\#\.\@\:\{\}]+$/,

    symbol: Symbol('formula'),
    settings: Symbol('settings')
};


exports = module.exports = internals.Formula = class {

    constructor(string, options = {}) {

        if (!options[internals.settings] &&
            options.constants) {

            for (const constant in options.constants) {
                const value = options.constants[constant];
                if (value !== null &&
                    !['boolean', 'number', 'string'].includes(typeof value)) {

                    throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);
                }
            }
        }

        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);
        this.single = null;

        this._parts = null;
        this._parse(string);
    }

    _parse(string) {

        let parts = [];
        let current = '';
        let parenthesis = 0;
        let literal = false;

        const flush = (inner) => {

            if (parenthesis) {
                throw new Error('Formula missing closing parenthesis');
            }

            const last = parts.length ? parts[parts.length - 1] : null;

            if (!literal &&
                !current &&
                !inner) {

                return;
            }

            if (last &&
                last.type === 'reference' &&
                inner === ')') {                                                                // Function

                last.type = 'function';
                last.value = this._subFormula(current, last.value);
                current = '';
                return;
            }

            if (inner === ')') {                                                                // Segment
                const sub = new internals.Formula(current, this.settings);
                parts.push({ type: 'segment', value: sub });
            }
            else if (literal) {
                if (literal === ']') {                                                          // Reference
                    parts.push({ type: 'reference', value: current });
                    current = '';
                    return;
                }

                parts.push({ type: 'literal', value: current });                                // Literal
            }
            else if (internals.operatorCharacters.includes(current)) {                          // Operator
                if (last &&
                    last.type === 'operator' &&
                    internals.operators.includes(last.value + current)) {                       // 2 characters operator

                    last.value += current;
                }
                else {
                    parts.push({ type: 'operator', value: current });
                }
            }
            else if (current.match(internals.numberRx)) {                                       // Number
                parts.push({ type: 'constant', value: parseFloat(current) });
            }
            else if (this.settings.constants[current] !== undefined) {                          // Constant
                parts.push({ type: 'constant', value: this.settings.constants[current] });
            }
            else {                                                                              // Reference
                if (!current.match(internals.tokenRx)) {
                    throw new Error(`Formula contains invalid token: ${current}`);
                }

                parts.push({ type: 'reference', value: current });
            }

            current = '';
        };

        for (const c of string) {
            if (literal) {
                if (c === literal) {
                    flush();
                    literal = false;
                }
                else {
                    current += c;
                }
            }
            else if (parenthesis) {
                if (c === '(') {
                    current += c;
                    ++parenthesis;
                }
                else if (c === ')') {
                    --parenthesis;
                    if (!parenthesis) {
                        flush(c);
                    }
                    else {
                        current += c;
                    }
                }
                else {
                    current += c;
                }
            }
            else if (c in internals.literals) {
                literal = internals.literals[c];
            }
            else if (c === '(') {
                flush();
                ++parenthesis;
            }
            else if (internals.operatorCharacters.includes(c)) {
                flush();
                current = c;
                flush();
            }
            else if (c !== ' ') {
                current += c;
            }
            else {
                flush();
            }
        }

        flush();

        // Replace prefix - to internal negative operator

        parts = parts.map((part, i) => {

            if (part.type !== 'operator' ||
                part.value !== '-' ||
                i && parts[i - 1].type !== 'operator') {

                return part;
            }

            return { type: 'operator', value: 'n' };
        });

        // Validate tokens order

        let operator = false;
        for (const part of parts) {
            if (part.type === 'operator') {
                if (internals.operatorsPrefix.includes(part.value)) {
                    continue;
                }

                if (!operator) {
                    throw new Error('Formula contains an operator in invalid position');
                }

                if (!internals.operators.includes(part.value)) {
                    throw new Error(`Formula contains an unknown operator ${part.value}`);
                }
            }
            else if (operator) {
                throw new Error('Formula missing expected operator');
            }

            operator = !operator;
        }

        if (!operator) {
            throw new Error('Formula contains invalid trailing operator');
        }

        // Identify single part

        if (parts.length === 1 &&
            ['reference', 'literal', 'constant'].includes(parts[0].type)) {

            this.single = { type: parts[0].type === 'reference' ? 'reference' : 'value', value: parts[0].value };
        }

        // Process parts

        this._parts = parts.map((part) => {

            // Operators

            if (part.type === 'operator') {
                return internals.operatorsPrefix.includes(part.value) ? part : part.value;
            }

            // Literals, constants, segments

            if (part.type !== 'reference') {
                return part.value;
            }

            // References

            if (this.settings.tokenRx &&
                !this.settings.tokenRx.test(part.value)) {

                throw new Error(`Formula contains invalid reference ${part.value}`);
            }

            if (this.settings.reference) {
                return this.settings.reference(part.value);
            }

            return internals.reference(part.value);
        });
    }

    _subFormula(string, name) {

        const method = this.settings.functions[name];
        if (typeof method !== 'function') {
            throw new Error(`Formula contains unknown function ${name}`);
        }

        let args = [];
        if (string) {
            let current = '';
            let parenthesis = 0;
            let literal = false;

            const flush = () => {

                if (!current) {
                    throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);
                }

                args.push(current);
                current = '';
            };

            for (let i = 0; i < string.length; ++i) {
                const c = string[i];
                if (literal) {
                    current += c;
                    if (c === literal) {
                        literal = false;
                    }
                }
                else if (c in internals.literals &&
                    !parenthesis) {

                    current += c;
                    literal = internals.literals[c];
                }
                else if (c === ',' &&
                    !parenthesis) {

                    flush();
                }
                else {
                    current += c;
                    if (c === '(') {
                        ++parenthesis;
                    }
                    else if (c === ')') {
                        --parenthesis;
                    }
                }
            }

            flush();
        }

        args = args.map((arg) => new internals.Formula(arg, this.settings));

        return function (context) {

            const innerValues = [];
            for (const arg of args) {
                innerValues.push(arg.evaluate(context));
            }

            return method.call(context, ...innerValues);
        };
    }

    evaluate(context) {

        const parts = this._parts.slice();

        // Prefix operators

        for (let i = parts.length - 2; i >= 0; --i) {
            const part = parts[i];
            if (part &&
                part.type === 'operator') {

                const current = parts[i + 1];
                parts.splice(i + 1, 1);
                const value = internals.evaluate(current, context);
                parts[i] = internals.single(part.value, value);
            }
        }

        // Left-right operators

        internals.operatorsOrder.forEach((set) => {

            for (let i = 1; i < parts.length - 1;) {
                if (set.includes(parts[i])) {
                    const operator = parts[i];
                    const left = internals.evaluate(parts[i - 1], context);
                    const right = internals.evaluate(parts[i + 1], context);

                    parts.splice(i, 2);
                    const result = internals.calculate(operator, left, right);
                    parts[i - 1] = result === 0 ? 0 : result;                               // Convert -0
                }
                else {
                    i += 2;
                }
            }
        });

        return internals.evaluate(parts[0], context);
    }
};


internals.Formula.prototype[internals.symbol] = true;


internals.reference = function (name) {

    return function (context) {

        return context && context[name] !== undefined ? context[name] : null;
    };
};


internals.evaluate = function (part, context) {

    if (part === null) {
        return null;
    }

    if (typeof part === 'function') {
        return part(context);
    }

    if (part[internals.symbol]) {
        return part.evaluate(context);
    }

    return part;
};


internals.single = function (operator, value) {

    if (operator === '!') {
        return value ? false : true;
    }

    // operator === 'n'

    const negative = -value;
    if (negative === 0) {       // Override -0
        return 0;
    }

    return negative;
};


internals.calculate = function (operator, left, right) {

    if (operator === '??') {
        return internals.exists(left) ? left : right;
    }

    if (typeof left === 'string' ||
        typeof right === 'string') {

        if (operator === '+') {
            left = internals.exists(left) ? left : '';
            right = internals.exists(right) ? right : '';
            return left + right;
        }
    }
    else {
        switch (operator) {
            case '^': return Math.pow(left, right);
            case '*': return left * right;
            case '/': return left / right;
            case '%': return left % right;
            case '+': return left + right;
            case '-': return left - right;
        }
    }

    switch (operator) {
        case '<': return left < right;
        case '<=': return left <= right;
        case '>': return left > right;
        case '>=': return left >= right;
        case '==': return left === right;
        case '!=': return left !== right;
        case '&&': return left && right;
        case '||': return left || right;
    }

    return null;
};


internals.exists = function (value) {

    return value !== null && value !== undefined;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/auth.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/auth.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");


const internals = {
    missing: Symbol('missing')
};


exports = module.exports = internals.Auth = class {

    constructor(core) {

        this._core = core;
        this._schemes = {};
        this._strategies = {};
        this.settings = {
            default: null           // Strategy used as default if route has no auth settings
        };

        this.api = {};
    }

    scheme(name, scheme) {

        Hoek.assert(name, 'Authentication scheme must have a name');
        Hoek.assert(!this._schemes[name], 'Authentication scheme name already exists:', name);
        Hoek.assert(typeof scheme === 'function', 'scheme must be a function:', name);

        this._schemes[name] = scheme;
    }

    _strategy(server, name, scheme, options = {}) {

        Hoek.assert(name, 'Authentication strategy must have a name');
        Hoek.assert(typeof options === 'object', 'options must be an object');
        Hoek.assert(!this._strategies[name], 'Authentication strategy name already exists');
        Hoek.assert(scheme, 'Authentication strategy', name, 'missing scheme');
        Hoek.assert(this._schemes[scheme], 'Authentication strategy', name, 'uses unknown scheme:', scheme);

        server = server._clone();
        const strategy = this._schemes[scheme](server, options);

        Hoek.assert(strategy.authenticate, 'Invalid scheme:', name, 'missing authenticate() method');
        Hoek.assert(typeof strategy.authenticate === 'function', 'Invalid scheme:', name, 'invalid authenticate() method');
        Hoek.assert(!strategy.payload || typeof strategy.payload === 'function', 'Invalid scheme:', name, 'invalid payload() method');
        Hoek.assert(!strategy.response || typeof strategy.response === 'function', 'Invalid scheme:', name, 'invalid response() method');
        strategy.options = strategy.options || {};
        Hoek.assert(strategy.payload || !strategy.options.payload, 'Cannot require payload validation without a payload method');

        this._strategies[name] = {
            methods: strategy,
            realm: server.realm
        };

        if (strategy.api) {
            this.api[name] = strategy.api;
        }
    }

    default(options) {

        Hoek.assert(!this.settings.default, 'Cannot set default strategy more than once');
        options = Config.apply('auth', options, 'default strategy');

        this.settings.default = this._setupRoute(Hoek.clone(options));      // Prevent changes to options

        const routes = this._core.router.table();
        for (const route of routes) {
            route.rebuild();
        }
    }

    async test(name, request) {

        Hoek.assert(name, 'Missing authentication strategy name');
        const strategy = this._strategies[name];
        Hoek.assert(strategy, 'Unknown authentication strategy:', name);

        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });

        if (!response.isAuth) {
            throw response;
        }

        if (response.error) {
            throw response.error;
        }

        return response.data;
    }

    async verify(request) {

        const auth = request.auth;

        if (auth.error) {
            throw auth.error;
        }

        if (!auth.isAuthenticated) {
            return;
        }

        const strategy = this._strategies[auth.strategy];
        Hoek.assert(strategy, 'Unknown authentication strategy:', auth.strategy);

        if (!strategy.methods.verify) {
            return;
        }

        const bind = strategy.methods;
        await strategy.methods.verify.call(bind, auth);
    }

    static testAccess(request, route) {

        const auth = request._core.auth;

        try {
            return auth._access(request, route);
        }
        catch (err) {
            Bounce.rethrow(err, 'system');
            return false;
        }
    }

    _setupRoute(options, path) {

        if (!options) {
            return options;         // Preserve the difference between undefined and false
        }

        if (typeof options === 'string') {
            options = { strategies: [options] };
        }
        else if (options.strategy) {
            options.strategies = [options.strategy];
            delete options.strategy;
        }

        if (path &&
            !options.strategies) {

            Hoek.assert(this.settings.default, 'Route missing authentication strategy and no default defined:', path);
            options = Hoek.applyToDefaults(this.settings.default, options);
        }

        path = path || 'default strategy';
        Hoek.assert(options.strategies && options.strategies.length, 'Missing authentication strategy:', path);

        options.mode = options.mode || 'required';

        if (options.entity !== undefined ||                                             // Backwards compatibility with <= 11.x.x
            options.scope !== undefined) {

            options.access = [{ entity: options.entity, scope: options.scope }];
            delete options.entity;
            delete options.scope;
        }

        if (options.access) {
            for (const access of options.access) {
                access.scope = internals.setupScope(access);
            }
        }

        if (options.payload === true) {
            options.payload = 'required';
        }

        let hasAuthenticatePayload = false;
        for (const name of options.strategies) {
            const strategy = this._strategies[name];
            Hoek.assert(strategy, 'Unknown authentication strategy', name, 'in', path);

            Hoek.assert(strategy.methods.payload || options.payload !== 'required', 'Payload validation can only be required when all strategies support it in', path);
            hasAuthenticatePayload = hasAuthenticatePayload || strategy.methods.payload;
            Hoek.assert(!strategy.methods.options.payload || options.payload === undefined || options.payload === 'required', 'Cannot set authentication payload to', options.payload, 'when a strategy requires payload validation in', path);
        }

        Hoek.assert(!options.payload || hasAuthenticatePayload, 'Payload authentication requires at least one strategy with payload support in', path);

        return options;
    }

    lookup(route) {

        if (route.settings.auth === false) {
            return false;
        }

        return route.settings.auth || this.settings.default;
    }

    _enabled(route, type) {

        const config = this.lookup(route);
        if (!config) {
            return false;
        }

        if (type === 'authenticate') {
            return true;
        }

        if (type === 'access') {
            return !!config.access;
        }

        for (const name of config.strategies) {
            const strategy = this._strategies[name];
            if (strategy.methods[type]) {
                return true;
            }
        }

        return false;
    }

    static authenticate(request) {

        const auth = request._core.auth;
        return auth._authenticate(request);
    }

    async _authenticate(request) {

        const config = this.lookup(request.route);

        const errors = [];
        request.auth.mode = config.mode;

        // Injection bypass

        if (request.auth.credentials) {
            internals.validate(null, { credentials: request.auth.credentials, artifacts: request.auth.artifacts }, request.auth.strategy, config, request, errors);
            return;
        }

        // Try each strategy

        for (const name of config.strategies) {
            const strategy = this._strategies[name];

            const bind = strategy.methods;
            const realm = strategy.realm;
            const response = await request._core.toolkit.execute(strategy.methods.authenticate, request, { bind, realm, auth: true });

            const message = (response.isAuth ? internals.validate(response.error, response.data, name, config, request, errors) : internals.validate(response, null, name, config, request, errors));
            if (!message) {
                return;
            }

            if (message !== internals.missing) {
                return message;
            }
        }

        // No more strategies

        const err = Boom.unauthorized('Missing authentication', errors);
        if (config.mode === 'required') {
            throw err;
        }

        request.auth.isAuthenticated = false;
        request.auth.credentials = null;
        request.auth.error = err;
        request._log(['auth', 'unauthenticated']);
    }

    static access(request) {

        const auth = request._core.auth;
        request.auth.isAuthorized = auth._access(request);
    }

    _access(request, route) {

        const config = this.lookup(route || request.route);
        if (!config ||
            !config.access) {

            return true;
        }

        const credentials = request.auth.credentials;
        if (!credentials) {
            if (config.mode !== 'required') {
                return false;
            }

            throw Boom.forbidden('Request is unauthenticated');
        }

        const requestEntity = (credentials.user ? 'user' : 'app');

        const scopeErrors = [];
        for (const access of config.access) {

            // Check entity

            const entity = access.entity;
            if (entity &&
                entity !== 'any' &&
                entity !== requestEntity) {

                continue;
            }

            // Check scope

            let scope = access.scope;
            if (scope) {
                if (!credentials.scope) {
                    scopeErrors.push(scope);
                    continue;
                }

                scope = internals.expandScope(request, scope);
                if (!internals.validateScope(credentials, scope, 'required') ||
                    !internals.validateScope(credentials, scope, 'selection') ||
                    !internals.validateScope(credentials, scope, 'forbidden')) {

                    scopeErrors.push(scope);
                    continue;
                }
            }

            return true;
        }

        // Scope error

        if (scopeErrors.length) {
            request._log(['auth', 'scope', 'error']);
            throw Boom.forbidden('Insufficient scope', { got: credentials.scope, need: scopeErrors });
        }

        // Entity error

        if (requestEntity === 'app') {
            request._log(['auth', 'entity', 'user', 'error']);
            throw Boom.forbidden('Application credentials cannot be used on a user endpoint');
        }

        request._log(['auth', 'entity', 'app', 'error']);
        throw Boom.forbidden('User credentials cannot be used on an application endpoint');
    }

    static async payload(request) {

        if (!request.auth.isAuthenticated) {
            return;
        }

        const auth = request._core.auth;
        const strategy = auth._strategies[request.auth.strategy];
        Hoek.assert(strategy, 'Unknown authentication strategy:', request.auth.strategy);

        if (!strategy.methods.payload) {
            return;
        }

        const config = auth.lookup(request.route);
        const setting = config.payload || (strategy.methods.options.payload ? 'required' : false);
        if (!setting) {
            return;
        }

        const bind = strategy.methods;
        const realm = strategy.realm;
        const response = await request._core.toolkit.execute(strategy.methods.payload, request, { bind, realm });

        if (response.isBoom &&
            response.isMissing) {

            return (setting === 'optional' ? undefined : Boom.unauthorized('Missing payload authentication'));
        }

        return response;
    }

    static async response(request) {

        const auth = request._core.auth;
        if (!request.auth.isAuthenticated) {
            return;
        }

        const strategy = auth._strategies[request.auth.strategy];
        Hoek.assert(strategy, 'Unknown authentication strategy:', request.auth.strategy);

        if (!strategy.methods.response) {
            return;
        }

        const bind = strategy.methods;
        const realm = strategy.realm;
        const error = await request._core.toolkit.execute(strategy.methods.response, request, { bind, realm, continue: 'undefined' });
        if (error) {
            throw error;
        }
    }
};


internals.setupScope = function (access) {

    if (!access.scope) {
        return false;
    }

    const scope = {};
    for (const value of access.scope) {
        const prefix = value[0];
        const type = (prefix === '+' ? 'required' : (prefix === '!' ? 'forbidden' : 'selection'));
        const clean = (type === 'selection' ? value : value.slice(1));
        scope[type] = scope[type] || [];
        scope[type].push(clean);

        if ((!scope._hasParameters || !scope._hasParameters[type]) &&
            /{([^}]+)}/.test(clean)) {

            scope._hasParameters = scope._hasParameters || {};
            scope._hasParameters[type] = true;
        }
    }

    return scope;
};


internals.validate = function (err, result, name, config, request, errors) {                 // err can be Boom, Error, or a valid response object

    result = result || {};

    // Unauthenticated

    if (err) {
        if (err instanceof Error === false) {
            request._log(['auth', 'unauthenticated', 'response', name], { statusCode: err.statusCode });
            return err;     // Non-error response
        }

        if (err.isMissing) {

            // Try next strategy

            request._log(['auth', 'unauthenticated', 'missing', name], err);
            errors.push(err.output.headers['WWW-Authenticate']);
            return internals.missing;
        }

        if (config.mode === 'try') {
            request.auth.isAuthenticated = false;
            request.auth.strategy = name;
            request.auth.credentials = result.credentials;
            request.auth.artifacts = result.artifacts;
            request.auth.error = err;
            request._log(['auth', 'unauthenticated', 'try', name], err);
            return;
        }

        request._log(['auth', 'unauthenticated', 'error', name], err);
        throw err;
    }

    // Authenticated

    const credentials = result.credentials;
    request.auth.strategy = name;
    request.auth.credentials = credentials;
    request.auth.artifacts = result.artifacts;
    request.auth.isAuthenticated = true;
};


internals.expandScope = function (request, scope) {

    if (!scope._hasParameters) {
        return scope;
    }

    const expanded = {
        required: internals.expandScopeType(request, scope, 'required'),
        selection: internals.expandScopeType(request, scope, 'selection'),
        forbidden: internals.expandScopeType(request, scope, 'forbidden')
    };

    return expanded;
};


internals.expandScopeType = function (request, scope, type) {

    if (!scope._hasParameters[type]) {
        return scope[type];
    }

    const expanded = [];
    const context = {
        params: request.params,
        query: request.query,
        payload: request.payload,
        credentials: request.auth.credentials
    };

    for (const template of scope[type]) {
        expanded.push(Hoek.reachTemplate(context, template));
    }

    return expanded;
};


internals.validateScope = function (credentials, scope, type) {

    if (!scope[type]) {
        return true;
    }

    const count = typeof credentials.scope === 'string' ?
        (scope[type].indexOf(credentials.scope) !== -1 ? 1 : 0) :
        Hoek.intersect(scope[type], credentials.scope).length;

    if (type === 'forbidden') {
        return count === 0;
    }

    if (type === 'required') {
        return count === scope.required.length;
    }

    return !!count;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/compression.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/compression.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Zlib = __webpack_require__(/*! zlib */ "zlib");

const Accept = __webpack_require__(/*! @hapi/accept */ "./node_modules/@hapi/accept/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    common: ['gzip, deflate', 'deflate, gzip', 'gzip', 'deflate', 'gzip, deflate, br']
};


exports = module.exports = internals.Compression = class {

    constructor() {

        this.encodings = ['identity', 'gzip', 'deflate'];
        this._encoders = {
            identity: null,
            gzip: (options) => Zlib.createGzip(options),
            deflate: (options) => Zlib.createDeflate(options)
        };

        this._decoders = {
            gzip: (options) => Zlib.createGunzip(options),
            deflate: (options) => Zlib.createInflate(options)
        };

        this._updateCommons();
    }

    _updateCommons() {

        this._common = new Map();
        internals.common.forEach((header) => {

            this._common.set(header, Accept.encoding(header, this.encodings));
        });
    }

    addEncoder(encoding, encoder) {

        Hoek.assert(this._encoders[encoding] === undefined, `Cannot override existing encoder for ${encoding}`);
        Hoek.assert(typeof encoder === 'function', `Invalid encoder function for ${encoding}`);
        this._encoders[encoding] = encoder;
        this.encodings.unshift(encoding);
        this._updateCommons();
    }

    addDecoder(encoding, decoder) {

        Hoek.assert(this._decoders[encoding] === undefined, `Cannot override existing decoder for ${encoding}`);
        Hoek.assert(typeof decoder === 'function', `Invalid decoder function for ${encoding}`);
        this._decoders[encoding] = decoder;
    }

    accept(request) {

        const header = request.headers['accept-encoding'];
        const common = this._common.get(header);
        if (common) {
            return common;
        }

        try {
            return Accept.encoding(header, this.encodings);
        }
        catch (err) {
            Bounce.rethrow(err, 'system');
            err.header = header;
            request._log(['accept-encoding', 'error'], err);
            return 'identity';
        }
    }

    encoding(response, length) {

        if (response.settings.compressed) {
            response.headers['content-encoding'] = response.settings.compressed;
            return null;
        }

        const request = response.request;
        if (!request._core.settings.compression ||
            length !== null && length < request._core.settings.compression.minBytes) {

            return null;
        }

        const mime = request._core.mime.type(response.headers['content-type'] || 'application/octet-stream');
        if (!mime.compressible) {
            return null;
        }

        response.vary('accept-encoding');

        if (response.headers['content-encoding']) {
            return null;
        }

        return request.info.acceptEncoding === 'identity' ? null : request.info.acceptEncoding;
    }

    encoder(request, encoding) {

        const encoder = this._encoders[encoding];
        Hoek.assert(encoder !== undefined, `Unknown encoding ${encoding}`);
        return encoder(request.route.settings.compression[encoding]);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/config.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/config.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Os = __webpack_require__(/*! os */ "os");

const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");


const internals = {};


exports.symbol = Symbol('hapi-response');


exports.apply = function (type, options, ...message) {

    const result = Joi.validate(options, internals[type]);

    if (result.error) {
        throw new Error(`Invalid ${type} options ${message.length ? '(' + message.join(' ') + ')' : ''} ${result.error.annotate()}`);
    }

    return result.value;
};


exports.enable = function (options) {

    const settings = (options ? Object.assign({}, options) : {});       // Shallow cloned

    if (settings.security === true) {
        settings.security = {};
    }

    if (settings.cors === true) {
        settings.cors = {};
    }

    return settings;
};


internals.access = Joi.object({
    entity: Joi.valid('user', 'app', 'any'),
    scope: [false, Joi.array().items(Joi.string()).single().min(1)]
});


internals.auth = Joi.alternatives([
    Joi.string(),
    internals.access.keys({
        mode: Joi.valid('required', 'optional', 'try'),
        strategy: Joi.string(),
        strategies: Joi.array().items(Joi.string()).min(1),
        access: Joi.array().items(internals.access.min(1)).single().min(1),
        payload: [
            Joi.valid('required', 'optional'),
            Joi.boolean()
        ]
    })
        .without('strategy', 'strategies')
        .without('access', ['scope', 'entity'])
]);


internals.event = Joi.object({
    method: Joi.array().items(Joi.func()).single(),
    options: Joi.object({
        before: Joi.array().items(Joi.string()).single(),
        after: Joi.array().items(Joi.string()).single(),
        bind: Joi.any(),
        sandbox: Joi.valid('server', 'plugin'),
        timeout: Joi.number().integer().min(1)
    })
        .default({})
});


internals.exts = Joi.array().items(internals.event.keys({ type: Joi.string().required() })).single();


internals.failAction = Joi.alternatives([
    Joi.valid('error', 'log', 'ignore'),
    Joi.func()
])
    .default('error');


internals.routeBase = Joi.object({
    app: Joi.object().allow(null),
    auth: internals.auth.allow(false),
    bind: Joi.object().allow(null),
    cache: Joi.object({
        expiresIn: Joi.number(),
        expiresAt: Joi.string(),
        privacy: Joi.valid('default', 'public', 'private'),
        statuses: Joi.array().items(Joi.number().integer().min(200)).min(1).single().default([200, 204]),
        otherwise: Joi.string().default('no-cache')
    })
        .allow(false)
        .default(),
    compression: Joi.object()
        .pattern(/.+/, Joi.object())
        .default(),
    cors: Joi.object({
        origin: Joi.array().min(1).allow('ignore').default(['*']),
        maxAge: Joi.number().default(86400),
        headers: Joi.array().items(Joi.string()).default(['Accept', 'Authorization', 'Content-Type', 'If-None-Match']),
        additionalHeaders: Joi.array().items(Joi.string()).default([]),
        exposedHeaders: Joi.array().items(Joi.string()).default(['WWW-Authenticate', 'Server-Authorization']),
        additionalExposedHeaders: Joi.array().items(Joi.string()).default([]),
        credentials: Joi.boolean().when('origin', { is: 'ignore', then: false }).default(false)
    })
        .allow(false, true)
        .default(false),
    ext: Joi.object({
        onPreAuth: Joi.array().items(internals.event).single(),
        onCredentials: Joi.array().items(internals.event).single(),
        onPostAuth: Joi.array().items(internals.event).single(),
        onPreHandler: Joi.array().items(internals.event).single(),
        onPostHandler: Joi.array().items(internals.event).single(),
        onPreResponse: Joi.array().items(internals.event).single()
    })
        .default({}),
    files: Joi.object({
        relativeTo: Joi.string().regex(/^([\/\.])|([A-Za-z]:\\)|(\\\\)/).default('.')
    })
        .default(),
    json: Joi.object({
        replacer: Joi.alternatives(Joi.func(), Joi.array()).allow(null).default(null),
        space: Joi.number().allow(null).default(null),
        suffix: Joi.string().allow(null).default(null),
        escape: Joi.boolean().default(false)
    })
        .default(),
    jsonp: Joi.string(),
    log: Joi.object({
        collect: Joi.boolean().default(false)
    })
        .default(),
    payload: Joi.object({
        output: Joi.valid('data', 'stream', 'file').default('data'),
        parse: Joi.boolean().allow('gunzip').default(true),
        multipart: Joi.object({
            output: Joi.valid('data', 'stream', 'file', 'annotated').required()
        })
            .allow(false),
        allow: Joi.array().items(Joi.string()).single(),
        override: Joi.string(),
        protoAction: Joi.valid('error', 'remove', 'ignore').default('error'),
        maxBytes: Joi.number().integer().positive().default(1024 * 1024),
        uploads: Joi.string().default(Os.tmpdir()),
        failAction: internals.failAction,
        timeout: Joi.number().integer().positive().allow(false).default(10 * 1000),
        defaultContentType: Joi.string().default('application/json'),
        compression: Joi.object()
            .pattern(/.+/, Joi.object())
            .default()
    })
        .default(),
    plugins: Joi.object(),
    response: Joi.object({
        disconnectStatusCode: Joi.number().integer().min(400).default(499),
        emptyStatusCode: Joi.valid(200, 204).default(200),
        failAction: internals.failAction,
        modify: Joi.boolean(),
        options: Joi.object().default(),
        ranges: Joi.boolean().default(true),
        sample: Joi.number().min(0).max(100).when('modify', { is: true, then: Joi.forbidden() }),
        schema: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(true, false),
        status: Joi.object().pattern(/\d\d\d/, Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(true, false))
    })
        .default()
        .assert('options.stripUnknown', Joi.when('modify', { is: true, otherwise: false }), 'meet requirement of having peer modify set to true'),
    security: Joi.object({
        hsts: Joi.alternatives([
            Joi.object({
                maxAge: Joi.number(),
                includeSubdomains: Joi.boolean(),
                includeSubDomains: Joi.boolean(),
                preload: Joi.boolean()
            }),
            Joi.boolean(),
            Joi.number()
        ])
            .default(15768000),
        xframe: Joi.alternatives([
            Joi.boolean(),
            Joi.valid('sameorigin', 'deny'),
            Joi.object({
                rule: Joi.valid('sameorigin', 'deny', 'allow-from'),
                source: Joi.string()
            })
        ])
            .default('deny'),
        xss: Joi.boolean().default(true),
        noOpen: Joi.boolean().default(true),
        noSniff: Joi.boolean().default(true),
        referrer: Joi.alternatives([
            Joi.boolean().valid(false),
            Joi.valid('', 'no-referrer', 'no-referrer-when-downgrade',
                'unsafe-url', 'same-origin', 'origin', 'strict-origin',
                'origin-when-cross-origin', 'strict-origin-when-cross-origin')
        ])
            .default(false)
    })
        .allow(null, false, true)
        .default(false),
    state: Joi.object({
        parse: Joi.boolean().default(true),
        failAction: internals.failAction
    })
        .default(),
    timeout: Joi.object({
        socket: Joi.number().integer().positive().allow(false),
        server: Joi.number().integer().positive().allow(false).default(false)
    })
        .default(),
    validate: Joi.object({
        headers: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, true),
        params: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, true),
        query: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),
        payload: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),
        state: Joi.alternatives(Joi.object(), Joi.array(), Joi.func()).allow(null, false, true),
        failAction: internals.failAction,
        errorFields: Joi.object(),
        options: Joi.object().default()
    })
        .default()
});


internals.server = Joi.object({
    address: Joi.string().hostname(),
    app: Joi.object().allow(null),
    autoListen: Joi.boolean(),
    cache: Joi.allow(null),                                 // Validated elsewhere
    compression: Joi.object({
        minBytes: Joi.number().min(1).integer().default(1024)
    })
        .allow(false)
        .default(),
    debug: Joi.object({
        request: Joi.array().items(Joi.string()).single().allow(false).default(['implementation']),
        log: Joi.array().items(Joi.string()).single().allow(false)
    })
        .allow(false)
        .default(),
    host: Joi.string().hostname().allow(null),
    listener: Joi.any(),
    load: Joi.object({
        sampleInterval: Joi.number().integer().min(0).default(0),
        concurrent: Joi.number().integer().min(0).default(0)
    })
        .unknown()
        .default(),
    mime: Joi.object().allow(null).default(null),
    operations: Joi.object({
        cleanStop: Joi.boolean().default(true)
    })
        .default(),
    plugins: Joi.object(),
    port: Joi.alternatives([
        Joi.number().integer().min(0),          // TCP port
        Joi.string().regex(/\//),               // Unix domain socket
        Joi.string().regex(/^\\\\\.\\pipe\\/)   // Windows named pipe
    ])
        .allow(null),
    query: Joi.object({
        parser: Joi.func()
    })
        .default(),
    router: Joi.object({
        isCaseSensitive: Joi.boolean().default(true),
        stripTrailingSlash: Joi.boolean().default(false)
    })
        .default(),
    routes: internals.routeBase.default(),
    state: Joi.object(),                                    // Cookie defaults
    tls: Joi.alternatives([
        Joi.object().allow(null),
        Joi.boolean()
    ]),
    uri: Joi.string().regex(/[^/]$/)
});


internals.vhost = Joi.alternatives([
    Joi.string().hostname(),
    Joi.array().items(Joi.string().hostname()).min(1)
]);


internals.handler = Joi.alternatives([
    Joi.func(),
    Joi.object().length(1)
]);


internals.route = Joi.object({
    method: Joi.string().regex(/^[a-zA-Z0-9!#\$%&'\*\+\-\.^_`\|~]+$/).required(),
    path: Joi.string().required(),
    rules: Joi.object(),
    vhost: internals.vhost,

    // Validated in route construction

    handler: Joi.any(),
    options: Joi.any(),
    config: Joi.any()               // Backwards compatibility
})
    .without('config', 'options');


internals.pre = [
    Joi.func(),
    Joi.object({
        method: Joi.alternatives(Joi.string(), Joi.func()).required(),
        assign: Joi.string(),
        mode: Joi.valid('serial', 'parallel'),
        failAction: internals.failAction
    })
];


internals.routeConfig = internals.routeBase.keys({
    description: Joi.string(),
    id: Joi.string(),
    isInternal: Joi.boolean(),
    notes: [
        Joi.string(),
        Joi.array().items(Joi.string())
    ],
    pre: Joi.array().items(internals.pre.concat(Joi.array().items(internals.pre).min(1))),
    tags: [
        Joi.string(),
        Joi.array().items(Joi.string())
    ]
});


internals.cacheConfig = Joi.alternatives([
    Joi.func(),
    Joi.object({
        name: Joi.string().invalid('_default'),
        shared: Joi.boolean(),
        provider: [
            Joi.func(),
            {
                constructor: Joi.func().required(),
                options: Joi.object({
                    partition: Joi.string().default('hapi-cache')
                })
                    .unknown()      // Catbox client validates other keys
                    .default({})
            }
        ],
        engine: Joi.object()
    })
        .xor('provider', 'engine')
]);


internals.cache = Joi.array().items(internals.cacheConfig).min(1).single();


internals.cachePolicy = Joi.object({
    cache: Joi.string().allow(null).allow(''),
    segment: Joi.string(),
    shared: Joi.boolean()
})
    .unknown();                     // Catbox policy validates other keys


internals.method = Joi.object({
    bind: Joi.object().allow(null),
    generateKey: Joi.func(),
    cache: internals.cachePolicy
});


internals.methodObject = Joi.object({
    name: Joi.string().required(),
    method: Joi.func().required(),
    options: Joi.object()
});


internals.register = Joi.object({
    once: true,
    routes: Joi.object({
        prefix: Joi.string().regex(/^\/.+/),
        vhost: internals.vhost
    })
        .default({})
});


internals.semver = Joi.string();


internals.plugin = internals.register.keys({
    options: Joi.any(),
    plugin: Joi.object({
        register: Joi.func().required(),
        name: Joi.string().when('pkg.name', { is: Joi.exist(), otherwise: Joi.required() }),
        version: Joi.string(),
        multiple: Joi.boolean().default(false),
        dependencies: [
            Joi.array().items(Joi.string()).single(),
            Joi.object().pattern(/.+/, internals.semver)
        ],
        once: true,
        requirements: Joi.object({
            hapi: Joi.string(),
            node: Joi.string()
        })
            .default(),
        pkg: Joi.object({
            name: Joi.string(),
            version: Joi.string().default('0.0.0')
        })
            .unknown()
            .default({})
    })
        .unknown()
})
    .without('once', 'options')
    .unknown();


internals.rules = Joi.object({
    validate: Joi.object({
        schema: Joi.alternatives(Joi.object(), Joi.array()).required(),
        options: Joi.object()
            .default({ allowUnknown: true })
    })
});


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/core.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/core.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Http = __webpack_require__(/*! http */ "http");
const Https = __webpack_require__(/*! https */ "https");
const Os = __webpack_require__(/*! os */ "os");
const Path = __webpack_require__(/*! path */ "path");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Call = __webpack_require__(/*! @hapi/call */ "./node_modules/@hapi/call/lib/index.js");
const Catbox = __webpack_require__(/*! @hapi/catbox */ "./node_modules/@hapi/catbox/lib/index.js");
const CatboxMemory = __webpack_require__(/*! @hapi/catbox-memory */ "./node_modules/@hapi/catbox-memory/lib/index.js");
const Heavy = __webpack_require__(/*! @hapi/heavy */ "./node_modules/@hapi/heavy/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Mimos = __webpack_require__(/*! @hapi/mimos */ "./node_modules/@hapi/mimos/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");
const Somever = __webpack_require__(/*! @hapi/somever */ "./node_modules/@hapi/somever/lib/index.js");
const Statehood = __webpack_require__(/*! @hapi/statehood */ "./node_modules/@hapi/statehood/lib/index.js");

const Auth = __webpack_require__(/*! ./auth */ "./node_modules/@hapi/hapi/lib/auth.js");
const Compression = __webpack_require__(/*! ./compression */ "./node_modules/@hapi/hapi/lib/compression.js");
const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Ext = __webpack_require__(/*! ./ext */ "./node_modules/@hapi/hapi/lib/ext.js");
const Methods = __webpack_require__(/*! ./methods */ "./node_modules/@hapi/hapi/lib/methods.js");
const Request = __webpack_require__(/*! ./request */ "./node_modules/@hapi/hapi/lib/request.js");
const Route = __webpack_require__(/*! ./route */ "./node_modules/@hapi/hapi/lib/route.js");
const Toolkit = __webpack_require__(/*! ./toolkit */ "./node_modules/@hapi/hapi/lib/toolkit.js");


const internals = {
    counter: {
        min: 10000,
        max: 99999
    },
    events: [
        { name: 'log', channels: ['app', 'internal'], tags: true },
        { name: 'request', channels: ['app', 'internal', 'error'], tags: true, spread: true },
        'response',
        'route',
        'start',
        'stop'
    ],
    badRequestResponse: Buffer.from('HTTP/1.1 400 Bad Request\r\n\r\n', 'ascii')
};


exports = module.exports = internals.Core = class {

    constructor(options) {

        this.root = null;                                                               // Dispatch reference of the root server

        const { settings, type } = internals.setup(options);

        this.settings = settings;
        this.type = type;

        this.app = {};
        this.auth = new Auth(this);
        this.caches = new Map();                                                        // Cache clients
        this.compression = new Compression();
        this.controlled = null;                                                         // Other servers linked to the phases of this server
        this.decorations = { handler: [], request: [], server: [], toolkit: [] };       // Public decoration names
        this.dependencies = [];                                                         // Plugin dependencies
        this.events = new Podium(internals.events);
        this.heavy = new Heavy(this.settings.load);
        this.instances = new Set();
        this.methods = new Methods(this);                                               // Server methods
        this.mime = new Mimos(this.settings.mime);
        this.onConnection = null;                                                       // Used to remove event listener on stop
        this.plugins = {};                                                              // Exposed plugin properties by name
        this.queue = new internals.Queue(this.settings.load);
        this.registrations = {};                                                        // Tracks plugin for dependency validation { name -> { version } }
        this.registring = 0;                                                            // > 0 while register() is waiting for plugin callbacks
        this.requestCounter = { value: internals.counter.min, min: internals.counter.min, max: internals.counter.max };
        this.router = new Call.Router(this.settings.router);
        this.phase = 'stopped';                                                         // 'stopped', 'initializing', 'initialized', 'starting', 'started', 'stopping', 'invalid'
        this.sockets = null;                                                            // Track open sockets for graceful shutdown
        this.actives = new WeakMap();                                                   // Active requests being processed
        this.started = false;
        this.states = new Statehood.Definitions(this.settings.state);
        this.toolkit = new Toolkit();

        this.extensionsSeq = 0;                                                         // Used to keep absolute order of extensions based on the order added across locations
        this.extensions = {
            server: {
                onPreStart: new Ext('onPreStart', this),
                onPostStart: new Ext('onPostStart', this),
                onPreStop: new Ext('onPreStop', this),
                onPostStop: new Ext('onPostStop', this)
            },
            route: {
                onRequest: new Ext('onRequest', this),
                onPreAuth: new Ext('onPreAuth', this),
                onCredentials: new Ext('onCredentials', this),
                onPostAuth: new Ext('onPostAuth', this),
                onPreHandler: new Ext('onPreHandler', this),
                onPostHandler: new Ext('onPostHandler', this),
                onPreResponse: new Ext('onPreResponse', this)
            }
        };

        this.Request = class extends Request { };

        this._debug();
        this._decorations = { handler: {}, request: {}, server: {}, toolkit: {}, requestApply: null };
        this._initializeCache();

        this.listener = this._createListener();
        this._initializeListener();
        this.info = this._info();
    }

    _debug() {

        // Subscribe to server log events

        if (this.settings.debug) {
            const debug = (request, event) => {

                const data = event.error || event.data;
                console.error('Debug:', event.tags.join(', '), data ? '\n    ' + (data.stack || (typeof data === 'object' ? Hoek.stringify(data) : data)) : '');
            };

            if (this.settings.debug.log) {
                const filter = this.settings.debug.log.some((tag) => tag === '*') ? undefined : this.settings.debug.log;
                this.events.on({ name: 'log', filter }, (event) => debug(null, event));
            }

            if (this.settings.debug.request) {
                const filter = this.settings.debug.request.some((tag) => tag === '*') ? undefined : this.settings.debug.request;
                this.events.on({ name: 'request', filter }, debug);
            }
        }
    }

    _initializeCache() {

        if (this.settings.cache) {
            this._createCache(this.settings.cache);
        }

        if (!this.caches.has('_default')) {
            this._createCache([{ provider: CatboxMemory }]);        // Defaults to memory-based
        }
    }

    _info() {

        const now = Date.now();
        const protocol = this.type === 'tcp' ? (this.settings.tls ? 'https' : 'http') : this.type;
        const host = this.settings.host || Os.hostname() || 'localhost';
        const port = this.settings.port;

        const info = {
            created: now,
            started: 0,
            host,
            port,
            protocol,
            id: Os.hostname() + ':' + process.pid + ':' + now.toString(36),
            uri: this.settings.uri || (protocol + ':' + (this.type === 'tcp' ? '//' + host + (port ? ':' + port : '') : port))
        };

        return info;
    }

    _createCache(configs) {

        Hoek.assert(this.phase !== 'initializing', 'Cannot provision server cache while server is initializing');

        configs = Config.apply('cache', configs);

        const added = [];
        for (let config of configs) {

            // <function>
            // { provider: <function> }
            // { provider: { constructor: <function>, options } }
            // { engine }

            if (typeof config === 'function') {
                config = { provider: { constructor: config } };
            }

            const name = config.name || '_default';
            Hoek.assert(!this.caches.has(name), 'Cannot configure the same cache more than once: ', name === '_default' ? 'default cache' : name);

            let client = null;

            if (config.provider) {
                let provider = config.provider;
                if (typeof provider === 'function') {
                    provider = { constructor: provider };
                }

                client = new Catbox.Client(provider.constructor, provider.options || { partition: 'hapi-cache' });
            }
            else {
                client = new Catbox.Client(config.engine);
            }

            this.caches.set(name, { client, segments: {}, shared: config.shared || false });
            added.push(client);
        }

        return added;
    }

    registerServer(server) {

        if (!this.root) {
            this.root = server;
            this._defaultRoutes();
        }

        this.instances.add(server);
    }

    async _start() {

        if (this.phase === 'initialized' ||
            this.phase === 'started') {

            this._validateDeps();
        }

        if (this.phase === 'started') {
            return;
        }

        if (this.phase !== 'stopped' &&
            this.phase !== 'initialized') {

            throw new Error('Cannot start server while it is in ' + this.phase + ' phase');
        }

        if (this.phase !== 'initialized') {
            await this._initialize();
        }

        this.phase = 'starting';
        this.started = true;
        this.info.started = Date.now();

        try {
            await this._listen();
        }
        catch (err) {
            this.started = false;
            this.phase = 'invalid';
            throw err;
        }

        this.phase = 'started';
        await this.events.emit('start');

        try {
            if (this.controlled) {
                await Promise.all(this.controlled.map((control) => control.start()));
            }

            await this._invoke('onPostStart');
        }
        catch (err) {
            this.phase = 'invalid';
            throw err;
        }
    }

    _listen() {

        return new Promise((resolve, reject) => {

            if (!this.settings.autoListen) {
                resolve();
                return;
            }

            const onError = (err) => {

                reject(err);
                return;
            };

            this.listener.once('error', onError);

            const finalize = () => {

                this.listener.removeListener('error', onError);
                resolve();
                return;
            };

            if (this.type !== 'tcp') {
                this.listener.listen(this.settings.port, finalize);
            }
            else {
                const address = this.settings.address || this.settings.host || '0.0.0.0';
                this.listener.listen(this.settings.port, address, finalize);
            }
        });
    }

    async _initialize() {

        if (this.registring) {
            throw new Error('Cannot start server before plugins finished registration');
        }

        if (this.phase === 'initialized') {
            return;
        }

        if (this.phase !== 'stopped') {
            throw new Error('Cannot initialize server while it is in ' + this.phase + ' phase');
        }

        this._validateDeps();
        this.phase = 'initializing';

        // Start cache

        try {
            const caches = [];
            this.caches.forEach((cache) => caches.push(cache.client.start()));
            await Promise.all(caches);
            await this._invoke('onPreStart');
            this.heavy.start();
            this.phase = 'initialized';

            if (this.controlled) {
                await Promise.all(this.controlled.map((control) => control.initialize()));
            }
        }
        catch (err) {
            this.phase = 'invalid';
            throw err;
        }
    }

    _validateDeps() {

        for (const { deps, plugin } of this.dependencies) {
            for (const dep in deps) {
                const version = deps[dep];
                Hoek.assert(this.registrations[dep], 'Plugin', plugin, 'missing dependency', dep);
                Hoek.assert(version === '*' || Somever.match(this.registrations[dep].version, version), 'Plugin', plugin, 'requires', dep, 'version', version, 'but found', this.registrations[dep].version);
            }
        }
    }

    async _stop(options = {}) {

        options.timeout = options.timeout || 5000;          // Default timeout to 5 seconds

        if (['stopped', 'initialized', 'started', 'invalid'].indexOf(this.phase) === -1) {
            throw new Error('Cannot stop server while in ' + this.phase + ' phase');
        }

        this.phase = 'stopping';

        try {
            await this._invoke('onPreStop');

            if (this.started) {
                this.started = false;
                this.info.started = 0;

                await this._unlisten(options.timeout);
            }

            const caches = [];
            this.caches.forEach((cache) => caches.push(cache.client.stop()));
            await Promise.all(caches);

            await this.events.emit('stop');
            this.heavy.stop();

            if (this.controlled) {
                await Promise.all(this.controlled.map((control) => control.stop(options)));
            }

            await this._invoke('onPostStop');
            this.phase = 'stopped';
        }
        catch (err) {
            this.phase = 'invalid';
            throw err;
        }
    }

    _unlisten(timeout) {

        let timeoutId = null;
        if (this.settings.operations.cleanStop) {

            // Set connections timeout

            const destroy = () => {

                this.sockets.forEach((connection) => connection.destroy());
                this.sockets.clear();
            };

            timeoutId = setTimeout(destroy, timeout);

            // Tell idle keep-alive connections to close

            this.sockets.forEach((connection) => {

                if (!this.actives.has(connection)) {
                    connection.end();
                }
            });
        }

        // Close connection

        return new Promise((resolve) => {

            this.listener.close(() => {

                if (this.settings.operations.cleanStop) {
                    this.listener.removeListener(this.settings.tls ? 'secureConnection' : 'connection', this.onConnection);
                    clearTimeout(timeoutId);
                }

                this._initializeListener();
                resolve();
            });
        });
    }

    async _invoke(type) {

        const exts = this.extensions.server[type];
        if (!exts.nodes) {
            return;
        }

        // Execute extensions

        for (const ext of exts.nodes) {
            const bind = ext.bind || ext.realm.settings.bind;
            const operation = ext.func.call(bind, ext.server, bind);
            await Toolkit.timed(operation, { timeout: ext.timeout, name: type });
        }
    }

    _defaultRoutes() {

        this.router.special('notFound', new Route({ method: '_special', path: '/{p*}', handler: internals.notFound }, this.root, { special: true }));
        this.router.special('badRequest', new Route({ method: '_special', path: '/{p*}', handler: internals.badRequest }, this.root, { special: true }));

        if (this.settings.routes.cors) {
            Cors.handler(this.root);
        }
    }

    _dispatch(options = {}) {

        return (req, res) => {

            // Create request

            const request = Request.generate(this.root, req, res, options);

            // Track socket request processing state

            if (req.socket) {
                this.actives.set(req.socket, request);
                const env = { core: this, req };
                res.on('finish', internals.onFinish.bind(res, env));
            }

            // Check load

            if (this.settings.load.sampleInterval) {
                try {
                    this.heavy.check();
                }
                catch (err) {
                    Bounce.rethrow(err, 'system');
                    this._log(['load'], this.heavy.load);
                    request._reply(err);
                    return;
                }
            }

            this.queue.add(request);
        };
    }

    _createListener() {

        const listener = this.settings.listener || (this.settings.tls ? Https.createServer(this.settings.tls) : Http.createServer());
        listener.on('request', this._dispatch());
        listener.on('checkContinue', this._dispatch({ expectContinue: true }));

        listener.on('clientError', (err, socket) => {

            this._log(['connection', 'client', 'error'], err);

            if (socket.readable) {
                const request = this.actives.get(socket);
                if (request) {
                    const error = Boom.badRequest();
                    error.output.headers = { connection: 'close' };
                    request._reply(error);
                }
                else {
                    socket.end(internals.badRequestResponse);
                }
            }
            else {
                socket.destroy(err);
            }
        });

        return listener;
    }

    _initializeListener() {

        this.listener.once('listening', () => {

            // Update the address, port, and uri with active values

            if (this.type === 'tcp') {
                const address = this.listener.address();
                this.info.address = address.address;
                this.info.port = address.port;
                this.info.uri = this.settings.uri || this.info.protocol + '://' + this.info.host + ':' + this.info.port;
            }

            if (this.settings.operations.cleanStop) {
                this.sockets = new Set();

                const self = this;
                const onClose = function () {           // 'this' is bound to the emitter

                    self.sockets.delete(this);
                };

                this.onConnection = (connection) => {

                    this.sockets.add(connection);
                    connection.on('close', onClose);
                };

                this.listener.on(this.settings.tls ? 'secureConnection' : 'connection', this.onConnection);
            }
        });
    }

    _cachePolicy(options, _segment, realm) {

        options = Config.apply('cachePolicy', options);

        const plugin = realm && realm.plugin;
        const segment = options.segment || _segment || (plugin ? `!${plugin}` : '');
        Hoek.assert(segment, 'Missing cache segment name');

        const cacheName = options.cache || '_default';
        const cache = this.caches.get(cacheName);
        Hoek.assert(cache, 'Unknown cache', cacheName);
        Hoek.assert(!cache.segments[segment] || cache.shared || options.shared, 'Cannot provision the same cache segment more than once');
        cache.segments[segment] = true;

        return new Catbox.Policy(options, cache.client, segment);
    }

    log(tags, data) {

        return this._log(tags, data, 'app');
    }

    _log(tags, data, channel = 'internal') {

        if (!this.events.hasListeners('log')) {
            return;
        }

        if (!Array.isArray(tags)) {
            tags = [tags];
        }

        const timestamp = Date.now();
        const field = data instanceof Error ? 'error' : 'data';

        let event = { timestamp, tags, [field]: data, channel };

        if (typeof data === 'function') {
            event = () => ({ timestamp, tags, data: data(), channel });
        }

        this.events.emit({ name: 'log', tags, channel }, event);
    }
};


internals.setup = function (options = {}) {

    let settings = Hoek.clone(options, { shallow: ['cache', 'listener', 'routes.bind'] });
    settings.routes = Config.enable(settings.routes);
    settings = Config.apply('server', settings);

    if (settings.port === undefined) {
        settings.port = 0;
    }

    const type = (typeof settings.port === 'string' ? 'socket' : 'tcp');
    if (type === 'socket') {
        settings.port = (settings.port.indexOf('/') !== -1 ? Path.resolve(settings.port) : settings.port.toLowerCase());
    }

    if (settings.autoListen === undefined) {
        settings.autoListen = true;
    }

    Hoek.assert(settings.autoListen || !settings.port, 'Cannot specify port when autoListen is false');
    Hoek.assert(settings.autoListen || !settings.address, 'Cannot specify address when autoListen is false');

    return { settings, type };
};


internals.notFound = function () {

    throw Boom.notFound();
};


internals.badRequest = function () {

    throw Boom.badRequest();
};


internals.onFinish = function (env) {

    const { core, req } = env;

    core.actives.delete(req.socket);
    if (!core.started) {
        req.socket.end();
    }
};


internals.Queue = class {

    constructor(options) {

        this.settings = options;

        this.active = 0;
        this.queue = [];
    }

    add(request) {

        if (this.settings.concurrent) {
            this.queue.push(request);
            this.next();
        }
        else {
            request._execute();
        }
    }

    next() {

        if (this.queue.length &&
            this.active < this.settings.concurrent) {

            const request = this.queue.shift();
            ++this.active;
            request._execute();
        }
    }

    release() {

        if (this.settings.concurrent) {
            --this.active;
            this.next();
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/cors.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/cors.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

let Route = null;                           // Delayed load due to circular dependency


const internals = {};


exports.route = function (options) {

    if (!options) {
        return false;
    }

    const settings = Hoek.clone(options);
    settings._headers = settings.headers.concat(settings.additionalHeaders);
    settings._headersString = settings._headers.join(',');
    for (let i = 0; i < settings._headers.length; ++i) {
        settings._headers[i] = settings._headers[i].toLowerCase();
    }

    if (settings._headers.indexOf('origin') === -1) {
        settings._headers.push('origin');
    }

    settings._exposedHeaders = settings.exposedHeaders.concat(settings.additionalExposedHeaders).join(',');

    if (settings.origin === 'ignore') {
        settings._origin = false;
    }
    else if (settings.origin.indexOf('*') !== -1) {
        Hoek.assert(settings.origin.length === 1, 'Cannot specify cors.origin * together with other values');
        settings._origin = true;
    }
    else {
        settings._origin = {
            qualified: [],
            wildcards: []
        };

        for (const origin of settings.origin) {
            if (origin.indexOf('*') !== -1) {
                settings._origin.wildcards.push(new RegExp('^' + Hoek.escapeRegex(origin).replace(/\\\*/g, '.*').replace(/\\\?/g, '.') + '$'));
            }
            else {
                settings._origin.qualified.push(origin);
            }
        }
    }

    return settings;
};


exports.options = function (route, server) {

    if (route.method === 'options' ||
        !route.settings.cors) {

        return;
    }

    exports.handler(server);
};


exports.handler = function (server) {

    Route = Route || __webpack_require__(/*! ./route */ "./node_modules/@hapi/hapi/lib/route.js");

    if (server._core.router.specials.options) {
        return;
    }

    const definition = {
        method: '_special',
        path: '/{p*}',
        handler: internals.handler,
        options: {
            cors: false
        }
    };

    const route = new Route(definition, server, { special: true });
    server._core.router.special('options', route);
};


internals.handler = function (request, h) {

    // Validate CORS preflight request

    const method = request.headers['access-control-request-method'];
    if (!method) {
        throw Boom.notFound('CORS error: Missing Access-Control-Request-Method header');
    }

    // Lookup route

    const route = request.server.match(method, request.path, request.info.hostname);
    if (!route) {
        throw Boom.notFound();
    }

    const settings = route.settings.cors;
    if (!settings) {
        return { message: 'CORS is disabled for this route' };
    }

    // Validate Origin header

    const origin = request.headers.origin;

    if (!origin &&
        settings._origin !== false) {

        throw Boom.notFound('CORS error: Missing Origin header');
    }

    if (!exports.matchOrigin(origin, settings)) {
        return { message: 'CORS error: Origin not allowed' };
    }

    // Validate allowed headers

    let headers = request.headers['access-control-request-headers'];
    if (headers) {
        headers = headers.toLowerCase().split(/\s*,\s*/);
        if (Hoek.intersect(headers, settings._headers).length !== headers.length) {
            return { message: 'CORS error: Some headers are not allowed' };
        }
    }

    // Reply with the route CORS headers

    const response = h.response();
    response._header('access-control-allow-origin', settings._origin ? origin : '*');
    response._header('access-control-allow-methods', method);
    response._header('access-control-allow-headers', settings._headersString);
    response._header('access-control-max-age', settings.maxAge);

    if (settings.credentials) {
        response._header('access-control-allow-credentials', 'true');
    }

    if (settings._exposedHeaders) {
        response._header('access-control-expose-headers', settings._exposedHeaders);
    }

    return response;
};


exports.headers = function (request) {

    const settings = request.route.settings.cors;
    const response = request.response;

    if (settings._origin !== false) {
        response.vary('origin');
    }

    if ((request.info.cors && !request.info.cors.isOriginMatch) ||                          // After route lookup
        !exports.matchOrigin(request.headers.origin, request.route.settings.cors)) {        // Response from onRequest

        return;
    }

    response._header('access-control-allow-origin', settings._origin ? request.headers.origin : '*');

    if (settings.credentials) {
        response._header('access-control-allow-credentials', 'true');
    }

    if (settings._exposedHeaders) {
        response._header('access-control-expose-headers', settings._exposedHeaders, { append: true });
    }
};


exports.matchOrigin = function (origin, settings) {

    if (settings._origin === true ||
        settings._origin === false) {

        return true;
    }

    if (!origin) {
        return false;
    }

    if (settings._origin.qualified.indexOf(origin) !== -1) {
        return true;
    }

    for (const wildcard of settings._origin.wildcards) {
        if (origin.match(wildcard)) {
            return true;
        }
    }

    return false;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/ext.js":
/*!********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/ext.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./node_modules/@hapi/topo/lib/index.js");


const internals = {};


exports = module.exports = internals.Ext = class {

    constructor(type, core) {

        this._topo = new Topo();
        this._core = core;
        this._routes = [];

        this.type = type;
        this.nodes = null;
    }

    add(event) {

        const methods = [].concat(event.method);
        for (const method of methods) {
            const settings = {
                before: event.options.before,
                after: event.options.after,
                group: event.realm.plugin,
                sort: this._core.extensionsSeq++
            };

            const node = {
                func: method,                       // Request: function (request, h), Server: function (server)
                bind: event.options.bind,
                server: event.server,               // Server event
                realm: event.realm,
                timeout: event.options.timeout
            };

            this._topo.add(node, settings);
        }

        this.nodes = this._topo.nodes;

        // Notify routes

        for (const route of this._routes) {
            route.rebuild(event);
        }
    }

    merge(others) {

        const merge = [];
        for (const other of others) {
            merge.push(other._topo);
        }

        this._topo.merge(merge);
        this.nodes = (this._topo.nodes.length ? this._topo.nodes : null);
    }

    subscribe(route) {

        this._routes.push(route);
    }

    static combine(route, type) {

        const ext = new internals.Ext(type, route._core);

        const events = route.settings.ext[type];
        if (events) {
            for (let event of events) {
                event = Object.assign({}, event);       // Shallow cloned
                Hoek.assert(!event.options.sandbox, 'Cannot specify sandbox option for route extension');
                event.realm = route.realm;
                ext.add(event);
            }
        }

        const server = route._core.extensions.route[type];
        const realm = route.realm._extensions[type];

        ext.merge([server, realm]);

        server.subscribe(route);
        realm.subscribe(route);

        return ext;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/handler.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/handler.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports.execute = async function (request) {

    // Prerequisites

    if (request._route._prerequisites) {
        for (const set of request._route._prerequisites) {      // Serial execution of each set
            const pres = [];
            for (const item of set) {
                pres.push(internals.handler(request, item.method, item));
            }

            const responses = await Promise.all(pres);                          // Parallel execution within sets
            for (const response of responses) {
                if (response !== undefined) {
                    return response;
                }
            }
        }
    }

    // Handler

    const result = await internals.handler(request, request.route.settings.handler);
    if (result._takeover ||
        typeof result === 'symbol') {

        return result;
    }

    request._setResponse(result);
};


internals.handler = async function (request, method, pre) {

    const bind = request.route.settings.bind;
    const realm = request.route.realm;
    let response = await request._core.toolkit.execute(method, request, { bind, realm, continue: 'null' });

    // Handler

    if (!pre) {
        if (response.isBoom) {
            request._log(['handler', 'error'], response);
            throw response;
        }

        return response;
    }

    // Pre

    if (response.isBoom) {
        response.assign = pre.assign;
        response = await request._core.toolkit.failAction(request, pre.failAction, response, { tags: ['pre', 'error'], retain: true });
    }

    if (typeof response === 'symbol') {
        return response;
    }

    if (pre.assign) {
        request.pre[pre.assign] = (response.isBoom ? response : response.source);
        request.preResponses[pre.assign] = response;
    }

    if (response._takeover) {
        return response;
    }
};


exports.defaults = function (method, handler, core) {

    let defaults = null;

    if (typeof handler === 'object') {
        const type = Object.keys(handler)[0];
        const serverHandler = core._decorations.handler[type];

        Hoek.assert(serverHandler, 'Unknown handler:', type);

        if (serverHandler.defaults) {
            defaults = (typeof serverHandler.defaults === 'function' ? serverHandler.defaults(method) : serverHandler.defaults);
        }
    }

    return defaults || {};
};


exports.configure = function (handler, route) {

    if (typeof handler === 'object') {
        const type = Object.keys(handler)[0];
        const serverHandler = route._core._decorations.handler[type];

        Hoek.assert(serverHandler, 'Unknown handler:', type);

        return serverHandler(route.public, handler[type]);
    }

    return handler;
};


exports.prerequisitesConfig = function (config) {

    if (!config) {
        return null;
    }

    /*
        [
            [
                function (request, h) { },
                {
                    method: function (request, h) { }
                    assign: key1
                },
                {
                    method: function (request, h) { },
                    assign: key2
                }
            ],
            {
                method: function (request, h) { },
                assign: key3
            }
        ]
    */

    const prerequisites = [];

    for (let pres of config) {
        pres = [].concat(pres);

        const set = [];
        for (let pre of pres) {
            if (typeof pre !== 'object') {
                pre = { method: pre };
            }

            const item = {
                method: pre.method,
                assign: pre.assign,
                failAction: pre.failAction || 'error'
            };

            set.push(item);
        }

        prerequisites.push(set);
    }

    return prerequisites.length ? prerequisites : null;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/headers.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/headers.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



const Stream = __webpack_require__(/*! stream */ "stream");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");

const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");


const internals = {};


exports.cache = function (request) {

    const response = request.response;
    if (response.headers['cache-control']) {
        return;
    }

    const settings = request.route.settings.cache;
    const policy = settings && request._route._cache && (settings._statuses.has(response.statusCode) || (response.statusCode === 304 && settings._statuses.has(200)));

    if (policy ||
        response.settings.ttl) {

        const ttl = (response.settings.ttl !== null ? response.settings.ttl : request._route._cache.ttl());
        const privacy = (request.auth.isAuthenticated || response.headers['set-cookie'] ? 'private' : settings.privacy || 'default');
        response._header('cache-control', 'max-age=' + Math.floor(ttl / 1000) + ', must-revalidate' + (privacy !== 'default' ? ', ' + privacy : ''));
    }
    else if (settings) {
        response._header('cache-control', settings.otherwise);
    }
};


exports.content = async function (request) {

    const response = request.response;
    if (response._isPayloadSupported() ||
        request.method === 'head') {

        await response._marshal();

        if (request.jsonp &&
            response._payload.jsonp) {

            response._header('content-type', 'text/javascript' + (response.settings.charset ? '; charset=' + response.settings.charset : ''));
            response._header('x-content-type-options', 'nosniff');
            response._payload.jsonp(request.jsonp);
        }

        if (response._payload.size &&
            typeof response._payload.size === 'function') {

            response._header('content-length', response._payload.size(), { override: false });
        }

        if (!response._isPayloadSupported()) {
            response._close(request);                       // Close unused file streams
            response._payload = new internals.Empty();      // Set empty stream
        }

        exports.type(request, true);
    }
    else {

        // Set empty stream

        response._close(request);                           // Close unused file streams
        response._payload = new internals.Empty();
        delete response.headers['content-length'];
    }
};


exports.state = async function (request) {

    const response = request.response;
    const states = [];

    for (const stateName in request._states) {
        states.push(request._states[stateName]);
    }

    try {
        for (const name in request._core.states.cookies) {
            const autoValue = request._core.states.cookies[name].autoValue;
            if (!autoValue || name in request._states || name in request.state) {
                continue;
            }

            if (typeof autoValue !== 'function') {
                states.push({ name, value: autoValue });
                continue;
            }

            const value = await autoValue(request);
            states.push({ name, value });
        }

        if (!states.length) {
            return;
        }

        let header = await request._core.states.format(states);
        const existing = response.headers['set-cookie'];
        if (existing) {
            header = (Array.isArray(existing) ? existing : [existing]).concat(header);
        }

        response._header('set-cookie', header);
    }
    catch (err) {
        const error = Boom.boomify(err);
        request._log(['state', 'response', 'error'], error);
        request._states = {};                                           // Clear broken state
        throw error;
    }
};


exports.type = function (request, postMarshal) {

    const response = request.response;
    let type = response.headers['content-type'];
    if (!type) {
        if (response._contentType) {
            const charset = (response.settings.charset && response._contentType !== 'application/octet-stream' ? '; charset=' + response.settings.charset : '');
            response.type(response._contentType + charset);
        }
    }
    else {
        type = type.trim();
        if ((!response._contentType || !postMarshal) &&
            response.settings.charset &&
            type.match(/^(?:text\/)|(?:application\/(?:json)|(?:javascript))/)) {

            if (!type.match(/; *charset=/)) {
                const semi = (type[type.length - 1] === ';');
                response.type(type + (semi ? ' ' : '; ') + 'charset=' + (response.settings.charset));
            }
        }
    }
};


exports.entity = function (request) {

    if (!request._entity) {
        return;
    }

    const response = request.response;

    if (request._entity.etag &&
        !response.headers.etag) {

        response.etag(request._entity.etag, { vary: request._entity.vary });
    }

    if (request._entity.modified &&
        !response.headers['last-modified']) {

        response.header('last-modified', request._entity.modified);
    }
};


exports.unmodified = function (request) {

    const response = request.response;
    if (response.statusCode === 304) {
        return;
    }

    const entity = {
        etag: response.headers.etag,
        vary: response.settings.varyEtag,
        modified: response.headers['last-modified']
    };

    const etag = Response.unmodified(request, entity);
    if (etag) {
        response.code(304);

        if (etag !== true) {                                // Override etag with incoming weak match
            response.headers.etag = etag;
        }
    }
};


internals.Empty = class extends Stream.Readable {

    _read(/* size */) {

        this.push(null);
    }

    writeToStream(stream) {

        stream.end();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Server = __webpack_require__(/*! ./server */ "./node_modules/@hapi/hapi/lib/server.js");


const internals = {};


exports.Server = Server;

exports.server = Server;


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/methods.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/methods.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");


const internals = {
    methodNameRx: /^[_$a-zA-Z][$\w]*(?:\.[_$a-zA-Z][$\w]*)*$/
};


exports = module.exports = internals.Methods = class {

    constructor(core) {

        this.core = core;
        this.methods = {};
    }

    add(name, method, options, realm) {

        if (typeof name !== 'object') {
            return this._add(name, method, options, realm);
        }

        // {} or [{}, {}]

        const items = [].concat(name);
        for (let item of items) {
            item = Config.apply('methodObject', item);
            this._add(item.name, item.method, item.options || {}, realm);
        }
    }

    _add(name, method, options, realm) {

        Hoek.assert(typeof method === 'function', 'method must be a function');
        Hoek.assert(typeof name === 'string', 'name must be a string');
        Hoek.assert(name.match(internals.methodNameRx), 'Invalid name:', name);
        Hoek.assert(!Hoek.reach(this.methods, name, { functions: false }), 'Server method function name already exists:', name);

        options = Config.apply('method', options, name);

        const settings = Hoek.clone(options, { shallow: ['bind'] });
        settings.generateKey = settings.generateKey || internals.generateKey;

        const bind = settings.bind || realm.settings.bind || null;
        const bound = !bind ? method : (...args) => method.apply(bind, args);

        // Not cached

        if (!settings.cache) {
            return this._assign(name, bound);
        }

        // Cached

        Hoek.assert(!settings.cache.generateFunc, 'Cannot set generateFunc with method caching:', name);
        Hoek.assert(settings.cache.generateTimeout !== undefined, 'Method caching requires a timeout value in generateTimeout:', name);

        settings.cache.generateFunc = (id, flags) => bound(...id.args, flags);
        const cache = this.core._cachePolicy(settings.cache, '#' + name);

        const func = function (...args) {

            const key = settings.generateKey.apply(bind, args);
            if (typeof key !== 'string') {
                return Promise.reject(Boom.badImplementation('Invalid method key when invoking: ' + name, { name, args }));
            }

            return cache.get({ id: key, args });
        };

        func.cache = {
            drop: function (...args) {

                const key = settings.generateKey.apply(bind, args);
                if (typeof key !== 'string') {
                    return Promise.reject(Boom.badImplementation('Invalid method key when invoking: ' + name, { name, args }));
                }

                return cache.drop(key);
            },
            stats: cache.stats
        };

        this._assign(name, func, func);
    }

    _assign(name, method) {

        const path = name.split('.');
        let ref = this.methods;
        for (let i = 0; i < path.length; ++i) {
            if (!ref[path[i]]) {
                ref[path[i]] = (i + 1 === path.length ? method : {});
            }

            ref = ref[path[i]];
        }
    }
};


internals.supportedArgs = ['string', 'number', 'boolean'];


internals.generateKey = function (...args) {

    let key = '';
    for (let i = 0; i < args.length; ++i) {
        const arg = args[i];
        if (!internals.supportedArgs.includes(typeof arg)) {
            return null;
        }

        key = key + (i ? ':' : '') + encodeURIComponent(arg.toString());
    }

    return key;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/request.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/request.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Url = __webpack_require__(/*! url */ "url");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");

const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");
const Transmit = __webpack_require__(/*! ./transmit */ "./node_modules/@hapi/hapi/lib/transmit.js");


const internals = {
    events: Podium.validate(['finish', { name: 'peek', spread: true }, 'disconnect']),
    reserved: ['server', 'url', 'query', 'path', 'method', 'mime', 'setUrl', 'setMethod', 'headers', 'id', 'app', 'plugins', 'route', 'auth', 'pre', 'preResponses', 'info', 'orig', 'params', 'paramsArray', 'payload', 'state', 'jsonp', 'response', 'raw', 'domain', 'log', 'logs', 'generateResponse']
};


exports = module.exports = internals.Request = class {

    constructor(server, req, res, options) {

        this._allowInternals = !!options.allowInternals;
        this._core = server._core;
        this._entity = null;                                                                                // Entity information set via h.entity()
        this._eventContext = { request: this };
        this._events = null;                                                                                // Assigned an emitter when request.events is accessed
        this._expectContinue = !!options.expectContinue;
        this._isPayloadPending = !!(req.headers['content-length'] || req.headers['transfer-encoding']);     // Changes to false when incoming payload fully processed
        this._isReplied = false;                                                                            // true when response processing started
        this._route = this._core.router.specials.notFound.route;                                            // Used prior to routing (only settings are used, not the handler)
        this._serverTimeoutId = null;
        this._states = {};
        this._urlError = null;

        this.app = options.app ? Object.assign({}, options.app) : {};                                       // Place for application-specific state without conflicts with hapi, should not be used by plugins (shallow cloned)
        this.headers = req.headers;
        this.info = internals.info(this._core, req);
        this.jsonp = null;
        this.logs = [];
        this.method = req.method.toLowerCase();
        this.mime = null;
        this.orig = {};
        this.params = null;
        this.paramsArray = null;                                                                            // Array of path parameters in path order
        this.path = null;
        this.payload = null;
        this.plugins = options.plugins ? Object.assign({}, options.plugins) : {};                           // Place for plugins to store state without conflicts with hapi, should be namespaced using plugin name (shallow cloned)
        this.pre = {};                                                                                      // Pre raw values
        this.preResponses = {};                                                                             // Pre response values
        this.raw = { req, res };
        this.response = null;
        this.route = this._route.public;
        this.query = null;
        this.server = server;
        this.state = null;
        this.url = null;

        this.auth = {
            isAuthenticated: false,
            isAuthorized: false,
            credentials: options.auth ? options.auth.credentials : null,                                    // Special keys: 'app', 'user', 'scope'
            artifacts: options.auth && options.auth.artifacts || null,                                      // Scheme-specific artifacts
            strategy: options.auth ? options.auth.strategy : null,
            mode: null,
            error: null
        };

        if (options.auth) {
            this.auth.isInjected = true;
        }

        // Parse request url

        this._initializeUrl();
    }

    static generate(server, req, res, options) {

        const request = new server._core.Request(server, req, res, options);

        // Decorate

        if (server._core._decorations.requestApply) {
            for (const property in server._core._decorations.requestApply) {
                const assignment = server._core._decorations.requestApply[property];
                request[property] = assignment(request);
            }
        }

        request._listen();
        return request;
    }

    get events() {

        if (!this._events) {
            this._events = new Podium(internals.events);
        }

        return this._events;
    }

    _initializeUrl() {

        try {
            this._setUrl(this.raw.req.url, this._core.settings.router.stripTrailingSlash);
        }
        catch (err) {
            this.path = this.raw.req.url;
            this.query = {};

            this._urlError = Boom.boomify(err, { statusCode: 400, override: false });
        }
    }

    setUrl(url, stripTrailingSlash) {

        Hoek.assert(this.params === null, 'Cannot change request URL after routing');

        if (url instanceof Url.URL) {
            url = url.href;
        }

        Hoek.assert(typeof url === 'string', 'Url must be a string or URL object');

        this._setUrl(url, stripTrailingSlash);
        this._urlError = null;
    }

    _setUrl(url, stripTrailingSlash) {

        const base = url[0] === '/' ? `${this._core.info.protocol}://${this.info.host || `${this._core.info.host}:${this._core.info.port}`}` : '';

        url = new Url.URL(base + url);

        // Apply path modifications

        let path = this._core.router.normalize(url.pathname);        // pathname excludes query

        if (stripTrailingSlash &&
            path.length > 1 &&
            path[path.length - 1] === '/') {

            path = path.slice(0, -1);
        }

        url.pathname = path;

        // Parse query (must be done before this.url is set in case query parsing throws)

        this.query = this._parseQuery(url.searchParams);

        // Store request properties

        this.url = url;
        this.path = path;

        this.info.hostname = url.hostname;
        this.info.host = url.host;
    }

    _parseQuery(searchParams) {

        // Flatten map

        let query = Object.create(null);
        for (let [key, value] of searchParams) {
            const entry = query[key];
            if (entry !== undefined) {
                value = [].concat(entry, value);
            }

            query[key] = value;
        }

        // Custom parser

        const parser = this._core.settings.query.parser;
        if (parser) {
            query = parser(query);
            if (!query ||
                typeof query !== 'object') {

                throw Boom.badImplementation('Parsed query must be an object');
            }
        }

        return query;
    }

    setMethod(method) {

        Hoek.assert(this.params === null, 'Cannot change request method after routing');
        Hoek.assert(method && typeof method === 'string', 'Missing method');

        this.method = method.toLowerCase();
    }

    active() {

        return !!this._eventContext.request;
    }

    async _execute() {

        this.info.acceptEncoding = this._core.compression.accept(this);

        try {
            await this._onRequest();
        }
        catch (err) {
            Bounce.rethrow(err, 'system');
            return this._reply(err);
        }

        this._lookup();
        this._setTimeouts();
        await this._lifecycle();
        this._reply();
    }

    async _onRequest() {

        // onRequest (can change request method and url)

        if (this._core.extensions.route.onRequest.nodes) {
            const response = await this._invoke(this._core.extensions.route.onRequest);
            if (response) {
                if (!internals.skip(response)) {
                    throw Boom.badImplementation('onRequest extension methods must return an error, a takeover response, or a continue signal');
                }

                throw response;
            }
        }

        // Validate path

        if (this._urlError) {
            throw this._urlError;
        }
    }

    _listen() {

        if (this._isPayloadPending) {
            this.raw.req.on('end', internals.event.bind(this.raw.req, this._eventContext, 'end'));
        }

        this.raw.req.on('close', internals.event.bind(this.raw.req, this._eventContext, 'close'));
        this.raw.req.on('error', internals.event.bind(this.raw.req, this._eventContext, 'error'));
        this.raw.req.on('aborted', internals.event.bind(this.raw.req, this._eventContext, 'abort'));
    }

    _lookup() {

        const match = this._core.router.route(this.method, this.path, this.info.hostname);
        if (!match.route.settings.isInternal ||
            this._allowInternals) {

            this._route = match.route;
            this.route = this._route.public;
        }

        this.params = match.params || {};
        this.paramsArray = match.paramsArray || [];

        if (this.route.settings.cors) {
            this.info.cors = {
                isOriginMatch: Cors.matchOrigin(this.headers.origin, this.route.settings.cors)
            };
        }
    }

    _setTimeouts() {

        if (this.raw.req.socket &&
            this.route.settings.timeout.socket !== undefined) {

            this.raw.req.socket.setTimeout(this.route.settings.timeout.socket || 0);    // Value can be false or positive
        }

        let serverTimeout = this.route.settings.timeout.server;
        if (!serverTimeout) {
            return;
        }

        const elapsed = Date.now() - this.info.received;
        serverTimeout = Math.floor(serverTimeout - elapsed);            // Calculate the timeout from when the request was constructed

        if (serverTimeout <= 0) {
            internals.timeoutReply(this, serverTimeout);
            return;
        }

        this._serverTimeoutId = setTimeout(internals.timeoutReply, serverTimeout, this, serverTimeout);
    }

    async _lifecycle() {

        for (const func of this._route._cycle) {
            if (this._isReplied ||
                !this._eventContext.request) {

                return;
            }

            try {
                var response = await (typeof func === 'function' ? func(this) : this._invoke(func));
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                response = Response.wrap(err, this);
            }

            if (!response ||
                response === this._core.toolkit.continue) {                     // Continue

                continue;
            }

            if (!internals.skip(response)) {
                response = Boom.badImplementation('Lifecycle methods called before the handler can only return an error, a takeover response, or a continue signal');
            }

            this._setResponse(response);
            return;
        }
    }

    async _invoke(event) {

        for (const ext of event.nodes) {
            const realm = ext.realm;
            const bind = ext.bind || realm.settings.bind;
            const response = await this._core.toolkit.execute(ext.func, this, { bind, realm, timeout: ext.timeout, name: event.type });

            if (response === this._core.toolkit.continue) {
                continue;
            }

            if (internals.skip(response) ||
                this.response === null) {

                return response;
            }

            this._setResponse(response);
        }
    }

    async _reply(exit) {

        if (this._isReplied) {                                          // Prevent any future responses to this request
            return;
        }

        this._isReplied = true;

        if (this._serverTimeoutId) {
            clearTimeout(this._serverTimeoutId);
        }

        if (!this._eventContext.request) {
            this._finalize();
            return;
        }

        if (exit) {                                                     // Can be a valid response or error (if returned from an ext, already handled because this.response is also set)
            this._setResponse(Response.wrap(exit, this));               // Wrap to ensure any object thrown is always a valid Boom or Response object
        }

        if (typeof this.response === 'symbol') {                        // close or abandon
            this._abort();
            return;
        }

        await this._postCycle();

        if (!this._eventContext.request ||
            typeof this.response === 'symbol') {                        // close or abandon

            this._abort();
            return;
        }

        await Transmit.send(this);
        this._finalize();
    }

    async _postCycle() {

        for (const func of this._route._postCycle) {
            if (!this._eventContext.request) {
                return;
            }

            try {
                var response = await (typeof func === 'function' ? func(this) : this._invoke(func));
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                response = Response.wrap(err, this);
            }

            if (response &&
                response !== this._core.toolkit.continue) {                     // Continue

                this._setResponse(response);
            }
        }
    }

    _abort() {

        if (this.response === this._core.toolkit.close) {
            this.raw.res.end();                                     // End the response in case it wasn't already closed
        }

        this._finalize();
    }

    _finalize() {

        if (this.response &&
            this.response.statusCode === 500 &&
            this.response._error) {

            const tags = this.response._error.isDeveloperError ? ['internal', 'implementation', 'error'] : ['internal', 'error'];
            this._log(tags, this.response._error, 'error');
        }

        // Cleanup

        this._eventContext.request = null;              // Disable req events

        if (this.response &&
            this.response._close) {

            this.response._close(this);
        }

        this.info.completed = Date.now();
        this._core.events.emit('response', this);
        this._core.queue.release();
    }

    _setResponse(response) {

        if (this.response &&
            !this.response.isBoom &&
            this.response !== response &&
            (response.isBoom || this.response.source !== response.source)) {

            this.response._close(this);
        }

        if (this.info.completed) {
            if (response._close) {
                response._close(this);
            }

            return;
        }

        this.response = response;
    }

    _setState(name, value, options) {

        const state = { name, value };
        if (options) {
            Hoek.assert(!options.autoValue, 'Cannot set autoValue directly in a response');
            state.options = Hoek.clone(options);
        }

        this._states[name] = state;
    }

    _clearState(name, options = {}) {

        const state = { name };

        state.options = Hoek.clone(options);
        state.options.ttl = 0;

        this._states[name] = state;
    }

    _tap() {

        if (!this._events) {
            return null;
        }

        if (this._events.hasListeners('peek') ||
            this._events.hasListeners('finish')) {

            return new Response.Peek(this._events);
        }

        return null;
    }

    log(tags, data) {

        return this._log(tags, data, 'app');
    }

    _log(tags, data, channel = 'internal') {

        if (!this._core.events.hasListeners('request') &&
            !this.route.settings.log.collect) {

            return;
        }

        if (!Array.isArray(tags)) {
            tags = [tags];
        }

        const timestamp = Date.now();
        const field = data instanceof Error ? 'error' : 'data';

        let event = [this, { request: this.info.id, timestamp, tags, [field]: data, channel }];
        if (typeof data === 'function') {
            event = () => [this, { request: this.info.id, timestamp, tags, data: data(), channel }];
        }

        if (this.route.settings.log.collect) {
            if (typeof data === 'function') {
                event = event();
            }

            this.logs.push(event[1]);
        }

        this._core.events.emit({ name: 'request', channel, tags }, event);
    }

    generateResponse(source, options) {

        return new Response(source, this, options);
    }
};


internals.Request.reserved = internals.reserved;


internals.info = function (core, req) {

    const host = req.headers.host ? req.headers.host.trim() : '';
    const received = Date.now();

    const info = {
        received,
        remoteAddress: req.connection.remoteAddress,
        remotePort: req.connection.remotePort || '',
        referrer: req.headers.referrer || req.headers.referer || '',
        host,
        hostname: host.split(':')[0],
        id: `${received}:${core.info.id}:${core.requestCounter.value++}`,

        // Assigned later

        acceptEncoding: null,
        cors: null,
        responded: 0,
        completed: 0
    };

    if (core.requestCounter.value > core.requestCounter.max) {
        core.requestCounter.value = core.requestCounter.min;
    }

    return info;
};


internals.event = function ({ request }, event, err) {

    if (!request) {
        return;
    }

    request._isPayloadPending = false;

    if (event === 'close' &&
        request.raw.res.finished) {

        return;
    }

    if (event === 'end') {
        return;
    }

    request._log(err ? ['request', 'error'] : ['request', 'error', event], err);

    if (event === 'error') {
        return;
    }

    request._eventContext.request = null;

    if (event === 'abort' &&
        request._events) {

        request._events.emit('disconnect');
    }
};


internals.timeoutReply = function (request, timeout) {

    const elapsed = Date.now() - request.info.received;
    request._log(['request', 'server', 'timeout', 'error'], { timeout, elapsed });
    request._reply(Boom.serverUnavailable());
};


internals.skip = function (response) {

    return response.isBoom || response._takeover || typeof response === 'symbol';
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/response.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/response.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Podium = __webpack_require__(/*! @hapi/podium */ "./node_modules/@hapi/podium/lib/index.js");

const Streams = __webpack_require__(/*! ./streams */ "./node_modules/@hapi/hapi/lib/streams.js");


const internals = {
    events: Podium.validate(['finish', { name: 'peek', spread: true }]),
    hopByHop: {
        connection: true,
        'keep-alive': true,
        'proxy-authenticate': true,
        'proxy-authorization': true,
        'te': true,
        'trailer': true,
        'transfer-encoding': true,
        'upgrade': true
    }
};


exports = module.exports = internals.Response = class {

    constructor(source, request, options = {}) {

        this.app = {};
        this.headers = {};                          // Incomplete as some headers are stored in flags
        this.plugins = {};
        this.request = request;
        this.source = null;
        this.statusCode = null;
        this.variety = null;

        this.settings = {
            charset: 'utf-8',                       // '-' required by IANA
            compressed: null,
            encoding: 'utf8',
            message: null,
            passThrough: true,
            stringify: null,                        // JSON.stringify options
            ttl: null,
            varyEtag: false
        };

        this._events = null;
        this._payload = null;                       // Readable stream
        this._error = null;                         // The boom object when created from an error (used for logging)
        this._contentType = null;                   // Used if no explicit content-type is set and type is known
        this._takeover = false;
        this._statusCode = false;                   // true when code() called

        this._processors = {
            marshal: options.marshal,
            prepare: options.prepare,
            close: options.close
        };

        this.temporary = null;
        this.permanent = null;
        this.rewritable = null;

        this._setSource(source, options.variety);
    }

    static wrap(result, request) {

        if (result instanceof internals.Response ||
            typeof result === 'symbol') {

            return result;
        }

        if (result instanceof Error) {
            return Boom.boomify(result);
        }

        return new internals.Response(result, request);
    }

    _setSource(source, variety) {

        // Method must not set any headers or other properties as source can change later

        this.variety = variety || 'plain';

        if (source === null ||
            source === undefined) {

            source = null;
        }
        else if (Buffer.isBuffer(source)) {
            this.variety = 'buffer';
            this._contentType = 'application/octet-stream';
        }
        else if (Streams.isStream(source)) {
            this.variety = 'stream';
            this._contentType = 'application/octet-stream';
        }

        this.source = source;

        if (this.variety === 'plain' &&
            this.source !== null) {

            this._contentType = (typeof this.source === 'string' ? 'text/html' : 'application/json');
        }
    }

    get events() {

        if (!this._events) {
            this._events = new Podium(internals.events);
        }

        return this._events;
    }

    code(statusCode) {

        Hoek.assert(Number.isSafeInteger(statusCode), 'Status code must be an integer');

        this.statusCode = statusCode;
        this._statusCode = true;

        return this;
    }

    message(httpMessage) {

        this.settings.message = httpMessage;
        return this;
    }

    header(key, value, options) {

        key = key.toLowerCase();
        if (key === 'vary') {
            return this.vary(value);
        }

        return this._header(key, value, options);
    }

    _header(key, value, options = {}) {

        const append = options.append || false;
        const separator = options.separator || ',';
        const override = options.override !== false;
        const duplicate = options.duplicate !== false;

        if (!append && override ||
            !this.headers[key]) {

            this.headers[key] = value;
        }
        else if (override) {
            if (key === 'set-cookie') {
                this.headers[key] = [].concat(this.headers[key], value);
            }
            else {
                const existing = this.headers[key];
                if (!duplicate) {
                    const values = existing.split(separator);
                    for (const v of values) {
                        if (v === value) {
                            return this;
                        }
                    }
                }

                this.headers[key] = existing + separator + value;
            }
        }

        return this;
    }

    vary(value) {

        if (value === '*') {
            this.headers.vary = '*';
        }
        else if (!this.headers.vary) {
            this.headers.vary = value;
        }
        else if (this.headers.vary !== '*') {
            this._header('vary', value, { append: true, duplicate: false });
        }

        return this;
    }

    etag(tag, options) {

        const entity = internals.Response.entity(tag, options);
        this._header('etag', entity.etag);
        this.settings.varyEtag = entity.vary;
        return this;
    }

    static entity(tag, options = {}) {

        Hoek.assert(tag !== '*', 'ETag cannot be *');

        return {
            etag: (options.weak ? 'W/' : '') + '"' + tag + '"',
            vary: options.vary !== false && !options.weak,                      // vary defaults to true
            modified: options.modified
        };
    }

    static unmodified(request, entity) {

        if (request.method !== 'get' &&
            request.method !== 'head') {

            return false;
        }

        // Strong verifier

        if (entity.etag &&
            request.headers['if-none-match']) {

            const ifNoneMatch = request.headers['if-none-match'].split(/\s*,\s*/);
            for (const etag of ifNoneMatch) {

                // Compare tags (https://tools.ietf.org/html/rfc7232#section-2.3.2)

                if (etag === entity.etag) {             // Strong comparison
                    return true;
                }

                if (!entity.vary) {
                    continue;
                }

                if (etag === `W/${entity.etag}`) {      // Weak comparison
                    return etag;
                }

                const etagBase = entity.etag.slice(0, -1);
                const encoders = request._core.compression.encodings;
                for (const encoder of encoders) {
                    if (etag === etagBase + `-${encoder}"`) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Weak verifier

        if (!entity.modified) {
            return false;
        }

        const ifModifiedSinceHeader = request.headers['if-modified-since'];
        if (!ifModifiedSinceHeader) {
            return false;
        }

        const ifModifiedSince = internals.parseDate(ifModifiedSinceHeader);
        if (!ifModifiedSince) {
            return false;
        }

        const lastModified = internals.parseDate(entity.modified);
        if (!lastModified) {
            return false;
        }

        return ifModifiedSince >= lastModified;
    }

    type(type) {

        this._header('content-type', type);
        return this;
    }

    bytes(bytes) {

        this._header('content-length', bytes);
        return this;
    }

    location(uri) {

        this._header('location', uri);
        return this;
    }

    created(location) {

        Hoek.assert(this.request.method === 'post' ||
            this.request.method === 'put' ||
            this.request.method === 'patch', 'Cannot return 201 status codes for ' + this.request.method.toUpperCase());

        this.statusCode = 201;
        this.location(location);
        return this;
    }

    compressed(encoding) {

        Hoek.assert(encoding && typeof encoding === 'string', 'Invalid content-encoding');
        this.settings.compressed = encoding;
        return this;
    }

    replacer(method) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.replacer = method;
        return this;
    }

    spaces(count) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.space = count;
        return this;
    }

    suffix(suffix) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.suffix = suffix;
        return this;
    }

    escape(escape) {

        this.settings.stringify = this.settings.stringify || {};
        this.settings.stringify.escape = escape;
        return this;
    }

    passThrough(enabled) {

        this.settings.passThrough = enabled !== false;      // Defaults to true
        return this;
    }

    redirect(location) {

        this.statusCode = 302;
        this.location(location);
        this.temporary = this._temporary;
        this.permanent = this._permanent;
        this.rewritable = this._rewritable;
        return this;
    }

    _temporary(isTemporary) {

        this._setTemporary(isTemporary !== false);           // Defaults to true
        return this;
    }

    _permanent(isPermanent) {

        this._setTemporary(isPermanent === false);           // Defaults to true
        return this;
    }

    _rewritable(isRewritable) {

        this._setRewritable(isRewritable !== false);         // Defaults to true
        return this;
    }

    _isTemporary() {

        return this.statusCode === 302 || this.statusCode === 307;
    }

    _isRewritable() {

        return this.statusCode === 301 || this.statusCode === 302;
    }

    _setTemporary(isTemporary) {

        if (isTemporary) {
            if (this._isRewritable()) {
                this.statusCode = 302;
            }
            else {
                this.statusCode = 307;
            }
        }
        else {
            if (this._isRewritable()) {
                this.statusCode = 301;
            }
            else {
                this.statusCode = 308;
            }
        }
    }

    _setRewritable(isRewritable) {

        if (isRewritable) {
            if (this._isTemporary()) {
                this.statusCode = 302;
            }
            else {
                this.statusCode = 301;
            }
        }
        else {
            if (this._isTemporary()) {
                this.statusCode = 307;
            }
            else {
                this.statusCode = 308;
            }
        }
    }

    encoding(encoding) {

        this.settings.encoding = encoding;
        return this;
    }

    charset(charset) {

        this.settings.charset = charset || null;
        return this;
    }

    ttl(ttl) {

        this.settings.ttl = ttl;
        return this;
    }

    state(name, value, options) {

        this.request._setState(name, value, options);
        return this;
    }

    unstate(name, options) {

        this.request._clearState(name, options);
        return this;
    }

    takeover() {

        this._takeover = true;
        return this;
    }

    _prepare() {

        this._passThrough();

        if (!this._processors.prepare) {
            return this;
        }

        try {
            return this._processors.prepare(this);
        }
        catch (err) {
            throw Boom.boomify(err);
        }
    }

    _passThrough() {

        if (this.variety === 'stream' &&
            this.settings.passThrough) {

            if (this.source.statusCode &&
                !this.statusCode) {

                this.statusCode = this.source.statusCode;                        // Stream is an HTTP response
            }

            if (this.source.headers) {
                let headerKeys = Object.keys(this.source.headers);

                if (headerKeys.length) {
                    const localHeaders = this.headers;
                    this.headers = {};

                    const connection = this.source.headers.connection;
                    const byHop = {};
                    if (connection) {
                        connection.split(/\s*,\s*/).forEach((header) => {

                            byHop[header] = true;
                        });
                    }

                    for (const key of headerKeys) {
                        const lower = key.toLowerCase();
                        if (!internals.hopByHop[lower] &&
                            !byHop[lower]) {

                            this.header(lower, Hoek.clone(this.source.headers[key]));     // Clone arrays
                        }
                    }

                    headerKeys = Object.keys(localHeaders);
                    for (const key of headerKeys) {
                        this.header(key, localHeaders[key], { append: key === 'set-cookie' });
                    }
                }
            }
        }

        this.statusCode = this.statusCode || 200;
    }

    async _marshal() {

        let source = this.source;

        // Processor marshal

        if (this._processors.marshal) {
            try {
                source = await this._processors.marshal(this);
            }
            catch (err) {
                throw Boom.boomify(err);
            }
        }

        // Stream source

        if (Streams.isStream(source)) {
            if (typeof source._read !== 'function') {
                throw Boom.badImplementation('Stream must have a readable interface');
            }

            if (source._readableState.objectMode) {
                throw Boom.badImplementation('Cannot reply with stream in object mode');
            }

            this._payload = source;
            return;
        }

        // Plain source (non string or null)

        const jsonify = this.variety === 'plain' && source !== null && typeof source !== 'string';

        if (!jsonify &&
            this.settings.stringify) {

            throw Boom.badImplementation('Cannot set formatting options on non object response');
        }

        let payload = source;

        if (jsonify) {
            const options = this.settings.stringify || {};
            const space = options.space || this.request.route.settings.json.space;
            const replacer = options.replacer || this.request.route.settings.json.replacer;
            const suffix = options.suffix || this.request.route.settings.json.suffix || '';
            const escape = this.request.route.settings.json.escape || false;

            try {
                if (replacer || space) {
                    payload = JSON.stringify(payload, replacer, space);
                }
                else {
                    payload = JSON.stringify(payload);
                }
            }
            catch (err) {
                throw Boom.boomify(err);
            }

            if (suffix) {
                payload = payload + suffix;
            }

            if (escape) {
                payload = Hoek.escapeJson(payload);
            }
        }

        this._payload = new internals.Response.Payload(payload, this.settings);
    }

    _tap() {

        if (!this._events) {
            return null;
        }

        if (this._events.hasListeners('peek') ||
            this._events.hasListeners('finish')) {

            return new internals.Response.Peek(this._events);
        }

        return null;
    }

    _close(request) {

        if (this._processors.close) {
            try {
                this._processors.close(this);
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                request._log(['response', 'cleanup', 'error'], err);
            }
        }

        const stream = this._payload || this.source;
        if (Streams.isStream(stream)) {
            internals.Response.drain(stream);
        }
    }

    _isPayloadSupported() {

        return this.request.method !== 'head' && this.statusCode !== 304 && this.statusCode !== 204;
    }

    static drain(stream) {

        if (stream.unpipe) {
            stream.unpipe();
        }

        if (stream.close) {
            stream.close();
        }
        else if (stream.destroy) {
            stream.destroy();
        }
        else {
            Streams.drain(stream);
        }
    }
};


internals.parseDate = function (string) {

    try {
        return Date.parse(string);
    }
    catch (errIgnore) { }
};


internals.Response.Payload = class extends Stream.Readable {

    constructor(payload, options) {

        super();

        this._data = payload;
        this._prefix = null;
        this._suffix = null;
        this._sizeOffset = 0;
        this._encoding = options.encoding;
    }

    _read(size) {

        if (this._prefix) {
            this.push(this._prefix, this._encoding);
        }

        if (this._data) {
            this.push(this._data, this._encoding);
        }

        if (this._suffix) {
            this.push(this._suffix, this._encoding);
        }

        this.push(null);
    }

    size() {

        if (!this._data) {
            return this._sizeOffset;
        }

        return (Buffer.isBuffer(this._data) ? this._data.length : Buffer.byteLength(this._data, this._encoding)) + this._sizeOffset;
    }

    jsonp(variable) {

        this._sizeOffset = this._sizeOffset + variable.length + 7;
        this._prefix = '/**/' + variable + '(';                 // '/**/' prefix prevents CVE-2014-4671 security exploit
        this._data = (this._data === null || Buffer.isBuffer(this._data)) ? this._data : this._data.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
        this._suffix = ');';
    }

    writeToStream(stream) {

        if (this._prefix) {
            stream.write(this._prefix, this._encoding);
        }

        if (this._data) {
            stream.write(this._data, this._encoding);
        }

        if (this._suffix) {
            stream.write(this._suffix, this._encoding);
        }

        stream.end();
    }
};


internals.Response.Peek = class extends Stream.Transform {

    constructor(podium) {

        super();

        this._podium = podium;
        this.on('finish', () => podium.emit('finish'));
    }

    _transform(chunk, encoding, callback) {

        this._podium.emit('peek', [chunk, encoding]);
        this.push(chunk, encoding);
        callback();
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/route.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/route.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! assert */ "assert");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Catbox = __webpack_require__(/*! @hapi/catbox */ "./node_modules/@hapi/catbox/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");
const Subtext = __webpack_require__(/*! @hapi/subtext */ "./node_modules/@hapi/subtext/lib/index.js");

const Auth = __webpack_require__(/*! ./auth */ "./node_modules/@hapi/hapi/lib/auth.js");
const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Ext = __webpack_require__(/*! ./ext */ "./node_modules/@hapi/hapi/lib/ext.js");
const Handler = __webpack_require__(/*! ./handler */ "./node_modules/@hapi/hapi/lib/handler.js");
const Headers = __webpack_require__(/*! ./headers */ "./node_modules/@hapi/hapi/lib/headers.js");
const Security = __webpack_require__(/*! ./security */ "./node_modules/@hapi/hapi/lib/security.js");
const Streams = __webpack_require__(/*! ./streams */ "./node_modules/@hapi/hapi/lib/streams.js");
const Validation = __webpack_require__(/*! ./validation */ "./node_modules/@hapi/hapi/lib/validation.js");


const internals = {};


exports = module.exports = internals.Route = class {

    constructor(route, server, options = {}) {

        const core = server._core;
        const realm = server.realm;

        // Routing information

        Config.apply('route', route, route.method, route.path);

        const method = route.method.toLowerCase();
        Hoek.assert(method !== 'head', 'Cannot set HEAD route:', route.path);

        const path = (realm.modifiers.route.prefix ? realm.modifiers.route.prefix + (route.path !== '/' ? route.path : '') : route.path);
        Hoek.assert(path === '/' || path[path.length - 1] !== '/' || !core.settings.router.stripTrailingSlash, 'Path cannot end with a trailing slash when configured to strip:', route.method, route.path);

        const vhost = (realm.modifiers.route.vhost || route.vhost);

        // Set identifying members (assert)

        this.method = method;
        this.path = path;

        // Prepare configuration

        let config = route.options || route.config || {};
        if (typeof config === 'function') {
            config = config.call(realm.settings.bind, server);
        }

        config = Config.enable(config);     // Shallow clone

        // Verify route level config (as opposed to the merged settings)

        this._assert(method !== 'get' || !config.payload, 'Cannot set payload settings on HEAD or GET request');
        this._assert(method !== 'get' || !config.validate || !config.validate.payload, 'Cannot validate HEAD or GET request payload');

        // Rules

        this._assert(!route.rules || !config.rules, 'Route rules can only appear once');                    // XOR
        const rules = (route.rules || config.rules);
        const rulesConfig = internals.rules(rules, { method, path, vhost }, server);
        delete config.rules;

        // Handler

        this._assert(route.handler || config.handler, 'Missing or undefined handler');
        this._assert(!!route.handler ^ !!config.handler, 'Handler must only appear once');                  // XOR

        const handler = Config.apply('handler', route.handler || config.handler);
        delete config.handler;

        const handlerDefaults = Handler.defaults(method, handler, core);

        // Apply settings in order: server <- handler <- realm <- route

        const settings = internals.config([core.settings.routes, handlerDefaults, realm.settings, rulesConfig, config]);
        this.settings = Config.apply('routeConfig', settings, method, path);

        // Validate timeouts

        const socketTimeout = (this.settings.timeout.socket === undefined ? 2 * 60 * 1000 : this.settings.timeout.socket);
        this._assert(!this.settings.timeout.server || !socketTimeout || this.settings.timeout.server < socketTimeout, 'Server timeout must be shorter than socket timeout');
        this._assert(!this.settings.payload.timeout || !socketTimeout || this.settings.payload.timeout < socketTimeout, 'Payload timeout must be shorter than socket timeout');

        // Route members

        this._core = core;
        this.realm = realm;

        this.settings.vhost = vhost;
        this.settings.plugins = this.settings.plugins || {};            // Route-specific plugins settings, namespaced using plugin name
        this.settings.app = this.settings.app || {};                    // Route-specific application settings

        // Path parsing

        this._special = !!options.special;
        this._analysis = this._core.router.analyze(this.path);
        this.params = this._analysis.params;
        this.fingerprint = this._analysis.fingerprint;

        this.public = {
            method: this.method,
            path: this.path,
            vhost,
            realm,
            settings: this.settings,
            fingerprint: this.fingerprint,
            auth: {
                access: (request) => Auth.testAccess(request, this.public)
            }
        };

        // Validation

        this._setupValidation();

        // Payload parsing

        if (this.method === 'get') {
            this.settings.payload = null;
        }
        else {
            this.settings.payload.decoders = this._core.compression._decoders;        // Reference the shared object to keep up to date
        }

        this._assert(!this.settings.validate.payload || this.settings.payload.parse, 'Route payload must be set to \'parse\' when payload validation enabled');
        this._assert(!this.settings.validate.state || this.settings.state.parse, 'Route state must be set to \'parse\' when state validation enabled');
        this._assert(!this.settings.jsonp || typeof this.settings.jsonp === 'string', 'Bad route JSONP parameter name');

        // Authentication configuration

        this.settings.auth = (this._special ? false : this._core.auth._setupRoute(this.settings.auth, path));

        // Cache

        if (this.method === 'get' &&
            typeof this.settings.cache === 'object' &&
            (this.settings.cache.expiresIn || this.settings.cache.expiresAt)) {

            this.settings.cache._statuses = new Set(this.settings.cache.statuses);
            this._cache = new Catbox.Policy({ expiresIn: this.settings.cache.expiresIn, expiresAt: this.settings.cache.expiresAt });
        }

        // CORS

        this.settings.cors = Cors.route(this.settings.cors);

        // Security

        this.settings.security = Security.route(this.settings.security);

        // Handler

        this.settings.handler = Handler.configure(handler, this);
        this._prerequisites = Handler.prerequisitesConfig(this.settings.pre);

        // Route lifecycle

        this._extensions = {
            onPreResponse: Ext.combine(this, 'onPreResponse')
        };

        if (this._special) {
            this._cycle = [internals.drain, Handler.execute];
            this.rebuild();
            return;
        }

        this._extensions.onPreAuth = Ext.combine(this, 'onPreAuth');
        this._extensions.onCredentials = Ext.combine(this, 'onCredentials');
        this._extensions.onPostAuth = Ext.combine(this, 'onPostAuth');
        this._extensions.onPreHandler = Ext.combine(this, 'onPreHandler');
        this._extensions.onPostHandler = Ext.combine(this, 'onPostHandler');

        this.rebuild();
    }

    _setupValidation() {

        const validation = this.settings.validate;
        if (this.method === 'get') {
            validation.payload = null;
        }

        this._assert(!validation.params || this.params.length, 'Cannot set path parameters validations without path parameters');

        ['headers', 'params', 'query', 'payload', 'state'].forEach((type) => {

            validation[type] = Validation.compile(validation[type]);
        });

        if (this.settings.response.schema !== undefined ||
            this.settings.response.status) {

            this.settings.response._validate = true;

            const rule = this.settings.response.schema;
            this.settings.response.status = this.settings.response.status || {};
            const statuses = Object.keys(this.settings.response.status);

            if (rule === true &&
                !statuses.length) {

                this.settings.response._validate = false;
            }
            else {
                this.settings.response.schema = Validation.compile(rule);
                for (const code of statuses) {
                    this.settings.response.status[code] = Validation.compile(this.settings.response.status[code]);
                }
            }
        }
    }

    rebuild(event) {

        if (event) {
            this._extensions[event.type].add(event);
        }

        if (this._special) {
            this._postCycle = (this._extensions.onPreResponse.nodes ? [this._extensions.onPreResponse] : []);
            this._buildMarshalCycle();
            return;
        }

        // Build lifecycle array

        this._cycle = [];

        // 'onRequest'

        if (this.settings.jsonp) {
            this._cycle.push(internals.parseJSONP);
        }

        if (this.settings.state.parse) {
            this._cycle.push(internals.state);
        }

        if (this._extensions.onPreAuth.nodes) {
            this._cycle.push(this._extensions.onPreAuth);
        }

        if (this._core.auth._enabled(this, 'authenticate')) {
            this._cycle.push(Auth.authenticate);
        }

        if (this.method !== 'get') {
            this._cycle.push(internals.payload);

            if (this._core.auth._enabled(this, 'payload')) {
                this._cycle.push(Auth.payload);
            }
        }

        if (this._core.auth._enabled(this, 'authenticate') &&
            this._extensions.onCredentials.nodes) {

            this._cycle.push(this._extensions.onCredentials);
        }

        if (this._core.auth._enabled(this, 'access')) {
            this._cycle.push(Auth.access);
        }

        if (this._extensions.onPostAuth.nodes) {
            this._cycle.push(this._extensions.onPostAuth);
        }

        if (this.settings.validate.headers) {
            this._cycle.push(Validation.headers);
        }

        if (this.settings.validate.params) {
            this._cycle.push(Validation.params);
        }

        if (this.settings.jsonp) {
            this._cycle.push(internals.cleanupJSONP);
        }

        if (this.settings.validate.query) {
            this._cycle.push(Validation.query);
        }

        if (this.settings.validate.payload) {
            this._cycle.push(Validation.payload);
        }

        if (this.settings.validate.state) {
            this._cycle.push(Validation.state);
        }

        if (this._extensions.onPreHandler.nodes) {
            this._cycle.push(this._extensions.onPreHandler);
        }

        this._cycle.push(Handler.execute);

        if (this._extensions.onPostHandler.nodes) {
            this._cycle.push(this._extensions.onPostHandler);
        }

        this._postCycle = [];

        if (this.settings.response._validate &&
            this.settings.response.sample !== 0) {

            this._postCycle.push(Validation.response);
        }

        if (this._extensions.onPreResponse.nodes) {
            this._postCycle.push(this._extensions.onPreResponse);
        }

        this._buildMarshalCycle();
    }

    _buildMarshalCycle() {

        this._marshalCycle = [Headers.type];

        if (this.settings.cors) {
            this._marshalCycle.push(Cors.headers);
        }

        if (this.settings.security) {
            this._marshalCycle.push(Security.headers);
        }

        this._marshalCycle.push(Headers.entity);

        if (this.method === 'get' ||
            this.method === '*') {

            this._marshalCycle.push(Headers.unmodified);
        }

        this._marshalCycle.push(Headers.cache);
        this._marshalCycle.push(Headers.state);
        this._marshalCycle.push(Headers.content);

        if (this._core.auth._enabled(this, 'response')) {
            this._marshalCycle.push(Auth.response);                            // Must be last in case requires access to headers
        }
    }

    _assert(condition, message) {

        if (condition) {
            return;
        }

        if (this.method[0] !== '_') {
            message = `${message}: ${this.method.toUpperCase()} ${this.path}`;
        }

        throw new Assert.AssertionError({
            message,
            actual: false,
            expected: true,
            operator: '==',
            stackStartFunction: this._assert
        });
    }
};


internals.state = async function (request) {

    request.state = {};

    const req = request.raw.req;
    const cookies = req.headers.cookie;
    if (!cookies) {
        return;
    }

    try {
        var result = await request._core.states.parse(cookies);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        var parseError = err;
    }

    const { states, failed = [] } = result || parseError;
    request.state = states || {};

    // Clear cookies

    for (const item of failed) {
        if (item.settings.clearInvalid) {
            request._clearState(item.name);
        }
    }

    if (!parseError) {
        return;
    }

    parseError.header = cookies;

    return request._core.toolkit.failAction(request, request.route.settings.state.failAction, parseError, { tags: ['state', 'error'] });
};


internals.payload = async function (request) {

    if (request.method === 'get' ||
        request.method === 'head') {            // When route.method is '*'

        return;
    }

    if (request._expectContinue) {
        request.raw.res.writeContinue();
    }

    try {
        const { payload, mime } = await Subtext.parse(request.raw.req, request._tap(), request.route.settings.payload);

        request._isPayloadPending = !!(payload && payload._readableState);
        request.mime = mime;
        request.payload = payload;
    }
    catch (err) {
        Bounce.rethrow(err, 'system');

        if (request._isPayloadPending) {
            await internals.drain(request);
            request._isPayloadPending = false;
        }
        else {
            request._isPayloadPending = true;
        }

        request.mime = err.mime;
        request.payload = null;

        return request._core.toolkit.failAction(request, request.route.settings.payload.failAction, err, { tags: ['payload', 'error'] });
    }
};


internals.drain = async function (request) {

    // Flush out any pending request payload not consumed due to errors

    await Streams.drain(request.raw.req);
    request._isPayloadPending = false;
};


internals.jsonpRegex = /^[\w\$\[\]\.]+$/;


internals.parseJSONP = function (request) {

    const jsonp = request.query[request.route.settings.jsonp];
    if (jsonp) {
        if (internals.jsonpRegex.test(jsonp) === false) {
            throw Boom.badRequest('Invalid JSONP parameter value');
        }

        request.jsonp = jsonp;
    }
};


internals.cleanupJSONP = function (request) {

    if (request.jsonp) {
        delete request.query[request.route.settings.jsonp];
    }
};


internals.config = function (chain) {

    if (!chain.length) {
        return {};
    }

    let config = chain[0];
    for (const item of chain) {
        config = Hoek.applyToDefaults(config, item, { shallow: ['bind', 'validate.headers', 'validate.payload', 'validate.params', 'validate.query', 'validate.state'] });
    }

    return config;
};


internals.rules = function (rules, info, server) {

    const configs = [];

    let realm = server.realm;
    while (realm) {
        if (realm._rules) {
            const source = (!realm._rules.settings.validate ? rules : Joi.attempt(rules, realm._rules.settings.validate.schema, realm._rules.settings.validate.options));
            const config = realm._rules.processor(source, info);
            if (config) {
                configs.unshift(config);
            }
        }

        realm = realm.parent;
    }

    return internals.config(configs);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/security.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/security.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.route = function (settings) {

    if (!settings) {
        return null;
    }

    const security = settings;
    if (security.hsts) {
        if (security.hsts === true) {
            security._hsts = 'max-age=15768000';
        }
        else if (typeof security.hsts === 'number') {
            security._hsts = 'max-age=' + security.hsts;
        }
        else {
            security._hsts = 'max-age=' + (security.hsts.maxAge || 15768000);
            if (security.hsts.includeSubdomains || security.hsts.includeSubDomains) {
                security._hsts = security._hsts + '; includeSubDomains';
            }

            if (security.hsts.preload) {
                security._hsts = security._hsts + '; preload';
            }
        }
    }

    if (security.xframe) {
        if (security.xframe === true) {
            security._xframe = 'DENY';
        }
        else if (typeof security.xframe === 'string') {
            security._xframe = security.xframe.toUpperCase();
        }
        else if (security.xframe.rule === 'allow-from') {
            if (!security.xframe.source) {
                security._xframe = 'SAMEORIGIN';
            }
            else {
                security._xframe = 'ALLOW-FROM ' + security.xframe.source;
            }
        }
        else {
            security._xframe = security.xframe.rule.toUpperCase();
        }
    }

    return security;
};


exports.headers = function (request) {

    const response = request.response;
    const security = response.request.route.settings.security;

    if (security._hsts) {
        response._header('strict-transport-security', security._hsts, { override: false });
    }

    if (security._xframe) {
        response._header('x-frame-options', security._xframe, { override: false });
    }

    if (security.xss) {
        response._header('x-xss-protection', '1; mode=block', { override: false });
    }

    if (security.noOpen) {
        response._header('x-download-options', 'noopen', { override: false });
    }

    if (security.noSniff) {
        response._header('x-content-type-options', 'nosniff', { override: false });
    }

    if (security.referrer !== false) {
        response._header('referrer-policy', security.referrer, { override: false });
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/server.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/server.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");
const Shot = __webpack_require__(/*! @hapi/shot */ "./node_modules/@hapi/shot/lib/index.js");
const Somever = __webpack_require__(/*! @hapi/somever */ "./node_modules/@hapi/somever/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Core = __webpack_require__(/*! ./core */ "./node_modules/@hapi/hapi/lib/core.js");
const Cors = __webpack_require__(/*! ./cors */ "./node_modules/@hapi/hapi/lib/cors.js");
const Ext = __webpack_require__(/*! ./ext */ "./node_modules/@hapi/hapi/lib/ext.js");
const Package = __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/hapi/package.json");
const Request = __webpack_require__(/*! ./request */ "./node_modules/@hapi/hapi/lib/request.js");
const Route = __webpack_require__(/*! ./route */ "./node_modules/@hapi/hapi/lib/route.js");


const internals = {};


exports = module.exports = function (options) {

    const core = new Core(options);
    return new internals.Server(core);
};


internals.Server = class {

    constructor(core, name, parent) {

        this._core = core;

        // Public interface

        this.app = core.app;
        this.auth = Object.create(this._core.auth);
        this.auth.strategy = this.auth._strategy.bind(this.auth, this);
        this.decorations = core.decorations;
        this.cache = internals.cache(this);
        this.events = core.events;
        this.info = core.info;
        this.listener = core.listener;
        this.load = core.heavy.load;
        this.methods = core.methods.methods;
        this.mime = core.mime;
        this.plugins = core.plugins;
        this.registrations = core.registrations;
        this.settings = core.settings;
        this.states = core.states;
        this.type = core.type;
        this.version = Package.version;

        this.realm = {
            _extensions: {
                onPreAuth: new Ext('onPreAuth', core),
                onCredentials: new Ext('onCredentials', core),
                onPostAuth: new Ext('onPostAuth', core),
                onPreHandler: new Ext('onPreHandler', core),
                onPostHandler: new Ext('onPostHandler', core),
                onPreResponse: new Ext('onPreResponse', core)
            },
            modifiers: {
                route: {}
            },
            parent: (parent ? parent.realm : null),
            plugin: name,
            pluginOptions: {},
            plugins: {},
            _rules: null,
            settings: {
                bind: undefined,
                files: {
                    relativeTo: undefined
                }
            }
        };

        // Decorations

        for (const method of core.decorations.server) {
            this[method] = core._decorations.server[method];
        }

        core.registerServer(this);
    }

    _clone(name) {

        return new internals.Server(this._core, name, this);
    }

    bind(context) {

        Hoek.assert(typeof context === 'object', 'bind must be an object');
        this.realm.settings.bind = context;
    }

    control(server) {

        Hoek.assert(server instanceof internals.Server, 'Can only control Server objects');

        this._core.controlled = this._core.controlled || [];
        this._core.controlled.push(server);
    }

    decoder(encoding, decoder) {

        return this._core.compression.addDecoder(encoding, decoder);
    }

    decorate(type, property, method, options = {}) {

        Hoek.assert(this._core.decorations[type], 'Unknown decoration type:', type);
        Hoek.assert(property, 'Missing decoration property name');
        Hoek.assert(typeof property === 'string' || typeof property === 'symbol', 'Decoration property must be a string or a symbol');

        const propertyName = property.toString();
        Hoek.assert(propertyName[0] !== '_', 'Property name cannot begin with an underscore:', propertyName);

        const existing = this._core._decorations[type][property];
        if (options.extend) {
            Hoek.assert(type !== 'handler', 'Cannot extent handler decoration:', propertyName);
            Hoek.assert(existing, `Cannot extend missing ${type} decoration: ${propertyName}`);
            Hoek.assert(typeof method === 'function', `Extended ${type} decoration method must be a function: ${propertyName}`);

            method = method(existing);
        }
        else {
            Hoek.assert(existing === undefined, `${type[0].toUpperCase() + type.slice(1)} decoration already defined: ${propertyName}`);
        }

        if (type === 'handler') {

            // Handler

            Hoek.assert(typeof method === 'function', 'Handler must be a function:', propertyName);
            Hoek.assert(!method.defaults || typeof method.defaults === 'object' || typeof method.defaults === 'function', 'Handler defaults property must be an object or function');
            Hoek.assert(!options.extend, 'Cannot extend handler decoration:', propertyName);
        }
        else if (type === 'request') {

            // Request

            Hoek.assert(Request.reserved.indexOf(property) === -1, 'Cannot override built-in request interface decoration:', propertyName);

            if (options.apply) {
                this._core._decorations.requestApply = this._core._decorations.requestApply || {};
                this._core._decorations.requestApply[property] = method;
            }
            else {
                this._core.Request.prototype[property] = method;
            }
        }
        else if (type === 'toolkit') {

            // Toolkit

            Hoek.assert(this._core.toolkit.reserved.indexOf(property) === -1, 'Cannot override built-in toolkit decoration:', propertyName);
        }
        else {

            // Server

            if (typeof property === 'string') {
                Hoek.assert(Object.getOwnPropertyNames(internals.Server.prototype).indexOf(property) === -1, 'Cannot override the built-in server interface method:', propertyName);
            }
            else {
                Hoek.assert(Object.getOwnPropertySymbols(internals.Server.prototype).indexOf(property) === -1, 'Cannot override the built-in server interface method:', propertyName);
            }

            this._core.instances.forEach((server) => {

                server[property] = method;
            });
        }

        this._core._decorations[type][property] = method;
        this._core.decorations[type].push(property);
    }

    dependency(dependencies, after) {

        Hoek.assert(this.realm.plugin, 'Cannot call dependency() outside of a plugin');
        Hoek.assert(!after || typeof after === 'function', 'Invalid after method');

        // Normalize to { plugin: version }

        if (typeof dependencies === 'string') {
            dependencies = { [dependencies]: '*' };
        }
        else if (Array.isArray(dependencies)) {
            const map = {};
            for (const dependency of dependencies) {
                map[dependency] = '*';
            }

            dependencies = map;
        }

        this._core.dependencies.push({ plugin: this.realm.plugin, deps: dependencies });

        if (after) {
            this.ext('onPreStart', after, { after: Object.keys(dependencies) });
        }
    }

    encoder(encoding, encoder) {

        return this._core.compression.addEncoder(encoding, encoder);
    }

    event(event) {

        this._core.events.registerEvent(event);
    }

    expose(key, value) {

        Hoek.assert(this.realm.plugin, 'Cannot call expose() outside of a plugin');

        const plugin = this.realm.plugin;
        this._core.plugins[plugin] = this._core.plugins[plugin] || {};

        if (typeof key === 'string') {
            this._core.plugins[plugin][key] = value;
        }
        else {
            Hoek.merge(this._core.plugins[plugin], key);
        }
    }

    ext(events, method, options) {        // (event, method, options) -OR- (events)

        if (typeof events === 'string') {
            events = { type: events, method, options };
        }

        events = Config.apply('exts', events);
        for (const event of events) {
            this._ext(event);
        }
    }

    _ext(event) {

        event = Object.assign({}, event);       // Shallow cloned
        event.realm = this.realm;
        const type = event.type;

        if (!this._core.extensions.server[type]) {

            // Realm route extensions

            if (event.options.sandbox === 'plugin') {
                Hoek.assert(this.realm._extensions[type], 'Unknown event type', type);
                return this.realm._extensions[type].add(event);
            }

            // Connection route extensions

            Hoek.assert(this._core.extensions.route[type], 'Unknown event type', type);
            return this._core.extensions.route[type].add(event);
        }

        // Server extensions

        Hoek.assert(!event.options.sandbox, 'Cannot specify sandbox option for server extension');
        Hoek.assert(type !== 'onPreStart' || this._core.phase === 'stopped', 'Cannot add onPreStart (after) extension after the server was initialized');

        event.server = this;
        this._core.extensions.server[type].add(event);
    }

    async inject(options) {

        let settings = options;
        if (typeof settings === 'string') {
            settings = { url: settings };
        }

        if (!settings.authority ||
            settings.auth ||
            settings.app ||
            settings.plugins ||
            settings.allowInternals !== undefined) {        // Can be false

            settings = Object.assign({}, settings);         // options can be reused (shallow cloned)
            delete settings.auth;
            delete settings.app;
            delete settings.plugins;
            delete settings.allowInternals;

            settings.authority = settings.authority || (this._core.info.host + ':' + this._core.info.port);
        }

        Hoek.assert(!options.credentials, 'options.credentials no longer supported (use options.auth)');

        if (options.auth) {
            Hoek.assert(typeof options.auth === 'object', 'options.auth must be an object');
            Hoek.assert(options.auth.credentials, 'options.auth.credentials is missing');
            Hoek.assert(options.auth.strategy, 'options.auth.strategy is missing');
        }

        const needle = this._core._dispatch({
            auth: options.auth,
            allowInternals: options.allowInternals,
            app: options.app,
            plugins: options.plugins
        });

        const res = await Shot.inject(needle, settings);
        const custom = res.raw.res[Config.symbol];
        if (custom) {
            res.result = custom.result;
            res.request = custom.request;
            delete res.raw.res[Config.symbol];
        }

        if (res.result === undefined) {
            res.result = res.payload;
        }

        return res;
    }

    log(tags, data) {

        return this._core.log(tags, data);
    }

    lookup(id) {

        Hoek.assert(id && typeof id === 'string', 'Invalid route id:', id);

        const record = this._core.router.ids[id];
        if (!record) {
            return null;
        }

        return record.route.public;
    }

    match(method, path, host) {

        Hoek.assert(method && typeof method === 'string', 'Invalid method:', method);
        Hoek.assert(path && typeof path === 'string' && path[0] === '/', 'Invalid path:', path);
        Hoek.assert(!host || typeof host === 'string', 'Invalid host:', host);

        const match = this._core.router.route(method.toLowerCase(), path, host);
        Hoek.assert(match !== this._core.router.specials.badRequest, 'Invalid path:', path);
        if (match === this._core.router.specials.notFound) {
            return null;
        }

        return match.route.public;
    }

    method(name, method, options = {}) {

        return this._core.methods.add(name, method, options, this.realm);
    }

    path(relativeTo) {

        Hoek.assert(relativeTo && typeof relativeTo === 'string', 'relativeTo must be a non-empty string');
        this.realm.settings.files.relativeTo = relativeTo;
    }

    async register(plugins, options = {}) {

        if (this.realm.modifiers.route.prefix ||
            this.realm.modifiers.route.vhost) {

            options = Hoek.clone(options);
            options.routes = options.routes || {};

            options.routes.prefix = (this.realm.modifiers.route.prefix || '') + (options.routes.prefix || '') || undefined;
            options.routes.vhost = this.realm.modifiers.route.vhost || options.routes.vhost;
        }

        options = Config.apply('register', options);

        ++this._core.registring;

        try {
            const items = [].concat(plugins);
            for (let item of items) {

                /*
                    { register, ...attributes }
                    { plugin: { register, ...attributes }, options, once, routes }
                    { plugin: { plugin: { register, ...attributes } }, options, once, routes }      // Required module
                */

                if (!item.plugin) {
                    item = {
                        plugin: item
                    };
                }
                else if (!item.plugin.register) {
                    item = {
                        options: item.options,
                        once: item.once,
                        routes: item.routes,
                        plugin: item.plugin.plugin
                    };
                }
                else if (typeof item === 'function') {
                    item = Object.assign({}, item);         // Shallow cloned
                }

                item = Config.apply('plugin', item);

                const name = item.plugin.name || item.plugin.pkg.name;
                const clone = this._clone(name);

                clone.realm.modifiers.route.prefix = item.routes.prefix || options.routes.prefix;
                clone.realm.modifiers.route.vhost = item.routes.vhost || options.routes.vhost;
                clone.realm.pluginOptions = item.options || {};

                // Validate requirements

                const requirements = item.plugin.requirements;
                Hoek.assert(!requirements.node || Somever.match(process.version, requirements.node), 'Plugin', name, 'requires node version', requirements.node, 'but found', process.version);
                Hoek.assert(!requirements.hapi || Somever.match(this.version, requirements.hapi), 'Plugin', name, 'requires hapi version', requirements.hapi, 'but found', this.version);

                // Protect against multiple registrations

                if (this._core.registrations[name]) {
                    if (item.plugin.once ||
                        item.once ||
                        options.once) {

                        continue;
                    }

                    Hoek.assert(item.plugin.multiple, 'Plugin', name, 'already registered');
                }
                else {
                    this._core.registrations[name] = {
                        version: item.plugin.version || item.plugin.pkg.version,
                        name,
                        options: item.options
                    };
                }

                if (item.plugin.dependencies) {
                    clone.dependency(item.plugin.dependencies);
                }

                // Register

                await item.plugin.register(clone, item.options || {});
            }
        }
        catch (err) {
            throw err;
        }
        finally {
            --this._core.registring;
        }
    }

    route(options) {

        Hoek.assert(typeof options === 'object', 'Invalid route options');

        options = [].concat(options);
        for (const config of options) {
            if (Array.isArray(config.method)) {
                for (const method of config.method) {
                    const settings = Object.assign({}, config);     // Shallow cloned
                    settings.method = method;
                    this._addRoute(settings, this);
                }
            }
            else {
                this._addRoute(config, this);
            }
        }
    }

    _addRoute(config, server) {

        const route = new Route(config, server);                        // Do no use config beyond this point, use route members
        const vhosts = [].concat(route.settings.vhost || '*');

        for (const vhost of vhosts) {
            const record = this._core.router.add({ method: route.method, path: route.path, vhost, analysis: route._analysis, id: route.settings.id }, route);
            route.fingerprint = record.fingerprint;
            route.params = record.params;
        }

        this.events.emit('route', route.public);
        Cors.options(route.public, server);
    }

    rules(processor, options = {}) {

        Hoek.assert(!this.realm._rules, 'Server realm rules already defined');

        const settings = Config.apply('rules', options);
        if (settings.validate) {
            const schema = settings.validate.schema;
            settings.validate.schema = Joi.compile(schema);
        }

        this.realm._rules = { processor, settings };
    }

    state(name, options) {

        this.states.add(name, options);
    }

    table(host) {

        return this._core.router.table(host);
    }

    start() {

        return this._core._start();
    }

    initialize() {

        return this._core._initialize();
    }

    stop(options) {

        return this._core._stop(options);
    }
};


internals.cache = (plugin) => {

    const policy = function (options, _segment) {

        return this._core._cachePolicy(options, _segment, plugin.realm);
    };

    policy.provision = async (opts) => {

        const clients = plugin._core._createCache(opts);

        // Start cache

        if (['initialized', 'starting', 'started'].indexOf(plugin._core.phase) !== -1) {
            await Promise.all(clients.map((client) => client.start()));
        }
    };

    return policy;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/streams.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/streams.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Teamwork = __webpack_require__(/*! @hapi/teamwork */ "./node_modules/@hapi/teamwork/lib/index.js");


const internals = {
    team: Symbol('team')
};


exports.isStream = function (stream) {

    return stream &&
        typeof stream === 'object' &&
        typeof stream.pipe === 'function';
};


exports.drain = function (stream) {

    const team = new Teamwork();
    stream[internals.team] = team;

    stream.on('readable', internals.read);
    stream.on('error', internals.end);
    stream.on('end', internals.end);
    stream.on('close', internals.end);

    return team.work;
};


internals.read = function () {

    while (this.read()) { }
};


internals.end = function () {

    this.removeListener('readable', internals.read);
    this.removeListener('error', internals.end);
    this.removeListener('end', internals.end);
    this.removeListener('close', internals.end);

    this[internals.team].attend();
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/toolkit.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/toolkit.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");


const internals = {
    reserved: ['abandon', 'authenticated', 'close', 'context', 'continue', 'entity', 'redirect', 'realm', 'request', 'response', 'state', 'unauthenticated', 'unstate']
};


exports = module.exports = internals.Manager = class {

    constructor() {

        this.abandon = Symbol('abandon');
        this.close = Symbol('close');
        this.continue = Symbol('continue');
        this.reserved = internals.reserved;
    }

    async execute(method, request, options) {

        const h = new internals.Toolkit(request, this, options);
        const bind = options.bind || null;

        try {
            let operation;

            if (bind) {
                operation = method.call(bind, request, h);
            }
            else {
                if (options.args) {
                    operation = method(request, h, ...options.args);
                }
                else {
                    operation = method(request, h);
                }
            }

            var response = await internals.Manager.timed(operation, options);
        }
        catch (err) {
            if (Bounce.isSystem(err)) {
                response = Boom.badImplementation(err);
            }
            else if (!Bounce.isError(err)) {
                response = Boom.badImplementation('Cannot throw non-error object', err);
            }
            else {
                response = Boom.boomify(err);
            }
        }

        // Process response

        if (response === undefined) {
            response = Boom.badImplementation(`${method.name} method did not return a value, a promise, or throw an error`);
        }

        if (options.continue &&
            response === this.continue) {

            if (options.continue === 'undefined') {
                return;
            }

            // 'null'

            response = null;
        }

        if (options.auth &&
            response instanceof internals.Auth) {

            return response;
        }

        if (typeof response !== 'symbol') {
            response = Response.wrap(response, request);
            if (!response.isBoom) {
                response = await response._prepare();
            }
        }

        return response;
    }

    failAction(request, failAction, err, options) {

        const retain = options.retain ? err : undefined;
        if (failAction === 'ignore') {
            return retain;
        }

        if (failAction === 'log') {
            request._log(options.tags, err);
            return retain;
        }

        if (failAction === 'error') {
            throw err;
        }

        return this.execute(failAction, request, { realm: request.route.realm, args: [options.details || err] });
    }

    static timed(method, options) {

        if (!options.timeout) {
            return method;
        }

        const timer = new Promise((resolve, reject) => {

            const handler = () => {

                reject(Boom.internal(`${options.name} timed out`));
            };

            setTimeout(handler, options.timeout);
        });

        return Promise.race([timer, method]);
    }
};


/*
    const handler = function (request, h) {

        result / h.response(result)         -> result                           // Not allowed before handler
        h.response(result).takeover()       -> result (respond)
        h.continue                          -> null                             // Defaults to null only in handler and pre, not allowed in auth

        throw error / h.response(error)     -> error (respond)                  // failAction override in pre
        <undefined>                         -> badImplementation (respond)

        // Auth only (scheme.payload and scheme.response use the same interface as pre-handler extension methods)

        h.unauthenticated(error, data)      -> error (respond) + data
        h.authenticated(data )              -> (continue) + data
    };
*/

internals.Toolkit = class {

    constructor(request, manager, options) {

        this.abandon = manager.abandon;
        this.close = manager.close;
        this.continue = manager.continue;
        this.context = options.bind;
        this.realm = options.realm;
        this.request = request;

        if (options.auth) {
            this.authenticated = internals.authenticated;
            this.unauthenticated = internals.unauthenticated;
        }

        for (const method of request._core.decorations.toolkit) {
            this[method] = request._core._decorations.toolkit[method];
        }
    }

    response(result) {

        Hoek.assert(!result || typeof result !== 'object' || typeof result.then !== 'function', 'Cannot wrap a promise');
        Hoek.assert(result instanceof Error === false, 'Cannot wrap an error');
        Hoek.assert(typeof result !== 'symbol', 'Cannot wrap a symbol');

        return Response.wrap(result, this.request);
    }

    redirect(location) {

        return this.response('').redirect(location);
    }

    entity(options) {

        Hoek.assert(options, 'Entity method missing required options');
        Hoek.assert(options.etag || options.modified, 'Entity methods missing required options key');

        this.request._entity = options;

        const entity = Response.entity(options.etag, options);
        if (Response.unmodified(this.request, entity)) {
            return this.response().code(304).takeover();
        }
    }

    state(name, value, options) {

        this.request._setState(name, value, options);
    }

    unstate(name, options) {

        this.request._clearState(name, options);
    }
};


internals.authenticated = function (data) {

    Hoek.assert(data && data.credentials, 'Authentication data missing credentials information');

    return new internals.Auth(null, data);
};


internals.unauthenticated = function (error, data) {

    Hoek.assert(!data || data.credentials, 'Authentication data missing credentials information');

    return new internals.Auth(error, data);
};


internals.Auth = class {

    constructor(error, data) {

        this.isAuth = true;
        this.error = error;
        this.data = data;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/transmit.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/transmit.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Http = __webpack_require__(/*! http */ "http");

const Ammo = __webpack_require__(/*! @hapi/ammo */ "./node_modules/@hapi/ammo/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Shot = __webpack_require__(/*! @hapi/shot */ "./node_modules/@hapi/shot/lib/index.js");
const Teamwork = __webpack_require__(/*! @hapi/teamwork */ "./node_modules/@hapi/teamwork/lib/index.js");

const Config = __webpack_require__(/*! ./config */ "./node_modules/@hapi/hapi/lib/config.js");
const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/hapi/lib/response.js");


const internals = {};


exports.send = async function (request) {

    const response = request.response;

    try {
        if (response.isBoom) {
            await internals.fail(request, response);
            return;
        }

        await internals.marshal(request);
        await internals.transmit(response);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        request._setResponse(err);
        return internals.fail(request, err);
    }
};


internals.marshal = async function (request) {

    for (const func of request._route._marshalCycle) {
        await func(request);
    }
};


internals.fail = async function (request, boom) {

    const response = internals.error(request, boom);
    request.response = response;                                // Not using request._setResponse() to avoid double log

    try {
        await internals.marshal(request);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');

        // Failed to marshal an error - replace with minimal representation of original error

        const minimal = {
            statusCode: response.statusCode,
            error: Http.STATUS_CODES[response.statusCode],
            message: boom.message
        };

        response._payload = new Response.Payload(JSON.stringify(minimal), {});
    }

    return internals.transmit(response);
};


internals.error = function (request, boom) {

    const error = boom.output;
    const response = new Response(error.payload, request);
    response._error = boom;
    response.code(error.statusCode);
    response.headers = Hoek.clone(error.headers);               // Prevent source from being modified
    return response;
};


internals.transmit = function (response) {

    const request = response.request;
    const length = internals.length(response);

    // Pipes

    const encoding = request._core.compression.encoding(response, length);
    const ranger = encoding ? null : internals.range(response, length);
    const compressor = internals.encoding(response, encoding);

    // Connection: close

    const isInjection = Shot.isInjection(request.raw.req);
    if (!(isInjection || request._core.started) ||
        request._isPayloadPending && !request.raw.req._readableState.ended) {

        response._header('connection', 'close');
    }

    // Write headers

    internals.writeHead(response);

    // Injection

    if (isInjection) {
        request.raw.res[Config.symbol] = { request };

        if (response.variety === 'plain') {
            request.raw.res[Config.symbol].result = response._isPayloadSupported() ? response.source : null;
        }
    }

    // Finalize response stream

    const stream = internals.chain([response._payload, response._tap(), compressor, ranger]);
    return internals.pipe(request, stream);
};


internals.length = function (response) {

    const request = response.request;

    const header = response.headers['content-length'];
    if (header === undefined) {
        return null;
    }

    let length = header;
    if (typeof length === 'string') {
        length = parseInt(header, 10);
        if (!isFinite(length)) {
            delete response.headers['content-length'];
            return null;
        }
    }

    // Empty response

    if (length === 0 &&
        !response._statusCode &&
        response.statusCode === 200 &&
        request.route.settings.response.emptyStatusCode === 204) {

        response.code(204);
        delete response.headers['content-length'];
    }

    return length;
};


internals.range = function (response, length) {

    const request = response.request;

    if (!length ||
        !request.route.settings.response.ranges ||
        request.method !== 'get' ||
        response.statusCode !== 200) {

        return null;
    }

    response._header('accept-ranges', 'bytes');

    if (!request.headers.range) {
        return null;
    }

    // Check If-Range

    if (request.headers['if-range'] &&
        request.headers['if-range'] !== response.headers.etag) {            // Ignoring last-modified date (weak)

        return null;
    }

    // Parse header

    const ranges = Ammo.header(request.headers.range, length);
    if (!ranges) {
        const error = Boom.rangeNotSatisfiable();
        error.output.headers['content-range'] = 'bytes */' + length;
        throw error;
    }

    // Prepare transform

    if (ranges.length !== 1) {                                              // Ignore requests for multiple ranges
        return null;
    }

    const range = ranges[0];
    response.code(206);
    response.bytes(range.to - range.from + 1);
    response._header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);

    return new Ammo.Stream(range);
};


internals.encoding = function (response, encoding) {

    const request = response.request;

    const header = response.headers['content-encoding'] || encoding;
    if (header &&
        response.headers.etag &&
        response.settings.varyEtag) {

        response.headers.etag = response.headers.etag.slice(0, -1) + '-' + header + '"';
    }

    if (!encoding ||
        response.statusCode === 206 ||
        !response._isPayloadSupported()) {

        return null;
    }

    delete response.headers['content-length'];
    response._header('content-encoding', encoding);
    const compressor = request._core.compression.encoder(request, encoding);
    if (response.variety === 'stream' &&
        typeof response._payload.setCompressor === 'function') {

        response._payload.setCompressor(compressor);
    }

    return compressor;
};


internals.pipe = function (request, stream) {

    const team = new Teamwork();

    // Write payload

    const env = { stream, request, team };

    const aborted = internals.end.bind(null, env, 'aborted');
    const close = internals.end.bind(null, env, 'close');
    const end = internals.end.bind(null, env, null);

    request.raw.req.on('aborted', aborted);
    request.raw.req.on('close', close);

    request.raw.res.on('close', close);
    request.raw.res.on('error', end);
    request.raw.res.on('finish', end);

    if (stream.writeToStream) {
        stream.writeToStream(request.raw.res);
    }
    else {
        stream.on('error', end);
        stream.pipe(request.raw.res);
    }

    return team.work;
};


internals.end = function (env, event, err) {

    const { request, stream, team } = env;

    if (!team) {                                                        // Used instead of cleaning up emitter listeners
        return;
    }

    env.team = null;

    if (request.raw.res.finished) {
        if (event !== 'aborted') {
            request.info.responded = Date.now();
        }

        team.attend();
        return;
    }

    if (err) {
        request.raw.res.destroy();
        Response.drain(stream);
    }

    err = err || new Boom(`Request ${event}`, { statusCode: request.route.settings.response.disconnectStatusCode });
    const error = internals.error(request, Boom.boomify(err));
    request._setResponse(error);

    if (request.raw.res[Config.symbol]) {
        request.raw.res.statusCode = error.statusCode;
        request.raw.res[Config.symbol].result = error.source;       // Force injected response to error
    }

    if (event) {
        request._log(['response', 'error', event]);
    }
    else {
        request._log(['response', 'error'], err);
    }

    request.raw.res.end();                                          // Triggers injection promise resolve
    team.attend();
};


internals.writeHead = function (response) {

    const res = response.request.raw.res;
    const headers = Object.keys(response.headers);
    let i = 0;

    try {
        for (; i < headers.length; ++i) {
            const header = headers[i];
            const value = response.headers[header];
            if (value !== undefined) {
                res.setHeader(header, value);
            }
        }
    }
    catch (err) {
        for (--i; i >= 0; --i) {
            res.removeHeader(headers[i]);       // Undo headers
        }

        throw Boom.boomify(err);
    }

    if (response.settings.message) {
        res.statusMessage = response.settings.message;
    }

    try {
        res.writeHead(response.statusCode);
    }
    catch (err) {
        throw Boom.boomify(err);
    }
};


internals.chain = function (sources) {

    let from = sources[0];
    for (let i = 1; i < sources.length; ++i) {
        const to = sources[i];
        if (to) {
            from.on('error', internals.errorPipe.bind(from, to));
            from = from.pipe(to);
        }
    }

    return from;
};


internals.errorPipe = function (to, err) {

    to.emit('error', err);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/lib/validation.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hapi/lib/validation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");


const internals = {};


exports.compile = function (rule) {

    // false - nothing allowed

    if (rule === false) {
        return Joi.object({}).allow(null);
    }

    // Custom function

    if (typeof rule === 'function') {
        return rule;
    }

    // null, undefined, true - anything allowed

    if (!rule ||                            // false tested above
        rule === true) {

        return null;
    }

    // {...} - ... allowed

    if (typeof rule.validate === 'function') {
        return rule;
    }

    return Joi.compile(rule);
};


exports.headers = function (request) {

    return internals.input('headers', request);
};


exports.params = function (request) {

    return internals.input('params', request);
};


exports.payload = function (request) {

    if (request.method === 'get' ||
        request.method === 'head') {                // When route.method is '*'

        return;
    }

    return internals.input('payload', request);
};


exports.query = function (request) {

    return internals.input('query', request);
};


exports.state = function (request) {

    return internals.input('state', request);
};


internals.input = async function (source, request) {

    const localOptions = {
        context: {
            headers: request.headers,
            params: request.params,
            query: request.query,
            payload: request.payload,
            state: request.state,
            auth: request.auth,
            app: {
                route: request.route.settings.app,
                request: request.app
            }
        }
    };

    delete localOptions.context[source];
    Hoek.merge(localOptions, request.route.settings.validate.options);

    try {
        const schema = request.route.settings.validate[source];
        const bind = request.route.settings.bind;

        var value = await (typeof schema !== 'function' ? internals.validate(request[source], schema, localOptions) : schema.call(bind, request[source], localOptions));
        return;
    }
    catch (err) {
        var validationError = err;
    }
    finally {
        request.orig[source] = request[source];
        if (value !== undefined) {
            request[source] = value;
        }
    }

    if (request.route.settings.validate.failAction === 'ignore') {
        return;
    }

    // Prepare error

    const defaultError = validationError.isBoom ? validationError : Boom.badRequest(`Invalid request ${source} input`);
    const detailedError = Boom.boomify(validationError, { statusCode: 400, override: false });
    detailedError.output.payload.validation = { source, keys: [] };
    if (validationError.details) {
        for (const details of validationError.details) {
            const path = details.path;
            detailedError.output.payload.validation.keys.push(Hoek.escapeHtml(path.join('.')));
        }
    }

    if (request.route.settings.validate.errorFields) {
        for (const field in request.route.settings.validate.errorFields) {
            detailedError.output.payload[field] = request.route.settings.validate.errorFields[field];
        }
    }

    return request._core.toolkit.failAction(request, request.route.settings.validate.failAction, defaultError, { details: detailedError, tags: ['validation', 'error', source] });
};


exports.response = async function (request) {

    if (request.route.settings.response.sample) {
        const currentSample = Math.ceil((Math.random() * 100));
        if (currentSample > request.route.settings.response.sample) {
            return;
        }
    }

    const response = request.response;
    const statusCode = response.isBoom ? response.output.statusCode : response.statusCode;

    const statusSchema = request.route.settings.response.status[statusCode];
    if (statusCode >= 400 &&
        !statusSchema) {

        return;                 // Do not validate errors by default
    }

    const schema = statusSchema !== undefined ? statusSchema : request.route.settings.response.schema;
    if (schema === null) {
        return;                 // No rules
    }

    if (!response.isBoom &&
        request.response.variety !== 'plain') {

        throw Boom.badImplementation('Cannot validate non-object response');
    }

    const localOptions = {
        context: {
            headers: request.headers,
            params: request.params,
            query: request.query,
            payload: request.payload,
            state: request.state,
            auth: request.auth,
            app: {
                route: request.route.settings.app,
                request: request.app
            }
        }
    };

    const source = response.isBoom ? response.output.payload : response.source;
    Hoek.merge(localOptions, request.route.settings.response.options);

    try {
        let value;

        if (typeof schema !== 'function') {
            value = await internals.validate(source, schema, localOptions);
        }
        else {
            value = await schema(source, localOptions);
        }

        if (value !== undefined &&
            request.route.settings.response.modify) {

            if (response.isBoom) {
                response.output.payload = value;
            }
            else {
                response.source = value;
            }
        }
    }
    catch (err) {

        return request._core.toolkit.failAction(request, request.route.settings.response.failAction, err, { tags: ['validation', 'response', 'error'] });
    }
};


internals.validate = function (value, schema, options) {

    if (typeof schema.validateAsync === 'function') {
        return schema.validateAsync(value, options);
    }

    return schema.validate(value, options);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js":
/*!********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


exports.schema = function (Joi, config) {

    if (config !== undefined && config !== null && typeof config === 'object') {

        if (config.isJoi) {
            return config;
        }

        if (Array.isArray(config)) {
            return Joi.alternatives().try(config);
        }

        if (config instanceof RegExp) {
            return Joi.string().regex(config);
        }

        if (config instanceof Date) {
            return Joi.date().valid(config);
        }

        return Joi.object().keys(config);
    }

    if (typeof config === 'string') {
        return Joi.string().valid(config);
    }

    if (typeof config === 'number') {
        return Joi.number().valid(config);
    }

    if (typeof config === 'boolean') {
        return Joi.boolean().valid(config);
    }

    if (Ref.isRef(config)) {
        return Joi.valid(config);
    }

    Hoek.assert(config === null, 'Invalid schema content:', config);

    return Joi.valid(null);
};


exports.ref = function (id) {

    return Ref.isRef(id) ? id : Ref.create(id);
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Language = __webpack_require__(/*! ./language */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/language.js");


const internals = {
    annotations: Symbol('joi-annotations')
};


internals.stringify = function (value, wrapArrays) {

    const type = typeof value;

    if (value === null) {
        return 'null';
    }

    if (type === 'string') {
        return value;
    }

    if (value instanceof exports.Err || type === 'function' || type === 'symbol') {
        return value.toString();
    }

    if (type === 'object') {
        if (Array.isArray(value)) {
            let partial = '';

            for (let i = 0; i < value.length; ++i) {
                partial = partial + (partial.length ? ', ' : '') + internals.stringify(value[i], wrapArrays);
            }

            return wrapArrays ? '[' + partial + ']' : partial;
        }

        return value.toString();
    }

    return JSON.stringify(value);
};


exports.Err = class {

    constructor(type, context, state, options, flags, message, template) {

        this.isJoi = true;
        this.type = type;
        this.context = context || {};
        this.context.key = state.path[state.path.length - 1];
        this.context.label = state.key;
        this.path = state.path;
        this.options = options;
        this.flags = flags;
        this.message = message;
        this.template = template;

        const localized = this.options.language;

        if (this.flags.label) {
            this.context.label = this.flags.label;
        }
        else if (localized &&                   // language can be null for arrays exclusion check
            (this.context.label === '' ||
            this.context.label === null)) {
            this.context.label = localized.root || Language.errors.root;
        }
    }

    toString() {

        if (this.message) {
            return this.message;
        }

        let format;

        if (this.template) {
            format = this.template;
        }

        const localized = this.options.language;

        format = format || Hoek.reach(localized, this.type) || Hoek.reach(Language.errors, this.type);

        if (format === undefined) {
            return `Error code "${this.type}" is not defined, your custom type is missing the correct language definition`;
        }

        let wrapArrays = Hoek.reach(localized, 'messages.wrapArrays');
        if (typeof wrapArrays !== 'boolean') {
            wrapArrays = Language.errors.messages.wrapArrays;
        }

        if (format === null) {
            const childrenString = internals.stringify(this.context.reason, wrapArrays);
            if (wrapArrays) {
                return childrenString.slice(1, -1);
            }

            return childrenString;
        }

        const hasKey = /{{!?label}}/.test(format);
        const skipKey = format.length > 2 && format[0] === '!' && format[1] === '!';

        if (skipKey) {
            format = format.slice(2);
        }

        if (!hasKey && !skipKey) {
            const localizedKey = Hoek.reach(localized, 'key');
            if (typeof localizedKey === 'string') {
                format = localizedKey + format;
            }
            else {
                format = Hoek.reach(Language.errors, 'key') + format;
            }
        }

        const message =  format.replace(/{{(!?)([^}]+)}}/g, ($0, isSecure, name) => {

            const value = Hoek.reach(this.context, name);
            const normalized = internals.stringify(value, wrapArrays);
            return (isSecure && this.options.escapeHtml ? Hoek.escapeHtml(normalized) : normalized);
        });

        this.toString = () => message;  // Persist result of last toString call, it won't change

        return message;
    }

};


exports.create = function (type, context, state, options, flags, message, template) {

    return new exports.Err(type, context, state, options, flags, message, template);
};


exports.process = function (errors, object) {

    if (!errors) {
        return null;
    }

    // Construct error

    let message = '';
    const details = [];

    const processErrors = function (localErrors, parent, overrideMessage) {

        for (let i = 0; i < localErrors.length; ++i) {
            const item = localErrors[i];

            if (item instanceof Error) {
                return item;
            }

            if (item.flags.error && typeof item.flags.error !== 'function') {
                if (!item.flags.selfError || !item.context.reason) {
                    return item.flags.error;
                }
            }

            let itemMessage;
            if (parent === undefined) {
                itemMessage = item.toString();
                message = message + (message ? '. ' : '') + itemMessage;
            }

            // Do not push intermediate errors, we're only interested in leafs

            if (item.context.reason) {
                const override = processErrors(item.context.reason, item.path, item.type === 'override' ? item.message : null);
                if (override) {
                    return override;
                }
            }
            else {
                details.push({
                    message: overrideMessage || itemMessage || item.toString(),
                    path: item.path,
                    type: item.type,
                    context: item.context
                });
            }
        }
    };

    const override = processErrors(errors);
    if (override) {
        return override;
    }

    const error = new Error(message);
    error.isJoi = true;
    error.name = 'ValidationError';
    error.details = details;
    error._object = object;
    error.annotate = internals.annotate;
    return error;
};


// Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {

    return JSON.stringify(obj, internals.serializer(), spaces);
};


internals.serializer = function () {

    const keys = [];
    const stack = [];

    const cycleReplacer = (key, value) => {

        if (stack[0] === value) {
            return '[Circular ~]';
        }

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };

    return function (key, value) {

        if (stack.length > 0) {
            const thisPos = stack.indexOf(this);
            if (~thisPos) {
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            }
            else {
                stack.push(this);
                keys.push(key);
            }

            if (~stack.indexOf(value)) {
                value = cycleReplacer.call(this, key, value);
            }
        }
        else {
            stack.push(value);
        }

        if (value) {
            const annotations = value[internals.annotations];
            if (annotations) {
                if (Array.isArray(value)) {
                    const annotated = [];

                    for (let i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
                        }

                        annotated.push(value[i]);
                    }

                    value = annotated;
                }
                else {
                    const errorKeys = Object.keys(annotations.errors);
                    for (let i = 0; i < errorKeys.length; ++i) {
                        const errorKey = errorKeys[i];
                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
                        value[errorKey] = undefined;
                    }

                    const missingKeys = Object.keys(annotations.missing);
                    for (let i = 0; i < missingKeys.length; ++i) {
                        const missingKey = missingKeys[i];
                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
                    }
                }

                return value;
            }
        }

        if (value === Infinity || value === -Infinity || Number.isNaN(value) ||
            typeof value === 'function' || typeof value === 'symbol') {
            return '[' + value.toString() + ']';
        }

        return value;
    };
};


internals.annotate = function (stripColorCodes) {

    const redFgEscape = stripColorCodes ? '' : '\u001b[31m';
    const redBgEscape = stripColorCodes ? '' : '\u001b[41m';
    const endColor = stripColorCodes ? '' : '\u001b[0m';

    if (typeof this._object !== 'object') {
        return this.details[0].message;
    }

    const obj = Hoek.clone(this._object || {});

    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first
        const pos = i + 1;
        const error = this.details[i];
        const path = error.path;
        let ref = obj;
        for (let j = 0; ; ++j) {
            const seg = path[j];

            if (ref.isImmutable) {
                ref = ref.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step
            }

            if (j + 1 < path.length &&
                ref[seg] &&
                typeof ref[seg] !== 'string') {

                ref = ref[seg];
            }
            else {
                const refAnnotations = ref[internals.annotations] = ref[internals.annotations] || { errors: {}, missing: {} };
                const value = ref[seg];
                const cacheKey = seg || error.context.label;

                if (value !== undefined) {
                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                    refAnnotations.errors[cacheKey].push(pos);
                }
                else {
                    refAnnotations.missing[cacheKey] = pos;
                }

                break;
            }
        }
    }

    const replacers = {
        key: /_\$key\$_([, \d]+)_\$end\$_"/g,
        missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
        arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
        specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
    };

    let message = internals.safeStringify(obj, 2)
        .replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)
        .replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`)
        .replace(replacers.specials, ($0, $1) => $1);

    message = `${message}\n${redFgEscape}`;

    for (let i = 0; i < this.details.length; ++i) {
        const pos = i + 1;
        message = `${message}\n[${pos}] ${this.details[i].message}`;
    }

    message = message + endColor;

    return message;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ./types/any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ./cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js");
const Lazy = __webpack_require__(/*! ./types/lazy */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/lazy/index.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {
    alternatives: __webpack_require__(/*! ./types/alternatives */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js"),
    array: __webpack_require__(/*! ./types/array */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/array/index.js"),
    boolean: __webpack_require__(/*! ./types/boolean */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/boolean/index.js"),
    binary: __webpack_require__(/*! ./types/binary */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/binary/index.js"),
    date: __webpack_require__(/*! ./types/date */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js"),
    func: __webpack_require__(/*! ./types/func */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/func/index.js"),
    number: __webpack_require__(/*! ./types/number */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/number/index.js"),
    object: __webpack_require__(/*! ./types/object */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js"),
    string: __webpack_require__(/*! ./types/string */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/index.js"),
    symbol: __webpack_require__(/*! ./types/symbol */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbol/index.js")
};


internals.callWithDefaults = function (schema, args) {

    Hoek.assert(this, 'Must be invoked on a Joi instance.');

    if (this._defaults) {
        schema = this._defaults(schema);
    }

    schema._currentJoi = this;

    return schema._init(...args);
};


internals.root = function () {

    const any = new Any();

    const root = any.clone();
    Any.prototype._currentJoi = root;
    root._currentJoi = root;
    root._binds = new Set(['any', 'alternatives', 'alt', 'array', 'bool', 'boolean', 'binary', 'date', 'func', 'number', 'object', 'string', 'symbol', 'validate', 'describe', 'compile', 'assert', 'attempt', 'lazy', 'defaults', 'extend', 'allow', 'valid', 'only', 'equal', 'invalid', 'disallow', 'not', 'required', 'exist', 'optional', 'forbidden', 'strip', 'when', 'empty', 'default']);

    root.any = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');

        return internals.callWithDefaults.call(this, any, args);
    };

    root.alternatives = root.alt = function (...args) {

        return internals.callWithDefaults.call(this, internals.alternatives, args);
    };

    root.array = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.array, args);
    };

    root.boolean = root.bool = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.boolean, args);
    };

    root.binary = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.binary, args);
    };

    root.date = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.date, args);
    };

    root.func = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.func, args);
    };

    root.number = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.number, args);
    };

    root.object = function (...args) {

        return internals.callWithDefaults.call(this, internals.object, args);
    };

    root.string = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.string, args);
    };

    root.symbol = function (...args) {

        Hoek.assert(args.length === 0, 'Joi.symbol() does not allow arguments.');

        return internals.callWithDefaults.call(this, internals.symbol, args);
    };

    root.ref = function (...args) {

        return Ref.create(...args);
    };

    root.isRef = function (ref) {

        return Ref.isRef(ref);
    };

    root.validate = function (value, ...args /*, [schema], [options], callback */) {

        const last = args[args.length - 1];
        const callback = typeof last === 'function' ? last : null;

        const count = args.length - (callback ? 1 : 0);
        if (count === 0) {
            return any.validate(value, callback);
        }

        const options = count === 2 ? args[1] : undefined;
        const schema = this.compile(args[0]);

        return schema._validateWithOptions(value, options, callback);
    };

    root.describe = function (...args) {

        const schema = args.length ? this.compile(args[0]) : any;
        return schema.describe();
    };

    root.compile = function (schema) {

        try {
            return Cast.schema(this, schema);
        }
        catch (err) {
            if (err.hasOwnProperty('path')) {
                err.message = err.message + '(' + err.path + ')';
            }

            throw err;
        }
    };

    root.assert = function (value, schema, message) {

        this.attempt(value, schema, message);
    };

    root.attempt = function (value, schema, message) {

        const result = this.validate(value, schema);
        const error = result.error;
        if (error) {
            if (!message) {
                if (typeof error.annotate === 'function') {
                    error.message = error.annotate();
                }

                throw error;
            }

            if (!(message instanceof Error)) {
                if (typeof error.annotate === 'function') {
                    error.message = `${message} ${error.annotate()}`;
                }

                throw error;
            }

            throw message;
        }

        return result.value;
    };

    root.reach = function (schema, path) {

        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');
        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');

        const reach = (sourceSchema, schemaPath) => {

            if (!schemaPath.length) {
                return sourceSchema;
            }

            const children = sourceSchema._inner.children;
            if (!children) {
                return;
            }

            const key = schemaPath.shift();
            for (let i = 0; i < children.length; ++i) {
                const child = children[i];
                if (child.key === key) {
                    return reach(child.schema, schemaPath);
                }
            }
        };

        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();

        return reach(schema, schemaPath);
    };

    root.lazy = function (...args) {

        return internals.callWithDefaults.call(this, Lazy, args);
    };

    root.defaults = function (fn) {

        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');

        let joi = Object.create(this.any());
        joi = fn(joi);

        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');

        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults

        joi._defaults = (schema) => {

            if (this._defaults) {
                schema = this._defaults(schema);
                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');
            }

            schema = fn(schema);
            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');
            return schema;
        };

        return joi;
    };

    root.bind = function () {

        const joi = Object.create(this);

        joi._binds.forEach((bind) => {

            joi[bind] = joi[bind].bind(joi);
        });

        return joi;
    };

    root.extend = function (...args) {

        const extensions = Hoek.flatten(args);
        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');

        this.assert(extensions, root.extensionsSchema);

        const joi = Object.create(this.any());
        Object.assign(joi, this);
        joi._currentJoi = joi;
        joi._binds = new Set(joi._binds);

        for (let i = 0; i < extensions.length; ++i) {
            let extension = extensions[i];

            if (typeof extension === 'function') {
                extension = extension(joi);
            }

            this.assert(extension, root.extensionSchema);

            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards
            const ctor = base.constructor;
            const type = class extends ctor { // eslint-disable-line no-loop-func

                constructor() {

                    super();
                    if (extension.base) {
                        Object.assign(this, base);
                    }

                    this._type = extension.name;
                }

            };

            if (extension.language) {
                const lang = {
                    [extension.name]: extension.language
                };
                type.prototype._language = Hoek.applyToDefaults(type.prototype._language || (base._settings && base._settings.language) || {}, lang);
            }


            if (extension.coerce) {
                type.prototype._coerce = function (value, state, options) {

                    if (ctor.prototype._coerce) {
                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);

                        if (baseRet.errors) {
                            return baseRet;
                        }

                        value = baseRet.value;
                    }

                    const ret = extension.coerce.call(this, value, state, options);
                    if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                    }

                    return { value: ret };
                };
            }

            if (extension.pre) {
                type.prototype._base = function (value, state, options) {

                    if (ctor.prototype._base) {
                        const baseRet = ctor.prototype._base.call(this, value, state, options);

                        if (baseRet.errors) {
                            return baseRet;
                        }

                        value = baseRet.value;
                    }

                    const ret = extension.pre.call(this, value, state, options);
                    if (ret instanceof Errors.Err) {
                        return { value, errors: ret };
                    }

                    return { value: ret };
                };
            }

            if (extension.rules) {
                for (let j = 0; j < extension.rules.length; ++j) {
                    const rule = extension.rules[j];
                    const ruleArgs = rule.params ?
                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :
                        [];
                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;

                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func

                        if (rArgs.length > ruleArgs.length) {
                            throw new Error('Unexpected number of arguments');
                        }

                        let hasRef = false;
                        let arg = {};

                        for (let k = 0; k < ruleArgs.length; ++k) {
                            arg[ruleArgs[k]] = rArgs[k];
                            if (!hasRef && Ref.isRef(rArgs[k])) {
                                hasRef = true;
                            }
                        }

                        if (validateArgs) {
                            arg = joi.attempt(arg, validateArgs);
                        }

                        let schema;
                        if (rule.validate && !rule.setup) {
                            const validate = function (value, state, options) {

                                return rule.validate.call(this, arg, value, state, options);
                            };

                            schema = this._test(rule.name, arg, validate, {
                                description: rule.description,
                                hasRef
                            });
                        }
                        else {
                            schema = this.clone();
                        }

                        if (rule.setup) {
                            const newSchema = rule.setup.call(schema, arg);
                            if (newSchema !== undefined) {
                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);
                                schema = newSchema;
                            }

                            if (rule.validate) {
                                const validate = function (value, state, options) {

                                    return rule.validate.call(this, arg, value, state, options);
                                };

                                schema = schema._test(rule.name, arg, validate, {
                                    description: rule.description,
                                    hasRef
                                });
                            }
                        }

                        return schema;
                    };
                }
            }

            if (extension.describe) {
                type.prototype.describe = function () {

                    const description = ctor.prototype.describe.call(this);
                    return extension.describe.call(this, description);
                };
            }

            const instance = new type();
            joi[extension.name] = function (...extArgs) {

                return internals.callWithDefaults.call(this, instance, extArgs);
            };

            joi._binds.add(extension.name);
        }

        return joi;
    };

    root.extensionSchema = internals.object.keys({
        base: internals.object.type(Any, 'Joi object'),
        name: internals.string.required(),
        coerce: internals.func.arity(3),
        pre: internals.func.arity(3),
        language: internals.object,
        describe: internals.func.arity(1),
        rules: internals.array.items(internals.object.keys({
            name: internals.string.required(),
            setup: internals.func.arity(1),
            validate: internals.func.arity(4),
            params: [
                internals.object.pattern(/.*/, internals.object.type(Any, 'Joi object')),
                internals.object.type(internals.object.constructor, 'Joi object')
            ],
            description: [internals.string, internals.func.arity(1)]
        }).or('setup', 'validate'))
    }).strict();

    root.extensionsSchema = internals.array.items([internals.object, internals.func.arity(1)]).strict();

    root.version = __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json").version;

    return root;
};


module.exports = internals.root();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/language.js":
/*!************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/language.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.errors = {
    root: 'value',
    key: '"{{!label}}" ',
    messages: {
        wrapArrays: true
    },
    any: {
        unknown: 'is not allowed',
        invalid: 'contains an invalid value',
        empty: 'is not allowed to be empty',
        required: 'is required',
        allowOnly: 'must be one of {{valids}}',
        default: 'threw an error when running default method'
    },
    alternatives: {
        base: 'not matching any of the allowed alternatives',
        child: null
    },
    array: {
        base: 'must be an array',
        includes: 'at position {{pos}} does not match any of the allowed types',
        includesSingle: 'single value of "{{!label}}" does not match any of the allowed types',
        includesOne: 'at position {{pos}} fails because {{reason}}',
        includesOneSingle: 'single value of "{{!label}}" fails because {{reason}}',
        includesRequiredUnknowns: 'does not contain {{unknownMisses}} required value(s)',
        includesRequiredKnowns: 'does not contain {{knownMisses}}',
        includesRequiredBoth: 'does not contain {{knownMisses}} and {{unknownMisses}} other required value(s)',
        excludes: 'at position {{pos}} contains an excluded value',
        excludesSingle: 'single value of "{{!label}}" contains an excluded value',
        hasKnown: 'does not contain at least one required match for type "{{!patternLabel}}"',
        hasUnknown: 'does not contain at least one required match',
        min: 'must contain at least {{limit}} items',
        max: 'must contain less than or equal to {{limit}} items',
        length: 'must contain {{limit}} items',
        ordered: 'at position {{pos}} fails because {{reason}}',
        orderedLength: 'at position {{pos}} fails because array must contain at most {{limit}} items',
        ref: 'references "{{ref}}" which is not a positive integer',
        sparse: 'must not be a sparse array',
        unique: 'position {{pos}} contains a duplicate value'
    },
    boolean: {
        base: 'must be a boolean'
    },
    binary: {
        base: 'must be a buffer or a string',
        min: 'must be at least {{limit}} bytes',
        max: 'must be less than or equal to {{limit}} bytes',
        length: 'must be {{limit}} bytes'
    },
    date: {
        base: 'must be a number of milliseconds or valid date string',
        strict: 'must be a valid date',
        min: 'must be larger than or equal to "{{limit}}"',
        max: 'must be less than or equal to "{{limit}}"',
        less: 'must be less than "{{limit}}"',
        greater: 'must be greater than "{{limit}}"',
        isoDate: 'must be a valid ISO 8601 date',
        timestamp: {
            javascript: 'must be a valid timestamp or number of milliseconds',
            unix: 'must be a valid timestamp or number of seconds'
        },
        ref: 'references "{{ref}}" which is not a date'
    },
    function: {
        base: 'must be a Function',
        arity: 'must have an arity of {{n}}',
        minArity: 'must have an arity greater or equal to {{n}}',
        maxArity: 'must have an arity lesser or equal to {{n}}',
        ref: 'must be a Joi reference',
        class: 'must be a class'
    },
    lazy: {
        base: '!!schema error: lazy schema must be set',
        schema: '!!schema error: lazy schema function must return a schema'
    },
    object: {
        base: 'must be an object',
        child: '!!child "{{!child}}" fails because {{reason}}',
        min: 'must have at least {{limit}} children',
        max: 'must have less than or equal to {{limit}} children',
        length: 'must have {{limit}} children',
        allowUnknown: '!!"{{!child}}" is not allowed',
        with: '!!"{{mainWithLabel}}" missing required peer "{{peerWithLabel}}"',
        without: '!!"{{mainWithLabel}}" conflict with forbidden peer "{{peerWithLabel}}"',
        missing: 'must contain at least one of {{peersWithLabels}}',
        xor: 'contains a conflict between exclusive peers {{peersWithLabels}}',
        oxor: 'contains a conflict between optional exclusive peers {{peersWithLabels}}',
        and: 'contains {{presentWithLabels}} without its required peers {{missingWithLabels}}',
        nand: '!!"{{mainWithLabel}}" must not exist simultaneously with {{peersWithLabels}}',
        assert: '!!"{{ref}}" validation failed because "{{ref}}" failed to {{message}}',
        rename: {
            multiple: 'cannot rename child "{{from}}" because multiple renames are disabled and another key was already renamed to "{{to}}"',
            override: 'cannot rename child "{{from}}" because override is disabled and target "{{to}}" exists',
            regex: {
                multiple: 'cannot rename children {{from}} because multiple renames are disabled and another key was already renamed to "{{to}}"',
                override: 'cannot rename children {{from}} because override is disabled and target "{{to}}" exists'
            }
        },
        type: 'must be an instance of "{{type}}"',
        schema: 'must be a Joi instance'
    },
    number: {
        base: 'must be a number',
        unsafe: 'must be a safe number',
        min: 'must be larger than or equal to {{limit}}',
        max: 'must be less than or equal to {{limit}}',
        less: 'must be less than {{limit}}',
        greater: 'must be greater than {{limit}}',
        integer: 'must be an integer',
        negative: 'must be a negative number',
        positive: 'must be a positive number',
        precision: 'must have no more than {{limit}} decimal places',
        ref: 'references "{{ref}}" which is not a number',
        multiple: 'must be a multiple of {{multiple}}',
        port: 'must be a valid port'
    },
    string: {
        base: 'must be a string',
        min: 'length must be at least {{limit}} characters long',
        max: 'length must be less than or equal to {{limit}} characters long',
        length: 'length must be {{limit}} characters long',
        alphanum: 'must only contain alpha-numeric characters',
        token: 'must only contain alpha-numeric and underscore characters',
        regex: {
            base: 'with value "{{!value}}" fails to match the required pattern: {{pattern}}',
            name: 'with value "{{!value}}" fails to match the {{name}} pattern',
            invert: {
                base: 'with value "{{!value}}" matches the inverted pattern: {{pattern}}',
                name: 'with value "{{!value}}" matches the inverted {{name}} pattern'
            }
        },
        email: 'must be a valid email',
        uri: 'must be a valid uri',
        uriRelativeOnly: 'must be a valid relative uri',
        uriCustomScheme: 'must be a valid uri with a scheme matching the {{scheme}} pattern',
        isoDate: 'must be a valid ISO 8601 date',
        guid: 'must be a valid GUID',
        hex: 'must only contain hexadecimal characters',
        hexAlign: 'hex decoded representation must be byte aligned',
        base64: 'must be a valid base64 string',
        dataUri: 'must be a valid dataUri string',
        hostname: 'must be a valid hostname',
        normalize: 'must be unicode normalized in the {{form}} form',
        lowercase: 'must only contain lowercase characters',
        uppercase: 'must only contain uppercase characters',
        trim: 'must not have leading or trailing whitespace',
        creditCard: 'must be a credit card',
        ref: 'references "{{ref}}" which is not a number',
        ip: 'must be a valid ip address with a {{cidr}} CIDR',
        ipVersion: 'must be a valid ip address of one of the following versions {{version}} with a {{cidr}} CIDR'
    },
    symbol: {
        base: 'must be a symbol',
        map: 'must be one of {{map}}'
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports.create = function (key, options) {

    Hoek.assert(typeof key === 'string', 'Invalid reference key:', key);

    const settings = Hoek.clone(options);         // options can be reused and modified

    const ref = function (value, validationOptions) {

        return Hoek.reach(ref.isContext ? validationOptions.context : value, ref.key, settings);
    };

    ref.isContext = (key[0] === ((settings && settings.contextPrefix) || '$'));
    ref.key = (ref.isContext ? key.slice(1) : key);
    ref.path = ref.key.split((settings && settings.separator) || '.');
    ref.depth = ref.path.length;
    ref.root = ref.path[0];
    ref.isJoi = true;

    ref.toString = function () {

        return (ref.isContext ? 'context:' : 'ref:') + ref.key;
    };

    return ref;
};


exports.isRef = function (ref) {

    return typeof ref === 'function' && ref.isJoi;
};


exports.push = function (array, ref) {

    if (exports.isRef(ref) &&
        !ref.isContext) {

        array.push(ref.root);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/schemas.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/schemas.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Joi = __webpack_require__(/*! ./index */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/index.js");


const internals = {};


exports.options = Joi.object({
    abortEarly: Joi.boolean(),
    convert: Joi.boolean(),
    allowUnknown: Joi.boolean(),
    skipFunctions: Joi.boolean(),
    stripUnknown: [Joi.boolean(), Joi.object({ arrays: Joi.boolean(), objects: Joi.boolean() }).or('arrays', 'objects')],
    language: Joi.object(),
    presence: Joi.string().only('required', 'optional', 'forbidden', 'ignore'),
    context: Joi.object(),
    noDefaults: Joi.boolean(),
    escapeHtml: Joi.boolean()
}).strict();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.extendedCheckForValue = function (value, insensitive) {

    const valueType = typeof value;

    if (valueType === 'object') {
        if (value instanceof Date) {
            return (item) => {

                return item instanceof Date && value.getTime() === item.getTime();
            };
        }

        if (Buffer.isBuffer(value)) {
            return (item) => {

                return Buffer.isBuffer(item) && value.length === item.length && value.toString('binary') === item.toString('binary');
            };
        }
    }
    else if (insensitive && valueType === 'string') {
        const lowercaseValue = value.toLowerCase();
        return (item) => {

            return typeof item === 'string' && lowercaseValue === item.toLowerCase();
        };
    }

    return null;
};


module.exports = class InternalSet {

    constructor(from) {

        this._set = new Set(from);
        this._hasRef = false;
    }

    add(value, refs) {

        const isRef = Ref.isRef(value);
        if (!isRef && this.has(value, null, null, false)) {

            return this;
        }

        if (refs !== undefined) { // If it's a merge, we don't have any refs
            Ref.push(refs, value);
        }

        this._set.add(value);

        this._hasRef |= isRef;

        return this;
    }

    merge(add, remove) {

        for (const item of add._set) {
            this.add(item);
        }

        for (const item of remove._set) {
            this.remove(item);
        }

        return this;
    }

    remove(value) {

        this._set.delete(value);
        return this;
    }

    has(value, state, options, insensitive) {

        return !!this.get(value, state, options, insensitive);
    }

    get(value, state, options, insensitive) {

        if (!this._set.size) {
            return false;
        }

        const hasValue = this._set.has(value);
        if (hasValue) {
            return { value };
        }

        const extendedCheck = internals.extendedCheckForValue(value, insensitive);
        if (!extendedCheck) {
            if (state && this._hasRef) {
                for (let item of this._set) {
                    if (Ref.isRef(item)) {
                        item = [].concat(item(state.reference || state.parent, options));
                        const found = item.indexOf(value);
                        if (found >= 0) {
                            return { value: item[found] };
                        }
                    }
                }
            }

            return false;
        }

        return this._has(value, state, options, extendedCheck);
    }

    _has(value, state, options, check) {

        const checkRef = !!(state && this._hasRef);

        const isReallyEqual = function (item) {

            if (value === item) {
                return true;
            }

            return check(item);
        };

        for (let item of this._set) {
            if (checkRef && Ref.isRef(item)) { // Only resolve references if there is a state, otherwise it's a merge
                item = item(state.reference || state.parent, options);

                if (Array.isArray(item)) {
                    const found = item.findIndex(isReallyEqual);
                    if (found >= 0) {
                        return {
                            value: item[found]
                        };
                    }

                    continue;
                }
            }

            if (isReallyEqual(item)) {
                return {
                    value: item
                };
            }
        }

        return false;
    }

    values(options) {

        if (options && options.stripUndefined) {
            const values = [];

            for (const item of this._set) {
                if (item !== undefined) {
                    values.push(item);
                }
            }

            return values;
        }

        return Array.from(this._set);
    }

    slice() {

        const set = new InternalSet(this._set);
        set._hasRef = this._hasRef;
        return set;
    }

    concat(source) {

        const set = new InternalSet([...this._set, ...source._set]);
        set._hasRef = !!(this._hasRef | source._hasRef);
        return set;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.Alternatives = class extends Any {

    constructor() {

        super();
        this._type = 'alternatives';
        this._invalids.remove(null);
        this._inner.matches = [];
    }

    _init(...args) {

        return args.length ? this.try(...args) : this;
    }

    _base(value, state, options) {

        const errors = [];
        const il = this._inner.matches.length;
        const baseType = this._baseType;

        for (let i = 0; i < il; ++i) {
            const item = this._inner.matches[i];
            if (!item.schema) {
                const schema = item.peek || item.is;
                const input = item.is ? item.ref(state.reference || state.parent, options) : value;
                const failed = schema._validate(input, null, options, state.parent).errors;

                if (failed) {
                    if (item.otherwise) {
                        return item.otherwise._validate(value, state, options);
                    }
                }
                else if (item.then) {
                    return item.then._validate(value, state, options);
                }

                if (i === (il - 1) && baseType) {
                    return baseType._validate(value, state, options);
                }

                continue;
            }

            const result = item.schema._validate(value, state, options);
            if (!result.errors) {     // Found a valid match
                return result;
            }

            errors.push(...result.errors);
        }

        if (errors.length) {
            return { errors: this.createError('alternatives.child', { reason: errors }, state, options) };
        }

        return { errors: this.createError('alternatives.base', null, state, options) };
    }

    try(...schemas) {

        schemas = Hoek.flatten(schemas);
        Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');

        const obj = this.clone();

        for (let i = 0; i < schemas.length; ++i) {
            const cast = Cast.schema(this._currentJoi, schemas[i]);
            if (cast._refs.length) {
                obj._refs.push(...cast._refs);
            }

            obj._inner.matches.push({ schema: cast });
        }

        return obj;
    }

    when(condition, options) {

        let schemaCondition = false;
        Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);
        Hoek.assert(options, 'Missing options');
        Hoek.assert(typeof options === 'object', 'Invalid options');
        if (schemaCondition) {
            Hoek.assert(!options.hasOwnProperty('is'), '"is" can not be used with a schema condition');
        }
        else {
            Hoek.assert(options.hasOwnProperty('is'), 'Missing "is" directive');
        }

        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

        const obj = this.clone();
        let is;
        if (!schemaCondition) {
            is = Cast.schema(this._currentJoi, options.is);

            if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {

                // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing
                is = is.required();
            }
        }

        const item = {
            ref: schemaCondition ? null : Cast.ref(condition),
            peek: schemaCondition ? condition : null,
            is,
            then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,
            otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined
        };

        if (obj._baseType) {

            item.then = item.then && obj._baseType.concat(item.then);
            item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);
        }

        if (!schemaCondition) {
            Ref.push(obj._refs, item.ref);
            obj._refs.push(...item.is._refs);
        }

        if (item.then && item.then._refs.length) {
            obj._refs.push(...item.then._refs);
        }

        if (item.otherwise && item.otherwise._refs.length) {
            obj._refs.push(...item.otherwise._refs);
        }

        obj._inner.matches.push(item);

        return obj;
    }

    label(name) {

        const obj = super.label(name);
        obj._inner.matches = obj._inner.matches.map((match) => {

            if (match.schema) {
                return { schema: match.schema.label(name) };
            }

            match = Object.assign({}, match);
            if (match.then) {
                match.then = match.then.label(name);
            }

            if (match.otherwise) {
                match.otherwise = match.otherwise.label(name);
            }

            return match;
        });
        return obj;
    }

    describe() {

        const description = super.describe();
        const alternatives = [];
        for (let i = 0; i < this._inner.matches.length; ++i) {
            const item = this._inner.matches[i];
            if (item.schema) {

                // try()

                alternatives.push(item.schema.describe());
            }
            else {

                // when()

                const when = item.is ? {
                    ref: item.ref.toString(),
                    is: item.is.describe()
                } : {
                    peek: item.peek.describe()
                };

                if (item.then) {
                    when.then = item.then.describe();
                }

                if (item.otherwise) {
                    when.otherwise = item.otherwise.describe();
                }

                alternatives.push(when);
            }
        }

        description.alternatives = alternatives;
        return description;
    }

};


module.exports = new internals.Alternatives();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Settings = __webpack_require__(/*! ./settings */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/settings.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");
const Errors = __webpack_require__(/*! ../../errors */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js");
const State = __webpack_require__(/*! ../state */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js");
const Symbols = __webpack_require__(/*! ../symbols */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js");

const Pkg = __webpack_require__(/*! ../../../package.json */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json");

let Alternatives = null;                            // Delay-loaded to prevent circular dependencies
let Schemas = null;


const internals = {
    Set: __webpack_require__(/*! ../../set */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js"),
    symbol: Symbol.for('@hapi/joi/schema')
};


internals.defaults = {
    abortEarly: true,
    convert: true,
    allowUnknown: false,
    skipFunctions: false,
    stripUnknown: false,
    language: {},
    presence: 'optional',
    noDefaults: false,
    escapeHtml: false

    // context: null
};


module.exports = internals.Any = class {

    constructor() {

        this.isJoi = true;
        this._type = 'any';
        this._settings = null;
        this._valids = new internals.Set();
        this._invalids = new internals.Set();
        this._tests = [];
        this._refs = [];
        this._flags = {
            /*
             presence: 'optional',                   // optional, required, forbidden, ignore
             allowOnly: false,
             allowUnknown: undefined,
             default: undefined,
             forbidden: false,
             encoding: undefined,
             insensitive: false,
             trim: false,
             normalize: undefined,                   // NFC, NFD, NFKC, NFKD
             case: undefined,                        // upper, lower
             empty: undefined,
             func: false,
             raw: false
             */
        };

        this._description = null;
        this._unit = null;
        this._notes = [];
        this._tags = [];
        this._examples = [];
        this._meta = [];

        this._inner = {};                           // Hash of arrays of immutable objects
    }

    _init() {

        return this;
    }

    get schemaType() {

        return this._type;
    }

    createError(type, context, state, options, flags = this._flags) {

        return Errors.create(type, context, state, options, flags);
    }

    createOverrideError(type, context, state, options, message, template) {

        return Errors.create(type, context, state, options, this._flags, message, template);
    }

    checkOptions(options) {

        Schemas = Schemas || __webpack_require__(/*! ../../schemas */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/schemas.js");

        const result = Schemas.options.validate(options);

        if (result.error) {
            throw new Error(result.error.details[0].message);
        }
    }

    clone() {

        const obj = Object.create(Object.getPrototypeOf(this));

        obj.isJoi = true;
        obj._currentJoi = this._currentJoi;
        obj._type = this._type;
        obj._settings = this._settings;
        obj._baseType = this._baseType;
        obj._valids = this._valids.slice();
        obj._invalids = this._invalids.slice();
        obj._tests = this._tests.slice();
        obj._refs = this._refs.slice();
        obj._flags = Hoek.clone(this._flags);

        obj._description = this._description;
        obj._unit = this._unit;
        obj._notes = this._notes.slice();
        obj._tags = this._tags.slice();
        obj._examples = this._examples.slice();
        obj._meta = this._meta.slice();

        obj._inner = {};
        const inners = Object.keys(this._inner);
        for (let i = 0; i < inners.length; ++i) {
            const key = inners[i];
            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;
        }

        return obj;
    }

    concat(schema) {

        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');
        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);

        let obj = this.clone();

        if (this._type === 'any' && schema._type !== 'any') {

            // Reset values as if we were "this"
            const tmpObj = schema.clone();
            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',
                '_notes', '_tags', '_examples', '_meta', '_inner'];

            for (let i = 0; i < keysToRestore.length; ++i) {
                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];
            }

            obj = tmpObj;
        }

        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;
        obj._valids.merge(schema._valids, schema._invalids);
        obj._invalids.merge(schema._invalids, schema._valids);
        obj._tests.push(...schema._tests);
        obj._refs.push(...schema._refs);
        if (obj._flags.empty && schema._flags.empty) {
            obj._flags.empty = obj._flags.empty.concat(schema._flags.empty);
            const flags = Object.assign({}, schema._flags);
            delete flags.empty;
            Hoek.merge(obj._flags, flags);
        }
        else if (schema._flags.empty) {
            obj._flags.empty = schema._flags.empty;
            const flags = Object.assign({}, schema._flags);
            delete flags.empty;
            Hoek.merge(obj._flags, flags);
        }
        else {
            Hoek.merge(obj._flags, schema._flags);
        }

        obj._description = schema._description || obj._description;
        obj._unit = schema._unit || obj._unit;
        obj._notes.push(...schema._notes);
        obj._tags.push(...schema._tags);
        obj._examples.push(...schema._examples);
        obj._meta.push(...schema._meta);

        const inners = Object.keys(schema._inner);
        const isObject = obj._type === 'object';
        for (let i = 0; i < inners.length; ++i) {
            const key = inners[i];
            const source = schema._inner[key];
            if (source) {
                const target = obj._inner[key];
                if (target) {
                    if (isObject && key === 'children') {
                        const keys = {};

                        for (let j = 0; j < target.length; ++j) {
                            keys[target[j].key] = j;
                        }

                        for (let j = 0; j < source.length; ++j) {
                            const sourceKey = source[j].key;
                            if (keys[sourceKey] >= 0) {
                                target[keys[sourceKey]] = {
                                    key: sourceKey,
                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)
                                };
                            }
                            else {
                                target.push(source[j]);
                            }
                        }
                    }
                    else {
                        obj._inner[key] = obj._inner[key].concat(source);
                    }
                }
                else {
                    obj._inner[key] = source.slice();
                }
            }
        }

        return obj;
    }

    _test(name, arg, func, options) {

        const obj = this.clone();
        obj._tests.push({ func, name, arg, options });
        return obj;
    }

    _testUnique(name, arg, func, options) {

        const obj = this.clone();
        obj._tests = obj._tests.filter((test) => test.name !== name);
        obj._tests.push({ func, name, arg, options });
        return obj;
    }

    options(options) {

        Hoek.assert(!options.context, 'Cannot override context');
        this.checkOptions(options);

        const obj = this.clone();
        obj._settings = Settings.concat(obj._settings, options);
        return obj;
    }

    strict(isStrict) {

        const obj = this.clone();

        const convert = isStrict === undefined ? false : !isStrict;
        obj._settings = Settings.concat(obj._settings, { convert });
        return obj;
    }

    raw(isRaw) {

        const value = isRaw === undefined ? true : isRaw;

        if (this._flags.raw === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.raw = value;
        return obj;
    }

    error(err, options = { self: false }) {

        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');

        const unknownKeys = Object.keys(options).filter((k) => !['self'].includes(k));
        Hoek.assert(unknownKeys.length === 0, `Options ${unknownKeys} are unknown`);

        const obj = this.clone();
        obj._flags.error = err;

        if (options.self) {
            obj._flags.selfError = true;
        }

        return obj;
    }

    allow(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            obj._invalids.remove(value);
            obj._valids.add(value, obj._refs);
        }

        return obj;
    }

    valid(...values) {

        const obj = this.allow(...values);
        obj._flags.allowOnly = true;
        return obj;
    }

    invalid(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            obj._valids.remove(value);
            obj._invalids.add(value, obj._refs);
        }

        return obj;
    }

    required() {

        if (this._flags.presence === 'required') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'required';
        return obj;
    }

    optional() {

        if (this._flags.presence === 'optional') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'optional';
        return obj;
    }


    forbidden() {

        if (this._flags.presence === 'forbidden') {
            return this;
        }

        const obj = this.clone();
        obj._flags.presence = 'forbidden';
        return obj;
    }


    strip() {

        if (this._flags.strip) {
            return this;
        }

        const obj = this.clone();
        obj._flags.strip = true;
        return obj;
    }

    applyFunctionToChildren(children, fn, args = [], root) {

        children = [].concat(children);

        if (children.length !== 1 || children[0] !== '') {
            root = root ? (root + '.') : '';

            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {

                return root + child;
            });

            throw new Error('unknown key(s) ' + extraChildren.join(', '));
        }

        return this[fn](...args);
    }

    default(value, description) {

        if (typeof value === 'function' &&
            !Ref.isRef(value)) {

            if (!value.description &&
                description) {

                value.description = description;
            }

            if (!this._flags.func) {
                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');
            }
        }

        const obj = this.clone();
        obj._flags.default = value;
        Ref.push(obj._refs, value);
        return obj;
    }

    empty(schema) {

        const obj = this.clone();
        if (schema === undefined) {
            delete obj._flags.empty;
        }
        else {
            obj._flags.empty = Cast.schema(this._currentJoi, schema);
        }

        return obj;
    }

    when(condition, options) {

        Hoek.assert(options && typeof options === 'object', 'Invalid options');
        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of "then" or "otherwise"');

        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;
        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;

        Alternatives = Alternatives || __webpack_require__(/*! ../alternatives */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/alternatives/index.js");

        const alternativeOptions = { then, otherwise };
        if (Object.prototype.hasOwnProperty.call(options, 'is')) {
            alternativeOptions.is = options.is;
        }

        const obj = Alternatives.when(condition, alternativeOptions);
        obj._flags.presence = 'ignore';
        obj._baseType = this;

        return obj;
    }

    description(desc) {

        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

        const obj = this.clone();
        obj._description = desc;
        return obj;
    }

    notes(notes) {

        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');

        const obj = this.clone();
        obj._notes = obj._notes.concat(notes);
        return obj;
    }

    tags(tags) {

        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');

        const obj = this.clone();
        obj._tags = obj._tags.concat(tags);
        return obj;
    }

    meta(meta) {

        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');

        const obj = this.clone();
        obj._meta = obj._meta.concat(meta);
        return obj;
    }

    example(...examples) {

        Hoek.assert(examples.length > 0, 'Missing examples');

        const processed = [];
        for (let i = 0; i < examples.length; ++i) {
            const example = [].concat(examples[i]);
            Hoek.assert(example.length <= 2, `Bad example format at index ${i}`);

            const value = example[0];
            let options = example[1];
            if (options !== undefined) {
                Hoek.assert(options && typeof options === 'object', `Options for example at index ${i} must be an object`);
                const unknownOptions = Object.keys(options).filter((option) => !['parent', 'context'].includes(option));
                Hoek.assert(unknownOptions.length === 0, `Unknown example options ${unknownOptions} at index ${i}`);
            }
            else {
                options = {};
            }

            const localState = new State('', [], options.parent || null);
            const result = this._validate(value, localState, Settings.concat(internals.defaults, options.context ? { context: options.context } : null));
            Hoek.assert(!result.errors, `Bad example at index ${i}:`, result.errors && Errors.process(result.errors, value));

            const ex = { value };
            if (Object.keys(options).length) {
                ex.options = options;
            }

            processed.push(ex);
        }

        const obj = this.clone();
        obj._examples = processed;
        return obj;
    }

    unit(name) {

        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

        const obj = this.clone();
        obj._unit = name;
        return obj;
    }

    _prepareEmptyValue(value) {

        if (typeof value === 'string' && this._flags.trim) {
            return value.trim();
        }

        return value;
    }

    _validate(value, state, options, reference) {

        const originalValue = value;

        // Setup state and settings

        state = state || new State('', [], null, reference);

        if (this._settings) {
            const isDefaultOptions = options === internals.defaults;
            if (isDefaultOptions && this._settings[Symbols.settingsCache]) {
                options = this._settings[Symbols.settingsCache];
            }
            else {
                options = Settings.concat(this._language ? Settings.concat({ language: this._language }, options) : options, this._settings);
                if (isDefaultOptions) {
                    this._settings[Symbols.settingsCache] = options;
                }
            }
        }
        else if (this._language) {
            options = Settings.concat({ language: this._language }, options);
        }

        let errors = [];

        if (this._coerce) {
            const coerced = this._coerce(value, state, options);
            if (coerced.errors) {
                value = coerced.value;
                errors = errors.concat(coerced.errors);
                return this._finalizeValue(value, originalValue, errors, state, options);                            // Coerced error always aborts early
            }

            value = coerced.value;
        }

        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {
            value = undefined;
        }

        // Check presence requirements

        const presence = this._flags.presence || options.presence;
        if (presence === 'optional') {
            if (value === undefined) {
                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;
                if (isDeepDefault && this._type === 'object') {
                    value = {};
                }
                else {
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }
            }
        }
        else if (presence === 'required' &&
            value === undefined) {

            errors.push(this.createError('any.required', null, state, options));
            return this._finalizeValue(value, originalValue, errors, state, options);
        }
        else if (presence === 'forbidden') {
            if (value === undefined) {
                return this._finalizeValue(value, originalValue, errors, state, options);
            }

            errors.push(this.createError('any.unknown', null, state, options));
            return this._finalizeValue(value, originalValue, errors, state, options);
        }

        // Check allowed and denied values using the original value

        let match = this._valids.get(value, state, options, this._flags.insensitive);
        if (match) {
            if (options.convert) {
                value = match.value;
            }

            return this._finalizeValue(value, originalValue, errors, state, options);
        }

        if (this._invalids.has(value, state, options, this._flags.insensitive)) {
            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
            if (options.abortEarly) {

                return this._finalizeValue(value, originalValue, errors, state, options);
            }
        }

        // Convert value and validate type

        if (this._base) {
            const base = this._base(value, state, options);
            if (base.errors) {
                value = base.value;
                errors = errors.concat(base.errors);
                return this._finalizeValue(value, originalValue, errors, state, options);                            // Base error always aborts early
            }

            if (base.value !== value) {
                value = base.value;

                // Check allowed and denied values using the converted value

                match = this._valids.get(value, state, options, this._flags.insensitive);
                if (match) {
                    value = match.value;
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }

                if (this._invalids.has(value, state, options, this._flags.insensitive)) {
                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));
                    if (options.abortEarly) {
                        return this._finalizeValue(value, originalValue, errors, state, options);
                    }
                }
            }
        }

        // Required values did not match

        if (this._flags.allowOnly) {
            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));
            if (options.abortEarly) {
                return this._finalizeValue(value, originalValue, errors, state, options);
            }
        }

        // Validate tests

        for (let i = 0; i < this._tests.length; ++i) {
            const test = this._tests[i];
            const ret = test.func.call(this, value, state, options);
            if (ret instanceof Errors.Err) {
                errors.push(ret);
                if (options.abortEarly) {
                    return this._finalizeValue(value, originalValue, errors, state, options);
                }
            }
            else {
                value = ret;
            }
        }

        return this._finalizeValue(value, originalValue, errors, state, options);
    }

    _finalizeValue(value, originalValue, errors, state, options) {

        let finalValue;

        if (value !== undefined) {
            finalValue = this._flags.raw ? originalValue : value;
        }
        else if (options.noDefaults) {
            finalValue = value;
        }
        else if (Ref.isRef(this._flags.default)) {
            finalValue = this._flags.default(state.parent, options);
        }
        else if (typeof this._flags.default === 'function' &&
            !(this._flags.func && !this._flags.default.description)) {

            let args;

            if (state.parent !== null &&
                this._flags.default.length > 0) {

                args = [Hoek.clone(state.parent), options];
            }

            const defaultValue = internals._try(this._flags.default, args);
            finalValue = defaultValue.value;
            if (defaultValue.error) {
                errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));
            }
        }
        else {
            finalValue = Hoek.clone(this._flags.default);
        }

        if (errors.length &&
            typeof this._flags.error === 'function' &&
            (
                !this._flags.selfError ||
                errors.some((e) => state.path.length === e.path.length)
            )
        ) {
            const change = this._flags.error.call(this, errors);

            if (typeof change === 'string') {
                errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];
            }
            else {
                errors = [].concat(change)
                    .map((err) => {

                        return err instanceof Error ?
                            err :
                            this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);
                    });
            }
        }

        return {
            value: this._flags.strip ? undefined : finalValue,
            finalValue,
            errors: errors.length ? errors : null
        };
    }

    _validateWithOptions(value, options, callback) {

        if (options) {
            this.checkOptions(options);
        }

        const settings = Settings.concat(internals.defaults, options);
        const result = this._validate(value, null, settings);
        const errors = Errors.process(result.errors, value);

        if (callback) {
            return callback(errors, result.value);
        }

        return {
            error: errors,
            value: result.value,
            then(resolve, reject) {

                if (errors) {
                    return Promise.reject(errors).catch(reject);
                }

                return Promise.resolve(result.value).then(resolve);
            },
            catch(reject) {

                if (errors) {
                    return Promise.reject(errors).catch(reject);
                }

                return Promise.resolve(result.value);
            }
        };
    }

    validate(value, options, callback) {

        if (typeof options === 'function') {
            return this._validateWithOptions(value, null, options);
        }

        return this._validateWithOptions(value, options, callback);
    }

    describe() {

        const description = {
            type: this._type
        };

        const flags = Object.keys(this._flags);
        if (flags.length) {
            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {
                description.flags = {};
                for (let i = 0; i < flags.length; ++i) {
                    const flag = flags[i];
                    if (flag === 'empty') {
                        description.flags[flag] = this._flags[flag].describe();
                    }
                    else if (flag === 'default') {
                        if (Ref.isRef(this._flags[flag])) {
                            description.flags[flag] = this._flags[flag].toString();
                        }
                        else if (typeof this._flags[flag] === 'function') {
                            description.flags[flag] = {
                                description: this._flags[flag].description,
                                function   : this._flags[flag]
                            };
                        }
                        else {
                            description.flags[flag] = this._flags[flag];
                        }
                    }
                    else if (flag === 'lazy' || flag === 'label') {
                        // We don't want it in the description
                    }
                    else {
                        description.flags[flag] = this._flags[flag];
                    }
                }
            }
            else {
                description.flags = this._flags;
            }
        }

        if (this._settings) {
            description.options = Hoek.clone(this._settings);
        }

        if (this._baseType) {
            description.base = this._baseType.describe();
        }

        if (this._description) {
            description.description = this._description;
        }

        if (this._notes.length) {
            description.notes = this._notes;
        }

        if (this._tags.length) {
            description.tags = this._tags;
        }

        if (this._meta.length) {
            description.meta = this._meta;
        }

        if (this._examples.length) {
            description.examples = this._examples;
        }

        if (this._unit) {
            description.unit = this._unit;
        }

        const valids = this._valids.values();
        if (valids.length) {
            description.valids = valids.map((v) => {

                return Ref.isRef(v) ? v.toString() : v;
            });
        }

        const invalids = this._invalids.values();
        if (invalids.length) {
            description.invalids = invalids.map((v) => {

                return Ref.isRef(v) ? v.toString() : v;
            });
        }

        description.rules = [];

        for (let i = 0; i < this._tests.length; ++i) {
            const validator = this._tests[i];
            const item = { name: validator.name };

            if (validator.arg !== void 0) {
                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;
            }

            const options = validator.options;
            if (options) {
                if (options.hasRef) {
                    item.arg = {};
                    const keys = Object.keys(validator.arg);
                    for (let j = 0; j < keys.length; ++j) {
                        const key = keys[j];
                        const value = validator.arg[key];
                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;
                    }
                }

                if (typeof options.description === 'string') {
                    item.description = options.description;
                }
                else if (typeof options.description === 'function') {
                    item.description = options.description(item.arg);
                }
            }

            description.rules.push(item);
        }

        if (!description.rules.length) {
            delete description.rules;
        }

        const label = this._getLabel();
        if (label) {
            description.label = label;
        }

        return description;
    }

    label(name) {

        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');

        const obj = this.clone();
        obj._flags.label = name;
        return obj;
    }

    _getLabel(def) {

        return this._flags.label || def;
    }

};


internals.Any.prototype.isImmutable = true;     // Prevents Hoek from deep cloning schema objects

// Aliases

internals.Any.prototype.only = internals.Any.prototype.equal = internals.Any.prototype.valid;
internals.Any.prototype.disallow = internals.Any.prototype.not = internals.Any.prototype.invalid;
internals.Any.prototype.exist = internals.Any.prototype.required;


internals.Any.prototype[internals.symbol] = {
    version: Pkg.version,
    compile: Cast.schema,
    root: '_currentJoi'
};


internals._try = function (fn, args = []) {

    let err;
    let result;

    try {
        result = fn(...args);
    }
    catch (e) {
        err = e;
    }

    return {
        value: result,
        error: err
    };
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/settings.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/settings.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Symbols = __webpack_require__(/*! ../symbols */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js");


const internals = {};


exports.concat = function (target, source) {

    if (!source) {
        return target;
    }

    const obj = Object.assign({}, target);

    const language = source.language;

    Object.assign(obj, source);

    if (language && target && target.language) {
        obj.language = Hoek.applyToDefaults(target.language, language);
    }

    if (obj[Symbols.settingsCache]) {
        delete obj[Symbols.settingsCache];
    }

    return obj;
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/array/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/array/index.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");
const State = __webpack_require__(/*! ../state */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js");


const internals = {};


internals.fastSplice = function (arr, i) {

    let pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];
    }

    --arr.length;
};


internals.Array = class extends Any {

    constructor() {

        super();
        this._type = 'array';
        this._inner.items = [];
        this._inner.ordereds = [];
        this._inner.inclusions = [];
        this._inner.exclusions = [];
        this._inner.requireds = [];
        this._flags.sparse = false;
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            if (value.length > 1 &&
                (value[0] === '[' || /^\s*\[/.test(value))) {

                try {
                    result.value = Bourne.parse(value);
                }
                catch (e) { }
            }
        }

        let isArray = Array.isArray(result.value);
        const wasArray = isArray;
        if (options.convert && this._flags.single && !isArray) {
            result.value = [result.value];
            isArray = true;
        }

        if (!isArray) {
            result.errors = this.createError('array.base', null, state, options);
            return result;
        }

        if (this._inner.inclusions.length ||
            this._inner.exclusions.length ||
            this._inner.requireds.length ||
            this._inner.ordereds.length ||
            !this._flags.sparse) {

            // Clone the array so that we don't modify the original
            if (wasArray) {
                result.value = result.value.slice(0);
            }

            result.errors = this._checkItems(result.value, wasArray, state, options);

            if (result.errors && wasArray && options.convert && this._flags.single) {

                // Attempt a 2nd pass by putting the array inside one.
                const previousErrors = result.errors;

                result.value = [result.value];
                result.errors = this._checkItems(result.value, wasArray, state, options);

                if (result.errors) {

                    // Restore previous errors and value since this didn't validate either.
                    result.errors = previousErrors;
                    result.value = result.value[0];
                }
            }
        }

        return result;
    }

    _checkItems(items, wasArray, state, options) {

        const errors = [];
        let errored;

        const requireds = this._inner.requireds.slice();
        const ordereds = this._inner.ordereds.slice();
        const inclusions = [...this._inner.inclusions, ...requireds];

        let il = items.length;
        for (let i = 0; i < il; ++i) {
            errored = false;
            const item = items[i];
            let isValid = false;
            const key = wasArray ? i : state.key;
            const path = wasArray ? [...state.path, i] : state.path;
            const localState = new State(key, path, state.parent, state.reference);
            let res;

            // Sparse

            if (!this._flags.sparse && item === undefined) {
                errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                if (options.abortEarly) {
                    return errors;
                }

                ordereds.shift();

                continue;
            }

            // Exclusions

            for (let j = 0; j < this._inner.exclusions.length; ++j) {
                res = this._inner.exclusions[j]._validate(item, localState, {});                // Not passing options to use defaults

                if (!res.errors) {
                    errors.push(this.createError(wasArray ? 'array.excludes' : 'array.excludesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;

                    if (options.abortEarly) {
                        return errors;
                    }

                    ordereds.shift();

                    break;
                }
            }

            if (errored) {
                continue;
            }

            // Ordered
            if (this._inner.ordereds.length) {
                if (ordereds.length > 0) {
                    const ordered = ordereds.shift();
                    res = ordered._validate(item, localState, options);
                    if (!res.errors) {
                        if (ordered._flags.strip) {
                            internals.fastSplice(items, i);
                            --i;
                            --il;
                        }
                        else if (!this._flags.sparse && res.value === undefined) {
                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                            if (options.abortEarly) {
                                return errors;
                            }

                            continue;
                        }
                        else {
                            items[i] = res.value;
                        }
                    }
                    else {
                        errors.push(this.createError('array.ordered', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                        if (options.abortEarly) {
                            return errors;
                        }
                    }

                    continue;
                }
                else if (!this._inner.items.length) {
                    errors.push(this.createError('array.orderedLength', { pos: i, limit: this._inner.ordereds.length }, { key: state.key, path: localState.path }, options));
                    if (options.abortEarly) {
                        return errors;
                    }

                    continue;
                }
            }

            // Requireds

            const requiredChecks = [];
            let jl = requireds.length;
            for (let j = 0; j < jl; ++j) {
                res = requiredChecks[j] = requireds[j]._validate(item, localState, options);
                if (!res.errors) {
                    items[i] = res.value;
                    isValid = true;
                    internals.fastSplice(requireds, j);
                    --j;
                    --jl;

                    if (!this._flags.sparse && res.value === undefined) {
                        errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));

                        if (options.abortEarly) {
                            return errors;
                        }
                    }

                    break;
                }
            }

            if (isValid) {
                continue;
            }

            // Inclusions

            const stripUnknown = options.stripUnknown && !!options.stripUnknown.arrays || false;

            jl = inclusions.length;
            for (let j = 0; j < jl; ++j) {
                const inclusion = inclusions[j];

                // Avoid re-running requireds that already didn't match in the previous loop
                const previousCheck = requireds.indexOf(inclusion);
                if (previousCheck !== -1) {
                    res = requiredChecks[previousCheck];
                }
                else {
                    res = inclusion._validate(item, localState, options);

                    if (!res.errors) {
                        if (inclusion._flags.strip) {
                            internals.fastSplice(items, i);
                            --i;
                            --il;
                        }
                        else if (!this._flags.sparse && res.value === undefined) {
                            errors.push(this.createError('array.sparse', null, { key: state.key, path: localState.path, pos: i }, options));
                            errored = true;
                        }
                        else {
                            items[i] = res.value;
                        }

                        isValid = true;
                        break;
                    }
                }

                // Return the actual error if only one inclusion defined
                if (jl === 1) {
                    if (stripUnknown) {
                        internals.fastSplice(items, i);
                        --i;
                        --il;
                        isValid = true;
                        break;
                    }

                    errors.push(this.createError(wasArray ? 'array.includesOne' : 'array.includesOneSingle', { pos: i, reason: res.errors, value: item }, { key: state.key, path: localState.path }, options));
                    errored = true;

                    if (options.abortEarly) {
                        return errors;
                    }

                    break;
                }
            }

            if (errored) {
                continue;
            }

            if (this._inner.inclusions.length && !isValid) {
                if (stripUnknown) {
                    internals.fastSplice(items, i);
                    --i;
                    --il;
                    continue;
                }

                errors.push(this.createError(wasArray ? 'array.includes' : 'array.includesSingle', { pos: i, value: item }, { key: state.key, path: localState.path }, options));

                if (options.abortEarly) {
                    return errors;
                }
            }
        }

        if (requireds.length) {
            this._fillMissedErrors(errors, requireds, state, options);
        }

        if (ordereds.length) {
            this._fillOrderedErrors(errors, ordereds, state, options);
        }

        return errors.length ? errors : null;
    }

    describe() {

        const description = super.describe();

        if (this._inner.ordereds.length) {
            description.orderedItems = [];

            for (let i = 0; i < this._inner.ordereds.length; ++i) {
                description.orderedItems.push(this._inner.ordereds[i].describe());
            }
        }

        if (this._inner.items.length) {
            description.items = [];

            for (let i = 0; i < this._inner.items.length; ++i) {
                description.items.push(this._inner.items[i].describe());
            }
        }

        if (description.rules) {
            for (let i = 0; i < description.rules.length; ++i) {
                const rule = description.rules[i];
                if (rule.name === 'has') {
                    rule.arg = rule.arg.describe();
                }
            }
        }

        return description;
    }

    items(...schemas) {

        const obj = this.clone();

        Hoek.flatten(schemas).forEach((type, index) => {

            try {
                type = Cast.schema(this._currentJoi, type);
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = index + '.' + castErr.path;
                }
                else {
                    castErr.path = index;
                }

                castErr.message = `${castErr.message}(${castErr.path})`;
                throw castErr;
            }

            obj._inner.items.push(type);

            if (type._flags.presence === 'required') {
                obj._inner.requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                obj._inner.exclusions.push(type.optional());
            }
            else {
                obj._inner.inclusions.push(type);
            }
        });

        return obj;
    }

    ordered(...schemas) {

        const obj = this.clone();

        Hoek.flatten(schemas).forEach((type, index) => {

            try {
                type = Cast.schema(this._currentJoi, type);
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = index + '.' + castErr.path;
                }
                else {
                    castErr.path = index;
                }

                castErr.message = `${castErr.message}(${castErr.path})`;
                throw castErr;
            }

            obj._inner.ordereds.push(type);
        });

        return obj;
    }

    min(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('min', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit, value: compareTo }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length >= compareTo) {
                return value;
            }

            return this.createError('array.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('max', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length <= compareTo) {
                return value;
            }

            return this.createError('array.max', { limit, value }, state, options);
        });
    }

    length(limit) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');

        return this._testUnique('length', limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(Number.isSafeInteger(compareTo) && compareTo >= 0)) {
                    return this.createError('array.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (value.length === compareTo) {
                return value;
            }

            return this.createError('array.length', { limit, value }, state, options);
        });
    }

    has(schema) {

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        return this._test('has', schema, function (value, state, options) {

            const isValid = value.some((item, idx) => {

                const localState = new State(idx, [...state.path, idx], state.key, state.reference);
                return !schema._validate(item, localState, options).errors;
            });

            if (isValid) {
                return value;
            }

            const patternLabel = schema._getLabel();
            if (patternLabel) {
                return this.createError('array.hasKnown', { patternLabel }, state, options);
            }

            return this.createError('array.hasUnknown', null, state, options);
        });
    }

    unique(comparator, configs) {

        Hoek.assert(comparator === undefined ||
            typeof comparator === 'function' ||
            typeof comparator === 'string', 'comparator must be a function or a string');

        Hoek.assert(configs === undefined ||
            typeof configs === 'object', 'configs must be an object');

        const settings = {
            ignoreUndefined: (configs && configs.ignoreUndefined) || false
        };


        if (typeof comparator === 'string') {
            settings.path = comparator;
        }
        else if (typeof comparator === 'function') {
            settings.comparator = comparator;
        }

        return this._test('unique', settings, function (value, state, options) {

            const found = {
                string: Object.create(null),
                number: Object.create(null),
                undefined: Object.create(null),
                boolean: Object.create(null),
                object: new Map(),
                function: new Map(),
                custom: new Map()
            };

            const compare = settings.comparator || Hoek.deepEqual;
            const ignoreUndefined = settings.ignoreUndefined;

            for (let i = 0; i < value.length; ++i) {
                const item = settings.path ? Hoek.reach(value[i], settings.path) : value[i];
                const records = settings.comparator ? found.custom : found[typeof item];

                // All available types are supported, so it's not possible to reach 100% coverage without ignoring this line.
                // I still want to keep the test for future js versions with new types (eg. Symbol).
                if (/* $lab:coverage:off$ */ records /* $lab:coverage:on$ */) {
                    if (records instanceof Map) {
                        const entries = records.entries();
                        let current;
                        while (!(current = entries.next()).done) {
                            if (compare(current.value[0], item)) {
                                const localState = new State(state.key, [...state.path, i], state.parent, state.reference);
                                const context = {
                                    pos: i,
                                    value: value[i],
                                    dupePos: current.value[1],
                                    dupeValue: value[current.value[1]]
                                };

                                if (settings.path) {
                                    context.path = settings.path;
                                }

                                return this.createError('array.unique', context, localState, options);
                            }
                        }

                        records.set(item, i);
                    }
                    else {
                        if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {
                            const localState = new State(state.key, [...state.path, i], state.parent, state.reference);

                            const context = {
                                pos: i,
                                value: value[i],
                                dupePos: records[item],
                                dupeValue: value[records[item]]
                            };

                            if (settings.path) {
                                context.path = settings.path;
                            }

                            return this.createError('array.unique', context, localState, options);
                        }

                        records[item] = i;
                    }
                }
            }

            return value;
        });
    }

    sparse(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.sparse === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.sparse = value;
        return obj;
    }

    single(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.single === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.single = value;
        return obj;
    }

    _fillMissedErrors(errors, requireds, state, options) {

        const knownMisses = [];
        let unknownMisses = 0;
        for (let i = 0; i < requireds.length; ++i) {
            const label = requireds[i]._getLabel();
            if (label) {
                knownMisses.push(label);
            }
            else {
                ++unknownMisses;
            }
        }

        if (knownMisses.length) {
            if (unknownMisses) {
                errors.push(this.createError('array.includesRequiredBoth', { knownMisses, unknownMisses }, { key: state.key, path: state.path }, options));
            }
            else {
                errors.push(this.createError('array.includesRequiredKnowns', { knownMisses }, { key: state.key, path: state.path }, options));
            }
        }
        else {
            errors.push(this.createError('array.includesRequiredUnknowns', { unknownMisses }, { key: state.key, path: state.path }, options));
        }
    }


    _fillOrderedErrors(errors, ordereds, state, options) {

        const requiredOrdereds = [];

        for (let i = 0; i < ordereds.length; ++i) {
            const presence = Hoek.reach(ordereds[i], '_flags.presence');
            if (presence === 'required') {
                requiredOrdereds.push(ordereds[i]);
            }
        }

        if (requiredOrdereds.length) {
            this._fillMissedErrors(errors, requiredOrdereds, state, options);
        }
    }

};


module.exports = new internals.Array();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/binary/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/binary/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Binary = class extends Any {

    constructor() {

        super();
        this._type = 'binary';
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            try {
                result.value = Buffer.from(value, this._flags.encoding);
            }
            catch (e) { }
        }

        result.errors = Buffer.isBuffer(result.value) ? null : this.createError('binary.base', null, state, options);
        return result;
    }

    encoding(encoding) {

        Hoek.assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

        if (this._flags.encoding === encoding) {
            return this;
        }

        const obj = this.clone();
        obj._flags.encoding = encoding;
        return obj;
    }

    min(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('min', limit, function (value, state, options) {

            if (value.length >= limit) {
                return value;
            }

            return this.createError('binary.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('max', limit, function (value, state, options) {

            if (value.length <= limit) {
                return value;
            }

            return this.createError('binary.max', { limit, value }, state, options);
        });
    }

    length(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('length', limit, function (value, state, options) {

            if (value.length === limit) {
                return value;
            }

            return this.createError('binary.length', { limit, value }, state, options);
        });
    }

};


module.exports = new internals.Binary();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/boolean/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/boolean/index.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {
    Set: __webpack_require__(/*! ../../set */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/set.js")
};


internals.Boolean = class extends Any {
    constructor() {

        super();
        this._type = 'boolean';
        this._flags.insensitive = true;
        this._inner.truthySet = new internals.Set();
        this._inner.falsySet = new internals.Set();
    }

    _base(value, state, options) {

        const result = {
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            const normalized = this._flags.insensitive ? value.toLowerCase() : value;
            result.value = (normalized === 'true' ? true
                : (normalized === 'false' ? false : value));
        }

        if (typeof result.value !== 'boolean') {
            result.value = (this._inner.truthySet.has(value, null, null, this._flags.insensitive) ? true
                : (this._inner.falsySet.has(value, null, null, this._flags.insensitive) ? false : value));
        }

        result.errors = (typeof result.value === 'boolean') ? null : this.createError('boolean.base', { value }, state, options);
        return result;
    }

    truthy(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call truthy with undefined');
            obj._inner.truthySet.add(value);
        }

        return obj;
    }

    falsy(...values) {

        const obj = this.clone();
        values = Hoek.flatten(values);
        for (let i = 0; i < values.length; ++i) {
            const value = values[i];

            Hoek.assert(value !== undefined, 'Cannot call falsy with undefined');
            obj._inner.falsySet.add(value);
        }

        return obj;
    }

    insensitive(enabled) {

        const insensitive = enabled === undefined ? true : !!enabled;

        if (this._flags.insensitive === insensitive) {
            return this;
        }

        const obj = this.clone();
        obj._flags.insensitive = insensitive;
        return obj;
    }

    describe() {

        const description = super.describe();
        description.truthy = [true, ...this._inner.truthySet.values()];
        description.falsy = [false, ...this._inner.falsySet.values()];
        return description;
    }
};


module.exports = new internals.Boolean();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};

internals.isoDate = /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/;
internals.invalidDate = new Date('');
internals.isIsoDate = (() => {

    const isoString = internals.isoDate.toString();

    return (date) => {

        return date && (date.toString() === isoString);
    };
})();

internals.Date = class extends Any {

    constructor() {

        super();
        this._type = 'date';
    }

    _base(value, state, options) {

        const result = {
            value: (options.convert && internals.Date.toDate(value, this._flags.format, this._flags.timestamp, this._flags.multiplier)) || value
        };

        if (result.value instanceof Date && !isNaN(result.value.getTime())) {
            result.errors = null;
        }
        else if (!options.convert) {
            result.errors = this.createError('date.strict', { value }, state, options);
        }
        else {
            let type;
            if (internals.isIsoDate(this._flags.format)) {
                type = 'isoDate';
            }
            else if (this._flags.timestamp) {
                type = `timestamp.${this._flags.timestamp}`;
            }
            else {
                type = 'base';
            }

            result.errors = this.createError(`date.${type}`, { value }, state, options);
        }

        return result;
    }

    static toDate(value, format, timestamp, multiplier) {

        if (value instanceof Date) {
            return value;
        }

        if (typeof value === 'string' ||
            (typeof value === 'number' && !isNaN(value) && isFinite(value))) {

            const isIsoDate = format && internals.isIsoDate(format);
            if (!isIsoDate &&
                typeof value === 'string' &&
                /^[+-]?\d+(\.\d+)?$/.test(value)) {

                value = parseFloat(value);
            }

            let date;
            if (isIsoDate) {
                date = format.test(value) ? new Date(value.toString()) : internals.invalidDate;
            }
            else if (timestamp) {
                date = /^\s*$/.test(value) ? internals.invalidDate : new Date(value * multiplier);
            }
            else {
                date = new Date(value);
            }

            if (!isNaN(date.getTime())) {
                return date;
            }
        }

        return null;
    }

    iso() {

        if (this._flags.format === internals.isoDate) {
            return this;
        }

        const obj = this.clone();
        obj._flags.format = internals.isoDate;
        return obj;
    }

    timestamp(type = 'javascript') {

        const allowed = ['javascript', 'unix'];
        Hoek.assert(allowed.includes(type), '"type" must be one of "' + allowed.join('", "') + '"');

        if (this._flags.timestamp === type) {
            return this;
        }

        const obj = this.clone();
        obj._flags.timestamp = type;
        obj._flags.multiplier = type === 'unix' ? 1000 : 1;
        return obj;
    }

    _isIsoDate(value) {

        return internals.isoDate.test(value);
    }

};

internals.compare = function (type, compare) {

    return function (date) {

        const isNow = date === 'now';
        const isRef = Ref.isRef(date);

        if (!isNow && !isRef) {
            date = internals.Date.toDate(date);
        }

        Hoek.assert(date, 'Invalid date format');

        return this._test(type, date, function (value, state, options) {

            let compareTo;
            if (isNow) {
                compareTo = Date.now();
            }
            else if (isRef) {
                const refValue = date(state.reference || state.parent, options);
                compareTo = internals.Date.toDate(refValue);

                if (!compareTo) {
                    return this.createError('date.ref', { ref: date, value: refValue }, state, options);
                }

                compareTo = compareTo.getTime();
            }
            else {
                compareTo = date.getTime();
            }

            if (compare(value.getTime(), compareTo)) {
                return value;
            }

            return this.createError('date.' + type, { limit: new Date(compareTo), value }, state, options);
        });
    };
};


internals.Date.prototype.min = internals.compare('min', (value, date) => value >= date);
internals.Date.prototype.max = internals.compare('max', (value, date) => value <= date);
internals.Date.prototype.greater = internals.compare('greater', (value, date) => value > date);
internals.Date.prototype.less = internals.compare('less', (value, date) => value < date);


module.exports = new internals.Date();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/func/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/func/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const ObjectType = __webpack_require__(/*! ../object */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {};


internals.Func = class extends ObjectType.constructor {

    constructor() {

        super();
        this._flags.func = true;
    }

    arity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

        return this._test('arity', n, function (value, state, options) {

            if (value.length === n) {
                return value;
            }

            return this.createError('function.arity', { n }, state, options);
        });
    }

    minArity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

        return this._test('minArity', n, function (value, state, options) {

            if (value.length >= n) {
                return value;
            }

            return this.createError('function.minArity', { n }, state, options);
        });
    }

    maxArity(n) {

        Hoek.assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

        return this._test('maxArity', n, function (value, state, options) {

            if (value.length <= n) {
                return value;
            }

            return this.createError('function.maxArity', { n }, state, options);
        });
    }

    ref() {

        return this._test('ref', null, function (value, state, options) {

            if (Ref.isRef(value)) {
                return value;
            }

            return this.createError('function.ref', { value }, state, options);
        });
    }

    class() {

        return this._test('class', null, function (value, state, options) {

            if ((/^\s*class\s/).test(value.toString())) {
                return value;
            }

            return this.createError('function.class', { value }, state, options);
        });
    }
};

module.exports = new internals.Func();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/lazy/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/lazy/index.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Lazy = class extends Any {

    constructor() {

        super();
        this._type = 'lazy';
        this._flags.once = true;
        this._cache = null;
    }

    _init(fn, options) {

        return this.set(fn, options);
    }

    _base(value, state, options) {

        let schema;
        if (this._cache) {
            schema = this._cache;
        }
        else {
            const result = { value };
            const lazy = this._flags.lazy;

            if (!lazy) {
                result.errors = this.createError('lazy.base', null, state, options);
                return result;
            }

            schema = lazy();

            if (!(schema instanceof Any)) {
                result.errors = this.createError('lazy.schema', { schema }, state, options);
                return result;
            }

            if (this._flags.once) {
                this._cache = schema;
            }
        }

        return schema._validate(value, state, options);
    }

    set(fn, options) {

        Hoek.assert(typeof fn === 'function', 'You must provide a function as first argument');
        Hoek.assert(options === undefined || (options && typeof options === 'object' && !Array.isArray(options)), `Options must be an object`);

        if (options) {
            const unknownOptions = Object.keys(options).filter((key) => !['once'].includes(key));
            Hoek.assert(unknownOptions.length === 0, `Options contain unknown keys: ${unknownOptions}`);
            Hoek.assert(options.once === undefined || typeof options.once === 'boolean', 'Option "once" must be a boolean');
        }

        const obj = this.clone();
        obj._flags.lazy = fn;

        if (options && options.once !== obj._flags.once) {
            obj._flags.once = options.once;
        }

        return obj;
    }

};

module.exports = new internals.Lazy();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/number/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/number/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");


const internals = {
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,
    normalizeExponent(str) {

        return str
            .replace(/\.?0+e/, 'e')
            .replace(/e\+/, 'e')
            .replace(/^\+/, '')
            .replace(/^(-?)0+([1-9])/, '$1$2');
    },
    normalizeDecimal(str) {

        str = str
            .replace(/^\+/, '')
            .replace(/\.0+$/, '')
            .replace(/^(-?)0+([1-9])/, '$1$2');

        if (str.includes('.') && str.endsWith('0')) {
            str = str.replace(/0+$/, '');
        }

        return str;
    }
};


internals.Number = class extends Any {

    constructor() {

        super();
        this._type = 'number';
        this._flags.unsafe = false;
        this._invalids.add(Infinity);
        this._invalids.add(-Infinity);
    }

    _base(value, state, options) {

        const result = {
            errors: null,
            value
        };

        if (typeof value === 'string' &&
            options.convert) {

            const matches = value.match(/^\s*[+-]?\d+(?:\.\d+)?(?:e([+-]?\d+))?\s*$/i);
            if (matches) {

                value = value.trim();
                result.value = parseFloat(value);

                if (!this._flags.unsafe) {
                    if (value.includes('e')) {
                        if (internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`) !== internals.normalizeExponent(value)) {
                            result.errors = this.createError('number.unsafe', { value }, state, options);
                            return result;
                        }
                    }
                    else {
                        if (result.value.toString() !== internals.normalizeDecimal(value)) {
                            result.errors = this.createError('number.unsafe', { value }, state, options);
                            return result;
                        }
                    }
                }
            }
        }

        const isNumber = typeof result.value === 'number' && !isNaN(result.value);

        if (options.convert && 'precision' in this._flags && isNumber) {

            // This is conceptually equivalent to using toFixed but it should be much faster
            const precision = Math.pow(10, this._flags.precision);
            result.value = Math.round(result.value * precision) / precision;
        }

        if (isNumber) {
            if (!this._flags.unsafe &&
                (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {
                result.errors = this.createError('number.unsafe', { value }, state, options);
            }
        }
        else {
            result.errors = this.createError('number.base', { value }, state, options);
        }

        return result;
    }

    multiple(base) {

        const isRef = Ref.isRef(base);

        if (!isRef) {
            Hoek.assert(typeof base === 'number' && isFinite(base), 'multiple must be a number');
            Hoek.assert(base > 0, 'multiple must be greater than 0');
        }

        return this._test('multiple', base, function (value, state, options) {

            const divisor = isRef ? base(state.reference || state.parent, options) : base;

            if (isRef && (typeof divisor !== 'number' || !isFinite(divisor))) {
                return this.createError('number.ref', { ref: base.key }, state, options);
            }

            if (value % divisor === 0) {
                return value;
            }

            return this.createError('number.multiple', { multiple: base, value }, state, options);
        });
    }

    integer() {

        return this._test('integer', undefined, function (value, state, options) {

            return Math.trunc(value) - value === 0 ? value : this.createError('number.integer', { value }, state, options);
        });
    }

    unsafe(enabled = true) {

        Hoek.assert(typeof enabled === 'boolean', 'enabled must be a boolean');

        if (this._flags.unsafe === enabled) {
            return this;
        }

        const obj = this.clone();
        obj._flags.unsafe = enabled;
        return obj;
    }

    negative() {

        return this._test('negative', undefined, function (value, state, options) {

            if (value < 0) {
                return value;
            }

            return this.createError('number.negative', { value }, state, options);
        });
    }

    positive() {

        return this._test('positive', undefined, function (value, state, options) {

            if (value > 0) {
                return value;
            }

            return this.createError('number.positive', { value }, state, options);
        });
    }

    precision(limit) {

        Hoek.assert(Number.isSafeInteger(limit), 'limit must be an integer');
        Hoek.assert(!('precision' in this._flags), 'precision already set');

        const obj = this._test('precision', limit, function (value, state, options) {

            const places = value.toString().match(internals.precisionRx);
            const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
            if (decimals <= limit) {
                return value;
            }

            return this.createError('number.precision', { limit, value }, state, options);
        });

        obj._flags.precision = limit;
        return obj;
    }

    port() {

        return this._test('port', undefined, function (value, state, options) {

            if (!Number.isSafeInteger(value) || value < 0 || value > 65535) {
                return this.createError('number.port', { value }, state, options);
            }

            return value;
        });
    }

};


internals.compare = function (type, compare) {

    return function (limit) {

        const isRef = Ref.isRef(limit);
        const isNumber = typeof limit === 'number' && !isNaN(limit);

        Hoek.assert(isNumber || isRef, 'limit must be a number or reference');

        return this._test(type, limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!(typeof compareTo === 'number' && !isNaN(compareTo))) {
                    return this.createError('number.ref', { ref: limit.key }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (compare(value, compareTo)) {
                return value;
            }

            return this.createError('number.' + type, { limit: compareTo, value }, state, options);
        });
    };
};


internals.Number.prototype.min = internals.compare('min', (value, limit) => value >= limit);
internals.Number.prototype.max = internals.compare('max', (value, limit) => value <= limit);
internals.Number.prototype.greater = internals.compare('greater', (value, limit) => value > limit);
internals.Number.prototype.less = internals.compare('less', (value, limit) => value < limit);


module.exports = new internals.Number();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/object/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./node_modules/@hapi/topo/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Errors = __webpack_require__(/*! ../../errors */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/errors.js");
const Cast = __webpack_require__(/*! ../../cast */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/cast.js");
const State = __webpack_require__(/*! ../state */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js");


const internals = {};


internals.Object = class extends Any {

    constructor() {

        super();
        this._type = 'object';
        this._inner.children = null;
        this._inner.renames = [];
        this._inner.dependencies = [];
        this._inner.patterns = [];
    }

    _init(...args) {

        return args.length ? this.keys(...args) : this;
    }

    _base(value, state, options) {

        let target = value;
        const errors = [];
        const finish = () => {

            return {
                value: target,
                errors: errors.length ? errors : null
            };
        };

        if (typeof value === 'string' &&
            options.convert) {

            if (value.length > 1 &&
                (value[0] === '{' || /^\s*\{/.test(value))) {

                try {
                    value = Bourne.parse(value);
                }
                catch (e) { }
            }
        }

        const type = this._flags.func ? 'function' : 'object';
        if (!value ||
            typeof value !== type ||
            Array.isArray(value)) {

            errors.push(this.createError(type + '.base', { value }, state, options));
            return finish();
        }

        // Skip if there are no other rules to test

        if (!this._inner.renames.length &&
            !this._inner.dependencies.length &&
            !this._inner.children &&                    // null allows any keys
            !this._inner.patterns.length) {

            target = value;
            return finish();
        }

        // Ensure target is a local copy (parsed) or shallow copy

        if (target === value) {
            if (type === 'object') {
                target = Object.create(Object.getPrototypeOf(value));
            }
            else {
                target = function (...args) {

                    return value.apply(this, args);
                };

                target.prototype = Hoek.clone(value.prototype);
            }

            const valueKeys = Object.keys(value);
            for (let i = 0; i < valueKeys.length; ++i) {
                target[valueKeys[i]] = value[valueKeys[i]];
            }
        }
        else {
            target = value;
        }

        // Rename keys

        const renamed = {};
        for (let i = 0; i < this._inner.renames.length; ++i) {
            const rename = this._inner.renames[i];

            if (rename.isRegExp) {
                const targetKeys = Object.keys(target);
                const matchedTargetKeys = [];

                for (let j = 0; j < targetKeys.length; ++j) {
                    if (rename.from.test(targetKeys[j])) {
                        matchedTargetKeys.push(targetKeys[j]);
                    }
                }

                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);
                if (rename.options.ignoreUndefined && allUndefined) {
                    continue;
                }

                if (!rename.options.multiple &&
                    renamed[rename.to]) {

                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&
                    !rename.options.override &&
                    !renamed[rename.to]) {

                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (allUndefined) {
                    delete target[rename.to];
                }
                else {
                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];
                }

                renamed[rename.to] = true;

                if (!rename.options.alias) {
                    for (let j = 0; j < matchedTargetKeys.length; ++j) {
                        delete target[matchedTargetKeys[j]];
                    }
                }
            }
            else {
                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {
                    continue;
                }

                if (!rename.options.multiple &&
                    renamed[rename.to]) {

                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&
                    !rename.options.override &&
                    !renamed[rename.to]) {

                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));
                    if (options.abortEarly) {
                        return finish();
                    }
                }

                if (target[rename.from] === undefined) {
                    delete target[rename.to];
                }
                else {
                    target[rename.to] = target[rename.from];
                }

                renamed[rename.to] = true;

                if (!rename.options.alias) {
                    delete target[rename.from];
                }
            }
        }

        // Validate schema

        if (!this._inner.children &&            // null allows any keys
            !this._inner.patterns.length &&
            !this._inner.dependencies.length) {

            return finish();
        }

        const unprocessed = new Set(Object.keys(target));

        if (this._inner.children) {
            const stripProps = [];

            for (let i = 0; i < this._inner.children.length; ++i) {
                const child = this._inner.children[i];
                const key = child.key;
                const item = target[key];

                unprocessed.delete(key);

                const localState = new State(key, [...state.path, key], target, state.reference);
                const result = child.schema._validate(item, localState, options);
                if (result.errors) {
                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));

                    if (options.abortEarly) {
                        return finish();
                    }
                }
                else {
                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {
                        stripProps.push(key);
                        target[key] = result.finalValue;
                    }
                    else if (result.value !== undefined) {
                        target[key] = result.value;
                    }
                }
            }

            for (let i = 0; i < stripProps.length; ++i) {
                delete target[stripProps[i]];
            }
        }

        // Unknown keys

        if (unprocessed.size && this._inner.patterns.length) {

            for (const key of unprocessed) {
                const localState = new State(key, [...state.path, key], target, state.reference);
                const item = target[key];

                for (let i = 0; i < this._inner.patterns.length; ++i) {
                    const pattern = this._inner.patterns[i];

                    if (pattern.regex ?
                        pattern.regex.test(key) :
                        !pattern.schema._validate(key, state, { ...options, abortEarly:true }).errors) {

                        unprocessed.delete(key);

                        const result = pattern.rule._validate(item, localState, options);
                        if (result.errors) {
                            errors.push(this.createError('object.child', {
                                key,
                                child: pattern.rule._getLabel(key),
                                reason: result.errors
                            }, localState, options));

                            if (options.abortEarly) {
                                return finish();
                            }
                        }

                        target[key] = result.value;
                    }
                }
            }
        }

        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {
            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||
                options.skipFunctions) {

                const stripUnknown = options.stripUnknown
                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)
                    : false;


                for (const key of unprocessed) {
                    if (stripUnknown) {
                        delete target[key];
                        unprocessed.delete(key);
                    }
                    else if (typeof target[key] === 'function') {
                        unprocessed.delete(key);
                    }
                }
            }

            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {

                for (const unprocessedKey of unprocessed) {
                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey, value: target[unprocessedKey] }, {
                        key: unprocessedKey,
                        path: [...state.path, unprocessedKey]
                    }, options, {}));
                }
            }
        }

        // Validate dependencies

        for (let i = 0; i < this._inner.dependencies.length; ++i) {
            const dep = this._inner.dependencies[i];
            const hasKey = dep.key !== null;
            const splitKey = hasKey && dep.key.split('.');
            const localState = hasKey ? new State(splitKey[splitKey.length - 1], [...state.path, ...splitKey]) : new State(null, state.path);
            const err = internals[dep.type].call(this, dep.key, hasKey && Hoek.reach(target, dep.key, { functions: true }), dep.peers, target, localState, options);
            if (err instanceof Errors.Err) {
                errors.push(err);
                if (options.abortEarly) {
                    return finish();
                }
            }
        }

        return finish();
    }

    keys(schema) {

        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');

        const obj = this.clone();

        if (!schema) {
            obj._inner.children = null;
            return obj;
        }

        const children = Object.keys(schema);

        if (!children.length) {
            obj._inner.children = [];
            return obj;
        }

        const topo = new Topo();
        if (obj._inner.children) {
            for (let i = 0; i < obj._inner.children.length; ++i) {
                const child = obj._inner.children[i];

                // Only add the key if we are not going to replace it later
                if (!children.includes(child.key)) {
                    topo.add(child, { after: child._refs, group: child.key });
                }
            }
        }

        for (let i = 0; i < children.length; ++i) {
            const key = children[i];
            const child = schema[key];
            try {
                const cast = Cast.schema(this._currentJoi, child);
                topo.add({ key, schema: cast }, { after: cast._refs, group: key });
            }
            catch (castErr) {
                if (castErr.hasOwnProperty('path')) {
                    castErr.path = key + '.' + castErr.path;
                }
                else {
                    castErr.path = key;
                }

                throw castErr;
            }
        }

        obj._inner.children = topo.nodes;

        return obj;
    }

    append(schema) {
        // Skip any changes
        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {
            return this;
        }

        return this.keys(schema);
    }

    unknown(allow) {

        const value = allow !== false;

        if (this._flags.allowUnknown === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.allowUnknown = value;
        return obj;
    }

    length(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('length', limit, function (value, state, options) {

            if (Object.keys(value).length === limit) {
                return value;
            }

            return this.createError('object.length', { limit, value }, state, options);
        });
    }

    min(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('min', limit, function (value, state, options) {

            if (Object.keys(value).length >= limit) {
                return value;
            }

            return this.createError('object.min', { limit, value }, state, options);
        });
    }

    max(limit) {

        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');

        return this._test('max', limit, function (value, state, options) {

            if (Object.keys(value).length <= limit) {
                return value;
            }

            return this.createError('object.max', { limit, value }, state, options);
        });
    }

    pattern(pattern, schema) {

        const isRegExp = pattern instanceof RegExp;
        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');
        Hoek.assert(schema !== undefined, 'Invalid rule');

        if (isRegExp) {
            Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
        }

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        const obj = this.clone();
        if (isRegExp) {
            obj._inner.patterns.push({ regex: pattern, rule: schema });
        }
        else {
            obj._inner.patterns.push({ schema: pattern, rule: schema });
        }

        return obj;
    }

    schema() {

        return this._test('schema', null, function (value, state, options) {

            if (value instanceof Any) {
                return value;
            }

            return this.createError('object.schema', null, state, options);
        });
    }

    with(key, peers) {

        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

        return this._dependency('with', key, peers);
    }

    without(key, peers) {

        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');

        return this._dependency('without', key, peers);
    }

    xor(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('xor', null, peers);
    }

    oxor(...peers) {

        return this._dependency('oxor', null, peers);
    }

    or(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('or', null, peers);
    }

    and(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('and', null, peers);
    }

    nand(...peers) {

        peers = Hoek.flatten(peers);
        return this._dependency('nand', null, peers);
    }

    requiredKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'required');
    }

    optionalKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'optional');
    }

    forbiddenKeys(...children) {

        children = Hoek.flatten(children);
        return this.applyFunctionToChildren(children, 'forbidden');
    }

    rename(from, to, options) {

        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');
        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);

        for (let i = 0; i < this._inner.renames.length; ++i) {
            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');
        }

        const obj = this.clone();

        obj._inner.renames.push({
            from,
            to,
            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),
            isRegExp: from instanceof RegExp
        });

        return obj;
    }

    applyFunctionToChildren(children, fn, args = [], root) {

        children = [].concat(children);
        Hoek.assert(children.length > 0, 'expected at least one children');

        const groupedChildren = internals.groupChildren(children);
        let obj;

        if ('' in groupedChildren) {
            obj = this[fn](...args);
            delete groupedChildren[''];
        }
        else {
            obj = this.clone();
        }

        if (obj._inner.children) {
            root = root ? (root + '.') : '';

            for (let i = 0; i < obj._inner.children.length; ++i) {
                const child = obj._inner.children[i];
                const group = groupedChildren[child.key];

                if (group) {
                    obj._inner.children[i] = {
                        key: child.key,
                        _refs: child._refs,
                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)
                    };

                    delete groupedChildren[child.key];
                }
            }
        }

        const remaining = Object.keys(groupedChildren);
        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));

        return obj;
    }

    _dependency(type, key, peers) {

        peers = [].concat(peers);
        for (let i = 0; i < peers.length; ++i) {
            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');
        }

        const obj = this.clone();
        obj._inner.dependencies.push({ type, key, peers });
        return obj;
    }

    describe(shallow) {

        const description = super.describe();

        if (description.rules) {
            for (let i = 0; i < description.rules.length; ++i) {
                const rule = description.rules[i];
                // Coverage off for future-proof descriptions, only object().assert() is use right now
                if (/* $lab:coverage:off$ */rule.arg &&
                    typeof rule.arg === 'object' &&
                    rule.arg.schema &&
                    rule.arg.ref /* $lab:coverage:on$ */) {
                    rule.arg = {
                        schema: rule.arg.schema.describe(),
                        ref: rule.arg.ref.toString()
                    };
                }
            }
        }

        if (this._inner.children &&
            !shallow) {

            description.children = {};
            for (let i = 0; i < this._inner.children.length; ++i) {
                const child = this._inner.children[i];
                description.children[child.key] = child.schema.describe();
            }
        }

        if (this._inner.dependencies.length) {
            description.dependencies = Hoek.clone(this._inner.dependencies);
        }

        if (this._inner.patterns.length) {
            description.patterns = [];

            for (let i = 0; i < this._inner.patterns.length; ++i) {
                const pattern = this._inner.patterns[i];
                if (pattern.regex) {
                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });
                }
                else {
                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });
                }
            }
        }

        if (this._inner.renames.length > 0) {
            description.renames = Hoek.clone(this._inner.renames);
        }

        return description;
    }

    assert(ref, schema, message) {

        ref = Cast.ref(ref);
        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');
        message = message || 'pass the assertion test';
        Hoek.assert(typeof message === 'string', 'Message must be a string');

        try {
            schema = Cast.schema(this._currentJoi, schema);
        }
        catch (castErr) {
            if (castErr.hasOwnProperty('path')) {
                castErr.message = `${castErr.message}(${castErr.path})`;
            }

            throw castErr;
        }

        const key = ref.path[ref.path.length - 1];
        const path = ref.path.join('.');

        return this._test('assert', { schema, ref }, function (value, state, options) {

            const result = schema._validate(ref(value), null, options, value);
            if (!result.errors) {
                return value;
            }

            const localState = new State(key, ref.path, state.parent, state.reference);
            return this.createError('object.assert', { ref: path, message }, localState, options);
        });
    }

    type(constructor, name = constructor.name) {

        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');
        const typeData = {
            name,
            ctor: constructor
        };

        return this._test('type', typeData, function (value, state, options) {

            if (value instanceof constructor) {
                return value;
            }

            return this.createError('object.type', { type: typeData.name, value }, state, options);
        });
    }
};


internals.renameDefaults = {
    alias: false,                   // Keep old value in place
    multiple: false,                // Allow renaming multiple keys into the same target
    override: false                 // Overrides an existing key
};


internals.groupChildren = function (children) {

    children.sort();

    const grouped = {};

    for (let i = 0; i < children.length; ++i) {
        const child = children[i];
        Hoek.assert(typeof child === 'string', 'children must be strings');
        const group = child.split('.')[0];
        const childGroup = grouped[group] = (grouped[group] || []);
        childGroup.push(child.substring(group.length + 1));
    }

    return grouped;
};


internals.keysToLabels = function (schema, keys) {

    const children = schema._inner.children;

    if (!children) {
        return keys;
    }

    const findLabel = function (key) {

        const matchingChild = schema._currentJoi.reach(schema, key);
        return matchingChild ? matchingChild._getLabel(key) : key;
    };

    if (Array.isArray(keys)) {
        return keys.map(findLabel);
    }

    return findLabel(keys);
};


internals.with = function (key, value, peers, parent, state, options) {

    if (value === undefined) {
        return;
    }

    for (let i = 0; i < peers.length; ++i) {

        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist === undefined) {

            return this.createError('object.with', {
                main: key,
                mainWithLabel: internals.keysToLabels(this, key),
                peer,
                peerWithLabel: internals.keysToLabels(this, peer)
            }, state, options);
        }
    }
};


internals.without = function (key, value, peers, parent, state, options) {

    if (value === undefined) {
        return;
    }

    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {

            return this.createError('object.without', {
                main: key,
                mainWithLabel: internals.keysToLabels(this, key),
                peer,
                peerWithLabel: internals.keysToLabels(this, peer)
            }, state, options);
        }
    }
};


internals.xor = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            present.push(peer);
        }
    }

    if (present.length === 1) {
        return;
    }

    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };

    if (present.length === 0) {
        return this.createError('object.missing', context, state, options);
    }

    context.present = present;
    context.presentWithLabels = internals.keysToLabels(this, present);

    return this.createError('object.xor', context, state, options);
};


internals.oxor = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            present.push(peer);
        }
    }

    if (!present.length ||
        present.length === 1) {

        return;
    }

    const context = { peers, peersWithLabels: internals.keysToLabels(this, peers) };
    context.present = present;
    context.presentWithLabels = internals.keysToLabels(this, present);

    return this.createError('object.oxor', context, state, options);
};


internals.or = function (key, value, peers, parent, state, options) {

    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {
            return;
        }
    }

    return this.createError('object.missing', {
        peers,
        peersWithLabels: internals.keysToLabels(this, peers)
    }, state, options);
};


internals.and = function (key, value, peers, parent, state, options) {

    const missing = [];
    const present = [];
    const count = peers.length;
    for (let i = 0; i < count; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist === undefined) {

            missing.push(peer);
        }
        else {
            present.push(peer);
        }
    }

    const aon = (missing.length === count || present.length === count);

    if (!aon) {

        return this.createError('object.and', {
            present,
            presentWithLabels: internals.keysToLabels(this, present),
            missing,
            missingWithLabels: internals.keysToLabels(this, missing)
        }, state, options);
    }
};


internals.nand = function (key, value, peers, parent, state, options) {

    const present = [];
    for (let i = 0; i < peers.length; ++i) {
        const peer = peers[i];
        const keysExist = Hoek.reach(parent, peer, { functions: true });
        if (keysExist !== undefined) {

            present.push(peer);
        }
    }

    const main = peers[0];
    const values = peers.slice(1);
    const allPresent = (present.length === peers.length);
    return allPresent ? this.createError('object.nand', {
        main,
        mainWithLabel: internals.keysToLabels(this, main),
        peers: values,
        peersWithLabels: internals.keysToLabels(this, values)
    }, state, options) : null;
};


module.exports = new internals.Object();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/state.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = class {
    constructor(key, path, parent, reference) {

        this.key = key;
        this.path = path;
        this.parent = parent;
        this.reference = reference;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Net = __webpack_require__(/*! net */ "net");

const Address = __webpack_require__(/*! @hapi/address */ "./node_modules/@hapi/address/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");
const Ref = __webpack_require__(/*! ../../ref */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/ref.js");
const JoiDate = __webpack_require__(/*! ../date */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/date/index.js");

const Uri = __webpack_require__(/*! ./uri */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/uri.js");
const Ip = __webpack_require__(/*! ./ip */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/ip.js");


const internals = {
    uriRegex: Uri.createUriRegex(),
    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
    guidBrackets: {
        '{': '}', '[': ']', '(': ')', '': ''
    },
    guidVersions: {
        uuidv1: '1',
        uuidv2: '2',
        uuidv3: '3',
        uuidv4: '4',
        uuidv5: '5'
    },
    cidrPresences: ['required', 'optional', 'forbidden'],
    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};


internals.String = class extends Any {

    constructor() {

        super();
        this._type = 'string';
        this._invalids.add('');
    }

    _base(value, state, options) {

        if (typeof value === 'string' &&
            options.convert) {

            if (this._flags.normalize) {
                value = value.normalize(this._flags.normalize);
            }

            if (this._flags.case) {
                value = (this._flags.case === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase());
            }

            if (this._flags.trim) {
                value = value.trim();
            }

            if (this._inner.replacements) {

                for (let i = 0; i < this._inner.replacements.length; ++i) {
                    const replacement = this._inner.replacements[i];
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }

            if (this._flags.truncate) {
                for (let i = 0; i < this._tests.length; ++i) {
                    const test = this._tests[i];
                    if (test.name === 'max') {
                        value = value.slice(0, test.arg);
                        break;
                    }
                }
            }

            if (this._flags.byteAligned && value.length % 2 !== 0) {
                value = `0${value}`;
            }
        }

        return {
            value,
            errors: (typeof value === 'string') ? null : this.createError('string.base', { value }, state, options)
        };
    }

    insensitive() {

        if (this._flags.insensitive) {
            return this;
        }

        const obj = this.clone();
        obj._flags.insensitive = true;
        return obj;
    }

    creditCard() {

        return this._test('creditCard', undefined, function (value, state, options) {

            let i = value.length;
            let sum = 0;
            let mul = 1;

            while (i--) {
                const char = value.charAt(i) * mul;
                sum = sum + (char - (char > 9) * 9);
                mul = mul ^ 3;
            }

            const check = (sum % 10 === 0) && (sum > 0);
            return check ? value : this.createError('string.creditCard', { value }, state, options);
        });
    }

    regex(pattern, patternOptions) {

        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Hoek.assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');

        const patternObject = { pattern };

        if (typeof patternOptions === 'string') {
            patternObject.name = patternOptions;
        }
        else if (typeof patternOptions === 'object') {
            patternObject.invert = !!patternOptions.invert;

            if (patternOptions.name) {
                patternObject.name = patternOptions.name;
            }
        }

        const errorCode = ['string.regex', patternObject.invert ? '.invert' : '', patternObject.name ? '.name' : '.base'].join('');

        return this._test('regex', patternObject, function (value, state, options) {

            const patternMatch = patternObject.pattern.test(value);

            if (patternMatch ^ patternObject.invert) {
                return value;
            }

            return this.createError(errorCode, { name: patternObject.name, pattern: patternObject.pattern, value }, state, options);
        });
    }

    alphanum() {

        return this._test('alphanum', undefined, function (value, state, options) {

            if (/^[a-zA-Z0-9]+$/.test(value)) {
                return value;
            }

            return this.createError('string.alphanum', { value }, state, options);
        });
    }

    token() {

        return this._test('token', undefined, function (value, state, options) {

            if (/^\w+$/.test(value)) {
                return value;
            }

            return this.createError('string.token', { value }, state, options);
        });
    }

    email(validationOptions) {

        if (validationOptions) {
            Hoek.assert(typeof validationOptions === 'object', 'email options must be an object');

            // Migration validation for unsupported options

            Hoek.assert(validationOptions.checkDNS === undefined, 'checkDNS option is not supported');
            Hoek.assert(validationOptions.errorLevel === undefined, 'errorLevel option is not supported');
            Hoek.assert(validationOptions.minDomainAtoms === undefined, 'minDomainAtoms option is not supported, use minDomainSegments instead');
            Hoek.assert(validationOptions.tldBlacklist === undefined, 'tldBlacklist option is not supported, use tlds.deny instead');
            Hoek.assert(validationOptions.tldWhitelist === undefined, 'tldWhitelist option is not supported, use tlds.allow instead');

            // Validate options

            if (validationOptions.tlds &&
                typeof validationOptions.tlds === 'object') {

                Hoek.assert(validationOptions.tlds.allow === undefined ||
                    validationOptions.tlds.allow === false ||
                    validationOptions.tlds.allow === true ||
                    Array.isArray(validationOptions.tlds.allow) ||
                    validationOptions.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');

                Hoek.assert(validationOptions.tlds.deny === undefined ||
                    Array.isArray(validationOptions.tlds.deny) ||
                    validationOptions.tlds.deny instanceof Set, 'tlds.deny must be an array or Set');

                const normalizeTable = (table) => {

                    if (table === undefined ||
                        typeof table === 'boolean' ||
                        table instanceof Set) {

                        return table;
                    }

                    return new Set(table);
                };

                validationOptions = Object.assign({}, validationOptions);       // Shallow cloned
                validationOptions.tlds = {
                    allow: normalizeTable(validationOptions.tlds.allow),
                    deny: normalizeTable(validationOptions.tlds.deny)
                };
            }

            Hoek.assert(validationOptions.minDomainSegments === undefined ||
                Number.isSafeInteger(validationOptions.minDomainSegments) && validationOptions.minDomainSegments > 0, 'minDomainSegments must be a positive integer');
        }

        return this._test('email', validationOptions, function (value, state, options) {

            if (Address.email.isValid(value, validationOptions)) {
                return value;
            }

            return this.createError('string.email', { value }, state, options);
        });
    }

    ip(ipOptions = {}) {

        let regex = internals.ipRegex;
        Hoek.assert(typeof ipOptions === 'object', 'options must be an object');

        if (ipOptions.cidr) {
            Hoek.assert(typeof ipOptions.cidr === 'string', 'cidr must be a string');
            ipOptions.cidr = ipOptions.cidr.toLowerCase();

            Hoek.assert(Hoek.contain(internals.cidrPresences, ipOptions.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));

            // If we only received a `cidr` setting, create a regex for it. But we don't need to create one if `cidr` is "optional" since that is the default
            if (!ipOptions.version && ipOptions.cidr !== 'optional') {
                regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], ipOptions.cidr);
            }
        }
        else {

            // Set our default cidr strategy
            ipOptions.cidr = 'optional';
        }

        let versions;
        if (ipOptions.version) {
            if (!Array.isArray(ipOptions.version)) {
                ipOptions.version = [ipOptions.version];
            }

            Hoek.assert(ipOptions.version.length >= 1, 'version must have at least 1 version specified');

            versions = [];
            for (let i = 0; i < ipOptions.version.length; ++i) {
                let version = ipOptions.version[i];
                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                version = version.toLowerCase();
                Hoek.assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
                versions.push(version);
            }

            // Make sure we have a set of versions
            versions = Array.from(new Set(versions));

            regex = Ip.createIpRegex(versions, ipOptions.cidr);
        }

        return this._test('ip', ipOptions, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            if (versions) {
                return this.createError('string.ipVersion', { value, cidr: ipOptions.cidr, version: versions }, state, options);
            }

            return this.createError('string.ip', { value, cidr: ipOptions.cidr }, state, options);
        });
    }

    uri(uriOptions) {

        let customScheme = '';
        let allowRelative = false;
        let relativeOnly = false;
        let allowQuerySquareBrackets = false;
        let regex = internals.uriRegex;

        if (uriOptions) {
            Hoek.assert(typeof uriOptions === 'object', 'options must be an object');

            const unknownOptions = Object.keys(uriOptions).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets'].includes(key));
            Hoek.assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);

            if (uriOptions.scheme) {
                Hoek.assert(uriOptions.scheme instanceof RegExp || typeof uriOptions.scheme === 'string' || Array.isArray(uriOptions.scheme), 'scheme must be a RegExp, String, or Array');

                if (!Array.isArray(uriOptions.scheme)) {
                    uriOptions.scheme = [uriOptions.scheme];
                }

                Hoek.assert(uriOptions.scheme.length >= 1, 'scheme must have at least 1 scheme specified');

                // Flatten the array into a string to be used to match the schemes.
                for (let i = 0; i < uriOptions.scheme.length; ++i) {
                    const scheme = uriOptions.scheme[i];
                    Hoek.assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

                    // Add OR separators if a value already exists
                    customScheme = customScheme + (customScheme ? '|' : '');

                    // If someone wants to match HTTP or HTTPS for example then we need to support both RegExp and String so we don't escape their pattern unknowingly.
                    if (scheme instanceof RegExp) {
                        customScheme = customScheme + scheme.source;
                    }
                    else {
                        Hoek.assert(/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                        customScheme = customScheme + Hoek.escapeRegex(scheme);
                    }
                }
            }

            if (uriOptions.allowRelative) {
                allowRelative = true;
            }

            if (uriOptions.relativeOnly) {
                relativeOnly = true;
            }

            if (uriOptions.allowQuerySquareBrackets) {
                allowQuerySquareBrackets = true;
            }
        }

        if (customScheme || allowRelative || relativeOnly || allowQuerySquareBrackets) {
            regex = Uri.createUriRegex(customScheme, allowRelative, relativeOnly, allowQuerySquareBrackets);
        }

        return this._test('uri', uriOptions, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            if (relativeOnly) {
                return this.createError('string.uriRelativeOnly', { value }, state, options);
            }

            if (customScheme) {
                return this.createError('string.uriCustomScheme', { scheme: customScheme, value }, state, options);
            }

            return this.createError('string.uri', { value }, state, options);
        });
    }

    isoDate() {

        return this._test('isoDate', undefined, function (value, state, options) {

            if (JoiDate._isIsoDate(value)) {
                if (!options.convert) {
                    return value;
                }

                const d = new Date(value);
                if (!isNaN(d.getTime())) {
                    return d.toISOString();
                }
            }

            return this.createError('string.isoDate', { value }, state, options);
        });
    }

    guid(guidOptions) {

        let versionNumbers = '';

        if (guidOptions && guidOptions.version) {
            if (!Array.isArray(guidOptions.version)) {
                guidOptions.version = [guidOptions.version];
            }

            Hoek.assert(guidOptions.version.length >= 1, 'version must have at least 1 valid version specified');
            const versions = new Set();

            for (let i = 0; i < guidOptions.version.length; ++i) {
                let version = guidOptions.version[i];
                Hoek.assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                version = version.toLowerCase();
                const versionNumber = internals.guidVersions[version];
                Hoek.assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                Hoek.assert(!(versions.has(versionNumber)), 'version at position ' + i + ' must not be a duplicate.');

                versionNumbers += versionNumber;
                versions.add(versionNumber);
            }
        }

        const guidRegex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, 'i');

        return this._test('guid', guidOptions, function (value, state, options) {

            const results = guidRegex.exec(value);

            if (!results) {
                return this.createError('string.guid', { value }, state, options);
            }

            // Matching braces
            if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                return this.createError('string.guid', { value }, state, options);
            }

            return value;
        });
    }

    hex(hexOptions = {}) {

        Hoek.assert(typeof hexOptions === 'object', 'hex options must be an object');
        Hoek.assert(typeof hexOptions.byteAligned === 'undefined' || typeof hexOptions.byteAligned === 'boolean',
            'byteAligned must be boolean');

        const byteAligned = hexOptions.byteAligned === true;
        const regex = /^[a-f0-9]+$/i;

        const obj = this._test('hex', regex, function (value, state, options) {

            if (regex.test(value)) {
                if (byteAligned && value.length % 2 !== 0) {
                    return this.createError('string.hexAlign', { value }, state, options);
                }

                return value;
            }

            return this.createError('string.hex', { value }, state, options);
        });

        if (byteAligned) {
            obj._flags.byteAligned = true;
        }

        return obj;
    }

    base64(base64Options = {}) {

        // Validation.
        Hoek.assert(typeof base64Options === 'object', 'base64 options must be an object');
        Hoek.assert(typeof base64Options.paddingRequired === 'undefined' || typeof base64Options.paddingRequired === 'boolean',
            'paddingRequired must be boolean');

        // Determine if padding is required.
        const paddingRequired = base64Options.paddingRequired === false ?
            base64Options.paddingRequired
            : base64Options.paddingRequired || true;

        // Set validation based on preference.
        const regex = paddingRequired ?
            // Padding is required.
            /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
            // Padding is optional.
            : /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;

        return this._test('base64', regex, function (value, state, options) {

            if (regex.test(value)) {
                return value;
            }

            return this.createError('string.base64', { value }, state, options);
        });
    }

    dataUri(dataUriOptions = {}) {

        const regex = /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/;

        // Determine if padding is required.
        const paddingRequired = dataUriOptions.paddingRequired === false ?
            dataUriOptions.paddingRequired
            : dataUriOptions.paddingRequired || true;

        const base64regex = paddingRequired ?
            /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
            : /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/;

        return this._test('dataUri', regex, function (value, state, options) {

            const matches = value.match(regex);

            if (matches) {
                if (!matches[2]) {
                    return value;
                }

                if (matches[2] !== 'base64') {
                    return value;
                }

                if (base64regex.test(matches[3])) {
                    return value;
                }
            }

            return this.createError('string.dataUri', { value }, state, options);
        });
    }

    hostname() {

        const regex = /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/;

        return this._test('hostname', undefined, function (value, state, options) {

            if ((value.length <= 255 && regex.test(value)) ||
                Net.isIPv6(value)) {

                return value;
            }

            return this.createError('string.hostname', { value }, state, options);
        });
    }

    normalize(form = 'NFC') {

        Hoek.assert(Hoek.contain(internals.normalizationForms, form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

        const obj = this._test('normalize', form, function (value, state, options) {

            if (options.convert ||
                value === value.normalize(form)) {

                return value;
            }

            return this.createError('string.normalize', { value, form }, state, options);
        });

        obj._flags.normalize = form;
        return obj;
    }

    lowercase() {

        const obj = this._test('lowercase', undefined, function (value, state, options) {

            if (options.convert ||
                value === value.toLocaleLowerCase()) {

                return value;
            }

            return this.createError('string.lowercase', { value }, state, options);
        });

        obj._flags.case = 'lower';
        return obj;
    }

    uppercase() {

        const obj = this._test('uppercase', undefined, function (value, state, options) {

            if (options.convert ||
                value === value.toLocaleUpperCase()) {

                return value;
            }

            return this.createError('string.uppercase', { value }, state, options);
        });

        obj._flags.case = 'upper';
        return obj;
    }

    trim(enabled = true) {

        Hoek.assert(typeof enabled === 'boolean', 'option must be a boolean');

        if ((this._flags.trim && enabled) || (!this._flags.trim && !enabled)) {
            return this;
        }

        let obj;
        if (enabled) {
            obj = this._test('trim', undefined, function (value, state, options) {

                if (options.convert ||
                    value === value.trim()) {

                    return value;
                }

                return this.createError('string.trim', { value }, state, options);
            });
        }
        else {
            obj = this.clone();
            obj._tests = obj._tests.filter((test) => test.name !== 'trim');
        }

        obj._flags.trim = enabled;
        return obj;
    }

    replace(pattern, replacement) {

        if (typeof pattern === 'string') {
            pattern = new RegExp(Hoek.escapeRegex(pattern), 'g');
        }

        Hoek.assert(pattern instanceof RegExp, 'pattern must be a RegExp');
        Hoek.assert(typeof replacement === 'string', 'replacement must be a String');

        // This can not be considere a test like trim, we can't "reject"
        // anything from this rule, so just clone the current object
        const obj = this.clone();

        if (!obj._inner.replacements) {
            obj._inner.replacements = [];
        }

        obj._inner.replacements.push({
            pattern,
            replacement
        });

        return obj;
    }

    truncate(enabled) {

        const value = enabled === undefined ? true : !!enabled;

        if (this._flags.truncate === value) {
            return this;
        }

        const obj = this.clone();
        obj._flags.truncate = value;
        return obj;
    }

};

internals.compare = function (type, compare) {

    return function (limit, encoding) {

        const isRef = Ref.isRef(limit);

        Hoek.assert((Number.isSafeInteger(limit) && limit >= 0) || isRef, 'limit must be a positive integer or reference');
        Hoek.assert(!encoding || Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

        return this._test(type, limit, function (value, state, options) {

            let compareTo;
            if (isRef) {
                compareTo = limit(state.reference || state.parent, options);

                if (!Number.isSafeInteger(compareTo)) {
                    return this.createError('string.ref', { ref: limit, value: compareTo }, state, options);
                }
            }
            else {
                compareTo = limit;
            }

            if (compare(value, compareTo, encoding)) {
                return value;
            }

            return this.createError('string.' + type, { limit: compareTo, value, encoding }, state, options);
        });
    };
};


internals.String.prototype.min = internals.compare('min', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length >= limit;
});


internals.String.prototype.max = internals.compare('max', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length <= limit;
});


internals.String.prototype.length = internals.compare('length', (value, limit, encoding) => {

    const length = encoding ? Buffer.byteLength(value, encoding) : value.length;
    return length === limit;
});

// Aliases

internals.String.prototype.uuid = internals.String.prototype.guid;

module.exports = new internals.String();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/ip.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/ip.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RFC3986 = __webpack_require__(/*! ./rfc3986 */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js");


const internals = {
    Ip: {
        cidrs: {
            ipv4: {
                required: '\\/(?:' + RFC3986.ipv4Cidr + ')',
                optional: '(?:\\/(?:' + RFC3986.ipv4Cidr + '))?',
                forbidden: ''
            },
            ipv6: {
                required: '\\/' + RFC3986.ipv6Cidr,
                optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                forbidden: ''
            },
            ipvfuture: {
                required: '\\/' + RFC3986.ipv6Cidr,
                optional: '(?:\\/' + RFC3986.ipv6Cidr + ')?',
                forbidden: ''
            }
        },
        versions: {
            ipv4: RFC3986.IPv4address,
            ipv6: RFC3986.IPv6address,
            ipvfuture: RFC3986.IPvFuture
        }
    }
};


internals.Ip.createIpRegex = function (versions, cidr) {

    let regex;
    for (let i = 0; i < versions.length; ++i) {
        const version = versions[i];
        if (!regex) {
            regex = '^(?:' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        }
        else {
            regex += '|' + internals.Ip.versions[version] + internals.Ip.cidrs[version][cidr];
        }
    }

    return new RegExp(regex + ')$');
};

module.exports = internals.Ip;


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {
    rfc3986: {}
};


internals.generate = function () {

    /**
     * elements separated by forward slash ("/") are alternatives.
     */
    const or = '|';

    /**
     * Rule to support zero-padded addresses.
     */
    const zeroPad = '0?';

    /**
     * DIGIT = %x30-39 ; 0-9
     */
    const digit = '0-9';
    const digitOnly = '[' + digit + ']';

    /**
     * ALPHA = %x41-5A / %x61-7A   ; A-Z / a-z
     */
    const alpha = 'a-zA-Z';
    const alphaOnly = '[' + alpha + ']';

    /**
     * IPv4
     * cidr       = DIGIT                ; 0-9
     *            / %x31-32 DIGIT         ; 10-29
     *            / "3" %x30-32           ; 30-32
     */
    internals.rfc3986.ipv4Cidr = digitOnly + or + '[1-2]' + digitOnly + or + '3' + '[0-2]';

    /**
     * IPv6
     * cidr       = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" %x0-1 DIGIT       ; 100-119
     *            / "12" %x0-8            ; 120-128
     */
    internals.rfc3986.ipv6Cidr = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + '[01]' + digitOnly + or + '12[0-8])';

    /**
     * HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
     */
    const hexDigit = digit + 'A-Fa-f';
    const hexDigitOnly = '[' + hexDigit + ']';

    /**
     * unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
     */
    const unreserved = alpha + digit + '-\\._~';

    /**
     * sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
     */
    const subDelims = '!\\$&\'\\(\\)\\*\\+,;=';

    /**
     * pct-encoded = "%" HEXDIG HEXDIG
     */
    const pctEncoded = '%' + hexDigit;

    /**
     * pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
     */
    const pchar = unreserved + pctEncoded + subDelims + ':@';
    const pcharOnly = '[' + pchar + ']';

    /**
     * squareBrackets example: []
     */
    const squareBrackets = '\\[\\]';

    /**
     * dec-octet   = DIGIT                 ; 0-9
     *            / %x31-39 DIGIT         ; 10-99
     *            / "1" 2DIGIT            ; 100-199
     *            / "2" %x30-34 DIGIT     ; 200-249
     *            / "25" %x30-35          ; 250-255
     */
    const decOctect = '(?:' + zeroPad + zeroPad + digitOnly + or + zeroPad + '[1-9]' + digitOnly + or + '1' + digitOnly + digitOnly + or + '2' + '[0-4]' + digitOnly + or + '25' + '[0-5])';

    /**
     * IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
     */
    internals.rfc3986.IPv4address = '(?:' + decOctect + '\\.){3}' + decOctect;

    /**
     * h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
     * ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
     * IPv6address =                            6( h16 ":" ) ls32
     *             /                       "::" 5( h16 ":" ) ls32
     *             / [               h16 ] "::" 4( h16 ":" ) ls32
     *             / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
     *             / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
     *             / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
     *             / [ *4( h16 ":" ) h16 ] "::"              ls32
     *             / [ *5( h16 ":" ) h16 ] "::"              h16
     *             / [ *6( h16 ":" ) h16 ] "::"
     */
    const h16 = hexDigitOnly + '{1,4}';
    const ls32 = '(?:' + h16 + ':' + h16 + '|' + internals.rfc3986.IPv4address + ')';
    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';
    internals.rfc3986.IPv6address = '(?:' + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ')';

    /**
     * IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
     */
    internals.rfc3986.IPvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';

    /**
     * scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
     */
    internals.rfc3986.scheme = alphaOnly + '[' + alpha + digit + '+-\\.]*';

    /**
     * userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
     */
    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';

    /**
     * IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
     */
    const IPLiteral = '\\[(?:' + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ')\\]';

    /**
     * reg-name = *( unreserved / pct-encoded / sub-delims )
     */
    const regName = '[' + unreserved + pctEncoded + subDelims + ']{0,255}';

    /**
     * host = IP-literal / IPv4address / reg-name
     */
    const host = '(?:' + IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ')';

    /**
     * port = *DIGIT
     */
    const port = digitOnly + '*';

    /**
     * authority   = [ userinfo "@" ] host [ ":" port ]
     */
    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';

    /**
     * segment       = *pchar
     * segment-nz    = 1*pchar
     * path          = path-abempty    ; begins with "/" or is empty
     *               / path-absolute   ; begins with "/" but not "//"
     *               / path-noscheme   ; begins with a non-colon segment
     *               / path-rootless   ; begins with a segment
     *               / path-empty      ; zero characters
     * path-abempty  = *( "/" segment )
     * path-absolute = "/" [ segment-nz *( "/" segment ) ]
     * path-rootless = segment-nz *( "/" segment )
     */
    const segment = pcharOnly + '*';
    const segmentNz = pcharOnly + '+';
    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
    const pathEmpty = '';
    const pathAbEmpty = '(?:\\/' + segment + ')*';
    const pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;

    /**
     * hier-part = "//" authority path
     */
    internals.rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + or + pathAbsolute + or + pathRootless + ')';

    /**
     * relative-part = "//" authority path-abempty
     *                 / path-absolute
     *                 / path-noscheme
     *                 / path-empty
     */
    internals.rfc3986.relativeRef = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty  + ')' + or + pathAbsolute + or + pathNoScheme + or + pathEmpty + ')';

    /**
     * query = *( pchar / "/" / "?" )
     */
    internals.rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

    /**
     * query = *( pchar / "[" / "]" / "/" / "?" )
     */
    internals.rfc3986.queryWithSquareBrackets = '[' + pchar + squareBrackets + '\\/\\?]*(?=#|$)'; //Finish matching either at the fragment part or end of the line.

    /**
     * fragment = *( pchar / "/" / "?" )
     */
    internals.rfc3986.fragment = '[' + pchar + '\\/\\?]*';
};


internals.generate();

module.exports = internals.rfc3986;


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/uri.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/uri.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const RFC3986 = __webpack_require__(/*! ./rfc3986 */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/string/rfc3986.js");


const internals = {
    Uri: {
        createUriRegex: function (optionalScheme, allowRelative, relativeOnly, allowQuerySquareBrackets) {

            let scheme = RFC3986.scheme;
            let prefix;

            if (relativeOnly) {
                prefix = '(?:' + RFC3986.relativeRef + ')';
            }
            else {
                // If we were passed a scheme, use it instead of the generic one
                if (optionalScheme) {

                    // Have to put this in a non-capturing group to handle the OR statements
                    scheme = '(?:' + optionalScheme + ')';
                }

                const withScheme = '(?:' + scheme + ':' + RFC3986.hierPart + ')';

                prefix = allowRelative ? '(?:' + withScheme + '|' + RFC3986.relativeRef + ')' : withScheme;
            }

            /**
             * URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
             *
             * OR
             *
             * relative-ref = relative-part [ "?" query ] [ "#" fragment ]
             */
            return new RegExp('^' + prefix + '(?:\\?' + (allowQuerySquareBrackets ? RFC3986.queryWithSquareBrackets : RFC3986.query) + ')?' + '(?:#' + RFC3986.fragment + ')?$');
        }
    }
};

module.exports = internals.Uri;


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbol/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbol/index.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Util = __webpack_require__(/*! util */ "util");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/any/index.js");


const internals = {};


internals.Map = class extends Map {

    slice() {

        return new internals.Map(this);
    }

    toString() {

        return Util.inspect(this);
    }
};


internals.Symbol = class extends Any {

    constructor() {

        super();
        this._type = 'symbol';
        this._inner.map = new internals.Map();
    }

    _base(value, state, options) {

        if (options.convert) {
            const lookup = this._inner.map.get(value);
            if (lookup) {
                value = lookup;
            }

            if (this._flags.allowOnly) {
                return {
                    value,
                    errors: (typeof value === 'symbol') ? null : this.createError('symbol.map', { value, map: this._inner.map }, state, options)
                };
            }
        }

        return {
            value,
            errors: (typeof value === 'symbol') ? null : this.createError('symbol.base', { value }, state, options)
        };
    }

    map(iterable) {

        if (iterable && !iterable[Symbol.iterator] && typeof iterable === 'object') {
            iterable = Object.entries(iterable);
        }

        Hoek.assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');
        const obj = this.clone();

        const symbols = [];
        for (const entry of iterable) {
            Hoek.assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');
            const [key, value] = entry;

            Hoek.assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be an object, function, or Symbol');
            Hoek.assert(typeof value === 'symbol', 'Value must be a Symbol');
            obj._inner.map.set(key, value);
            symbols.push(value);
        }

        return obj.valid(...symbols);
    }

    describe() {

        const description = super.describe();
        description.map = new Map(this._inner.map);
        return description;
    }
};


module.exports = new internals.Symbol();


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/lib/types/symbols.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = {
    settingsCache: Symbol('settingsCache')
};


/***/ }),

/***/ "./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json":
/*!*********************************************************************!*\
  !*** ./node_modules/@hapi/hapi/node_modules/@hapi/joi/package.json ***!
  \*********************************************************************/
/*! exports provided: name, description, version, homepage, repository, main, keywords, dependencies, devDependencies, scripts, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/joi\",\"description\":\"Object schema validation\",\"version\":\"15.1.1\",\"homepage\":\"https://github.com/hapijs/joi\",\"repository\":\"git://github.com/hapijs/joi\",\"main\":\"lib/index.js\",\"keywords\":[\"schema\",\"validation\"],\"dependencies\":{\"@hapi/address\":\"2.x.x\",\"@hapi/bourne\":\"1.x.x\",\"@hapi/hoek\":\"8.x.x\",\"@hapi/topo\":\"3.x.x\"},\"devDependencies\":{\"@hapi/code\":\"6.x.x\",\"@hapi/lab\":\"20.x.x\"},\"scripts\":{\"test\":\"lab -t 100 -a @hapi/code -L\",\"test-cov-html\":\"lab -r html -o coverage.html -a @hapi/code\"},\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/hapi/package.json":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hapi/package.json ***!
  \**********************************************/
/*! exports provided: name, description, homepage, version, repository, main, keywords, dependencies, devDependencies, scripts, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/hapi\",\"description\":\"HTTP Server framework\",\"homepage\":\"https://hapijs.com\",\"version\":\"18.4.0\",\"repository\":\"git://github.com/hapijs/hapi\",\"main\":\"lib/index.js\",\"keywords\":[\"framework\",\"http\",\"api\",\"web\"],\"dependencies\":{\"@hapi/accept\":\"3.x.x\",\"@hapi/ammo\":\"3.x.x\",\"@hapi/boom\":\"7.x.x\",\"@hapi/bounce\":\"1.x.x\",\"@hapi/call\":\"5.x.x\",\"@hapi/catbox\":\"10.x.x\",\"@hapi/catbox-memory\":\"4.x.x\",\"@hapi/heavy\":\"6.x.x\",\"@hapi/hoek\":\"8.x.x\",\"@hapi/joi\":\"15.x.x\",\"@hapi/mimos\":\"4.x.x\",\"@hapi/podium\":\"3.x.x\",\"@hapi/shot\":\"4.x.x\",\"@hapi/somever\":\"2.x.x\",\"@hapi/statehood\":\"6.x.x\",\"@hapi/subtext\":\"6.x.x\",\"@hapi/teamwork\":\"3.x.x\",\"@hapi/topo\":\"3.x.x\"},\"devDependencies\":{\"@hapi/code\":\"6.x.x\",\"@hapi/inert\":\"5.x.x\",\"@hapi/joi-next-test\":\"npm:@hapi/joi@16.x.x\",\"@hapi/lab\":\"20.x.x\",\"@hapi/wreck\":\"15.x.x\",\"@hapi/vision\":\"5.x.x\",\"handlebars\":\"4.x.x\"},\"scripts\":{\"test\":\"lab -a @hapi/code -t 100 -L -m 5000\",\"test-tap\":\"lab -a @hapi/code -r tap -o tests.tap -m 5000\",\"test-cov-html\":\"lab -a @hapi/code -r html -o coverage.html -m 5000\"},\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/heavy/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/heavy/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {};


internals.schema = Joi.object({
    sampleInterval: Joi.number().min(0),
    maxHeapUsedBytes: Joi.number().min(0),
    maxEventLoopDelay: Joi.number().min(0),
    maxRssBytes: Joi.number().min(0)
})
    .unknown();


internals.defaults = {
    sampleInterval: 0,                          // Frequency of load sampling in milliseconds (zero is no sampling)
    maxHeapUsedBytes: 0,                        // Reject requests when V8 heap is over size in bytes (zero is no max)
    maxRssBytes: 0,                             // Reject requests when process RSS is over size in bytes (zero is no max)
    maxEventLoopDelay: 0                        // Milliseconds of delay after which requests are rejected (zero is no max)
};


exports = module.exports = internals.Heavy = function (options) {

    options = options || {};

    Joi.assert(options, internals.schema, 'Invalid load monitoring options');
    this.settings = Hoek.applyToDefaults(internals.defaults, options);
    Hoek.assert(this.settings.sampleInterval || (!this.settings.maxEventLoopDelay && !this.settings.maxHeapUsedBytes && !this.settings.maxRssBytes), 'Load sample interval must be set to enable load limits');

    this._eventLoopTimer = null;
    this._loadBench = new Hoek.Bench();
    this.load = {
        eventLoopDelay: 0,
        heapUsed: 0,
        rss: 0
    };
};


internals.Heavy.prototype.start = function () {

    if (!this.settings.sampleInterval) {
        return;
    }

    const loopSample = () => {

        this._loadBench.reset();
        const measure = () => {

            const mem = process.memoryUsage();

            // Retain the same this.load object to keep external references valid

            this.load.eventLoopDelay = (this._loadBench.elapsed() - this.settings.sampleInterval);
            this.load.heapUsed = mem.heapUsed;
            this.load.rss = mem.rss;

            loopSample();
        };

        this._eventLoopTimer = setTimeout(measure, this.settings.sampleInterval);
    };

    loopSample();
};


internals.Heavy.prototype.stop = function () {

    clearTimeout(this._eventLoopTimer);
    this._eventLoopTimer = null;
};


internals.Heavy.prototype.check = function () {

    if (!this.settings.sampleInterval) {
        return;
    }

    Hoek.assert(this._eventLoopTimer, 'Cannot check load when sampler is not started');

    const elapsed = this._loadBench.elapsed();
    const load = this.load;

    if (elapsed > this.settings.sampleInterval) {
        load.eventLoopDelay = Math.max(load.eventLoopDelay, elapsed - this.settings.sampleInterval);
    }

    if (this.settings.maxEventLoopDelay &&
        load.eventLoopDelay > this.settings.maxEventLoopDelay) {

        throw Boom.serverUnavailable('Server under heavy load (event loop)', load);
    }

    if (this.settings.maxHeapUsedBytes &&
        load.heapUsed > this.settings.maxHeapUsedBytes) {

        throw Boom.serverUnavailable('Server under heavy load (heap)', load);
    }

    if (this.settings.maxRssBytes &&
        load.rss > this.settings.maxRssBytes) {

        throw Boom.serverUnavailable('Server under heavy load (rss)', load);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/applyToDefaults.js":
/*!********************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/applyToDefaults.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Merge = __webpack_require__(/*! ./merge */ "./node_modules/@hapi/hoek/lib/merge.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = function (defaults, source, options = {}) {

    Assert(defaults && typeof defaults === 'object', 'Invalid defaults value: must be an object');
    Assert(!source || source === true || typeof source === 'object', 'Invalid source value: must be true, falsy or an object');
    Assert(typeof options === 'object', 'Invalid options: must be an object');

    if (!source) {                                                  // If no source, return null
        return null;
    }

    if (options.shallow) {
        return internals.applyToDefaultsWithShallow(defaults, source, options);
    }

    const copy = Clone(defaults);

    if (source === true) {                                          // If source is set to true, use defaults
        return copy;
    }

    const nullOverride = options.nullOverride !== undefined ? options.nullOverride : false;
    return Merge(copy, source, { nullOverride, mergeArrays: false });
};


internals.applyToDefaultsWithShallow = function (defaults, source, options) {

    const keys = options.shallow;
    Assert(Array.isArray(keys), 'Invalid keys');

    options = Object.assign({}, options);
    options.shallow = false;

    const copy = Clone(defaults, { shallow: keys });

    if (source === true) {                                                      // If source is set to true, use defaults
        return copy;
    }

    const storage = Utils.store(source, keys);                              // Move shallow copy items to storage
    Merge(copy, source, { mergeArrays: false, nullOverride: false });   // Deep copy the rest
    Utils.restore(copy, source, storage);                                   // Shallow copy the stored items and restore
    return copy;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/assert.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/assert.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const AssertError = __webpack_require__(/*! ./error */ "./node_modules/@hapi/hoek/lib/error.js");

const internals = {};


module.exports = function (condition, ...args) {

    if (condition) {
        return;
    }

    if (args.length === 1 &&
        args[0] instanceof Error) {

        throw args[0];
    }

    throw new AssertError(args);
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/bench.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/bench.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = internals.Bench = class {

    constructor() {

        this.ts = 0;
        this.reset();
    }

    reset() {

        this.ts = internals.Bench.now();
    }

    elapsed() {

        return internals.Bench.now() - this.ts;
    }

    static now() {

        const ts = process.hrtime();
        return (ts[0] * 1e3) + (ts[1] / 1e6);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/block.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/block.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Ignore = __webpack_require__(/*! ./ignore */ "./node_modules/@hapi/hoek/lib/ignore.js");


const internals = {};


module.exports = function () {

    return new Promise(Ignore);         // $lab:coverage:ignore$
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/clone.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/clone.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Types = __webpack_require__(/*! ./types */ "./node_modules/@hapi/hoek/lib/types.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {
    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])
};


module.exports = internals.clone = function (obj, options = {}, _seen = null) {

    if (typeof obj !== 'object' ||
        obj === null) {

        return obj;
    }

    let clone = internals.clone;
    let seen = _seen;

    if (options.shallow) {
        if (options.shallow !== true) {
            return internals.cloneWithShallow(obj, options);
        }

        clone = (value) => value;
    }
    else {
        seen = seen || new Map();

        const lookup = seen.get(obj);
        if (lookup) {
            return lookup;
        }
    }

    // Built-in object types

    const baseProto = Types.getInternalProto(obj);
    if (baseProto === Types.buffer) {
        return Buffer && Buffer.from(obj);              // $lab:coverage:ignore$
    }

    if (baseProto === Types.date) {
        return new Date(obj.getTime());
    }

    if (baseProto === Types.regex) {
        return new RegExp(obj);
    }

    // Generic objects

    const newObj = internals.base(obj, baseProto, options);
    if (newObj === obj) {
        return obj;
    }

    if (seen) {
        seen.set(obj, newObj);                              // Set seen, since obj could recurse
    }

    if (baseProto === Types.set) {
        for (const value of obj) {
            newObj.add(clone(value, options, seen));
        }
    }
    else if (baseProto === Types.map) {
        for (const [key, value] of obj) {
            newObj.set(key, clone(value, options, seen));
        }
    }

    const keys = Utils.keys(obj, options);
    for (const key of keys) {
        if (baseProto === Types.array &&
            key === 'length') {

            newObj.length = obj.length;
            continue;
        }

        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
            if (descriptor.get ||
                descriptor.set) {

                Object.defineProperty(newObj, key, descriptor);
            }
            else if (descriptor.enumerable) {
                newObj[key] = clone(obj[key], options, seen);
            }
            else {
                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });
            }
        }
        else {
            Object.defineProperty(newObj, key, {
                enumerable: true,
                writable: true,
                configurable: true,
                value: clone(obj[key], options, seen)
            });
        }
    }

    return newObj;
};


internals.cloneWithShallow = function (source, options) {

    const keys = options.shallow;
    options = Object.assign({}, options);
    options.shallow = false;

    const storage = Utils.store(source, keys);    // Move shallow copy items to storage
    const copy = internals.clone(source, options);      // Deep copy the rest
    Utils.restore(copy, source, storage);         // Shallow copy the stored items and restore
    return copy;
};


internals.base = function (obj, baseProto, options) {

    if (baseProto === Types.array) {
        return [];
    }

    if (options.prototype === false) {                  // Defaults to true
        if (internals.needsProtoHack.has(baseProto)) {
            return new baseProto.constructor();
        }

        return {};
    }

    const proto = Object.getPrototypeOf(obj);
    if (proto &&
        proto.isImmutable) {

        return obj;
    }

    if (internals.needsProtoHack.has(baseProto)) {
        const newObj = new proto.constructor();
        if (proto !== baseProto) {
            Object.setPrototypeOf(newObj, proto);
        }

        return newObj;
    }

    return Object.create(proto);
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/contain.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/contain.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! ./deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const EscapeRegex = __webpack_require__(/*! ./escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = function (ref, values, options = {}) {        // options: { deep, once, only, part, symbols }

    /*
        string -> string(s)
        array -> item(s)
        object -> key(s)
        object -> object (key:value)
    */

    if (typeof values !== 'object') {
        values = [values];
    }

    Assert(!Array.isArray(values) || values.length, 'Values array cannot be empty');

    // String

    if (typeof ref === 'string') {
        return internals.string(ref, values, options);
    }

    // Array

    if (Array.isArray(ref)) {
        return internals.array(ref, values, options);
    }

    // Object

    Assert(typeof ref === 'object', 'Reference must be string or an object');
    return internals.object(ref, values, options);
};


internals.array = function (ref, values, options) {

    if (!Array.isArray(values)) {
        values = [values];
    }

    if (!ref.length) {
        return false;
    }

    if (options.only &&
        options.once &&
        ref.length !== values.length) {

        return false;
    }

    let compare;

    // Map values

    const map = new Map();
    for (const value of values) {
        if (!options.deep ||
            !value ||
            typeof value !== 'object') {

            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
        else {
            compare = compare || internals.compare(options);

            let found = false;
            for (const [key, existing] of map.entries()) {
                if (compare(key, value)) {
                    ++existing.allowed;
                    found = true;
                    break;
                }
            }

            if (!found) {
                map.set(value, { allowed: 1, hits: 0 });
            }
        }
    }

    // Lookup values

    let hits = 0;
    for (const item of ref) {
        let match;
        if (!options.deep ||
            !item ||
            typeof item !== 'object') {

            match = map.get(item);
        }
        else {
            for (const [key, existing] of map.entries()) {
                if (compare(key, item)) {
                    match = existing;
                    break;
                }
            }
        }

        if (match) {
            ++match.hits;
            ++hits;

            if (options.once &&
                match.hits > match.allowed) {

                return false;
            }
        }
    }

    // Validate results

    if (options.only &&
        hits !== ref.length) {

        return false;
    }

    for (const match of map.values()) {
        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }
    }

    return !!hits;
};


internals.object = function (ref, values, options) {

    Assert(options.once === undefined, 'Cannot use option once with object');

    const keys = Utils.keys(ref, options);
    if (!keys.length) {
        return false;
    }

    // Keys list

    if (Array.isArray(values)) {
        return internals.array(keys, values, options);
    }

    // Key value pairs

    const symbols = Object.getOwnPropertySymbols(values).filter((sym) => values.propertyIsEnumerable(sym));
    const targets = [...Object.keys(values), ...symbols];

    const compare = internals.compare(options);
    const set = new Set(targets);

    for (const key of keys) {
        if (!set.has(key)) {
            if (options.only) {
                return false;
            }

            continue;
        }

        if (!compare(values[key], ref[key])) {
            return false;
        }

        set.delete(key);
    }

    if (set.size) {
        return options.part ? set.size < targets.length : false;
    }

    return true;
};


internals.string = function (ref, values, options) {

    // Empty string

    if (ref === '') {
        return values.length === 1 && values[0] === '' ||               // '' contains ''
            !options.once && !values.some((v) => v !== '');             // '' contains multiple '' if !once
    }

    // Map values

    const map = new Map();
    const patterns = [];

    for (const value of values) {
        Assert(typeof value === 'string', 'Cannot compare string reference to non-string value');

        if (value) {
            const existing = map.get(value);
            if (existing) {
                ++existing.allowed;
            }
            else {
                map.set(value, { allowed: 1, hits: 0 });
                patterns.push(EscapeRegex(value));
            }
        }
        else if (options.once ||
            options.only) {

            return false;
        }
    }

    if (!patterns.length) {                     // Non-empty string contains unlimited empty string
        return true;
    }

    // Match patterns

    const regex = new RegExp(`(${patterns.join('|')})`, 'g');
    const leftovers = ref.replace(regex, ($0, $1) => {

        ++map.get($1).hits;
        return '';                              // Remove from string
    });

    // Validate results

    if (options.only &&
        leftovers) {

        return false;
    }

    let any = false;
    for (const match of map.values()) {
        if (match.hits) {
            any = true;
        }

        if (match.hits === match.allowed) {
            continue;
        }

        if (match.hits < match.allowed &&
            !options.part) {

            return false;
        }

        // match.hits > match.allowed

        if (options.once) {
            return false;
        }
    }

    return !!any;
};


internals.compare = function (options) {

    if (!options.deep) {
        return internals.shallow;
    }

    const hasOnly = options.only !== undefined;
    const hasPart = options.part !== undefined;

    const flags = {
        prototype: hasOnly ? options.only : hasPart ? !options.part : false,
        part: hasOnly ? !options.only : hasPart ? options.part : false
    };

    return (a, b) => DeepEqual(a, b, flags);
};


internals.shallow = function (a, b) {

    return a === b;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/deepEqual.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/deepEqual.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Types = __webpack_require__(/*! ./types */ "./node_modules/@hapi/hoek/lib/types.js");


const internals = {
    mismatched: null
};


module.exports = function (obj, ref, options) {

    options = Object.assign({ prototype: true }, options);

    return !!internals.isDeepEqual(obj, ref, options, []);
};


internals.isDeepEqual = function (obj, ref, options, seen) {

    if (obj === ref) {                                                      // Copied from Deep-eql, copyright(c) 2013 Jake Luer, jake@alogicalparadox.com, MIT Licensed, https://github.com/chaijs/deep-eql
        return obj !== 0 || 1 / obj === 1 / ref;
    }

    const type = typeof obj;

    if (type !== typeof ref) {
        return false;
    }

    if (obj === null ||
        ref === null) {

        return false;
    }

    if (type === 'function') {
        if (!options.deepFunction ||
            obj.toString() !== ref.toString()) {

            return false;
        }

        // Continue as object
    }
    else if (type !== 'object') {
        return obj !== obj && ref !== ref;                                  // NaN
    }

    const instanceType = internals.getSharedType(obj, ref, !!options.prototype);
    switch (instanceType) {
        case Types.buffer:
            return Buffer && Buffer.prototype.equals.call(obj, ref);        // $lab:coverage:ignore$
        case Types.promise:
            return obj === ref;
        case Types.regex:
            return obj.toString() === ref.toString();
        case internals.mismatched:
            return false;
    }

    for (let i = seen.length - 1; i >= 0; --i) {
        if (seen[i].isSame(obj, ref)) {
            return true;                                                    // If previous comparison failed, it would have stopped execution
        }
    }

    seen.push(new internals.SeenEntry(obj, ref));

    try {
        return !!internals.isDeepEqualObj(instanceType, obj, ref, options, seen);
    }
    finally {
        seen.pop();
    }
};


internals.getSharedType = function (obj, ref, checkPrototype) {

    if (checkPrototype) {
        if (Object.getPrototypeOf(obj) !== Object.getPrototypeOf(ref)) {
            return internals.mismatched;
        }

        return Types.getInternalProto(obj);
    }

    const type = Types.getInternalProto(obj);
    if (type !== Types.getInternalProto(ref)) {
        return internals.mismatched;
    }

    return type;
};


internals.valueOf = function (obj) {

    const objValueOf = obj.valueOf;
    if (objValueOf === undefined) {
        return obj;
    }

    try {
        return objValueOf.call(obj);
    }
    catch (err) {
        return err;
    }
};


internals.hasOwnEnumerableProperty = function (obj, key) {

    return Object.prototype.propertyIsEnumerable.call(obj, key);
};


internals.isSetSimpleEqual = function (obj, ref) {

    for (const entry of obj) {
        if (!ref.has(entry)) {
            return false;
        }
    }

    return true;
};


internals.isDeepEqualObj = function (instanceType, obj, ref, options, seen) {

    const { isDeepEqual, valueOf, hasOwnEnumerableProperty } = internals;
    const { keys, getOwnPropertySymbols } = Object;

    if (instanceType === Types.array) {
        if (options.part) {

            // Check if any index match any other index

            for (const objValue of obj) {
                for (const refValue of ref) {
                    if (isDeepEqual(objValue, refValue, options, seen)) {
                        return true;
                    }
                }
            }
        }
        else {
            if (obj.length !== ref.length) {
                return false;
            }

            for (let i = 0; i < obj.length; ++i) {
                if (!isDeepEqual(obj[i], ref[i], options, seen)) {
                    return false;
                }
            }

            return true;
        }
    }
    else if (instanceType === Types.set) {
        if (obj.size !== ref.size) {
            return false;
        }

        if (!internals.isSetSimpleEqual(obj, ref)) {

            // Check for deep equality

            const ref2 = new Set(ref);
            for (const objEntry of obj) {
                if (ref2.delete(objEntry)) {
                    continue;
                }

                let found = false;
                for (const refEntry of ref2) {
                    if (isDeepEqual(objEntry, refEntry, options, seen)) {
                        ref2.delete(refEntry);
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    return false;
                }
            }
        }
    }
    else if (instanceType === Types.map) {
        if (obj.size !== ref.size) {
            return false;
        }

        for (const [key, value] of obj) {
            if (value === undefined && !ref.has(key)) {
                return false;
            }

            if (!isDeepEqual(value, ref.get(key), options, seen)) {
                return false;
            }
        }
    }
    else if (instanceType === Types.error) {

        // Always check name and message

        if (obj.name !== ref.name ||
            obj.message !== ref.message) {

            return false;
        }
    }

    // Check .valueOf()

    const valueOfObj = valueOf(obj);
    const valueOfRef = valueOf(ref);
    if ((obj !== valueOfObj || ref !== valueOfRef) &&
        !isDeepEqual(valueOfObj, valueOfRef, options, seen)) {

        return false;
    }

    // Check properties

    const objKeys = keys(obj);
    if (!options.part &&
        objKeys.length !== keys(ref).length &&
        !options.skip) {

        return false;
    }

    let skipped = 0;
    for (const key of objKeys) {
        if (options.skip &&
            options.skip.includes(key)) {

            if (ref[key] === undefined) {
                ++skipped;
            }

            continue;
        }

        if (!hasOwnEnumerableProperty(ref, key)) {
            return false;
        }

        if (!isDeepEqual(obj[key], ref[key], options, seen)) {
            return false;
        }
    }

    if (!options.part &&
        objKeys.length - skipped !== keys(ref).length) {

        return false;
    }

    // Check symbols

    if (options.symbols !== false) {                                // Defaults to true
        const objSymbols = getOwnPropertySymbols(obj);
        const refSymbols = new Set(getOwnPropertySymbols(ref));

        for (const key of objSymbols) {
            if (!options.skip ||
                !options.skip.includes(key)) {

                if (hasOwnEnumerableProperty(obj, key)) {
                    if (!hasOwnEnumerableProperty(ref, key)) {
                        return false;
                    }

                    if (!isDeepEqual(obj[key], ref[key], options, seen)) {
                        return false;
                    }
                }
                else if (hasOwnEnumerableProperty(ref, key)) {
                    return false;
                }
            }

            refSymbols.delete(key);
        }

        for (const key of refSymbols) {
            if (hasOwnEnumerableProperty(ref, key)) {
                return false;
            }
        }
    }

    return true;
};


internals.SeenEntry = class {

    constructor(obj, ref) {

        this.obj = obj;
        this.ref = ref;
    }

    isSame(obj, ref) {

        return this.obj === obj && this.ref === ref;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/error.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/error.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stringify = __webpack_require__(/*! ./stringify */ "./node_modules/@hapi/hoek/lib/stringify.js");


const internals = {};


module.exports = class extends Error {

    constructor(args) {

        const msgs = args
            .filter((arg) => arg !== '')
            .map((arg) => {

                return typeof arg === 'string' ? arg : arg instanceof Error ? arg.message : Stringify(arg);
            });

        super(msgs.join(' ') || 'Unknown error');

        if (typeof Error.captureStackTrace === 'function') {            // $lab:coverage:ignore$
            Error.captureStackTrace(this, exports.assert);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js":
/*!**************************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = function (attribute) {

    // Allowed value characters: !#$%&'()*+,-./:;<=>?@[]^_`{|}~ and space, a-z, A-Z, 0-9, \, "

    Assert(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(attribute), 'Bad attribute value (' + attribute + ')');

    return attribute.replace(/\\/g, '\\\\').replace(/\"/g, '\\"');                             // Escape quotes and slash
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeHtml.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeHtml.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    let escaped = '';

    for (let i = 0; i < input.length; ++i) {

        const charCode = input.charCodeAt(i);

        if (internals.isSafe(charCode)) {
            escaped += input[i];
        }
        else {
            escaped += internals.escapeHtmlChar(charCode);
        }
    }

    return escaped;
};


internals.escapeHtmlChar = function (charCode) {

    const namedEscape = internals.namedHtml[charCode];
    if (typeof namedEscape !== 'undefined') {
        return namedEscape;
    }

    if (charCode >= 256) {
        return '&#' + charCode + ';';
    }

    const hexValue = charCode.toString(16).padStart(2, '0');
    return `&#x${hexValue};`;
};


internals.isSafe = function (charCode) {

    return (typeof internals.safeCharCodes[charCode] !== 'undefined');
};


internals.namedHtml = {
    '38': '&amp;',
    '60': '&lt;',
    '62': '&gt;',
    '34': '&quot;',
    '160': '&nbsp;',
    '162': '&cent;',
    '163': '&pound;',
    '164': '&curren;',
    '169': '&copy;',
    '174': '&reg;'
};


internals.safeCharCodes = (function () {

    const safe = {};

    for (let i = 32; i < 123; ++i) {

        if ((i >= 97) ||                    // a-z
            (i >= 65 && i <= 90) ||         // A-Z
            (i >= 48 && i <= 57) ||         // 0-9
            i === 32 ||                     // space
            i === 46 ||                     // .
            i === 44 ||                     // ,
            i === 45 ||                     // -
            i === 58 ||                     // :
            i === 95) {                     // _

            safe[i] = null;
        }
    }

    return safe;
}());


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeJson.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeJson.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (input) {

    if (!input) {
        return '';
    }

    const lessThan = 0x3C;
    const greaterThan = 0x3E;
    const andSymbol = 0x26;
    const lineSeperator = 0x2028;

    // replace method
    let charCode;
    return input.replace(/[<>&\u2028\u2029]/g, (match) => {

        charCode = match.charCodeAt(0);

        if (charCode === lessThan) {
            return '\\u003c';
        }

        if (charCode === greaterThan) {
            return '\\u003e';
        }

        if (charCode === andSymbol) {
            return '\\u0026';
        }

        if (charCode === lineSeperator) {
            return '\\u2028';
        }

        return '\\u2029';
    });
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/escapeRegex.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/escapeRegex.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (string) {

    // Escape ^$.*+-?=!:|\/()[]{},

    return string.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, '\\$&');
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/flatten.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/flatten.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = internals.flatten = function (array, target) {

    const result = target || [];

    for (let i = 0; i < array.length; ++i) {
        if (Array.isArray(array[i])) {
            internals.flatten(array[i], result);
        }
        else {
            result.push(array[i]);
        }
    }

    return result;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/ignore.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/ignore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function () { };


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = {
    applyToDefaults: __webpack_require__(/*! ./applyToDefaults */ "./node_modules/@hapi/hoek/lib/applyToDefaults.js"),
    assert: __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js"),
    Bench: __webpack_require__(/*! ./bench */ "./node_modules/@hapi/hoek/lib/bench.js"),
    block: __webpack_require__(/*! ./block */ "./node_modules/@hapi/hoek/lib/block.js"),
    clone: __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js"),
    contain: __webpack_require__(/*! ./contain */ "./node_modules/@hapi/hoek/lib/contain.js"),
    deepEqual: __webpack_require__(/*! ./deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js"),
    Error: __webpack_require__(/*! ./error */ "./node_modules/@hapi/hoek/lib/error.js"),
    escapeHeaderAttribute: __webpack_require__(/*! ./escapeHeaderAttribute */ "./node_modules/@hapi/hoek/lib/escapeHeaderAttribute.js"),
    escapeHtml: __webpack_require__(/*! ./escapeHtml */ "./node_modules/@hapi/hoek/lib/escapeHtml.js"),
    escapeJson: __webpack_require__(/*! ./escapeJson */ "./node_modules/@hapi/hoek/lib/escapeJson.js"),
    escapeRegex: __webpack_require__(/*! ./escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js"),
    flatten: __webpack_require__(/*! ./flatten */ "./node_modules/@hapi/hoek/lib/flatten.js"),
    ignore: __webpack_require__(/*! ./ignore */ "./node_modules/@hapi/hoek/lib/ignore.js"),
    intersect: __webpack_require__(/*! ./intersect */ "./node_modules/@hapi/hoek/lib/intersect.js"),
    merge: __webpack_require__(/*! ./merge */ "./node_modules/@hapi/hoek/lib/merge.js"),
    once: __webpack_require__(/*! ./once */ "./node_modules/@hapi/hoek/lib/once.js"),
    reach: __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js"),
    reachTemplate: __webpack_require__(/*! ./reachTemplate */ "./node_modules/@hapi/hoek/lib/reachTemplate.js"),
    stringify: __webpack_require__(/*! ./stringify */ "./node_modules/@hapi/hoek/lib/stringify.js"),
    wait: __webpack_require__(/*! ./wait */ "./node_modules/@hapi/hoek/lib/wait.js")
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/intersect.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/intersect.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (array1, array2, options = {}) {

    if (!array1 ||
        !array2) {

        return (options.first ? null : []);
    }

    const common = [];
    const hash = (Array.isArray(array1) ? new Set(array1) : array1);
    const found = new Set();
    for (const value of array2) {
        if (internals.has(hash, value) &&
            !found.has(value)) {

            if (options.first) {
                return value;
            }

            common.push(value);
            found.add(value);
        }
    }

    return (options.first ? null : common);
};


internals.has = function (ref, key) {

    if (typeof ref.has === 'function') {
        return ref.has(key);
    }

    return ref[key] !== undefined;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/merge.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/merge.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! ./clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Utils = __webpack_require__(/*! ./utils */ "./node_modules/@hapi/hoek/lib/utils.js");


const internals = {};


module.exports = internals.merge = function (target, source, options) {

    Assert(target && typeof target === 'object', 'Invalid target value: must be an object');
    Assert(source === null || source === undefined || typeof source === 'object', 'Invalid source value: must be null, undefined, or an object');

    if (!source) {
        return target;
    }

    options = Object.assign({ nullOverride: true, mergeArrays: true }, options);

    if (Array.isArray(source)) {
        Assert(Array.isArray(target), 'Cannot merge array onto an object');
        if (!options.mergeArrays) {
            target.length = 0;                                                          // Must not change target assignment
        }

        for (let i = 0; i < source.length; ++i) {
            target.push(Clone(source[i], { symbols: options.symbols }));
        }

        return target;
    }

    const keys = Utils.keys(source, options);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === '__proto__' ||
            !Object.prototype.propertyIsEnumerable.call(source, key)) {

            continue;
        }

        const value = source[key];
        if (value &&
            typeof value === 'object') {

            if (!target[key] ||
                typeof target[key] !== 'object' ||
                (Array.isArray(target[key]) !== Array.isArray(value)) ||
                value instanceof Date ||
                (Buffer && Buffer.isBuffer(value)) ||               // $lab:coverage:ignore$
                value instanceof RegExp) {

                target[key] = Clone(value, { symbols: options.symbols });
            }
            else {
                internals.merge(target[key], value, options);
            }
        }
        else {
            if (value !== null &&
                value !== undefined) {                              // Explicit to preserve empty strings

                target[key] = value;
            }
            else if (options.nullOverride) {
                target[key] = value;
            }
        }
    }

    return target;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/once.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/once.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (method) {

    if (method._hoekOnce) {
        return method;
    }

    let once = false;
    const wrapped = function (...args) {

        if (!once) {
            once = true;
            method(...args);
        }
    };

    wrapped._hoekOnce = true;
    return wrapped;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/reach.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/reach.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! ./assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = function (obj, chain, options) {

    if (chain === false ||
        chain === null ||
        chain === undefined) {

        return obj;
    }

    options = options || {};
    if (typeof options === 'string') {
        options = { separator: options };
    }

    const isChainArray = Array.isArray(chain);

    Assert(!isChainArray || !options.separator, 'Separator option no valid for array-based chain');

    const path = isChainArray ? chain : chain.split(options.separator || '.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        let key = path[i];
        const type = options.iterables && internals.iterables(ref);

        if (Array.isArray(ref) ||
            type === 'set') {

            const number = Number(key);
            if (Number.isInteger(number)) {
                key = number < 0 ? ref.length + number : number;
            }
        }

        if (!ref ||
            typeof ref === 'function' && options.functions === false ||         // Defaults to true
            !type && ref[key] === undefined) {

            Assert(!options.strict || i + 1 === path.length, 'Missing segment', key, 'in reach path ', chain);
            Assert(typeof ref === 'object' || options.functions === true || typeof ref !== 'function', 'Invalid segment', key, 'in reach path ', chain);
            ref = options.default;
            break;
        }

        if (!type) {
            ref = ref[key];
        }
        else if (type === 'set') {
            ref = [...ref][key];
        }
        else {  // type === 'map'
            ref = ref.get(key);
        }
    }

    return ref;
};


internals.iterables = function (ref) {

    if (ref instanceof Set) {
        return 'set';
    }

    if (ref instanceof Map) {
        return 'map';
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/reachTemplate.js":
/*!******************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/reachTemplate.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");


const internals = {};


module.exports = function (obj, template, options) {

    return template.replace(/{([^}]+)}/g, ($0, chain) => {

        const value = Reach(obj, chain, options);
        return (value === undefined || value === null ? '' : value);
    });
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/stringify.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/stringify.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (...args) {

    try {
        return JSON.stringify.apply(null, args);
    }
    catch (err) {
        return '[Cannot display object: ' + err.message + ']';
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/types.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/types.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = {
    array: Array.prototype,
    buffer: Buffer && Buffer.prototype,             // $lab:coverage:ignore$
    date: Date.prototype,
    error: Error.prototype,
    generic: Object.prototype,
    map: Map.prototype,
    promise: Promise.prototype,
    regex: RegExp.prototype,
    set: Set.prototype,
    weakMap: WeakMap.prototype,
    weakSet: WeakSet.prototype
};


internals.typeMap = new Map([
    ['[object Error]', exports.error],
    ['[object Map]', exports.map],
    ['[object Promise]', exports.promise],
    ['[object Set]', exports.set],
    ['[object WeakMap]', exports.weakMap],
    ['[object WeakSet]', exports.weakSet]
]);


exports.getInternalProto = function (obj) {

    if (Array.isArray(obj)) {
        return exports.array;
    }

    if (Buffer && obj instanceof Buffer) {          // $lab:coverage:ignore$
        return exports.buffer;
    }

    if (obj instanceof Date) {
        return exports.date;
    }

    if (obj instanceof RegExp) {
        return exports.regex;
    }

    if (obj instanceof Error) {
        return exports.error;
    }

    const objName = Object.prototype.toString.call(obj);
    return internals.typeMap.get(objName) || exports.generic;
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Reach = __webpack_require__(/*! ./reach */ "./node_modules/@hapi/hoek/lib/reach.js");


const internals = {};


exports.keys = function (obj, options = {}) {

    return options.symbols !== false ? Reflect.ownKeys(obj) : Object.getOwnPropertyNames(obj);  // Defaults to true
};


exports.store = function (source, keys) {

    const storage = new Map();
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const value = Reach(source, key);
        if (typeof value === 'object' ||
            typeof value === 'function') {

            storage.set(key, value);
            internals.reachSet(source, key, undefined);
        }
    }

    return storage;
};


exports.restore = function (copy, source, storage) {

    for (const [key, value] of storage) {
        internals.reachSet(copy, key, value);
        internals.reachSet(source, key, value);
    }
};


internals.reachSet = function (obj, key, value) {

    const path = Array.isArray(key) ? key : key.split('.');
    let ref = obj;
    for (let i = 0; i < path.length; ++i) {
        const segment = path[i];
        if (i + 1 === path.length) {
            ref[segment] = value;
        }

        ref = ref[segment];
    }
};


/***/ }),

/***/ "./node_modules/@hapi/hoek/lib/wait.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/hoek/lib/wait.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


module.exports = function (timeout) {

    return new Promise((resolve) => setTimeout(resolve, timeout));
};


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/directory.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/inert/lib/directory.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Path = __webpack_require__(/*! path */ "path");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const File = __webpack_require__(/*! ./file */ "./node_modules/@hapi/inert/lib/file.js");
const Fs = __webpack_require__(/*! ./fs */ "./node_modules/@hapi/inert/lib/fs.js");


const internals = {};


internals.schema = Joi.object({
    path: Joi.alternatives(Joi.array().items(Joi.string()).single(), Joi.func()).required(),
    index: Joi.alternatives(Joi.boolean(), Joi.array().items(Joi.string()).single()).default(true),
    listing: Joi.boolean(),
    showHidden: Joi.boolean(),
    redirectToSlash: Joi.boolean(),
    lookupCompressed: Joi.boolean(),
    lookupMap: Joi.object().min(1).pattern(/.+/, Joi.string()),
    etagMethod: Joi.string().valid('hash', 'simple').allow(false),
    defaultExtension: Joi.string().alphanum()
});


internals.resolvePathOption = function (result) {

    if (result instanceof Error) {
        throw result;
    }

    if (typeof result === 'string') {
        return [result];
    }

    if (Array.isArray(result)) {
        return result;
    }

    throw Boom.internal('Invalid path function');
};


exports.handler = function (route, options) {

    const settings = Joi.attempt(options, internals.schema, 'Invalid directory handler options (' + route.path + ')');
    Hoek.assert(route.path[route.path.length - 1] === '}', 'The route path for a directory handler must end with a parameter:', route.path);

    const paramName = /\w+/.exec(route.path.slice(route.path.lastIndexOf('{')))[0];
    const basePath = route.settings.files.relativeTo;

    const normalized = (Array.isArray(settings.path) ? settings.path : null);                            // Array or function
    const indexNames = (settings.index === true) ? ['index.html'] : (settings.index || []);

    // Declare handler

    const handler = async (request, reply) => {

        const paths = normalized || internals.resolvePathOption(settings.path.call(null, request));

        // Append parameter

        const selection = request.params[paramName];
        if (selection &&
            !settings.showHidden &&
            internals.isFileHidden(selection)) {

            throw Boom.notFound(null, {});
        }

        if (!selection &&
            (request.server.settings.router.stripTrailingSlash || !request.path.endsWith('/'))) {

            request.path += '/';
        }

        // Generate response

        const resource = request.path;
        const hasTrailingSlash = resource.endsWith('/');
        const fileOptions = {
            confine: null,
            lookupCompressed: settings.lookupCompressed,
            lookupMap: settings.lookupMap,
            etagMethod: settings.etagMethod
        };

        const each = async (baseDir) => {

            fileOptions.confine = baseDir;

            let path = selection || '';
            let error;

            try {
                return await File.load(path, request, fileOptions);
            }
            catch (err) {
                Bounce.ignore(err, 'boom');
                error = err;
            }

            // Handle Not found

            if (internals.isNotFound(error)) {
                if (!settings.defaultExtension) {
                    throw error;
                }

                if (hasTrailingSlash) {
                    path = path.slice(0, -1);
                }

                return await File.load(path + '.' + settings.defaultExtension, request, fileOptions);
            }

            // Handle Directory

            if (internals.isDirectory(error)) {
                if (settings.redirectToSlash !== false &&                       // Defaults to true
                    !request.server.settings.router.stripTrailingSlash &&
                    !hasTrailingSlash) {

                    return reply.redirect(resource + '/');
                }

                for (const indexName of indexNames) {
                    const indexFile = Path.join(path, indexName);
                    try {
                        return await File.load(indexFile, request, fileOptions);
                    }
                    catch (err) {
                        Bounce.ignore(err, 'boom');

                        if (!internals.isNotFound(err)) {
                            throw Boom.internal(indexName + ' is a directory', err);
                        }

                        // Not found - try next
                    }
                }

                // None of the index files were found

                if (settings.listing) {
                    return internals.generateListing(Path.join(basePath, baseDir, path), resource, selection, hasTrailingSlash, settings, request);
                }
            }

            throw error;
        };

        for (let i = 0; i < paths.length; ++i) {
            try {
                return await each(paths[i]);
            }
            catch (err) {
                Bounce.ignore(err, 'boom');

                // Propagate any non-404 errors

                if (!internals.isNotFound(err) ||
                    i === paths.length - 1) {
                    throw err;
                }
            }
        }

        throw Boom.notFound(null, {});
    };

    return handler;
};


internals.generateListing = async function (path, resource, selection, hasTrailingSlash, settings, request) {

    let files;
    try {
        files = await Fs.readdir(path);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        throw Boom.internal('Error accessing directory', err);
    }

    resource = decodeURIComponent(resource);
    const display = Hoek.escapeHtml(resource);
    let html = '<html><head><title>' + display + '</title></head><body><h1>Directory: ' + display + '</h1><ul>';

    if (selection) {
        const parent = resource.substring(0, resource.lastIndexOf('/', resource.length - (hasTrailingSlash ? 2 : 1))) + '/';
        html = html + '<li><a href="' + internals.pathEncode(parent) + '">Parent Directory</a></li>';
    }

    for (let i = 0; i < files.length; ++i) {
        if (settings.showHidden ||
            !internals.isFileHidden(files[i])) {

            html = html + '<li><a href="' + internals.pathEncode(resource + (!hasTrailingSlash ? '/' : '') + files[i]) + '">' + Hoek.escapeHtml(files[i]) + '</a></li>';
        }
    }

    html = html + '</ul></body></html>';

    return request.generateResponse(html);
};


internals.isFileHidden = function (path) {

    return /(^|[\\\/])\.([^.\\\/]|\.[^\\\/])/.test(path);           // Starts with a '.' or contains '/.' or '\.', which is not followed by a '/' or '\' or '.'
};


internals.pathEncode = function (path) {

    return encodeURIComponent(path).replace(/%2F/g, '/').replace(/%5C/g, '\\');
};


internals.isNotFound = function (boom) {

    return boom.output.statusCode === 404;
};


internals.isDirectory = function (boom) {

    return boom.output.statusCode === 403 && boom.data.code === 'EISDIR';
};


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/etag.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/etag.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const LruCache = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");


const internals = {
    pendings: Object.create(null)
};


internals.streamEnd = function (stream) {

    return new Promise((resolve, reject) => {

        stream.on('end', resolve);
        stream.on('error', reject);
    });
};


internals.computeHashed = async function (response, stat) {

    const etags = response.request.server.plugins.inert._etags;
    if (!etags) {
        return null;
    }

    // Use stat info for an LRU cache key.

    const path = response.source.path;
    const cachekey = [path, stat.ino, stat.size, stat.mtime.getTime()].join('-');

    // The etag hashes the file contents in order to be consistent across distributed deployments

    const cachedEtag = etags.get(cachekey);
    if (cachedEtag) {
        return cachedEtag;
    }

    let promise = internals.pendings[cachekey];
    if (promise) {
        return await promise;
    }

    // Start hashing

    const compute = async () => {

        try {
            const hash = await internals.hashFile(response);
            etags.set(cachekey, hash);

            return hash;
        }
        finally {
            delete internals.pendings[cachekey];
        }
    };

    internals.pendings[cachekey] = promise = compute();

    return await promise;
};


internals.hashFile = async function (response) {

    const hash = Crypto.createHash('sha1');
    hash.setEncoding('hex');

    const fileStream = response.source.file.createReadStream({ autoClose: false });
    fileStream.pipe(hash);

    try {
        await internals.streamEnd(fileStream);
        return hash.read();
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        throw Boom.boomify(err, { message: 'Failed to hash file', data: { path: response.source.path } });
    }
};


internals.computeSimple = function (response, stat) {

    const size = stat.size.toString(16);
    const mtime = stat.mtime.getTime().toString(16);

    return size + '-' + mtime;
};


exports.apply = async function (response, stat) {

    const etagMethod = response.source.settings.etagMethod;
    if (etagMethod === false) {
        return;
    }

    let etag;
    if (etagMethod === 'simple') {
        etag = internals.computeSimple(response, stat);
    }
    else {
        etag = await internals.computeHashed(response, stat);
    }

    if (etag !== null) {
        response.etag(etag, { vary: true });
    }
};


exports.Cache = LruCache;


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/file.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/file.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Path = __webpack_require__(/*! path */ "path");

const Ammo = __webpack_require__(/*! @hapi/ammo */ "./node_modules/@hapi/ammo/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const Etag = __webpack_require__(/*! ./etag */ "./node_modules/@hapi/inert/lib/etag.js");
const Fs = __webpack_require__(/*! ./fs */ "./node_modules/@hapi/inert/lib/fs.js");


const internals = {};


internals.defaultMap = {
    gzip: '.gz'
};


internals.schema = Joi.alternatives([
    Joi.string(),
    Joi.func(),
    Joi.object({
        path: Joi.alternatives(Joi.string(), Joi.func()).required(),
        confine: Joi.alternatives(Joi.string(), Joi.boolean()).default(true),
        filename: Joi.string(),
        mode: Joi.string().valid('attachment', 'inline').allow(false),
        lookupCompressed: Joi.boolean(),
        lookupMap: Joi.object().min(1).pattern(/.+/, Joi.string()),
        etagMethod: Joi.string().valid('hash', 'simple').allow(false),
        start: Joi.number().integer().min(0).default(0),
        end: Joi.number().integer().min(Joi.ref('start'))
    })
        .with('filename', 'mode')
]);


exports.handler = function (route, options) {

    let settings = Joi.attempt(options, internals.schema, 'Invalid file handler options (' + route.path + ')');
    settings = (typeof options !== 'object' ? { path: options, confine: '.' } : settings);
    settings.confine = settings.confine === true ? '.' : settings.confine;
    Hoek.assert(typeof settings.path !== 'string' || settings.path[settings.path.length - 1] !== '/', 'File path cannot end with a \'/\':', route.path);

    const handler = (request) => {

        const path = (typeof settings.path === 'function' ? settings.path(request) : settings.path);
        return exports.response(path, settings, request);
    };

    return handler;
};


exports.load = function (path, request, options) {

    const response = exports.response(path, options, request, true);
    return internals.prepare(response);
};


exports.response = function (path, options, request, _preloaded) {

    Hoek.assert(!options.mode || ['attachment', 'inline'].indexOf(options.mode) !== -1, 'options.mode must be either false, attachment, or inline');

    if (options.confine) {
        const confineDir = Path.resolve(request.route.settings.files.relativeTo, options.confine);
        path = Path.isAbsolute(path) ? Path.normalize(path) : Path.join(confineDir, path);

        // Verify that resolved path is within confineDir
        if (path.lastIndexOf(confineDir, 0) !== 0) {
            path = null;
        }
    }
    else {
        path = Path.isAbsolute(path) ? Path.normalize(path) : Path.join(request.route.settings.files.relativeTo, path);
    }

    const source = {
        path,
        settings: options,
        stat: null,
        file: null
    };

    const prepare = _preloaded ? null : internals.prepare;

    return request.generateResponse(source, { variety: 'file', marshal: internals.marshal, prepare, close: internals.close });
};


internals.prepare = async function (response) {

    const path = response.source.path;

    if (path === null) {
        throw Boom.forbidden(null, { code: 'EACCES' });
    }

    const file = response.source.file = new Fs.File(path);

    try {
        const stat = await file.openStat('r');

        const start = response.source.settings.start || 0;
        if (response.source.settings.end !== undefined) {
            response.bytes(response.source.settings.end - start + 1);
        }
        else {
            response.bytes(stat.size - start);
        }

        if (!response.headers['content-type']) {
            response.type(response.request.server.mime.path(path).type || 'application/octet-stream');
        }

        response.header('last-modified', stat.mtime.toUTCString());

        if (response.source.settings.mode) {
            const fileName = response.source.settings.filename || Path.basename(path);
            response.header('content-disposition', response.source.settings.mode + '; filename=' + encodeURIComponent(fileName));
        }

        await Etag.apply(response, stat);

        return response;
    }
    catch (err) {
        internals.close(response);
        throw err;
    }
};


internals.marshal = async function (response) {

    if (response.source.settings.lookupCompressed &&
        !response.source.settings.start &&
        response.source.settings.end === undefined &&
        response.request.server.settings.compression !== false) {

        const lookupMap = response.source.settings.lookupMap || internals.defaultMap;
        const encoding = response.request.info.acceptEncoding;
        const extension = lookupMap.hasOwnProperty(encoding) ? lookupMap[encoding] : null;
        if (extension) {
            const precompressed = new Fs.File(`${response.source.path}${extension}`);
            let stat;
            try {
                stat = await precompressed.openStat('r');
            }
            catch (err) {
                precompressed.close();
                Bounce.ignore(err, 'boom');
            }

            if (stat) {
                response.source.file.close();
                response.source.file = precompressed;

                response.bytes(stat.size);
                response.header('content-encoding', encoding);
                response.vary('accept-encoding');
            }
        }
    }

    return internals.createStream(response);
};


internals.addContentRange = function (response) {

    const request = response.request;
    const length = response.headers['content-length'];
    let range = null;

    if (request.route.settings.response.ranges) {
        if (request.headers.range && length) {

            // Check If-Range

            if (!request.headers['if-range'] ||
                request.headers['if-range'] === response.headers.etag) {            // Ignoring last-modified date (weak)

                // Check that response is not encoded once transmitted

                const mime = request.server.mime.type(response.headers['content-type'] || 'application/octet-stream');
                const encoding = (request.server.settings.compression && mime.compressible && !response.headers['content-encoding'] ? request.info.acceptEncoding : null);

                if (encoding === 'identity' || !encoding) {

                    // Parse header

                    const ranges = Ammo.header(request.headers.range, length);
                    if (!ranges) {
                        const error = Boom.rangeNotSatisfiable();
                        error.output.headers['content-range'] = 'bytes */' + length;
                        throw error;
                    }

                    // Prepare transform

                    if (ranges.length === 1) {                                          // Ignore requests for multiple ranges
                        range = ranges[0];
                        response.code(206);
                        response.bytes(range.to - range.from + 1);
                        response.header('content-range', 'bytes ' + range.from + '-' + range.to + '/' + length);
                    }
                }
            }
        }

        response.header('accept-ranges', 'bytes');
    }

    return range;
};


internals.createStream = function (response) {

    const source = response.source;

    Hoek.assert(source.file !== null);

    const range = internals.addContentRange(response);

    const options = {
        start: source.settings.start || 0,
        end: source.settings.end
    };

    if (range) {
        options.end = range.to + options.start;
        options.start = range.from + options.start;
    }

    return source.file.createReadStream(options);
};


internals.close = function (response) {

    if (response.source.file !== null) {
        response.source.file.close();
        response.source.file = null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/fs.js":
/*!********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/fs.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Fs = __webpack_require__(/*! fs */ "fs");
const Util = __webpack_require__(/*! util */ "util");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    methods: {
        promised: ['open', 'close', 'fstat', 'readdir'],
        raw: ['createReadStream']
    }
};


exports.File = function (path) {

    this.path = path;
    this.fd = null;
};


exports.File.prototype.open = async function (mode) {

    Hoek.assert(this.fd === null);

    try {
        this.fd = await exports.open(this.path, mode);
    }
    catch (err) {
        const data = { path: this.path };

        if (this.path.indexOf('\u0000') !== -1 || err.code === 'ENOENT') {
            throw Boom.notFound(null, data);
        }

        if (err.code === 'EACCES' || err.code === 'EPERM') {
            data.code = err.code;
            throw Boom.forbidden(null, data);
        }

        throw Boom.boomify(err, { message: 'Failed to open file', data });
    }
};


exports.File.prototype.close = function () {

    if (this.fd !== null) {
        Bounce.background(exports.close(this.fd));
        this.fd = null;
    }
};


exports.File.prototype.stat = async function () {

    Hoek.assert(this.fd !== null);

    try {
        const stat = await exports.fstat(this.fd);

        if (stat.isDirectory()) {
            throw Boom.forbidden(null, { code: 'EISDIR', path: this.path });
        }

        return stat;
    }
    catch (err) {
        this.close(this.fd);

        Bounce.rethrow(err, ['boom', 'system']);
        throw Boom.boomify(err, { message: 'Failed to stat file', data: { path: this.path } });
    }
};


exports.File.prototype.openStat = async function (mode) {

    await this.open(mode);
    return this.stat();
};


exports.File.prototype.createReadStream = function (options) {

    Hoek.assert(this.fd !== null);

    options = Object.assign({ fd: this.fd, start: 0 }, options);

    const stream = exports.createReadStream(this.path, options);

    if (options.autoClose !== false) {
        this.fd = null;           // The stream now owns the fd
    }

    return stream;
};


// Export Fs methods

for (let i = 0; i < internals.methods.raw.length; ++i) {
    const method = internals.methods.raw[i];
    exports[method] = Fs[method].bind(Fs);
}

for (let i = 0; i < internals.methods.promised.length; ++i) {
    const method = internals.methods.promised[i];
    exports[method] = Util.promisify(Fs[method]);
}


/***/ }),

/***/ "./node_modules/@hapi/inert/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/inert/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const Directory = __webpack_require__(/*! ./directory */ "./node_modules/@hapi/inert/lib/directory.js");
const Etag = __webpack_require__(/*! ./etag */ "./node_modules/@hapi/inert/lib/etag.js");
const File = __webpack_require__(/*! ./file */ "./node_modules/@hapi/inert/lib/file.js");


const internals = {
    schema: Joi.object({
        etagsCacheMaxSize: Joi.number().integer().min(0).default(1000)
    }).required()
};


internals.fileMethod = function (path, responseOptions) {

    // Set correct confine value

    responseOptions = responseOptions || {};

    if (typeof responseOptions.confine === 'undefined' || responseOptions.confine === true) {
        responseOptions.confine = '.';
    }

    Hoek.assert(responseOptions.end === undefined || +responseOptions.start <= +responseOptions.end, 'options.start must be less than or equal to options.end');

    return this.response(File.response(path, responseOptions, this.request));
};


exports.plugin = {
    name: 'inert',
    pkg: __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/inert/package.json"),
    once: true,
    requirements: {
        hapi: '>=17.7.0'
    },

    register(server, options) {

        Hoek.assert(Object.keys(options).length === 0, 'Inert does not support registration options');
        const settings = Joi.attempt(Hoek.reach(server.settings.plugins, 'inert') || {}, internals.schema, 'Invalid "inert" server options');

        server.expose('_etags', settings.etagsCacheMaxSize > 0 ? new Etag.Cache(settings.etagsCacheMaxSize) : null);

        server.decorate('handler', 'file', File.handler);
        server.decorate('handler', 'directory', Directory.handler);
        server.decorate('toolkit', 'file', internals.fileMethod);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/inert/package.json":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/inert/package.json ***!
  \***********************************************/
/*! exports provided: name, description, version, repository, main, keywords, dependencies, devDependencies, scripts, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/inert\",\"description\":\"Static file and directory handlers plugin for hapi.js\",\"version\":\"5.2.2\",\"repository\":\"https://github.com/hapijs/inert.git\",\"main\":\"lib/index.js\",\"keywords\":[\"file\",\"directory\",\"handler\",\"hapi\",\"plugin\"],\"dependencies\":{\"@hapi/ammo\":\"3.x.x\",\"@hapi/boom\":\"7.x.x\",\"@hapi/bounce\":\"1.x.x\",\"@hapi/hoek\":\"8.x.x\",\"@hapi/joi\":\"16.x.x\",\"lru-cache\":\"4.1.x\"},\"devDependencies\":{\"@hapi/code\":\"6.x.x\",\"@hapi/file\":\"1.x.x\",\"@hapi/hapi\":\"18.x.x\",\"@hapi/lab\":\"20.x.x\"},\"scripts\":{\"test\":\"lab -f -a @hapi/code -t 100 -L\",\"test-cov-html\":\"lab -f -a @hapi/code -r html -o coverage.html\"},\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/iron/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/iron/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Crypto = __webpack_require__(/*! crypto */ "crypto");

const B64 = __webpack_require__(/*! @hapi/b64 */ "./node_modules/@hapi/b64/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Cryptiles = __webpack_require__(/*! @hapi/cryptiles */ "./node_modules/@hapi/cryptiles/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports.defaults = {
    encryption: {
        saltBits: 256,
        algorithm: 'aes-256-cbc',
        iterations: 1,
        minPasswordlength: 32
    },

    integrity: {
        saltBits: 256,
        algorithm: 'sha256',
        iterations: 1,
        minPasswordlength: 32
    },

    ttl: 0,                                             // Milliseconds, 0 means forever
    timestampSkewSec: 60,                               // Seconds of permitted clock skew for incoming expirations
    localtimeOffsetMsec: 0                              // Local clock time offset express in a number of milliseconds (positive or negative)
};


// Algorithm configuration

exports.algorithms = {
    'aes-128-ctr': { keyBits: 128, ivBits: 128 },
    'aes-256-cbc': { keyBits: 256, ivBits: 128 },
    'sha256': { keyBits: 256 }
};


// MAC normalization format version

exports.macFormatVersion = '2';                         // Prevent comparison of mac values generated with different normalized string formats

exports.macPrefix = 'Fe26.' + exports.macFormatVersion;


// Generate a unique encryption key

/*
    const options =  {
        saltBits: 256,                                  // Ignored if salt is set
        salt: '4d8nr9q384nr9q384nr93q8nruq9348run',
        algorithm: 'aes-128-ctr',
        iterations: 10000,
        iv: 'sdfsdfsdfsdfscdrgercgesrcgsercg',          // Optional
        minPasswordlength: 32
    };
*/

exports.generateKey = async function (password, options) {

    if (!password) {
        throw new Boom('Empty password');
    }

    if (!options ||
        typeof options !== 'object') {

        throw new Boom('Bad options');
    }

    const algorithm = exports.algorithms[options.algorithm];
    if (!algorithm) {
        throw new Boom('Unknown algorithm: ' + options.algorithm);
    }

    const result = {};

    if (Buffer.isBuffer(password)) {
        if (password.length < algorithm.keyBits / 8) {
            throw new Boom('Key buffer (password) too small');
        }

        result.key = password;
        result.salt = '';
    }
    else {
        if (password.length < options.minPasswordlength) {
            throw new Boom('Password string too short (min ' + options.minPasswordlength + ' characters required)');
        }

        let salt = options.salt;
        if (!salt) {
            if (!options.saltBits) {
                throw new Boom('Missing salt and saltBits options');
            }

            const randomSalt = Cryptiles.randomBits(options.saltBits);
            salt = randomSalt.toString('hex');
        }

        const derivedKey = await internals.pbkdf2(password, salt, options.iterations, algorithm.keyBits / 8, 'sha1');

        result.key = derivedKey;
        result.salt = salt;
    }

    if (options.iv) {
        result.iv = options.iv;
    }
    else if (algorithm.ivBits) {
        result.iv = Cryptiles.randomBits(algorithm.ivBits);
    }

    return result;
};


// Encrypt data
// options: see exports.generateKey()

exports.encrypt = async function (password, options, data) {

    const key = await exports.generateKey(password, options);
    const cipher = Crypto.createCipheriv(options.algorithm, key.key, key.iv);
    const encrypted = Buffer.concat([cipher.update(data, 'utf8'), cipher.final()]);

    return { encrypted, key };
};


// Decrypt data
// options: see exports.generateKey()

exports.decrypt = async function (password, options, data) {

    const key = await exports.generateKey(password, options);
    const decipher = Crypto.createDecipheriv(options.algorithm, key.key, key.iv);
    let dec = decipher.update(data, null, 'utf8');
    dec = dec + decipher.final('utf8');

    return dec;
};


// HMAC using a password
// options: see exports.generateKey()

exports.hmacWithPassword = async function (password, options, data) {

    const key = await exports.generateKey(password, options);
    const hmac = Crypto.createHmac(options.algorithm, key.key).update(data);
    const digest = hmac.digest('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');

    return {
        digest,
        salt: key.salt
    };
};


// Normalizes a password parameter into a { id, encryption, integrity } object
// password: string, buffer or object with { id, secret } or { id, encryption, integrity }

internals.normalizePassword = function (password) {

    if (password &&
        typeof password === 'object' &&
        !Buffer.isBuffer(password)) {

        return {
            id: password.id,
            encryption: password.secret || password.encryption,
            integrity: password.secret || password.integrity
        };
    }

    return {
        encryption: password,
        integrity: password
    };
};


// Encrypt and HMAC an object
// password: string, buffer or object with { id, secret } or { id, encryption, integrity }
// options: see exports.defaults

exports.seal = async function (object, password, options) {

    options = Object.assign({}, options);       // Shallow cloned to prevent changes during async operations

    const now = Date.now() + (options.localtimeOffsetMsec || 0);                 // Measure now before any other processing

    // Serialize object

    const objectString = internals.stringify(object);

    // Obtain password

    let passwordId = '';
    password = internals.normalizePassword(password);
    if (password.id) {
        if (!/^\w+$/.test(password.id)) {
            throw new Boom('Invalid password id');
        }

        passwordId = password.id;
    }

    // Encrypt object string

    const { encrypted, key } = await exports.encrypt(password.encryption, options.encryption, objectString);

    // Base64url the encrypted value

    const encryptedB64 = B64.base64urlEncode(encrypted);
    const iv = B64.base64urlEncode(key.iv);
    const expiration = (options.ttl ? now + options.ttl : '');
    const macBaseString = exports.macPrefix + '*' + passwordId + '*' + key.salt + '*' + iv + '*' + encryptedB64 + '*' + expiration;

    // Mac the combined values

    const mac = await exports.hmacWithPassword(password.integrity, options.integrity, macBaseString);

    // Put it all together

    // prefix*[password-id]*encryption-salt*encryption-iv*encrypted*[expiration]*hmac-salt*hmac
    // Allowed URI query name/value characters: *-. \d \w

    const sealed = macBaseString + '*' + mac.salt + '*' + mac.digest;
    return sealed;
};


// Decrypt and validate sealed string
// password: string, buffer or object with { id: secret } or { id: { encryption, integrity } }
// options: see exports.defaults

exports.unseal = async function (sealed, password, options) {

    options = Object.assign({}, options);                                       // Shallow cloned to prevent changes during async operations

    const now = Date.now() + (options.localtimeOffsetMsec || 0);                // Measure now before any other processing

    // Break string into components

    const parts = sealed.split('*');
    if (parts.length !== 8) {
        throw new Boom('Incorrect number of sealed components');
    }

    const macPrefix = parts[0];
    const passwordId = parts[1];
    const encryptionSalt = parts[2];
    const encryptionIv = parts[3];
    const encryptedB64 = parts[4];
    const expiration = parts[5];
    const hmacSalt = parts[6];
    const hmac = parts[7];
    const macBaseString = macPrefix + '*' + passwordId + '*' + encryptionSalt + '*' + encryptionIv + '*' + encryptedB64 + '*' + expiration;

    // Check prefix

    if (macPrefix !== exports.macPrefix) {
        throw new Boom('Wrong mac prefix');
    }

    // Check expiration

    if (expiration) {
        if (!expiration.match(/^\d+$/)) {
            throw new Boom('Invalid expiration');
        }

        const exp = parseInt(expiration, 10);
        if (exp <= (now - (options.timestampSkewSec * 1000))) {
            throw new Boom('Expired seal');
        }
    }

    // Obtain password

    if (!password) {
        throw new Boom('Empty password');
    }

    if (typeof password === 'object' &&
        !Buffer.isBuffer(password)) {

        password = password[passwordId || 'default'];
        if (!password) {
            throw new Boom('Cannot find password: ' + passwordId);
        }
    }

    password = internals.normalizePassword(password);

    // Check hmac

    const macOptions = Hoek.clone(options.integrity);
    macOptions.salt = hmacSalt;
    const mac = await exports.hmacWithPassword(password.integrity, macOptions, macBaseString);

    if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw new Boom('Bad hmac value');
    }

    // Decrypt

    try {
        var encrypted = B64.base64urlDecode(encryptedB64, 'buffer');
    }
    catch (err) {
        throw Boom.boomify(err);
    }

    const decryptOptions = Hoek.clone(options.encryption);
    decryptOptions.salt = encryptionSalt;

    try {
        decryptOptions.iv = B64.base64urlDecode(encryptionIv, 'buffer');
    }
    catch (err) {
        throw Boom.boomify(err);
    }

    const decrypted = await exports.decrypt(password.encryption, decryptOptions, encrypted);

    // Parse JSON

    try {
        return Bourne.parse(decrypted);
    }
    catch (err) {
        throw new Boom('Failed parsing sealed object JSON: ' + err.message);
    }
};


internals.stringify = function (object) {

    try {
        return JSON.stringify(object);
    }
    catch (err) {
        throw new Boom('Failed to stringify object: ' + err.message);
    }
};


internals.pbkdf2 = function (...args) {

    return new Promise((resolve, reject) => {

        const next = (err, result) => {

            if (err) {
                return reject(Boom.boomify(err));
            }

            resolve(result);
        };

        args.push(next);
        Crypto.pbkdf2(...args);
    });
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/base.js":
/*!********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/base.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Merge = __webpack_require__(/*! @hapi/hoek/lib/merge */ "./node_modules/@hapi/hoek/lib/merge.js");

const Cache = __webpack_require__(/*! ./cache */ "./node_modules/@hapi/joi/lib/cache.js");
const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ./compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Extend = __webpack_require__(/*! ./extend */ "./node_modules/@hapi/joi/lib/extend.js");
const Manifest = __webpack_require__(/*! ./manifest */ "./node_modules/@hapi/joi/lib/manifest.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");
const Modify = __webpack_require__(/*! ./modify */ "./node_modules/@hapi/joi/lib/modify.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Trace = __webpack_require__(/*! ./trace */ "./node_modules/@hapi/joi/lib/trace.js");
const Validator = __webpack_require__(/*! ./validator */ "./node_modules/@hapi/joi/lib/validator.js");
const Values = __webpack_require__(/*! ./values */ "./node_modules/@hapi/joi/lib/values.js");


const internals = {};


internals.Base = class {

    constructor(type) {

        // Naming: public, _private, $_extension, $_mutate{action}

        this.type = type;

        this.$_root = null;
        this._definition = {};
        this._ids = new Modify.Ids();
        this._preferences = null;
        this._refs = new Ref.Manager();
        this._cache = null;

        this._valids = null;
        this._invalids = null;

        this._flags = {};
        this._rules = [];
        this._singleRules = new Map();              // The rule options passed for non-multi rules

        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)

        this.$_temp = {                             // Runtime state (not cloned)
            ruleset: null,                          // null: use last, false: error, number: start position
            whens: {}                               // Runtime cache of generated whens
        };
    }

    // Manifest

    describe() {

        Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');
        return Manifest.describe(this);
    }

    // Rules

    allow(...values) {

        return this._values(values, '_valids');
    }

    alter(targets) {

        Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');
        Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');

        const obj = this.clone();
        obj.$_terms.alterations = obj.$_terms.alterations || [];
        for (const target in targets) {
            const adjuster = targets[target];
            Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');
            obj.$_terms.alterations.push({ target, adjuster });
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    cast(to) {

        Assert(to === false || typeof to === 'string', 'Invalid to value');
        Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);

        return this.$_setFlag('cast', to === false ? undefined : to);
    }

    default(value, options) {

        return this._default('default', value, options);
    }

    description(desc) {

        Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');

        return this.$_setFlag('description', desc);
    }

    empty(schema) {

        const obj = this.clone();

        if (schema !== undefined) {
            schema = obj.$_compile(schema, { override: false });
        }

        return obj.$_setFlag('empty', schema, { clone: false });
    }

    error(err) {

        Assert(err, 'Missing error');
        Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');

        return this.$_setFlag('error', err);
    }

    example(example, options = {}) {

        Assert(example !== undefined, 'Missing example');
        Common.assertOptions(options, ['override']);

        return this._inner('examples', example, { single: true, override: options.override });
    }

    external(method, description) {

        if (typeof method === 'object') {
            Assert(!description, 'Cannot combine options with description');
            description = method.description;
            method = method.method;
        }

        Assert(typeof method === 'function', 'Method must be a function');
        Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

        return this._inner('externals', { method, description }, { single: true });
    }

    failover(value, options) {

        return this._default('failover', value, options);
    }

    forbidden() {

        return this.presence('forbidden');
    }

    id(id) {

        if (!id) {
            return this.$_setFlag('id', undefined);
        }

        Assert(typeof id === 'string', 'id must be a non-empty string');
        Assert(/^[^\.]+$/.test(id), 'id cannot contain period character');

        return this.$_setFlag('id', id);
    }

    invalid(...values) {

        return this._values(values, '_invalids');
    }

    label(name) {

        Assert(name && typeof name === 'string', 'Label name must be a non-empty string');

        return this.$_setFlag('label', name);
    }

    meta(meta) {

        Assert(meta !== undefined, 'Meta cannot be undefined');

        return this._inner('metas', meta, { single: true });
    }

    note(...notes) {

        Assert(notes.length, 'Missing notes');
        for (const note of notes) {
            Assert(note && typeof note === 'string', 'Notes must be non-empty strings');
        }

        return this._inner('notes', notes);
    }

    only(mode = true) {

        Assert(typeof mode === 'boolean', 'Invalid mode:', mode);

        return this.$_setFlag('only', mode);
    }

    optional() {

        return this.presence('optional');
    }

    prefs(prefs) {

        Assert(prefs, 'Missing preferences');
        Assert(prefs.context === undefined, 'Cannot override context');
        Assert(prefs.externals === undefined, 'Cannot override externals');
        Assert(prefs.warnings === undefined, 'Cannot override warnings');
        Assert(prefs.debug === undefined, 'Cannot override debug');

        Common.checkPreferences(prefs);

        const obj = this.clone();
        obj._preferences = Common.preferences(obj._preferences, prefs);
        return obj;
    }

    presence(mode) {

        Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);

        return this.$_setFlag('presence', mode);
    }

    raw(enabled = true) {

        return this.$_setFlag('result', enabled ? 'raw' : undefined);
    }

    result(mode) {

        Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);

        return this.$_setFlag('result', mode);
    }

    required() {

        return this.presence('required');
    }

    strict(enabled) {

        const obj = this.clone();

        const convert = enabled === undefined ? false : !enabled;
        obj._preferences = Common.preferences(obj._preferences, { convert });
        return obj;
    }

    strip(enabled = true) {

        return this.$_setFlag('result', enabled ? 'strip' : undefined);
    }

    tag(...tags) {

        Assert(tags.length, 'Missing tags');
        for (const tag of tags) {
            Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');
        }

        return this._inner('tags', tags);
    }

    unit(name) {

        Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');

        return this.$_setFlag('unit', name);
    }

    valid(...values) {

        const obj = this.allow(...values);
        obj.$_setFlag('only', !!obj._valids, { clone: false });
        return obj;
    }

    when(condition, options) {

        const obj = this.clone();

        if (!obj.$_terms.whens) {
            obj.$_terms.whens = [];
        }

        const when = Compile.when(obj, condition, options);
        if (!['any', 'link'].includes(obj.type)) {
            const conditions = when.is ? [when] : when.switch;
            for (const item of conditions) {
                Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);
                Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);

            }
        }

        obj.$_terms.whens.push(when);
        return obj.$_mutateRebuild();
    }

    // Helpers

    cache(cache) {

        Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');
        Assert(!this._cache, 'Cannot override schema cache');

        const obj = this.clone();
        obj._cache = cache || Cache.provider.provision();
        obj.$_temp.ruleset = false;
        return obj;
    }

    clone() {

        const obj = Object.create(Object.getPrototypeOf(this));
        return this._assign(obj);
    }

    concat(source) {

        Assert(Common.isSchema(source), 'Invalid schema object');
        Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);
        Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');
        Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');

        let obj = this.clone();

        if (this.type === 'any' &&
            source.type !== 'any') {

            // Change obj to match source type

            const tmpObj = source.clone();
            for (const key of Object.keys(obj)) {
                if (key !== 'type') {
                    tmpObj[key] = obj[key];
                }
            }

            obj = tmpObj;
        }

        obj._ids.concat(source._ids);
        obj._refs.register(source, Ref.toSibling);

        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;
        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);
        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);

        // Remove unique rules present in source

        for (const name of source._singleRules.keys()) {
            if (obj._singleRules.has(name)) {
                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);
                obj._singleRules.delete(name);
            }
        }

        // Rules

        for (const test of source._rules) {
            if (!source._definition.rules[test.method].multi) {
                obj._singleRules.set(test.name, test);
            }

            obj._rules.push(test);
        }

        // Flags

        if (obj._flags.empty &&
            source._flags.empty) {

            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            Merge(obj._flags, flags);
        }
        else if (source._flags.empty) {
            obj._flags.empty = source._flags.empty;
            const flags = Object.assign({}, source._flags);
            delete flags.empty;
            Merge(obj._flags, flags);
        }
        else {
            Merge(obj._flags, source._flags);
        }

        // Terms

        for (const key in source.$_terms) {
            const terms = source.$_terms[key];
            if (!terms) {
                if (!obj.$_terms[key]) {
                    obj.$_terms[key] = terms;
                }

                continue;
            }

            if (!obj.$_terms[key]) {
                obj.$_terms[key] = terms.slice();
                continue;
            }

            obj.$_terms[key] = obj.$_terms[key].concat(terms);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, source]);
        }

        // Rebuild

        return obj.$_mutateRebuild();
    }

    extend(options) {

        Assert(!options.base, 'Cannot extend type with another base');

        return Extend.type(this, options);
    }

    extract(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.reach(path);
    }

    fork(paths, adjuster) {

        Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');

        let obj = this;                                             // eslint-disable-line consistent-this
        for (let path of [].concat(paths)) {
            path = Array.isArray(path) ? path : path.split('.');
            obj = obj._ids.fork(path, adjuster, obj);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    rule(options) {

        const def = this._definition;
        Common.assertOptions(options, Object.keys(def.modifiers));

        Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');
        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
        Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');

        const obj = this.clone();

        for (let i = start; i < obj._rules.length; ++i) {
            const original = obj._rules[i];
            const rule = Clone(original);

            for (const name in options) {
                def.modifiers[name](rule, options[name]);
                Assert(rule.name === original.name, 'Cannot change rule name');
            }

            obj._rules[i] = rule;

            if (obj._singleRules.get(rule.name) === original) {
                obj._singleRules.set(rule.name, rule);
            }
        }

        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    get ruleset() {

        Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');

        const obj = this.clone();
        obj.$_temp.ruleset = obj._rules.length;
        return obj;
    }

    get $() {

        return this.ruleset;
    }

    tailor(targets) {

        targets = [].concat(targets);

        Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');

        let obj = this;                                                     // eslint-disable-line consistent-this

        if (this.$_terms.alterations) {
            for (const { target, adjuster } of this.$_terms.alterations) {
                if (targets.includes(target)) {
                    obj = adjuster(obj);
                    Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');
                }
            }
        }

        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });
        obj.$_temp.ruleset = false;
        return obj.$_mutateRebuild();
    }

    tracer() {

        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$
    }

    validate(value, options) {

        return Validator.entry(value, this, options);
    }

    validateAsync(value, options) {

        return Validator.entryAsync(value, this, options);
    }

    // Extensions

    $_addRule(options) {

        // Normalize rule

        if (typeof options === 'string') {
            options = { name: options };
        }

        Assert(options && typeof options === 'object', 'Invalid options');
        Assert(options.name && typeof options.name === 'string', 'Invalid rule name');

        for (const key in options) {
            Assert(key[0] !== '_', 'Cannot set private rule properties');
        }

        const rule = Object.assign({}, options);        // Shallow cloned
        rule._resolve = [];
        rule.method = rule.method || rule.name;

        const definition = this._definition.rules[rule.method];
        const args = rule.args;

        Assert(definition, 'Unknown rule', rule.method);

        // Args

        const obj = this.clone();

        if (args) {
            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);

            for (const key in args) {
                let arg = args[key];
                if (arg === undefined) {
                    delete args[key];
                    continue;
                }

                if (definition.argsByName) {
                    const resolver = definition.argsByName.get(key);

                    if (resolver.ref &&
                        Common.isResolvable(arg)) {

                        rule._resolve.push(key);
                        obj.$_mutateRegister(arg);
                    }
                    else {
                        if (resolver.normalize) {
                            arg = resolver.normalize(arg);
                            args[key] = arg;
                        }

                        if (resolver.assert) {
                            const error = Common.validateArg(arg, key, resolver);
                            Assert(!error, error, 'or reference');
                        }
                    }
                }

                args[key] = arg;
            }
        }

        // Unique rules

        if (!definition.multi) {
            obj._ruleRemove(rule.name, { clone: false });
            obj._singleRules.set(rule.name, rule);
        }

        if (obj.$_temp.ruleset === false) {
            obj.$_temp.ruleset = null;
        }

        if (definition.priority) {
            obj._rules.unshift(rule);
        }
        else {
            obj._rules.push(rule);
        }

        return obj;
    }

    $_compile(schema, options) {

        return Compile.schema(this.$_root, schema, options);
    }

    $_createError(code, value, local, state, prefs, options = {}) {

        const flags = options.flags !== false ? this._flags : {};
        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;
        return new Errors.Report(code, value, local, flags, messages, state, prefs);
    }

    $_getFlag(name) {

        return this._flags[name];
    }

    $_getRule(name) {

        return this._singleRules.get(name);
    }

    $_mapLabels(path) {

        path = Array.isArray(path) ? path : path.split('.');
        return this._ids.labels(path);
    }

    $_match(value, state, prefs, overrides) {

        prefs = Object.assign({}, prefs);       // Shallow cloned
        prefs.abortEarly = true;
        prefs._externals = false;

        state.snapshot();
        const result = !Validator.validate(value, this, state, prefs, overrides).errors;
        state.restore();

        return result;
    }

    $_modify(options) {

        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);
        return Modify.schema(this, options) || this;
    }

    $_mutateRebuild() {

        Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');

        this._refs.reset();
        this._ids.reset();

        const each = (item, { source, name, path, key }) => {

            const family = this._definition[source][name] && this._definition[source][name].register;
            if (family !== false) {
                this.$_mutateRegister(item, { family, key });
            }
        };

        this.$_modify({ each });

        if (this._definition.rebuild) {
            this._definition.rebuild(this);
        }

        this.$_temp.ruleset = false;
        return this;
    }

    $_mutateRegister(schema, { family, key } = {}) {

        this._refs.register(schema, family);
        this._ids.register(schema, { key });
    }

    $_property(name) {

        return this._definition.properties[name];
    }

    $_reach(path) {

        return this._ids.reach(path);
    }

    $_rootReferences() {

        return this._refs.roots();
    }

    $_setFlag(name, value, options = {}) {

        Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');

        const flag = this._definition.flags[name] || {};
        if (DeepEqual(value, flag.default)) {
            value = undefined;
        }

        if (DeepEqual(value, this._flags[name])) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        if (value !== undefined) {
            obj._flags[name] = value;
            obj.$_mutateRegister(value);
        }
        else {
            delete obj._flags[name];
        }

        if (name[0] !== '_') {
            obj.$_temp.ruleset = false;
        }

        return obj;
    }

    $_validate(value, state, prefs) {

        return Validator.validate(value, this, state, prefs);
    }

    // Internals

    _assign(target) {

        target.type = this.type;

        target.$_root = this.$_root;

        target.$_temp = Object.assign({}, this.$_temp);
        target.$_temp.whens = {};

        target._ids = this._ids.clone();
        target._preferences = this._preferences;
        target._valids = this._valids && this._valids.clone();
        target._invalids = this._invalids && this._invalids.clone();
        target._rules = this._rules.slice();
        target._singleRules = Clone(this._singleRules, { shallow: true });
        target._refs = this._refs.clone();
        target._flags = Object.assign({}, this._flags);
        target._cache = null;

        target.$_terms = {};
        for (const key in this.$_terms) {
            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;
        }

        target.$_super = {};
        for (const override in this.$_super) {
            target.$_super[override] = this._super[override].bind(target);
        }

        return target;
    }

    _default(flag, value, options = {}) {

        Common.assertOptions(options, 'literal');

        Assert(value !== undefined, 'Missing', flag, 'value');
        Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');

        if (typeof value === 'function' &&
            options.literal) {

            value = {
                [Common.symbols.literal]: true,
                literal: value
            };
        }

        const obj = this.$_setFlag(flag, value);
        return obj;
    }

    _generate(value, state, prefs) {

        if (!this.$_terms.whens) {
            return { schema: this };
        }

        // Collect matching whens

        const whens = [];
        const ids = [];
        for (let i = 0; i < this.$_terms.whens.length; ++i) {
            const when = this.$_terms.whens[i];

            if (when.concat) {
                whens.push(when.concat);
                ids.push(`${i}.concat`);
                continue;
            }

            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;
            const tests = when.is ? [when] : when.switch;
            const before = ids.length;

            for (let j = 0; j < tests.length; ++j) {
                const { is, then, otherwise } = tests[j];

                const baseId = `${i}${when.switch ? '.' + j : ''}`;
                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {
                    if (then) {
                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);
                        const { schema: generated, id } = then._generate(value, localState, prefs);
                        whens.push(generated);
                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);
                        break;
                    }
                }
                else if (otherwise) {
                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);
                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);
                    whens.push(generated);
                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);
                    break;
                }
            }

            if (when.break &&
                ids.length > before) {          // Something matched

                break;
            }
        }

        // Check cache

        const id = ids.join(', ');
        state.mainstay.tracer.debug(state, 'rule', 'when', id);

        if (!id) {
            return { schema: this };
        }

        if (!state.mainstay.tracer.active &&
            this.$_temp.whens[id]) {

            return { schema: this.$_temp.whens[id], id };
        }

        // Generate dynamic schema

        let obj = this;                                             // eslint-disable-line consistent-this
        if (this._definition.generate) {
            obj = this._definition.generate(this, value, state, prefs);
        }

        // Apply whens

        for (const when of whens) {
            obj = obj.concat(when);
        }

        // Tracing

        if (this.$_root._tracer) {
            this.$_root._tracer._combine(obj, [this, ...whens]);
        }

        // Cache result

        this.$_temp.whens[id] = obj;
        return { schema: obj, id };
    }

    _inner(type, values, options = {}) {

        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);

        const obj = this.clone();
        if (!obj.$_terms[type] ||
            options.override) {

            obj.$_terms[type] = [];
        }

        if (options.single) {
            obj.$_terms[type].push(values);
        }
        else {
            obj.$_terms[type].push(...values);
        }

        obj.$_temp.ruleset = false;
        return obj;
    }

    _inRuleset() {

        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;
    }

    _ruleRemove(name, options = {}) {

        if (!this._singleRules.has(name)) {
            return this;
        }

        const obj = options.clone !== false ? this.clone() : this;

        obj._singleRules.delete(name);

        const filtered = [];
        for (let i = 0; i < obj._rules.length; ++i) {
            const test = obj._rules[i];
            if (test.name === name &&
                !test.keep) {

                if (obj._inRuleset() &&
                    i < obj.$_temp.ruleset) {

                    --obj.$_temp.ruleset;
                }

                continue;
            }

            filtered.push(test);
        }

        obj._rules = filtered;
        return obj;
    }

    _values(values, key) {

        Common.verifyFlat(values, key.slice(1, -1));

        const obj = this.clone();

        const override = values[0] === Common.symbols.override;
        if (override) {
            values = values.slice(1);
        }

        if (!obj[key] &&
            values.length) {

            obj[key] = new Values();
        }
        else if (override) {
            obj[key] = values.length ? new Values() : null;
            obj.$_mutateRebuild();
        }

        if (!obj[key]) {
            return obj;
        }

        if (override) {
            obj[key].override();
        }

        for (const value of values) {
            Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');
            Assert(value !== Common.symbols.override, 'Override must be the first value');

            const other = key === '_invalids' ? '_valids' : '_invalids';
            if (obj[other]) {
                obj[other].remove(value);
                if (!obj[other].length) {
                    Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');
                    obj[other] = null;
                }
            }

            obj[key].add(value, obj._refs);
        }

        return obj;
    }
};


internals.Base.prototype.isImmutable = true;                        // Prevents Hoek from deep cloning schema objects


internals.Base.prototype[Common.symbols.any] = {
    version: Common.version,
    compile: Compile.compile,
    root: '$_root'
};


// Aliases

internals.Base.prototype.deny = internals.Base.prototype.invalid;
internals.Base.prototype.disallow = internals.Base.prototype.invalid;
internals.Base.prototype.equal = internals.Base.prototype.valid;
internals.Base.prototype.exist = internals.Base.prototype.required;
internals.Base.prototype.not = internals.Base.prototype.invalid;
internals.Base.prototype.options = internals.Base.prototype.prefs;
internals.Base.prototype.preferences = internals.Base.prototype.prefs;


module.exports = new internals.Base();


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/cache.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/cache.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {
    max: 1000,
    supported: new Set(['undefined', 'boolean', 'number', 'string'])
};


exports.provider = {

    provision(options) {

        return new internals.Cache(options);
    }
};


// Least Recently Used (LRU) Cache

internals.Cache = class {

    constructor(options = {}) {

        Common.assertOptions(options, ['max']);
        Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');

        this._max = options.max || internals.max;

        this._map = new Map();                          // Map of nodes by key
        this._list = new internals.List();              // List of nodes (most recently used in head)
    }

    get length() {

        return this._map.size;
    }

    set(key, value) {

        if (key !== null &&
            !internals.supported.has(typeof key)) {

            return;
        }

        let node = this._map.get(key);
        if (node) {
            node.value = value;
            this._list.first(node);
            return;
        }

        node = this._list.unshift({ key, value });
        this._map.set(key, node);
        this._compact();
    }

    get(key) {

        const node = this._map.get(key);
        if (node) {
            this._list.first(node);
            return Clone(node.value);
        }
    }

    _compact() {

        if (this._map.size > this._max) {
            const node = this._list.pop();
            this._map.delete(node.key);
        }
    }
};


internals.List = class {

    constructor() {

        this.tail = null;
        this.head = null;
    }

    unshift(node) {

        node.next = null;
        node.prev = this.head;

        if (this.head) {
            this.head.next = node;
        }

        this.head = node;

        if (!this.tail) {
            this.tail = node;
        }

        return node;
    }

    first(node) {

        if (node === this.head) {
            return;
        }

        this._remove(node);
        this.unshift(node);
    }

    pop() {

        return this._remove(this.tail);
    }

    _remove(node) {

        const { next, prev } = node;

        next.prev = prev;

        if (prev) {
            prev.next = next;
        }

        if (node === this.tail) {
            this.tail = next;
        }

        node.prev = null;
        node.next = null;

        return node;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/common.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/common.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const AssertError = __webpack_require__(/*! @hapi/hoek/lib/error */ "./node_modules/@hapi/hoek/lib/error.js");

const Pkg = __webpack_require__(/*! ../package.json */ "./node_modules/@hapi/joi/package.json");

let Messages;
let Schemas;


const internals = {
    isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/
};


exports.version = Pkg.version;


exports.defaults = {
    abortEarly: true,
    allowUnknown: false,
    cache: true,
    context: null,
    convert: true,
    dateFormat: 'iso',
    errors: {
        escapeHtml: false,
        label: 'path',
        language: null,
        render: true,
        stack: false,
        wrapArrays: true
    },
    externals: true,
    messages: {},
    nonEnumerables: false,
    noDefaults: false,
    presence: 'optional',
    skipFunctions: false,
    stripUnknown: false,
    warnings: false
};


exports.symbols = {
    any: Symbol.for('@hapi/joi/schema'),            // Used to internally identify any-based types (shared with other joi versions)
    arraySingle: Symbol('arraySingle'),
    deepDefault: Symbol('deepDefault'),
    literal: Symbol('literal'),
    override: Symbol('override'),
    prefs: Symbol('prefs'),
    ref: Symbol('ref'),
    values: Symbol('values'),
    template: Symbol('template')
};


exports.assertOptions = function (options, keys, name = 'Options') {

    Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');
    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));
    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);
};


exports.checkPreferences = function (prefs) {

    Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/@hapi/joi/lib/schemas.js");

    const result = Schemas.preferences.validate(prefs);

    if (result.error) {
        throw new AssertError([result.error.details[0].message]);
    }
};


exports.compare = function (a, b, operator) {

    switch (operator) {
        case '=': return a === b;
        case '>': return a > b;
        case '<': return a < b;
        case '>=': return a >= b;
        case '<=': return a <= b;
    }
};


exports.default = function (value, defaultValue) {

    return value === undefined ? defaultValue : value;
};


exports.isIsoDate = function (date) {

    return internals.isoDate.test(date);
};


exports.isNumber = function (value) {

    return typeof value === 'number' && !isNaN(value);
};


exports.isResolvable = function (obj) {

    if (!obj) {
        return false;
    }

    return obj[exports.symbols.ref] || obj[exports.symbols.template];
};


exports.isSchema = function (schema, options = {}) {

    const any = schema && schema[exports.symbols.any];
    if (!any) {
        return false;
    }

    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');
    return true;
};


exports.isValues = function (obj) {

    return obj[exports.symbols.values];
};


exports.limit = function (value) {

    return Number.isSafeInteger(value) && value >= 0;
};


exports.preferences = function (target, source) {

    Messages = Messages || __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");

    target = target || {};
    source = source || {};

    const merged = Object.assign({}, target, source);
    if (source.errors &&
        target.errors) {

        merged.errors = Object.assign({}, target.errors, source.errors);
    }

    if (source.messages) {
        merged.messages = Messages.compile(source.messages, target.messages);
    }

    delete merged[exports.symbols.prefs];
    return merged;
};


exports.tryWithPath = function (fn, key, options = {}) {

    try {
        return fn();
    }
    catch (err) {
        if (err.path !== undefined) {
            err.path = key + '.' + err.path;
        }
        else {
            err.path = key;
        }

        if (options.append) {
            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


exports.validateArg = function (value, label, { assert, message }) {

    if (exports.isSchema(assert)) {
        const result = assert.validate(value);
        if (!result.error) {
            return;
        }

        return result.error.message;
    }
    else if (!assert(value)) {
        return label ? `${label} ${message}` : message;
    }
};


exports.verifyFlat = function (args, method) {

    for (const arg of args) {
        Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/compile.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/compile.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {};


exports.schema = function (Joi, config, options = {}) {

    Common.assertOptions(options, ['appendPath', 'override']);

    try {
        return internals.schema(Joi, config, options);
    }
    catch (err) {
        if (options.appendPath &&
            err.path !== undefined) {

            err.message = `${err.message} (${err.path})`;
        }

        throw err;
    }
};


internals.schema = function (Joi, config, options) {

    Assert(config !== undefined, 'Invalid undefined schema');

    if (Array.isArray(config)) {
        Assert(config.length, 'Invalid empty array schema');

        if (config.length === 1) {
            config = config[0];
        }
    }

    const valid = (base, ...values) => {

        if (options.override !== false) {
            return base.valid(Joi.override, ...values);
        }

        return base.valid(...values);
    };

    if (internals.simple(config)) {
        return valid(Joi, config);
    }

    if (typeof config === 'function') {
        return Joi.custom(config);
    }

    Assert(typeof config === 'object', 'Invalid schema content:', typeof config);

    if (Common.isResolvable(config)) {
        return valid(Joi, config);
    }

    if (Common.isSchema(config)) {
        return config;
    }

    if (Array.isArray(config)) {
        for (const item of config) {
            if (!internals.simple(item)) {
                return Joi.alternatives().try(...config);
            }
        }

        return valid(Joi, ...config);
    }

    if (config instanceof RegExp) {
        return Joi.string().regex(config);
    }

    if (config instanceof Date) {
        return valid(Joi.date(), config);
    }

    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    return Joi.object().keys(config);
};


exports.ref = function (id, options) {

    return Ref.isRef(id) ? id : Ref.create(id, options);
};


exports.compile = function (root, schema, options = {}) {

    Common.assertOptions(options, ['legacy']);

    // Compiled by any supported version

    const any = schema && schema[Common.symbols.any];
    if (any) {
        Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas');
        return schema;
    }

    // Uncompiled root

    if (typeof schema !== 'object' ||
        !options.legacy) {

        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions
    }

    // Scan schema for compiled parts

    const compiler = internals.walk(schema);
    if (!compiler) {
        return exports.schema(root, schema, { appendPath: true });
    }

    return compiler.compile(compiler.root, schema);
};


internals.walk = function (schema) {

    if (typeof schema !== 'object') {
        return null;
    }

    if (Array.isArray(schema)) {
        for (const item of schema) {
            const compiler = internals.walk(item);
            if (compiler) {
                return compiler;
            }
        }

        return null;
    }

    const any = schema[Common.symbols.any];
    if (any) {
        return { root: schema[any.root], compile: any.compile };
    }

    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');

    for (const key in schema) {
        const compiler = internals.walk(schema[key]);
        if (compiler) {
            return compiler;
        }
    }

    return null;
};


internals.simple = function (value) {

    return value === null || ['boolean', 'string', 'number'].includes(typeof value);
};


exports.when = function (schema, condition, options) {

    if (options === undefined) {
        Assert(condition && typeof condition === 'object', 'Missing options');

        options = condition;
        condition = Ref.create('.');
    }

    if (Array.isArray(options)) {
        options = { switch: options };
    }

    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);

    // Schema condition

    if (Common.isSchema(condition)) {
        Assert(options.is === undefined, '"is" can not be used with a schema condition');
        Assert(options.not === undefined, '"not" can not be used with a schema condition');
        Assert(options.switch === undefined, '"switch" can not be used with a schema condition');

        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });
    }

    // Single condition

    Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);
    Assert(options.not === undefined || options.is === undefined, 'Cannot combine "is" with "not"');

    if (options.switch === undefined) {
        let rule = options;
        if (options.not !== undefined) {
            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };
        }

        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();
        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of "then", "otherwise", or "switch"');
        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');

        if (options.is !== undefined &&
            !Ref.isRef(options.is) &&
            !Common.isSchema(options.is)) {

            is = is.required();                     // Only apply required if this wasn't already a schema or a ref
        }

        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });
    }

    // Switch statement

    Assert(Array.isArray(options.switch), '"switch" must be an array');
    Assert(options.is === undefined, 'Cannot combine "switch" with "is"');
    Assert(options.not === undefined, 'Cannot combine "switch" with "not"');
    Assert(options.then === undefined, 'Cannot combine "switch" with "then"');

    const rule = {
        ref: exports.ref(condition),
        switch: [],
        break: options.break
    };

    for (let i = 0; i < options.switch.length; ++i) {
        const test = options.switch[i];
        const last = i === options.switch.length - 1;

        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);

        Assert(test.is !== undefined, 'Switch statement missing "is"');
        Assert(test.then !== undefined, 'Switch statement missing "then"');

        const item = {
            is: schema.$_compile(test.is),
            then: schema.$_compile(test.then)
        };

        if (!Ref.isRef(test.is) &&
            !Common.isSchema(test.is)) {

            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref
        }

        if (last) {
            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify "otherwise" inside and outside a "switch"');
            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;
            if (otherwise !== undefined) {
                Assert(rule.break === undefined, 'Cannot specify both otherwise and break');
                item.otherwise = schema.$_compile(otherwise);
            }
        }

        rule.switch.push(item);
    }

    return rule;
};


internals.condition = function (schema, condition) {

    for (const key of ['then', 'otherwise']) {
        if (condition[key] === undefined) {
            delete condition[key];
        }
        else {
            condition[key] = schema.$_compile(condition[key]);
        }
    }

    return condition;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/errors.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/errors.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {
    annotations: Symbol('annotations')
};


exports.Report = class {

    constructor(code, value, local, flags, messages, state, prefs) {

        this.code = code;
        this.flags = flags;
        this.messages = messages;
        this.path = state.path;
        this.prefs = prefs;
        this.state = state;
        this.value = value;

        this.message = null;
        this.template = null;

        this.local = local || {};
        this.local.label = exports.label(this.flags, this.state, this.prefs, this.messages);

        if (this.value !== undefined &&
            !this.local.hasOwnProperty('value')) {

            this.local.value = this.value;
        }

        if (this.path.length) {
            const key = this.path[this.path.length - 1];
            if (typeof key !== 'object') {
                this.local.key = key;
            }
        }
    }

    _setTemplate(template) {

        this.template = template;

        if (!this.flags.label &&
            this.path.length === 0) {

            const localized = this._template(this.template, 'root');
            if (localized) {
                this.local.label = localized;
            }
        }
    }

    toString() {

        if (this.message) {
            return this.message;
        }

        const code = this.code;

        if (!this.prefs.errors.render) {
            return this.code;
        }

        const template = this._template(this.template) ||
            this._template(this.prefs.messages) ||
            this._template(this.messages);

        if (template === undefined) {
            return `Error code "${code}" is not defined, your custom type is missing the correct messages definition`;
        }

        // Render and cache result

        this.message = template.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] });
        if (!this.prefs.errors.label) {
            this.message = this.message.replace(/^"" /, '').trim();
        }

        return this.message;
    }

    _template(messages, code) {

        return exports.template(this.value, messages, code || this.code, this.state, this.prefs);
    }
};


exports.path = function (path) {

    let label = '';
    for (const segment of path) {
        if (typeof segment === 'object') {          // Exclude array single path segment
            continue;
        }

        if (typeof segment === 'string') {
            if (label) {
                label += '.';
            }

            label += segment;
        }
        else {
            label += `[${segment}]`;
        }
    }

    return label;
};


exports.template = function (value, messages, code, state, prefs) {

    if (!messages) {
        return;
    }

    if (Template.isTemplate(messages)) {
        return code !== 'root' ? messages : null;
    }

    let lang = prefs.errors.language;
    if (Common.isResolvable(lang)) {
        lang = lang.resolve(value, state, prefs);
    }

    if (lang &&
        messages[lang] &&
        messages[lang][code] !== undefined) {

        return messages[lang][code];
    }

    return messages[code];
};


exports.label = function (flags, state, prefs, messages) {

    if (flags.label) {
        return flags.label;
    }

    if (!prefs.errors.label) {
        return '';
    }

    let path = state.path;
    if (prefs.errors.label === 'key' &&
        state.path.length > 1) {

        path = state.path.slice(-1);
    }

    return exports.path(path) ||
        exports.template(null, prefs.messages, 'root', state, prefs) ||
        messages && exports.template(null, messages, 'root', state, prefs) ||
        'value';
};


exports.process = function (errors, original, prefs) {

    if (!errors) {
        return null;
    }

    const { override, message, details } = exports.details(errors);
    if (override) {
        return override;
    }

    if (prefs.errors.stack) {
        return new exports.ValidationError(message, details, original);
    }

    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const validationError = new exports.ValidationError(message, details, original);
    Error.stackTraceLimit = limit;
    return validationError;
};


exports.details = function (errors, options = {}) {

    let messages = [];
    const details = [];

    for (const item of errors) {

        // Override

        if (item instanceof Error) {
            if (options.override !== false) {
                return { override: item };
            }

            const message = item.toString();
            messages.push(message);

            details.push({
                message,
                type: 'override',
                context: { error: item }
            });

            continue;
        }

        // Report

        const message = item.toString();
        messages.push(message);

        details.push({
            message,
            path: item.path.filter((v) => typeof v !== 'object'),
            type: item.code,
            context: item.local
        });
    }

    if (messages.length > 1) {
        messages = [...new Set(messages)];
    }

    return { message: messages.join('. '), details };
};


exports.ValidationError = class extends Error {

    constructor(message, details, original) {

        super(message);
        this._original = original;
        this.details = details;
    }

    annotate(stripColorCodes) {

        if (!this._original ||
            typeof this._original !== 'object') {

            return this.details[0].message;
        }

        const redFgEscape = stripColorCodes ? '' : '\u001b[31m';
        const redBgEscape = stripColorCodes ? '' : '\u001b[41m';
        const endColor = stripColorCodes ? '' : '\u001b[0m';

        const obj = Clone(this._original);

        for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first
            const pos = i + 1;
            const error = this.details[i];
            const path = error.path;
            let node = obj;
            for (let j = 0; ; ++j) {
                const seg = path[j];

                if (Common.isSchema(node)) {
                    node = node.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step
                }

                if (j + 1 < path.length &&
                    typeof node[seg] !== 'string') {

                    node = node[seg];
                }
                else {
                    const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };
                    node[internals.annotations] = refAnnotations;

                    const cacheKey = seg || error.context.key;

                    if (node[seg] !== undefined) {
                        refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];
                        refAnnotations.errors[cacheKey].push(pos);
                    }
                    else {
                        refAnnotations.missing[cacheKey] = pos;
                    }

                    break;
                }
            }
        }

        const replacers = {
            key: /_\$key\$_([, \d]+)_\$end\$_"/g,
            missing: /"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,
            arrayIndex: /\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,
            specials: /"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g
        };

        let message = internals.safeStringify(obj, 2)
            .replace(replacers.key, ($0, $1) => `" ${redFgEscape}[${$1}]${endColor}`)
            .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}"${$1}"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)
            .replace(replacers.arrayIndex, ($0, $1, $2) => `\n${$2} ${redFgEscape}[${$1}]${endColor}`)
            .replace(replacers.specials, ($0, $1) => $1);

        message = `${message}\n${redFgEscape}`;

        for (let i = 0; i < this.details.length; ++i) {
            const pos = i + 1;
            message = `${message}\n[${pos}] ${this.details[i].message}`;
        }

        message = message + endColor;

        return message;
    }
};


exports.ValidationError.prototype.isJoi = true;


exports.ValidationError.prototype.name = 'ValidationError';


// Inspired by json-stringify-safe

internals.safeStringify = function (obj, spaces) {

    return JSON.stringify(obj, internals.serializer(), spaces);
};


internals.serializer = function () {

    const keys = [];
    const stack = [];

    const cycleReplacer = (key, value) => {

        if (stack[0] === value) {
            return '[Circular ~]';
        }

        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
    };

    return function (key, value) {

        if (stack.length > 0) {
            const thisPos = stack.indexOf(this);
            if (~thisPos) {
                stack.length = thisPos + 1;
                keys.length = thisPos + 1;
                keys[thisPos] = key;
            }
            else {
                stack.push(this);
                keys.push(key);
            }

            if (~stack.indexOf(value)) {
                value = cycleReplacer.call(this, key, value);
            }
        }
        else {
            stack.push(value);
        }

        if (value) {
            const annotations = value[internals.annotations];
            if (annotations) {
                if (Array.isArray(value)) {
                    const annotated = [];

                    for (let i = 0; i < value.length; ++i) {
                        if (annotations.errors[i]) {
                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);
                        }

                        annotated.push(value[i]);
                    }

                    value = annotated;
                }
                else {
                    for (const errorKey in annotations.errors) {
                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];
                        value[errorKey] = undefined;
                    }

                    for (const missingKey in annotations.missing) {
                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';
                    }
                }

                return value;
            }
        }

        if (value === Infinity ||
            value === -Infinity ||
            Number.isNaN(value) ||
            typeof value === 'function' ||
            typeof value === 'symbol') {

            return '[' + value.toString() + ']';
        }

        return value;
    };
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/extend.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/extend.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");


const internals = {};


exports.type = function (from, options) {

    const base = Object.getPrototypeOf(from);
    const prototype = Clone(base);
    const schema = from._assign(Object.create(prototype));
    const def = Object.assign({}, options);                                 // Shallow cloned
    delete def.base;

    prototype._definition = def;

    const parent = base._definition || {};
    def.messages = Messages.merge(parent.messages, def.messages);
    def.properties = Object.assign({}, parent.properties, def.properties);

    // Type

    schema.type = def.type;

    // Flags

    def.flags = Object.assign({}, parent.flags, def.flags);

    // Terms

    const terms = Object.assign({}, parent.terms);
    if (def.terms) {
        for (const name in def.terms) {                                     // Only apply own terms
            const term = def.terms[name];
            Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);
            schema.$_terms[name] = term.init;
            terms[name] = term;
        }
    }

    def.terms = terms;

    // Constructor arguments

    if (!def.args) {
        def.args = parent.args;
    }

    // Prepare

    def.prepare = internals.prepare(def.prepare, parent.prepare);

    // Coerce

    if (def.coerce) {
        if (typeof def.coerce === 'function') {
            def.coerce = { method: def.coerce };
        }

        if (def.coerce.from &&
            !Array.isArray(def.coerce.from)) {

            def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };
        }
    }

    def.coerce = internals.coerce(def.coerce, parent.coerce);

    // Validate

    def.validate = internals.validate(def.validate, parent.validate);

    // Rules

    const rules = Object.assign({}, parent.rules);
    if (def.rules) {
        for (const name in def.rules) {
            const rule = def.rules[name];
            Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);

            let method = rule.method;
            if (method === undefined) {
                method = function () {

                    return this.$_addRule(name);
                };
            }

            if (method) {
                Assert(!prototype[name], 'Rule conflict in', def.type, name);
                prototype[name] = method;
            }

            Assert(!rules[name], 'Rule conflict in', def.type, name);
            rules[name] = rule;

            if (rule.alias) {
                const aliases = [].concat(rule.alias);
                for (const alias of aliases) {
                    prototype[alias] = rule.method;
                }
            }

            if (rule.args) {
                rule.argsByName = new Map();
                rule.args = rule.args.map((arg) => {

                    if (typeof arg === 'string') {
                        arg = { name: arg };
                    }

                    Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);

                    if (Common.isSchema(arg.assert)) {
                        arg.assert = arg.assert.strict().label(arg.name);
                    }

                    rule.argsByName.set(arg.name, arg);
                    return arg;
                });
            }
        }
    }

    def.rules = rules;

    // Modifiers

    const modifiers = Object.assign({}, parent.modifiers);
    if (def.modifiers) {
        for (const name in def.modifiers) {
            Assert(!prototype[name], 'Rule conflict in', def.type, name);

            const modifier = def.modifiers[name];
            Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);

            const method = function (arg) {

                return this.rule({ [name]: arg });
            };

            prototype[name] = method;
            modifiers[name] = modifier;
        }
    }

    def.modifiers = modifiers;

    // Overrides

    if (def.overrides) {
        prototype._super = base;
        schema.$_super = {};
        for (const override in def.overrides) {
            Assert(base[override], 'Cannot override missing', override);
            schema.$_super[override] = base[override].bind(schema);
        }

        Object.assign(prototype, def.overrides);
    }

    // Casts

    def.cast = Object.assign({}, parent.cast, def.cast);

    // Manifest

    const manifest = Object.assign({}, parent.manifest, def.manifest);
    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);
    def.manifest = manifest;

    // Rebuild

    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);

    return schema;
};


// Helpers

internals.build = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (obj, desc) {

        return parent(child(obj, desc), desc);
    };
};


internals.coerce = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return {
        from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,
        method(value, helpers) {

            let coerced;
            if (!parent.from ||
                parent.from.includes(typeof value)) {

                coerced = parent.method(value, helpers);
                if (coerced) {
                    if (coerced.errors ||
                        coerced.value === undefined) {

                        return coerced;
                    }

                    value = coerced.value;
                }
            }

            if (!child.from ||
                child.from.includes(typeof value)) {

                const own = child.method(value, helpers);
                if (own) {
                    return own;
                }
            }

            return coerced;
        }
    };
};


internals.prepare = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const prepared = child(value, helpers);
        if (prepared) {
            if (prepared.errors ||
                prepared.value === undefined) {

                return prepared;
            }

            value = prepared.value;
        }

        return parent(value, helpers) || prepared;
    };
};


internals.rebuild = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (schema) {

        parent(schema);
        child(schema);
    };
};


internals.validate = function (child, parent) {

    if (!child ||
        !parent) {

        return child || parent;
    }

    return function (value, helpers) {

        const result = parent(value, helpers);
        if (result) {
            if (result.errors &&
                (!Array.isArray(result.errors) || result.errors.length)) {

                return result;
            }

            value = result.value;
        }

        return child(value, helpers) || result;
    };
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Cache = __webpack_require__(/*! ./cache */ "./node_modules/@hapi/joi/lib/cache.js");
const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ./compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Extend = __webpack_require__(/*! ./extend */ "./node_modules/@hapi/joi/lib/extend.js");
const Manifest = __webpack_require__(/*! ./manifest */ "./node_modules/@hapi/joi/lib/manifest.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");
const Trace = __webpack_require__(/*! ./trace */ "./node_modules/@hapi/joi/lib/trace.js");

let Schemas;


const internals = {
    types: {
        alternatives: __webpack_require__(/*! ./types/alternatives */ "./node_modules/@hapi/joi/lib/types/alternatives.js"),
        any: __webpack_require__(/*! ./types/any */ "./node_modules/@hapi/joi/lib/types/any.js"),
        array: __webpack_require__(/*! ./types/array */ "./node_modules/@hapi/joi/lib/types/array.js"),
        boolean: __webpack_require__(/*! ./types/boolean */ "./node_modules/@hapi/joi/lib/types/boolean.js"),
        date: __webpack_require__(/*! ./types/date */ "./node_modules/@hapi/joi/lib/types/date.js"),
        function: __webpack_require__(/*! ./types/function */ "./node_modules/@hapi/joi/lib/types/function.js"),
        link: __webpack_require__(/*! ./types/link */ "./node_modules/@hapi/joi/lib/types/link.js"),
        number: __webpack_require__(/*! ./types/number */ "./node_modules/@hapi/joi/lib/types/number.js"),
        object: __webpack_require__(/*! ./types/object */ "./node_modules/@hapi/joi/lib/types/object.js"),
        string: __webpack_require__(/*! ./types/string */ "./node_modules/@hapi/joi/lib/types/string/index.js"),
        symbol: __webpack_require__(/*! ./types/symbol */ "./node_modules/@hapi/joi/lib/types/symbol.js")
    }
};


if (Buffer) {                                                           // $lab:coverage:ignore$
    internals.types.binary = __webpack_require__(/*! ./types/binary */ "./node_modules/@hapi/joi/lib/types/binary.js");
}


internals.root = function () {

    const root = {
        _types: new Set(Object.keys(internals.types))
    };

    // Types

    for (const type of root._types) {
        root[type] = function (...args) {

            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');
            return internals.generate(this, internals.types[type], args);
        };
    }

    // Shortcuts

    for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {
        root[method] = function (...args) {

            return this.any()[method](...args);
        };
    }

    // Methods

    Object.assign(root, internals.methods);

    // Aliases

    root.alt = root.alternatives;
    root.bool = root.boolean;
    root.func = root.function;
    root.x = root.expression;

    // Trace

    if (Trace.setup) {                                          // $lab:coverage:ignore$
        Trace.setup(root);
    }

    return root;
};


internals.methods = {

    ValidationError: Errors.ValidationError,
    version: Common.version,
    cache: Cache.provider,

    assert(value, schema, ...args /* [message], [options] */) {

        internals.assert(value, schema, true, args);
    },

    attempt(value, schema, ...args /* [message], [options] */) {

        return internals.assert(value, schema, false, args);
    },

    build(desc) {

        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');
        return Manifest.build(this, desc);
    },

    checkPreferences(prefs) {

        Common.checkPreferences(prefs);
    },

    compile(schema, options) {

        return Compile.compile(this, schema, options);
    },

    defaults(modifier) {

        Assert(typeof modifier === 'function', 'modifier must be a function');

        const joi = Object.assign({}, this);
        for (const type of joi._types) {
            const schema = modifier(joi[type]());
            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');

            joi[type] = function (...args) {

                return internals.generate(this, schema, args);
            };
        }

        return joi;
    },

    expression(...args) {

        return new Template(...args);
    },

    extend(...extensions) {

        Common.verifyFlat(extensions, 'extend');

        Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/@hapi/joi/lib/schemas.js");

        Assert(extensions.length, 'You need to provide at least one extension');
        this.assert(extensions, Schemas.extensions);

        const joi = Object.assign({}, this);
        joi._types = new Set(joi._types);

        for (let extension of extensions) {
            if (typeof extension === 'function') {
                extension = extension(joi);
            }

            this.assert(extension, Schemas.extension);

            Assert(joi[extension.type] === undefined || joi._types.has(extension.type), 'Cannot override name', extension.type);

            const base = extension.base || this.any();
            const schema = Extend.type(base, extension);

            joi._types.add(extension.type);
            joi[extension.type] = function (...args) {

                return internals.generate(this, schema, args);
            };
        }

        return joi;
    },

    isExpression: Template.isTemplate,
    isRef: Ref.isRef,
    isSchema: Common.isSchema,

    in(...args) {

        return Ref.in(...args);
    },

    override: Common.symbols.override,

    ref(...args) {

        return Ref.create(...args);
    },

    types() {

        const types = {};
        for (const type of this._types) {
            types[type] = this[type]();
        }

        return types;
    }
};


// Helpers

internals.assert = function (value, schema, annotate, args /* [message], [options] */) {

    const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;
    const options = message ? args[1] : args[0];
    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));

    let error = result.error;
    if (!error) {
        return result.value;
    }

    if (message instanceof Error) {
        throw message;
    }

    annotate = annotate && typeof error.annotate === 'function';
    const display = annotate ? error.annotate() : error.message;

    if (error instanceof Errors.ValidationError === false) {
        error = Clone(error);
    }

    error.message = message ? `${message} ${display}` : display;
    throw error;
};


internals.generate = function (root, schema, args) {

    Assert(root, 'Must be invoked on a Joi instance.');

    schema.$_root = root;

    if (!schema._definition.args ||
        !args.length) {

        return schema;
    }

    return schema._definition.args(schema, ...args);
};


module.exports = internals.root();


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/manifest.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/manifest.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Messages = __webpack_require__(/*! ./messages */ "./node_modules/@hapi/joi/lib/messages.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");

let Schemas;


const internals = {};


exports.describe = function (schema) {

    const def = schema._definition;

    // Type

    const desc = {
        type: schema.type,
        flags: {},
        rules: []
    };

    // Flags

    for (const flag in schema._flags) {
        if (flag[0] !== '_') {
            desc.flags[flag] = internals.describe(schema._flags[flag]);
        }
    }

    if (!Object.keys(desc.flags).length) {
        delete desc.flags;
    }

    // Preferences

    if (schema._preferences) {
        desc.preferences = Clone(schema._preferences, { shallow: ['messages'] });
        delete desc.preferences[Common.symbols.prefs];
        if (desc.preferences.messages) {
            desc.preferences.messages = Messages.decompile(desc.preferences.messages);
        }
    }

    // Allow / Invalid

    if (schema._valids) {
        desc.allow = schema._valids.describe();
    }

    if (schema._invalids) {
        desc.invalid = schema._invalids.describe();
    }

    // Rules

    for (const rule of schema._rules) {
        const ruleDef = def.rules[rule.name];
        if (ruleDef.manifest === false) {                           // Defaults to true
            continue;
        }

        const item = { name: rule.name };

        for (const custom in def.modifiers) {
            if (rule[custom] !== undefined) {
                item[custom] = internals.describe(rule[custom]);
            }
        }

        if (rule.args) {
            item.args = {};
            for (const key in rule.args) {
                const arg = rule.args[key];
                if (key === 'options' &&
                    !Object.keys(arg).length) {

                    continue;
                }

                item.args[key] = internals.describe(arg, { assign: key });
            }

            if (!Object.keys(item.args).length) {
                delete item.args;
            }
        }

        desc.rules.push(item);
    }

    if (!desc.rules.length) {
        delete desc.rules;
    }

    // Terms (must be last to verify no name conflicts)

    for (const term in schema.$_terms) {
        if (term[0] === '_') {
            continue;
        }

        Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);

        const items = schema.$_terms[term];
        if (!items) {
            continue;
        }

        if (items instanceof Map) {
            if (items.size) {
                desc[term] = [...items.entries()];
            }

            continue;
        }

        if (Common.isValues(items)) {
            desc[term] = items.describe();
            continue;
        }

        Assert(def.terms[term], 'Term', term, 'missing configuration');
        const manifest = def.terms[term].manifest;
        const mapped = typeof manifest === 'object';
        if (!items.length &&
            !mapped) {

            continue;
        }

        const normalized = [];
        for (const item of items) {
            normalized.push(internals.describe(item));
        }

        // Mapped

        if (mapped) {
            const { from, to } = manifest.mapped;
            desc[term] = {};
            for (const item of normalized) {
                desc[term][item[to]] = item[from];
            }

            continue;
        }

        // Single

        if (manifest === 'single') {
            Assert(normalized.length === 1, 'Term', term, 'contains more than one item');
            desc[term] = normalized[0];
            continue;
        }

        // Array

        desc[term] = normalized;
    }

    internals.validate(schema.$_root, desc);
    return desc;
};


internals.describe = function (item, options = {}) {

    if (Array.isArray(item)) {
        return item.map(internals.describe);
    }

    if (item === Common.symbols.deepDefault) {
        return { special: 'deep' };
    }

    if (typeof item !== 'object') {
        return item;
    }

    if (options.assign === 'options') {
        return Clone(item);
    }

    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$
        return { buffer: item.toString('binary') };
    }

    if (item instanceof Date) {
        return item.toISOString();
    }

    if (item instanceof Error) {
        return item;
    }

    if (item instanceof RegExp) {
        if (options.assign === 'regex') {
            return item.toString();
        }

        return { regex: item.toString() };
    }

    if (item[Common.symbols.literal]) {
        return { function: item.literal };
    }

    if (typeof item.describe === 'function') {
        if (options.assign === 'ref') {
            return item.describe().ref;
        }

        return item.describe();
    }

    const normalized = {};
    for (const key in item) {
        const value = item[key];
        if (value === undefined) {
            continue;
        }

        normalized[key] = internals.describe(value, { assign: key });
    }

    return normalized;
};


exports.build = function (joi, desc) {

    const builder = new internals.Builder(joi);
    return builder.parse(desc);
};


internals.Builder = class {

    constructor(joi) {

        this.joi = joi;
    }

    parse(desc) {

        internals.validate(this.joi, desc);

        // Type

        let schema = this.joi[desc.type]();
        const def = schema._definition;

        // Flags

        if (desc.flags) {
            for (const flag in desc.flags) {
                const setter = def.flags[flag] && def.flags[flag].setter || flag;
                Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);
                schema = schema[setter](this.build(desc.flags[flag]));
            }
        }

        // Preferences

        if (desc.preferences) {
            schema = schema.preferences(this.build(desc.preferences));
        }

        // Allow / Invalid

        if (desc.allow) {
            schema = schema.allow(...this.build(desc.allow));
        }

        if (desc.invalid) {
            schema = schema.invalid(...this.build(desc.invalid));
        }

        // Rules

        if (desc.rules) {
            for (const rule of desc.rules) {
                Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);

                const args = [];
                if (rule.args) {
                    const built = {};
                    for (const key in rule.args) {
                        built[key] = this.build(rule.args[key], { assign: key });
                    }

                    const keys = Object.keys(built);
                    const definition = def.rules[rule.name].args;
                    if (definition) {
                        Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');
                        for (const { name } of definition) {
                            args.push(built[name]);
                        }
                    }
                    else {
                        Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');
                        args.push(built[keys[0]]);
                    }
                }

                // Apply

                schema = schema[rule.name](...args);

                // Ruleset

                const options = {};
                for (const custom in def.modifiers) {
                    if (rule[custom] !== undefined) {
                        options[custom] = this.build(rule[custom]);
                    }
                }

                if (Object.keys(options).length) {
                    schema = schema.rule(options);
                }
            }
        }

        // Terms

        const terms = {};
        for (const key in desc) {
            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {
                continue;
            }

            Assert(def.terms[key], 'Term', key, 'missing configuration');
            const manifest = def.terms[key].manifest;

            if (manifest === 'schema') {
                terms[key] = desc[key].map((item) => this.parse(item));
                continue;
            }

            if (manifest === 'values') {
                terms[key] = desc[key].map((item) => this.build(item));
                continue;
            }

            if (manifest === 'single') {
                terms[key] = this.build(desc[key]);
                continue;
            }

            if (typeof manifest === 'object') {
                terms[key] = {};
                for (const name in desc[key]) {
                    const value = desc[key][name];
                    terms[key][name] = this.parse(value);
                }

                continue;
            }

            terms[key] = this.build(desc[key]);
        }

        if (desc.whens) {
            terms.whens = desc.whens.map((when) => this.build(when));
        }

        schema = def.manifest.build(schema, terms);
        schema.$_temp.ruleset = false;
        return schema;
    }

    build(desc, options = {}) {

        if (desc === null) {
            return null;
        }

        if (Array.isArray(desc)) {
            return desc.map((item) => this.build(item));
        }

        if (desc instanceof Error) {
            return desc;
        }

        if (options.assign === 'options') {
            return Clone(desc);
        }

        if (options.assign === 'regex') {
            return internals.regex(desc);
        }

        if (options.assign === 'ref') {
            return Ref.build(desc);
        }

        if (typeof desc !== 'object') {
            return desc;
        }

        if (Object.keys(desc).length === 1) {
            if (desc.buffer) {
                Assert(Buffer, 'Buffers are not supported');
                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$
            }

            if (desc.function) {
                return { [Common.symbols.literal]: true, literal: desc.function };
            }

            if (desc.override) {
                return Common.symbols.override;
            }

            if (desc.ref) {
                return Ref.build(desc.ref);
            }

            if (desc.regex) {
                return internals.regex(desc.regex);
            }

            if (desc.special) {
                Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);
                return Common.symbols.deepDefault;
            }

            if (desc.value) {
                return Clone(desc.value);
            }
        }

        if (desc.type) {
            return this.parse(desc);
        }

        if (desc.template) {
            return Template.build(desc);
        }

        const normalized = {};
        for (const key in desc) {
            normalized[key] = this.build(desc[key], { assign: key });
        }

        return normalized;
    }
};


internals.regex = function (string) {

    const end = string.lastIndexOf('/');
    const exp = string.slice(1, end);
    const flags = string.slice(end + 1);
    return new RegExp(exp, flags);
};


internals.validate = function (joi, desc) {

    Schemas = Schemas || __webpack_require__(/*! ./schemas */ "./node_modules/@hapi/joi/lib/schemas.js");

    joi.assert(desc, Schemas.description);
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");

const Template = __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {};


exports.compile = function (messages, target) {

    // Single value string ('plain error message', 'template {error} message')

    if (typeof messages === 'string') {
        Assert(!target, 'Cannot set single message string');
        return new Template(messages);
    }

    // Single value template

    if (Template.isTemplate(messages)) {
        Assert(!target, 'Cannot set single message template');
        return messages;
    }

    // By error code { 'number.min': <string | template> }

    Assert(typeof messages === 'object' && !Array.isArray(messages), 'Invalid message options');

    target = target ? Clone(target) : {};

    for (let code in messages) {
        const message = messages[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


exports.decompile = function (messages) {

    // By error code { 'number.min': <string | template> }

    const target = {};
    for (let code in messages) {
        const message = messages[code];

        if (code === 'root') {
            target[code] = message;
            continue;
        }

        if (Template.isTemplate(message)) {
            target[code] = message.describe({ compact: true });
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        const language = code;
        target[language] = {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root') {
                target[language][code] = localized;
                continue;
            }

            target[language][code] = localized.describe({ compact: true });
        }
    }

    return target;
};


exports.merge = function (base, extended) {

    if (!base) {
        return exports.compile(extended);
    }

    if (!extended) {
        return base;
    }

    // Single value string

    if (typeof extended === 'string') {
        return new Template(extended);
    }

    // Single value template

    if (Template.isTemplate(extended)) {
        return extended;
    }

    // By error code { 'number.min': <string | template> }

    const target = Clone(base);

    for (let code in extended) {
        const message = extended[code];

        if (code === 'root' ||
            Template.isTemplate(message)) {

            target[code] = message;
            continue;
        }

        if (typeof message === 'string') {
            target[code] = new Template(message);
            continue;
        }

        // By language { english: { 'number.min': <string | template> } }

        Assert(typeof message === 'object' && !Array.isArray(message), 'Invalid message for', code);

        const language = code;
        target[language] = target[language] || {};

        for (code in message) {
            const localized = message[code];

            if (code === 'root' ||
                Template.isTemplate(localized)) {

                target[language][code] = localized;
                continue;
            }

            Assert(typeof localized === 'string', 'Invalid message for', code, 'in', language);
            target[language][code] = new Template(localized);
        }
    }

    return target;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/modify.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/modify.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {};



exports.Ids = internals.Ids = class {

    constructor() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    clone() {

        const clone = new internals.Ids();
        clone._byId = new Map(this._byId);
        clone._byKey = new Map(this._byKey);
        clone._schemaChain = this._schemaChain;
        return clone;
    }

    concat(source) {

        if (source._schemaChain) {
            this._schemaChain = true;
        }

        for (const [id, value] of source._byId.entries()) {
            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);
            this._byId.set(id, value);
        }

        for (const [key, value] of source._byKey.entries()) {
            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);
            this._byKey.set(key, value);
        }
    }

    fork(path, adjuster, root) {

        const chain = this._collect(path);
        chain.push({ schema: root });
        const tail = chain.shift();
        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };

        Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');

        for (const node of chain) {
            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };
        }

        return adjusted.schema;
    }

    labels(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        if (!node) {
            return [...behind, ...path].join('.');
        }

        const forward = path.slice(1);
        behind = [...behind, node.schema._flags.label || current];
        if (!forward.length) {
            return behind.join('.');
        }

        return node.schema._ids.labels(forward, behind);
    }

    reach(path, behind = []) {

        const current = path[0];
        const node = this._get(current);
        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        const forward = path.slice(1);
        if (!forward.length) {
            return node.schema;
        }

        return node.schema._ids.reach(forward, [...behind, current]);
    }

    register(schema, { key } = {}) {

        if (!schema ||
            !Common.isSchema(schema)) {

            return;
        }

        if (schema.$_property('schemaChain') ||
            schema._ids._schemaChain) {

            this._schemaChain = true;
        }

        const id = schema._flags.id;
        if (id) {
            const existing = this._byId.get(id);
            Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);
            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);

            this._byId.set(id, { schema, id });
        }

        if (key) {
            Assert(!this._byKey.has(key), 'Schema already contains key:', key);
            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);

            this._byKey.set(key, { schema, id: key });
        }
    }

    reset() {

        this._byId = new Map();
        this._byKey = new Map();
        this._schemaChain = false;
    }

    _collect(path, behind = [], nodes = []) {

        const current = path[0];
        const node = this._get(current);
        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));

        nodes = [node, ...nodes];

        const forward = path.slice(1);
        if (!forward.length) {
            return nodes;
        }

        return node.schema._ids._collect(forward, [...behind, current], nodes);
    }

    _get(id) {

        return this._byId.get(id) || this._byKey.get(id);
    }
};


internals.fork = function (schema, id, replacement) {

    const each = (item, { key }) => {

        if (id === (item._flags.id || key)) {
            return replacement;
        }
    };

    const obj = exports.schema(schema, { each, ref: false });
    return obj.$_mutateRebuild();
};


exports.schema = function (schema, options) {

    let obj;

    for (const name in schema._flags) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj._flags[name] = result;
        }
    }

    for (let i = 0; i < schema._rules.length; ++i) {
        const rule = schema._rules[i];
        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            const clone = Object.assign({}, rule);
            clone.args = result;
            obj._rules[i] = clone;

            const existingUnique = obj._singleRules.get(rule.name);
            if (existingUnique === rule) {
                obj._singleRules.set(rule.name, clone);
            }
        }
    }

    for (const name in schema.$_terms) {
        if (name[0] === '_') {
            continue;
        }

        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);
        if (result !== undefined) {
            obj = obj || schema.clone();
            obj.$_terms[name] = result;
        }
    }

    return obj;
};


internals.scan = function (item, source, options, _path, _key) {

    const path = _path || [];

    if (item === null ||
        typeof item !== 'object') {

        return;
    }

    let clone;

    if (Array.isArray(item)) {
        for (let i = 0; i < item.length; ++i) {
            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;
            const result = internals.scan(item[i], source, options, [i, ...path], key);
            if (result !== undefined) {
                clone = clone || item.slice();
                clone[i] = result;
            }
        }

        return clone;
    }

    if (options.schema !== false && Common.isSchema(item) ||
        options.ref !== false && Ref.isRef(item)) {

        const result = options.each(item, { ...source, path, key: _key });
        if (result === item) {
            return;
        }

        return result;
    }

    for (const key in item) {
        if (key[0] === '_') {
            continue;
        }

        const result = internals.scan(item[key], source, options, [key, ...path], _key);
        if (result !== undefined) {
            clone = clone || Object.assign({}, item);
            clone[key] = result;
        }
    }

    return clone;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/ref.js":
/*!*******************************************!*\
  !*** ./node_modules/@hapi/joi/lib/ref.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");

let Template;


const internals = {
    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)
    defaults: {
        adjust: null,
        in: false,
        iterables: null,
        map: null,
        separator: '.',
        type: 'value'
    }
};


exports.create = function (key, options = {}) {

    Assert(typeof key === 'string', 'Invalid reference key:', key);
    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'separator']);
    Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');

    const ref = Object.assign({}, internals.defaults, options);
    delete ref.prefix;

    const separator = ref.separator;
    const context = internals.context(key, separator, options.prefix);
    ref.type = context.type;
    key = context.key;

    if (ref.type === 'value') {
        if (context.root) {
            Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');
            ref.ancestor = 'root';
            if (!key) {
                key = null;
            }
        }

        if (separator &&
            separator === key) {

            key = null;
            ref.ancestor = 0;
        }
        else {
            if (ref.ancestor !== undefined) {
                Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');
            }
            else {
                const [ancestor, slice] = internals.ancestor(key, separator);
                if (slice) {
                    key = key.slice(slice);
                    if (key === '') {
                        key = null;
                    }
                }

                ref.ancestor = ancestor;
            }
        }
    }

    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];

    return new internals.Ref(ref);
};


exports.in = function (key, options = {}) {

    return exports.create(key, Object.assign({}, options, { in: true }));
};


exports.isRef = function (ref) {

    return ref ? !!ref[Common.symbols.ref] : false;
};


internals.Ref = class {

    constructor(options) {

        Assert(typeof options === 'object', 'Invalid reference construction');
        Common.assertOptions(options, [
            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'separator', 'type',    // Copied
            'depth', 'key', 'root', 'display'                                               // Overridden
        ]);

        Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');
        Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');
        Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');
        Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');

        Object.assign(this, internals.defaults, options);

        Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');

        if (Array.isArray(this.map)) {
            this.map = new Map(this.map);
        }

        this.depth = this.path.length;
        this.key = this.path.length ? this.path.join(this.separator) : null;
        this.root = this.path[0];

        this.updateDisplay();
    }

    resolve(value, state, prefs, local, options = {}) {

        Assert(!this.in || options.in, 'Invalid in() reference usage');

        if (this.type === 'global') {
            return this._resolve(prefs.context, state, options);
        }

        if (this.type === 'local') {
            return this._resolve(local, state, options);
        }

        if (!this.ancestor) {
            return this._resolve(value, state, options);
        }

        if (this.ancestor === 'root') {
            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);
        }

        Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);
        return this._resolve(state.ancestors[this.ancestor - 1], state, options);
    }

    _resolve(target, state, options) {

        let resolved;

        if (this.type === 'value' &&
            state.mainstay.shadow &&
            options.shadow !== false) {

            resolved = state.mainstay.shadow.get(this.absolute(state));
        }

        if (resolved === undefined) {
            resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });
        }

        if (this.adjust) {
            resolved = this.adjust(resolved);
        }

        if (this.map) {
            const mapped = this.map.get(resolved);
            if (mapped !== undefined) {
                resolved = mapped;
            }
        }

        if (state.mainstay) {
            state.mainstay.tracer.resolve(state, this, resolved);
        }

        return resolved;
    }

    toString() {

        return this.display;
    }

    absolute(state) {

        return [...state.path.slice(0, -this.ancestor), ...this.path];
    }

    clone() {

        return new internals.Ref(this);
    }

    describe() {

        const ref = { path: this.path };

        if (this.type !== 'value') {
            ref.type = this.type;
        }

        if (this.separator !== '.') {
            ref.separator = this.separator;
        }

        if (this.type === 'value' &&
            this.ancestor !== 1) {

            ref.ancestor = this.ancestor;
        }

        if (this.map) {
            ref.map = [...this.map];
        }

        for (const key of ['adjust', 'iterables']) {
            if (this[key] !== null) {
                ref[key] = this[key];
            }
        }

        if (this.in !== false) {
            ref.in = true;
        }

        return { ref };
    }

    updateDisplay() {

        const key = this.key !== null ? this.key : '';
        if (this.type !== 'value') {
            this.display = `ref:${this.type}:${key}`;
            return;
        }

        if (!this.separator) {
            this.display = `ref:${key}`;
            return;
        }

        if (!this.ancestor) {
            this.display = `ref:${this.separator}${key}`;
            return;
        }

        if (this.ancestor === 'root') {
            this.display = `ref:root:${key}`;
            return;
        }

        if (this.ancestor === 1) {
            this.display = `ref:${key || '..'}`;
            return;
        }

        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');
        this.display = `ref:${lead}${key || ''}`;
    }
};


internals.Ref.prototype[Common.symbols.ref] = true;


exports.build = function (desc) {

    desc = Object.assign({}, internals.defaults, desc);
    if (desc.type === 'value' &&
        desc.ancestor === undefined) {

        desc.ancestor = 1;
    }

    return new internals.Ref(desc);
};


internals.context = function (key, separator, prefix = {}) {

    key = key.trim();

    const globalp = prefix.global === undefined ? '$' : prefix.global;
    if (globalp !== separator &&
        key.startsWith(globalp)) {

        return { key: key.slice(globalp.length), type: 'global' };
    }

    const local = prefix.local === undefined ? '#' : prefix.local;
    if (local !== separator &&
        key.startsWith(local)) {

        return { key: key.slice(local.length), type: 'local' };
    }

    const root = prefix.root === undefined ? '/' : prefix.root;
    if (root !== separator &&
        key.startsWith(root)) {

        return { key: key.slice(root.length), type: 'value', root: true };
    }

    return { key, type: 'value' };
};


internals.ancestor = function (key, separator) {

    if (!separator) {
        return [1, 0];              // 'a_b' -> 1 (parent)
    }

    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)
        return [1, 0];
    }

    if (key[1] !== separator) {     // '.a.b' -> 0 (self)
        return [0, 1];
    }

    let i = 2;
    while (key[i] === separator) {
        ++i;
    }

    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)
};


exports.toSibling = 0;

exports.toParent = 1;


exports.Manager = class {

    constructor() {

        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...
    }

    register(source, target) {

        if (!source) {
            return;
        }

        target = target === undefined ? exports.toParent : target;

        // Array

        if (Array.isArray(source)) {
            for (const ref of source) {
                this.register(ref, target);
            }

            return;
        }

        // Schema

        if (Common.isSchema(source)) {
            for (const item of source._refs.refs) {
                if (item.ancestor - target >= 0) {
                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });
                }
            }

            return;
        }

        // Reference

        if (exports.isRef(source) &&
            source.type === 'value' &&
            source.ancestor - target >= 0) {

            this.refs.push({ ancestor: source.ancestor - target, root: source.root });
        }

        // Template

        Template = Template || __webpack_require__(/*! ./template */ "./node_modules/@hapi/joi/lib/template.js");

        if (Template.isTemplate(source)) {
            this.register(source.refs(), target);
        }
    }

    get length() {

        return this.refs.length;
    }

    clone() {

        const copy = new exports.Manager();
        copy.refs = Clone(this.refs);
        return copy;
    }

    reset() {

        this.refs = [];
    }

    roots() {

        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/schemas.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/schemas.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Joi = __webpack_require__(/*! ./index */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {};


// Preferences

exports.preferences = Joi.object({
    allowUnknown: Joi.boolean(),
    abortEarly: Joi.boolean(),
    cache: Joi.boolean(),
    context: Joi.object(),
    convert: Joi.boolean(),
    dateFormat: Joi.valid('date', 'iso', 'string', 'time', 'utc'),
    debug: Joi.boolean(),
    errors: {
        escapeHtml: Joi.boolean(),
        label: Joi.valid('path', 'key', false),
        language: [
            Joi.string(),
            Joi.object().ref()
        ],
        render: Joi.boolean(),
        stack: Joi.boolean(),
        wrapArrays: Joi.boolean()
    },
    externals: Joi.boolean(),
    messages: Joi.object(),
    noDefaults: Joi.boolean(),
    nonEnumerables: Joi.boolean(),
    presence: Joi.valid('required', 'optional', 'forbidden'),
    skipFunctions: Joi.boolean(),
    stripUnknown: Joi.object({
        arrays: Joi.boolean(),
        objects: Joi.boolean()
    })
        .or('arrays', 'objects')
        .allow(true, false),
    warnings: Joi.boolean()
})
    .strict();


// Extensions

internals.nameRx = /^[a-zA-Z0-9]+$/;


internals.rule = Joi.object({
    alias: Joi.array().items(Joi.string().pattern(internals.nameRx)).single(),
    args: Joi.array().items(
        Joi.string(),
        Joi.object({
            name: Joi.string().pattern(internals.nameRx).required(),
            ref: Joi.boolean(),
            assert: Joi.alternatives([
                Joi.function(),
                Joi.object().schema()
            ])
                .conditional('ref', { is: true, then: Joi.required() }),
            normalize: Joi.function(),
            message: Joi.string().when('assert', { is: Joi.function(), then: Joi.required() })
        })
    ),
    convert: Joi.boolean(),
    manifest: Joi.boolean(),
    method: Joi.function().allow(false),
    multi: Joi.boolean(),
    validate: Joi.function()
});


exports.extension = Joi.object({
    type: Joi.string().required(),

    args: Joi.function(),
    base: Joi.object().schema(),
    coerce: [
        Joi.function().maxArity(3),
        Joi.object({ method: Joi.function().maxArity(3).required(), from: Joi.array().items(Joi.string()).single() })
    ],
    flags: Joi.object().pattern(internals.nameRx, Joi.object({
        setter: Joi.string(),
        default: Joi.any()
    })),
    manifest: {
        build: Joi.function().arity(2)
    },
    messages: [Joi.object(), Joi.string()],
    modifiers: Joi.object().pattern(internals.nameRx, Joi.function().minArity(1).maxArity(2)),
    overrides: Joi.object().pattern(internals.nameRx, Joi.function()),
    prepare: Joi.function().maxArity(3),
    rebuild: Joi.function().arity(1),
    rules: Joi.object().pattern(internals.nameRx, internals.rule),
    terms: Joi.object().pattern(internals.nameRx, Joi.object({
        init: Joi.array().allow(null).required(),
        manifest: Joi.object().pattern(/.+/, [
            Joi.valid('schema', 'single'),
            Joi.object({
                mapped: Joi.object({
                    from: Joi.string().required(),
                    to: Joi.string().required()
                })
                    .required()
            })
        ])
    })),
    validate: Joi.function().maxArity(3)
})
    .strict();


exports.extensions = Joi.array().items(Joi.object(), Joi.function().arity(1)).strict();


// Manifest

internals.desc = {

    buffer: Joi.object({
        buffer: Joi.string()
    }),

    func: Joi.object({
        function: Joi.function().required(),
        options: {
            literal: true
        }
    }),

    override: Joi.object({
        override: true
    }),

    ref: Joi.object({
        ref: Joi.object({
            type: Joi.valid('value', 'global', 'local'),
            path: Joi.array().required(),
            separator: Joi.string().length(1).allow(false),
            ancestor: Joi.number().min(0).integer().allow('root'),
            map: Joi.array().items(Joi.array().length(2)).min(1),
            adjust: Joi.function(),
            iterables: Joi.boolean(),
            in: Joi.boolean()
        })
            .required()
    }),

    regex: Joi.object({
        regex: Joi.string().min(3)
    }),

    special: Joi.object({
        special: Joi.valid('deep').required()
    }),

    template: Joi.object({
        template: Joi.string().required(),
        options: Joi.object()
    }),

    value: Joi.object({
        value: Joi.alternatives([Joi.object(), Joi.array()]).required()
    })
};


internals.desc.entity = Joi.alternatives([
    Joi.array().items(Joi.link('...')),
    Joi.boolean(),
    Joi.function(),
    Joi.number(),
    Joi.string(),
    internals.desc.buffer,
    internals.desc.func,
    internals.desc.ref,
    internals.desc.regex,
    internals.desc.special,
    internals.desc.template,
    internals.desc.value,
    Joi.link('/')
]);


internals.desc.values = Joi.array()
    .items(
        null,
        Joi.boolean(),
        Joi.function(),
        Joi.number().allow(Infinity, -Infinity),
        Joi.string().allow(''),
        Joi.symbol(),
        internals.desc.buffer,
        internals.desc.func,
        internals.desc.override,
        internals.desc.ref,
        internals.desc.regex,
        internals.desc.template,
        internals.desc.value
    );


internals.desc.messages = Joi.object()
    .pattern(/.+/, [
        Joi.string(),
        internals.desc.template,
        Joi.object().pattern(/.+/, [Joi.string(), internals.desc.template])
    ]);


exports.description = Joi.object({
    type: Joi.string().required(),
    flags: Joi.object({
        cast: Joi.string(),
        default: Joi.any(),
        description: Joi.string(),
        empty: Joi.link('/'),
        failover: internals.desc.entity,
        id: Joi.string(),
        label: Joi.string(),
        only: true,
        presence: ['optional', 'required', 'forbidden'],
        result: ['raw', 'strip'],
        strip: Joi.boolean(),
        unit: Joi.string()
    })
        .unknown(),
    preferences: {
        allowUnknown: Joi.boolean(),
        abortEarly: Joi.boolean(),
        cache: Joi.boolean(),
        convert: Joi.boolean(),
        dateFormat: ['date', 'iso', 'string', 'time', 'utc'],
        errors: {
            escapeHtml: Joi.boolean(),
            label: ['path', 'key'],
            language: [
                Joi.string(),
                internals.desc.ref
            ],
            wrapArrays: Joi.boolean()
        },
        externals: Joi.boolean(),
        messages: internals.desc.messages,
        noDefaults: Joi.boolean(),
        nonEnumerables: Joi.boolean(),
        presence: ['required', 'optional', 'forbidden'],
        skipFunctions: Joi.boolean(),
        stripUnknown: Joi.object({
            arrays: Joi.boolean(),
            objects: Joi.boolean()
        })
            .or('arrays', 'objects')
            .allow(true, false),
        warnings: Joi.boolean()
    },
    allow: internals.desc.values,
    invalid: internals.desc.values,
    rules: Joi.array().min(1).items({
        name: Joi.string().required(),
        args: Joi.object().min(1),
        keep: Joi.boolean(),
        message: [
            Joi.string(),
            internals.desc.messages
        ],
        warn: Joi.boolean()
    }),

    // Terms

    keys: Joi.object().pattern(/.*/, Joi.link('/')),
    link: internals.desc.ref
})
    .pattern(/^[a-z]\w*$/, Joi.any());


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/state.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/state.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {
    value: Symbol('value')
};


module.exports = internals.State = class {

    constructor(path, ancestors, state) {

        this.path = path;
        this.ancestors = ancestors;                 // [parent, ..., root]

        this.mainstay = state.mainstay;
        this.schemas = state.schemas;               // [current, ..., root]
        this.debug = null;
    }

    localize(path, ancestors = null, schema = null) {

        const state = new internals.State(path, ancestors, this);

        if (schema &&
            state.schemas) {

            state.schemas = [internals.schemas(schema), ...state.schemas];
        }

        return state;
    }

    nest(schema, debug) {

        const state = new internals.State(this.path, this.ancestors, this);
        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];
        state.debug = debug;
        return state;
    }

    shadow(value, reason) {

        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();
        this.mainstay.shadow.set(this.path, value, reason);
    }

    snapshot() {

        if (this.mainstay.shadow) {
            this._snapshot = Clone(this.mainstay.shadow.node(this.path));
        }
    }

    restore() {

        if (this.mainstay.shadow) {
            this.mainstay.shadow.override(this.path, this._snapshot);
            this._snapshot = undefined;
        }
    }
};


internals.schemas = function (schema) {

    if (Common.isSchema(schema)) {
        return { schema };
    }

    return schema;
};


internals.Shadow = class {

    constructor() {

        this._values = null;
    }

    set(path, value, reason) {

        if (!path.length) {                                     // No need to store root value
            return;
        }

        if (reason === 'strip' &&
            typeof path[path.length - 1] === 'number') {        // Cannot store stripped array values (due to shift)

            return;
        }

        this._values = this._values || new Map();

        let node = this._values;
        for (let i = 0; i < path.length; ++i) {
            const segment = path[i];
            let next = node.get(segment);
            if (!next) {
                next = new Map();
                node.set(segment, next);
            }

            node = next;
        }

        node[internals.value] = value;
    }

    get(path) {

        const node = this.node(path);
        if (node) {
            return node[internals.value];
        }
    }

    node(path) {

        if (!this._values) {
            return;
        }

        return Reach(this._values, path, { iterables: true });
    }

    override(path, node) {

        if (!this._values) {
            return;
        }

        const parents = path.slice(0, -1);
        const own = path[path.length - 1];
        const parent = Reach(this._values, parents, { iterables: true });

        if (node) {
            parent.set(own, node);
            return;
        }

        if (parent) {
            parent.delete(own);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/template.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/template.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const EscapeHtml = __webpack_require__(/*! @hapi/hoek/lib/escapeHtml */ "./node_modules/@hapi/hoek/lib/escapeHtml.js");
const Formula = __webpack_require__(/*! @hapi/formula */ "./node_modules/@hapi/formula/lib/index.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ./ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {
    symbol: Symbol('template'),

    opens: new Array(1000).join('\u0000'),
    closes: new Array(1000).join('\u0001'),

    dateFormat: {
        date: Date.prototype.toDateString,
        iso: Date.prototype.toISOString,
        string: Date.prototype.toString,
        time: Date.prototype.toTimeString,
        utc: Date.prototype.toUTCString
    }
};


module.exports = exports = internals.Template = class {

    constructor(source, options) {

        Assert(typeof source === 'string', 'Template source must be a string');
        Assert(!source.includes('\u0000') && !source.includes('\u0001'), 'Template source cannot contain reserved control characters');

        this.source = source;
        this.rendered = source;

        this._template = null;
        this._settings = Clone(options);

        this._parse();
    }

    _parse() {

        // 'text {raw} {{ref}} \\{{ignore}} {{ignore\\}} {{ignore {{ignore}'

        if (!this.source.includes('{')) {
            return;
        }

        // Encode escaped \\{{{{{

        const encoded = internals.encode(this.source);

        // Split on first { in each set

        const parts = internals.split(encoded);

        // Process parts

        let refs = false;
        const processed = [];
        const head = parts.shift();
        if (head) {
            processed.push(head);
        }

        for (const part of parts) {
            const raw = part[0] !== '{';
            const ender = raw ? '}' : '}}';
            const end = part.indexOf(ender);
            if (end === -1 ||                               // Ignore non-matching closing
                part[1] === '{') {                          // Ignore more than two {

                processed.push(`{${internals.decode(part)}`);
                continue;
            }

            const variable = part.slice(raw ? 0 : 1, end);
            const dynamic = this._ref(internals.decode(variable), raw);
            processed.push(dynamic);
            if (typeof dynamic !== 'string') {
                refs = true;
            }

            const rest = part.slice(end + ender.length);
            if (rest) {
                processed.push(internals.decode(rest));
            }
        }

        if (!refs) {
            this.rendered = processed.join('');
            return;
        }

        this._template = processed;
    }

    static date(date, prefs) {

        return internals.dateFormat[prefs.dateFormat].call(date);
    }

    describe(options = {}) {

        if (!this._settings &&
            options.compact) {

            return this.source;
        }

        const desc = { template: this.source };
        if (this._settings) {
            desc.options = this._settings;
        }

        return desc;
    }

    static build(desc) {

        return new internals.Template(desc.template, desc.options);
    }

    isDynamic() {

        return !!this._template;
    }

    static isTemplate(template) {

        return template ? !!template[Common.symbols.template] : false;
    }

    refs() {

        if (!this._template) {
            return;
        }

        const refs = [];
        for (const part of this._template) {
            if (typeof part !== 'string') {
                refs.push(...part.refs);
            }
        }

        return refs;
    }

    resolve(value, state, prefs, local) {

        if (this._template &&
            this._template.length === 1) {

            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);
        }

        return this.render(value, state, prefs, local);
    }

    _part(part, ...args) {

        if (part.ref) {
            return part.ref.resolve(...args);
        }

        return part.formula.evaluate(args);
    }

    render(value, state, prefs, local, options = {}) {

        if (!this.isDynamic()) {
            return this.rendered;
        }

        const parts = [];
        for (const part of this._template) {
            if (typeof part === 'string') {
                parts.push(part);
            }
            else {
                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);
                const string = internals.stringify(rendered, prefs, options.errors);
                if (string !== undefined) {
                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);
                    parts.push(result);
                }
            }
        }

        return parts.join('');
    }

    _ref(content, raw) {

        const refs = [];
        const reference = (variable) => {

            const ref = Ref.create(variable, this._settings);
            refs.push(ref);
            return (context) => ref.resolve(...context);
        };

        try {
            var formula = new Formula(content, { reference, functions: internals.functions, constants: internals.constants });
        }
        catch (err) {
            err.message = `Invalid template variable "${content}" fails due to: ${err.message}`;
            throw err;
        }

        if (formula.single) {
            if (formula.single.type === 'reference') {
                return { ref: refs[0], raw, refs };
            }

            return internals.stringify(formula.single.value);
        }

        return { formula, raw, refs };
    }

    toString() {

        return this.source;
    }
};


internals.Template.prototype[Common.symbols.template] = true;
internals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects


internals.encode = function (string) {

    return string
        .replace(/\\(\{+)/g, ($0, $1) => {

            return internals.opens.slice(0, $1.length);
        })
        .replace(/\\(\}+)/g, ($0, $1) => {

            return internals.closes.slice(0, $1.length);
        });
};


internals.decode = function (string) {

    return string
        .replace(/\u0000/g, '{')
        .replace(/\u0001/g, '}');
};


internals.split = function (string) {

    const parts = [];
    let current = '';

    for (let i = 0; i < string.length; ++i) {
        const char = string[i];

        if (char === '{') {
            let next = '';
            while (i + 1 < string.length &&
                string[i + 1] === '{') {

                next += '{';
                ++i;
            }

            parts.push(current);
            current = next;
        }
        else {
            current += char;
        }
    }

    parts.push(current);
    return parts;
};


internals.stringify = function (value, prefs, options) {

    const type = typeof value;

    if (value === null) {
        return 'null';
    }

    if (type === 'string') {
        return value;
    }

    if (type === 'number' ||
        type === 'function' ||
        type === 'symbol') {

        return value.toString();
    }

    if (type !== 'object') {
        return JSON.stringify(value);
    }

    if (value instanceof Date) {
        return internals.Template.date(value, prefs);
    }

    if (value instanceof Map) {
        const pairs = [];
        for (const [key, sym] of value.entries()) {
            pairs.push(`${key.toString()} -> ${sym.toString()}`);
        }

        value = pairs;
    }

    if (!Array.isArray(value)) {
        return value.toString();
    }

    let partial = '';
    for (const item of value) {
        partial = partial + (partial.length ? ', ' : '') + internals.stringify(item, prefs, options);
    }

    return options.wrapArrays ? '[' + partial + ']' : partial;
};


internals.constants = {

    true: true,
    false: false,
    null: null,

    second: 1000,
    minute: 60 * 1000,
    hour: 60 * 60 * 1000,
    day: 24 * 60 * 60 * 1000
};


internals.functions = {

    if(condition, then, otherwise) {

        return condition ? then : otherwise;
    },

    msg(code) {

        const [value, state, prefs, local, options] = this;
        const messages = options.messages;
        if (!messages) {
            return '';
        }

        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);
        if (!template) {
            return '';
        }

        return template.render(value, state, prefs, local, options);
    },

    number(value) {

        if (typeof value === 'number') {
            return value;
        }

        if (typeof value === 'string') {
            return parseFloat(value);
        }

        if (typeof value === 'boolean') {
            return value ? 1 : 0;
        }

        if (value instanceof Date) {
            return value.getTime();
        }

        return null;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/trace.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/trace.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Pinpoint = __webpack_require__(/*! @hapi/pinpoint */ "./node_modules/@hapi/pinpoint/lib/index.js");

const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");


const internals = {
    codes: {
        error: 1,
        pass: 2,
        full: 3
    },
    labels: {
        0: 'never used',
        1: 'always error',
        2: 'always pass'
    }
};


exports.setup = function (root) {

    const trace = function () {

        root._tracer = root._tracer || new internals.Tracer();
        return root._tracer;
    };

    root.trace = trace;
    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;

    root.untrace = () => {

        root._tracer = null;
    };
};


exports.location = function (schema) {

    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller
};


internals.Tracer = class {

    constructor() {

        this.name = 'Joi';
        this._schemas = new Map();
    }

    _register(schema) {

        const existing = this._schemas.get(schema);
        if (existing) {
            return existing.store;
        }

        const store = new internals.Store(schema);
        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller
        this._schemas.set(schema, { filename, line, store });
        return store;
    }

    _combine(merged, sources) {

        for (const { store } of this._schemas.values()) {
            store._combine(merged, sources);
        }
    }

    report(file) {

        const coverage = [];

        // Process each registered schema

        for (const { filename, line, store } of this._schemas.values()) {
            if (file &&
                file !== filename) {

                continue;
            }

            // Process sub schemas of the registered root

            const missing = [];
            const skipped = [];

            for (const [schema, log] of store._sources.entries()) {

                // Check if sub schema parent skipped

                if (internals.sub(log.paths, skipped)) {
                    continue;
                }

                // Check if sub schema reached

                if (!log.entry) {
                    missing.push({
                        status: 'never reached',
                        paths: [...log.paths]
                    });

                    skipped.push(...log.paths);
                    continue;
                }

                // Check values

                for (const type of ['valid', 'invalid']) {
                    const set = schema[`_${type}s`];
                    if (!set) {
                        continue;
                    }

                    const values = new Set(set._values);
                    const refs = new Set(set._refs);
                    for (const { value, ref } of log[type]) {
                        values.delete(value);
                        refs.delete(ref);
                    }

                    if (values.size ||
                        refs.size) {

                        missing.push({
                            status: [...values, ...[...refs].map((ref) => ref.display)],
                            rule: `${type}s`
                        });
                    }
                }

                // Check rules status

                const rules = schema._rules.map((rule) => rule.name);
                for (const type of ['default', 'failover']) {
                    if (schema._flags[type] !== undefined) {
                        rules.push(type);
                    }
                }

                for (const name of rules) {
                    const status = internals.labels[log.rule[name] || 0];
                    if (status) {
                        const report = { rule: name, status };
                        if (log.paths.size) {
                            report.paths = [...log.paths];
                        }

                        missing.push(report);
                    }
                }
            }

            if (missing.length) {
                coverage.push({
                    filename,
                    line,
                    missing,
                    severity: 'error',
                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`
                });
            }
        }

        return coverage.length ? coverage : null;
    }
};


internals.Store = class {

    constructor(schema) {

        this.active = true;
        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }
        this._combos = new Map();           // merged -> [sources]
        this._scan(schema);
    }

    debug(state, source, name, result) {

        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });
    }

    entry(schema, state) {

        internals.debug(state, { type: 'entry' });

        this._record(schema, (log) => {

            log.entry = true;
        });
    }

    filter(schema, state, source, value) {

        internals.debug(state, { type: source, ...value });

        this._record(schema, (log) => {

            log[source].add(value);
        });
    }

    log(schema, state, source, name, result) {

        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });

        this._record(schema, (log) => {

            log[source][name] = log[source][name] || 0;
            log[source][name] |= internals.codes[result];
        });
    }

    resolve(state, ref, to) {

        if (!state.mainstay.debug) {
            return;
        }

        const log = { type: 'resolve', ref: ref.display, to, path: state.path };
        state.mainstay.debug.push(log);
    }

    value(state, by, from, to, name) {

        if (!state.mainstay.debug ||
            DeepEqual(from, to)) {

            return;
        }

        const log = { type: 'value', by, from, to, path: state.path };
        if (name) {
            log.name = name;
        }

        state.mainstay.debug.push(log);
    }

    _record(schema, each) {

        const log = this._sources.get(schema);
        if (log) {
            each(log);
            return;
        }

        const sources = this._combos.get(schema);
        for (const source of sources) {
            this._record(source, each);
        }
    }

    _scan(schema, _path) {

        const path = _path || [];

        let log = this._sources.get(schema);
        if (!log) {
            log = {
                paths: new Set(),
                entry: false,
                rule: {},
                valid: new Set(),
                invalid: new Set()
            };

            this._sources.set(schema, log);
        }

        if (path.length) {
            log.paths.add(path);
        }

        const each = (sub, source) => {

            const subId = internals.id(sub, source);
            this._scan(sub, path.concat(subId));
        };

        schema.$_modify({ each, ref: false });
    }

    _combine(merged, sources) {

        this._combos.set(merged, sources);
    }
};


internals.message = function (item) {

    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';
    return `${path}${item.rule || ''} (${item.status})`;
};


internals.id = function (schema, { source, name, path, key }) {

    if (schema._flags.id) {
        return schema._flags.id;
    }

    if (key) {
        return key;
    }

    name = `@${name}`;

    if (source === 'terms') {
        return [name, path[Math.min(path.length - 1, 1)]];
    }

    return name;
};


internals.sub = function (paths, skipped) {

    for (const path of paths) {
        for (const skip of skipped) {
            if (DeepEqual(path.slice(0, skip.length), skip)) {
                return true;
            }
        }
    }

    return false;
};


internals.debug = function (state, event) {

    if (state.mainstay.debug) {
        event.path = state.debug ? [...state.path, state.debug] : state.path;
        state.mainstay.debug.push(event);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/alternatives.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/alternatives.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ../ref */ "./node_modules/@hapi/joi/lib/ref.js");


const internals = {};


module.exports = Any.extend({

    type: 'alternatives',

    flags: {

        match: { default: 'any' }                 // 'any', 'one', 'all'
    },

    terms: {

        matches: { init: [], register: Ref.toSibling }
    },

    args(schema, ...schemas) {

        if (schemas.length === 1) {
            if (Array.isArray(schemas[0])) {
                return schema.try(...schemas[0]);
            }
        }

        return schema.try(...schemas);
    },

    validate(value, helpers) {

        const { schema, error, state, prefs } = helpers;

        // Match all or one

        if (schema._flags.match) {
            let hits = 0;
            let matched;

            for (let i = 0; i < schema.$_terms.matches.length; ++i) {
                const item = schema.$_terms.matches[i];
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    ++hits;
                    matched = result.value;
                }
                else {
                    localState.restore();
                }
            }

            if (!hits) {
                return { errors: error('alternatives.any') };
            }

            if (schema._flags.match === 'one') {
                return hits === 1 ? { value: matched } : { errors: error('alternatives.one') };
            }

            return hits === schema.$_terms.matches.length ? { value } : { errors: error('alternatives.all') };
        }

        // Match any

        const errors = [];
        for (let i = 0; i < schema.$_terms.matches.length; ++i) {
            const item = schema.$_terms.matches[i];

            // Try

            if (item.schema) {
                const localState = state.nest(item.schema, `match.${i}`);
                localState.snapshot();

                const result = item.schema.$_validate(value, localState, prefs);
                if (!result.errors) {
                    return result;
                }

                localState.restore();
                errors.push({ schema: item.schema, reports: result.errors });
                continue;
            }

            // Conditional

            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;
            const tests = item.is ? [item] : item.switch;

            for (let j = 0; j < tests.length; ++j) {
                const test = tests[j];
                const { is, then, otherwise } = test;

                const id = `match.${i}${item.switch ? '.' + j : ''}`;
                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {
                    if (otherwise) {
                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);
                    }
                }
                else if (then) {
                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);
                }
            }
        }

        return internals.errors(errors, helpers);
    },

    rules: {

        conditional: {
            method(condition, options) {

                Assert(!this._flags._endedSwitch, 'Unreachable condition');
                Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');
                Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');

                const obj = this.clone();

                const match = Compile.when(obj, condition, options);
                const conditions = match.is ? [match] : match.switch;
                for (const item of conditions) {
                    if (item.then &&
                        item.otherwise) {

                        obj.$_setFlag('_endedSwitch', true, { clone: false });
                        break;
                    }
                }

                obj.$_terms.matches.push(match);
                return obj.$_mutateRebuild();
            }
        },

        match: {
            method(mode) {

                Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);

                if (mode !== 'any') {
                    for (const match of this.$_terms.matches) {
                        Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');
                    }
                }

                return this.$_setFlag('match', mode);
            }
        },

        try: {
            method(...schemas) {

                Assert(schemas.length, 'Missing alternative schemas');
                Common.verifyFlat(schemas, 'try');

                Assert(!this._flags._endedSwitch, 'Unreachable condition');

                const obj = this.clone();
                for (const schema of schemas) {
                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });
                }

                return obj.$_mutateRebuild();
            }
        }
    },

    overrides: {

        label(name) {

            const obj = this.$_super.label(name);
            const each = (item, source) => (source.path[0] !== 'is' ? item.label(name) : undefined);
            return obj.$_modify({ each, ref: false });
        }
    },

    rebuild(schema) {

        // Flag when an alternative type is an array

        const each = (item) => {

            if (Common.isSchema(item) &&
                item.type === 'array') {

                schema.$_setFlag('_arrayItems', true, { clone: false });
            }
        };

        schema.$_modify({ each });
    },

    manifest: {

        build(obj, desc) {

            if (desc.matches) {
                for (const match of desc.matches) {
                    const { schema, ref, is, not, then, otherwise } = match;
                    if (schema) {
                        obj = obj.try(schema);
                    }
                    else if (ref) {
                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });
                    }
                    else {
                        obj = obj.conditional(is, { then, otherwise });
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'alternatives.all': '"{{#label}}" does not match all of the required types',
        'alternatives.any': '"{{#label}}" does not match any of the allowed types',
        'alternatives.match': '"{{#label}}" does not match any of the allowed types',
        'alternatives.one': '"{{#label}}" matches more than one allowed type',
        'alternatives.types': '"{{#label}}" must be one of {{#types}}'
    }
});


// Helpers

internals.errors = function (failures, { error, state }) {

    // Nothing matched due to type criteria rules

    if (!failures.length) {
        return { errors: error('alternatives.any') };
    }

    // Single error

    if (failures.length === 1) {
        return { errors: failures[0].reports };
    }

    // Analyze reasons

    const valids = new Set();
    const complex = [];

    for (const { reports, schema } of failures) {

        // Multiple errors (!abortEarly)

        if (reports.length > 1) {
            return internals.unmatched(failures, error);
        }

        // Custom error

        const report = reports[0];
        if (report instanceof Errors.Report === false) {
            return internals.unmatched(failures, error);
        }

        // Internal object or array error

        if (report.state.path.length !== state.path.length) {
            complex.push({ type: schema.type, report });
            continue;
        }

        // Valids

        if (report.code === 'any.only') {
            for (const valid of report.local.valids) {
                valids.add(valid);
            }

            continue;
        }

        // Base type

        const [type, code] = report.code.split('.');
        if (code !== 'base') {
            complex.push({ type: schema.type, report });
            continue;
        }

        valids.add(type);
    }

    // All errors are base types or valids

    if (!complex.length) {
        return { errors: error('alternatives.types', { types: [...valids] }) };
    }

    // Single complex error

    if (complex.length === 1) {
        return { errors: complex[0].report };
    }

    return internals.unmatched(failures, error);
};


internals.unmatched = function (failures, error) {

    const errors = [];
    for (const failure of failures) {
        errors.push(...failure.reports);
    }

    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/any.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/any.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Base = __webpack_require__(/*! ../base */ "./node_modules/@hapi/joi/lib/base.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Messages = __webpack_require__(/*! ../messages */ "./node_modules/@hapi/joi/lib/messages.js");


const internals = {};


module.exports = Base.extend({

    type: 'any',

    flags: {

        only: { default: false }
    },

    terms: {

        alterations: { init: null },
        examples: { init: null },
        externals: { init: null },
        metas: { init: [] },
        notes: { init: [] },
        shared: { init: null },
        tags: { init: [] },
        whens: { init: null }
    },

    rules: {

        custom: {
            method(method, description) {

                Assert(typeof method === 'function', 'Method must be a function');
                Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');

                return this.$_addRule({ name: 'custom', args: { method, description } });
            },
            validate(value, helpers, { method }) {

                try {
                    return method(value, helpers);
                }
                catch (err) {
                    return helpers.error('any.custom', { error: err });
                }
            },
            args: ['method', 'description'],
            multi: true
        },

        messages: {
            method(messages) {

                return this.prefs({ messages });
            }
        },

        shared: {
            method(schema) {

                Assert(Common.isSchema(schema) && schema._flags.id, 'Schema must be a schema with an id');

                const obj = this.clone();
                obj.$_terms.shared = obj.$_terms.shared || [];
                obj.$_terms.shared.push(schema);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        warning: {
            method(code, local) {

                Assert(code && typeof code === 'string', 'Invalid warning code');

                return this.$_addRule({ name: 'warning', args: { code, local }, warn: true });
            },
            validate(value, helpers, { code, local }) {

                return helpers.error(code, local);
            },
            args: ['code', 'local'],
            multi: true
        }
    },

    modifiers: {

        keep(rule, enabled = true) {

            rule.keep = enabled;
        },

        message(rule, message) {

            rule.message = Messages.compile(message);
        },

        warn(rule, enabled = true) {

            rule.warn = enabled;
        }
    },

    manifest: {

        build(obj, desc) {

            for (const key in desc) {
                const values = desc[key];

                if (['examples', 'externals', 'metas', 'notes', 'tags'].includes(key)) {
                    for (const value of values) {
                        obj = obj[key.slice(0, -1)](value);
                    }

                    continue;
                }

                if (key === 'alterations') {
                    const alter = {};
                    for (const { target, adjuster } of values) {
                        alter[target] = adjuster;
                    }

                    obj = obj.alter(alter);
                    continue;
                }

                if (key === 'whens') {
                    for (const value of values) {
                        const { ref, is, not, then, otherwise, concat } = value;
                        if (concat) {
                            obj = obj.concat(concat);
                        }
                        else if (ref) {
                            obj = obj.when(ref, { is, not, then, otherwise, switch: value.switch, break: value.break });
                        }
                        else {
                            obj = obj.when(is, { then, otherwise, break: value.break });
                        }
                    }

                    continue;
                }

                if (key === 'shared') {
                    for (const value of values) {
                        obj = obj.shared(value);
                    }
                }
            }

            return obj;
        }
    },

    messages: {
        'any.custom': '"{{#label}}" failed custom validation because {{#error.message}}',
        'any.default': '"{{#label}}" threw an error when running default method',
        'any.failover': '"{{#label}}" threw an error when running failover method',
        'any.invalid': '"{{#label}}" contains an invalid value',
        'any.only': '"{{#label}}" must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',
        'any.ref': '"{{#label}}" {{#arg}} references "{{#ref}}" which {{#reason}}',
        'any.required': '"{{#label}}" is required',
        'any.unknown': '"{{#label}}" is not allowed'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/array.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/array.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");


const internals = {};


module.exports = Any.extend({

    type: 'array',

    flags: {

        single: { default: false },
        sparse: { default: false }
    },

    terms: {

        items: { init: [], manifest: 'schema' },
        ordered: { init: [], manifest: 'schema' },

        _exclusions: { init: [] },
        _inclusions: { init: [] },
        _requireds: { init: [] }
    },

    coerce: {
        from: 'object',
        method(value, { schema, state, prefs }) {

            if (!Array.isArray(value)) {
                return;
            }

            const sort = schema.$_getRule('sort');
            if (!sort) {
                return;
            }

            return internals.sort(schema, value, sort.args.options, state, prefs);
        }
    },

    validate(value, { schema, error }) {

        if (!Array.isArray(value)) {
            if (schema._flags.single) {
                const single = [value];
                single[Common.symbols.arraySingle] = true;
                return { value: single };
            }

            return { errors: error('array.base') };
        }

        if (!schema.$_getRule('items') &&
            !schema.$_terms.externals) {

            return;
        }

        return { value: value.slice() };        // Clone the array so that we don't modify the original
    },

    rules: {

        has: {
            method(schema) {

                schema = this.$_compile(schema, { appendPath: true });
                const obj = this.$_addRule({ name: 'has', args: { schema } });
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { state, prefs, error }, { schema: has }) {

                const ancestors = [value, ...state.ancestors];
                for (let i = 0; i < value.length; ++i) {
                    const localState = state.localize([...state.path, i], ancestors, has);
                    if (has.$_match(value[i], localState, prefs)) {
                        return value;
                    }
                }

                const patternLabel = has._flags.label;
                if (patternLabel) {
                    return error('array.hasKnown', { patternLabel });
                }

                return error('array.hasUnknown', null);
            },
            multi: true
        },

        items: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'items');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    obj.$_terms.items.push(type);
                }

                return obj.$_mutateRebuild();
            },
            validate(value, { schema, error, state, prefs }) {

                const requireds = schema.$_terms._requireds.slice();
                const ordereds = schema.$_terms.ordered.slice();
                const inclusions = [...schema.$_terms._inclusions, ...requireds];

                const wasArray = !value[Common.symbols.arraySingle];
                delete value[Common.symbols.arraySingle];

                const errors = [];
                let il = value.length;
                for (let i = 0; i < il; ++i) {
                    const item = value[i];

                    let errored = false;
                    let isValid = false;

                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers
                    const path = [...state.path, key];

                    // Sparse

                    if (!schema._flags.sparse &&
                        item === undefined) {

                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        ordereds.shift();
                        continue;
                    }

                    // Exclusions

                    const ancestors = [value, ...state.ancestors];

                    for (const exclusion of schema.$_terms._exclusions) {
                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {
                            continue;
                        }

                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }

                        errored = true;
                        ordereds.shift();
                        break;
                    }

                    if (errored) {
                        continue;
                    }

                    // Ordered

                    if (schema.$_terms.ordered.length) {
                        if (ordereds.length) {
                            const ordered = ordereds.shift();
                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);
                            if (!res.errors) {
                                if (ordered._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse && res.value === undefined) {
                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    if (prefs.abortEarly) {
                                        return errors;
                                    }

                                    continue;
                                }
                                else {
                                    value[i] = res.value;
                                }
                            }
                            else {
                                errors.push(...res.errors);
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            continue;
                        }
                        else if (!schema.$_terms.items.length) {
                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength
                        }
                    }

                    // Requireds

                    const requiredChecks = [];
                    let jl = requireds.length;
                    for (let j = 0; j < jl; ++j) {
                        const localState = state.localize(path, ancestors, requireds[j]);
                        localState.snapshot();

                        const res = requireds[j].$_validate(item, localState, prefs);
                        requiredChecks[j] = res;

                        if (!res.errors) {
                            value[i] = res.value;
                            isValid = true;
                            internals.fastSplice(requireds, j);
                            --j;
                            --jl;

                            if (!schema._flags.sparse &&
                                res.value === undefined) {

                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                if (prefs.abortEarly) {
                                    return errors;
                                }
                            }

                            break;
                        }

                        localState.restore();
                    }

                    if (isValid) {
                        continue;
                    }

                    // Inclusions

                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;

                    jl = inclusions.length;
                    for (const inclusion of inclusions) {

                        // Avoid re-running requireds that already didn't match in the previous loop

                        let res;
                        const previousCheck = requireds.indexOf(inclusion);
                        if (previousCheck !== -1) {
                            res = requiredChecks[previousCheck];
                        }
                        else {
                            const localState = state.localize(path, ancestors, inclusion);
                            localState.snapshot();

                            res = inclusion.$_validate(item, localState, prefs);
                            if (!res.errors) {
                                if (inclusion._flags.result === 'strip') {
                                    internals.fastSplice(value, i);
                                    --i;
                                    --il;
                                }
                                else if (!schema._flags.sparse &&
                                    res.value === undefined) {

                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));
                                    errored = true;
                                }
                                else {
                                    value[i] = res.value;
                                }

                                isValid = true;
                                break;
                            }

                            localState.restore();
                        }

                        // Return the actual error if only one inclusion defined

                        if (jl === 1) {
                            if (stripUnknown) {
                                internals.fastSplice(value, i);
                                --i;
                                --il;
                                isValid = true;
                                break;
                            }

                            errors.push(...res.errors);
                            if (prefs.abortEarly) {
                                return errors;
                            }

                            errored = true;
                            break;
                        }
                    }

                    if (errored) {
                        continue;
                    }

                    if (schema.$_terms._inclusions.length &&
                        !isValid) {

                        if (stripUnknown) {
                            internals.fastSplice(value, i);
                            --i;
                            --il;
                            continue;
                        }

                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));
                        if (prefs.abortEarly) {
                            return errors;
                        }
                    }
                }

                if (requireds.length) {
                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);
                }

                if (ordereds.length) {
                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);
                }

                return errors.length ? errors : value;
            },

            priority: true,
            manifest: false
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('array.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        ordered: {
            method(...schemas) {

                Common.verifyFlat(schemas, 'ordered');

                const obj = this.$_addRule('items');

                for (let i = 0; i < schemas.length; ++i) {
                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });
                    internals.validateSingle(type, obj);

                    obj.$_mutateRegister(type);
                    obj.$_terms.ordered.push(type);
                }

                return obj.$_mutateRebuild();
            }
        },

        single: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;
                Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');

                return this.$_setFlag('single', value);
            }
        },

        sort: {
            method(options = {}) {

                Common.assertOptions(options, ['by', 'order']);

                const settings = {
                    order: options.order || 'ascending'
                };

                if (options.by) {
                    settings.by = Compile.ref(options.by, { ancestor: 0 });
                    Assert(!settings.by.ancestor, 'Cannot sort by ancestor');
                }

                return this.$_addRule({ name: 'sort', args: { options: settings } });
            },
            validate(value, { error, state, prefs, schema }, { options }) {

                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);
                if (errors) {
                    return errors;
                }

                for (let i = 0; i < value.length; ++i) {
                    if (value[i] !== sorted[i]) {
                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });
                    }
                }

                return value;
            },
            convert: true
        },

        sparse: {
            method(enabled) {

                const value = enabled === undefined ? true : !!enabled;

                if (this._flags.sparse === value) {
                    return this;
                }

                const obj = value ? this.clone() : this.$_addRule('items');
                return obj.$_setFlag('sparse', value, { clone: false });
            }
        },

        unique: {
            method(comparator, options = {}) {

                Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');
                Common.assertOptions(options, ['ignoreUndefined', 'separator']);

                const rule = { name: 'unique', args: { options, comparator } };

                if (comparator) {
                    if (typeof comparator === 'string') {
                        const separator = Common.default(options.separator, '.');
                        rule.path = separator ? comparator.split(separator) : [comparator];
                    }
                    else {
                        rule.comparator = comparator;
                    }
                }

                return this.$_addRule(rule);
            },
            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {

                const found = {
                    string: Object.create(null),
                    number: Object.create(null),
                    undefined: Object.create(null),
                    boolean: Object.create(null),
                    object: new Map(),
                    function: new Map(),
                    custom: new Map()
                };

                const compare = comparator || DeepEqual;
                const ignoreUndefined = options.ignoreUndefined;

                for (let i = 0; i < value.length; ++i) {
                    const item = path ? Reach(value[i], path) : value[i];
                    const records = comparator ? found.custom : found[typeof item];
                    Assert(records, 'Failed to find unique map container for type', typeof item);

                    if (records instanceof Map) {
                        const entries = records.entries();
                        let current;
                        while (!(current = entries.next()).done) {
                            if (compare(current.value[0], item)) {
                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                                const context = {
                                    pos: i,
                                    value: value[i],
                                    dupePos: current.value[1],
                                    dupeValue: value[current.value[1]]
                                };

                                if (path) {
                                    context.path = raw;
                                }

                                return error('array.unique', context, localState);
                            }
                        }

                        records.set(item, i);
                    }
                    else {
                        if ((!ignoreUndefined || item !== undefined) &&
                            records[item] !== undefined) {

                            const context = {
                                pos: i,
                                value: value[i],
                                dupePos: records[item],
                                dupeValue: value[records[item]]
                            };

                            if (path) {
                                context.path = raw;
                            }

                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);
                            return error('array.unique', context, localState);
                        }

                        records[item] = i;
                    }
                }

                return value;
            },
            args: ['comparator', 'options'],
            multi: true
        }
    },

    cast: {
        set: {
            from: Array.isArray,
            to(value, helpers) {

                return new Set(value);
            }
        }
    },

    rebuild(schema) {

        schema.$_terms._inclusions = [];
        schema.$_terms._exclusions = [];
        schema.$_terms._requireds = [];

        for (const type of schema.$_terms.items) {
            internals.validateSingle(type, schema);

            if (type._flags.presence === 'required') {
                schema.$_terms._requireds.push(type);
            }
            else if (type._flags.presence === 'forbidden') {
                schema.$_terms._exclusions.push(type);
            }
            else {
                schema.$_terms._inclusions.push(type);
            }
        }

        for (const type of schema.$_terms.ordered) {
            internals.validateSingle(type, schema);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.items) {
                obj = obj.items(...desc.items);
            }

            if (desc.ordered) {
                obj = obj.ordered(...desc.ordered);
            }

            return obj;
        }
    },

    messages: {
        'array.base': '"{{#label}}" must be an array',
        'array.excludes': '"{{#label}}" contains an excluded value',
        'array.hasKnown': '"{{#label}}" does not contain at least one required match for type "{#patternLabel}"',
        'array.hasUnknown': '"{{#label}}" does not contain at least one required match',
        'array.includes': '"{{#label}}" does not match any of the allowed types',
        'array.includesRequiredBoth': '"{{#label}}" does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',
        'array.includesRequiredKnowns': '"{{#label}}" does not contain {{#knownMisses}}',
        'array.includesRequiredUnknowns': '"{{#label}}" does not contain {{#unknownMisses}} required value(s)',
        'array.length': '"{{#label}}" must contain {{#limit}} items',
        'array.max': '"{{#label}}" must contain less than or equal to {{#limit}} items',
        'array.min': '"{{#label}}" must contain at least {{#limit}} items',
        'array.orderedLength': '"{{#label}}" must contain at most {{#limit}} items',
        'array.sort': '"{{#label}}" must be sorted in {#order} order by {{#by}}',
        'array.sort.mismatching': '"{{#label}}" cannot be sorted due to mismatching types',
        'array.sort.unsupported': '"{{#label}}" cannot be sorted due to unsupported type {#type}',
        'array.sparse': '"{{#label}}" must not be a sparse array item',
        'array.unique': '"{{#label}}" contains a duplicate value'
    }
});


// Helpers

internals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {

    const knownMisses = [];
    let unknownMisses = 0;
    for (const required of requireds) {
        const label = required._flags.label;
        if (label) {
            knownMisses.push(label);
        }
        else {
            ++unknownMisses;
        }
    }

    if (knownMisses.length) {
        if (unknownMisses) {
            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));
        }
        else {
            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));
        }
    }
    else {
        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));
    }
};


internals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {

    const requiredOrdereds = [];

    for (const ordered of ordereds) {
        if (ordered._flags.presence === 'required') {
            requiredOrdereds.push(ordered);
        }
    }

    if (requiredOrdereds.length) {
        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);
    }
};


internals.fastSplice = function (arr, i) {

    let pos = i;
    while (pos < arr.length) {
        arr[pos++] = arr[pos];
    }

    --arr.length;
};


internals.validateSingle = function (type, obj) {

    if (type.type === 'array' ||
        type._flags._arrayItems) {

        Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');
        obj.$_setFlag('_arrayItems', true, { clone: false });
    }
};


internals.sort = function (schema, value, settings, state, prefs) {

    const order = settings.order === 'ascending' ? 1 : -1;
    const aFirst = -1 * order;
    const bFirst = order;

    const sort = (a, b) => {

        let compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        if (settings.by) {
            a = settings.by.resolve(a, state, prefs);
            b = settings.by.resolve(b, state, prefs);
        }

        compare = internals.compare(a, b, aFirst, bFirst);
        if (compare !== null) {
            return compare;
        }

        const type = typeof a;
        if (type !== typeof b) {
            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);
        }

        if (type !== 'number' &&
            type !== 'string') {

            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);
        }

        if (type === 'number') {
            return (a - b) * order;
        }

        return a < b ? aFirst : bFirst;
    };

    try {
        return { value: value.slice().sort(sort) };
    }
    catch (err) {
        return { errors: err };
    }
};


internals.compare = function (a, b, aFirst, bFirst) {

    if (a === b) {
        return 0;
    }

    if (a === undefined) {
        return 1;           // Always last regardless of sort order
    }

    if (b === undefined) {
        return -1;           // Always last regardless of sort order
    }

    if (a === null) {
        return bFirst;
    }

    if (b === null) {
        return aFirst;
    }

    return null;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/binary.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/binary.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {};


module.exports = Any.extend({

    type: 'binary',

    coerce: {
        from: 'string',
        method(value, { schema }) {

            try {
                return { value: Buffer.from(value, schema._flags.encoding) };
            }
            catch (ignoreErr) { }
        }
    },

    validate(value, { error }) {

        if (!Buffer.isBuffer(value)) {
            return { value, errors: error('binary.base') };
        }
    },

    rules: {
        encoding: {
            method(encoding) {

                Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);

                return this.$_setFlag('encoding', encoding);
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value.length, limit, operator)) {
                    return value;
                }

                return helpers.error('binary.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        }
    },

    cast: {
        string: {
            from: (value) => Buffer.isBuffer(value),
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'binary.base': '"{{#label}}" must be a buffer or a string',
        'binary.length': '"{{#label}}" must be {{#limit}} bytes',
        'binary.max': '"{{#label}}" must be less than or equal to {{#limit}} bytes',
        'binary.min': '"{{#label}}" must be at least {{#limit}} bytes'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/boolean.js":
/*!*****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/boolean.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Values = __webpack_require__(/*! ../values */ "./node_modules/@hapi/joi/lib/values.js");


const internals = {};


internals.isBool = function (value) {

    return typeof value === 'boolean';
};


module.exports = Any.extend({

    type: 'boolean',

    flags: {

        sensitive: { default: false }
    },

    terms: {

        falsy: {
            init: null,
            manifest: 'values'
        },

        truthy: {
            init: null,
            manifest: 'values'
        }
    },

    coerce(value, { schema }) {

        if (typeof value === 'boolean') {
            return;
        }

        if (typeof value === 'string') {
            const normalized = schema._flags.sensitive ? value : value.toLowerCase();
            value = normalized === 'true' ? true : (normalized === 'false' ? false : value);
        }

        if (typeof value !== 'boolean') {
            value = schema.$_terms.truthy && schema.$_terms.truthy.has(value, null, null, !schema._flags.sensitive) ||
                (schema.$_terms.falsy && schema.$_terms.falsy.has(value, null, null, !schema._flags.sensitive) ? false : value);
        }

        return { value };
    },

    validate(value, { error }) {

        if (typeof value !== 'boolean') {
            return { value, errors: error('boolean.base') };
        }
    },

    rules: {
        truthy: {
            method(...values) {

                Common.verifyFlat(values, 'truthy');

                const obj = this.clone();
                obj.$_terms.truthy = obj.$_terms.truthy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    Assert(value !== undefined, 'Cannot call truthy with undefined');
                    obj.$_terms.truthy.add(value);
                }

                return obj;
            }
        },

        falsy: {
            method(...values) {

                Common.verifyFlat(values, 'falsy');

                const obj = this.clone();
                obj.$_terms.falsy = obj.$_terms.falsy || new Values();

                for (let i = 0; i < values.length; ++i) {
                    const value = values[i];

                    Assert(value !== undefined, 'Cannot call falsy with undefined');
                    obj.$_terms.falsy.add(value);
                }

                return obj;
            }
        },

        sensitive: {
            method(enabled = true) {

                return this.$_setFlag('sensitive', enabled);
            }
        }
    },

    cast: {
        number: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 1 : 0;
            }
        },
        string: {
            from: internals.isBool,
            to(value, helpers) {

                return value ? 'true' : 'false';
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.truthy) {
                obj = obj.truthy(...desc.truthy);
            }

            if (desc.falsy) {
                obj = obj.falsy(...desc.falsy);
            }

            return obj;
        }
    },

    messages: {
        'boolean.base': '"{{#label}}" must be a boolean'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/date.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/date.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Template = __webpack_require__(/*! ../template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {};


internals.isDate = function (value) {

    return value instanceof Date;
};


module.exports = Any.extend({

    type: 'date',

    coerce: {
        from: ['number', 'string'],
        method(value, { schema }) {

            return { value: internals.parse(value, schema._flags.format) || value };
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value instanceof Date &&
            !isNaN(value.getTime())) {

            return;
        }

        const format = schema._flags.format;

        if (!prefs.convert ||
            !format ||
            typeof value !== 'string') {

            return { value, errors: error('date.base') };
        }

        return { value, errors: error('date.format', { format }) };
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { date }, { name, operator, args }) {

                const to = date === 'now' ? Date.now() : date.getTime();
                if (Common.compare(value.getTime(), to, operator)) {
                    return value;
                }

                return helpers.error('date.' + name, { limit: args.date, value });
            },
            args: [
                {
                    name: 'date',
                    ref: true,
                    normalize: (date) => {

                        return date === 'now' ? date : internals.parse(date);
                    },
                    assert: (date) => date !== null,
                    message: 'must have a valid date format'
                }
            ]
        },

        format: {
            method(format) {

                Assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);

                return this.$_setFlag('format', format);
            }
        },

        greater: {
            method(date) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { date }, operator: '>' });
            }
        },

        iso: {
            method() {

                return this.format('iso');
            }
        },

        less: {
            method(date) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { date }, operator: '<' });
            }
        },

        max: {
            method(date) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { date }, operator: '<=' });
            }
        },

        min: {
            method(date) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { date }, operator: '>=' });
            }
        },

        timestamp: {
            method(type = 'javascript') {

                Assert(['javascript', 'unix'].includes(type), '"type" must be one of "javascript, unix"');

                return this.format(type);
            }
        }
    },

    cast: {
        number: {
            from: internals.isDate,
            to(value, helpers) {

                return value.getTime();
            }
        },
        string: {
            from: internals.isDate,
            to(value, { prefs }) {

                return Template.date(value, prefs);
            }
        }
    },

    messages: {
        'date.base': '"{{#label}}" must be a valid date',
        'date.format': '"{{#label}}" must be in {msg("date.format." + #format) || #format} format',
        'date.greater': '"{{#label}}" must be greater than "{{#limit}}"',
        'date.less': '"{{#label}}" must be less than "{{#limit}}"',
        'date.max': '"{{#label}}" must be less than or equal to "{{#limit}}"',
        'date.min': '"{{#label}}" must be larger than or equal to "{{#limit}}"',

        // Messages used in date.format

        'date.format.iso': 'ISO 8601 date',
        'date.format.javascript': 'timestamp or number of milliseconds',
        'date.format.unix': 'timestamp or number of seconds'
    }
});


// Helpers

internals.parse = function (value, format) {

    if (value instanceof Date) {
        return value;
    }

    if (typeof value !== 'string' &&
        (isNaN(value) || !isFinite(value))) {

        return null;
    }

    if (/^\s*$/.test(value)) {
        return null;
    }

    // ISO

    if (format === 'iso') {
        if (!Common.isIsoDate(value)) {
            return null;
        }

        return internals.date(value.toString());
    }

    // Normalize number string

    const original = value;
    if (typeof value === 'string' &&
        /^[+-]?\d+(\.\d+)?$/.test(value)) {

        value = parseFloat(value);
    }

    // Timestamp

    if (format) {
        if (format === 'javascript') {
            return internals.date(1 * value);        // Casting to number
        }

        if (format === 'unix') {
            return internals.date(1000 * value);
        }

        if (typeof original === 'string') {
            return null;
        }
    }

    // Plain

    return internals.date(value);
};


internals.date = function (value) {

    const date = new Date(value);
    if (!isNaN(date.getTime())) {
        return date;
    }

    return null;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/function.js":
/*!******************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Keys = __webpack_require__(/*! ./keys */ "./node_modules/@hapi/joi/lib/types/keys.js");


const internals = {};


module.exports = Keys.extend({

    type: 'function',

    properties: {
        typeof: 'function'
    },

    rules: {
        arity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'arity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length === n) {
                    return value;
                }

                return helpers.error('function.arity', { n });
            }
        },

        class: {
            method() {

                return this.$_addRule('class');
            },
            validate(value, helpers) {

                if ((/^\s*class\s/).test(value.toString())) {
                    return value;
                }

                return helpers.error('function.class', { value });
            }
        },

        minArity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n > 0, 'n must be a strict positive integer');

                return this.$_addRule({ name: 'minArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length >= n) {
                    return value;
                }

                return helpers.error('function.minArity', { n });
            }
        },

        maxArity: {
            method(n) {

                Assert(Number.isSafeInteger(n) && n >= 0, 'n must be a positive integer');

                return this.$_addRule({ name: 'maxArity', args: { n } });
            },
            validate(value, helpers, { n }) {

                if (value.length <= n) {
                    return value;
                }

                return helpers.error('function.maxArity', { n });
            }
        }
    },

    messages: {
        'function.arity': '"{{#label}}" must have an arity of {{#n}}',
        'function.class': '"{{#label}}" must be a class',
        'function.maxArity': '"{{#label}}" must have an arity lesser or equal to {{#n}}',
        'function.minArity': '"{{#label}}" must have an arity greater or equal to {{#n}}'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/keys.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/keys.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const ApplyToDefaults = __webpack_require__(/*! @hapi/hoek/lib/applyToDefaults */ "./node_modules/@hapi/hoek/lib/applyToDefaults.js");
const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Topo = __webpack_require__(/*! @hapi/topo */ "./node_modules/@hapi/topo/lib/index.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/@hapi/joi/lib/errors.js");
const Ref = __webpack_require__(/*! ../ref */ "./node_modules/@hapi/joi/lib/ref.js");
const Template = __webpack_require__(/*! ../template */ "./node_modules/@hapi/joi/lib/template.js");


const internals = {
    renameDefaults: {
        alias: false,                   // Keep old value in place
        multiple: false,                // Allow renaming multiple keys into the same target
        override: false                 // Overrides an existing key
    }
};


module.exports = Any.extend({

    type: '_keys',

    properties: {
        typeof: 'object'
    },

    flags: {

        unknown: { default: false }
    },

    terms: {

        dependencies: { init: null },
        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },
        patterns: { init: null },
        renames: { init: null }
    },

    args(schema, keys) {

        return schema.keys(keys);
    },

    validate(value, { schema, error, state, prefs }) {

        if (!value ||
            typeof value !== schema.$_property('typeof') ||
            Array.isArray(value)) {

            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };
        }

        // Skip if there are no other rules to test

        if (!schema.$_terms.renames &&
            !schema.$_terms.dependencies &&
            !schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.externals) {

            return;
        }

        // Shallow clone value

        value = internals.clone(value, prefs);
        const errors = [];

        // Rename keys

        if (schema.$_terms.renames &&
            !internals.rename(schema, value, state, prefs, errors)) {

            return { value, errors };
        }

        // Anything allowed

        if (!schema.$_terms.keys &&                       // null allows any keys
            !schema.$_terms.patterns &&
            !schema.$_terms.dependencies) {

            return { value, errors };
        }

        // Defined keys

        const unprocessed = new Set(Object.keys(value));

        if (schema.$_terms.keys) {
            const ancestors = [value, ...state.ancestors];

            for (const child of schema.$_terms.keys) {
                const key = child.key;
                const item = value[key];

                unprocessed.delete(key);

                const localState = state.localize([...state.path, key], ancestors, child);
                const result = child.schema.$_validate(item, localState, prefs);

                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    errors.push(...result.errors);
                }
                else if (child.schema._flags.result === 'strip' ||
                    result.value === undefined && item !== undefined) {

                    delete value[key];
                }
                else if (result.value !== undefined) {
                    value[key] = result.value;
                }
            }
        }

        // Unknown keys

        if (unprocessed.size) {
            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);
            if (early) {
                return early;
            }
        }

        // Validate dependencies

        if (schema.$_terms.dependencies) {
            for (const dep of schema.$_terms.dependencies) {
                if (dep.key &&
                    dep.key.resolve(value, state, prefs, null, { shadow: false }) === undefined) {

                    continue;
                }

                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);
                if (failed) {
                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }

        return { value, errors };
    },

    rules: {

        and: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'and');

                return internals.dependency(this, 'and', null, peers);
            }
        },

        append: {
            method(schema) {

                if (schema === null ||
                    schema === undefined ||
                    Object.keys(schema).length === 0) {

                    return this;
                }

                return this.keys(schema);
            }
        },

        assert: {
            method(subject, schema, message) {

                if (!Template.isTemplate(subject)) {
                    subject = Compile.ref(subject);
                }

                Assert(message === undefined || typeof message === 'string', 'Message must be a string');

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });
                obj.$_mutateRegister(subject);
                obj.$_mutateRegister(schema);
                return obj;
            },
            validate(value, { error, prefs, state }, { subject, schema, message }) {

                const about = subject.resolve(value, state, prefs);
                const path = Ref.isRef(subject) ? subject.absolute(state) : [];
                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {
                    return value;
                }

                return error('object.assert', { subject, message });
            },
            args: ['subject', 'schema', 'message'],
            multi: true
        },

        instance: {
            method(constructor, name) {

                Assert(typeof constructor === 'function', 'constructor must be a function');

                name = name || constructor.name;

                return this.$_addRule({ name: 'instance', args: { constructor, name } });
            },
            validate(value, helpers, { constructor, name }) {

                if (value instanceof constructor) {
                    return value;
                }

                return helpers.error('object.instance', { type: name, value });
            },
            args: ['constructor', 'name']
        },

        keys: {
            method(schema) {

                Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');
                Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');

                const obj = this.clone();

                if (!schema) {                                      // Allow all
                    obj.$_terms.keys = null;
                }
                else if (!Object.keys(schema).length) {             // Allow none
                    obj.$_terms.keys = [];
                }
                else {
                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : [];
                    for (const key in schema) {
                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);
                    }
                }

                return obj.$_mutateRebuild();
            }
        },

        length: {
            method(limit) {

                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });
            },
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(Object.keys(value).length, limit, operator)) {
                    return value;
                }

                return helpers.error('object.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                }
            ]
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });
            }
        },

        nand: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'nand');

                return internals.dependency(this, 'nand', null, peers);
            }
        },

        or: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'or');

                return internals.dependency(this, 'or', null, peers);
            }
        },

        oxor: {
            method(...peers /*, [options] */) {

                return internals.dependency(this, 'oxor', null, peers);
            }
        },

        pattern: {
            method(pattern, schema, options = {}) {

                const isRegExp = pattern instanceof RegExp;
                if (!isRegExp) {
                    pattern = this.$_compile(pattern, { appendPath: true });
                }

                Assert(schema !== undefined, 'Invalid rule');
                Common.assertOptions(options, ['fallthrough', 'matches']);

                if (isRegExp) {
                    Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');
                }

                schema = this.$_compile(schema, { appendPath: true });

                const obj = this.clone();
                obj.$_terms.patterns = obj.$_terms.patterns || [];
                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };
                if (options.matches) {
                    config.matches = this.$_compile(options.matches);
                    if (config.matches.type !== 'array') {
                        config.matches = config.matches.$_root.array().items(config.matches);
                    }

                    obj.$_mutateRegister(config.matches);
                }

                if (options.fallthrough) {
                    config.fallthrough = true;
                }

                obj.$_terms.patterns.push(config);
                obj.$_mutateRegister(schema);
                return obj;
            }
        },

        ref: {
            method() {

                return this.$_addRule('ref');
            },
            validate(value, helpers) {

                if (Ref.isRef(value)) {
                    return value;
                }

                return helpers.error('object.refType', { value });
            }
        },

        rename: {
            method(from, to, options = {}) {

                Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');
                Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');
                Assert(to !== from, 'Cannot rename key to same name:', from);

                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);

                const obj = this.clone();

                obj.$_terms.renames = obj.$_terms.renames || [];
                for (const rename of obj.$_terms.renames) {
                    Assert(rename.from !== from, 'Cannot rename the same key multiple times');
                }

                if (to instanceof Template) {
                    obj.$_mutateRegister(to);
                }

                obj.$_terms.renames.push({
                    from,
                    to,
                    options: ApplyToDefaults(internals.renameDefaults, options)
                });

                return obj;
            }
        },

        schema: {
            method(type = 'any') {

                return this.$_addRule({ name: 'schema', args: { type } });
            },
            validate(value, helpers, { type }) {

                if (Common.isSchema(value) &&
                    (type === 'any' || value.type === type)) {

                    return value;
                }

                return helpers.error('object.schema', { type });
            }
        },

        unknown: {
            method(allow) {

                return this.$_setFlag('unknown', allow !== false);
            }
        },

        with: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'with', key, peers, options);
            }
        },

        without: {
            method(key, peers, options = {}) {

                return internals.dependency(this, 'without', key, peers, options);
            }
        },

        xor: {
            method(...peers /*, [options] */) {

                Common.verifyFlat(peers, 'xor');

                return internals.dependency(this, 'xor', null, peers);
            }
        }
    },

    overrides: {

        default(value, options) {

            if (value === undefined) {
                value = Common.symbols.deepDefault;
            }

            return this.$_super.default(value, options);
        }
    },

    rebuild(schema) {

        if (schema.$_terms.keys) {
            const topo = new Topo();
            for (const child of schema.$_terms.keys) {
                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);
            }

            schema.$_terms.keys = new internals.Keys(...topo.nodes);
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.keys) {
                obj = obj.keys(desc.keys);
            }

            if (desc.dependencies) {
                for (const { rel, key = null, peers, options } of desc.dependencies) {
                    obj = internals.dependency(obj, rel, key, peers, options);
                }
            }

            if (desc.patterns) {
                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {
                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });
                }
            }

            if (desc.renames) {
                for (const { from, to, options } of desc.renames) {
                    obj = obj.rename(from, to, options);
                }
            }

            return obj;
        }
    },

    messages: {
        'object.and': '"{{#label}}" contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',
        'object.assert': '"{{#label}}" is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',
        'object.base': '"{{#label}}" must be of type {{#type}}',
        'object.instance': '"{{#label}}" must be an instance of "{{#type}}"',
        'object.length': '"{{#label}}" must have {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.max': '"{{#label}}" must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.min': '"{{#label}}" must have at least {{#limit}} key{if(#limit == 1, "", "s")}',
        'object.missing': '"{{#label}}" must contain at least one of {{#peersWithLabels}}',
        'object.nand': '"{{#mainWithLabel}}" must not exist simultaneously with {{#peersWithLabels}}',
        'object.oxor': '"{{#label}}" contains a conflict between optional exclusive peers {{#peersWithLabels}}',
        'object.pattern.match': '"{{#label}}" keys failed to match pattern requirements',
        'object.refType': '"{{#label}}" must be a Joi reference',
        'object.rename.multiple': '"{{#label}}" cannot rename "{{#from}}" because multiple renames are disabled and another key was already renamed to "{{#to}}"',
        'object.rename.override': '"{{#label}}" cannot rename "{{#from}}" because override is disabled and target "{{#to}}" exists',
        'object.schema': '"{{#label}}" must be a Joi schema of {{#type}} type',
        'object.unknown': '"{{#label}}" is not allowed',
        'object.with': '"{{#mainWithLabel}}" missing required peer "{{#peerWithLabel}}"',
        'object.without': '"{{#mainWithLabel}}" conflict with forbidden peer "{{#peerWithLabel}}"',
        'object.xor': '"{{#label}}" contains a conflict between exclusive peers {{#peersWithLabels}}'
    }
});


// Helpers

internals.clone = function (value, prefs) {

    // Object

    if (typeof value === 'object') {
        if (prefs.nonEnumerables) {
            return Clone(value, { shallow: true });
        }

        const clone = Object.create(Object.getPrototypeOf(value));
        Object.assign(clone, value);
        return clone;
    }

    // Function

    const clone = function (...args) {

        return value.apply(this, args);
    };

    clone.prototype = Clone(value.prototype);
    Object.defineProperty(clone, 'name', { value: value.name, writable: false });
    Object.defineProperty(clone, 'length', { value: value.length, writable: false });
    Object.assign(clone, value);
    return clone;
};


internals.dependency = function (schema, rel, key, peers, options) {

    Assert(key === null || typeof key === 'string', rel, 'key must be a strings');

    // Extract options from peers array

    if (!options) {
        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};
    }

    Common.assertOptions(options, ['separator']);

    peers = [].concat(peers);

    // Cast peer paths

    const separator = Common.default(options.separator, '.');
    const paths = [];
    for (const peer of peers) {
        Assert(typeof peer === 'string', rel, 'peers must be a string or a reference');
        paths.push(Compile.ref(peer, { separator, ancestor: 0 }));
    }

    // Cast key

    if (key !== null) {
        key = Compile.ref(key, { separator, ancestor: 0 });
    }

    // Add rule

    const obj = schema.clone();
    obj.$_terms.dependencies = obj.$_terms.dependencies || [];
    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));
    return obj;
};


internals.dependencies = {

    and(schema, dep, value, state, prefs) {

        const missing = [];
        const present = [];
        const count = dep.peers.length;
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
                missing.push(peer.key);
            }
            else {
                present.push(peer.key);
            }
        }

        if (missing.length !== count &&
            present.length !== count) {

            return {
                code: 'object.and',
                context: {
                    present,
                    presentWithLabels: internals.keysToLabels(schema, present),
                    missing,
                    missingWithLabels: internals.keysToLabels(schema, missing)
                }
            };
        }
    },

    nand(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (present.length !== dep.peers.length) {
            return;
        }

        const main = dep.paths[0];
        const values = dep.paths.slice(1);
        return {
            code: 'object.nand',
            context: {
                main,
                mainWithLabel: internals.keysToLabels(schema, main),
                peers: values,
                peersWithLabels: internals.keysToLabels(schema, values)
            }
        };
    },

    or(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                return;
            }
        }

        return {
            code: 'object.missing',
            context: {
                peers: dep.paths,
                peersWithLabels: internals.keysToLabels(schema, dep.paths)
            }
        };
    },

    oxor(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (!present.length ||
            present.length === 1) {

            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.oxor', context };
    },

    with(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {
                return {
                    code: 'object.with',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    without(schema, dep, value, state, prefs) {

        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                return {
                    code: 'object.without',
                    context: {
                        main: dep.key.key,
                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),
                        peer: peer.key,
                        peerWithLabel: internals.keysToLabels(schema, peer.key)
                    }
                };
            }
        }
    },

    xor(schema, dep, value, state, prefs) {

        const present = [];
        for (const peer of dep.peers) {
            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {
                present.push(peer.key);
            }
        }

        if (present.length === 1) {
            return;
        }

        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };
        if (present.length === 0) {
            return { code: 'object.missing', context };
        }

        context.present = present;
        context.presentWithLabels = internals.keysToLabels(schema, present);
        return { code: 'object.xor', context };
    }
};


internals.keysToLabels = function (schema, keys) {

    if (Array.isArray(keys)) {
        return keys.map((key) => schema.$_mapLabels(key));
    }

    return schema.$_mapLabels(keys);
};


internals.rename = function (schema, value, state, prefs, errors) {

    const renamed = {};
    for (const rename of schema.$_terms.renames) {
        const matches = [];
        const pattern = typeof rename.from !== 'string';

        if (!pattern) {
            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&
                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {

                matches.push(rename);
            }
        }
        else {
            for (const from in value) {
                if (value[from] === undefined &&
                    rename.options.ignoreUndefined) {

                    continue;
                }

                if (from === rename.to) {
                    continue;
                }

                const match = rename.from.exec(from);
                if (!match) {
                    continue;
                }

                matches.push({ from, to: rename.to, match });
            }
        }

        for (const match of matches) {
            const from = match.from;
            let to = match.to;
            if (to instanceof Template) {
                to = to.render(value, state, prefs, match.match);
            }

            if (from === to) {
                continue;
            }

            if (!rename.options.multiple &&
                renamed[to]) {

                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (Object.prototype.hasOwnProperty.call(value, to) &&
                !rename.options.override &&
                !renamed[to]) {

                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));
                if (prefs.abortEarly) {
                    return false;
                }
            }

            if (value[from] === undefined) {
                delete value[to];
            }
            else {
                value[to] = value[from];
            }

            renamed[to] = true;

            if (!rename.options.alias) {
                delete value[from];
            }
        }
    }

    return true;
};


internals.unknown = function (schema, value, unprocessed, errors, state, prefs) {

    if (schema.$_terms.patterns) {
        let hasMatches = false;
        const matches = schema.$_terms.patterns.map((pattern) => {

            if (pattern.matches) {
                hasMatches = true;
                return [];
            }
        });

        const ancestors = [value, ...state.ancestors];

        for (const key of unprocessed) {
            const item = value[key];
            const path = [...state.path, key];

            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {
                const pattern = schema.$_terms.patterns[i];
                if (pattern.regex) {
                    const match = pattern.regex.test(key);
                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');
                    if (!match) {
                        continue;
                    }
                }
                else {
                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {
                        continue;
                    }
                }

                unprocessed.delete(key);

                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });
                const result = pattern.rule.$_validate(item, localState, prefs);
                if (result.errors) {
                    if (prefs.abortEarly) {
                        return { value, errors: result.errors };
                    }

                    errors.push(...result.errors);
                }

                if (pattern.matches) {
                    matches[i].push(key);
                }

                value[key] = result.value;
                if (!pattern.fallthrough) {
                    break;
                }
            }
        }

        // Validate pattern matches rules

        if (hasMatches) {
            for (let i = 0; i < matches.length; ++i) {
                const match = matches[i];
                if (!match) {
                    continue;
                }

                const stpm = schema.$_terms.patterns[i].matches;
                const localState = state.localize(state.path, ancestors, stpm);
                const result = stpm.$_validate(match, localState, prefs);
                if (result.errors) {
                    const details = Errors.details(result.errors, { override: false });
                    details.matches = match;
                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);
                    if (prefs.abortEarly) {
                        return { value, errors: report };
                    }

                    errors.push(report);
                }
            }
        }
    }

    if (!unprocessed.size ||
        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed

        return;
    }

    if (prefs.stripUnknown && !schema._flags.unknown ||
        prefs.skipFunctions) {

        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;

        for (const key of unprocessed) {
            if (stripUnknown) {
                delete value[key];
                unprocessed.delete(key);
            }
            else if (typeof value[key] === 'function') {
                unprocessed.delete(key);
            }
        }
    }

    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);
    if (forbidUnknown) {
        for (const unprocessedKey of unprocessed) {
            const localState = state.localize([...state.path, unprocessedKey], []);
            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });
            if (prefs.abortEarly) {
                return { value, errors: report };
            }

            errors.push(report);
        }
    }
};


internals.Dependency = class {

    constructor(rel, key, peers, paths) {

        this.rel = rel;
        this.key = key;
        this.peers = peers;
        this.paths = paths;
    }

    describe() {

        const desc = {
            rel: this.rel,
            peers: this.paths
        };

        if (this.key !== null) {
            desc.key = this.key.key;
        }

        if (this.peers[0].separator !== '.') {
            desc.options = { separator: this.peers[0].separator };
        }

        return desc;
    }
};


internals.Keys = class extends Array {

    concat(source) {

        const result = this.slice();

        const keys = new Map();
        for (let i = 0; i < result.length; ++i) {
            keys.set(result[i].key, i);
        }

        for (const item of source) {
            const key = item.key;
            const pos = keys.get(key);
            if (pos !== undefined) {
                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };
            }
            else {
                result.push(item);
            }
        }

        return result;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/link.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/link.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");
const Compile = __webpack_require__(/*! ../compile */ "./node_modules/@hapi/joi/lib/compile.js");
const Errors = __webpack_require__(/*! ../errors */ "./node_modules/@hapi/joi/lib/errors.js");


const internals = {};


module.exports = Any.extend({

    type: 'link',

    properties: {
        schemaChain: true
    },

    terms: {

        link: { init: null, manifest: 'single', register: false }
    },

    args(schema, ref) {

        return schema.ref(ref);
    },

    validate(value, { schema, state, prefs }) {

        Assert(schema.$_terms.link, 'Uninitialized link schema');

        const linked = internals.generate(schema, value, state, prefs);
        const ref = schema.$_terms.link[0].ref;
        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);
    },

    generate(schema, value, state, prefs) {

        return internals.generate(schema, value, state, prefs);
    },

    rules: {

        ref: {
            method(ref) {

                Assert(!this.$_terms.link, 'Cannot reinitialize schema');

                ref = Compile.ref(ref);

                Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);
                Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');

                const obj = this.clone();
                obj.$_terms.link = [{ ref }];
                return obj;
            }
        },

        relative: {
            method(enabled = true) {

                return this.$_setFlag('relative', enabled);
            }
        }
    },

    overrides: {

        concat(source) {

            Assert(this.$_terms.link, 'Uninitialized link schema');
            Assert(Common.isSchema(source), 'Invalid schema object');
            Assert(source.type !== 'link', 'Cannot merge type link with another link');

            const obj = this.clone();

            if (!obj.$_terms.whens) {
                obj.$_terms.whens = [];
            }

            obj.$_terms.whens.push({ concat: source });
            return obj.$_mutateRebuild();
        }
    },

    manifest: {

        build(obj, desc) {

            Assert(desc.link, 'Invalid link description missing link');
            return obj.ref(desc.link);
        }
    }
});


// Helpers

internals.generate = function (schema, value, state, prefs) {

    let linked = state.mainstay.links.get(schema);
    if (linked) {
        return linked._generate(value, state, prefs).schema;
    }

    const ref = schema.$_terms.link[0].ref;
    const { perspective, path } = internals.perspective(ref, state);
    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);

    try {
        linked = path.length ? perspective.$_reach(path) : perspective;
    }
    catch (ignoreErr) {
        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);
    }

    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);

    if (!schema._flags.relative) {
        state.mainstay.links.set(schema, linked);
    }

    return linked._generate(value, state, prefs).schema;
};


internals.perspective = function (ref, state) {

    if (ref.type === 'local') {
        for (const { schema, key } of state.schemas) {                              // From parent to root
            const id = schema._flags.id || key;
            if (id === ref.path[0]) {
                return { perspective: schema, path: ref.path.slice(1) };
            }

            if (schema.$_terms.shared) {
                for (const shared of schema.$_terms.shared) {
                    if (shared._flags.id === ref.path[0]) {
                        return { perspective: shared, path: ref.path.slice(1) };
                    }
                }
            }
        }

        return { perspective: null, path: null };
    }

    if (ref.ancestor === 'root') {
        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };
    }

    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };
};


internals.assert = function (condition, message, ref, schema, state, prefs) {

    if (condition) {                // Manual check to avoid generating error message on success
        return;
    }

    Assert(false, `"${Errors.label(schema._flags, state, prefs)}" contains link reference "${ref.display}" ${message}`);
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/number.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/number.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {
    numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,
    precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/
};


module.exports = Any.extend({

    type: 'number',

    flags: {

        unsafe: { default: false }
    },

    coerce: {
        from: 'string',
        method(value, { schema, error }) {

            const matches = value.match(internals.numberRx);
            if (!matches) {
                return;
            }

            value = value.trim();
            const result = { value: parseFloat(value) };

            if (result.value === 0) {
                result.value = 0;           // -0
            }

            if (!schema._flags.unsafe) {
                if (value.match(/e/i)) {
                    const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);
                    if (constructed !== internals.normalizeExponent(value)) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
                else {
                    const string = result.value.toString();
                    if (string.match(/e/i)) {
                        return result;
                    }

                    if (string !== internals.normalizeDecimal(value)) {
                        result.errors = error('number.unsafe');
                        return result;
                    }
                }
            }

            return result;
        }
    },

    validate(value, { schema, error, prefs }) {

        if (value === Infinity ||
            value === -Infinity) {

            return { value, errors: error('number.infinity') };
        }

        if (!Common.isNumber(value)) {
            return { value, errors: error('number.base') };
        }

        const result = { value };

        if (result.value === 0) {
            result.value = 0;           // -0
        }

        if (prefs.convert) {
            const rule = schema.$_getRule('precision');
            if (rule) {
                const precision = Math.pow(10, rule.args.limit);                    // This is conceptually equivalent to using toFixed but it should be much faster
                result.value = Math.round(result.value * precision) / precision;
            }
        }

        if (!schema._flags.unsafe &&
            (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {

            result.errors = error('number.unsafe');
        }

        return result;
    },

    rules: {

        compare: {
            method: false,
            validate(value, helpers, { limit }, { name, operator, args }) {

                if (Common.compare(value, limit, operator)) {
                    return value;
                }

                return helpers.error('number.' + name, { limit: args.limit, value });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.isNumber,
                    message: 'must be a number'
                }
            ]
        },

        greater: {
            method(limit) {

                return this.$_addRule({ name: 'greater', method: 'compare', args: { limit }, operator: '>' });
            }
        },

        integer: {
            method() {

                return this.$_addRule('integer');
            },
            validate(value, helpers) {

                if (Math.trunc(value) - value === 0) {
                    return value;
                }

                return helpers.error('number.integer');
            }
        },

        less: {
            method(limit) {

                return this.$_addRule({ name: 'less', method: 'compare', args: { limit }, operator: '<' });
            }
        },

        max: {
            method(limit) {

                return this.$_addRule({ name: 'max', method: 'compare', args: { limit }, operator: '<=' });
            }
        },

        min: {
            method(limit) {

                return this.$_addRule({ name: 'min', method: 'compare', args: { limit }, operator: '>=' });
            }
        },

        multiple: {
            method(base) {

                return this.$_addRule({ name: 'multiple', args: { base } });
            },
            validate(value, helpers, { base }, options) {

                if (value % base === 0) {
                    return value;
                }

                return helpers.error('number.multiple', { multiple: options.args.base, value });
            },
            args: [
                {
                    name: 'base',
                    ref: true,
                    assert: (value) => typeof value === 'number' && isFinite(value) && value > 0,
                    message: 'must be a positive number'
                }
            ],
            multi: true
        },

        negative: {
            method() {

                return this.sign('negative');
            }
        },

        port: {
            method() {

                return this.$_addRule('port');
            },
            validate(value, helpers) {

                if (Number.isSafeInteger(value) &&
                    value >= 0 &&
                    value <= 65535) {

                    return value;
                }

                return helpers.error('number.port');
            }
        },

        positive: {
            method() {

                return this.sign('positive');
            }
        },

        precision: {
            method(limit) {

                Assert(Number.isSafeInteger(limit), 'limit must be an integer');

                return this.$_addRule({ name: 'precision', args: { limit } });
            },
            validate(value, helpers, { limit }) {

                const places = value.toString().match(internals.precisionRx);
                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);
                if (decimals <= limit) {
                    return value;
                }

                return helpers.error('number.precision', { limit, value });
            },
            convert: true
        },

        sign: {
            method(sign) {

                Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);

                return this.$_addRule({ name: 'sign', args: { sign } });
            },
            validate(value, helpers, { sign }) {

                if (sign === 'negative' && value < 0 ||
                    sign === 'positive' && value > 0) {

                    return value;
                }

                return helpers.error(`number.${sign}`);
            }
        },

        unsafe: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('unsafe', enabled);
            }
        }
    },

    cast: {
        string: {
            from: (value) => typeof value === 'number',
            to(value, helpers) {

                return value.toString();
            }
        }
    },

    messages: {
        'number.base': '"{{#label}}" must be a number',
        'number.greater': '"{{#label}}" must be greater than {{#limit}}',
        'number.infinity': '"{{#label}}" cannot be infinity',
        'number.integer': '"{{#label}}" must be an integer',
        'number.less': '"{{#label}}" must be less than {{#limit}}',
        'number.max': '"{{#label}}" must be less than or equal to {{#limit}}',
        'number.min': '"{{#label}}" must be larger than or equal to {{#limit}}',
        'number.multiple': '"{{#label}}" must be a multiple of {{#multiple}}',
        'number.negative': '"{{#label}}" must be a negative number',
        'number.port': '"{{#label}}" must be a valid port',
        'number.positive': '"{{#label}}" must be a positive number',
        'number.precision': '"{{#label}}" must have no more than {{#limit}} decimal places',
        'number.unsafe': '"{{#label}}" must be a safe number'
    }
});


// Helpers

internals.normalizeExponent = function (str) {

    return str
        .replace(/E/, 'e')
        .replace(/\.(\d*[1-9])?0+e/, '.$1e')
        .replace(/\.e/, 'e')
        .replace(/e\+/, 'e')
        .replace(/^\+/, '')
        .replace(/^(-?)0+([1-9])/, '$1$2');
};


internals.normalizeDecimal = function (str) {

    str = str
        .replace(/^\+/, '')
        .replace(/\.0+$/, '')
        .replace(/^(-?)\.([^\.]*)$/, '$10.$2')
        .replace(/^(-?)0+([1-9])/, '$1$2');

    if (str.includes('.') &&
        str.endsWith('0')) {

        str = str.replace(/0+$/, '');
    }

    if (str === '-0') {
        return '0';
    }

    return str;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/object.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/object.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Keys = __webpack_require__(/*! ./keys */ "./node_modules/@hapi/joi/lib/types/keys.js");


const internals = {};


module.exports = Keys.extend({

    type: 'object',

    cast: {
        map: {
            from: (value) => value && typeof value === 'object',
            to(value, helpers) {

                return new Map(Object.entries(value));
            }
        }
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/string/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/string/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Domain = __webpack_require__(/*! @hapi/address/lib/domain */ "./node_modules/@hapi/address/lib/domain.js");
const Email = __webpack_require__(/*! @hapi/address/lib/email */ "./node_modules/@hapi/address/lib/email.js");
const EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");
const Tlds = __webpack_require__(/*! @hapi/address/lib/tlds */ "./node_modules/@hapi/address/lib/tlds.js");

const Any = __webpack_require__(/*! ../any */ "./node_modules/@hapi/joi/lib/types/any.js");
const Common = __webpack_require__(/*! ../../common */ "./node_modules/@hapi/joi/lib/common.js");

const Ip = __webpack_require__(/*! ./ip */ "./node_modules/@hapi/joi/lib/types/string/ip.js");
const Uri = __webpack_require__(/*! ./uri */ "./node_modules/@hapi/joi/lib/types/string/uri.js");


const internals = {
    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,              // $lab:coverage:ignore$
    base64Regex: {
        // paddingRequired
        true: {
            // urlSafe
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/
        },
        false: {
            true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,
            false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
    },
    dataUriRegex: {
        format: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,
        base64: {
            // paddingRequired
            true: /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/,
            false: /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/
        }
    },
    hexRegex: /^[a-f0-9]+$/i,
    hostRegex: /^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$/,
    ipRegex: Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], 'optional'),
    isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,

    guidBrackets: {
        '{': '}', '[': ']', '(': ')', '': ''
    },
    guidVersions: {
        uuidv1: '1',
        uuidv2: '2',
        uuidv3: '3',
        uuidv4: '4',
        uuidv5: '5'
    },

    cidrPresences: ['required', 'optional', 'forbidden'],
    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']
};


module.exports = Any.extend({

    type: 'string',

    flags: {

        insensitive: { default: false },
        truncate: { default: false }
    },

    terms: {

        replacements: { init: null }
    },

    coerce: {
        from: 'string',
        method(value, { schema, state, prefs }) {

            const normalize = schema.$_getRule('normalize');
            if (normalize) {
                value = value.normalize(normalize.args.form);
            }

            const casing = schema.$_getRule('case');
            if (casing) {
                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();
            }

            const trim = schema.$_getRule('trim');
            if (trim &&
                trim.args.enabled) {

                value = value.trim();
            }

            if (schema.$_terms.replacements) {
                for (const replacement of schema.$_terms.replacements) {
                    value = value.replace(replacement.pattern, replacement.replacement);
                }
            }

            const hex = schema.$_getRule('hex');
            if (hex &&
                hex.args.options.byteAligned &&
                value.length % 2 !== 0) {

                value = `0${value}`;
            }

            if (schema.$_getRule('isoDate')) {
                const iso = internals.isoDate(value);
                if (iso) {
                    value = iso;
                }
            }

            if (schema._flags.truncate) {
                const rule = schema.$_getRule('max');
                if (rule) {
                    let limit = rule.args.limit;
                    if (Common.isResolvable(limit)) {
                        limit = limit.resolve(value, state, prefs);
                        if (!Common.limit(limit)) {
                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };
                        }
                    }

                    value = value.slice(0, limit);
                }
            }

            return { value };
        }
    },

    validate(value, { error }) {

        if (typeof value !== 'string') {
            return { value, errors: error('string.base') };
        }

        if (value === '') {
            return { value, errors: error('string.empty') };
        }
    },

    rules: {

        alphanum: {
            method() {

                return this.$_addRule('alphanum');
            },
            validate(value, helpers) {

                if (/^[a-zA-Z0-9]+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.alphanum');
            }
        },

        base64: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);

                options = { urlSafe: false, paddingRequired: true, ...options };
                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');
                Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');

                return this.$_addRule({ name: 'base64', args: { options } });
            },
            validate(value, helpers, { options }) {

                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];
                if (regex.test(value)) {
                    return value;
                }

                return helpers.error('string.base64');
            }
        },

        case: {
            method(direction) {

                Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);

                return this.$_addRule({ name: 'case', args: { direction } });
            },
            validate(value, helpers, { direction }) {

                if (direction === 'lower' && value === value.toLocaleLowerCase() ||
                    direction === 'upper' && value === value.toLocaleUpperCase()) {

                    return value;
                }

                return helpers.error(`string.${direction}case`);
            },
            convert: true
        },

        creditCard: {
            method() {

                return this.$_addRule('creditCard');
            },
            validate(value, helpers) {

                let i = value.length;
                let sum = 0;
                let mul = 1;

                while (i--) {
                    const char = value.charAt(i) * mul;
                    sum = sum + (char - (char > 9) * 9);
                    mul = mul ^ 3;
                }

                if (sum > 0 &&
                    sum % 10 === 0) {

                    return value;
                }

                return helpers.error('string.creditCard');
            }
        },

        dataUri: {
            method(options = {}) {

                Common.assertOptions(options, ['paddingRequired']);

                options = { paddingRequired: true, ...options };
                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');

                return this.$_addRule({ name: 'dataUri', args: { options } });
            },
            validate(value, helpers, { options }) {

                const matches = value.match(internals.dataUriRegex.format);

                if (matches) {
                    if (!matches[2]) {
                        return value;
                    }

                    if (matches[2] !== 'base64') {
                        return value;
                    }

                    const base64regex = internals.dataUriRegex.base64[options.paddingRequired];
                    if (base64regex.test(matches[3])) {
                        return value;
                    }
                }

                return helpers.error('string.dataUri');
            }
        },

        domain: {
            method(options) {

                if (options) {
                    Common.assertOptions(options, ['allowUnicode', 'minDomainSegments', 'tlds']);
                }

                const address = internals.addressOptions(options);
                return this.$_addRule({ name: 'domain', args: { options }, address });
            },
            validate(value, helpers, args, { address }) {

                if (Domain.isValid(value, address)) {
                    return value;
                }

                return helpers.error('string.domain');
            }
        },

        email: {
            method(options = {}) {

                Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'minDomainSegments', 'multiple', 'separator', 'tlds']);
                Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');

                const address = internals.addressOptions(options);
                const regex = new RegExp(`\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\s*`);

                return this.$_addRule({ name: 'email', args: { options }, regex, address });
            },
            validate(value, helpers, { options }, { regex, address }) {

                const emails = options.multiple ? value.split(regex) : [value];
                const invalids = [];
                for (const email of emails) {
                    if (!Email.isValid(email, address)) {
                        invalids.push(email);
                    }
                }

                if (!invalids.length) {
                    return value;
                }

                return helpers.error('string.email', { value, invalids });
            }
        },

        guid: {
            alias: 'uuid',
            method(options = {}) {

                Common.assertOptions(options, ['version']);

                let versionNumbers = '';

                if (options.version) {
                    const versions = [].concat(options.version);

                    Assert(versions.length >= 1, 'version must have at least 1 valid version specified');
                    const set = new Set();

                    for (let i = 0; i < versions.length; ++i) {
                        const version = versions[i];
                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                        const versionNumber = internals.guidVersions[version.toLowerCase()];
                        Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));
                        Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');

                        versionNumbers += versionNumber;
                        set.add(versionNumber);
                    }
                }

                const regex = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}([:-]?)[0-9A-F]{4}\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, 'i');

                return this.$_addRule({ name: 'guid', args: { options }, regex });
            },
            validate(value, helpers, args, { regex }) {

                const results = regex.exec(value);

                if (!results) {
                    return helpers.error('string.guid');
                }

                // Matching braces

                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {
                    return helpers.error('string.guid');
                }

                return value;
            }
        },

        hex: {
            method(options = {}) {

                Common.assertOptions(options, ['byteAligned']);

                options = { byteAligned: false, ...options };
                Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');

                return this.$_addRule({ name: 'hex', args: { options } });
            },
            validate(value, helpers, { options }) {

                if (!internals.hexRegex.test(value)) {
                    return helpers.error('string.hex');
                }

                if (options.byteAligned &&
                    value.length % 2 !== 0) {

                    return helpers.error('string.hexAlign');
                }

                return value;
            }
        },

        hostname: {
            method() {

                return this.$_addRule('hostname');
            },
            validate(value, helpers) {

                if (value.length <= 255 && internals.hostRegex.test(value) ||
                    internals.ipRegex.test(value)) {

                    return value;
                }

                return helpers.error('string.hostname');
            }
        },

        insensitive: {
            method() {

                return this.$_setFlag('insensitive', true);
            }
        },

        ip: {
            method(options = {}) {

                Common.assertOptions(options, ['cidr', 'version']);

                options = Object.assign({}, options);       // Shallow cloned

                let regex = internals.ipRegex;
                if (options.cidr) {
                    Assert(typeof options.cidr === 'string', 'cidr must be a string');
                    options.cidr = options.cidr.toLowerCase();

                    Assert(internals.cidrPresences.includes(options.cidr), 'cidr must be one of ' + internals.cidrPresences.join(', '));

                    if (!options.version &&
                        options.cidr !== 'optional') {

                        regex = Ip.createIpRegex(['ipv4', 'ipv6', 'ipvfuture'], options.cidr);
                    }
                }
                else {
                    options.cidr = 'optional';
                }

                let versions;
                if (options.version) {
                    if (!Array.isArray(options.version)) {
                        options.version = [options.version];
                    }

                    Assert(options.version.length >= 1, 'version must have at least 1 version specified');

                    versions = [];
                    for (let i = 0; i < options.version.length; ++i) {
                        let version = options.version[i];
                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');
                        version = version.toLowerCase();
                        Assert(Ip.versions[version], 'version at position ' + i + ' must be one of ' + Object.keys(Ip.versions).join(', '));
                        versions.push(version);
                    }

                    versions = Array.from(new Set(versions));
                    regex = Ip.createIpRegex(versions, options.cidr);
                }

                return this.$_addRule({ name: 'ip', args: { options }, versions, regex });
            },
            validate(value, helpers, { options }, { versions, regex }) {

                if (regex.test(value)) {
                    return value;
                }

                if (versions) {
                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: versions });
                }

                return helpers.error('string.ip', { value, cidr: options.cidr });
            }
        },

        isoDate: {
            method() {

                return this.$_addRule('isoDate');
            },
            validate(value, { error }) {

                if (internals.isoDate(value)) {
                    return value;
                }

                return error('string.isoDate');
            }
        },

        isoDuration: {
            method() {

                return this.$_addRule('isoDuration');
            },
            validate(value, helpers) {

                if (internals.isoDurationRegex.test(value)) {
                    return value;
                }

                return helpers.error('string.isoDuration');
            }
        },

        length: {
            method(limit, encoding) {

                return internals.length(this, 'length', limit, '=', encoding);
            },
            validate(value, helpers, { limit, encoding }, { name, operator, args }) {

                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$
                if (Common.compare(length, limit, operator)) {
                    return value;
                }

                return helpers.error('string.' + name, { limit: args.limit, value, encoding });
            },
            args: [
                {
                    name: 'limit',
                    ref: true,
                    assert: Common.limit,
                    message: 'must be a positive integer'
                },
                'encoding'
            ]
        },

        lowercase: {
            method() {

                return this.case('lower');
            }
        },

        max: {
            method(limit, encoding) {

                return internals.length(this, 'max', limit, '<=', encoding);
            },
            args: ['limit', 'encoding']
        },

        min: {
            method(limit, encoding) {

                return internals.length(this, 'min', limit, '>=', encoding);
            },
            args: ['limit', 'encoding']
        },

        normalize: {
            method(form = 'NFC') {

                Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));

                return this.$_addRule({ name: 'normalize', args: { form } });
            },
            validate(value, { error }, { form }) {

                if (value === value.normalize(form)) {
                    return value;
                }

                return error('string.normalize', { value, form });
            },
            convert: true
        },

        pattern: {
            alias: 'regex',
            method(regex, options = {}) {

                Assert(regex instanceof RegExp, 'regex must be a RegExp');
                Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');

                if (typeof options === 'string') {
                    options = { name: options };
                }

                Common.assertOptions(options, ['invert', 'name']);

                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');
                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });
            },
            validate(value, helpers, { regex, options }, { errorCode }) {

                const patternMatch = regex.test(value);

                if (patternMatch ^ options.invert) {
                    return value;
                }

                return helpers.error(errorCode, { name: options.name, regex, value });
            },
            args: ['regex', 'options'],
            multi: true
        },

        replace: {
            method(pattern, replacement) {

                if (typeof pattern === 'string') {
                    pattern = new RegExp(EscapeRegex(pattern), 'g');
                }

                Assert(pattern instanceof RegExp, 'pattern must be a RegExp');
                Assert(typeof replacement === 'string', 'replacement must be a String');

                const obj = this.clone();

                if (!obj.$_terms.replacements) {
                    obj.$_terms.replacements = [];
                }

                obj.$_terms.replacements.push({ pattern, replacement });
                return obj;
            }
        },

        token: {
            method() {

                return this.$_addRule('token');
            },
            validate(value, helpers) {

                if (/^\w+$/.test(value)) {
                    return value;
                }

                return helpers.error('string.token');
            }
        },

        trim: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_addRule({ name: 'trim', args: { enabled } });
            },
            validate(value, helpers, { enabled }) {

                if (!enabled ||
                    value === value.trim()) {

                    return value;
                }

                return helpers.error('string.trim');
            },
            convert: true
        },

        truncate: {
            method(enabled = true) {

                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');

                return this.$_setFlag('truncate', enabled);
            }
        },

        uppercase: {
            method() {

                return this.case('upper');
            }
        },

        uri: {
            method(options = {}) {

                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);

                const unknownOptions = Object.keys(options).filter((key) => !['scheme', 'allowRelative', 'relativeOnly', 'allowQuerySquareBrackets', 'domain'].includes(key));
                Assert(unknownOptions.length === 0, `options contain unknown keys: ${unknownOptions}`);

                if (options.domain) {
                    Common.assertOptions(options.domain, ['allowUnicode', 'minDomainSegments', 'tlds']);
                }

                const regex = Uri.createRegex(options);
                const domain = options.domain ? internals.addressOptions(options.domain) : null;
                return this.$_addRule({ name: 'uri', args: { options }, regex, domain });
            },
            validate(value, helpers, { options }, { regex, domain }) {

                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense
                    return helpers.error('string.uri');
                }

                const match = regex.exec(value);
                if (match) {
                    if (domain &&
                        !Domain.isValid(match[1], domain)) {

                        return helpers.error('string.domain', { value: match[1] });
                    }

                    return value;
                }

                if (options.relativeOnly) {
                    return helpers.error('string.uriRelativeOnly');
                }

                if (options.scheme) {
                    return helpers.error('string.uriCustomScheme', { scheme: regex.scheme, value });
                }

                return helpers.error('string.uri');
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.replacements) {
                for (const { pattern, replacement } of desc.replacements) {
                    obj = obj.replace(pattern, replacement);
                }
            }

            return obj;
        }
    },

    messages: {
        'string.alphanum': '"{{#label}}" must only contain alpha-numeric characters',
        'string.base': '"{{#label}}" must be a string',
        'string.base64': '"{{#label}}" must be a valid base64 string',
        'string.creditCard': '"{{#label}}" must be a credit card',
        'string.dataUri': '"{{#label}}" must be a valid dataUri string',
        'string.domain': '"{{#label}}" must contain a valid domain name',
        'string.email': '"{{#label}}" must be a valid email',
        'string.empty': '"{{#label}}" is not allowed to be empty',
        'string.guid': '"{{#label}}" must be a valid GUID',
        'string.hex': '"{{#label}}" must only contain hexadecimal characters',
        'string.hexAlign': '"{{#label}}" hex decoded representation must be byte aligned',
        'string.hostname': '"{{#label}}" must be a valid hostname',
        'string.ip': '"{{#label}}" must be a valid ip address with a {{#cidr}} CIDR',
        'string.ipVersion': '"{{#label}}" must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',
        'string.isoDate': '"{{#label}}" must be in iso format',
        'string.isoDuration': '"{{#label}}" must be a valid ISO 8601 duration',
        'string.length': '"{{#label}}" length must be {{#limit}} characters long',
        'string.lowercase': '"{{#label}}" must only contain lowercase characters',
        'string.max': '"{{#label}}" length must be less than or equal to {{#limit}} characters long',
        'string.min': '"{{#label}}" length must be at least {{#limit}} characters long',
        'string.normalize': '"{{#label}}" must be unicode normalized in the {{#form}} form',
        'string.token': '"{{#label}}" must only contain alpha-numeric and underscore characters',
        'string.pattern.base': '"{{#label}}" with value "{[.]}" fails to match the required pattern: {{#regex}}',
        'string.pattern.name': '"{{#label}}" with value "{[.]}" fails to match the {{#name}} pattern',
        'string.pattern.invert.base': '"{{#label}}" with value "{[.]}" matches the inverted pattern: {{#regex}}',
        'string.pattern.invert.name': '"{{#label}}" with value "{[.]}" matches the inverted {{#name}} pattern',
        'string.trim': '"{{#label}}" must not have leading or trailing whitespace',
        'string.uri': '"{{#label}}" must be a valid uri',
        'string.uriCustomScheme': '"{{#label}}" must be a valid uri with a scheme matching the {{#scheme}} pattern',
        'string.uriRelativeOnly': '"{{#label}}" must be a valid relative uri',
        'string.uppercase': '"{{#label}}" must only contain uppercase characters'
    }
});


// Helpers

internals.addressOptions = function (options) {

    if (!options) {
        return options;
    }

    // minDomainSegments

    Assert(options.minDomainSegments === undefined ||
        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');

    // tlds

    if (options.tlds === false) {
        return options;
    }

    if (options.tlds === true ||
        options.tlds === undefined) {

        Assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');

    const deny = options.tlds.deny;
    if (deny) {
        if (Array.isArray(deny)) {
            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });
        }

        Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');
        Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');
        return options;
    }

    const allow = options.tlds.allow;
    if (!allow) {
        return options;
    }

    if (allow === true) {
        Assert(internals.tlds, 'Built-in TLD list disabled');
        return Object.assign({}, options, internals.tlds);
    }

    if (Array.isArray(allow)) {
        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });
    }

    Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');
    return options;
};


internals.isoDate = function (value) {

    if (!Common.isIsoDate(value)) {
        return null;
    }

    const date = new Date(value);
    if (isNaN(date.getTime())) {
        return null;
    }

    return date.toISOString();
};


internals.length = function (schema, name, limit, operator, encoding) {

    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$

    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/string/ip.js":
/*!*******************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/string/ip.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Uri = __webpack_require__(/*! ./uri */ "./node_modules/@hapi/joi/lib/types/string/uri.js");


const internals = {};


exports.cidrs = {
    ipv4: {
        required: '\\/(?:' + Uri.ipv4Cidr + ')',
        optional: '(?:\\/(?:' + Uri.ipv4Cidr + '))?',
        forbidden: ''
    },
    ipv6: {
        required: '\\/' + Uri.ipv6Cidr,
        optional: '(?:\\/' + Uri.ipv6Cidr + ')?',
        forbidden: ''
    },
    ipvfuture: {
        required: '\\/' + Uri.ipv6Cidr,
        optional: '(?:\\/' + Uri.ipv6Cidr + ')?',
        forbidden: ''
    }
};


exports.versions = {
    ipv4: Uri.ipv4address,
    ipv6: Uri.ipv6address,
    ipvfuture: Uri.ipvFuture
};


exports.createIpRegex = function (versions, cidr) {

    const parts = versions.map((version) => exports.versions[version] + exports.cidrs[version][cidr]);
    return new RegExp('^(?:' + parts.join('|') + ')$');
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/string/uri.js":
/*!********************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/string/uri.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const EscapeRegex = __webpack_require__(/*! @hapi/hoek/lib/escapeRegex */ "./node_modules/@hapi/hoek/lib/escapeRegex.js");


const internals = {};


internals.generate = function () {

    const rfc3986 = {};

    const hexDigit = '\\dA-Fa-f';                                               // HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
    const hexDigitOnly = '[' + hexDigit + ']';

    const unreserved = '\\w-\\.~';                                              // unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"
    const subDelims = '!\\$&\'\\(\\)\\*\\+,;=';                                 // sub-delims = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
    const pctEncoded = '%' + hexDigit;                                          // pct-encoded = "%" HEXDIG HEXDIG
    const pchar = unreserved + pctEncoded + subDelims + ':@';                   // pchar = unreserved / pct-encoded / sub-delims / ":" / "@"
    const pcharOnly = '[' + pchar + ']';
    const decOctect = '(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])';     // dec-octet = DIGIT / %x31-39 DIGIT / "1" 2DIGIT / "2" %x30-34 DIGIT / "25" %x30-35  ; 0-9 / 10-99 / 100-199 / 200-249 / 250-255

    rfc3986.ipv4address = '(?:' + decOctect + '\\.){3}' + decOctect;            // IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet

    /*
        h16 = 1*4HEXDIG ; 16 bits of address represented in hexadecimal
        ls32 = ( h16 ":" h16 ) / IPv4address ; least-significant 32 bits of address
        IPv6address =                            6( h16 ":" ) ls32
                    /                       "::" 5( h16 ":" ) ls32
                    / [               h16 ] "::" 4( h16 ":" ) ls32
                    / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                    / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                    / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                    / [ *4( h16 ":" ) h16 ] "::"              ls32
                    / [ *5( h16 ":" ) h16 ] "::"              h16
                    / [ *6( h16 ":" ) h16 ] "::"
    */

    const h16 = hexDigitOnly + '{1,4}';
    const ls32 = '(?:' + h16 + ':' + h16 + '|' + rfc3986.ipv4address + ')';
    const IPv6SixHex = '(?:' + h16 + ':){6}' + ls32;
    const IPv6FiveHex = '::(?:' + h16 + ':){5}' + ls32;
    const IPv6FourHex = '(?:' + h16 + ')?::(?:' + h16 + ':){4}' + ls32;
    const IPv6ThreeHex = '(?:(?:' + h16 + ':){0,1}' + h16 + ')?::(?:' + h16 + ':){3}' + ls32;
    const IPv6TwoHex = '(?:(?:' + h16 + ':){0,2}' + h16 + ')?::(?:' + h16 + ':){2}' + ls32;
    const IPv6OneHex = '(?:(?:' + h16 + ':){0,3}' + h16 + ')?::' + h16 + ':' + ls32;
    const IPv6NoneHex = '(?:(?:' + h16 + ':){0,4}' + h16 + ')?::' + ls32;
    const IPv6NoneHex2 = '(?:(?:' + h16 + ':){0,5}' + h16 + ')?::' + h16;
    const IPv6NoneHex3 = '(?:(?:' + h16 + ':){0,6}' + h16 + ')?::';

    rfc3986.ipv4Cidr = '\\d|[1-2]\\d|3[0-2]';                                               // IPv4 cidr = DIGIT / %x31-32 DIGIT / "3" %x30-32  ; 0-9 / 10-29 / 30-32
    rfc3986.ipv6Cidr = '(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])';                         // IPv6 cidr = DIGIT / %x31-39 DIGIT / "1" %x0-1 DIGIT / "12" %x0-8;   0-9 / 10-99 / 100-119 / 120-128
    rfc3986.ipv6address = '(?:' + IPv6SixHex + '|' + IPv6FiveHex + '|' + IPv6FourHex + '|' + IPv6ThreeHex + '|' + IPv6TwoHex + '|' + IPv6OneHex + '|' + IPv6NoneHex + '|' + IPv6NoneHex2 + '|' + IPv6NoneHex3 + ')';
    rfc3986.ipvFuture = 'v' + hexDigitOnly + '+\\.[' + unreserved + subDelims + ':]+';      // IPvFuture = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

    rfc3986.scheme = '[a-zA-Z][a-zA-Z\\d+-\\.]*';                                           // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    rfc3986.schemeRegex = new RegExp(rfc3986.scheme);

    const userinfo = '[' + unreserved + pctEncoded + subDelims + ':]*';                     // userinfo = *( unreserved / pct-encoded / sub-delims / ":" )
    const IPLiteral = '\\[(?:' + rfc3986.ipv6address + '|' + rfc3986.ipvFuture + ')\\]';    // IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
    const regName = '[' + unreserved + pctEncoded + subDelims + ']{1,255}';                 // reg-name = *( unreserved / pct-encoded / sub-delims )
    const host = '(?:' + IPLiteral + '|' + rfc3986.ipv4address + '|' + regName + ')';       // host = IP-literal / IPv4address / reg-name
    const port = '\\d*';                                                                    // port = *DIGIT
    const authority = '(?:' + userinfo + '@)?' + host + '(?::' + port + ')?';               // authority   = [ userinfo "@" ] host [ ":" port ]
    const authorityCapture = '(?:' + userinfo + '@)?(' + host + ')(?::' + port + ')?';

    /*
        segment       = *pchar
        segment-nz    = 1*pchar
        path          = path-abempty    ; begins with "/" '|' is empty
                    / path-absolute   ; begins with "/" but not "//"
                    / path-noscheme   ; begins with a non-colon segment
                    / path-rootless   ; begins with a segment
                    / path-empty      ; zero characters
        path-abempty  = *( "/" segment )
        path-absolute = "/" [ segment-nz *( "/" segment ) ]
        path-rootless = segment-nz *( "/" segment )
    */

    const segment = pcharOnly + '*';
    const segmentNz = pcharOnly + '+';
    const segmentNzNc = '[' + unreserved + pctEncoded + subDelims + '@' + ']+';
    const pathEmpty = '';
    const pathAbEmpty = '(?:\\/' + segment + ')*';
    const pathAbsolute = '\\/(?:' + segmentNz + pathAbEmpty + ')?';
    const pathRootless = segmentNz + pathAbEmpty;
    const pathNoScheme = segmentNzNc + pathAbEmpty;
    const pathAbNoAuthority = '(?:\\/\\/\\/' + segment + pathAbEmpty + ')';     // Used by file:///

    // hier-part = "//" authority path

    rfc3986.hierPart = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathRootless + '|' + pathAbNoAuthority + ')';
    rfc3986.hierPartCapture = '(?:' + '(?:\\/\\/' + authorityCapture + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathRootless + ')';

    // relative-part = "//" authority path-abempty / path-absolute / path-noscheme / path-empty

    rfc3986.relativeRef = '(?:' + '(?:\\/\\/' + authority + pathAbEmpty + ')' + '|' + pathAbsolute + '|' + pathNoScheme + '|' + pathEmpty + ')';

    // query = *( pchar / "/" / "?" )
    // query = *( pchar / "[" / "]" / "/" / "?" )

    rfc3986.query = '[' + pchar + '\\/\\?]*(?=#|$)';                            //Finish matching either at the fragment part '|' end of the line.
    rfc3986.queryWithSquareBrackets = '[' + pchar + '\\[\\]\\/\\?]*(?=#|$)';

    // fragment = *( pchar / "/" / "?" )

    rfc3986.fragment = '[' + pchar + '\\/\\?]*';

    return rfc3986;
};


module.exports = exports = internals.rfc3986 = internals.generate();


internals.createRegex = function (options) {

    const rfc = internals.rfc3986;

    // Construct expression

    const query = options.allowQuerySquareBrackets ? rfc.queryWithSquareBrackets : rfc.query;
    const suffix = '(?:\\?' + query + ')?' + '(?:#' + rfc.fragment + ')?$';

    // relative-ref = relative-part [ "?" query ] [ "#" fragment ]

    if (options.relativeOnly) {
        return new RegExp('^' + rfc.relativeRef + suffix);
    }

    // Custom schemes

    let customScheme = '';
    if (options.scheme) {
        Assert(options.scheme instanceof RegExp || typeof options.scheme === 'string' || Array.isArray(options.scheme), 'scheme must be a RegExp, String, or Array');

        const schemes = [].concat(options.scheme);
        Assert(schemes.length >= 1, 'scheme must have at least 1 scheme specified');

        // Flatten the array into a string to be used to match the schemes

        const selections = [];
        for (let i = 0; i < schemes.length; ++i) {
            const scheme = schemes[i];
            Assert(scheme instanceof RegExp || typeof scheme === 'string', 'scheme at position ' + i + ' must be a RegExp or String');

            if (scheme instanceof RegExp) {
                selections.push(scheme.source.toString());
            }
            else {
                Assert(rfc.schemeRegex.test(scheme), 'scheme at position ' + i + ' must be a valid scheme');
                selections.push(EscapeRegex(scheme));
            }
        }

        customScheme = selections.join('|');
    }

    // URI = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

    const scheme = customScheme ? '(?:' + customScheme + ')' : rfc.scheme;
    const absolute = '(?:' + scheme + ':' + (options.domain ? rfc.hierPartCapture : rfc.hierPart) + ')';
    const prefix = options.allowRelative ? '(?:' + absolute + '|' + rfc.relativeRef + ')' : absolute;
    const regex = new RegExp('^' + prefix + suffix);
    regex.scheme = customScheme;
    return regex;
};


internals.uriRegex = internals.createRegex({});


exports.createRegex = function (options = {}) {

    if (options.scheme ||
        options.allowRelative ||
        options.relativeOnly ||
        options.allowQuerySquareBrackets ||
        options.domain) {

        return internals.createRegex(options);
    }

    return internals.uriRegex;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/types/symbol.js":
/*!****************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/types/symbol.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");

const Any = __webpack_require__(/*! ./any */ "./node_modules/@hapi/joi/lib/types/any.js");


const internals = {};


internals.Map = class extends Map {

    slice() {

        return new internals.Map(this);
    }
};


module.exports = Any.extend({

    type: 'symbol',

    terms: {

        map: { init: new internals.Map() }
    },

    coerce: {
        method(value, { schema, error }) {

            const lookup = schema.$_terms.map.get(value);
            if (lookup) {
                value = lookup;
            }

            if (!schema._flags.only ||
                typeof value === 'symbol') {

                return { value };
            }

            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };
        }
    },

    validate(value, { error }) {

        if (typeof value !== 'symbol') {
            return { value, errors: error('symbol.base') };
        }
    },

    rules: {
        map: {
            method(iterable) {

                if (iterable &&
                    !iterable[Symbol.iterator] &&
                    typeof iterable === 'object') {

                    iterable = Object.entries(iterable);
                }

                Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');

                const obj = this.clone();

                const symbols = [];
                for (const entry of iterable) {
                    Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');
                    const [key, value] = entry;

                    Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');
                    Assert(typeof value === 'symbol', 'Value must be a Symbol');

                    obj.$_terms.map.set(key, value);
                    symbols.push(value);
                }

                return obj.valid(...symbols);
            }
        }
    },

    manifest: {

        build(obj, desc) {

            if (desc.map) {
                obj = obj.map(desc.map);
            }

            return obj;
        }
    },

    messages: {
        'symbol.base': '"{{#label}}" must be a symbol',
        'symbol.map': '"{{#label}}" must be one of {{#map}}'
    }
});


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/validator.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/joi/lib/validator.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const Clone = __webpack_require__(/*! @hapi/hoek/lib/clone */ "./node_modules/@hapi/hoek/lib/clone.js");
const Ignore = __webpack_require__(/*! @hapi/hoek/lib/ignore */ "./node_modules/@hapi/hoek/lib/ignore.js");
const Reach = __webpack_require__(/*! @hapi/hoek/lib/reach */ "./node_modules/@hapi/hoek/lib/reach.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@hapi/joi/lib/errors.js");
const State = __webpack_require__(/*! ./state */ "./node_modules/@hapi/joi/lib/state.js");


const internals = {
    result: Symbol('result')
};


exports.entry = function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');
    const outcome = { value: result.value };

    if (result.error) {
        outcome.error = result.error;
    }

    if (result.mainstay.warnings.length) {
        outcome.warning = Errors.details(result.mainstay.warnings);
    }

    if (result.mainstay.debug) {
        outcome.debug = result.mainstay.debug;
    }

    return outcome;
};


exports.entryAsync = async function (value, schema, prefs) {

    let settings = Common.defaults;
    if (prefs) {
        settings = Common.preferences(Common.defaults, prefs);
    }

    const result = internals.entry(value, schema, settings);
    const mainstay = result.mainstay;
    if (result.error) {
        if (mainstay.debug) {
            result.error.debug = mainstay.debug;
        }

        throw result.error;
    }

    if (mainstay.externals.length) {
        let root = result.value;
        for (const { method, path, label } of mainstay.externals) {
            let node = root;
            let key;
            let parent;

            if (path.length) {
                key = path[path.length - 1];
                parent = Reach(root, path.slice(0, -1));
                node = parent[key];
            }

            try {
                const output = await method(node);
                if (output === undefined ||
                    output === node) {

                    continue;
                }

                if (parent) {
                    parent[key] = output;
                }
                else {
                    root = output;
                }
            }
            catch (err) {
                err.message += ` (${label})`;       // Change message to include path
                throw err;
            }
        }

        result.value = root;
    }

    if (!settings.warnings &&
        !settings.debug) {

        return result.value;
    }

    const outcome = { value: result.value };
    if (mainstay.warnings.length) {
        outcome.warning = Errors.details(mainstay.warnings);
    }

    if (mainstay.debug) {
        outcome.debug = mainstay.debug;
    }

    return outcome;
};


internals.entry = function (value, schema, prefs) {

    // Prepare state

    const { tracer, cleanup } = internals.tracer(schema, prefs);
    const debug = prefs.debug ? [] : null;
    const links = schema._ids._schemaChain ? new Map() : null;
    const mainstay = { externals: [], warnings: [], tracer, debug, links };
    const schemas = schema._ids._schemaChain ? [{ schema }] : null;
    const state = new State([], [], { mainstay, schemas });

    // Validate value

    const result = exports.validate(value, schema, state, prefs);

    // Process value and errors

    if (cleanup) {
        schema.$_root.untrace();
    }

    const error = Errors.process(result.errors, value, prefs);
    return { value: result.value, error, mainstay };
};


internals.tracer = function (schema, prefs) {

    if (schema.$_root._tracer) {
        return { tracer: schema.$_root._tracer._register(schema) };
    }

    if (prefs.debug) {
        Assert(schema.$_root.trace, 'Debug mode not supported');
        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };
    }

    return { tracer: internals.ignore };
};


exports.validate = function (value, schema, state, prefs, overrides = {}) {

    if (schema.$_terms.whens) {
        schema = schema._generate(value, state, prefs).schema;
    }

    // Setup state and settings

    if (schema._preferences) {
        prefs = internals.prefs(schema, prefs);
    }

    // Cache

    if (schema._cache &&
        prefs.cache) {

        const result = schema._cache.get(value);
        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);
        if (result) {
            return result;
        }
    }

    // Helpers

    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);
    const helpers = {
        original: value,
        prefs,
        schema,
        state,
        error: createError,
        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),
        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })
    };

    // Prepare

    state.mainstay.tracer.entry(schema, state);

    const def = schema._definition;
    if (def.prepare &&
        value !== undefined &&
        prefs.convert) {

        const prepared = def.prepare(value, helpers);
        if (prepared) {
            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);
            if (prepared.errors) {
                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early
            }

            value = prepared.value;
        }
    }

    // Type coercion

    if (def.coerce &&
        value !== undefined &&
        prefs.convert &&
        (!def.coerce.from || def.coerce.from.includes(typeof value))) {

        const coerced = def.coerce.method(value, helpers);
        if (coerced) {
            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);
            if (coerced.errors) {
                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early
            }

            value = coerced.value;
        }
    }

    // Empty value

    const empty = schema._flags.empty;
    if (empty &&
        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {

        state.mainstay.tracer.value(state, 'empty', value, undefined);
        value = undefined;
    }

    // Presence requirements (required, optional, forbidden)

    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? 'ignore' : prefs.presence);
    if (value === undefined) {
        if (presence === 'forbidden') {
            return internals.finalize(value, null, helpers);
        }

        if (presence === 'required') {
            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);
        }

        if (presence === 'optional') {
            if (schema._flags.default !== Common.symbols.deepDefault) {
                return internals.finalize(value, null, helpers);
            }

            state.mainstay.tracer.value(state, 'default', value, {});
            value = {};
        }
    }
    else if (presence === 'forbidden') {
        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);
    }

    // Allowed values

    const errors = [];

    if (schema._valids) {
        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            if (prefs.convert) {
                state.mainstay.tracer.value(state, 'valids', value, match.value);
                value = match.value;
            }

            state.mainstay.tracer.filter(schema, state, 'valid', match);
            return internals.finalize(value, null, helpers);
        }

        if (schema._flags.only) {
            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Denied values

    if (schema._invalids) {
        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);
        if (match) {
            state.mainstay.tracer.filter(schema, state, 'invalid', match);
            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);
            if (prefs.abortEarly) {
                return internals.finalize(value, [report], helpers);
            }

            errors.push(report);
        }
    }

    // Base type

    if (def.validate) {
        const base = def.validate(value, helpers);
        if (base) {
            state.mainstay.tracer.value(state, 'base', value, base.value);
            value = base.value;

            if (base.errors) {
                if (!Array.isArray(base.errors)) {
                    errors.push(base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }

                if (base.errors.length) {
                    errors.push(...base.errors);
                    return internals.finalize(value, errors, helpers);          // Base error always aborts early
                }
            }
        }
    }

    // Validate tests

    if (!schema._rules.length) {
        return internals.finalize(value, errors, helpers);
    }

    return internals.rules(value, errors, helpers);
};


internals.rules = function (value, errors, helpers) {

    const { schema, state, prefs } = helpers;

    for (const rule of schema._rules) {
        const definition = schema._definition.rules[rule.method];

        // Skip rules that are also applied in coerce step

        if (definition.convert &&
            prefs.convert) {

            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');
            continue;
        }

        // Resolve references

        let ret;
        let args = rule.args;
        if (rule._resolve.length) {
            args = Object.assign({}, args);                                     // Shallow copy
            for (const key of rule._resolve) {
                const resolver = definition.argsByName.get(key);

                const resolved = args[key].resolve(value, state, prefs);
                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;

                const invalid = Common.validateArg(normalized, null, resolver);
                if (invalid) {
                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);
                    break;
                }

                args[key] = normalized;
            }
        }

        // Test rule

        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error

        const result = internals.rule(ret, rule);
        if (result.errors) {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');

            if (rule.warn) {
                state.mainstay.warnings.push(...result.errors);
                continue;
            }

            if (prefs.abortEarly) {
                return internals.finalize(value, result.errors, helpers);
            }

            errors.push(...result.errors);
        }
        else {
            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');
            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);
            value = result.value;
        }
    }

    return internals.finalize(value, errors, helpers);
};


internals.rule = function (ret, rule) {

    if (ret instanceof Errors.Report) {
        internals.error(ret, rule);
        return { errors: [ret], value: null };
    }

    if (Array.isArray(ret) &&
        (ret[0] instanceof Errors.Report || ret[0] instanceof Error)) {

        ret.forEach((report) => internals.error(report, rule));
        return { errors: ret, value: null };
    }

    return { errors: null, value: ret };
};


internals.error = function (report, rule) {

    if (rule.message) {
        report._setTemplate(rule.message);
    }

    return report;
};


internals.finalize = function (value, errors, helpers) {

    errors = errors || [];
    const { schema, state, prefs } = helpers;

    // Failover value

    if (errors.length) {
        const failover = internals.default('failover', undefined, errors, helpers);
        if (failover !== undefined) {
            state.mainstay.tracer.value(state, 'failover', value, failover);
            value = failover;
            errors = [];
        }
    }

    // Error override

    if (errors.length &&
        schema._flags.error) {

        if (typeof schema._flags.error === 'function') {
            errors = schema._flags.error(errors);
            if (!Array.isArray(errors)) {
                errors = [errors];
            }

            for (const error of errors) {
                Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');
            }
        }
        else {
            errors = [schema._flags.error];
        }
    }

    // Default

    if (value === undefined) {
        const defaulted = internals.default('default', value, errors, helpers);
        state.mainstay.tracer.value(state, 'default', value, defaulted);
        value = defaulted;
    }

    // Cast

    if (schema._flags.cast &&
        value !== undefined) {

        const caster = schema._definition.cast[schema._flags.cast];
        if (caster.from(value)) {
            const casted = caster.to(value, helpers);
            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);
            value = casted;
        }
    }

    // Externals

    if (schema.$_terms.externals &&
        prefs.externals &&
        prefs._externals !== false) {                       // Disabled for matching

        for (const { method } of schema.$_terms.externals) {
            state.mainstay.externals.push({ method, path: state.path, label: Errors.label(schema._flags, state, prefs) });
        }
    }

    // Result

    const result = { value, errors: errors.length ? errors : null };

    if (schema._flags.result) {
        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;
        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);
        state.shadow(value, schema._flags.result);
    }

    // Cache

    if (schema._cache &&
        prefs.cache !== false &&
        !schema._refs.length) {

        schema._cache.set(helpers.original, result);
    }

    return result;
};


internals.prefs = function (schema, prefs) {

    const isDefaultOptions = prefs === Common.defaults;
    if (isDefaultOptions &&
        schema._preferences[Common.symbols.prefs]) {

        return schema._preferences[Common.symbols.prefs];
    }

    prefs = Common.preferences(prefs, schema._preferences);
    if (isDefaultOptions) {
        schema._preferences[Common.symbols.prefs] = prefs;
    }

    return prefs;
};


internals.default = function (flag, value, errors, { schema, state, prefs }) {

    const source = schema._flags[flag];
    if (prefs.noDefaults ||
        source === undefined) {

        return value;
    }

    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');

    if (!source) {
        return source;
    }

    if (typeof source === 'function') {
        const args = source.length > 0 ? [Clone(state.ancestors[0]), prefs] : [];

        try {
            return source(...args);
        }
        catch (err) {
            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));
            return;
        }
    }

    if (typeof source !== 'object') {
        return source;
    }

    if (source[Common.symbols.literal]) {
        return source.literal;
    }

    if (Common.isResolvable(source)) {
        return source.resolve(value, state, prefs);
    }

    return Clone(source);
};


internals.trim = function (value, schema) {

    if (typeof value !== 'string') {
        return value;
    }

    const trim = schema.$_getRule('trim');
    if (!trim ||
        !trim.args.enabled) {

        return value;
    }

    return value.trim();
};


internals.ignore = {
    active: false,
    debug: Ignore,
    entry: Ignore,
    filter: Ignore,
    log: Ignore,
    resolve: Ignore,
    value: Ignore
};


/***/ }),

/***/ "./node_modules/@hapi/joi/lib/values.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/joi/lib/values.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");
const DeepEqual = __webpack_require__(/*! @hapi/hoek/lib/deepEqual */ "./node_modules/@hapi/hoek/lib/deepEqual.js");

const Common = __webpack_require__(/*! ./common */ "./node_modules/@hapi/joi/lib/common.js");


const internals = {};


module.exports = internals.Values = class {

    constructor(values, refs) {

        this._values = new Set(values);
        this._refs = new Set(refs);
        this._lowercase = internals.lowercases(values);

        this._override = false;
    }

    get length() {

        return this._values.size + this._refs.size;
    }

    add(value, refs) {

        // Reference

        if (Common.isResolvable(value)) {
            if (!this._refs.has(value)) {
                this._refs.add(value);

                if (refs) {                     // Skipped in a merge
                    refs.register(value);
                }
            }

            return;
        }

        // Value

        if (!this.has(value, null, null, false)) {
            this._values.add(value);

            if (typeof value === 'string') {
                this._lowercase.set(value.toLowerCase(), value);
            }
        }
    }

    static merge(target, source, remove) {

        target = target || new internals.Values();

        if (source) {
            if (source._override) {
                return source.clone();
            }

            for (const item of [...source._values, ...source._refs]) {
                target.add(item);
            }
        }

        if (remove) {
            for (const item of [...remove._values, ...remove._refs]) {
                target.remove(item);
            }
        }

        return target.length ? target : null;
    }

    remove(value) {

        // Reference

        if (Common.isResolvable(value)) {
            this._refs.delete(value);
            return;
        }

        // Value

        this._values.delete(value);

        if (typeof value === 'string') {
            this._lowercase.delete(value.toLowerCase());
        }
    }

    has(value, state, prefs, insensitive) {

        return !!this.get(value, state, prefs, insensitive);
    }

    get(value, state, prefs, insensitive) {

        if (!this.length) {
            return false;
        }

        // Simple match

        if (this._values.has(value)) {
            return { value };
        }

        // Case insensitive string match

        if (typeof value === 'string' &&
            value &&
            insensitive) {

            const found = this._lowercase.get(value.toLowerCase());
            if (found) {
                return { value: found };
            }
        }

        if (!this._refs.size &&
            typeof value !== 'object') {

            return false;
        }

        // Objects

        if (typeof value === 'object') {
            for (const item of this._values) {
                if (DeepEqual(item, value)) {
                    return { value: item };
                }
            }
        }

        // References

        if (state) {
            for (const ref of this._refs) {
                const resolved = ref.resolve(value, state, prefs, null, { in: true });
                if (resolved === undefined) {
                    continue;
                }

                const items = !ref.in || typeof resolved !== 'object'
                    ? [resolved]
                    : Array.isArray(resolved) ? resolved : Object.keys(resolved);

                for (const item of items) {
                    if (typeof item !== typeof value) {
                        continue;
                    }

                    if (insensitive &&
                        value &&
                        typeof value === 'string') {

                        if (item.toLowerCase() === value.toLowerCase()) {
                            return { value: item, ref };
                        }
                    }
                    else {
                        if (DeepEqual(item, value)) {
                            return { value: item, ref };
                        }
                    }
                }
            }
        }

        return false;
    }

    override() {

        this._override = true;
    }

    values(options) {

        if (options &&
            options.display) {

            const values = [];

            for (const item of [...this._values, ...this._refs]) {
                if (item !== undefined) {
                    values.push(item);
                }
            }

            return values;
        }

        return Array.from([...this._values, ...this._refs]);
    }

    clone() {

        const set = new internals.Values(this._values, this._refs);
        set._override = this._override;
        return set;
    }

    concat(source) {

        Assert(!source._override, 'Cannot concat override set of values');

        const set = new internals.Values([...this._values, ...source._values], [...this._refs, ...source._refs]);
        set._override = this._override;
        return set;
    }

    describe() {

        const normalized = [];

        if (this._override) {
            normalized.push({ override: true });
        }

        for (const value of this._values.values()) {
            normalized.push(value && typeof value === 'object' ? { value } : value);
        }

        for (const value of this._refs.values()) {
            normalized.push(value.describe());
        }

        return normalized;
    }
};


internals.Values.prototype[Common.symbols.values] = true;


// Aliases

internals.Values.prototype.slice = internals.Values.prototype.clone;


// Helpers

internals.lowercases = function (from) {

    const map = new Map();

    if (from) {
        for (const value of from) {
            if (typeof value === 'string') {
                map.set(value.toLowerCase(), value);
            }
        }
    }

    return map;
};


/***/ }),

/***/ "./node_modules/@hapi/joi/package.json":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/joi/package.json ***!
  \*********************************************/
/*! exports provided: name, description, version, repository, main, browser, keywords, dependencies, devDependencies, scripts, files, license, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"@hapi/joi\",\"description\":\"Object schema validation\",\"version\":\"16.1.7\",\"repository\":\"git://github.com/hapijs/joi\",\"main\":\"lib/index.js\",\"browser\":\"dist/joi-browser.min.js\",\"keywords\":[\"schema\",\"validation\"],\"dependencies\":{\"@hapi/address\":\"^2.1.2\",\"@hapi/formula\":\"^1.2.0\",\"@hapi/hoek\":\"^8.2.4\",\"@hapi/pinpoint\":\"^1.0.2\",\"@hapi/topo\":\"^3.1.3\"},\"devDependencies\":{\"@hapi/bourne\":\"1.x.x\",\"@hapi/code\":\"6.x.x\",\"@hapi/lab\":\"20.x.x\",\"@hapi/joi-legacy-test\":\"npm:@hapi/joi@15.x.x\"},\"scripts\":{\"prepublishOnly\":\"cd browser && npm install && npm run build\",\"test\":\"lab -t 100 -a @hapi/code -L\",\"test-cov-html\":\"lab -r html -o coverage.html -a @hapi/code\"},\"files\":[\"lib/**/*\",\"dist/*\"],\"license\":\"BSD-3-Clause\"}");

/***/ }),

/***/ "./node_modules/@hapi/mimos/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/mimos/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Path = __webpack_require__(/*! path */ "path");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const MimeDb = __webpack_require__(/*! mime-db/db.json */ "./node_modules/mime-db/db.json");          // Load JSON file to prevent loading or executing code


const internals = {};


internals.compressibleRx = /^text\/|\+json$|\+text$|\+xml$/;


internals.compile = function (override) {

    const db = Hoek.clone(MimeDb);
    Hoek.merge(db, override, { nullOverride: true, mergeArrays: false });

    const result = {
        byType: db,
        byExtension: {}
    };

    const keys = Object.keys(result.byType);
    for (let i = 0; i < keys.length; ++i) {
        const type = keys[i];
        const mime = result.byType[type];
        mime.type = mime.type || type;
        mime.source = mime.source || 'mime-db';
        mime.extensions = mime.extensions || [];
        mime.compressible = (mime.compressible !== undefined ? mime.compressible : internals.compressibleRx.test(type));

        Hoek.assert(!mime.predicate || typeof mime.predicate === 'function', 'predicate option must be a function');

        for (let j = 0; j < mime.extensions.length; ++j) {
            const ext = mime.extensions[j];
            result.byExtension[ext] = mime;
        }
    }

    return result;
};


module.exports = class Mimos {
    constructor(options) {

        options = options || {};
        const result = options.override ? internals.compile(options.override) : internals.base;
        this._byType = result.byType;
        this._byExtension = result.byExtension;
    }

    path(path) {

        const extension = Path.extname(path).slice(1).toLowerCase();
        const mime = this._byExtension[extension] || {};

        if (mime.predicate) {
            return mime.predicate(Hoek.clone(mime));
        }

        return mime;
    }

    type(type) {

        type = type.split(';', 1)[0].trim().toLowerCase();
        let mime = this._byType[type];
        if (!mime) {
            mime = {
                type,
                source: 'mimos',
                extensions: [],
                compressible: internals.compressibleRx.test(type)
            };

            this._byType[type] = mime;
            return mime;
        }

        if (mime.predicate) {
            return mime.predicate(Hoek.clone(mime));
        }

        return mime;
    }
};


internals.base = internals.compile();       // Prevents an expensive copy on each constructor when no customization is needed


/***/ }),

/***/ "./node_modules/@hapi/nigel/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/nigel/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Vise = __webpack_require__(/*! @hapi/vise */ "./node_modules/@hapi/vise/lib/index.js");


const internals = {};


exports.compile = function (needle) {

    Hoek.assert(needle && needle.length, 'Missing needle');
    Hoek.assert(Buffer.isBuffer(needle), 'Needle must be a buffer');

    const profile = {
        value: needle,
        lastPos: needle.length - 1,
        last: needle[needle.length - 1],
        length: needle.length,
        badCharShift: Buffer.alloc(256)                  // Lookup table of how many characters can be skipped for each match
    };

    for (let i = 0; i < 256; ++i) {
        profile.badCharShift[i] = profile.length;       // Defaults to the full length of the needle
    }

    const last = profile.length - 1;
    for (let i = 0; i < last; ++i) {                    // For each character in the needle (skip last since its position is already the default)
        profile.badCharShift[profile.value[i]] = last - i;
    }

    return profile;
};


exports.horspool = function (haystack, needle, start) {

    Hoek.assert(haystack, 'Missing haystack');

    needle = (needle.badCharShift ? needle : exports.compile(needle));
    start = start || 0;

    for (let i = start; i <= haystack.length - needle.length;) {       // Has enough room to fit the entire needle
        const lastChar = haystack.readUInt8(i + needle.lastPos);
        if (lastChar === needle.last &&
            internals.startsWith(haystack, needle, i)) {

            return i;
        }

        i += needle.badCharShift[lastChar];           // Jump to the next possible position based on last character location in needle
    }

    return -1;
};


internals.startsWith = function (haystack, needle, pos) {

    if (haystack.startsWith) {
        return haystack.startsWith(needle.value, pos, needle.lastPos);
    }

    for (let i = 0; i < needle.lastPos; ++i) {
        if (needle.value[i] !== haystack.readUInt8(pos + i)) {
            return false;
        }
    }

    return true;
};


exports.all = function (haystack, needle, start) {

    needle = exports.compile(needle);
    start = start || 0;

    const matches = [];
    for (let i = start; i !== -1 && i < haystack.length;) {

        i = exports.horspool(haystack, needle, i);
        if (i !== -1) {
            matches.push(i);
            i += needle.length;
        }
    }

    return matches;
};


internals._indexOf = function (haystack, needle) {

    Hoek.assert(haystack, 'Missing haystack');

    for (let i = 0; i <= haystack.length - needle.length; ++i) {       // Has enough room to fit the entire needle
        if (haystack.startsWith(needle.value, i)) {
            return i;
        }
    }

    return -1;
};


exports.Stream = internals.Stream = class extends Stream.Writable {

    constructor(needle) {

        super();

        this.needle(needle);
        this._haystack = new Vise();
        this._indexOf = this._needle.length > 2 ? exports.horspool : internals._indexOf;

        this.on('finish', () => {

            // Flush out the remainder

            const chunks = this._haystack.chunks();
            for (let i = 0; i < chunks.length; ++i) {
                this.emit('haystack', chunks[i]);
            }

            setImmediate(() => this.emit('close'));     // Give pending events a chance to fire
        });
    }

    needle(needle) {

        this._needle = exports.compile(needle);
    }

    _write(chunk, encoding, next) {

        this._haystack.push(chunk);

        let match = this._indexOf(this._haystack, this._needle);
        if (match === -1 &&
            chunk.length >= this._needle.length) {

            this._flush(this._haystack.length - chunk.length);
        }

        while (match !== -1) {
            this._flush(match);
            this._haystack.shift(this._needle.length);
            this.emit('needle');

            match = this._indexOf(this._haystack, this._needle);
        }

        if (this._haystack.length) {
            const notChecked = this._haystack.length - this._needle.length + 1;       // Not enough space for Horspool
            let i = notChecked;
            for (; i < this._haystack.length; ++i) {
                if (this._haystack.startsWith(this._needle.value, i, this._haystack.length - i)) {
                    break;
                }
            }

            this._flush(i);
        }

        return next();
    }

    _flush(pos) {

        const chunks = this._haystack.shift(pos);
        for (let i = 0; i < chunks.length; ++i) {
            this.emit('haystack', chunks[i]);
        }
    }

    flush() {

        const chunks = this._haystack.shift(this._haystack.length);
        for (let i = 0; i < chunks.length; ++i) {
            this.emit('haystack', chunks[i]);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/pez/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/pez/lib/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const B64 = __webpack_require__(/*! @hapi/b64 */ "./node_modules/@hapi/b64/lib/index.js");
const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Content = __webpack_require__(/*! @hapi/content */ "./node_modules/@hapi/content/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Nigel = __webpack_require__(/*! @hapi/nigel */ "./node_modules/@hapi/nigel/lib/index.js");


const internals = {};


/*
    RFC 2046 (http://tools.ietf.org/html/rfc2046)

    multipart-body = [preamble CRLF]
                    dash-boundary *( SPACE / HTAB ) CRLF body-part
                    *( CRLF dash-boundary *( SPACE / HTAB ) CRLF body-part )
                    CRLF dash-boundary "--" *( SPACE / HTAB )
                    [CRLF epilogue]

    boundary       = 0*69<bchars> bcharsnospace
    bchars         = bcharsnospace / " "
    bcharsnospace  = DIGIT / ALPHA / "'" / "(" / ")" / "+" / "_" / "," / "-" / "." / "/" / ":" / "=" / "?"
    dash-boundary  = "--" boundary

    preamble       = discard-text
    epilogue       = discard-text
    discard-text   = *(*text CRLF) *text

    body-part      = MIME-part-headers [CRLF *OCTET]
    OCTET          = <any 0-255 octet value>

    SPACE          = 32
    HTAB           = 9
    CRLF           = 13 10
*/


internals.state = {
    preamble: 0,                // Until the first boundary is received
    boundary: 1,                // After a boundary, waiting for first line with optional linear-whitespace
    header: 2,                  // Receiving part headers
    payload: 3,                 // Receiving part payload
    epilogue: 4
};


internals.defaults = {
    maxBytes: Infinity
};


exports.Dispenser = internals.Dispenser = class extends Stream.Writable {

    constructor(options) {

        super();

        Hoek.assert(options !== null && typeof options === 'object', 'options must be an object');
        const settings = Hoek.applyToDefaults(internals.defaults, options);

        this._boundary = settings.boundary;
        this._state = internals.state.preamble;
        this._held = '';

        this._stream = null;
        this._headers = {};
        this._name = '';
        this._pendingHeader = '';
        this._error = null;
        this._bytes = 0;
        this._maxBytes = settings.maxBytes;

        this._parts = new Nigel.Stream(Buffer.from('--' + settings.boundary));
        this._lines = new Nigel.Stream(Buffer.from('\r\n'));

        this._parts.on('needle', () => this._onPartEnd());
        this._parts.on('haystack', (chunk) => this._onPart(chunk));
        this._lines.on('needle', () => this._onLineEnd());
        this._lines.on('haystack', (chunk) => this._onLine(chunk));
        this.once('finish', () => this._parts.end());
        this._parts.once('close', () => this._lines.end());

        let piper = null;
        let finish = (err) => {

            if (piper) {
                piper.removeListener('data', onReqData);
                piper.removeListener('error', finish);
                piper.removeListener('aborted', onReqAborted);
            }

            if (err) {
                return this._abort(err);
            }

            this._emit('close');
        };

        finish = Hoek.once(finish);

        this._lines.once('close', () => {

            if (this._state === internals.state.epilogue) {
                if (this._held) {
                    this._emit('epilogue', this._held);
                    this._held = '';
                }
            }
            else if (this._state === internals.state.boundary) {
                if (!this._held) {
                    this._abort(Boom.badRequest('Missing end boundary'));
                }
                else if (this._held !== '--') {
                    this._abort(Boom.badRequest('Only white space allowed after boundary at end'));
                }
            }
            else {
                this._abort(Boom.badRequest('Incomplete multipart payload'));
            }

            setImmediate(finish);                  // Give pending events a chance to fire
        });

        const onReqAborted = () => {

            finish(Boom.badRequest('Client request aborted'));
        };

        const onReqData = (data) => {

            this._bytes += Buffer.byteLength(data);

            if (this._bytes > this._maxBytes) {
                finish(Boom.entityTooLarge('Maximum size exceeded'));
            }
        };

        this.once('pipe', (req) => {

            piper = req;
            req.on('data', onReqData);
            req.once('error', finish);
            req.once('aborted', onReqAborted);
        });
    }
};


internals.Dispenser.prototype._write = function (buffer, encoding, next) {

    if (this._error) {
        return next();
    }

    this._parts.write(buffer);
    return next();
};


internals.Dispenser.prototype._emit = function (...args) {

    if (this._error) {
        return;
    }

    this.emit(...args);
};


internals.Dispenser.prototype._abort = function (err) {

    this._emit('error', err);
    this._error = err;
};


internals.Dispenser.prototype._onPartEnd = function () {

    this._lines.flush();

    if (this._state === internals.state.preamble) {
        if (this._held) {
            const last = this._held.length - 1;

            if (this._held[last] !== '\n' ||
                this._held[last - 1] !== '\r') {

                return this._abort(Boom.badRequest('Preamble missing CRLF terminator'));
            }

            this._emit('preamble', this._held.slice(0, -2));
            this._held = '';
        }

        this._parts.needle(Buffer.from('\r\n--' + this._boundary));                      // CRLF no longer optional
    }

    this._state = internals.state.boundary;

    if (this._stream) {
        this._stream.end();
        this._stream = null;
    }
    else if (this._name) {
        this._emit('field', this._name, this._held);
        this._name = '';
        this._held = '';
    }
};


internals.Dispenser.prototype._onPart = function (chunk) {

    if (this._state === internals.state.preamble) {
        this._held = this._held + chunk.toString();
    }
    else if (this._state === internals.state.payload) {
        if (this._stream) {
            this._stream.write(chunk);                                                 // Stream payload
        }
        else {
            this._held = this._held + chunk.toString();
        }
    }
    else {
        this._lines.write(chunk);                                                       // Look for boundary
    }
};


internals.Dispenser.prototype._onLineEnd = function () {

    // Boundary whitespace

    if (this._state === internals.state.boundary) {
        if (this._held) {
            this._held = this._held.replace(/[\t ]/g, '');                                // trim() removes new lines
            if (this._held) {
                if (this._held === '--') {
                    this._state = internals.state.epilogue;
                    this._held = '';

                    return;
                }

                return this._abort(Boom.badRequest('Only white space allowed after boundary'));
            }
        }

        this._state = internals.state.header;

        return;
    }

    // Part headers

    if (this._state === internals.state.header) {

        // Header

        if (this._held) {

            // Header continuation

            if (this._held[0] === ' ' ||
                this._held[0] === '\t') {

                if (!this._pendingHeader) {
                    return this._abort(Boom.badRequest('Invalid header continuation without valid declaration on previous line'));
                }

                this._pendingHeader = this._pendingHeader + ' ' + this._held.slice(1);                       // Drop tab
                this._held = '';
                return;
            }

            // Start of new header

            this._flushHeader();
            this._pendingHeader = this._held;
            this._held = '';

            return;
        }

        // End of headers

        this._flushHeader();

        this._state = internals.state.payload;

        let disposition;

        try {
            disposition = Content.disposition(this._headers['content-disposition']);
        }
        catch (err) {
            return this._abort(err);
        }

        if (disposition.filename !== undefined) {
            const stream = new Stream.PassThrough();
            const transferEncoding = this._headers['content-transfer-encoding'];

            if (transferEncoding &&
                transferEncoding.toLowerCase() === 'base64') {

                this._stream = new B64.Decoder();
                this._stream.pipe(stream);
            }
            else {
                this._stream = stream;
            }

            stream.name = disposition.name;
            stream.filename = disposition.filename;
            stream.headers = this._headers;
            this._headers = {};
            this._emit('part', stream);
        }
        else {
            this._name = disposition.name;
        }

        this._lines.flush();
        return;
    }

    // Epilogue

    this._held = this._held + '\r\n';                               // Put the new line back
};


internals.Dispenser.prototype._onLine = function (chunk) {

    if (this._stream) {
        this._stream.write(chunk);                      // Stream payload
    }
    else {
        this._held = this._held + chunk.toString();                 // Reading header or field
    }
};


internals.Dispenser.prototype._flushHeader = function () {

    if (!this._pendingHeader) {
        return;
    }

    const sep = this._pendingHeader.indexOf(':');

    if (sep === -1) {
        return this._abort(Boom.badRequest('Invalid header missing colon separator'));
    }

    if (!sep) {
        return this._abort(Boom.badRequest('Invalid header missing field name'));
    }

    this._headers[this._pendingHeader.slice(0, sep).toLowerCase()] = this._pendingHeader.slice(sep + 1).trim();
    this._pendingHeader = '';
};


/***/ }),

/***/ "./node_modules/@hapi/pinpoint/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/pinpoint/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.location = function (depth = 0) {

    const orig = Error.prepareStackTrace;
    Error.prepareStackTrace = (ignore, stack) => stack;

    const capture = {};
    Error.captureStackTrace(capture, this);
    const line = capture.stack[depth + 1];

    Error.prepareStackTrace = orig;

    return {
        filename: line.getFileName(),
        line: line.getLineNumber()
    };
};


/***/ }),

/***/ "./node_modules/@hapi/podium/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/podium/lib/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {
    schema: {
        base: Joi.object({
            name: Joi.string().required(),
            clone: Joi.boolean(),
            tags: Joi.boolean(),
            spread: Joi.boolean(),
            channels: Joi.array().items(Joi.string()).single().unique().min(1)
        })
    }
};


internals.schema.event = internals.schema.base.keys({
    shared: Joi.boolean()
});


internals.schema.listener = internals.schema.event.keys({
    listener: Joi.func().required(),
    context: Joi.object(),
    count: Joi.number().integer().min(1),
    filter: {
        tags: Joi.array().items(Joi.string()).single().unique().min(1).required(),
        all: Joi.boolean()
    }
});


exports = module.exports = internals.Podium = function (events, options) {

    // Use descriptive names to avoid conflict when inherited

    this._eventListeners = Object.create(null);
    this._notificationsQueue = [];
    this._eventsProcessing = false;
    this._sourcePodiums = [];

    if (events) {
        this.registerEvent(events, options);
    }
};


internals.Podium.decorate = function (target, source) {

    internals.Podium.call(target, null);

    Object.keys(source._eventListeners).forEach((name) => {

        target._eventListeners[name] = {
            handlers: null,
            flags: source._eventListeners[name].flags
        };
    });
};


internals.Podium.validate = function (events) {

    const normalized = [];
    [].concat(events).forEach((event) => {

        if (typeof event === 'string') {
            event = { name: event };
        }

        normalized.push(Joi.attempt(event, internals.schema.event, 'Invalid event options'));
    });

    return normalized;
};


internals.Podium.prototype.registerEvent = function (events, options = {}) {

    events = Hoek.flatten([].concat(events));
    events.forEach((event) => {

        if (!event) {
            return;
        }

        if (event instanceof internals.Podium) {
            return this.registerPodium(event);
        }

        if (typeof event === 'string') {
            event = { name: event };
        }

        if (options.validate !== false) {                                                       // Defaults to true
            event = Joi.attempt(event, internals.schema.event, 'Invalid event options');
        }

        const name = event.name;
        if (this._eventListeners[name]) {
            Hoek.assert(event.shared, `Event ${name} exists`);
            return;
        }

        this._eventListeners[name] = { handlers: null, flags: event };
        this._sourcePodiums.forEach((podium) => {

            if (!podium._eventListeners[name]) {
                podium._eventListeners[name] = { handlers: null, flags: event };
            }
        });
    });
};


internals.Podium.prototype.registerPodium = function (podiums) {

    [].concat(podiums).forEach((podium) => {

        if (podium._sourcePodiums.indexOf(this) !== -1) {
            return;
        }

        podium._sourcePodiums.push(this);
        Object.keys(podium._eventListeners).forEach((name) => {

            if (!this._eventListeners[name]) {
                this._eventListeners[name] = { handlers: null, flags: podium._eventListeners[name].flags };
            }
        });
    });
};


internals.Podium.prototype.emit = async function (criteria, data, _generated) {

    criteria = internals.criteria(criteria);

    const name = criteria.name;
    Hoek.assert(name, 'Criteria missing event name');

    const event = this._eventListeners[name];
    Hoek.assert(event, `Unknown event ${name}`);
    Hoek.assert(!criteria.channel || typeof criteria.channel === 'string', 'Invalid channel name');
    Hoek.assert(!criteria.channel || !event.flags.channels || event.flags.channels.indexOf(criteria.channel) !== -1, `Unknown ${criteria.channel} channel`);
    Hoek.assert(!event.flags.spread || Array.isArray(data) || typeof data === 'function', 'Data must be an array for spread event');

    if (!event.handlers &&
        !this._sourcePodiums.length) {

        return;
    }

    if (typeof criteria.tags === 'string') {
        criteria.tags = [criteria.tags];
    }

    if (criteria.tags &&
        Array.isArray(criteria.tags)) {

        // Map array to object

        const tags = {};
        for (const tag of criteria.tags) {
            tags[tag] = true;
        }

        criteria.tags = tags;
    }

    if (event.handlers) {
        const processing = [];

        const handlers = event.handlers.slice();                // Clone in case handlers are changed by listeners
        for (let i = 0; i < handlers.length; ++i) {
            const handler = handlers[i];

            if (handler.channels &&
                (!criteria.channel || handler.channels.indexOf(criteria.channel) === -1)) {

                continue;
            }

            if (handler.filter) {
                if (!criteria.tags) {
                    continue;
                }

                const match = Hoek.intersect(criteria.tags, handler.filter.tags, { first: !handler.filter.all });
                if (!match ||
                    (handler.filter.all && match.length !== handler.filter.tags.length)) {

                    continue;
                }
            }

            if (handler.count) {
                --handler.count;
                if (handler.count < 1) {
                    internals.removeHandler(this, criteria.name, handler);
                }
            }

            if (!_generated &&
                typeof data === 'function') {

                data = data();
                _generated = true;
            }

            const update = (internals.flag('clone', handler, event) ? Hoek.clone(data) : data);
            const args = (internals.flag('spread', handler, event) && Array.isArray(update) ? update : [update]);

            if (internals.flag('tags', handler, event) &&
                criteria.tags) {

                args.push(criteria.tags);
            }

            try {
                const result = (handler.context ? handler.listener.apply(handler.context, args) : handler.listener(...args));
                if (result &&
                    typeof result.then === 'function') {

                    processing.push(result);
                }
            }
            catch (err) {
                processing.push(Promise.reject(err));
            }
        }

        if (processing.length) {
            await Promise.all(processing);
        }
    }

    if (this._sourcePodiums.length) {
        const podiums = this._sourcePodiums.slice();         // Clone in case modified while processing
        await Promise.all(podiums.map((podium) => podium.emit(criteria, data, _generated)));
    }
};


internals.Podium.prototype.on = internals.Podium.prototype.addListener = function (criteria, listener, context) {

    criteria = internals.criteria(criteria);
    criteria.listener = listener;
    criteria.context = context;

    if (criteria.filter &&
        (typeof criteria.filter === 'string' || Array.isArray(criteria.filter))) {

        criteria.filter = { tags: criteria.filter };
    }

    criteria = Joi.attempt(criteria, internals.schema.listener, 'Invalid event listener options');

    const name = criteria.name;
    const event = this._eventListeners[name];
    Hoek.assert(event, `Unknown event ${name}`);
    Hoek.assert(!criteria.channels || !event.flags.channels || Hoek.intersect(event.flags.channels, criteria.channels).length === criteria.channels.length, `Unknown event channels ${criteria.channels && criteria.channels.join(', ')}`);

    this._eventListeners[name].handlers = this._eventListeners[name].handlers || [];
    this._eventListeners[name].handlers.push(criteria);

    return this;
};


internals.Podium.prototype.once = function (criteria, listener, context) {

    criteria = Object.assign(internals.criteria(criteria), { count: 1 });

    if (listener) {
        return this.on(criteria, listener, context);
    }

    return new Promise((resolve) => this.on(criteria, (...args) => resolve(args), context));
};


internals.Podium.prototype.removeListener = function (name, listener) {

    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);
    Hoek.assert(typeof listener === 'function', 'Listener must be a function');

    const handlers = this._eventListeners[name].handlers;
    if (!handlers) {
        return this;
    }

    const filtered = handlers.filter((handler) => handler.listener !== listener);
    this._eventListeners[name].handlers = (filtered.length ? filtered : null);
    return this;
};


internals.Podium.prototype.removeAllListeners = function (name) {

    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);
    this._eventListeners[name].handlers = null;
    return this;
};


internals.Podium.prototype.hasListeners = function (name) {

    Hoek.assert(this._eventListeners[name], `Unknown event ${name}`);
    return !!this._eventListeners[name].handlers;
};


internals.removeHandler = function (emitter, name, handler) {

    const handlers = emitter._eventListeners[name].handlers;
    const filtered = handlers.filter((item) => item !== handler);
    emitter._eventListeners[name].handlers = (filtered.length ? filtered : null);
};


internals.criteria = function (criteria) {

    return (typeof criteria === 'string' ? { name: criteria } : Hoek.clone(criteria));
};


internals.flag = function (name, handler, event) {

    return (handler[name] !== undefined ? handler[name] : event.flags[name]) || false;
};


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/shot/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");

const Request = __webpack_require__(/*! ./request */ "./node_modules/@hapi/shot/lib/request.js");
const Response = __webpack_require__(/*! ./response */ "./node_modules/@hapi/shot/lib/response.js");
const Symbols = __webpack_require__(/*! ./symbols */ "./node_modules/@hapi/shot/lib/symbols.js");


const internals = {};


internals.options = Joi.object().keys({
    url: Joi.alternatives([
        Joi.string(),
        Joi.object().keys({
            protocol: Joi.string(),
            hostname: Joi.string(),
            port: Joi.any(),
            pathname: Joi.string().required(),
            query: Joi.any()
        })
    ])
        .required(),
    headers: Joi.object(),
    payload: Joi.any(),
    simulate: {
        end: Joi.boolean(),
        split: Joi.boolean(),
        error: Joi.boolean(),
        close: Joi.boolean()
    },
    authority: Joi.string(),
    remoteAddress: Joi.string(),
    method: Joi.string(),
    validate: Joi.boolean()
});


exports.inject = function (dispatchFunc, options) {

    options = (typeof options === 'string' ? { url: options } : options);

    if (options.validate !== false) {                                                           // Defaults to true
        try {
            Hoek.assert(typeof dispatchFunc === 'function', 'Invalid dispatch function');
            Joi.assert(options, internals.options);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }

    return new Promise((resolve) => {

        const req = new Request(options);
        const res = new Response(req, resolve);

        req.prepare(() => dispatchFunc(req, res));
    });
};


exports.isInjection = function (obj) {

    return !!obj[Symbols.injection];
};


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/request.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/shot/lib/request.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");
const Url = __webpack_require__(/*! url */ "url");

const Symbols = __webpack_require__(/*! ./symbols */ "./node_modules/@hapi/shot/lib/symbols.js");


const internals = {};


exports = module.exports = internals.Request = class extends Stream.Readable {

    constructor(options) {

        super();

        // options: method, url, payload, headers, remoteAddress

        let url = options.url;
        if (typeof url === 'object') {
            url = Url.format(url);
        }

        const uri = Url.parse(url);
        this.url = uri.path;

        this.httpVersion = '1.1';
        this.method = (options.method ? options.method.toUpperCase() : 'GET');

        this.headers = {};
        const headers = options.headers || {};
        const fields = Object.keys(headers);
        fields.forEach((field) => {

            this.headers[field.toLowerCase()] = headers[field];
        });

        this.headers['user-agent'] = this.headers['user-agent'] || 'shot';

        const hostHeaderFromUri = function () {

            if (uri.port) {
                return uri.host;
            }

            if (uri.protocol) {
                return uri.hostname + (uri.protocol === 'https:' ? ':443' : ':80');
            }

            return null;
        };

        this.headers.host = this.headers.host || hostHeaderFromUri() || options.authority || 'localhost:80';

        this.connection = {
            remoteAddress: options.remoteAddress || '127.0.0.1'
        };

        let payload = options.payload || null;
        if (payload &&
            typeof payload !== 'string' &&
            !(payload instanceof Stream) &&
            !Buffer.isBuffer(payload)) {

            payload = JSON.stringify(payload);
            this.headers['content-type'] = this.headers['content-type'] || 'application/json';
        }

        // Set the content-length for the corresponding payload if none set

        if (payload &&
            !(payload instanceof Stream) &&
            !this.headers.hasOwnProperty('content-length')) {

            this.headers['content-length'] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
        }

        // Use _shot namespace to avoid collision with Node

        this._shot = {
            payload,
            isDone: false,
            simulate: options.simulate || {}
        };

        return this;
    }

    prepare(next) {

        if (this._shot.payload instanceof Stream === false) {
            return next();
        }

        const chunks = [];

        this._shot.payload.on('data', (chunk) => chunks.push(Buffer.from(chunk)));

        this._shot.payload.on('end', () => {

            const payload = Buffer.concat(chunks);
            this.headers['content-length'] = this.headers['content-length'] || payload.length;
            this._shot.payload = payload;
            return next();
        });
    }

    _read(size) {

        setImmediate(() => {

            if (this._shot.isDone) {
                /* $lab:coverage:off$ */
                if (this._shot.simulate.end !== false) {        // 'end' defaults to true
                    this.push(null);
                }
                /* $lab:coverage:on$ */

                return;
            }

            this._shot.isDone = true;

            if (this._shot.payload) {
                if (this._shot.simulate.split) {
                    this.push(this._shot.payload.slice(0, 1));
                    this.push(this._shot.payload.slice(1));
                }
                else {
                    this.push(this._shot.payload);
                }
            }

            if (this._shot.simulate.error) {
                this.emit('error', new Error('Simulated'));
            }

            if (this._shot.simulate.close) {
                this.emit('close');
            }

            if (this._shot.simulate.end !== false) {        // 'end' defaults to true
                this.push(null);
            }
        });
    }

    destroy() {

    }
};


internals.Request.prototype[Symbols.injection] = true;


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/response.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/shot/lib/response.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Http = __webpack_require__(/*! http */ "http");
const Stream = __webpack_require__(/*! stream */ "stream");

const Symbols = __webpack_require__(/*! ./symbols */ "./node_modules/@hapi/shot/lib/symbols.js");


const internals = {};


exports = module.exports = internals.Response = class extends Http.ServerResponse {

    constructor(req, onEnd) {

        super({ method: req.method, httpVersionMajor: 1, httpVersionMinor: 1 });
        this._shot = { headers: null, trailers: {}, payloadChunks: [] };
        this.assignSocket(internals.nullSocket());

        this.once('finish', () => {

            const res = internals.payload(this);
            res.raw.req = req;
            process.nextTick(() => onEnd(res));
        });
    }

    writeHead(...args) {

        // Find the headers object if one was provided. If a headers object is present, call setHeader()
        // on the first valid header, and then break out of the loop and call writeHead(). By calling
        // setHeader(), Node will materialize a headers object.

        const headers = args[args.length - 1];

        if (typeof headers === 'object' && headers !== null) {
            const headerNames = Object.keys(headers);

            for (let i = 0; i < headerNames.length; ++i) {
                const name = headerNames[i];

                try {
                    this.setHeader(name, headers[name]);
                    break;
                }
                catch (ignoreErr) {} // Let the real writeHead() handle errors.
            }
        }

        const result = super.writeHead(...args);

        this._shot.headers = this.getHeaders();

        // Add raw headers

        ['Date', 'Connection', 'Transfer-Encoding'].forEach((name) => {

            const regex = new RegExp('\\r\\n' + name + ': ([^\\r]*)\\r\\n');
            const field = this._header.match(regex);
            if (field) {
                this._shot.headers[name.toLowerCase()] = field[1];
            }
        });

        return result;
    }

    write(data, encoding, callback) {

        super.write(data, encoding, callback);
        this._shot.payloadChunks.push(Buffer.from(data, encoding));
        return true;                                                    // Write always returns false when disconnected
    }

    end(data, encoding, callback) {

        if (data) {
            this.write(data, encoding);
        }

        super.end(callback);
        this.emit('finish');
    }

    destroy() {

    }

    addTrailers(trailers) {

        for (const key in trailers) {
            this._shot.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
        }
    }
};


internals.Response.prototype[Symbols.injection] = true;


internals.payload = function (response) {

    // Prepare response object

    const res = {
        raw: {
            res: response
        },
        headers: response._shot.headers,
        statusCode: response.statusCode,
        statusMessage: response.statusMessage,
        trailers: {}
    };

    // Prepare payload and trailers

    const rawBuffer = Buffer.concat(response._shot.payloadChunks);
    res.rawPayload = rawBuffer;
    res.payload = rawBuffer.toString();
    res.trailers = response._shot.trailers;

    return res;
};


// Throws away all written data to prevent response from buffering payload

internals.nullSocket = function () {

    return new Stream.Writable({
        write(chunk, encoding, callback) {

            setImmediate(callback);
        }
    });
};


/***/ }),

/***/ "./node_modules/@hapi/shot/lib/symbols.js":
/*!************************************************!*\
  !*** ./node_modules/@hapi/shot/lib/symbols.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports.injection = Symbol('injection');


/***/ }),

/***/ "./node_modules/@hapi/somever/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/somever/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {
    maxLength: 256,
    wildcards: ['x', 'X', '*'],
    any: Symbol('any')
};

//                              1:major         2:minor         3:patch          4:prerelease  5:build
//                              A         aB    C         cD    E         eF     G     gf H    I  ih d b
internals.versionRx = /^\s*[vV]?(\d+|[xX*])(?:\.(\d+|[xX*])(?:\.(\d+|[xX*])(?:\-?([^+]+))?(?:\+(.+))?)?)?\s*$/;

internals.strict = {
    tokenRx: /^[-\dA-Za-z]+(?:\.[-\dA-Za-z]+)*$/,
    numberRx: /^((?:0)|(?:[1-9]\d*))$/
};


exports.version = function (version, options) {

    return new internals.Version(version, options);
};


exports.range = function (range) {

    return new internals.Range(range);
};


exports.match = function (version, range) {

    try {
        return exports.range(range).match(version);
    }
    catch (err) {
        Bounce.rethrow(err, 'system');
        return false;
    }
};


internals.Version = class {

    constructor(version, options = {}) {

        Hoek.assert(version, 'Missing version argument');

        if (version instanceof internals.Version) {
            return version;
        }

        if (typeof version === 'object') {
            this._copy(version);
        }
        else {
            this._parse(version, options);
        }

        this.format();
    }

    _copy(version) {

        this.major = version.major === undefined ? internals.any : version.major;
        this.minor = version.minor === undefined ? internals.any : version.minor;
        this.patch = version.patch === undefined ? internals.any : version.patch;
        this.prerelease = version.prerelease || [];
        this.build = version.build || [];
    }

    _parse(version, options) {

        Hoek.assert(typeof version === 'string', 'Version argument must be a string');
        Hoek.assert(version.length <= internals.maxLength, 'Version string too long');

        const match = version.match(internals.versionRx);
        if (!match) {
            throw new Error(`Invalid version string format: ${version}`);
        }

        this.major = internals.Version._number(match[1], 'major', options);
        this.minor = internals.Version._number(match[2] || 'x', 'minor', options);
        this.patch = internals.Version._number(match[3] || 'x', 'patch', options);

        this.prerelease = internals.Version._sub(match[4], 'prerelease', options);
        this.build = internals.Version._sub(match[5], 'build', options);
    }

    static _number(string, source, options) {

        if (internals.wildcards.includes(string)) {
            return internals.any;
        }

        if (options.strict) {
            Hoek.assert(string.match(internals.strict.numberRx), 'Value must be 0 or a number without a leading zero:', source);
        }

        const value = parseInt(string, 10);
        Hoek.assert(value <= Number.MAX_SAFE_INTEGER, 'Value must be positive and less than max safe integer:', source);
        return value;
    }

    static _sub(string, source, options) {

        if (!string) {
            return [];
        }

        if (options.strict) {
            Hoek.assert(string.match(internals.strict.tokenRx), 'Value can only contain dot-separated hyphens, digits, a-z or A-Z:', source);
        }

        const subs = [];
        const parts = string.split('.');
        for (const part of parts) {
            if (!part) {
                throw new Error(`Invalid empty ${source} segment`);
            }

            subs.push(part.match(/^\d+$/) ? internals.Version._number(part, source, { strict: options.strict }) : part);
        }

        return subs;
    }

    format() {

        this.version = `${internals.dot(this.major)}.${internals.dot(this.minor)}.${internals.dot(this.patch)}${internals.token(this.prerelease, '-')}${internals.token(this.build, '+')}`;
        this.dots = [this.major, this.minor, this.patch];
        this.wildcard = this.major === internals.any && this.minor === internals.any && this.patch === internals.any && !this.prerelease.length;
    }

    toString() {

        return this.version;
    }

    compare(to, options) {

        return internals.Version.compare(this, to, options);
    }

    static compare(a, b, options = {}) {

        let aFirst = -1;
        let bFirst = 1;

        a = exports.version(a, options);
        b = exports.version(b, options);

        // Mark incompatible prereleases

        if (options.range &&
            a.prerelease.length &&
            (a.major !== b.major || a.minor !== b.minor || a.patch !== b.patch || !b.prerelease.length)) {

            aFirst = -2;
            bFirst = 2;
        }

        // Compare versions

        for (let i = 0; i < 3; ++i) {
            const av = a.dots[i];
            const bv = b.dots[i];

            if (av === bv ||
                av === internals.any ||                             // Wildcard is equal to everything
                bv === internals.any) {

                continue;
            }

            return av - bv < 0 ? aFirst : bFirst;
        }

        // Compare prerelease

        if (!a.prerelease.length &&
            !b.prerelease.length) {

            return 0;
        }

        if (!!a.prerelease.length !== !!b.prerelease.length) {
            return (a.prerelease.length ? aFirst : bFirst);         // prerelease < none
        }

        for (let i = 0; ; ++i) {
            const ai = a.prerelease[i];
            const bi = b.prerelease[i];

            if (ai === undefined &&
                bi === undefined) {

                return 0;
            }

            if (ai === bi) {
                continue;
            }

            if (ai === undefined) {
                return aFirst;
            }

            if (bi === undefined) {
                return bFirst;
            }

            const an = Number.isFinite(ai);
            const bn = Number.isFinite(bi);

            if (an !== bn) {
                return an ? aFirst : bFirst;
            }

            return (a < b ? aFirst : bFirst);
        }
    }
};


internals.dot = (v) => {

    return (v === internals.any ? 'x' : v);
};


internals.token = (v, prefix) => {

    if (!v.length) {
        return '';
    }

    return `${prefix}${v.join('.')}`;
};


internals.Range = class {

    constructor(range, options) {

        this._settings = Object.assign({}, options);    // Shallow cloned
        this._anything = false;
        this._or = [];                                  // [and, and, ..., active]
        this._active = null;

        if (range !== undefined) {
            this.pattern(range);
        }

        this._another();
    }

    _another() {

        if (!this._active ||
            this._active.rules.length) {

            this._active = { rules: [] };
            this._or.push(this._active);
        }

        return this;
    }

    _rule(operator, version) {

        version = exports.version(version, this._settings);

        const compare = internals.operator(operator);
        this._active.rules.push({ compare, version, operator });

        return this;
    }

    get or() {

        return this._another();
    }

    equal(version) {

        return this._rule('=', version);
    }

    above(version) {

        return this._rule('>', version);
    }

    below(version) {

        return this._rule('<', version);
    }

    between(from, to) {

        this._rule('>=', from);
        this._rule('<=', to);
        return this;
    }

    minor(version) {        // ~1.2.3

        // minor(2.5.7)     ->      2.5.7 <= X < 2.6.0
        // minor(2.5.x)     ->      2.5.0 <= X < 2.6.0
        // minor(2.x.x)     ->      2.0.0 <= X < 3.0.0

        version = exports.version(version, this._settings);

        if (version.major === internals.any) {
            this._rule('=', version);
            return this;
        }

        this._rule('>=', version);

        if (version.minor === internals.any) {
            this._rule('<', { major: version.major + 1, minor: 0, patch: 0 });
        }
        else {
            this._rule('<', { major: version.major, minor: version.minor + 1, patch: 0 });
        }

        return this;
    }

    compatible(version) {       // ^1.2.3

        // compatible(2.5.7)     ->      2.5.7 <= X < 3.0.0
        // compatible(2.x.x)     ->      2.0.0 <= X < 3.0.0
        // compatible(0.1.x)     ->      0.1.0 <= X < 0.2.0

        version = exports.version(version, this._settings);

        if (version.major === internals.any) {
            this._rule('=', version);
            return this;
        }

        this._rule('>=', version);

        if (version.major === 0 &&
            version.minor !== internals.any) {

            if (version.minor === 0) {
                this._rule('<', { major: 0, minor: 0, patch: version.patch + 1 });
            }
            else {
                this._rule('<', { major: 0, minor: version.minor + 1, patch: 0 });
            }
        }
        else {
            this._rule('<', { major: version.major + 1, minor: 0, patch: 0 });
        }

        return this;
    }

    pattern(range) {

        try {
            this._pattern(range);
            return this;
        }
        catch (err) {
            throw new Error(`Invalid range: "${range}" because: ${err.message}`);
        }
    }

    _pattern(range) {

        if (range === '') {
            this._anything = true;
            return;
        }

        const normalized = internals.normalize(range);
        const ors = normalized.split(/\s*\|\|\s*/);
        for (const condition of ors) {
            if (!condition) {
                this._anything = true;
                return;
            }

            this._another();

            const ands = condition.split(/\s+/);
            for (const and of ands) {

                // Hyphen range

                const hyphen = and.indexOf('@');            // Originally " - "
                if (hyphen !== -1) {
                    const from = and.slice(0, hyphen);
                    const to = and.slice(hyphen + 1);
                    this.between(from, to);
                    continue;
                }

                // Prefix

                const parts = and.match(/^(\^|~|<\=|>\=|<|>|\=)?(.+)$/);
                const operator = parts[1];
                const version = exports.version(parts[2], this._settings);

                if (version.wildcard) {
                    this._anything = true;
                    return;
                }

                // Tilde

                if (operator === '~') {
                    this.minor(version);
                    continue;
                }

                // Caret

                if (operator === '^') {
                    this.compatible(version);
                    continue;
                }

                // One sided range

                if (operator) {
                    this._rule(operator, version);
                    continue;
                }

                // Version

                this.equal(version);
            }
        }
    }

    match(version) {

        version = exports.version(version, this._settings);       // Always parse to validate

        if (this._anything) {
            return !version.prerelease.length;
        }

        for (const { rules } of this._or) {
            if (!rules.length) {
                continue;
            }

            let matches = 0;
            let excludes = 0;

            for (const rule of rules) {
                const compare = version.compare(rule.version, Object.assign(this._settings, { range: true }));
                const exclude = Math.abs(compare) === 2;

                if (rule.compare.includes(compare / (exclude ? 2 : 1))) {
                    ++matches;
                    if (exclude) {
                        ++excludes;
                    }
                }
                else {
                    break;
                }
            }

            if (matches === rules.length &&
                excludes < matches) {

                return true;
            }
        }

        return false;
    }

    toString() {

        if (this._anything) {
            return '*';
        }

        let string = '';
        for (const { rules } of this._or) {
            if (!rules.length) {
                continue;
            }

            const conditions = [];
            for (const rule of rules) {
                conditions.push(`${rule.operator !== '=' ? rule.operator : ''}${rule.version.version}`);
            }

            string += (string ? '||' : '') + conditions.join(' ');
        }

        return string;
    }
};


internals.operator = function (compare) {

    switch (compare) {
        case '=': return [0];
        case '>': return [1];
        case '>=': return [0, 1];
        case '<': return [-1];
        case '<=': return [0, -1];
    }
};


internals.normalize = function (range) {

    return range
        .replace(/ \- /g, '@')                                                          // Range to excluded symbol
        .replace(/~>/g, '~')                                                            // Legacy npm operator
        .replace(/(\^|~|<\=|>\=|<|>|\=)\s*([^\s]+)/g, ($0, $1, $2) => `${$1}${$2}`);    // Space between operator and version
};


/***/ }),

/***/ "./node_modules/@hapi/statehood/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@hapi/statehood/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Querystring = __webpack_require__(/*! querystring */ "querystring");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bounce = __webpack_require__(/*! @hapi/bounce */ "./node_modules/@hapi/bounce/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Cryptiles = __webpack_require__(/*! @hapi/cryptiles */ "./node_modules/@hapi/cryptiles/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Iron = __webpack_require__(/*! @hapi/iron */ "./node_modules/@hapi/iron/lib/index.js");
const Joi = __webpack_require__(/*! @hapi/joi */ "./node_modules/@hapi/joi/lib/index.js");


const internals = {};


internals.schema = Joi.object({
    strictHeader: Joi.boolean(),
    ignoreErrors: Joi.boolean(),
    isSecure: Joi.boolean(),
    isHttpOnly: Joi.boolean(),
    isSameSite: Joi.valid('Strict', 'Lax').allow(false),
    path: Joi.string().allow(null),
    domain: Joi.string().allow(null),
    ttl: Joi.number().allow(null),
    encoding: Joi.string().valid('base64json', 'base64', 'form', 'iron', 'none'),
    sign: Joi.object({
        password: [Joi.string(), Joi.binary(), Joi.object()],
        integrity: Joi.object()
    }),
    iron: Joi.object(),
    password: [Joi.string(), Joi.binary(), Joi.object()],

    // Used by hapi

    clearInvalid: Joi.boolean(),
    autoValue: Joi.any(),
    passThrough: Joi.boolean()
});


internals.defaults = {
    strictHeader: true,                             // Require an RFC 6265 compliant header format
    ignoreErrors: false,
    isSecure: true,
    isHttpOnly: true,
    isSameSite: 'Strict',
    path: null,
    domain: null,
    ttl: null,                                      // MSecs, 0 means remove
    encoding: 'none'                                // options: 'base64json', 'base64', 'form', 'iron', 'none'
};


exports.Definitions = internals.Definitions = function (options) {

    this.settings = Hoek.applyToDefaults(internals.defaults, options || {});
    Joi.assert(this.settings, internals.schema, 'Invalid state definition defaults');

    this.cookies = {};
    this.names = [];
};


internals.Definitions.prototype.add = function (name, options) {

    Hoek.assert(name && typeof name === 'string', 'Invalid name');
    Hoek.assert(!this.cookies[name], 'State already defined:', name);

    const settings = Hoek.applyToDefaults(this.settings, options || {}, { nullOverride: true });
    Joi.assert(settings, internals.schema, 'Invalid state definition: ' + name);

    this.cookies[name] = settings;
    this.names.push(name);
};


internals.empty = new internals.Definitions();


// Header format

//                      1: name                2: quoted  3: value
internals.parseRx = /\s*([^=\s]*)\s*=\s*(?:(?:"([^\"]*)")|([^\;]*))(?:(?:;\s*)|$)/g;

internals.validateRx = {
    nameRx: {
        strict: /^[^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+$/,
        loose: /^[^=\s]*$/
    },
    valueRx: {
        strict: /^[^\x00-\x20\"\,\;\\\x7F]*$/,
        loose: /^(?:"([^\"]*)")|(?:[^\;]*)$/
    },
    domainRx: /^\.?[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d]))(?:\.[a-z\d]+(?:(?:[a-z\d]*)|(?:[a-z\d\-]*[a-z\d])))*$/,
    domainLabelLenRx: /^\.?[a-z\d\-]{1,63}(?:\.[a-z\d\-]{1,63})*$/,
    pathRx: /^\/[^\x00-\x1F\;]*$/
};

//                      1: name         2: value
internals.pairsRx = /\s*([^=\s]*)\s*=\s*([^\;]*)(?:(?:;\s*)|$)/g;


internals.Definitions.prototype.parse = async function (cookies) {

    const state = {};
    const names = [];
    const verify = cookies.replace(internals.parseRx, ($0, $1, $2, $3) => {

        const name = $1;
        const value = $2 || $3 || '';

        if (state[name]) {
            if (!Array.isArray(state[name])) {
                state[name] = [state[name]];
            }

            state[name].push(value);
        }
        else {
            state[name] = value;
            names.push(name);
        }

        return '';
    });

    // Validate cookie header syntax

    const failed = [];                                                // All errors

    if (verify !== '') {
        if (!this.settings.ignoreErrors) {
            throw Boom.badRequest('Invalid cookie header');
        }

        failed.push({ settings: this.settings, reason: `Header contains unexpected syntax: ${verify}` });
    }

    // Collect errors

    const errored = [];                                               // Unignored errors
    const record = (reason, name, value, definition) => {

        const details = {
            name,
            value,
            settings: definition,
            reason: typeof reason === 'string' ? reason : reason.message
        };

        failed.push(details);
        if (!definition.ignoreErrors) {
            errored.push(details);
        }
    };

    // Parse cookies

    const parsed = {};
    for (let i = 0; i < names.length; ++i) {
        const name = names[i];
        const value = state[name];
        const definition = this.cookies[name] || this.settings;

        // Validate cookie

        if (definition.strictHeader) {
            const reason = internals.validate(name, state);
            if (reason) {
                record(reason, name, value, definition);
                continue;
            }
        }

        // Check cookie format

        if (definition.encoding === 'none') {
            parsed[name] = value;
            continue;
        }

        // Single value

        if (!Array.isArray(value)) {
            try {
                const unsigned = await internals.unsign(name, value, definition);
                const result = await internals.decode(unsigned, definition);
                parsed[name] = result;
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                record(err, name, value, definition);
            }

            continue;
        }

        // Array

        const arrayResult = [];
        for (let j = 0; j < value.length; ++j) {
            const arrayValue = value[j];

            try {
                const unsigned = await internals.unsign(name, arrayValue, definition);
                const result = await internals.decode(unsigned, definition);
                arrayResult.push(result);
            }
            catch (err) {
                Bounce.rethrow(err, 'system');
                record(err, name, value, definition);
            }
        }

        parsed[name] = arrayResult;
    }

    if (errored.length) {
        const error = Boom.badRequest('Invalid cookie value', errored);
        error.states = parsed;
        error.failed = failed;
        throw error;
    }

    return { states: parsed, failed };
};


internals.validate = function (name, state) {

    if (!name.match(internals.validateRx.nameRx.strict)) {
        return 'Invalid cookie name';
    }

    const values = [].concat(state[name]);
    for (let i = 0; i < values.length; ++i) {
        if (!values[i].match(internals.validateRx.valueRx.strict)) {
            return 'Invalid cookie value';
        }
    }

    return null;
};


internals.macPrefix = 'hapi.signed.cookie.1';


internals.unsign = async function (name, value, definition) {

    if (!definition.sign) {
        return value;
    }

    const pos = value.lastIndexOf('.');
    if (pos === -1) {
        throw Boom.badRequest('Missing signature separator');
    }

    const unsigned = value.slice(0, pos);
    const sig = value.slice(pos + 1);

    if (!sig) {
        throw Boom.badRequest('Missing signature');
    }

    const sigParts = sig.split('*');
    if (sigParts.length !== 2) {
        throw Boom.badRequest('Invalid signature format');
    }

    const hmacSalt = sigParts[0];
    const hmac = sigParts[1];

    const macOptions = Hoek.clone(definition.sign.integrity || Iron.defaults.integrity);
    macOptions.salt = hmacSalt;
    const mac = await Iron.hmacWithPassword(definition.sign.password, macOptions, [internals.macPrefix, name, unsigned].join('\n'));
    if (!Cryptiles.fixedTimeComparison(mac.digest, hmac)) {
        throw Boom.badRequest('Invalid hmac value');
    }

    return unsigned;
};


internals.decode = async function (value, definition) {

    if (!value &&
        definition.encoding === 'form') {

        return {};
    }

    Hoek.assert(typeof value === 'string', 'Invalid string');

    // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'

    if (definition.encoding === 'iron') {
        return await Iron.unseal(value, definition.password, definition.iron || Iron.defaults);
    }

    if (definition.encoding === 'base64json') {
        const decoded = (Buffer.from(value, 'base64')).toString('binary');
        try {
            return Bourne.parse(decoded);
        }
        catch (err) {
            throw Boom.badRequest('Invalid JSON payload');
        }
    }

    if (definition.encoding === 'base64') {
        return (Buffer.from(value, 'base64')).toString('binary');
    }

    // encoding: 'form'

    return Querystring.parse(value);
};


internals.Definitions.prototype.format = async function (cookies) {

    if (!cookies ||
        (Array.isArray(cookies) && !cookies.length)) {

        return [];
    }

    if (!Array.isArray(cookies)) {
        cookies = [cookies];
    }

    const header = [];
    for (let i = 0; i < cookies.length; ++i) {
        const cookie = cookies[i];

        // Apply definition to local configuration

        const base = this.cookies[cookie.name] || this.settings;
        const definition = cookie.options ? Hoek.applyToDefaults(base, cookie.options, { nullOverride: true }) : base;

        // Validate name

        const nameRx = (definition.strictHeader ? internals.validateRx.nameRx.strict : internals.validateRx.nameRx.loose);
        if (!nameRx.test(cookie.name)) {
            throw Boom.badImplementation('Invalid cookie name: ' + cookie.name);
        }

        // Prepare value (encode, sign)

        const value = await exports.prepareValue(cookie.name, cookie.value, definition);

        // Validate prepared value

        const valueRx = (definition.strictHeader ? internals.validateRx.valueRx.strict : internals.validateRx.valueRx.loose);
        if (value &&
            (typeof value !== 'string' || !value.match(valueRx))) {

            throw Boom.badImplementation('Invalid cookie value: ' + cookie.value);
        }

        // Construct cookie

        let segment = cookie.name + '=' + (value || '');

        if (definition.ttl !== null &&
            definition.ttl !== undefined) {            // Can be zero

            const expires = new Date(definition.ttl ? Date.now() + definition.ttl : 0);
            segment = segment + '; Max-Age=' + Math.floor(definition.ttl / 1000) + '; Expires=' + expires.toUTCString();
        }

        if (definition.isSecure) {
            segment = segment + '; Secure';
        }

        if (definition.isHttpOnly) {
            segment = segment + '; HttpOnly';
        }

        if (definition.isSameSite) {
            segment = segment + `; SameSite=${definition.isSameSite}`;
        }

        if (definition.domain) {
            const domain = definition.domain.toLowerCase();
            if (!domain.match(internals.validateRx.domainLabelLenRx)) {
                throw Boom.badImplementation('Cookie domain too long: ' + definition.domain);
            }

            if (!domain.match(internals.validateRx.domainRx)) {
                throw Boom.badImplementation('Invalid cookie domain: ' + definition.domain);
            }

            segment = segment + '; Domain=' + domain;
        }

        if (definition.path) {
            if (!definition.path.match(internals.validateRx.pathRx)) {
                throw Boom.badImplementation('Invalid cookie path: ' + definition.path);
            }

            segment = segment + '; Path=' + definition.path;
        }

        header.push(segment);
    }

    return header;
};


exports.prepareValue = async function (name, value, options) {

    Hoek.assert(options && typeof options === 'object', 'Missing or invalid options');

    try {
        const encoded = await internals.encode(value, options);
        const signed = await internals.sign(name, encoded, options.sign);
        return signed;
    }
    catch (err) {
        throw Boom.badImplementation('Failed to encode cookie (' + name + ') value: ' + err.message);
    }
};


internals.encode = function (value, options) {

    // Encodings: 'base64json', 'base64', 'form', 'iron', 'none'

    if (value === undefined ||
        options.encoding === 'none') {

        return value;
    }

    if (options.encoding === 'iron') {
        return Iron.seal(value, options.password, options.iron || Iron.defaults);
    }

    if (options.encoding === 'base64') {
        return (Buffer.from(value, 'binary')).toString('base64');
    }

    if (options.encoding === 'base64json') {
        const stringified = JSON.stringify(value);
        return (Buffer.from(stringified, 'binary')).toString('base64');
    }

    // encoding: 'form'

    return Querystring.stringify(value);
};


internals.sign = async function (name, value, options) {

    if (value === undefined ||
        !options) {

        return value;
    }

    const mac = await Iron.hmacWithPassword(options.password, options.integrity || Iron.defaults.integrity, [internals.macPrefix, name, value].join('\n'));
    const signed = value + '.' + mac.salt + '*' + mac.digest;
    return signed;
};


internals.Definitions.prototype.passThrough = function (header, fallback) {

    if (!this.names.length) {
        return header;
    }

    const exclude = [];
    for (let i = 0; i < this.names.length; ++i) {
        const name = this.names[i];
        const definition = this.cookies[name];
        const passCookie = definition.passThrough !== undefined ? definition.passThrough : fallback;
        if (!passCookie) {
            exclude.push(name);
        }
    }

    return exports.exclude(header, exclude);
};


exports.exclude = function (cookies, excludes) {

    let result = '';
    const verify = cookies.replace(internals.pairsRx, ($0, $1, $2) => {

        if (excludes.indexOf($1) === -1) {
            result = result + (result ? ';' : '') + $1 + '=' + $2;
        }

        return '';
    });

    return verify === '' ? result : Boom.badRequest('Invalid cookie header');
};


/***/ }),

/***/ "./node_modules/@hapi/subtext/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/subtext/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Fs = __webpack_require__(/*! fs */ "fs");
const Os = __webpack_require__(/*! os */ "os");
const Querystring = __webpack_require__(/*! querystring */ "querystring");
const Stream = __webpack_require__(/*! stream */ "stream");
const Zlib = __webpack_require__(/*! zlib */ "zlib");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Content = __webpack_require__(/*! @hapi/content */ "./node_modules/@hapi/content/lib/index.js");
const File = __webpack_require__(/*! @hapi/file */ "./node_modules/@hapi/file/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");
const Pez = __webpack_require__(/*! @hapi/pez */ "./node_modules/@hapi/pez/lib/index.js");
const Wreck = __webpack_require__(/*! @hapi/wreck */ "./node_modules/@hapi/wreck/lib/index.js");


const internals = {
    decoders: {
        gzip: (options) => Zlib.createGunzip(options),
        deflate: (options) => Zlib.createInflate(options)
    }
};


exports.parse = async function (req, tap, options) {

    Hoek.assert(options, 'Missing options');
    Hoek.assert(options.parse !== undefined, 'Missing parse option setting');
    Hoek.assert(options.output !== undefined, 'Missing output option setting');

    // Content size

    const contentLength = req.headers['content-length'];
    if (options.maxBytes !== undefined &&
        contentLength &&
        parseInt(contentLength, 10) > options.maxBytes) {

        throw Boom.entityTooLarge('Payload content length greater than maximum allowed: ' + options.maxBytes);
    }

    // Content type

    const contentType = Content.type(options.override || req.headers['content-type'] || options.defaultContentType || 'application/octet-stream');
    try {
        if (options.allow &&
            options.allow.indexOf(contentType.mime) === -1) {

            throw Boom.unsupportedMediaType();
        }

        const parsed = { mime: contentType.mime };

        // Parse: true

        if (options.parse === true) {
            parsed.payload = await internals.parse(req, tap, options, contentType);
            return parsed;
        }

        // Parse: false, 'gunzip'

        parsed.payload = await internals.raw(req, tap, options);
        return parsed;
    }
    catch (err) {
        err.mime = contentType.mime;
        throw err;
    }
};


internals.parse = async function (req, tap, options, contentType) {

    const output = options.output;        // Output: 'data', 'stream', 'file'
    let source = internals.decoder(req, options);

    // Tap request

    if (tap) {
        source = internals.pipe(source, tap);
    }

    // Multipart

    if (contentType.mime === 'multipart/form-data') {
        if (options.multipart === false) {                            // Defaults to true
            throw Boom.unsupportedMediaType();
        }

        return await internals.multipart(req, options, source, contentType);
    }

    // Output: 'stream'

    if (output === 'stream') {
        return source;
    }

    // Output: 'file'

    if (output === 'file') {
        const file = await internals.writeFile(req, options, source);
        return file.item;
    }

    // Output: 'data'

    const payload = await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
    return internals.object(options, payload, contentType.mime);
};


internals.decoder = function (source, options) {

    const contentEncoding = source.headers['content-encoding'];
    const decoder = (options.decoders || internals.decoders)[contentEncoding];
    if (!decoder) {
        return source;
    }

    const decoderOptions = (options.compression && options.compression[contentEncoding]) || null;
    const stream = decoder(decoderOptions);

    const orig = stream.emit;
    stream.emit = (event, ...args) => {

        if (event === 'error') {
            args = [Boom.badRequest('Invalid compressed payload', args[0])];
        }

        return orig.call(stream, event, ...args);
    };

    return internals.pipe(source, stream);
};


internals.raw = async function (req, tap, options) {

    const output = options.output;      // Output: 'data', 'stream', 'file'
    let source = req;

    // Content-encoding (optional)

    if (options.parse === 'gunzip') {
        source = internals.decoder(source, options);
    }

    // Setup source

    if (tap) {
        source = internals.pipe(source, tap);
    }

    // Output: 'stream'

    if (output === 'stream') {
        return source;
    }

    // Output: 'file'

    if (output === 'file') {
        const file = await internals.writeFile(req, options, source);
        return file.item;
    }

    // Output: 'data'

    return await Wreck.read(source, { timeout: options.timeout, maxBytes: options.maxBytes });
};


internals.object = function (options, payload, mime) {

    // Binary

    if (mime === 'application/octet-stream') {
        return (payload.length ? payload : null);
    }

    // Text

    if (mime.match(/^text\/.+$/)) {
        return payload.toString('utf8');
    }

    // JSON

    if (/^application\/(?:.+\+)?json$/.test(mime)) {
        if (!payload.length) {
            return null;
        }

        try {
            return Bourne.parse(payload.toString('utf8'), { protoAction: options.protoAction });
        }
        catch (err) {
            const error = Boom.badRequest('Invalid request payload JSON format', err);
            error.raw = payload;
            throw error;
        }
    }

    // Form-encoded

    if (mime === 'application/x-www-form-urlencoded') {
        const parse = (options.querystring || Querystring.parse);
        return (payload.length ? parse(payload.toString('utf8')) : {});
    }

    const error = Boom.unsupportedMediaType();
    error.raw = payload;
    throw error;
};


internals.multipart = function (req, options, source, contentType) {

    return new Promise((resolve, reject) => {

        // Set stream timeout

        const clientTimeout = options.timeout;
        const clientTimeoutId = (clientTimeout ? setTimeout(() => reject(Boom.clientTimeout()), clientTimeout) : null);

        // Create parser

        const dispenserOptions = Hoek.applyToDefaults(contentType, { maxBytes: options.maxBytes });
        const dispenser = new Pez.Dispenser(dispenserOptions);

        const onError = (err) => reject(Boom.badRequest('Invalid multipart payload format', err));
        dispenser.once('error', onError);

        const data = {};
        const pendingFiles = [];

        const set = (name, value) => {

            if (!data.hasOwnProperty(name)) {
                data[name] = value;
            }
            else if (Array.isArray(data[name])) {
                data[name].push(value);
            }
            else {
                data[name] = [data[name], value];
            }
        };

        const finalize = async () => {

            // Clean up

            clearTimeout(clientTimeoutId);
            dispenser.removeListener('error', onError);
            dispenser.removeListener('part', onPart);
            dispenser.removeListener('field', onField);
            dispenser.removeListener('close', onClose);

            // Wait for files

            try {
                const files = await Promise.all(pendingFiles);
                for (const { item, name } of files) {
                    set(name, item);
                }
            }
            catch (err) {
                reject(err);
                return;
            }

            resolve(data);
        };

        const output = (options.multipart ? options.multipart.output : options.output);

        const onPart = (part) => {

            if (output === 'file') {                                                                // Output: 'file'
                pendingFiles.push(internals.writeFile(req, options, part));
            }
            else {
                internals.part(part, output, set, options);                                         // Output: 'data' / 'stream'
            }
        };

        dispenser.on('part', onPart);

        const onField = (name, value) => set(name, value);
        dispenser.on('field', onField);

        const onClose = () => finalize();
        dispenser.once('close', onClose);

        source.pipe(dispenser);
    });
};


internals.writeFile = function (req, options, stream) {

    const promise = new Promise((resolve, reject) => {

        const path = File.uniqueFilename(options.uploads || Os.tmpdir());
        const file = Fs.createWriteStream(path, { flags: 'wx' });
        const counter = new internals.Counter(options);

        const finalize = (err) => {

            req.removeListener('aborted', onAbort);
            file.removeListener('close', finalize);
            file.removeListener('error', finalize);

            if (err) {
                stream.unpipe(counter);
                counter.unpipe(file);

                file.destroy();
                Fs.unlink(path, (/* fsErr */) => reject(err));      // Ignore unlink errors
                return;
            }

            const result = {
                item: {
                    path,
                    bytes: counter.bytes
                }
            };

            if (stream.name) {                                      // Multipart
                result.name = stream.name;
                result.item.filename = stream.filename;
                result.item.headers = stream.headers;
            }

            resolve(result);
        };

        file.once('close', finalize);
        file.once('error', finalize);

        const onAbort = () => finalize(Boom.badRequest('Client connection aborted'));
        req.once('aborted', onAbort);

        internals.pipe(stream, counter);
        internals.pipe(counter, file);
    });

    promise.catch(Hoek.ignore);     // Prevent triggering node's PromiseRejectionHandledWarning
    return promise;
};


internals.part = async function (part, output, set, options) {

    const payload = await Wreck.read(part);             // Error handled by dispenser.once('error')

    if (output === 'stream') {                          // Output: 'stream'
        const item = Wreck.toReadableStream(payload);
        item.hapi = {
            filename: part.filename,
            headers: part.headers
        };

        return set(part.name, item);
    }

    const ct = part.headers['content-type'] || '';      // Output: 'data'
    const mime = ct.split(';')[0].trim().toLowerCase();
    const annotate = (value) => set(part.name, output === 'annotated' ? { filename: part.filename, headers: part.headers, payload: value } : value);

    if (!mime) {
        return annotate(payload);
    }

    if (!payload.length) {
        return annotate({});
    }

    try {
        const object = internals.object(options, payload, mime);
        annotate(object);
    }
    catch (err) {
        annotate(payload);
    }
};


internals.pipe = function (from, to) {

    from.once('error', (err) => {

        from.unpipe(to);
        to.emit('error', err);
    });

    return from.pipe(to);
};


internals.Counter = class extends Stream.Transform {

    constructor(options) {

        super();
        this.bytes = 0;
        this._maxBytes = options.maxBytes;
    }

    _transform(chunk, encoding, next) {

        this.bytes = this.bytes + chunk.length;

        if (this._maxBytes !== undefined &&
            this.bytes > this._maxBytes) {

            return next(Boom.entityTooLarge('Payload content length greater than maximum allowed: ' + this._maxBytes));
        }

        return next(null, chunk);
    }
};


/***/ }),

/***/ "./node_modules/@hapi/teamwork/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/teamwork/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const internals = {};


exports = module.exports = internals.Team = class {

    constructor(options) {

        this._init(options);
    }

    _init(options = {}) {

        this.work = new Promise((resolve, reject) => {

            this._resolve = resolve;
            this._reject = reject;
        });

        const meetings = options.meetings || 1;
        this._meetings = meetings;
        this._count = meetings;
        this._notes = [];
    }

    attend(note) {

        if (note instanceof Error) {
            return this._reject(note);
        }

        this._notes.push(note);

        if (--this._count) {
            return;
        }

        return this._resolve(this._meetings === 1 ? this._notes[0] : this._notes);
    }

    async regroup(options) {

        await this.work;

        this._init(options);
    }
};


Object.defineProperties(internals.Team, {
    __esModule: {
        value: true
    },
    default: {
        value: internals.Team
    },
    Teamwork: {
        value: internals.Team
    }
});


/***/ }),

/***/ "./node_modules/@hapi/topo/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/topo/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Assert = __webpack_require__(/*! @hapi/hoek/lib/assert */ "./node_modules/@hapi/hoek/lib/assert.js");


const internals = {};


module.exports = class Topo {

    constructor() {

        this._items = [];
        this.nodes = [];
    }

    add(nodes, options) {

        options = options || {};

        // Validate rules

        const before = [].concat(options.before || []);
        const after = [].concat(options.after || []);
        const group = options.group || '?';
        const sort = options.sort || 0;                   // Used for merging only

        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);
        Assert(!before.includes('?'), 'Item cannot come before unassociated items');
        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);
        Assert(!after.includes('?'), 'Item cannot come after unassociated items');

        if (!Array.isArray(nodes)) {
            nodes = [nodes];
        }

        for (const node of nodes) {
            const item = {
                seq: this._items.length,
                sort,
                before,
                after,
                group,
                node
            };

            this._items.push(item);
        }

        // Insert event

        const valid = this._sort();
        Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');

        return this.nodes;
    }

    merge(others) {

        if (!Array.isArray(others)) {
            others = [others];
        }

        for (const other of others) {
            if (other) {
                for (const item of other._items) {
                    this._items.push(Object.assign({}, item));      // Shallow cloned
                }
            }
        }

        // Sort items

        this._items.sort(internals.mergeSort);
        for (let i = 0; i < this._items.length; ++i) {
            this._items[i].seq = i;
        }

        const valid = this._sort();
        Assert(valid, 'merge created a dependencies error');

        return this.nodes;
    }

    _sort() {

        // Construct graph

        const graph = {};
        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives
        const groups = Object.create(null);

        for (const item of this._items) {
            const seq = item.seq;                           // Unique across all items
            const group = item.group;

            // Determine Groups

            groups[group] = groups[group] || [];
            groups[group].push(seq);

            // Build intermediary graph using 'before'

            graph[seq] = item.before;

            // Build second intermediary graph with 'after'

            for (const after of item.after) {
                graphAfters[after] = graphAfters[after] || [];
                graphAfters[after].push(seq);
            }
        }

        // Expand intermediary graph

        for (const node in graph) {
            const expandedGroups = [];

            for (const graphNodeItem in graph[node]) {
                const group = graph[node][graphNodeItem];
                groups[group] = groups[group] || [];
                expandedGroups.push(...groups[group]);
            }

            graph[node] = expandedGroups;
        }

        // Merge intermediary graph using graphAfters into final graph

        for (const group in graphAfters) {
            if (groups[group]) {
                for (const node of groups[group]) {
                    graph[node].push(...graphAfters[group]);
                }
            }
        }

        // Compile ancestors

        const ancestors = {};
        for (const node in graph) {
            const children = graph[node];
            for (const child of children) {
                ancestors[child] = ancestors[child] || [];
                ancestors[child].push(node);
            }
        }

        // Topo sort

        const visited = {};
        const sorted = [];

        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order
            let next = i;

            if (ancestors[i]) {
                next = null;
                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values
                    if (visited[j] === true) {
                        continue;
                    }

                    if (!ancestors[j]) {
                        ancestors[j] = [];
                    }

                    const shouldSeeCount = ancestors[j].length;
                    let seenCount = 0;
                    for (let k = 0; k < shouldSeeCount; ++k) {
                        if (visited[ancestors[j][k]]) {
                            ++seenCount;
                        }
                    }

                    if (seenCount === shouldSeeCount) {
                        next = j;
                        break;
                    }
                }
            }

            if (next !== null) {
                visited[next] = true;
                sorted.push(next);
            }
        }

        if (sorted.length !== this._items.length) {
            return false;
        }

        const seqIndex = {};
        for (const item of this._items) {
            seqIndex[item.seq] = item;
        }

        this._items = [];
        this.nodes = [];

        for (const value of sorted) {
            const sortedItem = seqIndex[value];
            this.nodes.push(sortedItem.node);
            this._items.push(sortedItem);
        }

        return true;
    }
};


internals.mergeSort = (a, b) => {

    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);
};


/***/ }),

/***/ "./node_modules/@hapi/vise/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@hapi/vise/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");


const internals = {};


exports = module.exports = internals.Vise = function (chunks) {

    this.length = 0;
    this._chunks = [];
    this._offset = 0;

    if (chunks) {
        chunks = [].concat(chunks);
        for (let i = 0; i < chunks.length; ++i) {
            this.push(chunks[i]);
        }
    }
};


internals.Vise.prototype.push = function (chunk) {

    Hoek.assert(Buffer.isBuffer(chunk), 'Chunk must be a buffer');

    const item = {
        data: chunk,
        length: chunk.length,
        offset: this.length + this._offset,
        index: this._chunks.length
    };

    this._chunks.push(item);
    this.length += chunk.length;
};


internals.Vise.prototype.shift = function (length) {

    if (!length) {
        return [];
    }

    const prevOffset = this._offset;
    const item = this._chunkAt(length);

    let dropTo = this._chunks.length;
    this._offset = 0;

    if (item) {
        dropTo = item.chunk.index;
        this._offset = item.offset;
    }

    // Drop lower chunks

    const chunks = [];
    for (let i = 0; i < dropTo; ++i) {
        const chunk = this._chunks.shift();
        if (i === 0 &&
            prevOffset) {

            chunks.push(chunk.data.slice(prevOffset));
        }
        else {
            chunks.push(chunk.data);
        }
    }

    if (this._offset) {
        chunks.push(item.chunk.data.slice(dropTo ? 0 : prevOffset, this._offset));
    }

    // Recalculate existing chunks

    this.length = 0;
    for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        chunk.offset = this.length,
        chunk.index = i;

        this.length += chunk.length;
    }

    this.length -= this._offset;

    return chunks;
};


internals.Vise.prototype.at = internals.Vise.prototype.readUInt8 = function (pos) {

    const item = this._chunkAt(pos);
    return item ? item.chunk.data[item.offset] : undefined;
};


internals.Vise.prototype._chunkAt = function (pos) {

    if (pos < 0) {
        return null;
    }

    pos = pos + this._offset;

    for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        const offset = pos - chunk.offset;
        if (offset < chunk.length) {
            return { chunk, offset };
        }
    }

    return null;
};


internals.Vise.prototype.chunks = function () {

    const chunks = [];

    for (let i = 0; i < this._chunks.length; ++i) {
        const chunk = this._chunks[i];
        if (i === 0 &&
            this._offset) {

            chunks.push(chunk.data.slice(this._offset));
        }
        else {
            chunks.push(chunk.data);
        }
    }

    return chunks;
};


internals.Vise.prototype.startsWith = function (value, pos, length) {

    pos = pos || 0;

    length = length ? Math.min(value.length, length) : value.length;
    if (pos + length > this.length) {                                   // Not enough length to fit value
        return false;
    }

    const start = this._chunkAt(pos);
    if (!start) {
        return false;
    }

    let j = start.chunk.index;
    for (let i = 0; j < this._chunks.length && i < length; ++j) {
        const chunk = this._chunks[j];

        let k = (j === start.chunk.index ? start.offset : 0);
        for (; k < chunk.length && i < length; ++k, ++i) {
            if (chunk.data[k] !== value[i]) {
                return false;
            }
        }
    }

    return true;
};


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Events = __webpack_require__(/*! events */ "events");
const Http = __webpack_require__(/*! http */ "http");
const Https = __webpack_require__(/*! https */ "https");
const Stream = __webpack_require__(/*! stream */ "stream");
const Url = __webpack_require__(/*! url */ "url");
const Zlib = __webpack_require__(/*! zlib */ "zlib");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");
const Bourne = __webpack_require__(/*! @hapi/bourne */ "./node_modules/@hapi/bourne/lib/index.js");
const Hoek = __webpack_require__(/*! @hapi/hoek */ "./node_modules/@hapi/hoek/lib/index.js");

const Payload = __webpack_require__(/*! ./payload */ "./node_modules/@hapi/wreck/lib/payload.js");
const Recorder = __webpack_require__(/*! ./recorder */ "./node_modules/@hapi/wreck/lib/recorder.js");
const Tap = __webpack_require__(/*! ./tap */ "./node_modules/@hapi/wreck/lib/tap.js");


const internals = {
    jsonRegex: /^application\/([a-z0-9.]*[+-]json|json)$/,
    shallowOptions: ['agent', 'agents', 'beforeRedirect', 'downstreamRes', 'payload', 'redirected']
};


// New instance is exported as module.exports

internals.Client = function (options = {}) {

    Hoek.assert(!options.agents || (options.agents.https && options.agents.http && options.agents.httpsAllowUnauthorized), 'Option agents must include "http", "https", and "httpsAllowUnauthorized"');

    this._defaults = Hoek.clone(options, { shallow: internals.shallowOptions });

    this.agents = this._defaults.agents || {
        https: new Https.Agent({ maxSockets: Infinity }),
        http: new Http.Agent({ maxSockets: Infinity }),
        httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })
    };

    if (!options.events) {
        return;
    }

    this.events = new Events.EventEmitter();
    this._emit = function (...args) {

        this.events.emit(...args);
    };
};


internals.Client.prototype.defaults = function (options) {

    Hoek.assert(options && (typeof options === 'object'), 'options must be provided to defaults');

    options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });
    return new internals.Client(options);
};


// baseUrl needs to end in a trailing / if it contains paths that need to be preserved
internals.resolveUrl = function (baseUrl, path) {

    if (!path) {
        return baseUrl;
    }

    // Will default to path if it's not a relative URL
    const url = new Url.URL(path, baseUrl);
    return Url.format(url);
};


internals.Client.prototype.request = function (method, url, options = {}) {

    try {
        options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });

        Hoek.assert(options.payload === undefined || typeof options.payload === 'string' || typeof options.payload === 'object', 'options.payload must be a string, a Buffer, a Stream, or an Object');
        Hoek.assert((options.agent === undefined || options.agent === null) || (typeof options.rejectUnauthorized !== 'boolean'), 'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');
        Hoek.assert(options.beforeRedirect === undefined || options.beforeRedirect === null || typeof options.beforeRedirect === 'function', 'options.beforeRedirect must be a function');
        Hoek.assert(options.redirected === undefined || options.redirected === null || typeof options.redirected === 'function', 'options.redirected must be a function');
        Hoek.assert(options.gunzip === undefined || typeof options.gunzip === 'boolean' || options.gunzip === 'force', 'options.gunzip must be a boolean or "force"');
    }
    catch (err) {
        return Promise.reject(err);
    }

    options.beforeRedirect = options.beforeRedirect || ((redirectMethod, statusCode, location, resHeaders, redirectOptions, next) => next());

    if (options.baseUrl) {
        url = internals.resolveUrl(options.baseUrl, url);
        delete options.baseUrl;
    }

    const relay = {};
    const req = this._request(method, url, options, relay);
    const promise = new Promise((resolve, reject) => {

        relay.callback = (err, res) => {

            if (err) {
                reject(err);
                return;
            }

            resolve(res);
            return;
        };
    });

    promise.req = req;
    return promise;
};


internals.Client.prototype._request = function (method, url, options, relay, _trace) {

    const uri = {};
    if (options.socketPath) {
        uri.socketPath = options.socketPath;

        const parsedUri = new Url.URL(url, `unix://${options.socketPath}`);
        internals.applyUrlToOptions(uri, {
            // The host must be empty according to https://tools.ietf.org/html/rfc2616#section-14.23
            host: '',
            protocol: 'http:',
            hash: parsedUri.hash,
            search: parsedUri.search,
            searchParams: parsedUri.searchParams,
            pathname: parsedUri.pathname,
            href: parsedUri.href
        });
    }
    else {
        uri.setHost = false;
        const parsedUri = new Url.URL(url);
        internals.applyUrlToOptions(uri, parsedUri);
    }

    uri.method = method.toUpperCase();
    uri.headers = options.headers || {};

    const hostHeader = internals.findHeader('host', uri.headers);

    if (!hostHeader) {
        uri.headers.host = uri.host;
    }

    const hasContentLength = internals.findHeader('content-length', uri.headers) !== undefined;

    if (options.payload && typeof options.payload === 'object' && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {
        options.payload = JSON.stringify(options.payload);
        if (!internals.findHeader('content-type', uri.headers)) {
            uri.headers['content-type'] = 'application/json';
        }
    }

    if (options.gunzip &&
        internals.findHeader('accept-encoding', uri.headers) === undefined) {

        uri.headers['accept-encoding'] = 'gzip';
    }

    const payloadSupported = (uri.method !== 'GET' && uri.method !== 'HEAD' && options.payload !== null && options.payload !== undefined);
    if (payloadSupported &&
        (typeof options.payload === 'string' || Buffer.isBuffer(options.payload)) &&
        (!hasContentLength)) {

        uri.headers = Hoek.clone(uri.headers);
        uri.headers['content-length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);
    }

    let redirects = (options.hasOwnProperty('redirects') ? options.redirects : false);      // Needed to allow 0 as valid value when passed recursively

    _trace = (_trace || []);
    _trace.push({ method: uri.method, url });

    const client = (uri.protocol === 'https:' ? Https : Http);

    if (options.rejectUnauthorized !== undefined && uri.protocol === 'https:') {
        uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;
    }
    else if (options.agent || options.agent === false) {
        uri.agent = options.agent;
    }
    else {
        uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;
    }

    if (options.secureProtocol !== undefined) {
        uri.secureProtocol = options.secureProtocol;
    }

    if (options.ciphers !== undefined) {
        uri.ciphers = options.ciphers;
    }

    if (this._emit) {
        this._emit('preRequest', uri, options);
    }

    const start = Date.now();
    const req = client.request(uri);

    if (this._emit) {
        this._emit('request', req);
    }

    let shadow = null;                                                                      // A copy of the streamed request payload when redirects are enabled
    let timeoutId;

    const onError = (err) => {

        err.trace = _trace;
        return finishOnce(Boom.badGateway('Client request error', err));
    };

    req.once('error', onError);

    const onResponse = (res) => {

        // Pass-through response

        const statusCode = res.statusCode;
        const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);

        if (redirects === false ||
            !redirectMethod) {

            return finishOnce(null, res);
        }

        // Redirection

        res.destroy();

        if (redirects === 0) {
            return finishOnce(Boom.badGateway('Maximum redirections reached', _trace));
        }

        let location = res.headers.location;
        if (!location) {
            return finishOnce(Boom.badGateway('Received redirection without location', _trace));
        }

        if (!/^https?:/i.test(location)) {
            location = Url.resolve(uri.href, location);
        }

        const redirectOptions = Hoek.clone(options, { shallow: internals.shallowOptions });
        redirectOptions.payload = shadow || options.payload;                                    // shadow must be ready at this point if set
        redirectOptions.redirects = --redirects;

        return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, () => {

            const redirectReq = this._request(redirectMethod, location, redirectOptions, { callback: finishOnce }, _trace);

            if (options.redirected) {
                options.redirected(statusCode, location, redirectReq);
            }
        });
    };

    // Register handlers

    const finish = (err, res) => {

        if (err) {
            req.abort();
        }

        req.abort = _abort;                             // Restore original function to release memory
        req.removeListener('response', onResponse);
        req.removeListener('error', onError);
        req.on('error', Hoek.ignore);

        clearTimeout(timeoutId);

        if (this._emit) {
            this._emit('response', err, { req, res, start, uri });
        }

        return relay.callback(err, res);
    };

    const finishOnce = Hoek.once(finish);

    req.once('response', onResponse);

    if (options.timeout) {
        timeoutId = setTimeout(() => {

            return finishOnce(Boom.gatewayTimeout('Client request timeout'));
        }, options.timeout);
        delete options.timeout;
    }

    // Custom abort method to detect early aborts

    const _abort = req.abort;
    let aborted = false;
    req.abort = () => {

        if (!aborted && !req.res && !req.socket) {
            process.nextTick(() => {

                // Fake an ECONNRESET error

                const error = new Error('socket hang up');
                error.code = 'ECONNRESET';
                finishOnce(error);
            });
        }

        aborted = true;
        return _abort.call(req);
    };

    // Write payload

    if (payloadSupported) {
        if (options.payload instanceof Stream) {
            let stream = options.payload;

            if (redirects) {
                const collector = new Tap();
                collector.once('finish', () => {

                    shadow = collector.collect();
                });

                stream = options.payload.pipe(collector);
            }

            internals.deferPipeUntilSocketConnects(req, stream);
            return req;
        }

        req.write(options.payload);
    }

    // Finalize request

    req.end();
    return req;
};


internals.deferPipeUntilSocketConnects = function (req, stream) {

    const onSocket = (socket) => {

        if (!socket.connecting) {
            return onSocketConnect();
        }

        socket.once('connect', onSocketConnect);
    };

    const onSocketConnect = () => {

        stream.pipe(req);
        stream.removeListener('error', onStreamError);
    };

    const onStreamError = (err) => {

        req.emit('error', err);
    };

    req.once('socket', onSocket);
    stream.on('error', onStreamError);
};


internals.redirectMethod = function (code, method, options) {

    switch (code) {
        case 301:
        case 302:
            return options.redirectMethod || method;

        case 303:
            if (options.redirect303) {
                return 'GET';
            }

            break;

        case 307:
        case 308:
            return method;
    }

    return null;
};


internals.Client.prototype.read = function (res, options = {}) {

    return new Promise((resolve, reject) => {

        this._read(res, options, (err, payload) => {

            if (err) {
                reject(err);
                return;
            }

            resolve(payload);
            return;
        });
    });
};


internals.Client.prototype._read = function (res, options, callback) {

    options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });

    // Finish once

    let clientTimeoutId = null;

    const finish = (err, buffer) => {

        clearTimeout(clientTimeoutId);
        reader.removeListener('error', onReaderError);
        reader.removeListener('finish', onReaderFinish);
        res.removeListener('error', onResError);
        res.removeListener('close', onResAborted);
        res.removeListener('aborted', onResAborted);
        res.on('error', Hoek.ignore);

        if (err) {
            return callback(err);
        }

        if (!options.json) {
            return callback(null, buffer);
        }

        // Parse JSON

        if (options.json === 'force') {
            return internals.tryParseBuffer(buffer, callback);
        }

        // mode is "smart", "strict" or true

        const contentType = (res.headers && internals.findHeader('content-type', res.headers)) || '';
        const mime = contentType.split(';')[0].trim().toLowerCase();

        if (!internals.jsonRegex.test(mime)) {
            if (options.json === 'strict') {
                return callback(Boom.notAcceptable('The content-type is not JSON compatible'));
            }

            return callback(null, buffer);
        }

        return internals.tryParseBuffer(buffer, callback);
    };

    const finishOnce = Hoek.once(finish);

    const clientTimeout = options.timeout;
    if (clientTimeout &&
        clientTimeout > 0) {

        clientTimeoutId = setTimeout(() => {

            finishOnce(Boom.clientTimeout());
        }, clientTimeout);
    }

    // Hander errors

    const onResError = (err) => {

        return finishOnce(err.isBoom ? err : Boom.internal('Payload stream error', err));
    };

    const onResAborted = () => {

        // Workaround https://github.com/nodejs/node/pull/20611
        // This is covered in node 10
        /* $lab:coverage:off$ */
        if (res.complete) {
            return;
        }
        /* $lab:coverage:on$ */

        return finishOnce(Boom.internal('Payload stream closed prematurely'));
    };

    res.once('error', onResError);
    res.once('close', onResAborted);
    res.once('aborted', onResAborted);

    // Read payload

    const reader = new Recorder({ maxBytes: options.maxBytes });

    const onReaderError = (err) => {

        if (res.destroy) {                          // GZip stream has no destroy() method
            res.destroy();
        }

        return finishOnce(err);
    };

    reader.once('error', onReaderError);

    const onReaderFinish = () => {

        return finishOnce(null, reader.collect());
    };

    reader.once('finish', onReaderFinish);

    if (options.gunzip) {
        const contentEncoding = options.gunzip === 'force' ?
            'gzip' :
            (res.headers && internals.findHeader('content-encoding', res.headers)) || '';

        if (/^(x-)?gzip(\s*,\s*identity)?$/.test(contentEncoding)) {
            const gunzip = Zlib.createGunzip();

            gunzip.once('error', onReaderError);

            res.pipe(gunzip).pipe(reader);
            return;
        }
    }

    res.pipe(reader);
};


internals.Client.prototype.toReadableStream = function (payload, encoding) {

    return new Payload(payload, encoding);
};


internals.Client.prototype.parseCacheControl = function (field) {

    /*
        Cache-Control   = 1#cache-directive
        cache-directive = token [ "=" ( token / quoted-string ) ]
        token           = [^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+
        quoted-string   = "(?:[^"\\]|\\.)*"
    */

    //                             1: directive                                        =   2: token                                              3: quoted-string
    const regex = /(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g;

    const header = {};
    const error = field.replace(regex, ($0, $1, $2, $3) => {

        const value = $2 || $3;
        header[$1] = value ? value.toLowerCase() : true;
        return '';
    });

    if (header['max-age']) {
        try {
            const maxAge = parseInt(header['max-age'], 10);
            if (isNaN(maxAge)) {
                return null;
            }

            header['max-age'] = maxAge;
        }
        catch (err) { }
    }

    return (error ? null : header);
};


// Shortcuts

internals.Client.prototype.get = function (uri, options) {

    return this._shortcut('GET', uri, options);
};


internals.Client.prototype.post = function (uri, options) {

    return this._shortcut('POST', uri, options);
};


internals.Client.prototype.patch = function (uri, options) {

    return this._shortcut('PATCH', uri, options);
};


internals.Client.prototype.put = function (uri, options) {

    return this._shortcut('PUT', uri, options);
};


internals.Client.prototype.delete = function (uri, options) {

    return this._shortcut('DELETE', uri, options);
};


internals.Client.prototype._shortcut = async function (method, uri, options = {}) {

    const res = await this.request(method, uri, options);

    let payload;
    try {
        payload = await this.read(res, options);
    }
    catch (err) {
        err.data = err.data || {};
        err.data.res = res;
        throw err;
    }

    if (res.statusCode < 400) {
        return { res, payload };
    }

    // Response error

    const data = {
        isResponseError: true,
        headers: res.headers,
        res,
        payload
    };

    throw new Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, { statusCode: res.statusCode, data });
};


internals.tryParseBuffer = function (buffer, next) {

    if (buffer.length === 0) {
        return next(null, null);
    }

    let payload;
    try {
        payload = Bourne.parse(buffer.toString());
    }
    catch (err) {
        return next(Boom.badGateway(err.message, { payload: buffer }));
    }

    return next(null, payload);
};


internals.findHeader = function (headerName, headers) {

    const foundKey = Object.keys(headers)
        .find((key) => key.toLowerCase() === headerName.toLowerCase());

    return foundKey && headers[foundKey];
};

internals.applyUrlToOptions = (options, url) => {

    options.host = url.host;
    options.origin = url.origin;
    options.searchParams = url.searchParams;
    options.protocol = url.protocol;
    options.hostname = url.hostname;
    options.hash = url.hash;
    options.search = url.search;
    options.pathname = url.pathname;
    options.path = `${url.pathname}${url.search || ''}`;
    options.href = url.href;
    if (url.port !== '') {
        options.port = Number(url.port);
    }

    if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
        options.username = url.username;
        options.password = url.password;
    }

    return options;
};


module.exports = new internals.Client();


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/payload.js":
/*!*************************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/payload.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");


const internals = {};


module.exports = internals.Payload = class extends Stream.Readable {

    constructor(payload, encoding) {

        super();

        const data = [].concat(payload || '');
        let size = 0;
        for (let i = 0; i < data.length; ++i) {
            const chunk = data[i];
            size = size + chunk.length;
            data[i] = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        }

        this._data = Buffer.concat(data, size);
        this._position = 0;
        this._encoding = encoding || 'utf8';
    }

    _read(size) {

        const chunk = this._data.slice(this._position, this._position + size);
        this.push(chunk, this._encoding);
        this._position = this._position + chunk.length;

        if (this._position >= this._data.length) {
            this.push(null);
        }
    }
};


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/recorder.js":
/*!**************************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/recorder.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Boom = __webpack_require__(/*! @hapi/boom */ "./node_modules/@hapi/boom/lib/index.js");


const internals = {};


module.exports = internals.Recorder = class extends Stream.Writable {

    constructor(options) {

        super();

        this.settings = options;                // No need to clone since called internally with new object
        this.buffers = [];
        this.length = 0;
    }

    _write(chunk, encoding, next) {

        if (this.settings.maxBytes &&
            this.length + chunk.length > this.settings.maxBytes) {

            return this.emit('error', Boom.entityTooLarge('Payload content length greater than maximum allowed: ' + this.settings.maxBytes));
        }

        this.length = this.length + chunk.length;
        this.buffers.push(chunk);
        next();
    }

    collect() {

        const buffer = (this.buffers.length === 0 ? Buffer.alloc(0) : (this.buffers.length === 1 ? this.buffers[0] : Buffer.concat(this.buffers, this.length)));
        return buffer;
    }
};


/***/ }),

/***/ "./node_modules/@hapi/wreck/lib/tap.js":
/*!*********************************************!*\
  !*** ./node_modules/@hapi/wreck/lib/tap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


const Stream = __webpack_require__(/*! stream */ "stream");

const Payload = __webpack_require__(/*! ./payload */ "./node_modules/@hapi/wreck/lib/payload.js");


const internals = {};


module.exports = internals.Tap = class extends Stream.Transform {

    constructor() {

        super();
        this.buffers = [];
    }

    _transform(chunk, encoding, next) {

        this.buffers.push(chunk);
        next(null, chunk);
    }

    collect() {

        return new Payload(this.buffers);
    }
};


/***/ }),

/***/ "./node_modules/gud/index.js":
/*!***********************************!*\
  !*** ./node_modules/gud/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// @flow


var key = '__global_unique_id__';

module.exports = function() {
  return global[key] = (global[key] || 0) + 1;
};


/***/ }),

/***/ "./node_modules/history/esm/history.js":
/*!*********************************************!*\
  !*** ./node_modules/history/esm/history.js ***!
  \*********************************************/
/*! exports provided: createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBrowserHistory", function() { return createBrowserHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHashHistory", function() { return createHashHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createMemoryHistory", function() { return createMemoryHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLocation", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locationsAreEqual", function() { return locationsAreEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePath", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPath", function() { return createPath; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var resolve_pathname__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! resolve-pathname */ "./node_modules/resolve-pathname/esm/resolve-pathname.js");
/* harmony import */ var value_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! value-equal */ "./node_modules/value-equal/esm/value-equal.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-invariant */ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");






function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
}
function hasBasename(path, prefix) {
  return path.toLowerCase().indexOf(prefix.toLowerCase()) === 0 && '/?#'.indexOf(path.charAt(prefix.length)) !== -1;
}
function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';
  var hashIndex = pathname.indexOf('#');

  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');

  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
}
function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;
  var path = pathname || '/';
  if (search && search !== '?') path += search.charAt(0) === '?' ? search : "?" + search;
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#" + hash;
  return path;
}

function createLocation(path, state, key, currentLocation) {
  var location;

  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = parsePath(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, path);
    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(resolve_pathname__WEBPACK_IMPORTED_MODULE_1__["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
}
function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal__WEBPACK_IMPORTED_MODULE_2__["default"])(a.state, b.state);
}

function createTransitionManager() {
  var prompt = null;

  function setPrompt(nextPrompt) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(prompt == null, 'A history supports only one prompt at a time') : undefined;
    prompt = nextPrompt;
    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  }

  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
           true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : undefined;
          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }

  var listeners = [];

  function appendListener(fn) {
    var isActive = true;

    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }

    listeners.push(listener);
    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  }

  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(void 0, args);
    });
  }

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message)); // eslint-disable-line no-alert
}
/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */

function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;
  return window.history && 'pushState' in window.history;
}
/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */

function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
}
/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */

function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
}
/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */

function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
}
/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */


function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_4__["default"])(false, 'Browser history needs a DOM') : undefined : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props,
      _props$forceRefresh = _props.forceRefresh,
      forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';

  function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;
    var path = pathname + search + hash;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : undefined;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path, state, key);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }

  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }

  var forceNextPop = false;

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key]; // Public interface

  function createHref(location) {
    return basename + createPath(location);
  }

  function push(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history') : undefined;
        window.location.href = href;
      }
    });
  }

  function replace(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({
          key: key,
          state: state
        }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action: action,
            location: location
          });
        }
      } else {
         true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history') : undefined;
        window.location.replace(href);
      }
    });
  }

  function go(n) {
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

var HashChangeEvent$1 = 'hashchange';
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash
  },
  slash: {
    encodePath: addLeadingSlash,
    decodePath: addLeadingSlash
  }
};

function stripHash(url) {
  var hashIndex = url.indexOf('#');
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}

function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
}

function pushHashPath(path) {
  window.location.hash = path;
}

function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + '#' + path);
}

function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }

  !canUseDOM ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_4__["default"])(false, 'Hash history needs a DOM') : undefined : void 0;
  var globalHistory = window.history;
  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();
  var _props = props,
      _props$getUserConfirm = _props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm,
      _props$hashType = _props.hashType,
      hashType = _props$hashType === void 0 ? 'slash' : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';
  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  function getDOMLocation() {
    var path = decodePath(getHashPath());
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".') : undefined;
    if (basename) path = stripBasename(path, basename);
    return createLocation(path);
  }

  var transitionManager = createTransitionManager();

  function setState(nextState) {
    Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])(history, nextState);

    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  var forceNextPop = false;
  var ignorePath = null;

  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }

  function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;
      handlePop(location);
    }
  }

  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({
            action: action,
            location: location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }

  function revertPop(fromLocation) {
    var toLocation = history.location; // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  } // Ensure the hash is encoded properly before doing anything else.


  var path = getHashPath();
  var encodedPath = encodePath(path);
  if (path !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)]; // Public interface

  function createHref(location) {
    var baseTag = document.querySelector('base');
    var href = '';

    if (baseTag && baseTag.getAttribute('href')) {
      href = stripHash(window.location.href);
    }

    return href + '#' + encodePath(basename + createPath(location));
  }

  function push(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Hash history cannot push state; it is ignored') : undefined;
    var action = 'PUSH';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path);
        allPaths = nextPaths;
        setState({
          action: action,
          location: location
        });
      } else {
         true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack') : undefined;
        setState();
      }
    });
  }

  function replace(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(state === undefined, 'Hash history cannot replace state; it is ignored') : undefined;
    var action = 'REPLACE';
    var location = createLocation(path, undefined, undefined, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var path = createPath(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
    globalHistory.go(n);
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  var listenerCount = 0;

  function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }

  var isBlocked = false;

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  }

  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  }

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };
  return history;
}

function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
/**
 * Creates a history object that stores locations in memory.
 */


function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      getUserConfirmation = _props.getUserConfirmation,
      _props$initialEntries = _props.initialEntries,
      initialEntries = _props$initialEntries === void 0 ? ['/'] : _props$initialEntries,
      _props$initialIndex = _props.initialIndex,
      initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex,
      _props$keyLength = _props.keyLength,
      keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();

  function setState(nextState) {
    Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])(history, nextState);

    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }

  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());
  }); // Public interface

  var createHref = createPath;

  function push(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'PUSH';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);

      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }

  function replace(path, state) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_3__["default"])(!(typeof path === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored') : undefined;
    var action = 'REPLACE';
    var location = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action: action,
        location: location
      });
    });
  }

  function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
    var action = 'POP';
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  }

  function goBack() {
    go(-1);
  }

  function goForward() {
    go(1);
  }

  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }

  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }

    return transitionManager.setPrompt(prompt);
  }

  function listen(listener) {
    return transitionManager.appendListener(listener);
  }

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };
  return history;
}




/***/ }),

/***/ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
};

var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
};

var TYPE_STATICS = {};
TYPE_STATICS[ReactIs.ForwardRef] = FORWARD_REF_STATICS;

function getStatics(component) {
    if (ReactIs.isMemo(component)) {
        return MEMO_STATICS;
    }
    return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try {
                    // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(/*! pseudomap */ "./node_modules/pseudomap/map.js")
var util = __webpack_require__(/*! util */ "util")

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(/*! yallist */ "./node_modules/lru-cache/node_modules/yallist/yallist.js")

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function' && process.env._nodeLRUCacheForceNoSymbol !== '1'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

/* istanbul ignore next */
LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}


/***/ }),

/***/ "./node_modules/lru-cache/node_modules/yallist/yallist.js":
/*!****************************************************************!*\
  !*** ./node_modules/lru-cache/node_modules/yallist/yallist.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/*! exports provided: application/1d-interleaved-parityfec, application/3gpdash-qoe-report+xml, application/3gpp-ims+xml, application/a2l, application/activemessage, application/activity+json, application/alto-costmap+json, application/alto-costmapfilter+json, application/alto-directory+json, application/alto-endpointcost+json, application/alto-endpointcostparams+json, application/alto-endpointprop+json, application/alto-endpointpropparams+json, application/alto-error+json, application/alto-networkmap+json, application/alto-networkmapfilter+json, application/aml, application/andrew-inset, application/applefile, application/applixware, application/atf, application/atfx, application/atom+xml, application/atomcat+xml, application/atomdeleted+xml, application/atomicmail, application/atomsvc+xml, application/atsc-dwd+xml, application/atsc-held+xml, application/atsc-rsat+xml, application/atxml, application/auth-policy+xml, application/bacnet-xdd+zip, application/batch-smtp, application/bdoc, application/beep+xml, application/calendar+json, application/calendar+xml, application/call-completion, application/cals-1840, application/cbor, application/cccex, application/ccmp+xml, application/ccxml+xml, application/cdfx+xml, application/cdmi-capability, application/cdmi-container, application/cdmi-domain, application/cdmi-object, application/cdmi-queue, application/cdni, application/cea, application/cea-2018+xml, application/cellml+xml, application/cfw, application/clue_info+xml, application/cms, application/cnrp+xml, application/coap-group+json, application/coap-payload, application/commonground, application/conference-info+xml, application/cose, application/cose-key, application/cose-key-set, application/cpl+xml, application/csrattrs, application/csta+xml, application/cstadata+xml, application/csvm+json, application/cu-seeme, application/cwt, application/cybercash, application/dart, application/dash+xml, application/dashdelta, application/davmount+xml, application/dca-rft, application/dcd, application/dec-dx, application/dialog-info+xml, application/dicom, application/dicom+json, application/dicom+xml, application/dii, application/dit, application/dns, application/dns+json, application/dns-message, application/docbook+xml, application/dskpp+xml, application/dssc+der, application/dssc+xml, application/dvcs, application/ecmascript, application/edi-consent, application/edi-x12, application/edifact, application/efi, application/emergencycalldata.comment+xml, application/emergencycalldata.control+xml, application/emergencycalldata.deviceinfo+xml, application/emergencycalldata.ecall.msd, application/emergencycalldata.providerinfo+xml, application/emergencycalldata.serviceinfo+xml, application/emergencycalldata.subscriberinfo+xml, application/emergencycalldata.veds+xml, application/emma+xml, application/emotionml+xml, application/encaprtp, application/epp+xml, application/epub+zip, application/eshop, application/exi, application/expect-ct-report+json, application/fastinfoset, application/fastsoap, application/fdt+xml, application/fhir+json, application/fhir+xml, application/fido.trusted-apps+json, application/fits, application/flexfec, application/font-sfnt, application/font-tdpfr, application/font-woff, application/framework-attributes+xml, application/geo+json, application/geo+json-seq, application/geopackage+sqlite3, application/geoxacml+xml, application/gltf-buffer, application/gml+xml, application/gpx+xml, application/gxf, application/gzip, application/h224, application/held+xml, application/hjson, application/http, application/hyperstudio, application/ibe-key-request+xml, application/ibe-pkg-reply+xml, application/ibe-pp-data, application/iges, application/im-iscomposing+xml, application/index, application/index.cmd, application/index.obj, application/index.response, application/index.vnd, application/inkml+xml, application/iotp, application/ipfix, application/ipp, application/isup, application/its+xml, application/java-archive, application/java-serialized-object, application/java-vm, application/javascript, application/jf2feed+json, application/jose, application/jose+json, application/jrd+json, application/json, application/json-patch+json, application/json-seq, application/json5, application/jsonml+json, application/jwk+json, application/jwk-set+json, application/jwt, application/kpml-request+xml, application/kpml-response+xml, application/ld+json, application/lgr+xml, application/link-format, application/load-control+xml, application/lost+xml, application/lostsync+xml, application/lxf, application/mac-binhex40, application/mac-compactpro, application/macwriteii, application/mads+xml, application/manifest+json, application/marc, application/marcxml+xml, application/mathematica, application/mathml+xml, application/mathml-content+xml, application/mathml-presentation+xml, application/mbms-associated-procedure-description+xml, application/mbms-deregister+xml, application/mbms-envelope+xml, application/mbms-msk+xml, application/mbms-msk-response+xml, application/mbms-protection-description+xml, application/mbms-reception-report+xml, application/mbms-register+xml, application/mbms-register-response+xml, application/mbms-schedule+xml, application/mbms-user-service-description+xml, application/mbox, application/media-policy-dataset+xml, application/media_control+xml, application/mediaservercontrol+xml, application/merge-patch+json, application/metalink+xml, application/metalink4+xml, application/mets+xml, application/mf4, application/mikey, application/mipc, application/mmt-aei+xml, application/mmt-usd+xml, application/mods+xml, application/moss-keys, application/moss-signature, application/mosskey-data, application/mosskey-request, application/mp21, application/mp4, application/mpeg4-generic, application/mpeg4-iod, application/mpeg4-iod-xmt, application/mrb-consumer+xml, application/mrb-publish+xml, application/msc-ivr+xml, application/msc-mixer+xml, application/msword, application/mud+json, application/mxf, application/n-quads, application/n-triples, application/nasdata, application/news-checkgroups, application/news-groupinfo, application/news-transmission, application/nlsml+xml, application/node, application/nss, application/ocsp-request, application/ocsp-response, application/octet-stream, application/oda, application/odm+xml, application/odx, application/oebps-package+xml, application/ogg, application/omdoc+xml, application/onenote, application/oscore, application/oxps, application/p2p-overlay+xml, application/parityfec, application/passport, application/patch-ops-error+xml, application/pdf, application/pdx, application/pem-certificate-chain, application/pgp-encrypted, application/pgp-keys, application/pgp-signature, application/pics-rules, application/pidf+xml, application/pidf-diff+xml, application/pkcs10, application/pkcs12, application/pkcs7-mime, application/pkcs7-signature, application/pkcs8, application/pkcs8-encrypted, application/pkix-attr-cert, application/pkix-cert, application/pkix-crl, application/pkix-pkipath, application/pkixcmp, application/pls+xml, application/poc-settings+xml, application/postscript, application/ppsp-tracker+json, application/problem+json, application/problem+xml, application/provenance+xml, application/prs.alvestrand.titrax-sheet, application/prs.cww, application/prs.hpub+zip, application/prs.nprend, application/prs.plucker, application/prs.rdf-xml-crypt, application/prs.xsf+xml, application/pskc+xml, application/qsig, application/raml+yaml, application/raptorfec, application/rdap+json, application/rdf+xml, application/reginfo+xml, application/relax-ng-compact-syntax, application/remote-printing, application/reputon+json, application/resource-lists+xml, application/resource-lists-diff+xml, application/rfc+xml, application/riscos, application/rlmi+xml, application/rls-services+xml, application/route-apd+xml, application/route-s-tsid+xml, application/route-usd+xml, application/rpki-ghostbusters, application/rpki-manifest, application/rpki-publication, application/rpki-roa, application/rpki-updown, application/rsd+xml, application/rss+xml, application/rtf, application/rtploopback, application/rtx, application/samlassertion+xml, application/samlmetadata+xml, application/sbml+xml, application/scaip+xml, application/scim+json, application/scvp-cv-request, application/scvp-cv-response, application/scvp-vp-request, application/scvp-vp-response, application/sdp, application/secevent+jwt, application/senml+cbor, application/senml+json, application/senml+xml, application/senml-exi, application/sensml+cbor, application/sensml+json, application/sensml+xml, application/sensml-exi, application/sep+xml, application/sep-exi, application/session-info, application/set-payment, application/set-payment-initiation, application/set-registration, application/set-registration-initiation, application/sgml, application/sgml-open-catalog, application/shf+xml, application/sieve, application/simple-filter+xml, application/simple-message-summary, application/simplesymbolcontainer, application/sipc, application/slate, application/smil, application/smil+xml, application/smpte336m, application/soap+fastinfoset, application/soap+xml, application/sparql-query, application/sparql-results+xml, application/spirits-event+xml, application/sql, application/srgs, application/srgs+xml, application/sru+xml, application/ssdl+xml, application/ssml+xml, application/stix+json, application/swid+xml, application/tamp-apex-update, application/tamp-apex-update-confirm, application/tamp-community-update, application/tamp-community-update-confirm, application/tamp-error, application/tamp-sequence-adjust, application/tamp-sequence-adjust-confirm, application/tamp-status-query, application/tamp-status-response, application/tamp-update, application/tamp-update-confirm, application/tar, application/taxii+json, application/tei+xml, application/tetra_isi, application/thraud+xml, application/timestamp-query, application/timestamp-reply, application/timestamped-data, application/tlsrpt+gzip, application/tlsrpt+json, application/tnauthlist, application/toml, application/trickle-ice-sdpfrag, application/trig, application/ttml+xml, application/tve-trigger, application/tzif, application/tzif-leap, application/ulpfec, application/urc-grpsheet+xml, application/urc-ressheet+xml, application/urc-targetdesc+xml, application/urc-uisocketdesc+xml, application/vcard+json, application/vcard+xml, application/vemmi, application/vividence.scriptfile, application/vnd.1000minds.decision-model+xml, application/vnd.3gpp-prose+xml, application/vnd.3gpp-prose-pc3ch+xml, application/vnd.3gpp-v2x-local-service-information, application/vnd.3gpp.access-transfer-events+xml, application/vnd.3gpp.bsf+xml, application/vnd.3gpp.gmop+xml, application/vnd.3gpp.mc-signalling-ear, application/vnd.3gpp.mcdata-affiliation-command+xml, application/vnd.3gpp.mcdata-info+xml, application/vnd.3gpp.mcdata-payload, application/vnd.3gpp.mcdata-service-config+xml, application/vnd.3gpp.mcdata-signalling, application/vnd.3gpp.mcdata-ue-config+xml, application/vnd.3gpp.mcdata-user-profile+xml, application/vnd.3gpp.mcptt-affiliation-command+xml, application/vnd.3gpp.mcptt-floor-request+xml, application/vnd.3gpp.mcptt-info+xml, application/vnd.3gpp.mcptt-location-info+xml, application/vnd.3gpp.mcptt-mbms-usage-info+xml, application/vnd.3gpp.mcptt-service-config+xml, application/vnd.3gpp.mcptt-signed+xml, application/vnd.3gpp.mcptt-ue-config+xml, application/vnd.3gpp.mcptt-ue-init-config+xml, application/vnd.3gpp.mcptt-user-profile+xml, application/vnd.3gpp.mcvideo-affiliation-command+xml, application/vnd.3gpp.mcvideo-affiliation-info+xml, application/vnd.3gpp.mcvideo-info+xml, application/vnd.3gpp.mcvideo-location-info+xml, application/vnd.3gpp.mcvideo-mbms-usage-info+xml, application/vnd.3gpp.mcvideo-service-config+xml, application/vnd.3gpp.mcvideo-transmission-request+xml, application/vnd.3gpp.mcvideo-ue-config+xml, application/vnd.3gpp.mcvideo-user-profile+xml, application/vnd.3gpp.mid-call+xml, application/vnd.3gpp.pic-bw-large, application/vnd.3gpp.pic-bw-small, application/vnd.3gpp.pic-bw-var, application/vnd.3gpp.sms, application/vnd.3gpp.sms+xml, application/vnd.3gpp.srvcc-ext+xml, application/vnd.3gpp.srvcc-info+xml, application/vnd.3gpp.state-and-event-info+xml, application/vnd.3gpp.ussd+xml, application/vnd.3gpp2.bcmcsinfo+xml, application/vnd.3gpp2.sms, application/vnd.3gpp2.tcap, application/vnd.3lightssoftware.imagescal, application/vnd.3m.post-it-notes, application/vnd.accpac.simply.aso, application/vnd.accpac.simply.imp, application/vnd.acucobol, application/vnd.acucorp, application/vnd.adobe.air-application-installer-package+zip, application/vnd.adobe.flash.movie, application/vnd.adobe.formscentral.fcdt, application/vnd.adobe.fxp, application/vnd.adobe.partial-upload, application/vnd.adobe.xdp+xml, application/vnd.adobe.xfdf, application/vnd.aether.imp, application/vnd.afpc.afplinedata, application/vnd.afpc.modca, application/vnd.ah-barcode, application/vnd.ahead.space, application/vnd.airzip.filesecure.azf, application/vnd.airzip.filesecure.azs, application/vnd.amadeus+json, application/vnd.amazon.ebook, application/vnd.amazon.mobi8-ebook, application/vnd.americandynamics.acc, application/vnd.amiga.ami, application/vnd.amundsen.maze+xml, application/vnd.android.ota, application/vnd.android.package-archive, application/vnd.anki, application/vnd.anser-web-certificate-issue-initiation, application/vnd.anser-web-funds-transfer-initiation, application/vnd.antix.game-component, application/vnd.apache.thrift.binary, application/vnd.apache.thrift.compact, application/vnd.apache.thrift.json, application/vnd.api+json, application/vnd.apothekende.reservation+json, application/vnd.apple.installer+xml, application/vnd.apple.keynote, application/vnd.apple.mpegurl, application/vnd.apple.numbers, application/vnd.apple.pages, application/vnd.apple.pkpass, application/vnd.arastra.swi, application/vnd.aristanetworks.swi, application/vnd.artisan+json, application/vnd.artsquare, application/vnd.astraea-software.iota, application/vnd.audiograph, application/vnd.autopackage, application/vnd.avalon+json, application/vnd.avistar+xml, application/vnd.balsamiq.bmml+xml, application/vnd.balsamiq.bmpr, application/vnd.banana-accounting, application/vnd.bbf.usp.error, application/vnd.bbf.usp.msg, application/vnd.bbf.usp.msg+json, application/vnd.bekitzur-stech+json, application/vnd.bint.med-content, application/vnd.biopax.rdf+xml, application/vnd.blink-idb-value-wrapper, application/vnd.blueice.multipass, application/vnd.bluetooth.ep.oob, application/vnd.bluetooth.le.oob, application/vnd.bmi, application/vnd.bpf, application/vnd.bpf3, application/vnd.businessobjects, application/vnd.byu.uapi+json, application/vnd.cab-jscript, application/vnd.canon-cpdl, application/vnd.canon-lips, application/vnd.capasystems-pg+json, application/vnd.cendio.thinlinc.clientconf, application/vnd.century-systems.tcp_stream, application/vnd.chemdraw+xml, application/vnd.chess-pgn, application/vnd.chipnuts.karaoke-mmd, application/vnd.ciedi, application/vnd.cinderella, application/vnd.cirpack.isdn-ext, application/vnd.citationstyles.style+xml, application/vnd.claymore, application/vnd.cloanto.rp9, application/vnd.clonk.c4group, application/vnd.cluetrust.cartomobile-config, application/vnd.cluetrust.cartomobile-config-pkg, application/vnd.coffeescript, application/vnd.collabio.xodocuments.document, application/vnd.collabio.xodocuments.document-template, application/vnd.collabio.xodocuments.presentation, application/vnd.collabio.xodocuments.presentation-template, application/vnd.collabio.xodocuments.spreadsheet, application/vnd.collabio.xodocuments.spreadsheet-template, application/vnd.collection+json, application/vnd.collection.doc+json, application/vnd.collection.next+json, application/vnd.comicbook+zip, application/vnd.comicbook-rar, application/vnd.commerce-battelle, application/vnd.commonspace, application/vnd.contact.cmsg, application/vnd.coreos.ignition+json, application/vnd.cosmocaller, application/vnd.crick.clicker, application/vnd.crick.clicker.keyboard, application/vnd.crick.clicker.palette, application/vnd.crick.clicker.template, application/vnd.crick.clicker.wordbank, application/vnd.criticaltools.wbs+xml, application/vnd.cryptii.pipe+json, application/vnd.crypto-shade-file, application/vnd.ctc-posml, application/vnd.ctct.ws+xml, application/vnd.cups-pdf, application/vnd.cups-postscript, application/vnd.cups-ppd, application/vnd.cups-raster, application/vnd.cups-raw, application/vnd.curl, application/vnd.curl.car, application/vnd.curl.pcurl, application/vnd.cyan.dean.root+xml, application/vnd.cybank, application/vnd.d2l.coursepackage1p0+zip, application/vnd.dart, application/vnd.data-vision.rdz, application/vnd.datapackage+json, application/vnd.dataresource+json, application/vnd.debian.binary-package, application/vnd.dece.data, application/vnd.dece.ttml+xml, application/vnd.dece.unspecified, application/vnd.dece.zip, application/vnd.denovo.fcselayout-link, application/vnd.desmume.movie, application/vnd.dir-bi.plate-dl-nosuffix, application/vnd.dm.delegation+xml, application/vnd.dna, application/vnd.document+json, application/vnd.dolby.mlp, application/vnd.dolby.mobile.1, application/vnd.dolby.mobile.2, application/vnd.doremir.scorecloud-binary-document, application/vnd.dpgraph, application/vnd.dreamfactory, application/vnd.drive+json, application/vnd.ds-keypoint, application/vnd.dtg.local, application/vnd.dtg.local.flash, application/vnd.dtg.local.html, application/vnd.dvb.ait, application/vnd.dvb.dvbj, application/vnd.dvb.esgcontainer, application/vnd.dvb.ipdcdftnotifaccess, application/vnd.dvb.ipdcesgaccess, application/vnd.dvb.ipdcesgaccess2, application/vnd.dvb.ipdcesgpdd, application/vnd.dvb.ipdcroaming, application/vnd.dvb.iptv.alfec-base, application/vnd.dvb.iptv.alfec-enhancement, application/vnd.dvb.notif-aggregate-root+xml, application/vnd.dvb.notif-container+xml, application/vnd.dvb.notif-generic+xml, application/vnd.dvb.notif-ia-msglist+xml, application/vnd.dvb.notif-ia-registration-request+xml, application/vnd.dvb.notif-ia-registration-response+xml, application/vnd.dvb.notif-init+xml, application/vnd.dvb.pfr, application/vnd.dvb.service, application/vnd.dxr, application/vnd.dynageo, application/vnd.dzr, application/vnd.easykaraoke.cdgdownload, application/vnd.ecdis-update, application/vnd.ecip.rlp, application/vnd.ecowin.chart, application/vnd.ecowin.filerequest, application/vnd.ecowin.fileupdate, application/vnd.ecowin.series, application/vnd.ecowin.seriesrequest, application/vnd.ecowin.seriesupdate, application/vnd.efi.img, application/vnd.efi.iso, application/vnd.emclient.accessrequest+xml, application/vnd.enliven, application/vnd.enphase.envoy, application/vnd.eprints.data+xml, application/vnd.epson.esf, application/vnd.epson.msf, application/vnd.epson.quickanime, application/vnd.epson.salt, application/vnd.epson.ssf, application/vnd.ericsson.quickcall, application/vnd.espass-espass+zip, application/vnd.eszigno3+xml, application/vnd.etsi.aoc+xml, application/vnd.etsi.asic-e+zip, application/vnd.etsi.asic-s+zip, application/vnd.etsi.cug+xml, application/vnd.etsi.iptvcommand+xml, application/vnd.etsi.iptvdiscovery+xml, application/vnd.etsi.iptvprofile+xml, application/vnd.etsi.iptvsad-bc+xml, application/vnd.etsi.iptvsad-cod+xml, application/vnd.etsi.iptvsad-npvr+xml, application/vnd.etsi.iptvservice+xml, application/vnd.etsi.iptvsync+xml, application/vnd.etsi.iptvueprofile+xml, application/vnd.etsi.mcid+xml, application/vnd.etsi.mheg5, application/vnd.etsi.overload-control-policy-dataset+xml, application/vnd.etsi.pstn+xml, application/vnd.etsi.sci+xml, application/vnd.etsi.simservs+xml, application/vnd.etsi.timestamp-token, application/vnd.etsi.tsl+xml, application/vnd.etsi.tsl.der, application/vnd.eudora.data, application/vnd.evolv.ecig.profile, application/vnd.evolv.ecig.settings, application/vnd.evolv.ecig.theme, application/vnd.exstream-empower+zip, application/vnd.exstream-package, application/vnd.ezpix-album, application/vnd.ezpix-package, application/vnd.f-secure.mobile, application/vnd.fastcopy-disk-image, application/vnd.fdf, application/vnd.fdsn.mseed, application/vnd.fdsn.seed, application/vnd.ffsns, application/vnd.ficlab.flb+zip, application/vnd.filmit.zfc, application/vnd.fints, application/vnd.firemonkeys.cloudcell, application/vnd.flographit, application/vnd.fluxtime.clip, application/vnd.font-fontforge-sfd, application/vnd.framemaker, application/vnd.frogans.fnc, application/vnd.frogans.ltf, application/vnd.fsc.weblaunch, application/vnd.fujitsu.oasys, application/vnd.fujitsu.oasys2, application/vnd.fujitsu.oasys3, application/vnd.fujitsu.oasysgp, application/vnd.fujitsu.oasysprs, application/vnd.fujixerox.art-ex, application/vnd.fujixerox.art4, application/vnd.fujixerox.ddd, application/vnd.fujixerox.docuworks, application/vnd.fujixerox.docuworks.binder, application/vnd.fujixerox.docuworks.container, application/vnd.fujixerox.hbpl, application/vnd.fut-misnet, application/vnd.futoin+cbor, application/vnd.futoin+json, application/vnd.fuzzysheet, application/vnd.genomatix.tuxedo, application/vnd.geo+json, application/vnd.geocube+xml, application/vnd.geogebra.file, application/vnd.geogebra.tool, application/vnd.geometry-explorer, application/vnd.geonext, application/vnd.geoplan, application/vnd.geospace, application/vnd.gerber, application/vnd.globalplatform.card-content-mgt, application/vnd.globalplatform.card-content-mgt-response, application/vnd.gmx, application/vnd.google-apps.document, application/vnd.google-apps.presentation, application/vnd.google-apps.spreadsheet, application/vnd.google-earth.kml+xml, application/vnd.google-earth.kmz, application/vnd.gov.sk.e-form+xml, application/vnd.gov.sk.e-form+zip, application/vnd.gov.sk.xmldatacontainer+xml, application/vnd.grafeq, application/vnd.gridmp, application/vnd.groove-account, application/vnd.groove-help, application/vnd.groove-identity-message, application/vnd.groove-injector, application/vnd.groove-tool-message, application/vnd.groove-tool-template, application/vnd.groove-vcard, application/vnd.hal+json, application/vnd.hal+xml, application/vnd.handheld-entertainment+xml, application/vnd.hbci, application/vnd.hc+json, application/vnd.hcl-bireports, application/vnd.hdt, application/vnd.heroku+json, application/vnd.hhe.lesson-player, application/vnd.hp-hpgl, application/vnd.hp-hpid, application/vnd.hp-hps, application/vnd.hp-jlyt, application/vnd.hp-pcl, application/vnd.hp-pclxl, application/vnd.httphone, application/vnd.hydrostatix.sof-data, application/vnd.hyper+json, application/vnd.hyper-item+json, application/vnd.hyperdrive+json, application/vnd.hzn-3d-crossword, application/vnd.ibm.afplinedata, application/vnd.ibm.electronic-media, application/vnd.ibm.minipay, application/vnd.ibm.modcap, application/vnd.ibm.rights-management, application/vnd.ibm.secure-container, application/vnd.iccprofile, application/vnd.ieee.1905, application/vnd.igloader, application/vnd.imagemeter.folder+zip, application/vnd.imagemeter.image+zip, application/vnd.immervision-ivp, application/vnd.immervision-ivu, application/vnd.ims.imsccv1p1, application/vnd.ims.imsccv1p2, application/vnd.ims.imsccv1p3, application/vnd.ims.lis.v2.result+json, application/vnd.ims.lti.v2.toolconsumerprofile+json, application/vnd.ims.lti.v2.toolproxy+json, application/vnd.ims.lti.v2.toolproxy.id+json, application/vnd.ims.lti.v2.toolsettings+json, application/vnd.ims.lti.v2.toolsettings.simple+json, application/vnd.informedcontrol.rms+xml, application/vnd.informix-visionary, application/vnd.infotech.project, application/vnd.infotech.project+xml, application/vnd.innopath.wamp.notification, application/vnd.insors.igm, application/vnd.intercon.formnet, application/vnd.intergeo, application/vnd.intertrust.digibox, application/vnd.intertrust.nncp, application/vnd.intu.qbo, application/vnd.intu.qfx, application/vnd.iptc.g2.catalogitem+xml, application/vnd.iptc.g2.conceptitem+xml, application/vnd.iptc.g2.knowledgeitem+xml, application/vnd.iptc.g2.newsitem+xml, application/vnd.iptc.g2.newsmessage+xml, application/vnd.iptc.g2.packageitem+xml, application/vnd.iptc.g2.planningitem+xml, application/vnd.ipunplugged.rcprofile, application/vnd.irepository.package+xml, application/vnd.is-xpr, application/vnd.isac.fcs, application/vnd.iso11783-10+zip, application/vnd.jam, application/vnd.japannet-directory-service, application/vnd.japannet-jpnstore-wakeup, application/vnd.japannet-payment-wakeup, application/vnd.japannet-registration, application/vnd.japannet-registration-wakeup, application/vnd.japannet-setstore-wakeup, application/vnd.japannet-verification, application/vnd.japannet-verification-wakeup, application/vnd.jcp.javame.midlet-rms, application/vnd.jisp, application/vnd.joost.joda-archive, application/vnd.jsk.isdn-ngn, application/vnd.kahootz, application/vnd.kde.karbon, application/vnd.kde.kchart, application/vnd.kde.kformula, application/vnd.kde.kivio, application/vnd.kde.kontour, application/vnd.kde.kpresenter, application/vnd.kde.kspread, application/vnd.kde.kword, application/vnd.kenameaapp, application/vnd.kidspiration, application/vnd.kinar, application/vnd.koan, application/vnd.kodak-descriptor, application/vnd.las, application/vnd.las.las+json, application/vnd.las.las+xml, application/vnd.laszip, application/vnd.leap+json, application/vnd.liberty-request+xml, application/vnd.llamagraphics.life-balance.desktop, application/vnd.llamagraphics.life-balance.exchange+xml, application/vnd.logipipe.circuit+zip, application/vnd.loom, application/vnd.lotus-1-2-3, application/vnd.lotus-approach, application/vnd.lotus-freelance, application/vnd.lotus-notes, application/vnd.lotus-organizer, application/vnd.lotus-screencam, application/vnd.lotus-wordpro, application/vnd.macports.portpkg, application/vnd.mapbox-vector-tile, application/vnd.marlin.drm.actiontoken+xml, application/vnd.marlin.drm.conftoken+xml, application/vnd.marlin.drm.license+xml, application/vnd.marlin.drm.mdcf, application/vnd.mason+json, application/vnd.maxmind.maxmind-db, application/vnd.mcd, application/vnd.medcalcdata, application/vnd.mediastation.cdkey, application/vnd.meridian-slingshot, application/vnd.mfer, application/vnd.mfmp, application/vnd.micro+json, application/vnd.micrografx.flo, application/vnd.micrografx.igx, application/vnd.microsoft.portable-executable, application/vnd.microsoft.windows.thumbnail-cache, application/vnd.miele+json, application/vnd.mif, application/vnd.minisoft-hp3000-save, application/vnd.mitsubishi.misty-guard.trustweb, application/vnd.mobius.daf, application/vnd.mobius.dis, application/vnd.mobius.mbk, application/vnd.mobius.mqy, application/vnd.mobius.msl, application/vnd.mobius.plc, application/vnd.mobius.txf, application/vnd.mophun.application, application/vnd.mophun.certificate, application/vnd.motorola.flexsuite, application/vnd.motorola.flexsuite.adsi, application/vnd.motorola.flexsuite.fis, application/vnd.motorola.flexsuite.gotap, application/vnd.motorola.flexsuite.kmr, application/vnd.motorola.flexsuite.ttc, application/vnd.motorola.flexsuite.wem, application/vnd.motorola.iprm, application/vnd.mozilla.xul+xml, application/vnd.ms-3mfdocument, application/vnd.ms-artgalry, application/vnd.ms-asf, application/vnd.ms-cab-compressed, application/vnd.ms-color.iccprofile, application/vnd.ms-excel, application/vnd.ms-excel.addin.macroenabled.12, application/vnd.ms-excel.sheet.binary.macroenabled.12, application/vnd.ms-excel.sheet.macroenabled.12, application/vnd.ms-excel.template.macroenabled.12, application/vnd.ms-fontobject, application/vnd.ms-htmlhelp, application/vnd.ms-ims, application/vnd.ms-lrm, application/vnd.ms-office.activex+xml, application/vnd.ms-officetheme, application/vnd.ms-opentype, application/vnd.ms-outlook, application/vnd.ms-package.obfuscated-opentype, application/vnd.ms-pki.seccat, application/vnd.ms-pki.stl, application/vnd.ms-playready.initiator+xml, application/vnd.ms-powerpoint, application/vnd.ms-powerpoint.addin.macroenabled.12, application/vnd.ms-powerpoint.presentation.macroenabled.12, application/vnd.ms-powerpoint.slide.macroenabled.12, application/vnd.ms-powerpoint.slideshow.macroenabled.12, application/vnd.ms-powerpoint.template.macroenabled.12, application/vnd.ms-printdevicecapabilities+xml, application/vnd.ms-printing.printticket+xml, application/vnd.ms-printschematicket+xml, application/vnd.ms-project, application/vnd.ms-tnef, application/vnd.ms-windows.devicepairing, application/vnd.ms-windows.nwprinting.oob, application/vnd.ms-windows.printerpairing, application/vnd.ms-windows.wsd.oob, application/vnd.ms-wmdrm.lic-chlg-req, application/vnd.ms-wmdrm.lic-resp, application/vnd.ms-wmdrm.meter-chlg-req, application/vnd.ms-wmdrm.meter-resp, application/vnd.ms-word.document.macroenabled.12, application/vnd.ms-word.template.macroenabled.12, application/vnd.ms-works, application/vnd.ms-wpl, application/vnd.ms-xpsdocument, application/vnd.msa-disk-image, application/vnd.mseq, application/vnd.msign, application/vnd.multiad.creator, application/vnd.multiad.creator.cif, application/vnd.music-niff, application/vnd.musician, application/vnd.muvee.style, application/vnd.mynfc, application/vnd.ncd.control, application/vnd.ncd.reference, application/vnd.nearst.inv+json, application/vnd.nervana, application/vnd.netfpx, application/vnd.neurolanguage.nlu, application/vnd.nimn, application/vnd.nintendo.nitro.rom, application/vnd.nintendo.snes.rom, application/vnd.nitf, application/vnd.noblenet-directory, application/vnd.noblenet-sealer, application/vnd.noblenet-web, application/vnd.nokia.catalogs, application/vnd.nokia.conml+wbxml, application/vnd.nokia.conml+xml, application/vnd.nokia.iptv.config+xml, application/vnd.nokia.isds-radio-presets, application/vnd.nokia.landmark+wbxml, application/vnd.nokia.landmark+xml, application/vnd.nokia.landmarkcollection+xml, application/vnd.nokia.n-gage.ac+xml, application/vnd.nokia.n-gage.data, application/vnd.nokia.n-gage.symbian.install, application/vnd.nokia.ncd, application/vnd.nokia.pcd+wbxml, application/vnd.nokia.pcd+xml, application/vnd.nokia.radio-preset, application/vnd.nokia.radio-presets, application/vnd.novadigm.edm, application/vnd.novadigm.edx, application/vnd.novadigm.ext, application/vnd.ntt-local.content-share, application/vnd.ntt-local.file-transfer, application/vnd.ntt-local.ogw_remote-access, application/vnd.ntt-local.sip-ta_remote, application/vnd.ntt-local.sip-ta_tcp_stream, application/vnd.oasis.opendocument.chart, application/vnd.oasis.opendocument.chart-template, application/vnd.oasis.opendocument.database, application/vnd.oasis.opendocument.formula, application/vnd.oasis.opendocument.formula-template, application/vnd.oasis.opendocument.graphics, application/vnd.oasis.opendocument.graphics-template, application/vnd.oasis.opendocument.image, application/vnd.oasis.opendocument.image-template, application/vnd.oasis.opendocument.presentation, application/vnd.oasis.opendocument.presentation-template, application/vnd.oasis.opendocument.spreadsheet, application/vnd.oasis.opendocument.spreadsheet-template, application/vnd.oasis.opendocument.text, application/vnd.oasis.opendocument.text-master, application/vnd.oasis.opendocument.text-template, application/vnd.oasis.opendocument.text-web, application/vnd.obn, application/vnd.ocf+cbor, application/vnd.oftn.l10n+json, application/vnd.oipf.contentaccessdownload+xml, application/vnd.oipf.contentaccessstreaming+xml, application/vnd.oipf.cspg-hexbinary, application/vnd.oipf.dae.svg+xml, application/vnd.oipf.dae.xhtml+xml, application/vnd.oipf.mippvcontrolmessage+xml, application/vnd.oipf.pae.gem, application/vnd.oipf.spdiscovery+xml, application/vnd.oipf.spdlist+xml, application/vnd.oipf.ueprofile+xml, application/vnd.oipf.userprofile+xml, application/vnd.olpc-sugar, application/vnd.oma-scws-config, application/vnd.oma-scws-http-request, application/vnd.oma-scws-http-response, application/vnd.oma.bcast.associated-procedure-parameter+xml, application/vnd.oma.bcast.drm-trigger+xml, application/vnd.oma.bcast.imd+xml, application/vnd.oma.bcast.ltkm, application/vnd.oma.bcast.notification+xml, application/vnd.oma.bcast.provisioningtrigger, application/vnd.oma.bcast.sgboot, application/vnd.oma.bcast.sgdd+xml, application/vnd.oma.bcast.sgdu, application/vnd.oma.bcast.simple-symbol-container, application/vnd.oma.bcast.smartcard-trigger+xml, application/vnd.oma.bcast.sprov+xml, application/vnd.oma.bcast.stkm, application/vnd.oma.cab-address-book+xml, application/vnd.oma.cab-feature-handler+xml, application/vnd.oma.cab-pcc+xml, application/vnd.oma.cab-subs-invite+xml, application/vnd.oma.cab-user-prefs+xml, application/vnd.oma.dcd, application/vnd.oma.dcdc, application/vnd.oma.dd2+xml, application/vnd.oma.drm.risd+xml, application/vnd.oma.group-usage-list+xml, application/vnd.oma.lwm2m+json, application/vnd.oma.lwm2m+tlv, application/vnd.oma.pal+xml, application/vnd.oma.poc.detailed-progress-report+xml, application/vnd.oma.poc.final-report+xml, application/vnd.oma.poc.groups+xml, application/vnd.oma.poc.invocation-descriptor+xml, application/vnd.oma.poc.optimized-progress-report+xml, application/vnd.oma.push, application/vnd.oma.scidm.messages+xml, application/vnd.oma.xcap-directory+xml, application/vnd.omads-email+xml, application/vnd.omads-file+xml, application/vnd.omads-folder+xml, application/vnd.omaloc-supl-init, application/vnd.onepager, application/vnd.onepagertamp, application/vnd.onepagertamx, application/vnd.onepagertat, application/vnd.onepagertatp, application/vnd.onepagertatx, application/vnd.openblox.game+xml, application/vnd.openblox.game-binary, application/vnd.openeye.oeb, application/vnd.openofficeorg.extension, application/vnd.openstreetmap.data+xml, application/vnd.openxmlformats-officedocument.custom-properties+xml, application/vnd.openxmlformats-officedocument.customxmlproperties+xml, application/vnd.openxmlformats-officedocument.drawing+xml, application/vnd.openxmlformats-officedocument.drawingml.chart+xml, application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml, application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml, application/vnd.openxmlformats-officedocument.extended-properties+xml, application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml, application/vnd.openxmlformats-officedocument.presentationml.comments+xml, application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml, application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml, application/vnd.openxmlformats-officedocument.presentationml.presentation, application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml, application/vnd.openxmlformats-officedocument.presentationml.presprops+xml, application/vnd.openxmlformats-officedocument.presentationml.slide, application/vnd.openxmlformats-officedocument.presentationml.slide+xml, application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml, application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml, application/vnd.openxmlformats-officedocument.presentationml.slideshow, application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml, application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml, application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml, application/vnd.openxmlformats-officedocument.presentationml.tags+xml, application/vnd.openxmlformats-officedocument.presentationml.template, application/vnd.openxmlformats-officedocument.presentationml.template.main+xml, application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.template, application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml, application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml, application/vnd.openxmlformats-officedocument.theme+xml, application/vnd.openxmlformats-officedocument.themeoverride+xml, application/vnd.openxmlformats-officedocument.vmldrawing, application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document, application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.template, application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml, application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml, application/vnd.openxmlformats-package.core-properties+xml, application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml, application/vnd.openxmlformats-package.relationships+xml, application/vnd.oracle.resource+json, application/vnd.orange.indata, application/vnd.osa.netdeploy, application/vnd.osgeo.mapguide.package, application/vnd.osgi.bundle, application/vnd.osgi.dp, application/vnd.osgi.subsystem, application/vnd.otps.ct-kip+xml, application/vnd.oxli.countgraph, application/vnd.pagerduty+json, application/vnd.palm, application/vnd.panoply, application/vnd.paos.xml, application/vnd.patentdive, application/vnd.patientecommsdoc, application/vnd.pawaafile, application/vnd.pcos, application/vnd.pg.format, application/vnd.pg.osasli, application/vnd.piaccess.application-licence, application/vnd.picsel, application/vnd.pmi.widget, application/vnd.poc.group-advertisement+xml, application/vnd.pocketlearn, application/vnd.powerbuilder6, application/vnd.powerbuilder6-s, application/vnd.powerbuilder7, application/vnd.powerbuilder7-s, application/vnd.powerbuilder75, application/vnd.powerbuilder75-s, application/vnd.preminet, application/vnd.previewsystems.box, application/vnd.proteus.magazine, application/vnd.psfs, application/vnd.publishare-delta-tree, application/vnd.pvi.ptid1, application/vnd.pwg-multiplexed, application/vnd.pwg-xhtml-print+xml, application/vnd.qualcomm.brew-app-res, application/vnd.quarantainenet, application/vnd.quark.quarkxpress, application/vnd.quobject-quoxdocument, application/vnd.radisys.moml+xml, application/vnd.radisys.msml+xml, application/vnd.radisys.msml-audit+xml, application/vnd.radisys.msml-audit-conf+xml, application/vnd.radisys.msml-audit-conn+xml, application/vnd.radisys.msml-audit-dialog+xml, application/vnd.radisys.msml-audit-stream+xml, application/vnd.radisys.msml-conf+xml, application/vnd.radisys.msml-dialog+xml, application/vnd.radisys.msml-dialog-base+xml, application/vnd.radisys.msml-dialog-fax-detect+xml, application/vnd.radisys.msml-dialog-fax-sendrecv+xml, application/vnd.radisys.msml-dialog-group+xml, application/vnd.radisys.msml-dialog-speech+xml, application/vnd.radisys.msml-dialog-transform+xml, application/vnd.rainstor.data, application/vnd.rapid, application/vnd.rar, application/vnd.realvnc.bed, application/vnd.recordare.musicxml, application/vnd.recordare.musicxml+xml, application/vnd.renlearn.rlprint, application/vnd.restful+json, application/vnd.rig.cryptonote, application/vnd.rim.cod, application/vnd.rn-realmedia, application/vnd.rn-realmedia-vbr, application/vnd.route66.link66+xml, application/vnd.rs-274x, application/vnd.ruckus.download, application/vnd.s3sms, application/vnd.sailingtracker.track, application/vnd.sbm.cid, application/vnd.sbm.mid2, application/vnd.scribus, application/vnd.sealed.3df, application/vnd.sealed.csf, application/vnd.sealed.doc, application/vnd.sealed.eml, application/vnd.sealed.mht, application/vnd.sealed.net, application/vnd.sealed.ppt, application/vnd.sealed.tiff, application/vnd.sealed.xls, application/vnd.sealedmedia.softseal.html, application/vnd.sealedmedia.softseal.pdf, application/vnd.seemail, application/vnd.sema, application/vnd.semd, application/vnd.semf, application/vnd.shade-save-file, application/vnd.shana.informed.formdata, application/vnd.shana.informed.formtemplate, application/vnd.shana.informed.interchange, application/vnd.shana.informed.package, application/vnd.shootproof+json, application/vnd.shopkick+json, application/vnd.sigrok.session, application/vnd.simtech-mindmapper, application/vnd.siren+json, application/vnd.smaf, application/vnd.smart.notebook, application/vnd.smart.teacher, application/vnd.software602.filler.form+xml, application/vnd.software602.filler.form-xml-zip, application/vnd.solent.sdkm+xml, application/vnd.spotfire.dxp, application/vnd.spotfire.sfs, application/vnd.sqlite3, application/vnd.sss-cod, application/vnd.sss-dtf, application/vnd.sss-ntf, application/vnd.stardivision.calc, application/vnd.stardivision.draw, application/vnd.stardivision.impress, application/vnd.stardivision.math, application/vnd.stardivision.writer, application/vnd.stardivision.writer-global, application/vnd.stepmania.package, application/vnd.stepmania.stepchart, application/vnd.street-stream, application/vnd.sun.wadl+xml, application/vnd.sun.xml.calc, application/vnd.sun.xml.calc.template, application/vnd.sun.xml.draw, application/vnd.sun.xml.draw.template, application/vnd.sun.xml.impress, application/vnd.sun.xml.impress.template, application/vnd.sun.xml.math, application/vnd.sun.xml.writer, application/vnd.sun.xml.writer.global, application/vnd.sun.xml.writer.template, application/vnd.sus-calendar, application/vnd.svd, application/vnd.swiftview-ics, application/vnd.symbian.install, application/vnd.syncml+xml, application/vnd.syncml.dm+wbxml, application/vnd.syncml.dm+xml, application/vnd.syncml.dm.notification, application/vnd.syncml.dmddf+wbxml, application/vnd.syncml.dmddf+xml, application/vnd.syncml.dmtnds+wbxml, application/vnd.syncml.dmtnds+xml, application/vnd.syncml.ds.notification, application/vnd.tableschema+json, application/vnd.tao.intent-module-archive, application/vnd.tcpdump.pcap, application/vnd.think-cell.ppttc+json, application/vnd.tmd.mediaflex.api+xml, application/vnd.tml, application/vnd.tmobile-livetv, application/vnd.tri.onesource, application/vnd.trid.tpt, application/vnd.triscape.mxs, application/vnd.trueapp, application/vnd.truedoc, application/vnd.ubisoft.webplayer, application/vnd.ufdl, application/vnd.uiq.theme, application/vnd.umajin, application/vnd.unity, application/vnd.uoml+xml, application/vnd.uplanet.alert, application/vnd.uplanet.alert-wbxml, application/vnd.uplanet.bearer-choice, application/vnd.uplanet.bearer-choice-wbxml, application/vnd.uplanet.cacheop, application/vnd.uplanet.cacheop-wbxml, application/vnd.uplanet.channel, application/vnd.uplanet.channel-wbxml, application/vnd.uplanet.list, application/vnd.uplanet.list-wbxml, application/vnd.uplanet.listcmd, application/vnd.uplanet.listcmd-wbxml, application/vnd.uplanet.signal, application/vnd.uri-map, application/vnd.valve.source.material, application/vnd.vcx, application/vnd.vd-study, application/vnd.vectorworks, application/vnd.vel+json, application/vnd.verimatrix.vcas, application/vnd.veryant.thin, application/vnd.ves.encrypted, application/vnd.vidsoft.vidconference, application/vnd.visio, application/vnd.visionary, application/vnd.vividence.scriptfile, application/vnd.vsf, application/vnd.wap.sic, application/vnd.wap.slc, application/vnd.wap.wbxml, application/vnd.wap.wmlc, application/vnd.wap.wmlscriptc, application/vnd.webturbo, application/vnd.wfa.p2p, application/vnd.wfa.wsc, application/vnd.windows.devicepairing, application/vnd.wmc, application/vnd.wmf.bootstrap, application/vnd.wolfram.mathematica, application/vnd.wolfram.mathematica.package, application/vnd.wolfram.player, application/vnd.wordperfect, application/vnd.wqd, application/vnd.wrq-hp3000-labelled, application/vnd.wt.stf, application/vnd.wv.csp+wbxml, application/vnd.wv.csp+xml, application/vnd.wv.ssp+xml, application/vnd.xacml+json, application/vnd.xara, application/vnd.xfdl, application/vnd.xfdl.webform, application/vnd.xmi+xml, application/vnd.xmpie.cpkg, application/vnd.xmpie.dpkg, application/vnd.xmpie.plan, application/vnd.xmpie.ppkg, application/vnd.xmpie.xlim, application/vnd.yamaha.hv-dic, application/vnd.yamaha.hv-script, application/vnd.yamaha.hv-voice, application/vnd.yamaha.openscoreformat, application/vnd.yamaha.openscoreformat.osfpvg+xml, application/vnd.yamaha.remote-setup, application/vnd.yamaha.smaf-audio, application/vnd.yamaha.smaf-phrase, application/vnd.yamaha.through-ngn, application/vnd.yamaha.tunnel-udpencap, application/vnd.yaoweme, application/vnd.yellowriver-custom-menu, application/vnd.youtube.yt, application/vnd.zul, application/vnd.zzazz.deck+xml, application/voicexml+xml, application/voucher-cms+json, application/vq-rtcpxr, application/wasm, application/watcherinfo+xml, application/webpush-options+json, application/whoispp-query, application/whoispp-response, application/widget, application/winhlp, application/wita, application/wordperfect5.1, application/wsdl+xml, application/wspolicy+xml, application/x-7z-compressed, application/x-abiword, application/x-ace-compressed, application/x-amf, application/x-apple-diskimage, application/x-arj, application/x-authorware-bin, application/x-authorware-map, application/x-authorware-seg, application/x-bcpio, application/x-bdoc, application/x-bittorrent, application/x-blorb, application/x-bzip, application/x-bzip2, application/x-cbr, application/x-cdlink, application/x-cfs-compressed, application/x-chat, application/x-chess-pgn, application/x-chrome-extension, application/x-cocoa, application/x-compress, application/x-conference, application/x-cpio, application/x-csh, application/x-deb, application/x-debian-package, application/x-dgc-compressed, application/x-director, application/x-doom, application/x-dtbncx+xml, application/x-dtbook+xml, application/x-dtbresource+xml, application/x-dvi, application/x-envoy, application/x-eva, application/x-font-bdf, application/x-font-dos, application/x-font-framemaker, application/x-font-ghostscript, application/x-font-libgrx, application/x-font-linux-psf, application/x-font-pcf, application/x-font-snf, application/x-font-speedo, application/x-font-sunos-news, application/x-font-type1, application/x-font-vfont, application/x-freearc, application/x-futuresplash, application/x-gca-compressed, application/x-glulx, application/x-gnumeric, application/x-gramps-xml, application/x-gtar, application/x-gzip, application/x-hdf, application/x-httpd-php, application/x-install-instructions, application/x-iso9660-image, application/x-java-archive-diff, application/x-java-jnlp-file, application/x-javascript, application/x-latex, application/x-lua-bytecode, application/x-lzh-compressed, application/x-makeself, application/x-mie, application/x-mobipocket-ebook, application/x-mpegurl, application/x-ms-application, application/x-ms-shortcut, application/x-ms-wmd, application/x-ms-wmz, application/x-ms-xbap, application/x-msaccess, application/x-msbinder, application/x-mscardfile, application/x-msclip, application/x-msdos-program, application/x-msdownload, application/x-msmediaview, application/x-msmetafile, application/x-msmoney, application/x-mspublisher, application/x-msschedule, application/x-msterminal, application/x-mswrite, application/x-netcdf, application/x-ns-proxy-autoconfig, application/x-nzb, application/x-perl, application/x-pilot, application/x-pkcs12, application/x-pkcs7-certificates, application/x-pkcs7-certreqresp, application/x-rar-compressed, application/x-redhat-package-manager, application/x-research-info-systems, application/x-sea, application/x-sh, application/x-shar, application/x-shockwave-flash, application/x-silverlight-app, application/x-sql, application/x-stuffit, application/x-stuffitx, application/x-subrip, application/x-sv4cpio, application/x-sv4crc, application/x-t3vm-image, application/x-tads, application/x-tar, application/x-tcl, application/x-tex, application/x-tex-tfm, application/x-texinfo, application/x-tgif, application/x-ustar, application/x-virtualbox-hdd, application/x-virtualbox-ova, application/x-virtualbox-ovf, application/x-virtualbox-vbox, application/x-virtualbox-vbox-extpack, application/x-virtualbox-vdi, application/x-virtualbox-vhd, application/x-virtualbox-vmdk, application/x-wais-source, application/x-web-app-manifest+json, application/x-www-form-urlencoded, application/x-x509-ca-cert, application/x-xfig, application/x-xliff+xml, application/x-xpinstall, application/x-xz, application/x-zmachine, application/x400-bp, application/xacml+xml, application/xaml+xml, application/xcap-att+xml, application/xcap-caps+xml, application/xcap-diff+xml, application/xcap-el+xml, application/xcap-error+xml, application/xcap-ns+xml, application/xcon-conference-info+xml, application/xcon-conference-info-diff+xml, application/xenc+xml, application/xhtml+xml, application/xhtml-voice+xml, application/xliff+xml, application/xml, application/xml-dtd, application/xml-external-parsed-entity, application/xml-patch+xml, application/xmpp+xml, application/xop+xml, application/xproc+xml, application/xslt+xml, application/xspf+xml, application/xv+xml, application/yang, application/yang-data+json, application/yang-data+xml, application/yang-patch+json, application/yang-patch+xml, application/yin+xml, application/zip, application/zlib, application/zstd, audio/1d-interleaved-parityfec, audio/32kadpcm, audio/3gpp, audio/3gpp2, audio/aac, audio/ac3, audio/adpcm, audio/amr, audio/amr-wb, audio/amr-wb+, audio/aptx, audio/asc, audio/atrac-advanced-lossless, audio/atrac-x, audio/atrac3, audio/basic, audio/bv16, audio/bv32, audio/clearmode, audio/cn, audio/dat12, audio/dls, audio/dsr-es201108, audio/dsr-es202050, audio/dsr-es202211, audio/dsr-es202212, audio/dv, audio/dvi4, audio/eac3, audio/encaprtp, audio/evrc, audio/evrc-qcp, audio/evrc0, audio/evrc1, audio/evrcb, audio/evrcb0, audio/evrcb1, audio/evrcnw, audio/evrcnw0, audio/evrcnw1, audio/evrcwb, audio/evrcwb0, audio/evrcwb1, audio/evs, audio/flexfec, audio/fwdred, audio/g711-0, audio/g719, audio/g722, audio/g7221, audio/g723, audio/g726-16, audio/g726-24, audio/g726-32, audio/g726-40, audio/g728, audio/g729, audio/g7291, audio/g729d, audio/g729e, audio/gsm, audio/gsm-efr, audio/gsm-hr-08, audio/ilbc, audio/ip-mr_v2.5, audio/isac, audio/l16, audio/l20, audio/l24, audio/l8, audio/lpc, audio/melp, audio/melp1200, audio/melp2400, audio/melp600, audio/midi, audio/mobile-xmf, audio/mp3, audio/mp4, audio/mp4a-latm, audio/mpa, audio/mpa-robust, audio/mpeg, audio/mpeg4-generic, audio/musepack, audio/ogg, audio/opus, audio/parityfec, audio/pcma, audio/pcma-wb, audio/pcmu, audio/pcmu-wb, audio/prs.sid, audio/qcelp, audio/raptorfec, audio/red, audio/rtp-enc-aescm128, audio/rtp-midi, audio/rtploopback, audio/rtx, audio/s3m, audio/silk, audio/smv, audio/smv-qcp, audio/smv0, audio/sp-midi, audio/speex, audio/t140c, audio/t38, audio/telephone-event, audio/tetra_acelp, audio/tone, audio/uemclip, audio/ulpfec, audio/usac, audio/vdvi, audio/vmr-wb, audio/vnd.3gpp.iufp, audio/vnd.4sb, audio/vnd.audiokoz, audio/vnd.celp, audio/vnd.cisco.nse, audio/vnd.cmles.radio-events, audio/vnd.cns.anp1, audio/vnd.cns.inf1, audio/vnd.dece.audio, audio/vnd.digital-winds, audio/vnd.dlna.adts, audio/vnd.dolby.heaac.1, audio/vnd.dolby.heaac.2, audio/vnd.dolby.mlp, audio/vnd.dolby.mps, audio/vnd.dolby.pl2, audio/vnd.dolby.pl2x, audio/vnd.dolby.pl2z, audio/vnd.dolby.pulse.1, audio/vnd.dra, audio/vnd.dts, audio/vnd.dts.hd, audio/vnd.dts.uhd, audio/vnd.dvb.file, audio/vnd.everad.plj, audio/vnd.hns.audio, audio/vnd.lucent.voice, audio/vnd.ms-playready.media.pya, audio/vnd.nokia.mobile-xmf, audio/vnd.nortel.vbk, audio/vnd.nuera.ecelp4800, audio/vnd.nuera.ecelp7470, audio/vnd.nuera.ecelp9600, audio/vnd.octel.sbc, audio/vnd.presonus.multitrack, audio/vnd.qcelp, audio/vnd.rhetorex.32kadpcm, audio/vnd.rip, audio/vnd.rn-realaudio, audio/vnd.sealedmedia.softseal.mpeg, audio/vnd.vmx.cvsd, audio/vnd.wave, audio/vorbis, audio/vorbis-config, audio/wav, audio/wave, audio/webm, audio/x-aac, audio/x-aiff, audio/x-caf, audio/x-flac, audio/x-m4a, audio/x-matroska, audio/x-mpegurl, audio/x-ms-wax, audio/x-ms-wma, audio/x-pn-realaudio, audio/x-pn-realaudio-plugin, audio/x-realaudio, audio/x-tta, audio/x-wav, audio/xm, chemical/x-cdx, chemical/x-cif, chemical/x-cmdf, chemical/x-cml, chemical/x-csml, chemical/x-pdb, chemical/x-xyz, font/collection, font/otf, font/sfnt, font/ttf, font/woff, font/woff2, image/aces, image/apng, image/avci, image/avcs, image/bmp, image/cgm, image/dicom-rle, image/emf, image/fits, image/g3fax, image/gif, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/hej2k, image/hsj2, image/ief, image/jls, image/jp2, image/jpeg, image/jph, image/jphc, image/jpm, image/jpx, image/jxr, image/jxra, image/jxrs, image/jxs, image/jxsc, image/jxsi, image/jxss, image/ktx, image/naplps, image/pjpeg, image/png, image/prs.btif, image/prs.pti, image/pwg-raster, image/sgi, image/svg+xml, image/t38, image/tiff, image/tiff-fx, image/vnd.adobe.photoshop, image/vnd.airzip.accelerator.azv, image/vnd.cns.inf2, image/vnd.dece.graphic, image/vnd.djvu, image/vnd.dvb.subtitle, image/vnd.dwg, image/vnd.dxf, image/vnd.fastbidsheet, image/vnd.fpx, image/vnd.fst, image/vnd.fujixerox.edmics-mmr, image/vnd.fujixerox.edmics-rlc, image/vnd.globalgraphics.pgb, image/vnd.microsoft.icon, image/vnd.mix, image/vnd.mozilla.apng, image/vnd.ms-dds, image/vnd.ms-modi, image/vnd.ms-photo, image/vnd.net-fpx, image/vnd.radiance, image/vnd.sealed.png, image/vnd.sealedmedia.softseal.gif, image/vnd.sealedmedia.softseal.jpg, image/vnd.svf, image/vnd.tencent.tap, image/vnd.valve.source.texture, image/vnd.wap.wbmp, image/vnd.xiff, image/vnd.zbrush.pcx, image/webp, image/wmf, image/x-3ds, image/x-cmu-raster, image/x-cmx, image/x-freehand, image/x-icon, image/x-jng, image/x-mrsid-image, image/x-ms-bmp, image/x-pcx, image/x-pict, image/x-portable-anymap, image/x-portable-bitmap, image/x-portable-graymap, image/x-portable-pixmap, image/x-rgb, image/x-tga, image/x-xbitmap, image/x-xcf, image/x-xpixmap, image/x-xwindowdump, message/cpim, message/delivery-status, message/disposition-notification, message/external-body, message/feedback-report, message/global, message/global-delivery-status, message/global-disposition-notification, message/global-headers, message/http, message/imdn+xml, message/news, message/partial, message/rfc822, message/s-http, message/sip, message/sipfrag, message/tracking-status, message/vnd.si.simp, message/vnd.wfa.wsc, model/3mf, model/gltf+json, model/gltf-binary, model/iges, model/mesh, model/stl, model/vnd.collada+xml, model/vnd.dwf, model/vnd.flatland.3dml, model/vnd.gdl, model/vnd.gs-gdl, model/vnd.gs.gdl, model/vnd.gtw, model/vnd.moml+xml, model/vnd.mts, model/vnd.opengex, model/vnd.parasolid.transmit.binary, model/vnd.parasolid.transmit.text, model/vnd.rosette.annotated-data-model, model/vnd.usdz+zip, model/vnd.valve.source.compiled-map, model/vnd.vtu, model/vrml, model/x3d+binary, model/x3d+fastinfoset, model/x3d+vrml, model/x3d+xml, model/x3d-vrml, multipart/alternative, multipart/appledouble, multipart/byteranges, multipart/digest, multipart/encrypted, multipart/form-data, multipart/header-set, multipart/mixed, multipart/multilingual, multipart/parallel, multipart/related, multipart/report, multipart/signed, multipart/vnd.bint.med-plus, multipart/voice-message, multipart/x-mixed-replace, text/1d-interleaved-parityfec, text/cache-manifest, text/calendar, text/calender, text/cmd, text/coffeescript, text/css, text/csv, text/csv-schema, text/directory, text/dns, text/ecmascript, text/encaprtp, text/enriched, text/flexfec, text/fwdred, text/grammar-ref-list, text/html, text/jade, text/javascript, text/jcr-cnd, text/jsx, text/less, text/markdown, text/mathml, text/mdx, text/mizar, text/n3, text/parameters, text/parityfec, text/plain, text/provenance-notation, text/prs.fallenstein.rst, text/prs.lines.tag, text/prs.prop.logic, text/raptorfec, text/red, text/rfc822-headers, text/richtext, text/rtf, text/rtp-enc-aescm128, text/rtploopback, text/rtx, text/sgml, text/shex, text/slim, text/strings, text/stylus, text/t140, text/tab-separated-values, text/troff, text/turtle, text/ulpfec, text/uri-list, text/vcard, text/vnd.a, text/vnd.abc, text/vnd.ascii-art, text/vnd.curl, text/vnd.curl.dcurl, text/vnd.curl.mcurl, text/vnd.curl.scurl, text/vnd.debian.copyright, text/vnd.dmclientscript, text/vnd.dvb.subtitle, text/vnd.esmertec.theme-descriptor, text/vnd.ficlab.flt, text/vnd.fly, text/vnd.fmi.flexstor, text/vnd.gml, text/vnd.graphviz, text/vnd.hgl, text/vnd.in3d.3dml, text/vnd.in3d.spot, text/vnd.iptc.newsml, text/vnd.iptc.nitf, text/vnd.latex-z, text/vnd.motorola.reflex, text/vnd.ms-mediapackage, text/vnd.net2phone.commcenter.command, text/vnd.radisys.msml-basic-layout, text/vnd.senx.warpscript, text/vnd.si.uricatalogue, text/vnd.sosi, text/vnd.sun.j2me.app-descriptor, text/vnd.trolltech.linguist, text/vnd.wap.si, text/vnd.wap.sl, text/vnd.wap.wml, text/vnd.wap.wmlscript, text/vtt, text/x-asm, text/x-c, text/x-component, text/x-fortran, text/x-gwt-rpc, text/x-handlebars-template, text/x-java-source, text/x-jquery-tmpl, text/x-lua, text/x-markdown, text/x-nfo, text/x-opml, text/x-org, text/x-pascal, text/x-processing, text/x-sass, text/x-scss, text/x-setext, text/x-sfv, text/x-suse-ymp, text/x-uuencode, text/x-vcalendar, text/x-vcard, text/xml, text/xml-external-parsed-entity, text/yaml, video/1d-interleaved-parityfec, video/3gpp, video/3gpp-tt, video/3gpp2, video/bmpeg, video/bt656, video/celb, video/dv, video/encaprtp, video/flexfec, video/h261, video/h263, video/h263-1998, video/h263-2000, video/h264, video/h264-rcdo, video/h264-svc, video/h265, video/iso.segment, video/jpeg, video/jpeg2000, video/jpm, video/mj2, video/mp1s, video/mp2p, video/mp2t, video/mp4, video/mp4v-es, video/mpeg, video/mpeg4-generic, video/mpv, video/nv, video/ogg, video/parityfec, video/pointer, video/quicktime, video/raptorfec, video/raw, video/rtp-enc-aescm128, video/rtploopback, video/rtx, video/smpte291, video/smpte292m, video/ulpfec, video/vc1, video/vc2, video/vnd.cctv, video/vnd.dece.hd, video/vnd.dece.mobile, video/vnd.dece.mp4, video/vnd.dece.pd, video/vnd.dece.sd, video/vnd.dece.video, video/vnd.directv.mpeg, video/vnd.directv.mpeg-tts, video/vnd.dlna.mpeg-tts, video/vnd.dvb.file, video/vnd.fvt, video/vnd.hns.video, video/vnd.iptvforum.1dparityfec-1010, video/vnd.iptvforum.1dparityfec-2005, video/vnd.iptvforum.2dparityfec-1010, video/vnd.iptvforum.2dparityfec-2005, video/vnd.iptvforum.ttsavc, video/vnd.iptvforum.ttsmpeg2, video/vnd.motorola.video, video/vnd.motorola.videop, video/vnd.mpegurl, video/vnd.ms-playready.media.pyv, video/vnd.nokia.interleaved-multimedia, video/vnd.nokia.mp4vr, video/vnd.nokia.videovoip, video/vnd.objectvideo, video/vnd.radgamettools.bink, video/vnd.radgamettools.smacker, video/vnd.sealed.mpeg1, video/vnd.sealed.mpeg4, video/vnd.sealed.swf, video/vnd.sealedmedia.softseal.mov, video/vnd.uvvu.mp4, video/vnd.vivo, video/vnd.youtube.yt, video/vp8, video/webm, video/x-f4v, video/x-fli, video/x-flv, video/x-m4v, video/x-matroska, video/x-mng, video/x-ms-asf, video/x-ms-vob, video/x-ms-wm, video/x-ms-wmv, video/x-ms-wmx, video/x-ms-wvx, video/x-msvideo, video/x-sgi-movie, video/x-smv, x-conference/x-cooltalk, x-shader/x-fragment, x-shader/x-vertex, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"application/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"application/3gpdash-qoe-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/3gpp-ims+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/a2l\":{\"source\":\"iana\"},\"application/activemessage\":{\"source\":\"iana\"},\"application/activity+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-costmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-directory+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcost+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointcostparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointprop+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-endpointpropparams+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-error+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/alto-networkmapfilter+json\":{\"source\":\"iana\",\"compressible\":true},\"application/aml\":{\"source\":\"iana\"},\"application/andrew-inset\":{\"source\":\"iana\",\"extensions\":[\"ez\"]},\"application/applefile\":{\"source\":\"iana\"},\"application/applixware\":{\"source\":\"apache\",\"extensions\":[\"aw\"]},\"application/atf\":{\"source\":\"iana\"},\"application/atfx\":{\"source\":\"iana\"},\"application/atom+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atom\"]},\"application/atomcat+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomcat\"]},\"application/atomdeleted+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atomicmail\":{\"source\":\"iana\"},\"application/atomsvc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"atomsvc\"]},\"application/atsc-dwd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atsc-held+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atsc-rsat+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/atxml\":{\"source\":\"iana\"},\"application/auth-policy+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/bacnet-xdd+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/batch-smtp\":{\"source\":\"iana\"},\"application/bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/beep+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/calendar+json\":{\"source\":\"iana\",\"compressible\":true},\"application/calendar+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/call-completion\":{\"source\":\"iana\"},\"application/cals-1840\":{\"source\":\"iana\"},\"application/cbor\":{\"source\":\"iana\"},\"application/cccex\":{\"source\":\"iana\"},\"application/ccmp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ccxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ccxml\"]},\"application/cdfx+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cdmi-capability\":{\"source\":\"iana\",\"extensions\":[\"cdmia\"]},\"application/cdmi-container\":{\"source\":\"iana\",\"extensions\":[\"cdmic\"]},\"application/cdmi-domain\":{\"source\":\"iana\",\"extensions\":[\"cdmid\"]},\"application/cdmi-object\":{\"source\":\"iana\",\"extensions\":[\"cdmio\"]},\"application/cdmi-queue\":{\"source\":\"iana\",\"extensions\":[\"cdmiq\"]},\"application/cdni\":{\"source\":\"iana\"},\"application/cea\":{\"source\":\"iana\"},\"application/cea-2018+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cellml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cfw\":{\"source\":\"iana\"},\"application/clue_info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cms\":{\"source\":\"iana\"},\"application/cnrp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-group+json\":{\"source\":\"iana\",\"compressible\":true},\"application/coap-payload\":{\"source\":\"iana\"},\"application/commonground\":{\"source\":\"iana\"},\"application/conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cose\":{\"source\":\"iana\"},\"application/cose-key\":{\"source\":\"iana\"},\"application/cose-key-set\":{\"source\":\"iana\"},\"application/cpl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/csrattrs\":{\"source\":\"iana\"},\"application/csta+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/cstadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/csvm+json\":{\"source\":\"iana\",\"compressible\":true},\"application/cu-seeme\":{\"source\":\"apache\",\"extensions\":[\"cu\"]},\"application/cwt\":{\"source\":\"iana\"},\"application/cybercash\":{\"source\":\"iana\"},\"application/dart\":{\"compressible\":true},\"application/dash+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpd\"]},\"application/dashdelta\":{\"source\":\"iana\"},\"application/davmount+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"davmount\"]},\"application/dca-rft\":{\"source\":\"iana\"},\"application/dcd\":{\"source\":\"iana\"},\"application/dec-dx\":{\"source\":\"iana\"},\"application/dialog-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom\":{\"source\":\"iana\"},\"application/dicom+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dicom+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dii\":{\"source\":\"iana\"},\"application/dit\":{\"source\":\"iana\"},\"application/dns\":{\"source\":\"iana\"},\"application/dns+json\":{\"source\":\"iana\",\"compressible\":true},\"application/dns-message\":{\"source\":\"iana\"},\"application/docbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dbk\"]},\"application/dskpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/dssc+der\":{\"source\":\"iana\",\"extensions\":[\"dssc\"]},\"application/dssc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdssc\"]},\"application/dvcs\":{\"source\":\"iana\"},\"application/ecmascript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ecma\",\"es\"]},\"application/edi-consent\":{\"source\":\"iana\"},\"application/edi-x12\":{\"source\":\"iana\",\"compressible\":false},\"application/edifact\":{\"source\":\"iana\",\"compressible\":false},\"application/efi\":{\"source\":\"iana\"},\"application/emergencycalldata.comment+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.deviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.ecall.msd\":{\"source\":\"iana\"},\"application/emergencycalldata.providerinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.serviceinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.subscriberinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emergencycalldata.veds+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/emma+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"emma\"]},\"application/emotionml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/encaprtp\":{\"source\":\"iana\"},\"application/epp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/epub+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"epub\"]},\"application/eshop\":{\"source\":\"iana\"},\"application/exi\":{\"source\":\"iana\",\"extensions\":[\"exi\"]},\"application/expect-ct-report+json\":{\"source\":\"iana\",\"compressible\":true},\"application/fastinfoset\":{\"source\":\"iana\"},\"application/fastsoap\":{\"source\":\"iana\"},\"application/fdt+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/fhir+json\":{\"source\":\"iana\",\"compressible\":true},\"application/fhir+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/fido.trusted-apps+json\":{\"compressible\":true},\"application/fits\":{\"source\":\"iana\"},\"application/flexfec\":{\"source\":\"iana\"},\"application/font-sfnt\":{\"source\":\"iana\"},\"application/font-tdpfr\":{\"source\":\"iana\",\"extensions\":[\"pfr\"]},\"application/font-woff\":{\"source\":\"iana\",\"compressible\":false},\"application/framework-attributes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/geo+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"geojson\"]},\"application/geo+json-seq\":{\"source\":\"iana\"},\"application/geopackage+sqlite3\":{\"source\":\"iana\"},\"application/geoxacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/gltf-buffer\":{\"source\":\"iana\"},\"application/gml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gml\"]},\"application/gpx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"gpx\"]},\"application/gxf\":{\"source\":\"apache\",\"extensions\":[\"gxf\"]},\"application/gzip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gz\"]},\"application/h224\":{\"source\":\"iana\"},\"application/held+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/hjson\":{\"extensions\":[\"hjson\"]},\"application/http\":{\"source\":\"iana\"},\"application/hyperstudio\":{\"source\":\"iana\",\"extensions\":[\"stk\"]},\"application/ibe-key-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pkg-reply+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ibe-pp-data\":{\"source\":\"iana\"},\"application/iges\":{\"source\":\"iana\"},\"application/im-iscomposing+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/index\":{\"source\":\"iana\"},\"application/index.cmd\":{\"source\":\"iana\"},\"application/index.obj\":{\"source\":\"iana\"},\"application/index.response\":{\"source\":\"iana\"},\"application/index.vnd\":{\"source\":\"iana\"},\"application/inkml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ink\",\"inkml\"]},\"application/iotp\":{\"source\":\"iana\"},\"application/ipfix\":{\"source\":\"iana\",\"extensions\":[\"ipfix\"]},\"application/ipp\":{\"source\":\"iana\"},\"application/isup\":{\"source\":\"iana\"},\"application/its+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/java-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jar\",\"war\",\"ear\"]},\"application/java-serialized-object\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"ser\"]},\"application/java-vm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"class\"]},\"application/javascript\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"js\",\"mjs\"]},\"application/jf2feed+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jose\":{\"source\":\"iana\"},\"application/jose+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jrd+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"json\",\"map\"]},\"application/json-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/json-seq\":{\"source\":\"iana\"},\"application/json5\":{\"extensions\":[\"json5\"]},\"application/jsonml+json\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"jsonml\"]},\"application/jwk+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwk-set+json\":{\"source\":\"iana\",\"compressible\":true},\"application/jwt\":{\"source\":\"iana\"},\"application/kpml-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/kpml-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/ld+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"jsonld\"]},\"application/lgr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/link-format\":{\"source\":\"iana\"},\"application/load-control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lost+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lostxml\"]},\"application/lostsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/lxf\":{\"source\":\"iana\"},\"application/mac-binhex40\":{\"source\":\"iana\",\"extensions\":[\"hqx\"]},\"application/mac-compactpro\":{\"source\":\"apache\",\"extensions\":[\"cpt\"]},\"application/macwriteii\":{\"source\":\"iana\"},\"application/mads+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mads\"]},\"application/manifest+json\":{\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"webmanifest\"]},\"application/marc\":{\"source\":\"iana\",\"extensions\":[\"mrc\"]},\"application/marcxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mrcx\"]},\"application/mathematica\":{\"source\":\"iana\",\"extensions\":[\"ma\",\"nb\",\"mb\"]},\"application/mathml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mathml\"]},\"application/mathml-content+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mathml-presentation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-associated-procedure-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-deregister+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-envelope+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-msk-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-protection-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-reception-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-register-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-schedule+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbms-user-service-description+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mbox\":{\"source\":\"iana\",\"extensions\":[\"mbox\"]},\"application/media-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/media_control+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mediaservercontrol+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mscml\"]},\"application/merge-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/metalink+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"metalink\"]},\"application/metalink4+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"meta4\"]},\"application/mets+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mets\"]},\"application/mf4\":{\"source\":\"iana\"},\"application/mikey\":{\"source\":\"iana\"},\"application/mipc\":{\"source\":\"iana\"},\"application/mmt-aei+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mmt-usd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mods+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mods\"]},\"application/moss-keys\":{\"source\":\"iana\"},\"application/moss-signature\":{\"source\":\"iana\"},\"application/mosskey-data\":{\"source\":\"iana\"},\"application/mosskey-request\":{\"source\":\"iana\"},\"application/mp21\":{\"source\":\"iana\",\"extensions\":[\"m21\",\"mp21\"]},\"application/mp4\":{\"source\":\"iana\",\"extensions\":[\"mp4s\",\"m4p\"]},\"application/mpeg4-generic\":{\"source\":\"iana\"},\"application/mpeg4-iod\":{\"source\":\"iana\"},\"application/mpeg4-iod-xmt\":{\"source\":\"iana\"},\"application/mrb-consumer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/mrb-publish+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msc-ivr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msc-mixer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/msword\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"doc\",\"dot\"]},\"application/mud+json\":{\"source\":\"iana\",\"compressible\":true},\"application/mxf\":{\"source\":\"iana\",\"extensions\":[\"mxf\"]},\"application/n-quads\":{\"source\":\"iana\",\"extensions\":[\"nq\"]},\"application/n-triples\":{\"source\":\"iana\",\"extensions\":[\"nt\"]},\"application/nasdata\":{\"source\":\"iana\"},\"application/news-checkgroups\":{\"source\":\"iana\"},\"application/news-groupinfo\":{\"source\":\"iana\"},\"application/news-transmission\":{\"source\":\"iana\"},\"application/nlsml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/node\":{\"source\":\"iana\"},\"application/nss\":{\"source\":\"iana\"},\"application/ocsp-request\":{\"source\":\"iana\"},\"application/ocsp-response\":{\"source\":\"iana\"},\"application/octet-stream\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"bin\",\"dms\",\"lrf\",\"mar\",\"so\",\"dist\",\"distz\",\"pkg\",\"bpk\",\"dump\",\"elc\",\"deploy\",\"exe\",\"dll\",\"deb\",\"dmg\",\"iso\",\"img\",\"msi\",\"msp\",\"msm\",\"buffer\"]},\"application/oda\":{\"source\":\"iana\",\"extensions\":[\"oda\"]},\"application/odm+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/odx\":{\"source\":\"iana\"},\"application/oebps-package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"opf\"]},\"application/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogx\"]},\"application/omdoc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"omdoc\"]},\"application/onenote\":{\"source\":\"apache\",\"extensions\":[\"onetoc\",\"onetoc2\",\"onetmp\",\"onepkg\"]},\"application/oscore\":{\"source\":\"iana\"},\"application/oxps\":{\"source\":\"iana\",\"extensions\":[\"oxps\"]},\"application/p2p-overlay+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/parityfec\":{\"source\":\"iana\"},\"application/passport\":{\"source\":\"iana\"},\"application/patch-ops-error+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xer\"]},\"application/pdf\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pdf\"]},\"application/pdx\":{\"source\":\"iana\"},\"application/pem-certificate-chain\":{\"source\":\"iana\"},\"application/pgp-encrypted\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pgp\"]},\"application/pgp-keys\":{\"source\":\"iana\"},\"application/pgp-signature\":{\"source\":\"iana\",\"extensions\":[\"asc\",\"sig\"]},\"application/pics-rules\":{\"source\":\"apache\",\"extensions\":[\"prf\"]},\"application/pidf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pidf-diff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pkcs10\":{\"source\":\"iana\",\"extensions\":[\"p10\"]},\"application/pkcs12\":{\"source\":\"iana\"},\"application/pkcs7-mime\":{\"source\":\"iana\",\"extensions\":[\"p7m\",\"p7c\"]},\"application/pkcs7-signature\":{\"source\":\"iana\",\"extensions\":[\"p7s\"]},\"application/pkcs8\":{\"source\":\"iana\",\"extensions\":[\"p8\"]},\"application/pkcs8-encrypted\":{\"source\":\"iana\"},\"application/pkix-attr-cert\":{\"source\":\"iana\",\"extensions\":[\"ac\"]},\"application/pkix-cert\":{\"source\":\"iana\",\"extensions\":[\"cer\"]},\"application/pkix-crl\":{\"source\":\"iana\",\"extensions\":[\"crl\"]},\"application/pkix-pkipath\":{\"source\":\"iana\",\"extensions\":[\"pkipath\"]},\"application/pkixcmp\":{\"source\":\"iana\",\"extensions\":[\"pki\"]},\"application/pls+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pls\"]},\"application/poc-settings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/postscript\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ai\",\"eps\",\"ps\"]},\"application/ppsp-tracker+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+json\":{\"source\":\"iana\",\"compressible\":true},\"application/problem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/provenance+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/prs.alvestrand.titrax-sheet\":{\"source\":\"iana\"},\"application/prs.cww\":{\"source\":\"iana\",\"extensions\":[\"cww\"]},\"application/prs.hpub+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/prs.nprend\":{\"source\":\"iana\"},\"application/prs.plucker\":{\"source\":\"iana\"},\"application/prs.rdf-xml-crypt\":{\"source\":\"iana\"},\"application/prs.xsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/pskc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"pskcxml\"]},\"application/qsig\":{\"source\":\"iana\"},\"application/raml+yaml\":{\"compressible\":true,\"extensions\":[\"raml\"]},\"application/raptorfec\":{\"source\":\"iana\"},\"application/rdap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/rdf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rdf\",\"owl\"]},\"application/reginfo+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rif\"]},\"application/relax-ng-compact-syntax\":{\"source\":\"iana\",\"extensions\":[\"rnc\"]},\"application/remote-printing\":{\"source\":\"iana\"},\"application/reputon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/resource-lists+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rl\"]},\"application/resource-lists-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rld\"]},\"application/rfc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/riscos\":{\"source\":\"iana\"},\"application/rlmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/rls-services+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rs\"]},\"application/route-apd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/route-s-tsid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/route-usd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/rpki-ghostbusters\":{\"source\":\"iana\",\"extensions\":[\"gbr\"]},\"application/rpki-manifest\":{\"source\":\"iana\",\"extensions\":[\"mft\"]},\"application/rpki-publication\":{\"source\":\"iana\"},\"application/rpki-roa\":{\"source\":\"iana\",\"extensions\":[\"roa\"]},\"application/rpki-updown\":{\"source\":\"iana\"},\"application/rsd+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rsd\"]},\"application/rss+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"rss\"]},\"application/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"application/rtploopback\":{\"source\":\"iana\"},\"application/rtx\":{\"source\":\"iana\"},\"application/samlassertion+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/samlmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sbml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sbml\"]},\"application/scaip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/scim+json\":{\"source\":\"iana\",\"compressible\":true},\"application/scvp-cv-request\":{\"source\":\"iana\",\"extensions\":[\"scq\"]},\"application/scvp-cv-response\":{\"source\":\"iana\",\"extensions\":[\"scs\"]},\"application/scvp-vp-request\":{\"source\":\"iana\",\"extensions\":[\"spq\"]},\"application/scvp-vp-response\":{\"source\":\"iana\",\"extensions\":[\"spp\"]},\"application/sdp\":{\"source\":\"iana\",\"extensions\":[\"sdp\"]},\"application/secevent+jwt\":{\"source\":\"iana\"},\"application/senml+cbor\":{\"source\":\"iana\"},\"application/senml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/senml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/senml-exi\":{\"source\":\"iana\"},\"application/sensml+cbor\":{\"source\":\"iana\"},\"application/sensml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/sensml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sensml-exi\":{\"source\":\"iana\"},\"application/sep+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sep-exi\":{\"source\":\"iana\"},\"application/session-info\":{\"source\":\"iana\"},\"application/set-payment\":{\"source\":\"iana\"},\"application/set-payment-initiation\":{\"source\":\"iana\",\"extensions\":[\"setpay\"]},\"application/set-registration\":{\"source\":\"iana\"},\"application/set-registration-initiation\":{\"source\":\"iana\",\"extensions\":[\"setreg\"]},\"application/sgml\":{\"source\":\"iana\"},\"application/sgml-open-catalog\":{\"source\":\"iana\"},\"application/shf+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"shf\"]},\"application/sieve\":{\"source\":\"iana\",\"extensions\":[\"siv\",\"sieve\"]},\"application/simple-filter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/simple-message-summary\":{\"source\":\"iana\"},\"application/simplesymbolcontainer\":{\"source\":\"iana\"},\"application/sipc\":{\"source\":\"iana\"},\"application/slate\":{\"source\":\"iana\"},\"application/smil\":{\"source\":\"iana\"},\"application/smil+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"smi\",\"smil\"]},\"application/smpte336m\":{\"source\":\"iana\"},\"application/soap+fastinfoset\":{\"source\":\"iana\"},\"application/soap+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sparql-query\":{\"source\":\"iana\",\"extensions\":[\"rq\"]},\"application/sparql-results+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"srx\"]},\"application/spirits-event+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/sql\":{\"source\":\"iana\"},\"application/srgs\":{\"source\":\"iana\",\"extensions\":[\"gram\"]},\"application/srgs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"grxml\"]},\"application/sru+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sru\"]},\"application/ssdl+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ssdl\"]},\"application/ssml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ssml\"]},\"application/stix+json\":{\"source\":\"iana\",\"compressible\":true},\"application/swid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/tamp-apex-update\":{\"source\":\"iana\"},\"application/tamp-apex-update-confirm\":{\"source\":\"iana\"},\"application/tamp-community-update\":{\"source\":\"iana\"},\"application/tamp-community-update-confirm\":{\"source\":\"iana\"},\"application/tamp-error\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust\":{\"source\":\"iana\"},\"application/tamp-sequence-adjust-confirm\":{\"source\":\"iana\"},\"application/tamp-status-query\":{\"source\":\"iana\"},\"application/tamp-status-response\":{\"source\":\"iana\"},\"application/tamp-update\":{\"source\":\"iana\"},\"application/tamp-update-confirm\":{\"source\":\"iana\"},\"application/tar\":{\"compressible\":true},\"application/taxii+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tei+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tei\",\"teicorpus\"]},\"application/tetra_isi\":{\"source\":\"iana\"},\"application/thraud+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tfi\"]},\"application/timestamp-query\":{\"source\":\"iana\"},\"application/timestamp-reply\":{\"source\":\"iana\"},\"application/timestamped-data\":{\"source\":\"iana\",\"extensions\":[\"tsd\"]},\"application/tlsrpt+gzip\":{\"source\":\"iana\"},\"application/tlsrpt+json\":{\"source\":\"iana\",\"compressible\":true},\"application/tnauthlist\":{\"source\":\"iana\"},\"application/toml\":{\"compressible\":true,\"extensions\":[\"toml\"]},\"application/trickle-ice-sdpfrag\":{\"source\":\"iana\"},\"application/trig\":{\"source\":\"iana\"},\"application/ttml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/tve-trigger\":{\"source\":\"iana\"},\"application/tzif\":{\"source\":\"iana\"},\"application/tzif-leap\":{\"source\":\"iana\"},\"application/ulpfec\":{\"source\":\"iana\"},\"application/urc-grpsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-ressheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-targetdesc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/urc-uisocketdesc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vcard+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vemmi\":{\"source\":\"iana\"},\"application/vividence.scriptfile\":{\"source\":\"apache\"},\"application/vnd.1000minds.decision-model+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-prose+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-prose-pc3ch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp-v2x-local-service-information\":{\"source\":\"iana\"},\"application/vnd.3gpp.access-transfer-events+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.bsf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.gmop+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mc-signalling-ear\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-payload\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-signalling\":{\"source\":\"iana\"},\"application/vnd.3gpp.mcdata-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcdata-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-floor-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-signed+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-ue-init-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcptt-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-command+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-affiliation-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-location-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-mbms-usage-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-service-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-transmission-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-ue-config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mcvideo-user-profile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.mid-call+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.pic-bw-large\":{\"source\":\"iana\",\"extensions\":[\"plb\"]},\"application/vnd.3gpp.pic-bw-small\":{\"source\":\"iana\",\"extensions\":[\"psb\"]},\"application/vnd.3gpp.pic-bw-var\":{\"source\":\"iana\",\"extensions\":[\"pvb\"]},\"application/vnd.3gpp.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp.sms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-ext+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.srvcc-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.state-and-event-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp.ussd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.bcmcsinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.3gpp2.sms\":{\"source\":\"iana\"},\"application/vnd.3gpp2.tcap\":{\"source\":\"iana\",\"extensions\":[\"tcap\"]},\"application/vnd.3lightssoftware.imagescal\":{\"source\":\"iana\"},\"application/vnd.3m.post-it-notes\":{\"source\":\"iana\",\"extensions\":[\"pwn\"]},\"application/vnd.accpac.simply.aso\":{\"source\":\"iana\",\"extensions\":[\"aso\"]},\"application/vnd.accpac.simply.imp\":{\"source\":\"iana\",\"extensions\":[\"imp\"]},\"application/vnd.acucobol\":{\"source\":\"iana\",\"extensions\":[\"acu\"]},\"application/vnd.acucorp\":{\"source\":\"iana\",\"extensions\":[\"atc\",\"acutc\"]},\"application/vnd.adobe.air-application-installer-package+zip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"air\"]},\"application/vnd.adobe.flash.movie\":{\"source\":\"iana\"},\"application/vnd.adobe.formscentral.fcdt\":{\"source\":\"iana\",\"extensions\":[\"fcdt\"]},\"application/vnd.adobe.fxp\":{\"source\":\"iana\",\"extensions\":[\"fxp\",\"fxpl\"]},\"application/vnd.adobe.partial-upload\":{\"source\":\"iana\"},\"application/vnd.adobe.xdp+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdp\"]},\"application/vnd.adobe.xfdf\":{\"source\":\"iana\",\"extensions\":[\"xfdf\"]},\"application/vnd.aether.imp\":{\"source\":\"iana\"},\"application/vnd.afpc.afplinedata\":{\"source\":\"iana\"},\"application/vnd.afpc.modca\":{\"source\":\"iana\"},\"application/vnd.ah-barcode\":{\"source\":\"iana\"},\"application/vnd.ahead.space\":{\"source\":\"iana\",\"extensions\":[\"ahead\"]},\"application/vnd.airzip.filesecure.azf\":{\"source\":\"iana\",\"extensions\":[\"azf\"]},\"application/vnd.airzip.filesecure.azs\":{\"source\":\"iana\",\"extensions\":[\"azs\"]},\"application/vnd.amadeus+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.amazon.ebook\":{\"source\":\"apache\",\"extensions\":[\"azw\"]},\"application/vnd.amazon.mobi8-ebook\":{\"source\":\"iana\"},\"application/vnd.americandynamics.acc\":{\"source\":\"iana\",\"extensions\":[\"acc\"]},\"application/vnd.amiga.ami\":{\"source\":\"iana\",\"extensions\":[\"ami\"]},\"application/vnd.amundsen.maze+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.android.ota\":{\"source\":\"iana\"},\"application/vnd.android.package-archive\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"apk\"]},\"application/vnd.anki\":{\"source\":\"iana\"},\"application/vnd.anser-web-certificate-issue-initiation\":{\"source\":\"iana\",\"extensions\":[\"cii\"]},\"application/vnd.anser-web-funds-transfer-initiation\":{\"source\":\"apache\",\"extensions\":[\"fti\"]},\"application/vnd.antix.game-component\":{\"source\":\"iana\",\"extensions\":[\"atx\"]},\"application/vnd.apache.thrift.binary\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.compact\":{\"source\":\"iana\"},\"application/vnd.apache.thrift.json\":{\"source\":\"iana\"},\"application/vnd.api+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apothekende.reservation+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.apple.installer+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mpkg\"]},\"application/vnd.apple.keynote\":{\"source\":\"iana\",\"extensions\":[\"keynote\"]},\"application/vnd.apple.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"m3u8\"]},\"application/vnd.apple.numbers\":{\"source\":\"iana\",\"extensions\":[\"numbers\"]},\"application/vnd.apple.pages\":{\"source\":\"iana\",\"extensions\":[\"pages\"]},\"application/vnd.apple.pkpass\":{\"compressible\":false,\"extensions\":[\"pkpass\"]},\"application/vnd.arastra.swi\":{\"source\":\"iana\"},\"application/vnd.aristanetworks.swi\":{\"source\":\"iana\",\"extensions\":[\"swi\"]},\"application/vnd.artisan+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.artsquare\":{\"source\":\"iana\"},\"application/vnd.astraea-software.iota\":{\"source\":\"iana\",\"extensions\":[\"iota\"]},\"application/vnd.audiograph\":{\"source\":\"iana\",\"extensions\":[\"aep\"]},\"application/vnd.autopackage\":{\"source\":\"iana\"},\"application/vnd.avalon+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.avistar+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.balsamiq.bmml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.balsamiq.bmpr\":{\"source\":\"iana\"},\"application/vnd.banana-accounting\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.error\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg\":{\"source\":\"iana\"},\"application/vnd.bbf.usp.msg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bekitzur-stech+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.bint.med-content\":{\"source\":\"iana\"},\"application/vnd.biopax.rdf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.blink-idb-value-wrapper\":{\"source\":\"iana\"},\"application/vnd.blueice.multipass\":{\"source\":\"iana\",\"extensions\":[\"mpm\"]},\"application/vnd.bluetooth.ep.oob\":{\"source\":\"iana\"},\"application/vnd.bluetooth.le.oob\":{\"source\":\"iana\"},\"application/vnd.bmi\":{\"source\":\"iana\",\"extensions\":[\"bmi\"]},\"application/vnd.bpf\":{\"source\":\"iana\"},\"application/vnd.bpf3\":{\"source\":\"iana\"},\"application/vnd.businessobjects\":{\"source\":\"iana\",\"extensions\":[\"rep\"]},\"application/vnd.byu.uapi+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cab-jscript\":{\"source\":\"iana\"},\"application/vnd.canon-cpdl\":{\"source\":\"iana\"},\"application/vnd.canon-lips\":{\"source\":\"iana\"},\"application/vnd.capasystems-pg+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cendio.thinlinc.clientconf\":{\"source\":\"iana\"},\"application/vnd.century-systems.tcp_stream\":{\"source\":\"iana\"},\"application/vnd.chemdraw+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"cdxml\"]},\"application/vnd.chess-pgn\":{\"source\":\"iana\"},\"application/vnd.chipnuts.karaoke-mmd\":{\"source\":\"iana\",\"extensions\":[\"mmd\"]},\"application/vnd.ciedi\":{\"source\":\"iana\"},\"application/vnd.cinderella\":{\"source\":\"iana\",\"extensions\":[\"cdy\"]},\"application/vnd.cirpack.isdn-ext\":{\"source\":\"iana\"},\"application/vnd.citationstyles.style+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csl\"]},\"application/vnd.claymore\":{\"source\":\"iana\",\"extensions\":[\"cla\"]},\"application/vnd.cloanto.rp9\":{\"source\":\"iana\",\"extensions\":[\"rp9\"]},\"application/vnd.clonk.c4group\":{\"source\":\"iana\",\"extensions\":[\"c4g\",\"c4d\",\"c4f\",\"c4p\",\"c4u\"]},\"application/vnd.cluetrust.cartomobile-config\":{\"source\":\"iana\",\"extensions\":[\"c11amc\"]},\"application/vnd.cluetrust.cartomobile-config-pkg\":{\"source\":\"iana\",\"extensions\":[\"c11amz\"]},\"application/vnd.coffeescript\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.document-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.presentation-template\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet\":{\"source\":\"iana\"},\"application/vnd.collabio.xodocuments.spreadsheet-template\":{\"source\":\"iana\"},\"application/vnd.collection+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.doc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.collection.next+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.comicbook+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.comicbook-rar\":{\"source\":\"iana\"},\"application/vnd.commerce-battelle\":{\"source\":\"iana\"},\"application/vnd.commonspace\":{\"source\":\"iana\",\"extensions\":[\"csp\"]},\"application/vnd.contact.cmsg\":{\"source\":\"iana\",\"extensions\":[\"cdbcmsg\"]},\"application/vnd.coreos.ignition+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cosmocaller\":{\"source\":\"iana\",\"extensions\":[\"cmc\"]},\"application/vnd.crick.clicker\":{\"source\":\"iana\",\"extensions\":[\"clkx\"]},\"application/vnd.crick.clicker.keyboard\":{\"source\":\"iana\",\"extensions\":[\"clkk\"]},\"application/vnd.crick.clicker.palette\":{\"source\":\"iana\",\"extensions\":[\"clkp\"]},\"application/vnd.crick.clicker.template\":{\"source\":\"iana\",\"extensions\":[\"clkt\"]},\"application/vnd.crick.clicker.wordbank\":{\"source\":\"iana\",\"extensions\":[\"clkw\"]},\"application/vnd.criticaltools.wbs+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wbs\"]},\"application/vnd.cryptii.pipe+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.crypto-shade-file\":{\"source\":\"iana\"},\"application/vnd.ctc-posml\":{\"source\":\"iana\",\"extensions\":[\"pml\"]},\"application/vnd.ctct.ws+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cups-pdf\":{\"source\":\"iana\"},\"application/vnd.cups-postscript\":{\"source\":\"iana\"},\"application/vnd.cups-ppd\":{\"source\":\"iana\",\"extensions\":[\"ppd\"]},\"application/vnd.cups-raster\":{\"source\":\"iana\"},\"application/vnd.cups-raw\":{\"source\":\"iana\"},\"application/vnd.curl\":{\"source\":\"iana\"},\"application/vnd.curl.car\":{\"source\":\"apache\",\"extensions\":[\"car\"]},\"application/vnd.curl.pcurl\":{\"source\":\"apache\",\"extensions\":[\"pcurl\"]},\"application/vnd.cyan.dean.root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.cybank\":{\"source\":\"iana\"},\"application/vnd.d2l.coursepackage1p0+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.dart\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dart\"]},\"application/vnd.data-vision.rdz\":{\"source\":\"iana\",\"extensions\":[\"rdz\"]},\"application/vnd.datapackage+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dataresource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.debian.binary-package\":{\"source\":\"iana\"},\"application/vnd.dece.data\":{\"source\":\"iana\",\"extensions\":[\"uvf\",\"uvvf\",\"uvd\",\"uvvd\"]},\"application/vnd.dece.ttml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uvt\",\"uvvt\"]},\"application/vnd.dece.unspecified\":{\"source\":\"iana\",\"extensions\":[\"uvx\",\"uvvx\"]},\"application/vnd.dece.zip\":{\"source\":\"iana\",\"extensions\":[\"uvz\",\"uvvz\"]},\"application/vnd.denovo.fcselayout-link\":{\"source\":\"iana\",\"extensions\":[\"fe_launch\"]},\"application/vnd.desmume.movie\":{\"source\":\"iana\"},\"application/vnd.dir-bi.plate-dl-nosuffix\":{\"source\":\"iana\"},\"application/vnd.dm.delegation+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dna\":{\"source\":\"iana\",\"extensions\":[\"dna\"]},\"application/vnd.document+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dolby.mlp\":{\"source\":\"apache\",\"extensions\":[\"mlp\"]},\"application/vnd.dolby.mobile.1\":{\"source\":\"iana\"},\"application/vnd.dolby.mobile.2\":{\"source\":\"iana\"},\"application/vnd.doremir.scorecloud-binary-document\":{\"source\":\"iana\"},\"application/vnd.dpgraph\":{\"source\":\"iana\",\"extensions\":[\"dpg\"]},\"application/vnd.dreamfactory\":{\"source\":\"iana\",\"extensions\":[\"dfac\"]},\"application/vnd.drive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ds-keypoint\":{\"source\":\"apache\",\"extensions\":[\"kpxx\"]},\"application/vnd.dtg.local\":{\"source\":\"iana\"},\"application/vnd.dtg.local.flash\":{\"source\":\"iana\"},\"application/vnd.dtg.local.html\":{\"source\":\"iana\"},\"application/vnd.dvb.ait\":{\"source\":\"iana\",\"extensions\":[\"ait\"]},\"application/vnd.dvb.dvbj\":{\"source\":\"iana\"},\"application/vnd.dvb.esgcontainer\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcdftnotifaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgaccess2\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcesgpdd\":{\"source\":\"iana\"},\"application/vnd.dvb.ipdcroaming\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-base\":{\"source\":\"iana\"},\"application/vnd.dvb.iptv.alfec-enhancement\":{\"source\":\"iana\"},\"application/vnd.dvb.notif-aggregate-root+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-container+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-generic+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-msglist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-ia-registration-response+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.notif-init+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.dvb.pfr\":{\"source\":\"iana\"},\"application/vnd.dvb.service\":{\"source\":\"iana\",\"extensions\":[\"svc\"]},\"application/vnd.dxr\":{\"source\":\"iana\"},\"application/vnd.dynageo\":{\"source\":\"iana\",\"extensions\":[\"geo\"]},\"application/vnd.dzr\":{\"source\":\"iana\"},\"application/vnd.easykaraoke.cdgdownload\":{\"source\":\"iana\"},\"application/vnd.ecdis-update\":{\"source\":\"iana\"},\"application/vnd.ecip.rlp\":{\"source\":\"iana\"},\"application/vnd.ecowin.chart\":{\"source\":\"iana\",\"extensions\":[\"mag\"]},\"application/vnd.ecowin.filerequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.fileupdate\":{\"source\":\"iana\"},\"application/vnd.ecowin.series\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesrequest\":{\"source\":\"iana\"},\"application/vnd.ecowin.seriesupdate\":{\"source\":\"iana\"},\"application/vnd.efi.img\":{\"source\":\"iana\"},\"application/vnd.efi.iso\":{\"source\":\"iana\"},\"application/vnd.emclient.accessrequest+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.enliven\":{\"source\":\"iana\",\"extensions\":[\"nml\"]},\"application/vnd.enphase.envoy\":{\"source\":\"iana\"},\"application/vnd.eprints.data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.epson.esf\":{\"source\":\"iana\",\"extensions\":[\"esf\"]},\"application/vnd.epson.msf\":{\"source\":\"iana\",\"extensions\":[\"msf\"]},\"application/vnd.epson.quickanime\":{\"source\":\"iana\",\"extensions\":[\"qam\"]},\"application/vnd.epson.salt\":{\"source\":\"iana\",\"extensions\":[\"slt\"]},\"application/vnd.epson.ssf\":{\"source\":\"iana\",\"extensions\":[\"ssf\"]},\"application/vnd.ericsson.quickcall\":{\"source\":\"iana\"},\"application/vnd.espass-espass+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.eszigno3+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"es3\",\"et3\"]},\"application/vnd.etsi.aoc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.asic-e+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.asic-s+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.etsi.cug+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvcommand+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-bc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-cod+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsad-npvr+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvservice+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvsync+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.iptvueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mcid+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.mheg5\":{\"source\":\"iana\"},\"application/vnd.etsi.overload-control-policy-dataset+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.pstn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.sci+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.simservs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.timestamp-token\":{\"source\":\"iana\"},\"application/vnd.etsi.tsl+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.etsi.tsl.der\":{\"source\":\"iana\"},\"application/vnd.eudora.data\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.profile\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.settings\":{\"source\":\"iana\"},\"application/vnd.evolv.ecig.theme\":{\"source\":\"iana\"},\"application/vnd.exstream-empower+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.exstream-package\":{\"source\":\"iana\"},\"application/vnd.ezpix-album\":{\"source\":\"iana\",\"extensions\":[\"ez2\"]},\"application/vnd.ezpix-package\":{\"source\":\"iana\",\"extensions\":[\"ez3\"]},\"application/vnd.f-secure.mobile\":{\"source\":\"iana\"},\"application/vnd.fastcopy-disk-image\":{\"source\":\"iana\"},\"application/vnd.fdf\":{\"source\":\"iana\",\"extensions\":[\"fdf\"]},\"application/vnd.fdsn.mseed\":{\"source\":\"iana\",\"extensions\":[\"mseed\"]},\"application/vnd.fdsn.seed\":{\"source\":\"iana\",\"extensions\":[\"seed\",\"dataless\"]},\"application/vnd.ffsns\":{\"source\":\"iana\"},\"application/vnd.ficlab.flb+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.filmit.zfc\":{\"source\":\"iana\"},\"application/vnd.fints\":{\"source\":\"iana\"},\"application/vnd.firemonkeys.cloudcell\":{\"source\":\"iana\"},\"application/vnd.flographit\":{\"source\":\"iana\",\"extensions\":[\"gph\"]},\"application/vnd.fluxtime.clip\":{\"source\":\"iana\",\"extensions\":[\"ftc\"]},\"application/vnd.font-fontforge-sfd\":{\"source\":\"iana\"},\"application/vnd.framemaker\":{\"source\":\"iana\",\"extensions\":[\"fm\",\"frame\",\"maker\",\"book\"]},\"application/vnd.frogans.fnc\":{\"source\":\"iana\",\"extensions\":[\"fnc\"]},\"application/vnd.frogans.ltf\":{\"source\":\"iana\",\"extensions\":[\"ltf\"]},\"application/vnd.fsc.weblaunch\":{\"source\":\"iana\",\"extensions\":[\"fsc\"]},\"application/vnd.fujitsu.oasys\":{\"source\":\"iana\",\"extensions\":[\"oas\"]},\"application/vnd.fujitsu.oasys2\":{\"source\":\"iana\",\"extensions\":[\"oa2\"]},\"application/vnd.fujitsu.oasys3\":{\"source\":\"iana\",\"extensions\":[\"oa3\"]},\"application/vnd.fujitsu.oasysgp\":{\"source\":\"iana\",\"extensions\":[\"fg5\"]},\"application/vnd.fujitsu.oasysprs\":{\"source\":\"iana\",\"extensions\":[\"bh2\"]},\"application/vnd.fujixerox.art-ex\":{\"source\":\"iana\"},\"application/vnd.fujixerox.art4\":{\"source\":\"iana\"},\"application/vnd.fujixerox.ddd\":{\"source\":\"iana\",\"extensions\":[\"ddd\"]},\"application/vnd.fujixerox.docuworks\":{\"source\":\"iana\",\"extensions\":[\"xdw\"]},\"application/vnd.fujixerox.docuworks.binder\":{\"source\":\"iana\",\"extensions\":[\"xbd\"]},\"application/vnd.fujixerox.docuworks.container\":{\"source\":\"iana\"},\"application/vnd.fujixerox.hbpl\":{\"source\":\"iana\"},\"application/vnd.fut-misnet\":{\"source\":\"iana\"},\"application/vnd.futoin+cbor\":{\"source\":\"iana\"},\"application/vnd.futoin+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.fuzzysheet\":{\"source\":\"iana\",\"extensions\":[\"fzs\"]},\"application/vnd.genomatix.tuxedo\":{\"source\":\"iana\",\"extensions\":[\"txd\"]},\"application/vnd.geo+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geocube+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.geogebra.file\":{\"source\":\"iana\",\"extensions\":[\"ggb\"]},\"application/vnd.geogebra.tool\":{\"source\":\"iana\",\"extensions\":[\"ggt\"]},\"application/vnd.geometry-explorer\":{\"source\":\"iana\",\"extensions\":[\"gex\",\"gre\"]},\"application/vnd.geonext\":{\"source\":\"iana\",\"extensions\":[\"gxt\"]},\"application/vnd.geoplan\":{\"source\":\"iana\",\"extensions\":[\"g2w\"]},\"application/vnd.geospace\":{\"source\":\"iana\",\"extensions\":[\"g3w\"]},\"application/vnd.gerber\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt\":{\"source\":\"iana\"},\"application/vnd.globalplatform.card-content-mgt-response\":{\"source\":\"iana\"},\"application/vnd.gmx\":{\"source\":\"iana\",\"extensions\":[\"gmx\"]},\"application/vnd.google-apps.document\":{\"compressible\":false,\"extensions\":[\"gdoc\"]},\"application/vnd.google-apps.presentation\":{\"compressible\":false,\"extensions\":[\"gslides\"]},\"application/vnd.google-apps.spreadsheet\":{\"compressible\":false,\"extensions\":[\"gsheet\"]},\"application/vnd.google-earth.kml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"kml\"]},\"application/vnd.google-earth.kmz\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"kmz\"]},\"application/vnd.gov.sk.e-form+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.gov.sk.e-form+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.gov.sk.xmldatacontainer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.grafeq\":{\"source\":\"iana\",\"extensions\":[\"gqf\",\"gqs\"]},\"application/vnd.gridmp\":{\"source\":\"iana\"},\"application/vnd.groove-account\":{\"source\":\"iana\",\"extensions\":[\"gac\"]},\"application/vnd.groove-help\":{\"source\":\"iana\",\"extensions\":[\"ghf\"]},\"application/vnd.groove-identity-message\":{\"source\":\"iana\",\"extensions\":[\"gim\"]},\"application/vnd.groove-injector\":{\"source\":\"iana\",\"extensions\":[\"grv\"]},\"application/vnd.groove-tool-message\":{\"source\":\"iana\",\"extensions\":[\"gtm\"]},\"application/vnd.groove-tool-template\":{\"source\":\"iana\",\"extensions\":[\"tpl\"]},\"application/vnd.groove-vcard\":{\"source\":\"iana\",\"extensions\":[\"vcg\"]},\"application/vnd.hal+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hal+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"hal\"]},\"application/vnd.handheld-entertainment+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zmm\"]},\"application/vnd.hbci\":{\"source\":\"iana\",\"extensions\":[\"hbci\"]},\"application/vnd.hc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hcl-bireports\":{\"source\":\"iana\"},\"application/vnd.hdt\":{\"source\":\"iana\"},\"application/vnd.heroku+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hhe.lesson-player\":{\"source\":\"iana\",\"extensions\":[\"les\"]},\"application/vnd.hp-hpgl\":{\"source\":\"iana\",\"extensions\":[\"hpgl\"]},\"application/vnd.hp-hpid\":{\"source\":\"iana\",\"extensions\":[\"hpid\"]},\"application/vnd.hp-hps\":{\"source\":\"iana\",\"extensions\":[\"hps\"]},\"application/vnd.hp-jlyt\":{\"source\":\"iana\",\"extensions\":[\"jlt\"]},\"application/vnd.hp-pcl\":{\"source\":\"iana\",\"extensions\":[\"pcl\"]},\"application/vnd.hp-pclxl\":{\"source\":\"iana\",\"extensions\":[\"pclxl\"]},\"application/vnd.httphone\":{\"source\":\"iana\"},\"application/vnd.hydrostatix.sof-data\":{\"source\":\"iana\",\"extensions\":[\"sfd-hdstx\"]},\"application/vnd.hyper+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyper-item+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hyperdrive+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.hzn-3d-crossword\":{\"source\":\"iana\"},\"application/vnd.ibm.afplinedata\":{\"source\":\"iana\"},\"application/vnd.ibm.electronic-media\":{\"source\":\"iana\"},\"application/vnd.ibm.minipay\":{\"source\":\"iana\",\"extensions\":[\"mpy\"]},\"application/vnd.ibm.modcap\":{\"source\":\"iana\",\"extensions\":[\"afp\",\"listafp\",\"list3820\"]},\"application/vnd.ibm.rights-management\":{\"source\":\"iana\",\"extensions\":[\"irm\"]},\"application/vnd.ibm.secure-container\":{\"source\":\"iana\",\"extensions\":[\"sc\"]},\"application/vnd.iccprofile\":{\"source\":\"iana\",\"extensions\":[\"icc\",\"icm\"]},\"application/vnd.ieee.1905\":{\"source\":\"iana\"},\"application/vnd.igloader\":{\"source\":\"iana\",\"extensions\":[\"igl\"]},\"application/vnd.imagemeter.folder+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.imagemeter.image+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.immervision-ivp\":{\"source\":\"iana\",\"extensions\":[\"ivp\"]},\"application/vnd.immervision-ivu\":{\"source\":\"iana\",\"extensions\":[\"ivu\"]},\"application/vnd.ims.imsccv1p1\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p2\":{\"source\":\"iana\"},\"application/vnd.ims.imsccv1p3\":{\"source\":\"iana\"},\"application/vnd.ims.lis.v2.result+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolconsumerprofile+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolproxy.id+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ims.lti.v2.toolsettings.simple+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informedcontrol.rms+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.informix-visionary\":{\"source\":\"iana\"},\"application/vnd.infotech.project\":{\"source\":\"iana\"},\"application/vnd.infotech.project+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.innopath.wamp.notification\":{\"source\":\"iana\"},\"application/vnd.insors.igm\":{\"source\":\"iana\",\"extensions\":[\"igm\"]},\"application/vnd.intercon.formnet\":{\"source\":\"iana\",\"extensions\":[\"xpw\",\"xpx\"]},\"application/vnd.intergeo\":{\"source\":\"iana\",\"extensions\":[\"i2g\"]},\"application/vnd.intertrust.digibox\":{\"source\":\"iana\"},\"application/vnd.intertrust.nncp\":{\"source\":\"iana\"},\"application/vnd.intu.qbo\":{\"source\":\"iana\",\"extensions\":[\"qbo\"]},\"application/vnd.intu.qfx\":{\"source\":\"iana\",\"extensions\":[\"qfx\"]},\"application/vnd.iptc.g2.catalogitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.conceptitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.knowledgeitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.newsmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.packageitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.iptc.g2.planningitem+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ipunplugged.rcprofile\":{\"source\":\"iana\",\"extensions\":[\"rcprofile\"]},\"application/vnd.irepository.package+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"irp\"]},\"application/vnd.is-xpr\":{\"source\":\"iana\",\"extensions\":[\"xpr\"]},\"application/vnd.isac.fcs\":{\"source\":\"iana\",\"extensions\":[\"fcs\"]},\"application/vnd.iso11783-10+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.jam\":{\"source\":\"iana\",\"extensions\":[\"jam\"]},\"application/vnd.japannet-directory-service\":{\"source\":\"iana\"},\"application/vnd.japannet-jpnstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-payment-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-registration\":{\"source\":\"iana\"},\"application/vnd.japannet-registration-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-setstore-wakeup\":{\"source\":\"iana\"},\"application/vnd.japannet-verification\":{\"source\":\"iana\"},\"application/vnd.japannet-verification-wakeup\":{\"source\":\"iana\"},\"application/vnd.jcp.javame.midlet-rms\":{\"source\":\"iana\",\"extensions\":[\"rms\"]},\"application/vnd.jisp\":{\"source\":\"iana\",\"extensions\":[\"jisp\"]},\"application/vnd.joost.joda-archive\":{\"source\":\"iana\",\"extensions\":[\"joda\"]},\"application/vnd.jsk.isdn-ngn\":{\"source\":\"iana\"},\"application/vnd.kahootz\":{\"source\":\"iana\",\"extensions\":[\"ktz\",\"ktr\"]},\"application/vnd.kde.karbon\":{\"source\":\"iana\",\"extensions\":[\"karbon\"]},\"application/vnd.kde.kchart\":{\"source\":\"iana\",\"extensions\":[\"chrt\"]},\"application/vnd.kde.kformula\":{\"source\":\"iana\",\"extensions\":[\"kfo\"]},\"application/vnd.kde.kivio\":{\"source\":\"iana\",\"extensions\":[\"flw\"]},\"application/vnd.kde.kontour\":{\"source\":\"iana\",\"extensions\":[\"kon\"]},\"application/vnd.kde.kpresenter\":{\"source\":\"iana\",\"extensions\":[\"kpr\",\"kpt\"]},\"application/vnd.kde.kspread\":{\"source\":\"iana\",\"extensions\":[\"ksp\"]},\"application/vnd.kde.kword\":{\"source\":\"iana\",\"extensions\":[\"kwd\",\"kwt\"]},\"application/vnd.kenameaapp\":{\"source\":\"iana\",\"extensions\":[\"htke\"]},\"application/vnd.kidspiration\":{\"source\":\"iana\",\"extensions\":[\"kia\"]},\"application/vnd.kinar\":{\"source\":\"iana\",\"extensions\":[\"kne\",\"knp\"]},\"application/vnd.koan\":{\"source\":\"iana\",\"extensions\":[\"skp\",\"skd\",\"skt\",\"skm\"]},\"application/vnd.kodak-descriptor\":{\"source\":\"iana\",\"extensions\":[\"sse\"]},\"application/vnd.las\":{\"source\":\"iana\"},\"application/vnd.las.las+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.las.las+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lasxml\"]},\"application/vnd.laszip\":{\"source\":\"iana\"},\"application/vnd.leap+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.liberty-request+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.llamagraphics.life-balance.desktop\":{\"source\":\"iana\",\"extensions\":[\"lbd\"]},\"application/vnd.llamagraphics.life-balance.exchange+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"lbe\"]},\"application/vnd.logipipe.circuit+zip\":{\"source\":\"iana\",\"compressible\":false},\"application/vnd.loom\":{\"source\":\"iana\"},\"application/vnd.lotus-1-2-3\":{\"source\":\"iana\",\"extensions\":[\"123\"]},\"application/vnd.lotus-approach\":{\"source\":\"iana\",\"extensions\":[\"apr\"]},\"application/vnd.lotus-freelance\":{\"source\":\"iana\",\"extensions\":[\"pre\"]},\"application/vnd.lotus-notes\":{\"source\":\"iana\",\"extensions\":[\"nsf\"]},\"application/vnd.lotus-organizer\":{\"source\":\"iana\",\"extensions\":[\"org\"]},\"application/vnd.lotus-screencam\":{\"source\":\"iana\",\"extensions\":[\"scm\"]},\"application/vnd.lotus-wordpro\":{\"source\":\"iana\",\"extensions\":[\"lwp\"]},\"application/vnd.macports.portpkg\":{\"source\":\"iana\",\"extensions\":[\"portpkg\"]},\"application/vnd.mapbox-vector-tile\":{\"source\":\"iana\"},\"application/vnd.marlin.drm.actiontoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.conftoken+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.license+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.marlin.drm.mdcf\":{\"source\":\"iana\"},\"application/vnd.mason+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.maxmind.maxmind-db\":{\"source\":\"iana\"},\"application/vnd.mcd\":{\"source\":\"iana\",\"extensions\":[\"mcd\"]},\"application/vnd.medcalcdata\":{\"source\":\"iana\",\"extensions\":[\"mc1\"]},\"application/vnd.mediastation.cdkey\":{\"source\":\"iana\",\"extensions\":[\"cdkey\"]},\"application/vnd.meridian-slingshot\":{\"source\":\"iana\"},\"application/vnd.mfer\":{\"source\":\"iana\",\"extensions\":[\"mwf\"]},\"application/vnd.mfmp\":{\"source\":\"iana\",\"extensions\":[\"mfm\"]},\"application/vnd.micro+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.micrografx.flo\":{\"source\":\"iana\",\"extensions\":[\"flo\"]},\"application/vnd.micrografx.igx\":{\"source\":\"iana\",\"extensions\":[\"igx\"]},\"application/vnd.microsoft.portable-executable\":{\"source\":\"iana\"},\"application/vnd.microsoft.windows.thumbnail-cache\":{\"source\":\"iana\"},\"application/vnd.miele+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.mif\":{\"source\":\"iana\",\"extensions\":[\"mif\"]},\"application/vnd.minisoft-hp3000-save\":{\"source\":\"iana\"},\"application/vnd.mitsubishi.misty-guard.trustweb\":{\"source\":\"iana\"},\"application/vnd.mobius.daf\":{\"source\":\"iana\",\"extensions\":[\"daf\"]},\"application/vnd.mobius.dis\":{\"source\":\"iana\",\"extensions\":[\"dis\"]},\"application/vnd.mobius.mbk\":{\"source\":\"iana\",\"extensions\":[\"mbk\"]},\"application/vnd.mobius.mqy\":{\"source\":\"iana\",\"extensions\":[\"mqy\"]},\"application/vnd.mobius.msl\":{\"source\":\"iana\",\"extensions\":[\"msl\"]},\"application/vnd.mobius.plc\":{\"source\":\"iana\",\"extensions\":[\"plc\"]},\"application/vnd.mobius.txf\":{\"source\":\"iana\",\"extensions\":[\"txf\"]},\"application/vnd.mophun.application\":{\"source\":\"iana\",\"extensions\":[\"mpn\"]},\"application/vnd.mophun.certificate\":{\"source\":\"iana\",\"extensions\":[\"mpc\"]},\"application/vnd.motorola.flexsuite\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.adsi\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.fis\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.gotap\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.kmr\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.ttc\":{\"source\":\"iana\"},\"application/vnd.motorola.flexsuite.wem\":{\"source\":\"iana\"},\"application/vnd.motorola.iprm\":{\"source\":\"iana\"},\"application/vnd.mozilla.xul+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xul\"]},\"application/vnd.ms-3mfdocument\":{\"source\":\"iana\"},\"application/vnd.ms-artgalry\":{\"source\":\"iana\",\"extensions\":[\"cil\"]},\"application/vnd.ms-asf\":{\"source\":\"iana\"},\"application/vnd.ms-cab-compressed\":{\"source\":\"iana\",\"extensions\":[\"cab\"]},\"application/vnd.ms-color.iccprofile\":{\"source\":\"apache\"},\"application/vnd.ms-excel\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xls\",\"xlm\",\"xla\",\"xlc\",\"xlt\",\"xlw\"]},\"application/vnd.ms-excel.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlam\"]},\"application/vnd.ms-excel.sheet.binary.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsb\"]},\"application/vnd.ms-excel.sheet.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xlsm\"]},\"application/vnd.ms-excel.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"xltm\"]},\"application/vnd.ms-fontobject\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eot\"]},\"application/vnd.ms-htmlhelp\":{\"source\":\"iana\",\"extensions\":[\"chm\"]},\"application/vnd.ms-ims\":{\"source\":\"iana\",\"extensions\":[\"ims\"]},\"application/vnd.ms-lrm\":{\"source\":\"iana\",\"extensions\":[\"lrm\"]},\"application/vnd.ms-office.activex+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-officetheme\":{\"source\":\"iana\",\"extensions\":[\"thmx\"]},\"application/vnd.ms-opentype\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-outlook\":{\"compressible\":false,\"extensions\":[\"msg\"]},\"application/vnd.ms-package.obfuscated-opentype\":{\"source\":\"apache\"},\"application/vnd.ms-pki.seccat\":{\"source\":\"apache\",\"extensions\":[\"cat\"]},\"application/vnd.ms-pki.stl\":{\"source\":\"apache\",\"extensions\":[\"stl\"]},\"application/vnd.ms-playready.initiator+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-powerpoint\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ppt\",\"pps\",\"pot\"]},\"application/vnd.ms-powerpoint.addin.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppam\"]},\"application/vnd.ms-powerpoint.presentation.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"pptm\"]},\"application/vnd.ms-powerpoint.slide.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"sldm\"]},\"application/vnd.ms-powerpoint.slideshow.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"ppsm\"]},\"application/vnd.ms-powerpoint.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"potm\"]},\"application/vnd.ms-printdevicecapabilities+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-printing.printticket+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/vnd.ms-printschematicket+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.ms-project\":{\"source\":\"iana\",\"extensions\":[\"mpp\",\"mpt\"]},\"application/vnd.ms-tnef\":{\"source\":\"iana\"},\"application/vnd.ms-windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.nwprinting.oob\":{\"source\":\"iana\"},\"application/vnd.ms-windows.printerpairing\":{\"source\":\"iana\"},\"application/vnd.ms-windows.wsd.oob\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.lic-resp\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-chlg-req\":{\"source\":\"iana\"},\"application/vnd.ms-wmdrm.meter-resp\":{\"source\":\"iana\"},\"application/vnd.ms-word.document.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"docm\"]},\"application/vnd.ms-word.template.macroenabled.12\":{\"source\":\"iana\",\"extensions\":[\"dotm\"]},\"application/vnd.ms-works\":{\"source\":\"iana\",\"extensions\":[\"wps\",\"wks\",\"wcm\",\"wdb\"]},\"application/vnd.ms-wpl\":{\"source\":\"iana\",\"extensions\":[\"wpl\"]},\"application/vnd.ms-xpsdocument\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xps\"]},\"application/vnd.msa-disk-image\":{\"source\":\"iana\"},\"application/vnd.mseq\":{\"source\":\"iana\",\"extensions\":[\"mseq\"]},\"application/vnd.msign\":{\"source\":\"iana\"},\"application/vnd.multiad.creator\":{\"source\":\"iana\"},\"application/vnd.multiad.creator.cif\":{\"source\":\"iana\"},\"application/vnd.music-niff\":{\"source\":\"iana\"},\"application/vnd.musician\":{\"source\":\"iana\",\"extensions\":[\"mus\"]},\"application/vnd.muvee.style\":{\"source\":\"iana\",\"extensions\":[\"msty\"]},\"application/vnd.mynfc\":{\"source\":\"iana\",\"extensions\":[\"taglet\"]},\"application/vnd.ncd.control\":{\"source\":\"iana\"},\"application/vnd.ncd.reference\":{\"source\":\"iana\"},\"application/vnd.nearst.inv+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nervana\":{\"source\":\"iana\"},\"application/vnd.netfpx\":{\"source\":\"iana\"},\"application/vnd.neurolanguage.nlu\":{\"source\":\"iana\",\"extensions\":[\"nlu\"]},\"application/vnd.nimn\":{\"source\":\"iana\"},\"application/vnd.nintendo.nitro.rom\":{\"source\":\"iana\"},\"application/vnd.nintendo.snes.rom\":{\"source\":\"iana\"},\"application/vnd.nitf\":{\"source\":\"iana\",\"extensions\":[\"ntf\",\"nitf\"]},\"application/vnd.noblenet-directory\":{\"source\":\"iana\",\"extensions\":[\"nnd\"]},\"application/vnd.noblenet-sealer\":{\"source\":\"iana\",\"extensions\":[\"nns\"]},\"application/vnd.noblenet-web\":{\"source\":\"iana\",\"extensions\":[\"nnw\"]},\"application/vnd.nokia.catalogs\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.conml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.iptv.config+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.isds-radio-presets\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.landmark+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.landmarkcollection+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.n-gage.ac+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.n-gage.data\":{\"source\":\"iana\",\"extensions\":[\"ngdat\"]},\"application/vnd.nokia.n-gage.symbian.install\":{\"source\":\"iana\",\"extensions\":[\"n-gage\"]},\"application/vnd.nokia.ncd\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+wbxml\":{\"source\":\"iana\"},\"application/vnd.nokia.pcd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.nokia.radio-preset\":{\"source\":\"iana\",\"extensions\":[\"rpst\"]},\"application/vnd.nokia.radio-presets\":{\"source\":\"iana\",\"extensions\":[\"rpss\"]},\"application/vnd.novadigm.edm\":{\"source\":\"iana\",\"extensions\":[\"edm\"]},\"application/vnd.novadigm.edx\":{\"source\":\"iana\",\"extensions\":[\"edx\"]},\"application/vnd.novadigm.ext\":{\"source\":\"iana\",\"extensions\":[\"ext\"]},\"application/vnd.ntt-local.content-share\":{\"source\":\"iana\"},\"application/vnd.ntt-local.file-transfer\":{\"source\":\"iana\"},\"application/vnd.ntt-local.ogw_remote-access\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_remote\":{\"source\":\"iana\"},\"application/vnd.ntt-local.sip-ta_tcp_stream\":{\"source\":\"iana\"},\"application/vnd.oasis.opendocument.chart\":{\"source\":\"iana\",\"extensions\":[\"odc\"]},\"application/vnd.oasis.opendocument.chart-template\":{\"source\":\"iana\",\"extensions\":[\"otc\"]},\"application/vnd.oasis.opendocument.database\":{\"source\":\"iana\",\"extensions\":[\"odb\"]},\"application/vnd.oasis.opendocument.formula\":{\"source\":\"iana\",\"extensions\":[\"odf\"]},\"application/vnd.oasis.opendocument.formula-template\":{\"source\":\"iana\",\"extensions\":[\"odft\"]},\"application/vnd.oasis.opendocument.graphics\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odg\"]},\"application/vnd.oasis.opendocument.graphics-template\":{\"source\":\"iana\",\"extensions\":[\"otg\"]},\"application/vnd.oasis.opendocument.image\":{\"source\":\"iana\",\"extensions\":[\"odi\"]},\"application/vnd.oasis.opendocument.image-template\":{\"source\":\"iana\",\"extensions\":[\"oti\"]},\"application/vnd.oasis.opendocument.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odp\"]},\"application/vnd.oasis.opendocument.presentation-template\":{\"source\":\"iana\",\"extensions\":[\"otp\"]},\"application/vnd.oasis.opendocument.spreadsheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ods\"]},\"application/vnd.oasis.opendocument.spreadsheet-template\":{\"source\":\"iana\",\"extensions\":[\"ots\"]},\"application/vnd.oasis.opendocument.text\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"odt\"]},\"application/vnd.oasis.opendocument.text-master\":{\"source\":\"iana\",\"extensions\":[\"odm\"]},\"application/vnd.oasis.opendocument.text-template\":{\"source\":\"iana\",\"extensions\":[\"ott\"]},\"application/vnd.oasis.opendocument.text-web\":{\"source\":\"iana\",\"extensions\":[\"oth\"]},\"application/vnd.obn\":{\"source\":\"iana\"},\"application/vnd.ocf+cbor\":{\"source\":\"iana\"},\"application/vnd.oftn.l10n+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessdownload+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.contentaccessstreaming+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.cspg-hexbinary\":{\"source\":\"iana\"},\"application/vnd.oipf.dae.svg+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.dae.xhtml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.mippvcontrolmessage+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.pae.gem\":{\"source\":\"iana\"},\"application/vnd.oipf.spdiscovery+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.spdlist+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.ueprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oipf.userprofile+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.olpc-sugar\":{\"source\":\"iana\",\"extensions\":[\"xo\"]},\"application/vnd.oma-scws-config\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-request\":{\"source\":\"iana\"},\"application/vnd.oma-scws-http-response\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.associated-procedure-parameter+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.drm-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.imd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.ltkm\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.notification+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.provisioningtrigger\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgboot\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.sgdd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sgdu\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.simple-symbol-container\":{\"source\":\"iana\"},\"application/vnd.oma.bcast.smartcard-trigger+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.sprov+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.bcast.stkm\":{\"source\":\"iana\"},\"application/vnd.oma.cab-address-book+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-feature-handler+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-pcc+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-subs-invite+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.cab-user-prefs+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.dcd\":{\"source\":\"iana\"},\"application/vnd.oma.dcdc\":{\"source\":\"iana\"},\"application/vnd.oma.dd2+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dd2\"]},\"application/vnd.oma.drm.risd+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.group-usage-list+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.lwm2m+tlv\":{\"source\":\"iana\"},\"application/vnd.oma.pal+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.detailed-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.final-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.groups+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.invocation-descriptor+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.poc.optimized-progress-report+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.push\":{\"source\":\"iana\"},\"application/vnd.oma.scidm.messages+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oma.xcap-directory+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-email+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-file+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omads-folder+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.omaloc-supl-init\":{\"source\":\"iana\"},\"application/vnd.onepager\":{\"source\":\"iana\"},\"application/vnd.onepagertamp\":{\"source\":\"iana\"},\"application/vnd.onepagertamx\":{\"source\":\"iana\"},\"application/vnd.onepagertat\":{\"source\":\"iana\"},\"application/vnd.onepagertatp\":{\"source\":\"iana\"},\"application/vnd.onepagertatx\":{\"source\":\"iana\"},\"application/vnd.openblox.game+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openblox.game-binary\":{\"source\":\"iana\"},\"application/vnd.openeye.oeb\":{\"source\":\"iana\"},\"application/vnd.openofficeorg.extension\":{\"source\":\"apache\",\"extensions\":[\"oxt\"]},\"application/vnd.openstreetmap.data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.custom-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.customxmlproperties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawing+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.extended-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presentation\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"pptx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slide\":{\"source\":\"iana\",\"extensions\":[\"sldx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow\":{\"source\":\"iana\",\"extensions\":[\"ppsx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.tags+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.template\":{\"source\":\"iana\",\"extensions\":[\"potx\"]},\"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"xlsx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template\":{\"source\":\"iana\",\"extensions\":[\"xltx\"]},\"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.theme+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.themeoverride+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.vmldrawing\":{\"source\":\"iana\"},\"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"docx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template\":{\"source\":\"iana\",\"extensions\":[\"dotx\"]},\"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.core-properties+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.openxmlformats-package.relationships+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oracle.resource+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.orange.indata\":{\"source\":\"iana\"},\"application/vnd.osa.netdeploy\":{\"source\":\"iana\"},\"application/vnd.osgeo.mapguide.package\":{\"source\":\"iana\",\"extensions\":[\"mgp\"]},\"application/vnd.osgi.bundle\":{\"source\":\"iana\"},\"application/vnd.osgi.dp\":{\"source\":\"iana\",\"extensions\":[\"dp\"]},\"application/vnd.osgi.subsystem\":{\"source\":\"iana\",\"extensions\":[\"esa\"]},\"application/vnd.otps.ct-kip+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.oxli.countgraph\":{\"source\":\"iana\"},\"application/vnd.pagerduty+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.palm\":{\"source\":\"iana\",\"extensions\":[\"pdb\",\"pqa\",\"oprc\"]},\"application/vnd.panoply\":{\"source\":\"iana\"},\"application/vnd.paos.xml\":{\"source\":\"iana\"},\"application/vnd.patentdive\":{\"source\":\"iana\"},\"application/vnd.patientecommsdoc\":{\"source\":\"iana\"},\"application/vnd.pawaafile\":{\"source\":\"iana\",\"extensions\":[\"paw\"]},\"application/vnd.pcos\":{\"source\":\"iana\"},\"application/vnd.pg.format\":{\"source\":\"iana\",\"extensions\":[\"str\"]},\"application/vnd.pg.osasli\":{\"source\":\"iana\",\"extensions\":[\"ei6\"]},\"application/vnd.piaccess.application-licence\":{\"source\":\"iana\"},\"application/vnd.picsel\":{\"source\":\"iana\",\"extensions\":[\"efif\"]},\"application/vnd.pmi.widget\":{\"source\":\"iana\",\"extensions\":[\"wg\"]},\"application/vnd.poc.group-advertisement+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.pocketlearn\":{\"source\":\"iana\",\"extensions\":[\"plf\"]},\"application/vnd.powerbuilder6\":{\"source\":\"iana\",\"extensions\":[\"pbd\"]},\"application/vnd.powerbuilder6-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7\":{\"source\":\"iana\"},\"application/vnd.powerbuilder7-s\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75\":{\"source\":\"iana\"},\"application/vnd.powerbuilder75-s\":{\"source\":\"iana\"},\"application/vnd.preminet\":{\"source\":\"iana\"},\"application/vnd.previewsystems.box\":{\"source\":\"iana\",\"extensions\":[\"box\"]},\"application/vnd.proteus.magazine\":{\"source\":\"iana\",\"extensions\":[\"mgz\"]},\"application/vnd.psfs\":{\"source\":\"iana\"},\"application/vnd.publishare-delta-tree\":{\"source\":\"iana\",\"extensions\":[\"qps\"]},\"application/vnd.pvi.ptid1\":{\"source\":\"iana\",\"extensions\":[\"ptid\"]},\"application/vnd.pwg-multiplexed\":{\"source\":\"iana\"},\"application/vnd.pwg-xhtml-print+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.qualcomm.brew-app-res\":{\"source\":\"iana\"},\"application/vnd.quarantainenet\":{\"source\":\"iana\"},\"application/vnd.quark.quarkxpress\":{\"source\":\"iana\",\"extensions\":[\"qxd\",\"qxt\",\"qwd\",\"qwt\",\"qxl\",\"qxb\"]},\"application/vnd.quobject-quoxdocument\":{\"source\":\"iana\"},\"application/vnd.radisys.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-conn+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-audit-stream+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-conf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-base+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-detect+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-fax-sendrecv+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-group+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-speech+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.radisys.msml-dialog-transform+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rainstor.data\":{\"source\":\"iana\"},\"application/vnd.rapid\":{\"source\":\"iana\"},\"application/vnd.rar\":{\"source\":\"iana\"},\"application/vnd.realvnc.bed\":{\"source\":\"iana\",\"extensions\":[\"bed\"]},\"application/vnd.recordare.musicxml\":{\"source\":\"iana\",\"extensions\":[\"mxl\"]},\"application/vnd.recordare.musicxml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"musicxml\"]},\"application/vnd.renlearn.rlprint\":{\"source\":\"iana\"},\"application/vnd.restful+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.rig.cryptonote\":{\"source\":\"iana\",\"extensions\":[\"cryptonote\"]},\"application/vnd.rim.cod\":{\"source\":\"apache\",\"extensions\":[\"cod\"]},\"application/vnd.rn-realmedia\":{\"source\":\"apache\",\"extensions\":[\"rm\"]},\"application/vnd.rn-realmedia-vbr\":{\"source\":\"apache\",\"extensions\":[\"rmvb\"]},\"application/vnd.route66.link66+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"link66\"]},\"application/vnd.rs-274x\":{\"source\":\"iana\"},\"application/vnd.ruckus.download\":{\"source\":\"iana\"},\"application/vnd.s3sms\":{\"source\":\"iana\"},\"application/vnd.sailingtracker.track\":{\"source\":\"iana\",\"extensions\":[\"st\"]},\"application/vnd.sbm.cid\":{\"source\":\"iana\"},\"application/vnd.sbm.mid2\":{\"source\":\"iana\"},\"application/vnd.scribus\":{\"source\":\"iana\"},\"application/vnd.sealed.3df\":{\"source\":\"iana\"},\"application/vnd.sealed.csf\":{\"source\":\"iana\"},\"application/vnd.sealed.doc\":{\"source\":\"iana\"},\"application/vnd.sealed.eml\":{\"source\":\"iana\"},\"application/vnd.sealed.mht\":{\"source\":\"iana\"},\"application/vnd.sealed.net\":{\"source\":\"iana\"},\"application/vnd.sealed.ppt\":{\"source\":\"iana\"},\"application/vnd.sealed.tiff\":{\"source\":\"iana\"},\"application/vnd.sealed.xls\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.html\":{\"source\":\"iana\"},\"application/vnd.sealedmedia.softseal.pdf\":{\"source\":\"iana\"},\"application/vnd.seemail\":{\"source\":\"iana\",\"extensions\":[\"see\"]},\"application/vnd.sema\":{\"source\":\"iana\",\"extensions\":[\"sema\"]},\"application/vnd.semd\":{\"source\":\"iana\",\"extensions\":[\"semd\"]},\"application/vnd.semf\":{\"source\":\"iana\",\"extensions\":[\"semf\"]},\"application/vnd.shade-save-file\":{\"source\":\"iana\"},\"application/vnd.shana.informed.formdata\":{\"source\":\"iana\",\"extensions\":[\"ifm\"]},\"application/vnd.shana.informed.formtemplate\":{\"source\":\"iana\",\"extensions\":[\"itp\"]},\"application/vnd.shana.informed.interchange\":{\"source\":\"iana\",\"extensions\":[\"iif\"]},\"application/vnd.shana.informed.package\":{\"source\":\"iana\",\"extensions\":[\"ipk\"]},\"application/vnd.shootproof+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.shopkick+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.sigrok.session\":{\"source\":\"iana\"},\"application/vnd.simtech-mindmapper\":{\"source\":\"iana\",\"extensions\":[\"twd\",\"twds\"]},\"application/vnd.siren+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.smaf\":{\"source\":\"iana\",\"extensions\":[\"mmf\"]},\"application/vnd.smart.notebook\":{\"source\":\"iana\"},\"application/vnd.smart.teacher\":{\"source\":\"iana\",\"extensions\":[\"teacher\"]},\"application/vnd.software602.filler.form+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.software602.filler.form-xml-zip\":{\"source\":\"iana\"},\"application/vnd.solent.sdkm+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"sdkm\",\"sdkd\"]},\"application/vnd.spotfire.dxp\":{\"source\":\"iana\",\"extensions\":[\"dxp\"]},\"application/vnd.spotfire.sfs\":{\"source\":\"iana\",\"extensions\":[\"sfs\"]},\"application/vnd.sqlite3\":{\"source\":\"iana\"},\"application/vnd.sss-cod\":{\"source\":\"iana\"},\"application/vnd.sss-dtf\":{\"source\":\"iana\"},\"application/vnd.sss-ntf\":{\"source\":\"iana\"},\"application/vnd.stardivision.calc\":{\"source\":\"apache\",\"extensions\":[\"sdc\"]},\"application/vnd.stardivision.draw\":{\"source\":\"apache\",\"extensions\":[\"sda\"]},\"application/vnd.stardivision.impress\":{\"source\":\"apache\",\"extensions\":[\"sdd\"]},\"application/vnd.stardivision.math\":{\"source\":\"apache\",\"extensions\":[\"smf\"]},\"application/vnd.stardivision.writer\":{\"source\":\"apache\",\"extensions\":[\"sdw\",\"vor\"]},\"application/vnd.stardivision.writer-global\":{\"source\":\"apache\",\"extensions\":[\"sgl\"]},\"application/vnd.stepmania.package\":{\"source\":\"iana\",\"extensions\":[\"smzip\"]},\"application/vnd.stepmania.stepchart\":{\"source\":\"iana\",\"extensions\":[\"sm\"]},\"application/vnd.street-stream\":{\"source\":\"iana\"},\"application/vnd.sun.wadl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wadl\"]},\"application/vnd.sun.xml.calc\":{\"source\":\"apache\",\"extensions\":[\"sxc\"]},\"application/vnd.sun.xml.calc.template\":{\"source\":\"apache\",\"extensions\":[\"stc\"]},\"application/vnd.sun.xml.draw\":{\"source\":\"apache\",\"extensions\":[\"sxd\"]},\"application/vnd.sun.xml.draw.template\":{\"source\":\"apache\",\"extensions\":[\"std\"]},\"application/vnd.sun.xml.impress\":{\"source\":\"apache\",\"extensions\":[\"sxi\"]},\"application/vnd.sun.xml.impress.template\":{\"source\":\"apache\",\"extensions\":[\"sti\"]},\"application/vnd.sun.xml.math\":{\"source\":\"apache\",\"extensions\":[\"sxm\"]},\"application/vnd.sun.xml.writer\":{\"source\":\"apache\",\"extensions\":[\"sxw\"]},\"application/vnd.sun.xml.writer.global\":{\"source\":\"apache\",\"extensions\":[\"sxg\"]},\"application/vnd.sun.xml.writer.template\":{\"source\":\"apache\",\"extensions\":[\"stw\"]},\"application/vnd.sus-calendar\":{\"source\":\"iana\",\"extensions\":[\"sus\",\"susp\"]},\"application/vnd.svd\":{\"source\":\"iana\",\"extensions\":[\"svd\"]},\"application/vnd.swiftview-ics\":{\"source\":\"iana\"},\"application/vnd.symbian.install\":{\"source\":\"apache\",\"extensions\":[\"sis\",\"sisx\"]},\"application/vnd.syncml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xsm\"]},\"application/vnd.syncml.dm+wbxml\":{\"source\":\"iana\",\"extensions\":[\"bdm\"]},\"application/vnd.syncml.dm+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdm\"]},\"application/vnd.syncml.dm.notification\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmddf+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.syncml.dmtnds+wbxml\":{\"source\":\"iana\"},\"application/vnd.syncml.dmtnds+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.syncml.ds.notification\":{\"source\":\"iana\"},\"application/vnd.tableschema+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tao.intent-module-archive\":{\"source\":\"iana\",\"extensions\":[\"tao\"]},\"application/vnd.tcpdump.pcap\":{\"source\":\"iana\",\"extensions\":[\"pcap\",\"cap\",\"dmp\"]},\"application/vnd.think-cell.ppttc+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tmd.mediaflex.api+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.tml\":{\"source\":\"iana\"},\"application/vnd.tmobile-livetv\":{\"source\":\"iana\",\"extensions\":[\"tmo\"]},\"application/vnd.tri.onesource\":{\"source\":\"iana\"},\"application/vnd.trid.tpt\":{\"source\":\"iana\",\"extensions\":[\"tpt\"]},\"application/vnd.triscape.mxs\":{\"source\":\"iana\",\"extensions\":[\"mxs\"]},\"application/vnd.trueapp\":{\"source\":\"iana\",\"extensions\":[\"tra\"]},\"application/vnd.truedoc\":{\"source\":\"iana\"},\"application/vnd.ubisoft.webplayer\":{\"source\":\"iana\"},\"application/vnd.ufdl\":{\"source\":\"iana\",\"extensions\":[\"ufd\",\"ufdl\"]},\"application/vnd.uiq.theme\":{\"source\":\"iana\",\"extensions\":[\"utz\"]},\"application/vnd.umajin\":{\"source\":\"iana\",\"extensions\":[\"umj\"]},\"application/vnd.unity\":{\"source\":\"iana\",\"extensions\":[\"unityweb\"]},\"application/vnd.uoml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uoml\"]},\"application/vnd.uplanet.alert\":{\"source\":\"iana\"},\"application/vnd.uplanet.alert-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice\":{\"source\":\"iana\"},\"application/vnd.uplanet.bearer-choice-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop\":{\"source\":\"iana\"},\"application/vnd.uplanet.cacheop-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel\":{\"source\":\"iana\"},\"application/vnd.uplanet.channel-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.list\":{\"source\":\"iana\"},\"application/vnd.uplanet.list-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd\":{\"source\":\"iana\"},\"application/vnd.uplanet.listcmd-wbxml\":{\"source\":\"iana\"},\"application/vnd.uplanet.signal\":{\"source\":\"iana\"},\"application/vnd.uri-map\":{\"source\":\"iana\"},\"application/vnd.valve.source.material\":{\"source\":\"iana\"},\"application/vnd.vcx\":{\"source\":\"iana\",\"extensions\":[\"vcx\"]},\"application/vnd.vd-study\":{\"source\":\"iana\"},\"application/vnd.vectorworks\":{\"source\":\"iana\"},\"application/vnd.vel+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.verimatrix.vcas\":{\"source\":\"iana\"},\"application/vnd.veryant.thin\":{\"source\":\"iana\"},\"application/vnd.ves.encrypted\":{\"source\":\"iana\"},\"application/vnd.vidsoft.vidconference\":{\"source\":\"iana\"},\"application/vnd.visio\":{\"source\":\"iana\",\"extensions\":[\"vsd\",\"vst\",\"vss\",\"vsw\"]},\"application/vnd.visionary\":{\"source\":\"iana\",\"extensions\":[\"vis\"]},\"application/vnd.vividence.scriptfile\":{\"source\":\"iana\"},\"application/vnd.vsf\":{\"source\":\"iana\",\"extensions\":[\"vsf\"]},\"application/vnd.wap.sic\":{\"source\":\"iana\"},\"application/vnd.wap.slc\":{\"source\":\"iana\"},\"application/vnd.wap.wbxml\":{\"source\":\"iana\",\"extensions\":[\"wbxml\"]},\"application/vnd.wap.wmlc\":{\"source\":\"iana\",\"extensions\":[\"wmlc\"]},\"application/vnd.wap.wmlscriptc\":{\"source\":\"iana\",\"extensions\":[\"wmlsc\"]},\"application/vnd.webturbo\":{\"source\":\"iana\",\"extensions\":[\"wtb\"]},\"application/vnd.wfa.p2p\":{\"source\":\"iana\"},\"application/vnd.wfa.wsc\":{\"source\":\"iana\"},\"application/vnd.windows.devicepairing\":{\"source\":\"iana\"},\"application/vnd.wmc\":{\"source\":\"iana\"},\"application/vnd.wmf.bootstrap\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica\":{\"source\":\"iana\"},\"application/vnd.wolfram.mathematica.package\":{\"source\":\"iana\"},\"application/vnd.wolfram.player\":{\"source\":\"iana\",\"extensions\":[\"nbp\"]},\"application/vnd.wordperfect\":{\"source\":\"iana\",\"extensions\":[\"wpd\"]},\"application/vnd.wqd\":{\"source\":\"iana\",\"extensions\":[\"wqd\"]},\"application/vnd.wrq-hp3000-labelled\":{\"source\":\"iana\"},\"application/vnd.wt.stf\":{\"source\":\"iana\",\"extensions\":[\"stf\"]},\"application/vnd.wv.csp+wbxml\":{\"source\":\"iana\"},\"application/vnd.wv.csp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.wv.ssp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xacml+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xara\":{\"source\":\"iana\",\"extensions\":[\"xar\"]},\"application/vnd.xfdl\":{\"source\":\"iana\",\"extensions\":[\"xfdl\"]},\"application/vnd.xfdl.webform\":{\"source\":\"iana\"},\"application/vnd.xmi+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/vnd.xmpie.cpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.dpkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.plan\":{\"source\":\"iana\"},\"application/vnd.xmpie.ppkg\":{\"source\":\"iana\"},\"application/vnd.xmpie.xlim\":{\"source\":\"iana\"},\"application/vnd.yamaha.hv-dic\":{\"source\":\"iana\",\"extensions\":[\"hvd\"]},\"application/vnd.yamaha.hv-script\":{\"source\":\"iana\",\"extensions\":[\"hvs\"]},\"application/vnd.yamaha.hv-voice\":{\"source\":\"iana\",\"extensions\":[\"hvp\"]},\"application/vnd.yamaha.openscoreformat\":{\"source\":\"iana\",\"extensions\":[\"osf\"]},\"application/vnd.yamaha.openscoreformat.osfpvg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"osfpvg\"]},\"application/vnd.yamaha.remote-setup\":{\"source\":\"iana\"},\"application/vnd.yamaha.smaf-audio\":{\"source\":\"iana\",\"extensions\":[\"saf\"]},\"application/vnd.yamaha.smaf-phrase\":{\"source\":\"iana\",\"extensions\":[\"spf\"]},\"application/vnd.yamaha.through-ngn\":{\"source\":\"iana\"},\"application/vnd.yamaha.tunnel-udpencap\":{\"source\":\"iana\"},\"application/vnd.yaoweme\":{\"source\":\"iana\"},\"application/vnd.yellowriver-custom-menu\":{\"source\":\"iana\",\"extensions\":[\"cmp\"]},\"application/vnd.youtube.yt\":{\"source\":\"iana\"},\"application/vnd.zul\":{\"source\":\"iana\",\"extensions\":[\"zir\",\"zirz\"]},\"application/vnd.zzazz.deck+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"zaz\"]},\"application/voicexml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vxml\"]},\"application/voucher-cms+json\":{\"source\":\"iana\",\"compressible\":true},\"application/vq-rtcpxr\":{\"source\":\"iana\"},\"application/wasm\":{\"compressible\":true,\"extensions\":[\"wasm\"]},\"application/watcherinfo+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/webpush-options+json\":{\"source\":\"iana\",\"compressible\":true},\"application/whoispp-query\":{\"source\":\"iana\"},\"application/whoispp-response\":{\"source\":\"iana\"},\"application/widget\":{\"source\":\"iana\",\"extensions\":[\"wgt\"]},\"application/winhlp\":{\"source\":\"apache\",\"extensions\":[\"hlp\"]},\"application/wita\":{\"source\":\"iana\"},\"application/wordperfect5.1\":{\"source\":\"iana\"},\"application/wsdl+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wsdl\"]},\"application/wspolicy+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"wspolicy\"]},\"application/x-7z-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"7z\"]},\"application/x-abiword\":{\"source\":\"apache\",\"extensions\":[\"abw\"]},\"application/x-ace-compressed\":{\"source\":\"apache\",\"extensions\":[\"ace\"]},\"application/x-amf\":{\"source\":\"apache\"},\"application/x-apple-diskimage\":{\"source\":\"apache\",\"extensions\":[\"dmg\"]},\"application/x-arj\":{\"compressible\":false,\"extensions\":[\"arj\"]},\"application/x-authorware-bin\":{\"source\":\"apache\",\"extensions\":[\"aab\",\"x32\",\"u32\",\"vox\"]},\"application/x-authorware-map\":{\"source\":\"apache\",\"extensions\":[\"aam\"]},\"application/x-authorware-seg\":{\"source\":\"apache\",\"extensions\":[\"aas\"]},\"application/x-bcpio\":{\"source\":\"apache\",\"extensions\":[\"bcpio\"]},\"application/x-bdoc\":{\"compressible\":false,\"extensions\":[\"bdoc\"]},\"application/x-bittorrent\":{\"source\":\"apache\",\"extensions\":[\"torrent\"]},\"application/x-blorb\":{\"source\":\"apache\",\"extensions\":[\"blb\",\"blorb\"]},\"application/x-bzip\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz\"]},\"application/x-bzip2\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"bz2\",\"boz\"]},\"application/x-cbr\":{\"source\":\"apache\",\"extensions\":[\"cbr\",\"cba\",\"cbt\",\"cbz\",\"cb7\"]},\"application/x-cdlink\":{\"source\":\"apache\",\"extensions\":[\"vcd\"]},\"application/x-cfs-compressed\":{\"source\":\"apache\",\"extensions\":[\"cfs\"]},\"application/x-chat\":{\"source\":\"apache\",\"extensions\":[\"chat\"]},\"application/x-chess-pgn\":{\"source\":\"apache\",\"extensions\":[\"pgn\"]},\"application/x-chrome-extension\":{\"extensions\":[\"crx\"]},\"application/x-cocoa\":{\"source\":\"nginx\",\"extensions\":[\"cco\"]},\"application/x-compress\":{\"source\":\"apache\"},\"application/x-conference\":{\"source\":\"apache\",\"extensions\":[\"nsc\"]},\"application/x-cpio\":{\"source\":\"apache\",\"extensions\":[\"cpio\"]},\"application/x-csh\":{\"source\":\"apache\",\"extensions\":[\"csh\"]},\"application/x-deb\":{\"compressible\":false},\"application/x-debian-package\":{\"source\":\"apache\",\"extensions\":[\"deb\",\"udeb\"]},\"application/x-dgc-compressed\":{\"source\":\"apache\",\"extensions\":[\"dgc\"]},\"application/x-director\":{\"source\":\"apache\",\"extensions\":[\"dir\",\"dcr\",\"dxr\",\"cst\",\"cct\",\"cxt\",\"w3d\",\"fgd\",\"swa\"]},\"application/x-doom\":{\"source\":\"apache\",\"extensions\":[\"wad\"]},\"application/x-dtbncx+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ncx\"]},\"application/x-dtbook+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"dtb\"]},\"application/x-dtbresource+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"res\"]},\"application/x-dvi\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"dvi\"]},\"application/x-envoy\":{\"source\":\"apache\",\"extensions\":[\"evy\"]},\"application/x-eva\":{\"source\":\"apache\",\"extensions\":[\"eva\"]},\"application/x-font-bdf\":{\"source\":\"apache\",\"extensions\":[\"bdf\"]},\"application/x-font-dos\":{\"source\":\"apache\"},\"application/x-font-framemaker\":{\"source\":\"apache\"},\"application/x-font-ghostscript\":{\"source\":\"apache\",\"extensions\":[\"gsf\"]},\"application/x-font-libgrx\":{\"source\":\"apache\"},\"application/x-font-linux-psf\":{\"source\":\"apache\",\"extensions\":[\"psf\"]},\"application/x-font-pcf\":{\"source\":\"apache\",\"extensions\":[\"pcf\"]},\"application/x-font-snf\":{\"source\":\"apache\",\"extensions\":[\"snf\"]},\"application/x-font-speedo\":{\"source\":\"apache\"},\"application/x-font-sunos-news\":{\"source\":\"apache\"},\"application/x-font-type1\":{\"source\":\"apache\",\"extensions\":[\"pfa\",\"pfb\",\"pfm\",\"afm\"]},\"application/x-font-vfont\":{\"source\":\"apache\"},\"application/x-freearc\":{\"source\":\"apache\",\"extensions\":[\"arc\"]},\"application/x-futuresplash\":{\"source\":\"apache\",\"extensions\":[\"spl\"]},\"application/x-gca-compressed\":{\"source\":\"apache\",\"extensions\":[\"gca\"]},\"application/x-glulx\":{\"source\":\"apache\",\"extensions\":[\"ulx\"]},\"application/x-gnumeric\":{\"source\":\"apache\",\"extensions\":[\"gnumeric\"]},\"application/x-gramps-xml\":{\"source\":\"apache\",\"extensions\":[\"gramps\"]},\"application/x-gtar\":{\"source\":\"apache\",\"extensions\":[\"gtar\"]},\"application/x-gzip\":{\"source\":\"apache\"},\"application/x-hdf\":{\"source\":\"apache\",\"extensions\":[\"hdf\"]},\"application/x-httpd-php\":{\"compressible\":true,\"extensions\":[\"php\"]},\"application/x-install-instructions\":{\"source\":\"apache\",\"extensions\":[\"install\"]},\"application/x-iso9660-image\":{\"source\":\"apache\",\"extensions\":[\"iso\"]},\"application/x-java-archive-diff\":{\"source\":\"nginx\",\"extensions\":[\"jardiff\"]},\"application/x-java-jnlp-file\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"jnlp\"]},\"application/x-javascript\":{\"compressible\":true},\"application/x-latex\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"latex\"]},\"application/x-lua-bytecode\":{\"extensions\":[\"luac\"]},\"application/x-lzh-compressed\":{\"source\":\"apache\",\"extensions\":[\"lzh\",\"lha\"]},\"application/x-makeself\":{\"source\":\"nginx\",\"extensions\":[\"run\"]},\"application/x-mie\":{\"source\":\"apache\",\"extensions\":[\"mie\"]},\"application/x-mobipocket-ebook\":{\"source\":\"apache\",\"extensions\":[\"prc\",\"mobi\"]},\"application/x-mpegurl\":{\"compressible\":false},\"application/x-ms-application\":{\"source\":\"apache\",\"extensions\":[\"application\"]},\"application/x-ms-shortcut\":{\"source\":\"apache\",\"extensions\":[\"lnk\"]},\"application/x-ms-wmd\":{\"source\":\"apache\",\"extensions\":[\"wmd\"]},\"application/x-ms-wmz\":{\"source\":\"apache\",\"extensions\":[\"wmz\"]},\"application/x-ms-xbap\":{\"source\":\"apache\",\"extensions\":[\"xbap\"]},\"application/x-msaccess\":{\"source\":\"apache\",\"extensions\":[\"mdb\"]},\"application/x-msbinder\":{\"source\":\"apache\",\"extensions\":[\"obd\"]},\"application/x-mscardfile\":{\"source\":\"apache\",\"extensions\":[\"crd\"]},\"application/x-msclip\":{\"source\":\"apache\",\"extensions\":[\"clp\"]},\"application/x-msdos-program\":{\"extensions\":[\"exe\"]},\"application/x-msdownload\":{\"source\":\"apache\",\"extensions\":[\"exe\",\"dll\",\"com\",\"bat\",\"msi\"]},\"application/x-msmediaview\":{\"source\":\"apache\",\"extensions\":[\"mvb\",\"m13\",\"m14\"]},\"application/x-msmetafile\":{\"source\":\"apache\",\"extensions\":[\"wmf\",\"wmz\",\"emf\",\"emz\"]},\"application/x-msmoney\":{\"source\":\"apache\",\"extensions\":[\"mny\"]},\"application/x-mspublisher\":{\"source\":\"apache\",\"extensions\":[\"pub\"]},\"application/x-msschedule\":{\"source\":\"apache\",\"extensions\":[\"scd\"]},\"application/x-msterminal\":{\"source\":\"apache\",\"extensions\":[\"trm\"]},\"application/x-mswrite\":{\"source\":\"apache\",\"extensions\":[\"wri\"]},\"application/x-netcdf\":{\"source\":\"apache\",\"extensions\":[\"nc\",\"cdf\"]},\"application/x-ns-proxy-autoconfig\":{\"compressible\":true,\"extensions\":[\"pac\"]},\"application/x-nzb\":{\"source\":\"apache\",\"extensions\":[\"nzb\"]},\"application/x-perl\":{\"source\":\"nginx\",\"extensions\":[\"pl\",\"pm\"]},\"application/x-pilot\":{\"source\":\"nginx\",\"extensions\":[\"prc\",\"pdb\"]},\"application/x-pkcs12\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"p12\",\"pfx\"]},\"application/x-pkcs7-certificates\":{\"source\":\"apache\",\"extensions\":[\"p7b\",\"spc\"]},\"application/x-pkcs7-certreqresp\":{\"source\":\"apache\",\"extensions\":[\"p7r\"]},\"application/x-rar-compressed\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"rar\"]},\"application/x-redhat-package-manager\":{\"source\":\"nginx\",\"extensions\":[\"rpm\"]},\"application/x-research-info-systems\":{\"source\":\"apache\",\"extensions\":[\"ris\"]},\"application/x-sea\":{\"source\":\"nginx\",\"extensions\":[\"sea\"]},\"application/x-sh\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"sh\"]},\"application/x-shar\":{\"source\":\"apache\",\"extensions\":[\"shar\"]},\"application/x-shockwave-flash\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"swf\"]},\"application/x-silverlight-app\":{\"source\":\"apache\",\"extensions\":[\"xap\"]},\"application/x-sql\":{\"source\":\"apache\",\"extensions\":[\"sql\"]},\"application/x-stuffit\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"sit\"]},\"application/x-stuffitx\":{\"source\":\"apache\",\"extensions\":[\"sitx\"]},\"application/x-subrip\":{\"source\":\"apache\",\"extensions\":[\"srt\"]},\"application/x-sv4cpio\":{\"source\":\"apache\",\"extensions\":[\"sv4cpio\"]},\"application/x-sv4crc\":{\"source\":\"apache\",\"extensions\":[\"sv4crc\"]},\"application/x-t3vm-image\":{\"source\":\"apache\",\"extensions\":[\"t3\"]},\"application/x-tads\":{\"source\":\"apache\",\"extensions\":[\"gam\"]},\"application/x-tar\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"tar\"]},\"application/x-tcl\":{\"source\":\"apache\",\"extensions\":[\"tcl\",\"tk\"]},\"application/x-tex\":{\"source\":\"apache\",\"extensions\":[\"tex\"]},\"application/x-tex-tfm\":{\"source\":\"apache\",\"extensions\":[\"tfm\"]},\"application/x-texinfo\":{\"source\":\"apache\",\"extensions\":[\"texinfo\",\"texi\"]},\"application/x-tgif\":{\"source\":\"apache\",\"extensions\":[\"obj\"]},\"application/x-ustar\":{\"source\":\"apache\",\"extensions\":[\"ustar\"]},\"application/x-virtualbox-hdd\":{\"compressible\":true,\"extensions\":[\"hdd\"]},\"application/x-virtualbox-ova\":{\"compressible\":true,\"extensions\":[\"ova\"]},\"application/x-virtualbox-ovf\":{\"compressible\":true,\"extensions\":[\"ovf\"]},\"application/x-virtualbox-vbox\":{\"compressible\":true,\"extensions\":[\"vbox\"]},\"application/x-virtualbox-vbox-extpack\":{\"compressible\":false,\"extensions\":[\"vbox-extpack\"]},\"application/x-virtualbox-vdi\":{\"compressible\":true,\"extensions\":[\"vdi\"]},\"application/x-virtualbox-vhd\":{\"compressible\":true,\"extensions\":[\"vhd\"]},\"application/x-virtualbox-vmdk\":{\"compressible\":true,\"extensions\":[\"vmdk\"]},\"application/x-wais-source\":{\"source\":\"apache\",\"extensions\":[\"src\"]},\"application/x-web-app-manifest+json\":{\"compressible\":true,\"extensions\":[\"webapp\"]},\"application/x-www-form-urlencoded\":{\"source\":\"iana\",\"compressible\":true},\"application/x-x509-ca-cert\":{\"source\":\"apache\",\"extensions\":[\"der\",\"crt\",\"pem\"]},\"application/x-xfig\":{\"source\":\"apache\",\"extensions\":[\"fig\"]},\"application/x-xliff+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xlf\"]},\"application/x-xpinstall\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"xpi\"]},\"application/x-xz\":{\"source\":\"apache\",\"extensions\":[\"xz\"]},\"application/x-zmachine\":{\"source\":\"apache\",\"extensions\":[\"z1\",\"z2\",\"z3\",\"z4\",\"z5\",\"z6\",\"z7\",\"z8\"]},\"application/x400-bp\":{\"source\":\"iana\"},\"application/xacml+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xaml+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xaml\"]},\"application/xcap-att+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-caps+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-diff+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xdf\"]},\"application/xcap-el+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-error+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcap-ns+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcon-conference-info+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xcon-conference-info-diff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xenc+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xenc\"]},\"application/xhtml+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xhtml\",\"xht\"]},\"application/xhtml-voice+xml\":{\"source\":\"apache\",\"compressible\":true},\"application/xliff+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\",\"xsl\",\"xsd\",\"rng\"]},\"application/xml-dtd\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dtd\"]},\"application/xml-external-parsed-entity\":{\"source\":\"iana\"},\"application/xml-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xmpp+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/xop+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xop\"]},\"application/xproc+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xpl\"]},\"application/xslt+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xslt\"]},\"application/xspf+xml\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"xspf\"]},\"application/xv+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"mxml\",\"xhvml\",\"xvml\",\"xvm\"]},\"application/yang\":{\"source\":\"iana\",\"extensions\":[\"yang\"]},\"application/yang-data+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-data+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+json\":{\"source\":\"iana\",\"compressible\":true},\"application/yang-patch+xml\":{\"source\":\"iana\",\"compressible\":true},\"application/yin+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"yin\"]},\"application/zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"zip\"]},\"application/zlib\":{\"source\":\"iana\"},\"application/zstd\":{\"source\":\"iana\"},\"audio/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"audio/32kadpcm\":{\"source\":\"iana\"},\"audio/3gpp\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"3gpp\"]},\"audio/3gpp2\":{\"source\":\"iana\"},\"audio/aac\":{\"source\":\"iana\"},\"audio/ac3\":{\"source\":\"iana\"},\"audio/adpcm\":{\"source\":\"apache\",\"extensions\":[\"adp\"]},\"audio/amr\":{\"source\":\"iana\"},\"audio/amr-wb\":{\"source\":\"iana\"},\"audio/amr-wb+\":{\"source\":\"iana\"},\"audio/aptx\":{\"source\":\"iana\"},\"audio/asc\":{\"source\":\"iana\"},\"audio/atrac-advanced-lossless\":{\"source\":\"iana\"},\"audio/atrac-x\":{\"source\":\"iana\"},\"audio/atrac3\":{\"source\":\"iana\"},\"audio/basic\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"au\",\"snd\"]},\"audio/bv16\":{\"source\":\"iana\"},\"audio/bv32\":{\"source\":\"iana\"},\"audio/clearmode\":{\"source\":\"iana\"},\"audio/cn\":{\"source\":\"iana\"},\"audio/dat12\":{\"source\":\"iana\"},\"audio/dls\":{\"source\":\"iana\"},\"audio/dsr-es201108\":{\"source\":\"iana\"},\"audio/dsr-es202050\":{\"source\":\"iana\"},\"audio/dsr-es202211\":{\"source\":\"iana\"},\"audio/dsr-es202212\":{\"source\":\"iana\"},\"audio/dv\":{\"source\":\"iana\"},\"audio/dvi4\":{\"source\":\"iana\"},\"audio/eac3\":{\"source\":\"iana\"},\"audio/encaprtp\":{\"source\":\"iana\"},\"audio/evrc\":{\"source\":\"iana\"},\"audio/evrc-qcp\":{\"source\":\"iana\"},\"audio/evrc0\":{\"source\":\"iana\"},\"audio/evrc1\":{\"source\":\"iana\"},\"audio/evrcb\":{\"source\":\"iana\"},\"audio/evrcb0\":{\"source\":\"iana\"},\"audio/evrcb1\":{\"source\":\"iana\"},\"audio/evrcnw\":{\"source\":\"iana\"},\"audio/evrcnw0\":{\"source\":\"iana\"},\"audio/evrcnw1\":{\"source\":\"iana\"},\"audio/evrcwb\":{\"source\":\"iana\"},\"audio/evrcwb0\":{\"source\":\"iana\"},\"audio/evrcwb1\":{\"source\":\"iana\"},\"audio/evs\":{\"source\":\"iana\"},\"audio/flexfec\":{\"source\":\"iana\"},\"audio/fwdred\":{\"source\":\"iana\"},\"audio/g711-0\":{\"source\":\"iana\"},\"audio/g719\":{\"source\":\"iana\"},\"audio/g722\":{\"source\":\"iana\"},\"audio/g7221\":{\"source\":\"iana\"},\"audio/g723\":{\"source\":\"iana\"},\"audio/g726-16\":{\"source\":\"iana\"},\"audio/g726-24\":{\"source\":\"iana\"},\"audio/g726-32\":{\"source\":\"iana\"},\"audio/g726-40\":{\"source\":\"iana\"},\"audio/g728\":{\"source\":\"iana\"},\"audio/g729\":{\"source\":\"iana\"},\"audio/g7291\":{\"source\":\"iana\"},\"audio/g729d\":{\"source\":\"iana\"},\"audio/g729e\":{\"source\":\"iana\"},\"audio/gsm\":{\"source\":\"iana\"},\"audio/gsm-efr\":{\"source\":\"iana\"},\"audio/gsm-hr-08\":{\"source\":\"iana\"},\"audio/ilbc\":{\"source\":\"iana\"},\"audio/ip-mr_v2.5\":{\"source\":\"iana\"},\"audio/isac\":{\"source\":\"apache\"},\"audio/l16\":{\"source\":\"iana\"},\"audio/l20\":{\"source\":\"iana\"},\"audio/l24\":{\"source\":\"iana\",\"compressible\":false},\"audio/l8\":{\"source\":\"iana\"},\"audio/lpc\":{\"source\":\"iana\"},\"audio/melp\":{\"source\":\"iana\"},\"audio/melp1200\":{\"source\":\"iana\"},\"audio/melp2400\":{\"source\":\"iana\"},\"audio/melp600\":{\"source\":\"iana\"},\"audio/midi\":{\"source\":\"apache\",\"extensions\":[\"mid\",\"midi\",\"kar\",\"rmi\"]},\"audio/mobile-xmf\":{\"source\":\"iana\"},\"audio/mp3\":{\"compressible\":false,\"extensions\":[\"mp3\"]},\"audio/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"m4a\",\"mp4a\"]},\"audio/mp4a-latm\":{\"source\":\"iana\"},\"audio/mpa\":{\"source\":\"iana\"},\"audio/mpa-robust\":{\"source\":\"iana\"},\"audio/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpga\",\"mp2\",\"mp2a\",\"mp3\",\"m2a\",\"m3a\"]},\"audio/mpeg4-generic\":{\"source\":\"iana\"},\"audio/musepack\":{\"source\":\"apache\"},\"audio/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"oga\",\"ogg\",\"spx\"]},\"audio/opus\":{\"source\":\"iana\"},\"audio/parityfec\":{\"source\":\"iana\"},\"audio/pcma\":{\"source\":\"iana\"},\"audio/pcma-wb\":{\"source\":\"iana\"},\"audio/pcmu\":{\"source\":\"iana\"},\"audio/pcmu-wb\":{\"source\":\"iana\"},\"audio/prs.sid\":{\"source\":\"iana\"},\"audio/qcelp\":{\"source\":\"iana\"},\"audio/raptorfec\":{\"source\":\"iana\"},\"audio/red\":{\"source\":\"iana\"},\"audio/rtp-enc-aescm128\":{\"source\":\"iana\"},\"audio/rtp-midi\":{\"source\":\"iana\"},\"audio/rtploopback\":{\"source\":\"iana\"},\"audio/rtx\":{\"source\":\"iana\"},\"audio/s3m\":{\"source\":\"apache\",\"extensions\":[\"s3m\"]},\"audio/silk\":{\"source\":\"apache\",\"extensions\":[\"sil\"]},\"audio/smv\":{\"source\":\"iana\"},\"audio/smv-qcp\":{\"source\":\"iana\"},\"audio/smv0\":{\"source\":\"iana\"},\"audio/sp-midi\":{\"source\":\"iana\"},\"audio/speex\":{\"source\":\"iana\"},\"audio/t140c\":{\"source\":\"iana\"},\"audio/t38\":{\"source\":\"iana\"},\"audio/telephone-event\":{\"source\":\"iana\"},\"audio/tetra_acelp\":{\"source\":\"iana\"},\"audio/tone\":{\"source\":\"iana\"},\"audio/uemclip\":{\"source\":\"iana\"},\"audio/ulpfec\":{\"source\":\"iana\"},\"audio/usac\":{\"source\":\"iana\"},\"audio/vdvi\":{\"source\":\"iana\"},\"audio/vmr-wb\":{\"source\":\"iana\"},\"audio/vnd.3gpp.iufp\":{\"source\":\"iana\"},\"audio/vnd.4sb\":{\"source\":\"iana\"},\"audio/vnd.audiokoz\":{\"source\":\"iana\"},\"audio/vnd.celp\":{\"source\":\"iana\"},\"audio/vnd.cisco.nse\":{\"source\":\"iana\"},\"audio/vnd.cmles.radio-events\":{\"source\":\"iana\"},\"audio/vnd.cns.anp1\":{\"source\":\"iana\"},\"audio/vnd.cns.inf1\":{\"source\":\"iana\"},\"audio/vnd.dece.audio\":{\"source\":\"iana\",\"extensions\":[\"uva\",\"uvva\"]},\"audio/vnd.digital-winds\":{\"source\":\"iana\",\"extensions\":[\"eol\"]},\"audio/vnd.dlna.adts\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.1\":{\"source\":\"iana\"},\"audio/vnd.dolby.heaac.2\":{\"source\":\"iana\"},\"audio/vnd.dolby.mlp\":{\"source\":\"iana\"},\"audio/vnd.dolby.mps\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2x\":{\"source\":\"iana\"},\"audio/vnd.dolby.pl2z\":{\"source\":\"iana\"},\"audio/vnd.dolby.pulse.1\":{\"source\":\"iana\"},\"audio/vnd.dra\":{\"source\":\"iana\",\"extensions\":[\"dra\"]},\"audio/vnd.dts\":{\"source\":\"iana\",\"extensions\":[\"dts\"]},\"audio/vnd.dts.hd\":{\"source\":\"iana\",\"extensions\":[\"dtshd\"]},\"audio/vnd.dts.uhd\":{\"source\":\"iana\"},\"audio/vnd.dvb.file\":{\"source\":\"iana\"},\"audio/vnd.everad.plj\":{\"source\":\"iana\"},\"audio/vnd.hns.audio\":{\"source\":\"iana\"},\"audio/vnd.lucent.voice\":{\"source\":\"iana\",\"extensions\":[\"lvp\"]},\"audio/vnd.ms-playready.media.pya\":{\"source\":\"iana\",\"extensions\":[\"pya\"]},\"audio/vnd.nokia.mobile-xmf\":{\"source\":\"iana\"},\"audio/vnd.nortel.vbk\":{\"source\":\"iana\"},\"audio/vnd.nuera.ecelp4800\":{\"source\":\"iana\",\"extensions\":[\"ecelp4800\"]},\"audio/vnd.nuera.ecelp7470\":{\"source\":\"iana\",\"extensions\":[\"ecelp7470\"]},\"audio/vnd.nuera.ecelp9600\":{\"source\":\"iana\",\"extensions\":[\"ecelp9600\"]},\"audio/vnd.octel.sbc\":{\"source\":\"iana\"},\"audio/vnd.presonus.multitrack\":{\"source\":\"iana\"},\"audio/vnd.qcelp\":{\"source\":\"iana\"},\"audio/vnd.rhetorex.32kadpcm\":{\"source\":\"iana\"},\"audio/vnd.rip\":{\"source\":\"iana\",\"extensions\":[\"rip\"]},\"audio/vnd.rn-realaudio\":{\"compressible\":false},\"audio/vnd.sealedmedia.softseal.mpeg\":{\"source\":\"iana\"},\"audio/vnd.vmx.cvsd\":{\"source\":\"iana\"},\"audio/vnd.wave\":{\"compressible\":false},\"audio/vorbis\":{\"source\":\"iana\",\"compressible\":false},\"audio/vorbis-config\":{\"source\":\"iana\"},\"audio/wav\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/wave\":{\"compressible\":false,\"extensions\":[\"wav\"]},\"audio/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"weba\"]},\"audio/x-aac\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"aac\"]},\"audio/x-aiff\":{\"source\":\"apache\",\"extensions\":[\"aif\",\"aiff\",\"aifc\"]},\"audio/x-caf\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"caf\"]},\"audio/x-flac\":{\"source\":\"apache\",\"extensions\":[\"flac\"]},\"audio/x-m4a\":{\"source\":\"nginx\",\"extensions\":[\"m4a\"]},\"audio/x-matroska\":{\"source\":\"apache\",\"extensions\":[\"mka\"]},\"audio/x-mpegurl\":{\"source\":\"apache\",\"extensions\":[\"m3u\"]},\"audio/x-ms-wax\":{\"source\":\"apache\",\"extensions\":[\"wax\"]},\"audio/x-ms-wma\":{\"source\":\"apache\",\"extensions\":[\"wma\"]},\"audio/x-pn-realaudio\":{\"source\":\"apache\",\"extensions\":[\"ram\",\"ra\"]},\"audio/x-pn-realaudio-plugin\":{\"source\":\"apache\",\"extensions\":[\"rmp\"]},\"audio/x-realaudio\":{\"source\":\"nginx\",\"extensions\":[\"ra\"]},\"audio/x-tta\":{\"source\":\"apache\"},\"audio/x-wav\":{\"source\":\"apache\",\"extensions\":[\"wav\"]},\"audio/xm\":{\"source\":\"apache\",\"extensions\":[\"xm\"]},\"chemical/x-cdx\":{\"source\":\"apache\",\"extensions\":[\"cdx\"]},\"chemical/x-cif\":{\"source\":\"apache\",\"extensions\":[\"cif\"]},\"chemical/x-cmdf\":{\"source\":\"apache\",\"extensions\":[\"cmdf\"]},\"chemical/x-cml\":{\"source\":\"apache\",\"extensions\":[\"cml\"]},\"chemical/x-csml\":{\"source\":\"apache\",\"extensions\":[\"csml\"]},\"chemical/x-pdb\":{\"source\":\"apache\"},\"chemical/x-xyz\":{\"source\":\"apache\",\"extensions\":[\"xyz\"]},\"font/collection\":{\"source\":\"iana\",\"extensions\":[\"ttc\"]},\"font/otf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"otf\"]},\"font/sfnt\":{\"source\":\"iana\"},\"font/ttf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"ttf\"]},\"font/woff\":{\"source\":\"iana\",\"extensions\":[\"woff\"]},\"font/woff2\":{\"source\":\"iana\",\"extensions\":[\"woff2\"]},\"image/aces\":{\"source\":\"iana\",\"extensions\":[\"exr\"]},\"image/apng\":{\"compressible\":false,\"extensions\":[\"apng\"]},\"image/avci\":{\"source\":\"iana\"},\"image/avcs\":{\"source\":\"iana\"},\"image/bmp\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/cgm\":{\"source\":\"iana\",\"extensions\":[\"cgm\"]},\"image/dicom-rle\":{\"source\":\"iana\",\"extensions\":[\"drle\"]},\"image/emf\":{\"source\":\"iana\",\"extensions\":[\"emf\"]},\"image/fits\":{\"source\":\"iana\",\"extensions\":[\"fits\"]},\"image/g3fax\":{\"source\":\"iana\",\"extensions\":[\"g3\"]},\"image/gif\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"gif\"]},\"image/heic\":{\"source\":\"iana\",\"extensions\":[\"heic\"]},\"image/heic-sequence\":{\"source\":\"iana\",\"extensions\":[\"heics\"]},\"image/heif\":{\"source\":\"iana\",\"extensions\":[\"heif\"]},\"image/heif-sequence\":{\"source\":\"iana\",\"extensions\":[\"heifs\"]},\"image/hej2k\":{\"source\":\"iana\",\"extensions\":[\"hej2\"]},\"image/hsj2\":{\"source\":\"iana\",\"extensions\":[\"hsj2\"]},\"image/ief\":{\"source\":\"iana\",\"extensions\":[\"ief\"]},\"image/jls\":{\"source\":\"iana\",\"extensions\":[\"jls\"]},\"image/jp2\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jp2\",\"jpg2\"]},\"image/jpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpeg\",\"jpg\",\"jpe\"]},\"image/jph\":{\"source\":\"iana\",\"extensions\":[\"jph\"]},\"image/jphc\":{\"source\":\"iana\",\"extensions\":[\"jhc\"]},\"image/jpm\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpm\"]},\"image/jpx\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"jpx\",\"jpf\"]},\"image/jxr\":{\"source\":\"iana\",\"extensions\":[\"jxr\"]},\"image/jxra\":{\"source\":\"iana\",\"extensions\":[\"jxra\"]},\"image/jxrs\":{\"source\":\"iana\",\"extensions\":[\"jxrs\"]},\"image/jxs\":{\"source\":\"iana\",\"extensions\":[\"jxs\"]},\"image/jxsc\":{\"source\":\"iana\",\"extensions\":[\"jxsc\"]},\"image/jxsi\":{\"source\":\"iana\",\"extensions\":[\"jxsi\"]},\"image/jxss\":{\"source\":\"iana\",\"extensions\":[\"jxss\"]},\"image/ktx\":{\"source\":\"iana\",\"extensions\":[\"ktx\"]},\"image/naplps\":{\"source\":\"iana\"},\"image/pjpeg\":{\"compressible\":false},\"image/png\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"png\"]},\"image/prs.btif\":{\"source\":\"iana\",\"extensions\":[\"btif\"]},\"image/prs.pti\":{\"source\":\"iana\",\"extensions\":[\"pti\"]},\"image/pwg-raster\":{\"source\":\"iana\"},\"image/sgi\":{\"source\":\"apache\",\"extensions\":[\"sgi\"]},\"image/svg+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"svg\",\"svgz\"]},\"image/t38\":{\"source\":\"iana\",\"extensions\":[\"t38\"]},\"image/tiff\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"tif\",\"tiff\"]},\"image/tiff-fx\":{\"source\":\"iana\",\"extensions\":[\"tfx\"]},\"image/vnd.adobe.photoshop\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"psd\"]},\"image/vnd.airzip.accelerator.azv\":{\"source\":\"iana\",\"extensions\":[\"azv\"]},\"image/vnd.cns.inf2\":{\"source\":\"iana\"},\"image/vnd.dece.graphic\":{\"source\":\"iana\",\"extensions\":[\"uvi\",\"uvvi\",\"uvg\",\"uvvg\"]},\"image/vnd.djvu\":{\"source\":\"iana\",\"extensions\":[\"djvu\",\"djv\"]},\"image/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"image/vnd.dwg\":{\"source\":\"iana\",\"extensions\":[\"dwg\"]},\"image/vnd.dxf\":{\"source\":\"iana\",\"extensions\":[\"dxf\"]},\"image/vnd.fastbidsheet\":{\"source\":\"iana\",\"extensions\":[\"fbs\"]},\"image/vnd.fpx\":{\"source\":\"iana\",\"extensions\":[\"fpx\"]},\"image/vnd.fst\":{\"source\":\"iana\",\"extensions\":[\"fst\"]},\"image/vnd.fujixerox.edmics-mmr\":{\"source\":\"iana\",\"extensions\":[\"mmr\"]},\"image/vnd.fujixerox.edmics-rlc\":{\"source\":\"iana\",\"extensions\":[\"rlc\"]},\"image/vnd.globalgraphics.pgb\":{\"source\":\"iana\"},\"image/vnd.microsoft.icon\":{\"source\":\"iana\",\"extensions\":[\"ico\"]},\"image/vnd.mix\":{\"source\":\"iana\"},\"image/vnd.mozilla.apng\":{\"source\":\"iana\"},\"image/vnd.ms-dds\":{\"extensions\":[\"dds\"]},\"image/vnd.ms-modi\":{\"source\":\"iana\",\"extensions\":[\"mdi\"]},\"image/vnd.ms-photo\":{\"source\":\"apache\",\"extensions\":[\"wdp\"]},\"image/vnd.net-fpx\":{\"source\":\"iana\",\"extensions\":[\"npx\"]},\"image/vnd.radiance\":{\"source\":\"iana\"},\"image/vnd.sealed.png\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.gif\":{\"source\":\"iana\"},\"image/vnd.sealedmedia.softseal.jpg\":{\"source\":\"iana\"},\"image/vnd.svf\":{\"source\":\"iana\"},\"image/vnd.tencent.tap\":{\"source\":\"iana\",\"extensions\":[\"tap\"]},\"image/vnd.valve.source.texture\":{\"source\":\"iana\",\"extensions\":[\"vtf\"]},\"image/vnd.wap.wbmp\":{\"source\":\"iana\",\"extensions\":[\"wbmp\"]},\"image/vnd.xiff\":{\"source\":\"iana\",\"extensions\":[\"xif\"]},\"image/vnd.zbrush.pcx\":{\"source\":\"iana\",\"extensions\":[\"pcx\"]},\"image/webp\":{\"source\":\"apache\",\"extensions\":[\"webp\"]},\"image/wmf\":{\"source\":\"iana\",\"extensions\":[\"wmf\"]},\"image/x-3ds\":{\"source\":\"apache\",\"extensions\":[\"3ds\"]},\"image/x-cmu-raster\":{\"source\":\"apache\",\"extensions\":[\"ras\"]},\"image/x-cmx\":{\"source\":\"apache\",\"extensions\":[\"cmx\"]},\"image/x-freehand\":{\"source\":\"apache\",\"extensions\":[\"fh\",\"fhc\",\"fh4\",\"fh5\",\"fh7\"]},\"image/x-icon\":{\"source\":\"apache\",\"compressible\":true,\"extensions\":[\"ico\"]},\"image/x-jng\":{\"source\":\"nginx\",\"extensions\":[\"jng\"]},\"image/x-mrsid-image\":{\"source\":\"apache\",\"extensions\":[\"sid\"]},\"image/x-ms-bmp\":{\"source\":\"nginx\",\"compressible\":true,\"extensions\":[\"bmp\"]},\"image/x-pcx\":{\"source\":\"apache\",\"extensions\":[\"pcx\"]},\"image/x-pict\":{\"source\":\"apache\",\"extensions\":[\"pic\",\"pct\"]},\"image/x-portable-anymap\":{\"source\":\"apache\",\"extensions\":[\"pnm\"]},\"image/x-portable-bitmap\":{\"source\":\"apache\",\"extensions\":[\"pbm\"]},\"image/x-portable-graymap\":{\"source\":\"apache\",\"extensions\":[\"pgm\"]},\"image/x-portable-pixmap\":{\"source\":\"apache\",\"extensions\":[\"ppm\"]},\"image/x-rgb\":{\"source\":\"apache\",\"extensions\":[\"rgb\"]},\"image/x-tga\":{\"source\":\"apache\",\"extensions\":[\"tga\"]},\"image/x-xbitmap\":{\"source\":\"apache\",\"extensions\":[\"xbm\"]},\"image/x-xcf\":{\"compressible\":false},\"image/x-xpixmap\":{\"source\":\"apache\",\"extensions\":[\"xpm\"]},\"image/x-xwindowdump\":{\"source\":\"apache\",\"extensions\":[\"xwd\"]},\"message/cpim\":{\"source\":\"iana\"},\"message/delivery-status\":{\"source\":\"iana\"},\"message/disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"disposition-notification\"]},\"message/external-body\":{\"source\":\"iana\"},\"message/feedback-report\":{\"source\":\"iana\"},\"message/global\":{\"source\":\"iana\",\"extensions\":[\"u8msg\"]},\"message/global-delivery-status\":{\"source\":\"iana\",\"extensions\":[\"u8dsn\"]},\"message/global-disposition-notification\":{\"source\":\"iana\",\"extensions\":[\"u8mdn\"]},\"message/global-headers\":{\"source\":\"iana\",\"extensions\":[\"u8hdr\"]},\"message/http\":{\"source\":\"iana\",\"compressible\":false},\"message/imdn+xml\":{\"source\":\"iana\",\"compressible\":true},\"message/news\":{\"source\":\"iana\"},\"message/partial\":{\"source\":\"iana\",\"compressible\":false},\"message/rfc822\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"eml\",\"mime\"]},\"message/s-http\":{\"source\":\"iana\"},\"message/sip\":{\"source\":\"iana\"},\"message/sipfrag\":{\"source\":\"iana\"},\"message/tracking-status\":{\"source\":\"iana\"},\"message/vnd.si.simp\":{\"source\":\"iana\"},\"message/vnd.wfa.wsc\":{\"source\":\"iana\",\"extensions\":[\"wsc\"]},\"model/3mf\":{\"source\":\"iana\",\"extensions\":[\"3mf\"]},\"model/gltf+json\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"gltf\"]},\"model/gltf-binary\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"glb\"]},\"model/iges\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"igs\",\"iges\"]},\"model/mesh\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"msh\",\"mesh\",\"silo\"]},\"model/stl\":{\"source\":\"iana\",\"extensions\":[\"stl\"]},\"model/vnd.collada+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"dae\"]},\"model/vnd.dwf\":{\"source\":\"iana\",\"extensions\":[\"dwf\"]},\"model/vnd.flatland.3dml\":{\"source\":\"iana\"},\"model/vnd.gdl\":{\"source\":\"iana\",\"extensions\":[\"gdl\"]},\"model/vnd.gs-gdl\":{\"source\":\"apache\"},\"model/vnd.gs.gdl\":{\"source\":\"iana\"},\"model/vnd.gtw\":{\"source\":\"iana\",\"extensions\":[\"gtw\"]},\"model/vnd.moml+xml\":{\"source\":\"iana\",\"compressible\":true},\"model/vnd.mts\":{\"source\":\"iana\",\"extensions\":[\"mts\"]},\"model/vnd.opengex\":{\"source\":\"iana\",\"extensions\":[\"ogex\"]},\"model/vnd.parasolid.transmit.binary\":{\"source\":\"iana\",\"extensions\":[\"x_b\"]},\"model/vnd.parasolid.transmit.text\":{\"source\":\"iana\",\"extensions\":[\"x_t\"]},\"model/vnd.rosette.annotated-data-model\":{\"source\":\"iana\"},\"model/vnd.usdz+zip\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"usdz\"]},\"model/vnd.valve.source.compiled-map\":{\"source\":\"iana\",\"extensions\":[\"bsp\"]},\"model/vnd.vtu\":{\"source\":\"iana\",\"extensions\":[\"vtu\"]},\"model/vrml\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"wrl\",\"vrml\"]},\"model/x3d+binary\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3db\",\"x3dbz\"]},\"model/x3d+fastinfoset\":{\"source\":\"iana\",\"extensions\":[\"x3db\"]},\"model/x3d+vrml\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"x3dv\",\"x3dvz\"]},\"model/x3d+xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"x3d\",\"x3dz\"]},\"model/x3d-vrml\":{\"source\":\"iana\",\"extensions\":[\"x3dv\"]},\"multipart/alternative\":{\"source\":\"iana\",\"compressible\":false},\"multipart/appledouble\":{\"source\":\"iana\"},\"multipart/byteranges\":{\"source\":\"iana\"},\"multipart/digest\":{\"source\":\"iana\"},\"multipart/encrypted\":{\"source\":\"iana\",\"compressible\":false},\"multipart/form-data\":{\"source\":\"iana\",\"compressible\":false},\"multipart/header-set\":{\"source\":\"iana\"},\"multipart/mixed\":{\"source\":\"iana\"},\"multipart/multilingual\":{\"source\":\"iana\"},\"multipart/parallel\":{\"source\":\"iana\"},\"multipart/related\":{\"source\":\"iana\",\"compressible\":false},\"multipart/report\":{\"source\":\"iana\"},\"multipart/signed\":{\"source\":\"iana\",\"compressible\":false},\"multipart/vnd.bint.med-plus\":{\"source\":\"iana\"},\"multipart/voice-message\":{\"source\":\"iana\"},\"multipart/x-mixed-replace\":{\"source\":\"iana\"},\"text/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"text/cache-manifest\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"appcache\",\"manifest\"]},\"text/calendar\":{\"source\":\"iana\",\"extensions\":[\"ics\",\"ifb\"]},\"text/calender\":{\"compressible\":true},\"text/cmd\":{\"compressible\":true},\"text/coffeescript\":{\"extensions\":[\"coffee\",\"litcoffee\"]},\"text/css\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"css\"]},\"text/csv\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"csv\"]},\"text/csv-schema\":{\"source\":\"iana\"},\"text/directory\":{\"source\":\"iana\"},\"text/dns\":{\"source\":\"iana\"},\"text/ecmascript\":{\"source\":\"iana\"},\"text/encaprtp\":{\"source\":\"iana\"},\"text/enriched\":{\"source\":\"iana\"},\"text/flexfec\":{\"source\":\"iana\"},\"text/fwdred\":{\"source\":\"iana\"},\"text/grammar-ref-list\":{\"source\":\"iana\"},\"text/html\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"html\",\"htm\",\"shtml\"]},\"text/jade\":{\"extensions\":[\"jade\"]},\"text/javascript\":{\"source\":\"iana\",\"compressible\":true},\"text/jcr-cnd\":{\"source\":\"iana\"},\"text/jsx\":{\"compressible\":true,\"extensions\":[\"jsx\"]},\"text/less\":{\"compressible\":true,\"extensions\":[\"less\"]},\"text/markdown\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"markdown\",\"md\"]},\"text/mathml\":{\"source\":\"nginx\",\"extensions\":[\"mml\"]},\"text/mdx\":{\"compressible\":true,\"extensions\":[\"mdx\"]},\"text/mizar\":{\"source\":\"iana\"},\"text/n3\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"n3\"]},\"text/parameters\":{\"source\":\"iana\"},\"text/parityfec\":{\"source\":\"iana\"},\"text/plain\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"txt\",\"text\",\"conf\",\"def\",\"list\",\"log\",\"in\",\"ini\"]},\"text/provenance-notation\":{\"source\":\"iana\"},\"text/prs.fallenstein.rst\":{\"source\":\"iana\"},\"text/prs.lines.tag\":{\"source\":\"iana\",\"extensions\":[\"dsc\"]},\"text/prs.prop.logic\":{\"source\":\"iana\"},\"text/raptorfec\":{\"source\":\"iana\"},\"text/red\":{\"source\":\"iana\"},\"text/rfc822-headers\":{\"source\":\"iana\"},\"text/richtext\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtx\"]},\"text/rtf\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"rtf\"]},\"text/rtp-enc-aescm128\":{\"source\":\"iana\"},\"text/rtploopback\":{\"source\":\"iana\"},\"text/rtx\":{\"source\":\"iana\"},\"text/sgml\":{\"source\":\"iana\",\"extensions\":[\"sgml\",\"sgm\"]},\"text/shex\":{\"extensions\":[\"shex\"]},\"text/slim\":{\"extensions\":[\"slim\",\"slm\"]},\"text/strings\":{\"source\":\"iana\"},\"text/stylus\":{\"extensions\":[\"stylus\",\"styl\"]},\"text/t140\":{\"source\":\"iana\"},\"text/tab-separated-values\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"tsv\"]},\"text/troff\":{\"source\":\"iana\",\"extensions\":[\"t\",\"tr\",\"roff\",\"man\",\"me\",\"ms\"]},\"text/turtle\":{\"source\":\"iana\",\"charset\":\"UTF-8\",\"extensions\":[\"ttl\"]},\"text/ulpfec\":{\"source\":\"iana\"},\"text/uri-list\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"uri\",\"uris\",\"urls\"]},\"text/vcard\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"vcard\"]},\"text/vnd.a\":{\"source\":\"iana\"},\"text/vnd.abc\":{\"source\":\"iana\"},\"text/vnd.ascii-art\":{\"source\":\"iana\"},\"text/vnd.curl\":{\"source\":\"iana\",\"extensions\":[\"curl\"]},\"text/vnd.curl.dcurl\":{\"source\":\"apache\",\"extensions\":[\"dcurl\"]},\"text/vnd.curl.mcurl\":{\"source\":\"apache\",\"extensions\":[\"mcurl\"]},\"text/vnd.curl.scurl\":{\"source\":\"apache\",\"extensions\":[\"scurl\"]},\"text/vnd.debian.copyright\":{\"source\":\"iana\"},\"text/vnd.dmclientscript\":{\"source\":\"iana\"},\"text/vnd.dvb.subtitle\":{\"source\":\"iana\",\"extensions\":[\"sub\"]},\"text/vnd.esmertec.theme-descriptor\":{\"source\":\"iana\"},\"text/vnd.ficlab.flt\":{\"source\":\"iana\"},\"text/vnd.fly\":{\"source\":\"iana\",\"extensions\":[\"fly\"]},\"text/vnd.fmi.flexstor\":{\"source\":\"iana\",\"extensions\":[\"flx\"]},\"text/vnd.gml\":{\"source\":\"iana\"},\"text/vnd.graphviz\":{\"source\":\"iana\",\"extensions\":[\"gv\"]},\"text/vnd.hgl\":{\"source\":\"iana\"},\"text/vnd.in3d.3dml\":{\"source\":\"iana\",\"extensions\":[\"3dml\"]},\"text/vnd.in3d.spot\":{\"source\":\"iana\",\"extensions\":[\"spot\"]},\"text/vnd.iptc.newsml\":{\"source\":\"iana\"},\"text/vnd.iptc.nitf\":{\"source\":\"iana\"},\"text/vnd.latex-z\":{\"source\":\"iana\"},\"text/vnd.motorola.reflex\":{\"source\":\"iana\"},\"text/vnd.ms-mediapackage\":{\"source\":\"iana\"},\"text/vnd.net2phone.commcenter.command\":{\"source\":\"iana\"},\"text/vnd.radisys.msml-basic-layout\":{\"source\":\"iana\"},\"text/vnd.senx.warpscript\":{\"source\":\"iana\"},\"text/vnd.si.uricatalogue\":{\"source\":\"iana\"},\"text/vnd.sosi\":{\"source\":\"iana\"},\"text/vnd.sun.j2me.app-descriptor\":{\"source\":\"iana\",\"extensions\":[\"jad\"]},\"text/vnd.trolltech.linguist\":{\"source\":\"iana\"},\"text/vnd.wap.si\":{\"source\":\"iana\"},\"text/vnd.wap.sl\":{\"source\":\"iana\"},\"text/vnd.wap.wml\":{\"source\":\"iana\",\"extensions\":[\"wml\"]},\"text/vnd.wap.wmlscript\":{\"source\":\"iana\",\"extensions\":[\"wmls\"]},\"text/vtt\":{\"charset\":\"UTF-8\",\"compressible\":true,\"extensions\":[\"vtt\"]},\"text/x-asm\":{\"source\":\"apache\",\"extensions\":[\"s\",\"asm\"]},\"text/x-c\":{\"source\":\"apache\",\"extensions\":[\"c\",\"cc\",\"cxx\",\"cpp\",\"h\",\"hh\",\"dic\"]},\"text/x-component\":{\"source\":\"nginx\",\"extensions\":[\"htc\"]},\"text/x-fortran\":{\"source\":\"apache\",\"extensions\":[\"f\",\"for\",\"f77\",\"f90\"]},\"text/x-gwt-rpc\":{\"compressible\":true},\"text/x-handlebars-template\":{\"extensions\":[\"hbs\"]},\"text/x-java-source\":{\"source\":\"apache\",\"extensions\":[\"java\"]},\"text/x-jquery-tmpl\":{\"compressible\":true},\"text/x-lua\":{\"extensions\":[\"lua\"]},\"text/x-markdown\":{\"compressible\":true,\"extensions\":[\"mkd\"]},\"text/x-nfo\":{\"source\":\"apache\",\"extensions\":[\"nfo\"]},\"text/x-opml\":{\"source\":\"apache\",\"extensions\":[\"opml\"]},\"text/x-org\":{\"compressible\":true,\"extensions\":[\"org\"]},\"text/x-pascal\":{\"source\":\"apache\",\"extensions\":[\"p\",\"pas\"]},\"text/x-processing\":{\"compressible\":true,\"extensions\":[\"pde\"]},\"text/x-sass\":{\"extensions\":[\"sass\"]},\"text/x-scss\":{\"extensions\":[\"scss\"]},\"text/x-setext\":{\"source\":\"apache\",\"extensions\":[\"etx\"]},\"text/x-sfv\":{\"source\":\"apache\",\"extensions\":[\"sfv\"]},\"text/x-suse-ymp\":{\"compressible\":true,\"extensions\":[\"ymp\"]},\"text/x-uuencode\":{\"source\":\"apache\",\"extensions\":[\"uu\"]},\"text/x-vcalendar\":{\"source\":\"apache\",\"extensions\":[\"vcs\"]},\"text/x-vcard\":{\"source\":\"apache\",\"extensions\":[\"vcf\"]},\"text/xml\":{\"source\":\"iana\",\"compressible\":true,\"extensions\":[\"xml\"]},\"text/xml-external-parsed-entity\":{\"source\":\"iana\"},\"text/yaml\":{\"extensions\":[\"yaml\",\"yml\"]},\"video/1d-interleaved-parityfec\":{\"source\":\"iana\"},\"video/3gpp\":{\"source\":\"iana\",\"extensions\":[\"3gp\",\"3gpp\"]},\"video/3gpp-tt\":{\"source\":\"iana\"},\"video/3gpp2\":{\"source\":\"iana\",\"extensions\":[\"3g2\"]},\"video/bmpeg\":{\"source\":\"iana\"},\"video/bt656\":{\"source\":\"iana\"},\"video/celb\":{\"source\":\"iana\"},\"video/dv\":{\"source\":\"iana\"},\"video/encaprtp\":{\"source\":\"iana\"},\"video/flexfec\":{\"source\":\"iana\"},\"video/h261\":{\"source\":\"iana\",\"extensions\":[\"h261\"]},\"video/h263\":{\"source\":\"iana\",\"extensions\":[\"h263\"]},\"video/h263-1998\":{\"source\":\"iana\"},\"video/h263-2000\":{\"source\":\"iana\"},\"video/h264\":{\"source\":\"iana\",\"extensions\":[\"h264\"]},\"video/h264-rcdo\":{\"source\":\"iana\"},\"video/h264-svc\":{\"source\":\"iana\"},\"video/h265\":{\"source\":\"iana\"},\"video/iso.segment\":{\"source\":\"iana\"},\"video/jpeg\":{\"source\":\"iana\",\"extensions\":[\"jpgv\"]},\"video/jpeg2000\":{\"source\":\"iana\"},\"video/jpm\":{\"source\":\"apache\",\"extensions\":[\"jpm\",\"jpgm\"]},\"video/mj2\":{\"source\":\"iana\",\"extensions\":[\"mj2\",\"mjp2\"]},\"video/mp1s\":{\"source\":\"iana\"},\"video/mp2p\":{\"source\":\"iana\"},\"video/mp2t\":{\"source\":\"iana\",\"extensions\":[\"ts\"]},\"video/mp4\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mp4\",\"mp4v\",\"mpg4\"]},\"video/mp4v-es\":{\"source\":\"iana\"},\"video/mpeg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"mpeg\",\"mpg\",\"mpe\",\"m1v\",\"m2v\"]},\"video/mpeg4-generic\":{\"source\":\"iana\"},\"video/mpv\":{\"source\":\"iana\"},\"video/nv\":{\"source\":\"iana\"},\"video/ogg\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"ogv\"]},\"video/parityfec\":{\"source\":\"iana\"},\"video/pointer\":{\"source\":\"iana\"},\"video/quicktime\":{\"source\":\"iana\",\"compressible\":false,\"extensions\":[\"qt\",\"mov\"]},\"video/raptorfec\":{\"source\":\"iana\"},\"video/raw\":{\"source\":\"iana\"},\"video/rtp-enc-aescm128\":{\"source\":\"iana\"},\"video/rtploopback\":{\"source\":\"iana\"},\"video/rtx\":{\"source\":\"iana\"},\"video/smpte291\":{\"source\":\"iana\"},\"video/smpte292m\":{\"source\":\"iana\"},\"video/ulpfec\":{\"source\":\"iana\"},\"video/vc1\":{\"source\":\"iana\"},\"video/vc2\":{\"source\":\"iana\"},\"video/vnd.cctv\":{\"source\":\"iana\"},\"video/vnd.dece.hd\":{\"source\":\"iana\",\"extensions\":[\"uvh\",\"uvvh\"]},\"video/vnd.dece.mobile\":{\"source\":\"iana\",\"extensions\":[\"uvm\",\"uvvm\"]},\"video/vnd.dece.mp4\":{\"source\":\"iana\"},\"video/vnd.dece.pd\":{\"source\":\"iana\",\"extensions\":[\"uvp\",\"uvvp\"]},\"video/vnd.dece.sd\":{\"source\":\"iana\",\"extensions\":[\"uvs\",\"uvvs\"]},\"video/vnd.dece.video\":{\"source\":\"iana\",\"extensions\":[\"uvv\",\"uvvv\"]},\"video/vnd.directv.mpeg\":{\"source\":\"iana\"},\"video/vnd.directv.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dlna.mpeg-tts\":{\"source\":\"iana\"},\"video/vnd.dvb.file\":{\"source\":\"iana\",\"extensions\":[\"dvb\"]},\"video/vnd.fvt\":{\"source\":\"iana\",\"extensions\":[\"fvt\"]},\"video/vnd.hns.video\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.1dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-1010\":{\"source\":\"iana\"},\"video/vnd.iptvforum.2dparityfec-2005\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsavc\":{\"source\":\"iana\"},\"video/vnd.iptvforum.ttsmpeg2\":{\"source\":\"iana\"},\"video/vnd.motorola.video\":{\"source\":\"iana\"},\"video/vnd.motorola.videop\":{\"source\":\"iana\"},\"video/vnd.mpegurl\":{\"source\":\"iana\",\"extensions\":[\"mxu\",\"m4u\"]},\"video/vnd.ms-playready.media.pyv\":{\"source\":\"iana\",\"extensions\":[\"pyv\"]},\"video/vnd.nokia.interleaved-multimedia\":{\"source\":\"iana\"},\"video/vnd.nokia.mp4vr\":{\"source\":\"iana\"},\"video/vnd.nokia.videovoip\":{\"source\":\"iana\"},\"video/vnd.objectvideo\":{\"source\":\"iana\"},\"video/vnd.radgamettools.bink\":{\"source\":\"iana\"},\"video/vnd.radgamettools.smacker\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg1\":{\"source\":\"iana\"},\"video/vnd.sealed.mpeg4\":{\"source\":\"iana\"},\"video/vnd.sealed.swf\":{\"source\":\"iana\"},\"video/vnd.sealedmedia.softseal.mov\":{\"source\":\"iana\"},\"video/vnd.uvvu.mp4\":{\"source\":\"iana\",\"extensions\":[\"uvu\",\"uvvu\"]},\"video/vnd.vivo\":{\"source\":\"iana\",\"extensions\":[\"viv\"]},\"video/vnd.youtube.yt\":{\"source\":\"iana\"},\"video/vp8\":{\"source\":\"iana\"},\"video/webm\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"webm\"]},\"video/x-f4v\":{\"source\":\"apache\",\"extensions\":[\"f4v\"]},\"video/x-fli\":{\"source\":\"apache\",\"extensions\":[\"fli\"]},\"video/x-flv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"flv\"]},\"video/x-m4v\":{\"source\":\"apache\",\"extensions\":[\"m4v\"]},\"video/x-matroska\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"mkv\",\"mk3d\",\"mks\"]},\"video/x-mng\":{\"source\":\"apache\",\"extensions\":[\"mng\"]},\"video/x-ms-asf\":{\"source\":\"apache\",\"extensions\":[\"asf\",\"asx\"]},\"video/x-ms-vob\":{\"source\":\"apache\",\"extensions\":[\"vob\"]},\"video/x-ms-wm\":{\"source\":\"apache\",\"extensions\":[\"wm\"]},\"video/x-ms-wmv\":{\"source\":\"apache\",\"compressible\":false,\"extensions\":[\"wmv\"]},\"video/x-ms-wmx\":{\"source\":\"apache\",\"extensions\":[\"wmx\"]},\"video/x-ms-wvx\":{\"source\":\"apache\",\"extensions\":[\"wvx\"]},\"video/x-msvideo\":{\"source\":\"apache\",\"extensions\":[\"avi\"]},\"video/x-sgi-movie\":{\"source\":\"apache\",\"extensions\":[\"movie\"]},\"video/x-smv\":{\"source\":\"apache\",\"extensions\":[\"smv\"]},\"x-conference/x-cooltalk\":{\"source\":\"apache\",\"extensions\":[\"ice\"]},\"x-shader/x-fragment\":{\"compressible\":true},\"x-shader/x-vertex\":{\"compressible\":true}}");

/***/ }),

/***/ "./node_modules/mini-create-react-context/dist/esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/mini-create-react-context/dist/esm/index.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ "./node_modules/@babel/runtime/helpers/inheritsLoose.js");
/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var gud__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gud */ "./node_modules/gud/index.js");
/* harmony import */ var gud__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(gud__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");






var MAX_SIGNED_31_BIT_INT = 1073741823;

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + gud__WEBPACK_IMPORTED_MODULE_3___default()() + '__';

  var Provider =
  /*#__PURE__*/
  function (_Component) {
    _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if (true) {
            Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired, _Provider$childContex);

  var Consumer =
  /*#__PURE__*/
  function (_Component2) {
    _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1___default()(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}

var index = react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext || createReactContext;

/* harmony default export */ __webpack_exports__["default"] = (index);


/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/path-to-regexp/index.js":
/*!**********************************************!*\
  !*** ./node_modules/path-to-regexp/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__(/*! isarray */ "./node_modules/path-to-regexp/node_modules/isarray/index.js")

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),

/***/ "./node_modules/path-to-regexp/node_modules/isarray/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/path-to-regexp/node_modules/isarray/index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(/*! ./pseudomap */ "./node_modules/pseudomap/pseudomap.js")
}


/***/ }),

/***/ "./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-server.node.development.js":
/*!*************************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-server.node.development.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.11.0
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");
var stream = __webpack_require__(/*! stream */ "stream");

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.11.0';

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be replaced with error codes
// during build.

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var warningWithoutStack = function () {};

{
  warningWithoutStack = function (condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (args.length > 8) {
      // Check before the condition to catch violations early.
      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
    }

    if (condition) {
      return;
    }

    if (typeof console !== 'undefined') {
      var argsWithFormat = args.map(function (item) {
        return '' + item;
      });
      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610

      Function.prototype.apply.call(console.error, console, argsWithFormat);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  };
}

var warningWithoutStack$1 = warningWithoutStack;

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?


var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;

var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED; // Prevent newer renderers from RTE when used with older react package versions.
// Current owner and dispatcher used to share the same ref,
// but PR #14548 split them out to better support the react-debug-tools package.

if (!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')) {
  ReactSharedInternals.ReactCurrentDispatcher = {
    current: null
  };
}

if (!ReactSharedInternals.hasOwnProperty('ReactCurrentBatchConfig')) {
  ReactSharedInternals.ReactCurrentBatchConfig = {
    suspense: null
  };
}

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = warningWithoutStack$1;

{
  warning = function (condition, format) {
    if (condition) {
      return;
    }

    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum(); // eslint-disable-next-line react-internal/warning-and-invariant-args

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    warningWithoutStack$1.apply(void 0, [false, format + '%s'].concat(args, [stack]));
  };
}

var warning$1 = warning;

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;
function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}
function initializeLazyComponentType(lazyComponent) {
  if (lazyComponent._status === Uninitialized) {
    lazyComponent._status = Pending;
    var ctor = lazyComponent._ctor;
    var thenable = ctor();
    lazyComponent._result = thenable;
    thenable.then(function (moduleObject) {
      if (lazyComponent._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            warning$1(false, 'lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + "const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
          }
        }

        lazyComponent._status = Resolved;
        lazyComponent._result = defaultExport;
      }
    }, function (error) {
      if (lazyComponent._status === Pending) {
        lazyComponent._status = Rejected;
        lazyComponent._result = error;
      }
    });
  }
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return "Profiler";

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';

      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = refineResolvedLazyComponent(thenable);

          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }

          break;
        }
    }
  }

  return null;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var lowPriorityWarningWithoutStack = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.warn(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarningWithoutStack = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  };
}

var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
var describeComponentFrame = function (name, source, ownerName) {
  var sourceInfo = '';

  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');

    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);

        if (match) {
          var pathBeforeSlash = match[1];

          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }

    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }

  return '\n    in ' + (name || 'Unknown') + sourceInfo;
};

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:

 // In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:

 // To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.

 // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:

var warnAboutDeprecatedLifecycles = true; // Gather advanced timing metrics for Profiler subtrees.

 // Trace which interactions trigger each commit.

 // SSR experiments

var enableSuspenseServerRenderer = false;
 // Only used in www builds.

 // Only used in www builds.

 // Disable javascript: URL strings in href for XSS protection.

var disableJavaScriptURLs = false; // React Fire: prevent the value and checked attributes from syncing
// with their related DOM properties

 // These APIs will no longer be "unstable" in the upcoming 16.7 release,
// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.


 // Experimental React Flare event system and event components support.

var enableFlareAPI = false; // Experimental Host Component support.

var enableFundamentalAPI = false; // Experimental Scope support.

var enableScopeAPI = false; // New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107

 // We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)
// Till then, we warn about the missing mock, but still fallback to a sync mode compatible version

 // For tests, we flush suspense fallbacks in an act scope;
// *except* in some of our own tests, where we test incremental loading states.

 // Add a callback property to suspense to notify which promises are currently
// in the update queue. This allows reporting and tracing of what is causing
// the user to see a loading state.
// Also allows hydration callbacks to fire when a dehydrated boundary gets
// hydrated or deleted.

 // Part of the simplification of React.createElement so we can eventually move
// from React.createElement to React.jsx
// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md



var disableLegacyContext = false;

var ReactDebugCurrentFrame$1;
var didWarnAboutInvalidateContextType;

{
  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
  didWarnAboutInvalidateContextType = new Set();
}

var emptyObject = {};

{
  Object.freeze(emptyObject);
}

function maskContext(type, context) {
  var contextTypes = type.contextTypes;

  if (!contextTypes) {
    return emptyObject;
  }

  var maskedContext = {};

  for (var contextName in contextTypes) {
    maskedContext[contextName] = context[contextName];
  }

  return maskedContext;
}

function checkContextTypes(typeSpecs, values, location) {
  {
    checkPropTypes(typeSpecs, values, location, 'Component', ReactDebugCurrentFrame$1.getCurrentStack);
  }
}

function validateContextBounds(context, threadID) {
  // If we don't have enough slots in this context to store this threadID,
  // fill it in without leaving any holes to ensure that the VM optimizes
  // this as non-holey index properties.
  // (Note: If `react` package is < 16.6, _threadCount is undefined.)
  for (var i = context._threadCount | 0; i <= threadID; i++) {
    // We assume that this is the same as the defaultValue which might not be
    // true if we're rendering inside a secondary renderer but they are
    // secondary because these use cases are very rare.
    context[i] = context._currentValue2;
    context._threadCount = i + 1;
  }
}
function processContext(type, context, threadID, isClass) {
  if (isClass) {
    var contextType = type.contextType;

    {
      if ('contextType' in type) {
        var isValid = // Allow null for conditional declaration
        contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

        if (!isValid && !didWarnAboutInvalidateContextType.has(type)) {
          didWarnAboutInvalidateContextType.add(type);
          var addendum = '';

          if (contextType === undefined) {
            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
          } else if (typeof contextType !== 'object') {
            addendum = ' However, it is set to a ' + typeof contextType + '.';
          } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
            addendum = ' Did you accidentally pass the Context.Provider instead?';
          } else if (contextType._context !== undefined) {
            // <Context.Consumer>
            addendum = ' Did you accidentally pass the Context.Consumer instead?';
          } else {
            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
          }

          warningWithoutStack$1(false, '%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(type) || 'Component', addendum);
        }
      }
    }

    if (typeof contextType === 'object' && contextType !== null) {
      validateContextBounds(contextType, threadID);
      return contextType[threadID];
    }

    if (disableLegacyContext) {
      {
        if (type.contextTypes) {
          warningWithoutStack$1(false, '%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with static contextType instead.', getComponentName(type) || 'Unknown');
        }
      }

      return emptyObject;
    } else {
      var maskedContext = maskContext(type, context);

      {
        if (type.contextTypes) {
          checkContextTypes(type.contextTypes, maskedContext, 'context');
        }
      }

      return maskedContext;
    }
  } else {
    if (disableLegacyContext) {
      {
        if (type.contextTypes) {
          warningWithoutStack$1(false, '%s uses the legacy contextTypes API which is no longer supported. ' + 'Use React.createContext() with React.useContext() instead.', getComponentName(type) || 'Unknown');
        }
      }

      return undefined;
    } else {
      var _maskedContext = maskContext(type, context);

      {
        if (type.contextTypes) {
          checkContextTypes(type.contextTypes, _maskedContext, 'context');
        }
      }

      return _maskedContext;
    }
  }
}

// Allocates a new index for each request. Tries to stay as compact as possible so that these
// indices can be used to reference a tightly packed array. As opposed to being used in a Map.
// The first allocated index is 1.
var nextAvailableThreadIDs = new Uint16Array(16);

for (var i = 0; i < 15; i++) {
  nextAvailableThreadIDs[i] = i + 1;
}

nextAvailableThreadIDs[15] = 0;

function growThreadCountAndReturnNextAvailable() {
  var oldArray = nextAvailableThreadIDs;
  var oldSize = oldArray.length;
  var newSize = oldSize * 2;

  if (!(newSize <= 0x10000)) {
    {
      throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
    }
  }

  var newArray = new Uint16Array(newSize);
  newArray.set(oldArray);
  nextAvailableThreadIDs = newArray;
  nextAvailableThreadIDs[0] = oldSize + 1;

  for (var _i = oldSize; _i < newSize - 1; _i++) {
    nextAvailableThreadIDs[_i] = _i + 1;
  }

  nextAvailableThreadIDs[newSize - 1] = 0;
  return oldSize;
}

function allocThreadID() {
  var nextID = nextAvailableThreadIDs[0];

  if (nextID === 0) {
    return growThreadCountAndReturnNextAvailable();
  }

  nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
  return nextID;
}
function freeThreadID(id) {
  nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
  nextAvailableThreadIDs[0] = id;
}

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the whitelist are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */

var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";

var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty$1.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }

  if (hasOwnProperty$1.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;

  {
    warning$1(false, 'Invalid attribute name: `%s`', attributeName);
  }

  return false;
}
function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }

  return false;
}
function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  switch (typeof value) {
    case 'function': // $FlowIssue symbol is perfectly valid here

    case 'symbol':
      // eslint-disable-line
      return true;

    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }

        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }

    default:
      return false;
  }
}
function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {
    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;

      case OVERLOADED_BOOLEAN:
        return value === false;

      case NUMERIC:
        return isNaN(value);

      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }

  return false;
}
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function (token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML whitelist.
// Some of these attributes can be hard to find. This list was created by
// scrapping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true);
});

var ReactDebugCurrentFrame$2 = null;

{
  ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;
} // A javascript: URL can contain leading C0 control or \u0020 SPACE,
// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space

/* eslint-disable max-len */


var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
var didWarn = false;

function sanitizeURL(url) {
  if (disableJavaScriptURLs) {
    if (!!isJavaScriptProtocol.test(url)) {
      {
        throw Error("React has blocked a javascript: URL as a security precaution." + (ReactDebugCurrentFrame$2.getStackAddendum()));
      }
    }
  } else if ( true && !didWarn && isJavaScriptProtocol.test(url)) {
    didWarn = true;
    warning$1(false, 'A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
  }
}

// code copied and modified from escape-html

/**
 * Module variables.
 * @private
 */
var matchHtmlRegExp = /["'&<>]/;
/**
 * Escapes special characters and HTML entities in a given html string.
 *
 * @param  {string} string HTML string to escape for later insertion
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;

      case 38:
        // &
        escape = '&amp;';
        break;

      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'

        break;

      case 60:
        // <
        escape = '&lt;';
        break;

      case 62:
        // >
        escape = '&gt;';
        break;

      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
} // end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */


function escapeTextForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }

  return escapeHtml(text);
}

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */

function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextForBrowser(value) + '"';
}

/**
 * Operations for dealing with DOM properties.
 */

/**
 * Creates markup for the ID property.
 *
 * @param {string} id Unescaped ID.
 * @return {string} Markup string.
 */


function createMarkupForRoot() {
  return ROOT_ATTRIBUTE_NAME + '=""';
}
/**
 * Creates markup for a property.
 *
 * @param {string} name
 * @param {*} value
 * @return {?string} Markup string, or null if the property was invalid.
 */

function createMarkupForProperty(name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (name !== 'style' && shouldIgnoreAttribute(name, propertyInfo, false)) {
    return '';
  }

  if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
    return '';
  }

  if (propertyInfo !== null) {
    var attributeName = propertyInfo.attributeName;
    var type = propertyInfo.type;

    if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
      return attributeName + '=""';
    } else {
      if (propertyInfo.sanitizeURL) {
        value = '' + value;
        sanitizeURL(value);
      }

      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    }
  } else if (isAttributeNameSafe(name)) {
    return name + '=' + quoteAttributeValueForBrowser(value);
  }

  return '';
}
/**
 * Creates markup for a custom property.
 *
 * @param {string} name
 * @param {*} value
 * @return {string} Markup string, or empty string if the property was invalid.
 */

function createMarkupForCustomAttribute(name, value) {
  if (!isAttributeNameSafe(name) || value == null) {
    return '';
  }

  return name + '=' + quoteAttributeValueForBrowser(value);
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var is$1 = typeof Object.is === 'function' ? Object.is : is;

var currentlyRenderingComponent = null;
var firstWorkInProgressHook = null;
var workInProgressHook = null; // Whether the work-in-progress hook is a re-rendered hook

var isReRender = false; // Whether an update was scheduled during the currently executing render pass.

var didScheduleRenderPhaseUpdate = false; // Lazily created map of render-phase updates

var renderPhaseUpdates = null; // Counter to prevent infinite loops.

var numberOfReRenders = 0;
var RE_RENDER_LIMIT = 25;
var isInHookUserCodeInDev = false; // In DEV, this is the name of the currently executing primitive hook

var currentHookNameInDev;

function resolveCurrentlyRenderingComponent() {
  if (!(currentlyRenderingComponent !== null)) {
    {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
    }
  }

  {
    !!isInHookUserCodeInDev ? warning$1(false, 'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://fb.me/rules-of-hooks') : void 0;
  }

  return currentlyRenderingComponent;
}

function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) {
    {
      warning$1(false, '%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }

    return false;
  }

  {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      warning$1(false, 'The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + nextDeps.join(', ') + "]", "[" + prevDeps.join(', ') + "]");
    }
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (is$1(nextDeps[i], prevDeps[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function createHook() {
  if (numberOfReRenders > 0) {
    {
      {
        throw Error("Rendered more hooks than during the previous render");
      }
    }
  }

  return {
    memoizedState: null,
    queue: null,
    next: null
  };
}

function createWorkInProgressHook() {
  if (workInProgressHook === null) {
    // This is the first hook in the list
    if (firstWorkInProgressHook === null) {
      isReRender = false;
      firstWorkInProgressHook = workInProgressHook = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = firstWorkInProgressHook;
    }
  } else {
    if (workInProgressHook.next === null) {
      isReRender = false; // Append to the end of the list

      workInProgressHook = workInProgressHook.next = createHook();
    } else {
      // There's already a work-in-progress. Reuse it.
      isReRender = true;
      workInProgressHook = workInProgressHook.next;
    }
  }

  return workInProgressHook;
}

function prepareToUseHooks(componentIdentity) {
  currentlyRenderingComponent = componentIdentity;

  {
    isInHookUserCodeInDev = false;
  } // The following should have already been reset
  // didScheduleRenderPhaseUpdate = false;
  // firstWorkInProgressHook = null;
  // numberOfReRenders = 0;
  // renderPhaseUpdates = null;
  // workInProgressHook = null;

}
function finishHooks(Component, props, children, refOrContext) {
  // This must be called after every function component to prevent hooks from
  // being used in classes.
  while (didScheduleRenderPhaseUpdate) {
    // Updates were scheduled during the render phase. They are stored in
    // the `renderPhaseUpdates` map. Call the component again, reusing the
    // work-in-progress hooks and applying the additional updates on top. Keep
    // restarting until no more updates are scheduled.
    didScheduleRenderPhaseUpdate = false;
    numberOfReRenders += 1; // Start over from the beginning of the list

    workInProgressHook = null;
    children = Component(props, refOrContext);
  }

  currentlyRenderingComponent = null;
  firstWorkInProgressHook = null;
  numberOfReRenders = 0;
  renderPhaseUpdates = null;
  workInProgressHook = null;

  {
    isInHookUserCodeInDev = false;
  } // These were reset above
  // currentlyRenderingComponent = null;
  // didScheduleRenderPhaseUpdate = false;
  // firstWorkInProgressHook = null;
  // numberOfReRenders = 0;
  // renderPhaseUpdates = null;
  // workInProgressHook = null;


  return children;
}

function readContext(context, observedBits) {
  var threadID = currentThreadID;
  validateContextBounds(context, threadID);

  {
    !!isInHookUserCodeInDev ? warning$1(false, 'Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().') : void 0;
  }

  return context[threadID];
}

function useContext(context, observedBits) {
  {
    currentHookNameInDev = 'useContext';
  }

  resolveCurrentlyRenderingComponent();
  var threadID = currentThreadID;
  validateContextBounds(context, threadID);
  return context[threadID];
}

function basicStateReducer(state, action) {
  return typeof action === 'function' ? action(state) : action;
}

function useState(initialState) {
  {
    currentHookNameInDev = 'useState';
  }

  return useReducer(basicStateReducer, // useReducer has a special case to support lazy useState initializers
  initialState);
}
function useReducer(reducer, initialArg, init) {
  {
    if (reducer !== basicStateReducer) {
      currentHookNameInDev = 'useReducer';
    }
  }

  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();

  if (isReRender) {
    // This is a re-render. Apply the new render phase updates to the previous
    // current hook.
    var queue = workInProgressHook.queue;
    var dispatch = queue.dispatch;

    if (renderPhaseUpdates !== null) {
      // Render phase updates are stored in a map of queue -> linked list
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

      if (firstRenderPhaseUpdate !== undefined) {
        renderPhaseUpdates.delete(queue);
        var newState = workInProgressHook.memoizedState;
        var update = firstRenderPhaseUpdate;

        do {
          // Process this render phase update. We don't have to check the
          // priority because it will always be the same as the current
          // render's.
          var action = update.action;

          {
            isInHookUserCodeInDev = true;
          }

          newState = reducer(newState, action);

          {
            isInHookUserCodeInDev = false;
          }

          update = update.next;
        } while (update !== null);

        workInProgressHook.memoizedState = newState;
        return [newState, dispatch];
      }
    }

    return [workInProgressHook.memoizedState, dispatch];
  } else {
    {
      isInHookUserCodeInDev = true;
    }

    var initialState;

    if (reducer === basicStateReducer) {
      // Special case for `useState`.
      initialState = typeof initialArg === 'function' ? initialArg() : initialArg;
    } else {
      initialState = init !== undefined ? init(initialArg) : initialArg;
    }

    {
      isInHookUserCodeInDev = false;
    }

    workInProgressHook.memoizedState = initialState;

    var _queue = workInProgressHook.queue = {
      last: null,
      dispatch: null
    };

    var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);

    return [workInProgressHook.memoizedState, _dispatch];
  }
}

function useMemo(nextCreate, deps) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;

  if (workInProgressHook !== null) {
    var prevState = workInProgressHook.memoizedState;

    if (prevState !== null) {
      if (nextDeps !== null) {
        var prevDeps = prevState[1];

        if (areHookInputsEqual(nextDeps, prevDeps)) {
          return prevState[0];
        }
      }
    }
  }

  {
    isInHookUserCodeInDev = true;
  }

  var nextValue = nextCreate();

  {
    isInHookUserCodeInDev = false;
  }

  workInProgressHook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function useRef(initialValue) {
  currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
  workInProgressHook = createWorkInProgressHook();
  var previousRef = workInProgressHook.memoizedState;

  if (previousRef === null) {
    var ref = {
      current: initialValue
    };

    {
      Object.seal(ref);
    }

    workInProgressHook.memoizedState = ref;
    return ref;
  } else {
    return previousRef;
  }
}

function useLayoutEffect(create, inputs) {
  {
    currentHookNameInDev = 'useLayoutEffect';
  }

  warning$1(false, 'useLayoutEffect does nothing on the server, because its effect cannot ' + "be encoded into the server renderer's output format. This will lead " + 'to a mismatch between the initial, non-hydrated UI and the intended ' + 'UI. To avoid this, useLayoutEffect should only be used in ' + 'components that render exclusively on the client. ' + 'See https://fb.me/react-uselayouteffect-ssr for common fixes.');
}

function dispatchAction(componentIdentity, queue, action) {
  if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
    {
      throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
    }
  }

  if (componentIdentity === currentlyRenderingComponent) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdate = true;
    var update = {
      action: action,
      next: null
    };

    if (renderPhaseUpdates === null) {
      renderPhaseUpdates = new Map();
    }

    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);

    if (firstRenderPhaseUpdate === undefined) {
      renderPhaseUpdates.set(queue, update);
    } else {
      // Append the update to the end of the list.
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;

      while (lastRenderPhaseUpdate.next !== null) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }

      lastRenderPhaseUpdate.next = update;
    }
  } else {// This means an update has happened after the function component has
    // returned. On the server this is a no-op. In React Fiber, the update
    // would be scheduled for a future render.
  }
}

function useCallback(callback, deps) {
  // Callbacks are passed as they are in the server environment.
  return callback;
}

function useResponder(responder, props) {
  return {
    props: props,
    responder: responder
  };
}

function useDeferredValue(value, config) {
  resolveCurrentlyRenderingComponent();
  return value;
}

function useTransition(config) {
  resolveCurrentlyRenderingComponent();

  var startTransition = function (callback) {
    callback();
  };

  return [startTransition, false];
}

function noop() {}

var currentThreadID = 0;
function setCurrentThreadID(threadID) {
  currentThreadID = threadID;
}
var Dispatcher = {
  readContext: readContext,
  useContext: useContext,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  useLayoutEffect: useLayoutEffect,
  useCallback: useCallback,
  // useImperativeHandle is not run in the server environment
  useImperativeHandle: noop,
  // Effects are not run in the server environment.
  useEffect: noop,
  // Debugging effect
  useDebugValue: noop,
  useResponder: useResponder,
  useDeferredValue: useDeferredValue,
  useTransition: useTransition
};

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
var Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
}; // Assumes there is no parent namespace.

function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;

    case 'math':
      return MATH_NAMESPACE;

    default:
      return HTML_NAMESPACE;
  }
}
function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }

  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  } // By default, pass namespace below.


  return parentNamespace;
}

var ReactDebugCurrentFrame$3 = null;
var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  ReactDebugCurrentFrame$3 = ReactSharedInternals.ReactDebugCurrentFrame;
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };
  var propTypes = {
    value: function (props, propName, componentName) {
      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null || enableFlareAPI && props.listeners) {
        return null;
      }

      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (props.onChange || props.readOnly || props.disabled || props[propName] == null || enableFlareAPI && props.listeners) {
        return null;
      }

      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };
  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */

  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {
    checkPropTypes(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame$3.getStackAddendum);
  };
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

};

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

// or add stack by default to invariants where possible.

var HTML = '__html';
var ReactDebugCurrentFrame$4 = null;

{
  ReactDebugCurrentFrame$4 = ReactSharedInternals.ReactDebugCurrentFrame;
}

function assertValidProps(tag, props) {
  if (!props) {
    return;
  } // Note the use of `==` which checks for null or undefined.


  if (voidElementTags[tag]) {
    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
      {
        throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." + (ReactDebugCurrentFrame$4.getStackAddendum()));
      }
    }
  }

  if (props.dangerouslySetInnerHTML != null) {
    if (!(props.children == null)) {
      {
        throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
      }
    }

    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
      {
        throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.");
      }
    }
  }

  {
    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning$1(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
  }

  if (!(props.style == null || typeof props.style === 'object')) {
    {
      throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." + (ReactDebugCurrentFrame$4.getStackAddendum()));
    }
  }
}

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon

  var badStyleValueWithSemicolonPattern = /;\s*$/;
  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$1(false, 'Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning$1(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning$1(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning$1(false, '`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning$1(false, '`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

var ariaProperties = {
  'aria-current': 0,
  // state
  'aria-details': 0,
  'aria-disabled': 0,
  // state
  'aria-hidden': 0,
  // state
  'aria-invalid': 0,
  // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.

    if (correctName == null) {
      warning$1(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);
      warnedProperties[name] = true;
      return true;
    } // aria-* attributes should be lowercase; suggest the lowercase version.


    if (name !== correctName) {
      warning$1(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.

    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    } // aria-* attributes should be lowercase; suggest the lowercase version.


    if (name !== standardName) {
      warning$1(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);

    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning$1(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  } else if (invalidProps.length > 1) {
    warning$1(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;
function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;

    if (type === 'select' && props.multiple) {
      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
    } else {
      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */



/**
 * Mapping from event name to dispatch config
 */


/**
 * Mapping from registration name to plugin module
 */

var registrationNameModules = {};
/**
 * Mapping from registration name to event name
 */


/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */

var possibleRegistrationNames = {}; // Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */


/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  disablepictureinpicture: 'disablePictureInPicture',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',
  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning$1(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    } // We can't rely on the event system being injected on the server.


    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }

      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

      if (registrationName != null) {
        warning$1(false, 'Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);
        warnedProperties$1[name] = true;
        return true;
      }

      if (EVENT_NAME_REGEX.test(name)) {
        warning$1(false, 'Unknown event handler property `%s`. It will be ignored.', name);
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning$1(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Let the ARIA attribute hook validate ARIA attributes


    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning$1(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning$1(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning$1(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning$1(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);
      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.

    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];

      if (standardName !== name) {
        warning$1(false, 'Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning$1(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Now that we've validated casing, do not validate
    // data types for reserved props


    if (isReserved) {
      return true;
    } // Warn when a known attribute is a bad type


    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    } // Warn when passing the strings 'false' or 'true' into a boolean prop


    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      warning$1(false, 'Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];

  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);

    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    warning$1(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  } else if (unknownProps.length > 1) {
    warning$1(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnUnknownProperties(type, props, canUseEventSystem);
}

var toArray = React.Children.toArray; // This is only used in DEV.
// Each entry is `this.stack` from a currently executing renderer instance.
// (There may be more than one because ReactDOMServer is reentrant).
// Each stack is an array of frames which may contain nested stacks of elements.

var currentDebugStacks = [];
var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var ReactDebugCurrentFrame;
var prevGetCurrentStackImpl = null;

var getCurrentServerStackImpl = function () {
  return '';
};

var describeStackFrame = function (element) {
  return '';
};

var validatePropertiesInDevelopment = function (type, props) {};

var pushCurrentDebugStack = function (stack) {};

var pushElementToDebugStack = function (element) {};

var popCurrentDebugStack = function () {};

var hasWarnedAboutUsingContextAsConsumer = false;

{
  ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props,
    /* canUseEventSystem */
    false);
  };

  describeStackFrame = function (element) {
    var source = element._source;
    var type = element.type;
    var name = getComponentName(type);
    var ownerName = null;
    return describeComponentFrame(name, source, ownerName);
  };

  pushCurrentDebugStack = function (stack) {
    currentDebugStacks.push(stack);

    if (currentDebugStacks.length === 1) {
      // We are entering a server renderer.
      // Remember the previous (e.g. client) global stack implementation.
      prevGetCurrentStackImpl = ReactDebugCurrentFrame.getCurrentStack;
      ReactDebugCurrentFrame.getCurrentStack = getCurrentServerStackImpl;
    }
  };

  pushElementToDebugStack = function (element) {
    // For the innermost executing ReactDOMServer call,
    var stack = currentDebugStacks[currentDebugStacks.length - 1]; // Take the innermost executing frame (e.g. <Foo>),

    var frame = stack[stack.length - 1]; // and record that it has one more element associated with it.

    frame.debugElementStack.push(element); // We only need this because we tail-optimize single-element
    // children and directly handle them in an inner loop instead of
    // creating separate frames for them.
  };

  popCurrentDebugStack = function () {
    currentDebugStacks.pop();

    if (currentDebugStacks.length === 0) {
      // We are exiting the server renderer.
      // Restore the previous (e.g. client) global stack implementation.
      ReactDebugCurrentFrame.getCurrentStack = prevGetCurrentStackImpl;
      prevGetCurrentStackImpl = null;
    }
  };

  getCurrentServerStackImpl = function () {
    if (currentDebugStacks.length === 0) {
      // Nothing is currently rendering.
      return '';
    } // ReactDOMServer is reentrant so there may be multiple calls at the same time.
    // Take the frames from the innermost call which is the last in the array.


    var frames = currentDebugStacks[currentDebugStacks.length - 1];
    var stack = ''; // Go through every frame in the stack from the innermost one.

    for (var i = frames.length - 1; i >= 0; i--) {
      var frame = frames[i]; // Every frame might have more than one debug element stack entry associated with it.
      // This is because single-child nesting doesn't create materialized frames.
      // Instead it would push them through `pushElementToDebugStack()`.

      var debugElementStack = frame.debugElementStack;

      for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
        stack += describeStackFrame(debugElementStack[ii]);
      }
    }

    return stack;
  };
}

var didWarnDefaultInputValue = false;
var didWarnDefaultChecked = false;
var didWarnDefaultSelectValue = false;
var didWarnDefaultTextareaValue = false;
var didWarnInvalidOptionChildren = false;
var didWarnAboutNoopUpdateForComponent = {};
var didWarnAboutBadClass = {};
var didWarnAboutModulePatternComponent = {};
var didWarnAboutDeprecatedWillMount = {};
var didWarnAboutUndefinedDerivedState = {};
var didWarnAboutUninitializedState = {};
var valuePropNames = ['value', 'defaultValue'];
var newlineEatingTags = {
  listing: true,
  pre: true,
  textarea: true
}; // We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset

var validatedTagCache = {};

function validateDangerousTag(tag) {
  if (!validatedTagCache.hasOwnProperty(tag)) {
    if (!VALID_TAG_REGEX.test(tag)) {
      {
        throw Error("Invalid tag: " + tag);
      }
    }

    validatedTagCache[tag] = true;
  }
}

var styleNameCache = {};

var processStyleName = function (styleName) {
  if (styleNameCache.hasOwnProperty(styleName)) {
    return styleNameCache[styleName];
  }

  var result = hyphenateStyleName(styleName);
  styleNameCache[styleName] = result;
  return result;
};

function createMarkupForStyles(styles) {
  var serialized = '';
  var delimiter = '';

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;
    var styleValue = styles[styleName];

    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styleValue);
      }
    }

    if (styleValue != null) {
      serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ':';
      serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
      delimiter = ';';
    }
  }

  return serialized || null;
}

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && getComponentName(_constructor) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;

    if (didWarnAboutNoopUpdateForComponent[warningKey]) {
      return;
    }

    warningWithoutStack$1(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnAboutNoopUpdateForComponent[warningKey] = true;
  }
}

function shouldConstruct(Component) {
  return Component.prototype && Component.prototype.isReactComponent;
}

function getNonChildrenInnerMarkup(props) {
  var innerHTML = props.dangerouslySetInnerHTML;

  if (innerHTML != null) {
    if (innerHTML.__html != null) {
      return innerHTML.__html;
    }
  } else {
    var content = props.children;

    if (typeof content === 'string' || typeof content === 'number') {
      return escapeTextForBrowser(content);
    }
  }

  return null;
}

function flattenTopLevelChildren(children) {
  if (!React.isValidElement(children)) {
    return toArray(children);
  }

  var element = children;

  if (element.type !== REACT_FRAGMENT_TYPE) {
    return [element];
  }

  var fragmentChildren = element.props.children;

  if (!React.isValidElement(fragmentChildren)) {
    return toArray(fragmentChildren);
  }

  var fragmentChildElement = fragmentChildren;
  return [fragmentChildElement];
}

function flattenOptionChildren(children) {
  if (children === undefined || children === null) {
    return children;
  }

  var content = ''; // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.

  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }

    content += child;

    {
      if (!didWarnInvalidOptionChildren && typeof child !== 'string' && typeof child !== 'number') {
        didWarnInvalidOptionChildren = true;
        warning$1(false, 'Only strings and numbers are supported as <option> children.');
      }
    }
  });
  return content;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var STYLE = 'style';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null,
  suppressHydrationWarning: null
};

function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
  var ret = '<' + tagVerbatim;

  for (var propKey in props) {
    if (!hasOwnProperty.call(props, propKey)) {
      continue;
    }

    if (enableFlareAPI && propKey === 'listeners') {
      continue;
    }

    var propValue = props[propKey];

    if (propValue == null) {
      continue;
    }

    if (propKey === STYLE) {
      propValue = createMarkupForStyles(propValue);
    }

    var markup = null;

    if (isCustomComponent(tagLowercase, props)) {
      if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
        markup = createMarkupForCustomAttribute(propKey, propValue);
      }
    } else {
      markup = createMarkupForProperty(propKey, propValue);
    }

    if (markup) {
      ret += ' ' + markup;
    }
  } // For static pages, no need to put React ID and checksum. Saves lots of
  // bytes.


  if (makeStaticMarkup) {
    return ret;
  }

  if (isRootElement) {
    ret += ' ' + createMarkupForRoot();
  }

  return ret;
}

function validateRenderResult(child, type) {
  if (child === undefined) {
    {
      {
        throw Error((getComponentName(type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
      }
    }
  }
}

function resolve(child, context, threadID) {
  while (React.isValidElement(child)) {
    // Safe because we just checked it's an element.
    var element = child;
    var Component = element.type;

    {
      pushElementToDebugStack(element);
    }

    if (typeof Component !== 'function') {
      break;
    }

    processChild(element, Component);
  } // Extra closure so queue and replace can be captured properly


  function processChild(element, Component) {
    var isClass = shouldConstruct(Component);
    var publicContext = processContext(Component, context, threadID, isClass);
    var queue = [];
    var replace = false;
    var updater = {
      isMounted: function (publicInstance) {
        return false;
      },
      enqueueForceUpdate: function (publicInstance) {
        if (queue === null) {
          warnNoop(publicInstance, 'forceUpdate');
          return null;
        }
      },
      enqueueReplaceState: function (publicInstance, completeState) {
        replace = true;
        queue = [completeState];
      },
      enqueueSetState: function (publicInstance, currentPartialState) {
        if (queue === null) {
          warnNoop(publicInstance, 'setState');
          return null;
        }

        queue.push(currentPartialState);
      }
    };
    var inst;

    if (isClass) {
      inst = new Component(element.props, publicContext, updater);

      if (typeof Component.getDerivedStateFromProps === 'function') {
        {
          if (inst.state === null || inst.state === undefined) {
            var componentName = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutUninitializedState[componentName]) {
              warningWithoutStack$1(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, inst.state === null ? 'null' : 'undefined', componentName);
              didWarnAboutUninitializedState[componentName] = true;
            }
          }
        }

        var partialState = Component.getDerivedStateFromProps.call(null, element.props, inst.state);

        {
          if (partialState === undefined) {
            var _componentName = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutUndefinedDerivedState[_componentName]) {
              warningWithoutStack$1(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', _componentName);
              didWarnAboutUndefinedDerivedState[_componentName] = true;
            }
          }
        }

        if (partialState != null) {
          inst.state = _assign({}, inst.state, partialState);
        }
      }
    } else {
      {
        if (Component.prototype && typeof Component.prototype.render === 'function') {
          var _componentName2 = getComponentName(Component) || 'Unknown';

          if (!didWarnAboutBadClass[_componentName2]) {
            warningWithoutStack$1(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', _componentName2, _componentName2);
            didWarnAboutBadClass[_componentName2] = true;
          }
        }
      }

      var componentIdentity = {};
      prepareToUseHooks(componentIdentity);
      inst = Component(element.props, publicContext, updater);
      inst = finishHooks(Component, element.props, inst, publicContext);

      if (inst == null || inst.render == null) {
        child = inst;
        validateRenderResult(child, Component);
        return;
      }

      {
        var _componentName3 = getComponentName(Component) || 'Unknown';

        if (!didWarnAboutModulePatternComponent[_componentName3]) {
          warningWithoutStack$1(false, 'The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName3, _componentName3, _componentName3);
          didWarnAboutModulePatternComponent[_componentName3] = true;
        }
      }
    }

    inst.props = element.props;
    inst.context = publicContext;
    inst.updater = updater;
    var initialState = inst.state;

    if (initialState === undefined) {
      inst.state = initialState = null;
    }

    if (typeof inst.UNSAFE_componentWillMount === 'function' || typeof inst.componentWillMount === 'function') {
      if (typeof inst.componentWillMount === 'function') {
        {
          if (warnAboutDeprecatedLifecycles && inst.componentWillMount.__suppressDeprecationWarning !== true) {
            var _componentName4 = getComponentName(Component) || 'Unknown';

            if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
              lowPriorityWarningWithoutStack$1(false, // keep this warning in sync with ReactStrictModeWarning.js
              'componentWillMount has been renamed, and is not recommended for use. ' + 'See https://fb.me/react-unsafe-component-lifecycles for details.\n\n' + '* Move code from componentWillMount to componentDidMount (preferred in most cases) ' + 'or the constructor.\n' + '\nPlease update the following components: %s', _componentName4);
              didWarnAboutDeprecatedWillMount[_componentName4] = true;
            }
          }
        } // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for any component with the new gDSFP.


        if (typeof Component.getDerivedStateFromProps !== 'function') {
          inst.componentWillMount();
        }
      }

      if (typeof inst.UNSAFE_componentWillMount === 'function' && typeof Component.getDerivedStateFromProps !== 'function') {
        // In order to support react-lifecycles-compat polyfilled components,
        // Unsafe lifecycles should not be invoked for any component with the new gDSFP.
        inst.UNSAFE_componentWillMount();
      }

      if (queue.length) {
        var oldQueue = queue;
        var oldReplace = replace;
        queue = null;
        replace = false;

        if (oldReplace && oldQueue.length === 1) {
          inst.state = oldQueue[0];
        } else {
          var nextState = oldReplace ? oldQueue[0] : inst.state;
          var dontMutate = true;

          for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
            var partial = oldQueue[i];

            var _partialState = typeof partial === 'function' ? partial.call(inst, nextState, element.props, publicContext) : partial;

            if (_partialState != null) {
              if (dontMutate) {
                dontMutate = false;
                nextState = _assign({}, nextState, _partialState);
              } else {
                _assign(nextState, _partialState);
              }
            }
          }

          inst.state = nextState;
        }
      } else {
        queue = null;
      }
    }

    child = inst.render();

    {
      if (child === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        child = null;
      }
    }

    validateRenderResult(child, Component);
    var childContext;

    if (disableLegacyContext) {
      {
        var childContextTypes = Component.childContextTypes;

        if (childContextTypes !== undefined) {
          warningWithoutStack$1(false, '%s uses the legacy childContextTypes API which is no longer supported. ' + 'Use React.createContext() instead.', getComponentName(Component) || 'Unknown');
        }
      }
    } else {
      if (typeof inst.getChildContext === 'function') {
        var _childContextTypes = Component.childContextTypes;

        if (typeof _childContextTypes === 'object') {
          childContext = inst.getChildContext();

          for (var contextKey in childContext) {
            if (!(contextKey in _childContextTypes)) {
              {
                throw Error((getComponentName(Component) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes.");
              }
            }
          }
        } else {
          warningWithoutStack$1(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(Component) || 'Unknown');
        }
      }

      if (childContext) {
        context = _assign({}, context, childContext);
      }
    }
  }

  return {
    child: child,
    context: context
  };
}

var ReactDOMServerRenderer =
/*#__PURE__*/
function () {
  // TODO: type this more strictly:
  // DEV-only
  function ReactDOMServerRenderer(children, makeStaticMarkup) {
    var flatChildren = flattenTopLevelChildren(children);
    var topFrame = {
      type: null,
      // Assume all trees start in the HTML namespace (not totally true, but
      // this is what we did historically)
      domNamespace: Namespaces.html,
      children: flatChildren,
      childIndex: 0,
      context: emptyObject,
      footer: ''
    };

    {
      topFrame.debugElementStack = [];
    }

    this.threadID = allocThreadID();
    this.stack = [topFrame];
    this.exhausted = false;
    this.currentSelectValue = null;
    this.previousWasTextNode = false;
    this.makeStaticMarkup = makeStaticMarkup;
    this.suspenseDepth = 0; // Context (new API)

    this.contextIndex = -1;
    this.contextStack = [];
    this.contextValueStack = [];

    {
      this.contextProviderStack = [];
    }
  }

  var _proto = ReactDOMServerRenderer.prototype;

  _proto.destroy = function destroy() {
    if (!this.exhausted) {
      this.exhausted = true;
      this.clearProviders();
      freeThreadID(this.threadID);
    }
  }
  /**
   * Note: We use just two stacks regardless of how many context providers you have.
   * Providers are always popped in the reverse order to how they were pushed
   * so we always know on the way down which provider you'll encounter next on the way up.
   * On the way down, we push the current provider, and its context value *before*
   * we mutated it, onto the stacks. Therefore, on the way up, we always know which
   * provider needs to be "restored" to which value.
   * https://github.com/facebook/react/pull/12985#issuecomment-396301248
   */
  ;

  _proto.pushProvider = function pushProvider(provider) {
    var index = ++this.contextIndex;
    var context = provider.type._context;
    var threadID = this.threadID;
    validateContextBounds(context, threadID);
    var previousValue = context[threadID]; // Remember which value to restore this context to on our way up.

    this.contextStack[index] = context;
    this.contextValueStack[index] = previousValue;

    {
      // Only used for push/pop mismatch warnings.
      this.contextProviderStack[index] = provider;
    } // Mutate the current value.


    context[threadID] = provider.props.value;
  };

  _proto.popProvider = function popProvider(provider) {
    var index = this.contextIndex;

    {
      !(index > -1 && provider === this.contextProviderStack[index]) ? warningWithoutStack$1(false, 'Unexpected pop.') : void 0;
    }

    var context = this.contextStack[index];
    var previousValue = this.contextValueStack[index]; // "Hide" these null assignments from Flow by using `any`
    // because conceptually they are deletions--as long as we
    // promise to never access values beyond `this.contextIndex`.

    this.contextStack[index] = null;
    this.contextValueStack[index] = null;

    {
      this.contextProviderStack[index] = null;
    }

    this.contextIndex--; // Restore to the previous value we stored as we were walking down.
    // We've already verified that this context has been expanded to accommodate
    // this thread id, so we don't need to do it again.

    context[this.threadID] = previousValue;
  };

  _proto.clearProviders = function clearProviders() {
    // Restore any remaining providers on the stack to previous values
    for (var index = this.contextIndex; index >= 0; index--) {
      var context = this.contextStack[index];
      var previousValue = this.contextValueStack[index];
      context[this.threadID] = previousValue;
    }
  };

  _proto.read = function read(bytes) {
    if (this.exhausted) {
      return null;
    }

    var prevThreadID = currentThreadID;
    setCurrentThreadID(this.threadID);
    var prevDispatcher = ReactCurrentDispatcher.current;
    ReactCurrentDispatcher.current = Dispatcher;

    try {
      // Markup generated within <Suspense> ends up buffered until we know
      // nothing in that boundary suspended
      var out = [''];
      var suspended = false;

      while (out[0].length < bytes) {
        if (this.stack.length === 0) {
          this.exhausted = true;
          freeThreadID(this.threadID);
          break;
        }

        var frame = this.stack[this.stack.length - 1];

        if (suspended || frame.childIndex >= frame.children.length) {
          var footer = frame.footer;

          if (footer !== '') {
            this.previousWasTextNode = false;
          }

          this.stack.pop();

          if (frame.type === 'select') {
            this.currentSelectValue = null;
          } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
            var provider = frame.type;
            this.popProvider(provider);
          } else if (frame.type === REACT_SUSPENSE_TYPE) {
            this.suspenseDepth--;
            var buffered = out.pop();

            if (suspended) {
              suspended = false; // If rendering was suspended at this boundary, render the fallbackFrame

              var fallbackFrame = frame.fallbackFrame;

              if (!fallbackFrame) {
                {
                  throw Error("ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue.");
                }
              }

              this.stack.push(fallbackFrame);
              out[this.suspenseDepth] += '<!--$!-->'; // Skip flushing output since we're switching to the fallback

              continue;
            } else {
              out[this.suspenseDepth] += buffered;
            }
          } // Flush output


          out[this.suspenseDepth] += footer;
          continue;
        }

        var child = frame.children[frame.childIndex++];
        var outBuffer = '';

        {
          pushCurrentDebugStack(this.stack); // We're starting work on this frame, so reset its inner stack.

          frame.debugElementStack.length = 0;
        }

        try {
          outBuffer += this.render(child, frame.context, frame.domNamespace);
        } catch (err) {
          if (err != null && typeof err.then === 'function') {
            if (enableSuspenseServerRenderer) {
              if (!(this.suspenseDepth > 0)) {
                {
                  throw Error("A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
                }
              }

              suspended = true;
            } else {
              {
                {
                  throw Error("ReactDOMServer does not yet support Suspense.");
                }
              }
            }
          } else {
            throw err;
          }
        } finally {
          {
            popCurrentDebugStack();
          }
        }

        if (out.length <= this.suspenseDepth) {
          out.push('');
        }

        out[this.suspenseDepth] += outBuffer;
      }

      return out[0];
    } finally {
      ReactCurrentDispatcher.current = prevDispatcher;
      setCurrentThreadID(prevThreadID);
    }
  };

  _proto.render = function render(child, context, parentNamespace) {
    if (typeof child === 'string' || typeof child === 'number') {
      var text = '' + child;

      if (text === '') {
        return '';
      }

      if (this.makeStaticMarkup) {
        return escapeTextForBrowser(text);
      }

      if (this.previousWasTextNode) {
        return '<!-- -->' + escapeTextForBrowser(text);
      }

      this.previousWasTextNode = true;
      return escapeTextForBrowser(text);
    } else {
      var nextChild;

      var _resolve = resolve(child, context, this.threadID);

      nextChild = _resolve.child;
      context = _resolve.context;

      if (nextChild === null || nextChild === false) {
        return '';
      } else if (!React.isValidElement(nextChild)) {
        if (nextChild != null && nextChild.$$typeof != null) {
          // Catch unexpected special types early.
          var $$typeof = nextChild.$$typeof;

          if (!($$typeof !== REACT_PORTAL_TYPE)) {
            {
              throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
            }
          } // Catch-all to prevent an infinite loop if React.Children.toArray() supports some new type.


          {
            {
              throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
            }
          }
        }

        var nextChildren = toArray(nextChild);
        var frame = {
          type: null,
          domNamespace: parentNamespace,
          children: nextChildren,
          childIndex: 0,
          context: context,
          footer: ''
        };

        {
          frame.debugElementStack = [];
        }

        this.stack.push(frame);
        return '';
      } // Safe because we just checked it's an element.


      var nextElement = nextChild;
      var elementType = nextElement.type;

      if (typeof elementType === 'string') {
        return this.renderDOM(nextElement, context, parentNamespace);
      }

      switch (elementType) {
        case REACT_STRICT_MODE_TYPE:
        case REACT_CONCURRENT_MODE_TYPE:
        case REACT_PROFILER_TYPE:
        case REACT_SUSPENSE_LIST_TYPE:
        case REACT_FRAGMENT_TYPE:
          {
            var _nextChildren = toArray(nextChild.props.children);

            var _frame = {
              type: null,
              domNamespace: parentNamespace,
              children: _nextChildren,
              childIndex: 0,
              context: context,
              footer: ''
            };

            {
              _frame.debugElementStack = [];
            }

            this.stack.push(_frame);
            return '';
          }

        case REACT_SUSPENSE_TYPE:
          {
            if (enableSuspenseServerRenderer) {
              var fallback = nextChild.props.fallback;

              if (fallback === undefined) {
                // If there is no fallback, then this just behaves as a fragment.
                var _nextChildren3 = toArray(nextChild.props.children);

                var _frame3 = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: _nextChildren3,
                  childIndex: 0,
                  context: context,
                  footer: ''
                };

                {
                  _frame3.debugElementStack = [];
                }

                this.stack.push(_frame3);
                return '';
              }

              var fallbackChildren = toArray(fallback);

              var _nextChildren2 = toArray(nextChild.props.children);

              var fallbackFrame = {
                type: null,
                domNamespace: parentNamespace,
                children: fallbackChildren,
                childIndex: 0,
                context: context,
                footer: '<!--/$-->'
              };
              var _frame2 = {
                fallbackFrame: fallbackFrame,
                type: REACT_SUSPENSE_TYPE,
                domNamespace: parentNamespace,
                children: _nextChildren2,
                childIndex: 0,
                context: context,
                footer: '<!--/$-->'
              };

              {
                _frame2.debugElementStack = [];
                fallbackFrame.debugElementStack = [];
              }

              this.stack.push(_frame2);
              this.suspenseDepth++;
              return '<!--$-->';
            } else {
              {
                {
                  throw Error("ReactDOMServer does not yet support Suspense.");
                }
              }
            }
          }
        // eslint-disable-next-line-no-fallthrough

        default:
          break;
      }

      if (typeof elementType === 'object' && elementType !== null) {
        switch (elementType.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            {
              var element = nextChild;

              var _nextChildren4;

              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              _nextChildren4 = elementType.render(element.props, element.ref);
              _nextChildren4 = finishHooks(elementType.render, element.props, _nextChildren4, element.ref);
              _nextChildren4 = toArray(_nextChildren4);
              var _frame4 = {
                type: null,
                domNamespace: parentNamespace,
                children: _nextChildren4,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame4.debugElementStack = [];
              }

              this.stack.push(_frame4);
              return '';
            }

          case REACT_MEMO_TYPE:
            {
              var _element = nextChild;
              var _nextChildren5 = [React.createElement(elementType.type, _assign({
                ref: _element.ref
              }, _element.props))];
              var _frame5 = {
                type: null,
                domNamespace: parentNamespace,
                children: _nextChildren5,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame5.debugElementStack = [];
              }

              this.stack.push(_frame5);
              return '';
            }

          case REACT_PROVIDER_TYPE:
            {
              var provider = nextChild;
              var nextProps = provider.props;

              var _nextChildren6 = toArray(nextProps.children);

              var _frame6 = {
                type: provider,
                domNamespace: parentNamespace,
                children: _nextChildren6,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame6.debugElementStack = [];
              }

              this.pushProvider(provider);
              this.stack.push(_frame6);
              return '';
            }

          case REACT_CONTEXT_TYPE:
            {
              var reactContext = nextChild.type; // The logic below for Context differs depending on PROD or DEV mode. In
              // DEV mode, we create a separate object for Context.Consumer that acts
              // like a proxy to Context. This proxy object adds unnecessary code in PROD
              // so we use the old behaviour (Context.Consumer references Context) to
              // reduce size and overhead. The separate object references context via
              // a property called "_context", which also gives us the ability to check
              // in DEV mode if this property exists or not and warn if it does not.

              {
                if (reactContext._context === undefined) {
                  // This may be because it's a Context (rather than a Consumer).
                  // Or it may be because it's older React where they're the same thing.
                  // We only want to warn if we're sure it's a new React.
                  if (reactContext !== reactContext.Consumer) {
                    if (!hasWarnedAboutUsingContextAsConsumer) {
                      hasWarnedAboutUsingContextAsConsumer = true;
                      warning$1(false, 'Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
                    }
                  }
                } else {
                  reactContext = reactContext._context;
                }
              }

              var _nextProps = nextChild.props;
              var threadID = this.threadID;
              validateContextBounds(reactContext, threadID);
              var nextValue = reactContext[threadID];

              var _nextChildren7 = toArray(_nextProps.children(nextValue));

              var _frame7 = {
                type: nextChild,
                domNamespace: parentNamespace,
                children: _nextChildren7,
                childIndex: 0,
                context: context,
                footer: ''
              };

              {
                _frame7.debugElementStack = [];
              }

              this.stack.push(_frame7);
              return '';
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_FUNDAMENTAL_TYPE:
            {
              if (enableFundamentalAPI) {
                var fundamentalImpl = elementType.impl;
                var open = fundamentalImpl.getServerSideString(null, nextElement.props);
                var getServerSideStringClose = fundamentalImpl.getServerSideStringClose;
                var close = getServerSideStringClose !== undefined ? getServerSideStringClose(null, nextElement.props) : '';

                var _nextChildren8 = fundamentalImpl.reconcileChildren !== false ? toArray(nextChild.props.children) : [];

                var _frame8 = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: _nextChildren8,
                  childIndex: 0,
                  context: context,
                  footer: close
                };

                {
                  _frame8.debugElementStack = [];
                }

                this.stack.push(_frame8);
                return open;
              }

              {
                {
                  throw Error("ReactDOMServer does not yet support the fundamental API.");
                }
              }
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_LAZY_TYPE:
            {
              var _element2 = nextChild;
              var lazyComponent = nextChild.type; // Attempt to initialize lazy component regardless of whether the
              // suspense server-side renderer is enabled so synchronously
              // resolved constructors are supported.

              initializeLazyComponentType(lazyComponent);

              switch (lazyComponent._status) {
                case Resolved:
                  {
                    var _nextChildren9 = [React.createElement(lazyComponent._result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame9 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren9,
                      childIndex: 0,
                      context: context,
                      footer: ''
                    };

                    {
                      _frame9.debugElementStack = [];
                    }

                    this.stack.push(_frame9);
                    return '';
                  }

                case Rejected:
                  throw lazyComponent._result;

                case Pending:
                default:
                  {
                    {
                      throw Error("ReactDOMServer does not yet support lazy-loaded components.");
                    }
                  }

              }
            }
          // eslint-disable-next-line-no-fallthrough

          case REACT_SCOPE_TYPE:
            {
              if (enableScopeAPI) {
                var _nextChildren10 = toArray(nextChild.props.children);

                var _frame10 = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: _nextChildren10,
                  childIndex: 0,
                  context: context,
                  footer: ''
                };

                {
                  _frame10.debugElementStack = [];
                }

                this.stack.push(_frame10);
                return '';
              }

              {
                {
                  throw Error("ReactDOMServer does not yet support scope components.");
                }
              }
            }
        }
      }

      var info = '';

      {
        var owner = nextElement._owner;

        if (elementType === undefined || typeof elementType === 'object' && elementType !== null && Object.keys(elementType).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
        }

        var ownerName = owner ? getComponentName(owner) : null;

        if (ownerName) {
          info += '\n\nCheck the render method of `' + ownerName + '`.';
        }
      }

      {
        {
          throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
        }
      }
    }
  };

  _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
    var tag = element.type.toLowerCase();
    var namespace = parentNamespace;

    if (parentNamespace === Namespaces.html) {
      namespace = getIntrinsicNamespace(tag);
    }

    {
      if (namespace === Namespaces.html) {
        // Should this check be gated by parent namespace? Not sure we want to
        // allow <SVG> or <mATH>.
        !(tag === element.type) ? warning$1(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', element.type) : void 0;
      }
    }

    validateDangerousTag(tag);
    var props = element.props;

    if (tag === 'input') {
      {
        ReactControlledValuePropTypes.checkPropTypes('input', props);

        if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnDefaultChecked) {
          warning$1(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', 'A component', props.type);
          didWarnDefaultChecked = true;
        }

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultInputValue) {
          warning$1(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', 'A component', props.type);
          didWarnDefaultInputValue = true;
        }
      }

      props = _assign({
        type: undefined
      }, props, {
        defaultChecked: undefined,
        defaultValue: undefined,
        value: props.value != null ? props.value : props.defaultValue,
        checked: props.checked != null ? props.checked : props.defaultChecked
      });
    } else if (tag === 'textarea') {
      {
        ReactControlledValuePropTypes.checkPropTypes('textarea', props);

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultTextareaValue) {
          warning$1(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
          didWarnDefaultTextareaValue = true;
        }
      }

      var initialValue = props.value;

      if (initialValue == null) {
        var defaultValue = props.defaultValue; // TODO (yungsters): Remove support for children content in <textarea>.

        var textareaChildren = props.children;

        if (textareaChildren != null) {
          {
            warning$1(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
          }

          if (!(defaultValue == null)) {
            {
              throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            }
          }

          if (Array.isArray(textareaChildren)) {
            if (!(textareaChildren.length <= 1)) {
              {
                throw Error("<textarea> can only have at most one child.");
              }
            }

            textareaChildren = textareaChildren[0];
          }

          defaultValue = '' + textareaChildren;
        }

        if (defaultValue == null) {
          defaultValue = '';
        }

        initialValue = defaultValue;
      }

      props = _assign({}, props, {
        value: undefined,
        children: '' + initialValue
      });
    } else if (tag === 'select') {
      {
        ReactControlledValuePropTypes.checkPropTypes('select', props);

        for (var i = 0; i < valuePropNames.length; i++) {
          var propName = valuePropNames[i];

          if (props[propName] == null) {
            continue;
          }

          var isArray = Array.isArray(props[propName]);

          if (props.multiple && !isArray) {
            warning$1(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.', propName);
          } else if (!props.multiple && isArray) {
            warning$1(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.', propName);
          }
        }

        if (props.value !== undefined && props.defaultValue !== undefined && !didWarnDefaultSelectValue) {
          warning$1(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
          didWarnDefaultSelectValue = true;
        }
      }

      this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
      props = _assign({}, props, {
        value: undefined
      });
    } else if (tag === 'option') {
      var selected = null;
      var selectValue = this.currentSelectValue;
      var optionChildren = flattenOptionChildren(props.children);

      if (selectValue != null) {
        var value;

        if (props.value != null) {
          value = props.value + '';
        } else {
          value = optionChildren;
        }

        selected = false;

        if (Array.isArray(selectValue)) {
          // multiple
          for (var j = 0; j < selectValue.length; j++) {
            if ('' + selectValue[j] === value) {
              selected = true;
              break;
            }
          }
        } else {
          selected = '' + selectValue === value;
        }

        props = _assign({
          selected: undefined,
          children: undefined
        }, props, {
          selected: selected,
          children: optionChildren
        });
      }
    }

    {
      validatePropertiesInDevelopment(tag, props);
    }

    assertValidProps(tag, props);
    var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
    var footer = '';

    if (omittedCloseTags.hasOwnProperty(tag)) {
      out += '/>';
    } else {
      out += '>';
      footer = '</' + element.type + '>';
    }

    var children;
    var innerMarkup = getNonChildrenInnerMarkup(props);

    if (innerMarkup != null) {
      children = [];

      if (newlineEatingTags[tag] && innerMarkup.charAt(0) === '\n') {
        // text/html ignores the first character in these tags if it's a newline
        // Prefer to break application/xml over text/html (for now) by adding
        // a newline specifically to get eaten by the parser. (Alternately for
        // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
        // \r is normalized out by HTMLTextAreaElement#value.)
        // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
        // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
        // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
        // See: Parsing of "textarea" "listing" and "pre" elements
        //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
        out += '\n';
      }

      out += innerMarkup;
    } else {
      children = toArray(props.children);
    }

    var frame = {
      domNamespace: getChildNamespace(parentNamespace, element.type),
      type: tag,
      children: children,
      childIndex: 0,
      context: context,
      footer: footer
    };

    {
      frame.debugElementStack = [];
    }

    this.stack.push(frame);
    this.previousWasTextNode = false;
    return out;
  };

  return ReactDOMServerRenderer;
}();

/**
 * Render a ReactElement to its initial HTML. This should only be used on the
 * server.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostring
 */

function renderToString(element) {
  var renderer = new ReactDOMServerRenderer(element, false);

  try {
    var markup = renderer.read(Infinity);
    return markup;
  } finally {
    renderer.destroy();
  }
}
/**
 * Similar to renderToString, except this doesn't create extra DOM attributes
 * such as data-react-id that React uses internally.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostaticmarkup
 */

function renderToStaticMarkup(element) {
  var renderer = new ReactDOMServerRenderer(element, true);

  try {
    var markup = renderer.read(Infinity);
    return markup;
  } finally {
    renderer.destroy();
  }
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var ReactMarkupReadableStream =
/*#__PURE__*/
function (_Readable) {
  _inheritsLoose(ReactMarkupReadableStream, _Readable);

  function ReactMarkupReadableStream(element, makeStaticMarkup) {
    var _this;

    // Calls the stream.Readable(options) constructor. Consider exposing built-in
    // features like highWaterMark in the future.
    _this = _Readable.call(this, {}) || this;
    _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup);
    return _this;
  }

  var _proto = ReactMarkupReadableStream.prototype;

  _proto._destroy = function _destroy(err, callback) {
    this.partialRenderer.destroy();
    callback(err);
  };

  _proto._read = function _read(size) {
    try {
      this.push(this.partialRenderer.read(size));
    } catch (err) {
      this.destroy(err);
    }
  };

  return ReactMarkupReadableStream;
}(stream.Readable);
/**
 * Render a ReactElement to its initial HTML. This should only be used on the
 * server.
 * See https://reactjs.org/docs/react-dom-server.html#rendertonodestream
 */


function renderToNodeStream(element) {
  return new ReactMarkupReadableStream(element, false);
}
/**
 * Similar to renderToNodeStream, except this doesn't create extra DOM attributes
 * such as data-react-id that React uses internally.
 * See https://reactjs.org/docs/react-dom-server.html#rendertostaticnodestream
 */

function renderToStaticNodeStream(element) {
  return new ReactMarkupReadableStream(element, true);
}

var ReactDOMServerNode = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup,
  renderToNodeStream: renderToNodeStream,
  renderToStaticNodeStream: renderToStaticNodeStream,
  version: ReactVersion
};

var ReactDOMServerNode$1 = Object.freeze({
	default: ReactDOMServerNode
});

var ReactDOMServer = ( ReactDOMServerNode$1 && ReactDOMServerNode ) || ReactDOMServerNode$1;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest


var server_node = ReactDOMServer.default || ReactDOMServer;

module.exports = server_node;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/server.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/server.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./server.node */ "./node_modules/react-dom/server.node.js");


/***/ }),

/***/ "./node_modules/react-dom/server.node.js":
/*!***********************************************!*\
  !*** ./node_modules/react-dom/server.node.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom-server.node.development.js */ "./node_modules/react-dom/cjs/react-dom-server.node.development.js");
}


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.11.0
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var lowPriorityWarningWithoutStack = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.warn(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarningWithoutStack = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  };
}

var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarningWithoutStack$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-router-dom/esm/react-router-dom.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-router-dom/esm/react-router-dom.js ***!
  \***************************************************************/
/*! exports provided: BrowserRouter, HashRouter, Link, NavLink, MemoryRouter, Prompt, Redirect, Route, Router, StaticRouter, Switch, __RouterContext, generatePath, matchPath, useHistory, useLocation, useParams, useRouteMatch, withRouter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserRouter", function() { return BrowserRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashRouter", function() { return HashRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return Link; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NavLink", function() { return NavLink; });
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router */ "./node_modules/react-router/esm/react-router.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["MemoryRouter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Prompt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Redirect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Route"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Router"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["StaticRouter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["Switch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__RouterContext", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["__RouterContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "generatePath", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["generatePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["matchPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useHistory", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useHistory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useLocation", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useLocation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useParams", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useParams"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRouteMatch", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["useRouteMatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return react_router__WEBPACK_IMPORTED_MODULE_0__["withRouter"]; });

/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history */ "./node_modules/history/esm/history.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tiny-invariant */ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");











/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = Object(history__WEBPACK_IMPORTED_MODULE_3__["createBrowserHistory"])(_this.props);
    return _this;
  }

  var _proto = BrowserRouter.prototype;

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["Router"], {
      history: this.history,
      children: this.props.children
    });
  };

  return BrowserRouter;
}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);

if (true) {
  BrowserRouter.propTypes = {
    basename: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node,
    forceRefresh: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    keyLength: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number
  };

  BrowserRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_5__["default"])(!this.props.history, "<BrowserRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`.") : undefined;
  };
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(HashRouter, _React$Component);

  function HashRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = Object(history__WEBPACK_IMPORTED_MODULE_3__["createHashHistory"])(_this.props);
    return _this;
  }

  var _proto = HashRouter.prototype;

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["Router"], {
      history: this.history,
      children: this.props.children
    });
  };

  return HashRouter;
}(react__WEBPACK_IMPORTED_MODULE_2___default.a.Component);

if (true) {
  HashRouter.propTypes = {
    basename: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node,
    getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    hashType: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(["hashbang", "noslash", "slash"])
  };

  HashRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_5__["default"])(!this.props.history, "<HashRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { HashRouter as Router }`.") : undefined;
  };
}

var resolveToLocation = function resolveToLocation(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation(to, currentLocation) {
  return typeof to === "string" ? Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(to, null, null, currentLocation) : to;
};

var forwardRefShim = function forwardRefShim(C) {
  return C;
};

var forwardRef = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef;

if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

var LinkAnchor = forwardRef(function (_ref, forwardedRef) {
  var innerRef = _ref.innerRef,
      navigate = _ref.navigate,
      _onClick = _ref.onClick,
      rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__["default"])(_ref, ["innerRef", "navigate", "onClick"]);

  var target = rest.target;

  var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick) _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && ( // ignore everything but left clicks
      !target || target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();
          navigate();
        }
    }
  }); // React 15 compat


  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }

  return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("a", props);
});

if (true) {
  LinkAnchor.displayName = "LinkAnchor";
}
/**
 * The public API for rendering a history-aware <a>.
 */


var Link = forwardRef(function (_ref2, forwardedRef) {
  var _ref2$component = _ref2.component,
      component = _ref2$component === void 0 ? LinkAnchor : _ref2$component,
      replace = _ref2.replace,
      to = _ref2.to,
      innerRef = _ref2.innerRef,
      rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__["default"])(_ref2, ["component", "replace", "to", "innerRef"]);

  return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["__RouterContext"].Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_8__["default"])(false, "You should not use <Link> outside a <Router>") : undefined : void 0;
    var history = context.history;
    var location = normalizeToLocation(resolveToLocation(to, context.location), context.location);
    var href = location ? history.createHref(location) : "";

    var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, rest, {
      href: href,
      navigate: function navigate() {
        var location = resolveToLocation(to, context.location);
        var method = replace ? history.replace : history.push;
        method(location);
      }
    }); // React 15 compat


    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(component, props);
  });
});

if (true) {
  var toType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func]);
  var refType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.shape({
    current: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.any
  })]);
  Link.displayName = "Link";
  Link.propTypes = {
    innerRef: refType,
    onClick: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    replace: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    target: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    to: toType.isRequired
  };
}

var forwardRefShim$1 = function forwardRefShim(C) {
  return C;
};

var forwardRef$1 = react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef;

if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}

function joinClassnames() {
  for (var _len = arguments.length, classnames = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames[_key] = arguments[_key];
  }

  return classnames.filter(function (i) {
    return i;
  }).join(" ");
}
/**
 * A <Link> wrapper that knows if it's "active" or not.
 */


var NavLink = forwardRef$1(function (_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"],
      ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent,
      _ref$activeClassName = _ref.activeClassName,
      activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName,
      activeStyle = _ref.activeStyle,
      classNameProp = _ref.className,
      exact = _ref.exact,
      isActiveProp = _ref.isActive,
      locationProp = _ref.location,
      strict = _ref.strict,
      styleProp = _ref.style,
      to = _ref.to,
      innerRef = _ref.innerRef,
      rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_7__["default"])(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "strict", "style", "to", "innerRef"]);

  return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react_router__WEBPACK_IMPORTED_MODULE_0__["__RouterContext"].Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_8__["default"])(false, "You should not use <NavLink> outside a <Router>") : undefined : void 0;
    var currentLocation = locationProp || context.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname; // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202

    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match = escapedPath ? Object(react_router__WEBPACK_IMPORTED_MODULE_0__["matchPath"])(currentLocation.pathname, {
      path: escapedPath,
      exact: exact,
      strict: strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match, currentLocation) : match);
    var className = isActive ? joinClassnames(classNameProp, activeClassName) : classNameProp;
    var style = isActive ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, styleProp, {}, activeStyle) : styleProp;

    var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({
      "aria-current": isActive && ariaCurrent || null,
      className: className,
      style: style,
      to: toLocation
    }, rest); // React 15 compat


    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }

    return react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Link, props);
  });
});

if (true) {
  NavLink.displayName = "NavLink";
  var ariaCurrentType = prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOf(["page", "step", "location", "date", "time", "true"]);
  NavLink.propTypes = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_6__["default"])({}, Link.propTypes, {
    "aria-current": ariaCurrentType,
    activeClassName: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    activeStyle: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
    className: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
    exact: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    isActive: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
    location: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
    strict: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,
    style: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object
  });
}


//# sourceMappingURL=react-router-dom.js.map


/***/ }),

/***/ "./node_modules/react-router/esm/react-router.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-router/esm/react-router.js ***!
  \*******************************************************/
/*! exports provided: MemoryRouter, Prompt, Redirect, Route, Router, StaticRouter, Switch, __RouterContext, generatePath, matchPath, useHistory, useLocation, useParams, useRouteMatch, withRouter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return MemoryRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return Prompt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return Redirect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return Route; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return Router; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return StaticRouter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return Switch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__RouterContext", function() { return context; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generatePath", function() { return generatePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return matchPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useHistory", function() { return useHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useLocation", function() { return useLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useParams", function() { return useParams; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRouteMatch", function() { return useRouteMatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return withRouter; });
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! history */ "./node_modules/history/esm/history.js");
/* harmony import */ var tiny_warning__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tiny-warning */ "./node_modules/tiny-warning/dist/tiny-warning.esm.js");
/* harmony import */ var mini_create_react_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mini-create-react-context */ "./node_modules/mini-create-react-context/dist/esm/index.js");
/* harmony import */ var tiny_invariant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! tiny-invariant */ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! path-to-regexp */ "./node_modules/path-to-regexp/index.js");
/* harmony import */ var path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(path_to_regexp__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! hoist-non-react-statics */ "./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11__);













// TODO: Replace with React.createContext once we can assume React 16+

var createNamedContext = function createNamedContext(name) {
  var context = Object(mini_create_react_context__WEBPACK_IMPORTED_MODULE_5__["default"])();
  context.displayName = name;
  return context;
};

var context =
/*#__PURE__*/
createNamedContext("Router");

/**
 * The public API for putting history on context.
 */

var Router =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Router, _React$Component);

  Router.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };

  function Router(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    }; // This is a bit of a hack. We have to start listening for location
    // changes here in the constructor in case there are any <Redirect>s
    // on the initial render. If there are, they will replace/push when
    // they mount and since cDM fires in children before parents, we may
    // get a new location before the <Router> is mounted.

    _this._isMounted = false;
    _this._pendingLocation = null;

    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function (location) {
        if (_this._isMounted) {
          _this.setState({
            location: location
          });
        } else {
          _this._pendingLocation = location;
        }
      });
    }

    return _this;
  }

  var _proto = Router.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;

    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) this.unlisten();
  };

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Provider, {
      children: this.props.children || null,
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    });
  };

  return Router;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  Router.propTypes = {
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
    history: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object.isRequired,
    staticContext: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object
  };

  Router.prototype.componentDidUpdate = function (prevProps) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(prevProps.history === this.props.history, "You cannot change <Router history>") : undefined;
  };
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = Object(history__WEBPACK_IMPORTED_MODULE_3__["createMemoryHistory"])(_this.props);
    return _this;
  }

  var _proto = MemoryRouter.prototype;

  _proto.render = function render() {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };

  return MemoryRouter;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  MemoryRouter.propTypes = {
    initialEntries: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,
    initialIndex: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,
    getUserConfirmation: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
    keyLength: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node
  };

  MemoryRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!this.props.history, "<MemoryRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { MemoryRouter as Router }`.") : undefined;
  };
}

var Lifecycle =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Lifecycle, _React$Component);

  function Lifecycle() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

/**
 * The public API for prompting the user before navigating away from a screen.
 */

function Prompt(_ref) {
  var message = _ref.message,
      _ref$when = _ref.when,
      when = _ref$when === void 0 ? true : _ref$when;
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Prompt> outside a <Router>") : undefined : void 0;
    if (!when || context.staticContext) return null;
    var method = context.history.block;
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Lifecycle, {
      onMount: function onMount(self) {
        self.release = method(message);
      },
      onUpdate: function onUpdate(self, prevProps) {
        if (prevProps.message !== message) {
          self.release();
          self.release = method(message);
        }
      },
      onUnmount: function onUnmount(self) {
        self.release();
      },
      message: message
    });
  });
}

if (true) {
  var messageType = prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string]);
  Prompt.propTypes = {
    when: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    message: messageType.isRequired
  };
}

var cache = {};
var cacheLimit = 10000;
var cacheCount = 0;

function compilePath(path) {
  if (cache[path]) return cache[path];
  var generator = path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default.a.compile(path);

  if (cacheCount < cacheLimit) {
    cache[path] = generator;
    cacheCount++;
  }

  return generator;
}
/**
 * Public API for generating a URL pathname from a path and parameters.
 */


function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }

  if (params === void 0) {
    params = {};
  }

  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}

/**
 * The public API for navigating programmatically with a component.
 */

function Redirect(_ref) {
  var computedMatch = _ref.computedMatch,
      to = _ref.to,
      _ref$push = _ref.push,
      push = _ref$push === void 0 ? false : _ref$push;
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
    !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Redirect> outside a <Router>") : undefined : void 0;
    var history = context.history,
        staticContext = context.staticContext;
    var method = push ? history.push : history.replace;
    var location = Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to); // When rendering in a static context,
    // set the new location immediately.

    if (staticContext) {
      method(location);
      return null;
    }

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Lifecycle, {
      onMount: function onMount() {
        method(location);
      },
      onUpdate: function onUpdate(self, prevProps) {
        var prevLocation = Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(prevProps.to);

        if (!Object(history__WEBPACK_IMPORTED_MODULE_3__["locationsAreEqual"])(prevLocation, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, location, {
          key: prevLocation.key
        }))) {
          method(location);
        }
      },
      to: to
    });
  });
}

if (true) {
  Redirect.propTypes = {
    push: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    from: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
    to: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object]).isRequired
  };
}

var cache$1 = {};
var cacheLimit$1 = 10000;
var cacheCount$1 = 0;

function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path]) return pathCache[path];
  var keys = [];
  var regexp = path_to_regexp__WEBPACK_IMPORTED_MODULE_8___default()(path, keys, options);
  var result = {
    regexp: regexp,
    keys: keys
  };

  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }

  return result;
}
/**
 * Public API for matching a URL pathname to a path.
 */


function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }

  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }

  var _options = options,
      path = _options.path,
      _options$exact = _options.exact,
      exact = _options$exact === void 0 ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === void 0 ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function (matched, path) {
    if (!path && path !== "") return null;
    if (matched) return matched;

    var _compilePath = compilePath$1(path, {
      end: exact,
      strict: strict,
      sensitive: sensitive
    }),
        regexp = _compilePath.regexp,
        keys = _compilePath.keys;

    var match = regexp.exec(pathname);
    if (!match) return null;
    var url = match[0],
        values = match.slice(1);
    var isExact = pathname === url;
    if (exact && !isExact) return null;
    return {
      path: path,
      // the path used to match
      url: path === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact: isExact,
      // whether or not we matched exactly
      params: keys.reduce(function (memo, key, index) {
        memo[key.name] = values[index];
        return memo;
      }, {})
    };
  }, null);
}

function isEmptyChildren(children) {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.count(children) === 0;
}

function evalChildrenDev(children, props, path) {
  var value = children(props);
   true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(value !== undefined, "You returned `undefined` from the `children` function of " + ("<Route" + (path ? " path=\"" + path + "\"" : "") + ">, but you ") + "should have returned a React element or `null`") : undefined;
  return value || null;
}
/**
 * The public API for matching a single path and rendering.
 */


var Route =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Route, _React$Component);

  function Route() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Route.prototype;

  _proto.render = function render() {
    var _this = this;

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context$1) {
      !context$1 ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Route> outside a <Router>") : undefined : void 0;
      var location = _this.props.location || context$1.location;
      var match = _this.props.computedMatch ? _this.props.computedMatch // <Switch> already computed the match for us
      : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;

      var props = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, context$1, {
        location: location,
        match: match
      });

      var _this$props = _this.props,
          children = _this$props.children,
          component = _this$props.component,
          render = _this$props.render; // Preact uses an empty array as children by
      // default, so use null if that's the case.

      if (Array.isArray(children) && children.length === 0) {
        children = null;
      }

      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ?  true ? evalChildrenDev(children, props, _this.props.path) : undefined : children : component ? react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(component, props) : render ? render(props) : null : typeof children === "function" ?  true ? evalChildrenDev(children, props, _this.props.path) : undefined : null);
    });
  };

  return Route;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  Route.propTypes = {
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node]),
    component: function component(props, propName) {
      if (props[propName] && !Object(react_is__WEBPACK_IMPORTED_MODULE_9__["isValidElementType"])(props[propName])) {
        return new Error("Invalid prop 'component' supplied to 'Route': the prop is not a valid React component");
      }
    },
    exact: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
    path: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string)]),
    render: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
    sensitive: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,
    strict: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool
  };

  Route.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.component), "You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored") : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.children && !isEmptyChildren(this.props.children) && this.props.render), "You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored") : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.component && this.props.render), "You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored") : undefined;
  };

  Route.prototype.componentDidUpdate = function (prevProps) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.location && !prevProps.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(!this.props.location && prevProps.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : undefined;
  };
}

function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}

function addBasename(basename, location) {
  if (!basename) return location;
  return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}

function stripBasename(basename, location) {
  if (!basename) return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}

function createURL(location) {
  return typeof location === "string" ? location : Object(history__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
}

function staticHandler(methodName) {
  return function () {
      true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You cannot %s with <StaticRouter>", methodName) : undefined ;
  };
}

function noop() {}
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */


var StaticRouter =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(StaticRouter, _React$Component);

  function StaticRouter() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;

    _this.handlePush = function (location) {
      return _this.navigateTo(location, "PUSH");
    };

    _this.handleReplace = function (location) {
      return _this.navigateTo(location, "REPLACE");
    };

    _this.handleListen = function () {
      return noop;
    };

    _this.handleBlock = function () {
      return noop;
    };

    return _this;
  }

  var _proto = StaticRouter.prototype;

  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props,
        _this$props$basename = _this$props.basename,
        basename = _this$props$basename === void 0 ? "" : _this$props$basename,
        _this$props$context = _this$props.context,
        context = _this$props$context === void 0 ? {} : _this$props$context;
    context.action = action;
    context.location = addBasename(basename, Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(location));
    context.url = createURL(context.location);
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        _this$props2$basename = _this$props2.basename,
        basename = _this$props2$basename === void 0 ? "" : _this$props2$basename,
        _this$props2$context = _this$props2.context,
        context = _this$props2$context === void 0 ? {} : _this$props2$context,
        _this$props2$location = _this$props2.location,
        location = _this$props2$location === void 0 ? "/" : _this$props2$location,
        rest = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__["default"])(_this$props2, ["basename", "context", "location"]);

    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename, Object(history__WEBPACK_IMPORTED_MODULE_3__["createLocation"])(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler("go"),
      goBack: staticHandler("goBack"),
      goForward: staticHandler("goForward"),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Router, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, rest, {
      history: history,
      staticContext: context
    }));
  };

  return StaticRouter;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  StaticRouter.propTypes = {
    basename: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string,
    context: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object,
    location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object])
  };

  StaticRouter.prototype.componentDidMount = function () {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!this.props.history, "<StaticRouter> ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { StaticRouter as Router }`.") : undefined;
  };
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch =
/*#__PURE__*/
function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(Switch, _React$Component);

  function Switch() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = Switch.prototype;

  _proto.render = function render() {
    var _this = this;

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
      !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <Switch> outside a <Router>") : undefined : void 0;
      var location = _this.props.location || context.location;
      var element, match; // We use React.Children.forEach instead of React.Children.toArray().find()
      // here because toArray adds keys to all child elements and we do not want
      // to trigger an unmount/remount for two <Route>s that render the same
      // component at different URLs.

      react__WEBPACK_IMPORTED_MODULE_1___default.a.Children.forEach(_this.props.children, function (child) {
        if (match == null && react__WEBPACK_IMPORTED_MODULE_1___default.a.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match = path ? matchPath(location.pathname, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, child.props, {
            path: path
          })) : context.match;
        }
      });
      return match ? react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(element, {
        location: location,
        computedMatch: match
      }) : null;
    });
  };

  return Switch;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

if (true) {
  Switch.propTypes = {
    children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.node,
    location: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object
  };

  Switch.prototype.componentDidUpdate = function (prevProps) {
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(this.props.location && !prevProps.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.') : undefined;
     true ? Object(tiny_warning__WEBPACK_IMPORTED_MODULE_4__["default"])(!(!this.props.location && prevProps.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.') : undefined;
  };
}

/**
 * A public higher-order component to access the imperative API
 */

function withRouter(Component) {
  var displayName = "withRouter(" + (Component.displayName || Component.name) + ")";

  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_10__["default"])(props, ["wrappedComponentRef"]);

    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(context.Consumer, null, function (context) {
      !context ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You should not use <" + displayName + " /> outside a <Router>") : undefined : void 0;
      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_7__["default"])({}, remainingProps, context, {
        ref: wrappedComponentRef
      }));
    });
  };

  C.displayName = displayName;
  C.WrappedComponent = Component;

  if (true) {
    C.propTypes = {
      wrappedComponentRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.object])
    };
  }

  return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_11___default()(C, Component);
}

var useContext = react__WEBPACK_IMPORTED_MODULE_1___default.a.useContext;
function useHistory() {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useHistory()") : undefined : void 0;
  }

  return useContext(context).history;
}
function useLocation() {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useLocation()") : undefined : void 0;
  }

  return useContext(context).location;
}
function useParams() {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useParams()") : undefined : void 0;
  }

  var match = useContext(context).match;
  return match ? match.params : {};
}
function useRouteMatch(path) {
  if (true) {
    !(typeof useContext === "function") ?  true ? Object(tiny_invariant__WEBPACK_IMPORTED_MODULE_6__["default"])(false, "You must use React >= 16.8 in order to use useRouteMatch()") : undefined : void 0;
  }

  return path ? matchPath(useLocation().pathname, path) : useContext(context).match;
}

if (true) {
  if (typeof window !== "undefined") {
    var global = window;
    var key = "__react_router_build__";
    var buildNames = {
      cjs: "CommonJS",
      esm: "ES modules",
      umd: "UMD"
    };

    if (global[key] && global[key] !== "esm") {
      var initialBuildName = buildNames[global[key]];
      var secondaryBuildName = buildNames["esm"]; // TODO: Add link to article that explains in detail how to avoid
      // loading 2 different builds.

      throw new Error("You are loading the " + secondaryBuildName + " build of React Router " + ("on a page that is already running the " + initialBuildName + " ") + "build, so things won't work right.");
    }

    global[key] = "esm";
  }
}


//# sourceMappingURL=react-router.js.map


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.11.0
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.11.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?


var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

// Do not require this module directly! Use normal `invariant` calls with
// template literal strings. The messages will be replaced with error codes
// during build.

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var lowPriorityWarningWithoutStack = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.warn(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarningWithoutStack = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(void 0, [format].concat(args));
    }
  };
}

var lowPriorityWarningWithoutStack$1 = lowPriorityWarningWithoutStack;

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */
var warningWithoutStack = function () {};

{
  warningWithoutStack = function (condition, format) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (args.length > 8) {
      // Check before the condition to catch violations early.
      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
    }

    if (condition) {
      return;
    }

    if (typeof console !== 'undefined') {
      var argsWithFormat = args.map(function (item) {
        return '' + item;
      });
      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610

      Function.prototype.apply.call(console.error, console, argsWithFormat);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      throw new Error(message);
    } catch (x) {}
  };
}

var warningWithoutStack$1 = warningWithoutStack;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarningWithoutStack$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  suspense: null
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
var describeComponentFrame = function (name, source, ownerName) {
  var sourceInfo = '';

  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');

    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);

        if (match) {
          var pathBeforeSlash = match[1];

          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }

    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }

  return '\n    in ' + (name || 'Unknown') + sourceInfo;
};

var Resolved = 1;

function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return "Profiler";

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';

      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = refineResolvedLazyComponent(thenable);

          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }

          break;
        }
    }
  }

  return null;
}

var ReactDebugCurrentFrame = {};
var currentlyValidatingElement = null;
function setCurrentlyValidatingElement(element) {
  {
    currentlyValidatingElement = element;
  }
}

{
  // Stack implementation injected by the current renderer.
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentlyValidatingElement) {
      var name = getComponentName(currentlyValidatingElement.type);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  _assign(ReactSharedInternals, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = warningWithoutStack$1;

{
  warning = function (condition, format) {
    if (condition) {
      return;
    }

    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum(); // eslint-disable-next-line react-internal/warning-and-invariant-args

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    warningWithoutStack$1.apply(void 0, [false, format + '%s'].concat(args, [stack]));
  };
}

var warning$1 = warning;

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */



/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null; // Currently, key can be spread in as a prop. This causes a potential
  // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
  // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
  // but as an intermediary step, we will use jsxDEV for everything except
  // <div {...props} key="Hi" />, because we aren't currently able to tell if
  // key is explicitly declared to be undefined or not.

  if (maybeKey !== undefined) {
    key = '' + maybeKey;
  }

  if (hasValidKey(config)) {
    key = '' + config.key;
  }

  if (hasValidRef(config)) {
    ref = config.ref;
  } // Remaining properties are added to a new props object


  for (propName in config) {
    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
      props[propName] = config[propName];
    }
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  if (key || ref) {
    var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

    if (key) {
      defineKeyPropWarningGetter(props, displayName);
    }

    if (ref) {
      defineRefPropWarningGetter(props, displayName);
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];

function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;

  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}
/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */


function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';

      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }

      var childrenString = '' + children;

      {
        {
          throw Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + ")." + addendum);
        }
      }
    }
  }

  return subtreeCount;
}
/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */


function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}
/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;
  func.call(context, child, bookKeeping.count++);
}
/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */


function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;
  var mappedChild = func.call(context, child, bookKeeping.count++);

  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
      return c;
    });
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }

    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';

  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }

  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}
/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */


function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  return traverseAllChildren(children, function () {
    return null;
  }, null);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
    return child;
  });
  return result;
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error("React.Children.only expected to receive a single React element child.");
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;
            warning$1(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;
            warning$1(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

function lazy(ctor) {
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _ctor: ctor,
    // React uses these fields to store the result.
    _status: -1,
    _result: null
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes;
    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          warning$1(false, 'React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
          defaultProps = newDefaultProps; // Match production behavior more closely:

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          warning$1(false, 'React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
          propTypes = newPropTypes; // Match production behavior more closely:

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      warningWithoutStack$1(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      !( // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object
      render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;
    }

    if (render != null) {
      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
    }
  }

  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
}

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE);
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      warningWithoutStack$1(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    !(unstable_observedBits === undefined) ? warning$1(false, 'useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '') : void 0; // TODO: add a more generic warning for invalid values.

    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        warning$1(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        warning$1(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, inputs);
}
function useLayoutEffect(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, inputs);
}
function useCallback(callback, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, inputs);
}
function useMemo(create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, inputs);
}
function useImperativeHandle(ref, create, inputs) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, inputs);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}
var emptyObject$1 = {};
function useResponder(responder, listenerProps) {
  var dispatcher = resolveDispatcher();

  {
    if (responder == null || responder.$$typeof !== REACT_RESPONDER_TYPE) {
      warning$1(false, 'useResponder: invalid first argument. Expected an event responder, but instead got %s', responder);
      return;
    }
  }

  return dispatcher.useResponder(responder, listenerProps || emptyObject$1);
}
function useTransition(config) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useTransition(config);
}
function useDeferredValue(value, config) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useDeferredValue(value, config);
}

function withSuspenseConfig(scope, config) {
  var previousConfig = ReactCurrentBatchConfig.suspense;
  ReactCurrentBatchConfig.suspense = config === undefined ? null : config;

  try {
    scope();
  } finally {
    ReactCurrentBatchConfig.suspense = previousConfig;
  }
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */
var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  setCurrentlyValidatingElement(element);

  {
    warning$1(false, 'Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
  }

  setCurrentlyValidatingElement(null);
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  var type = element.type;

  if (type === null || type === undefined || typeof type === 'string') {
    return;
  }

  var name = getComponentName(type);
  var propTypes;

  if (typeof type === 'function') {
    propTypes = type.propTypes;
  } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
  // Inner props are checked in the reconciler.
  type.$$typeof === REACT_MEMO_TYPE)) {
    propTypes = type.propTypes;
  } else {
    return;
  }

  if (propTypes) {
    setCurrentlyValidatingElement(element);
    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
    setCurrentlyValidatingElement(null);
  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }

  if (typeof type.getDefaultProps === 'function') {
    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  setCurrentlyValidatingElement(fragment);
  var keys = Object.keys(fragment.props);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];

    if (key !== 'children' && key !== 'key') {
      warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
      break;
    }
  }

  if (fragment.ref !== null) {
    warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
  }

  setCurrentlyValidatingElement(null);
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(source);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    warning$1(false, 'React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    var children = props.children;

    if (children !== undefined) {
      if (isStaticChildren) {
        if (Array.isArray(children)) {
          for (var i = 0; i < children.length; i++) {
            validateChildKeys(children[i], type);
          }

          if (Object.freeze) {
            Object.freeze(children);
          }
        } else {
          warning$1(false, 'React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
        }
      } else {
        validateChildKeys(children, type);
      }
    }
  }

  if (hasOwnProperty$1.call(props, 'key')) {
    warning$1(false, 'React.jsx: Spreading a key to JSX is a deprecated pattern. ' + 'Explicitly pass a key after spreading props in your JSX call. ' + 'E.g. <ComponentName {...props} key={key} />');
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  return jsxWithValidation(type, props, key, true);
}
function jsxWithValidationDynamic(type, props, key) {
  return jsxWithValidation(type, props, key, false);
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type; // Legacy hook: remove it

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarningWithoutStack$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

var hasBadMapPolyfill;

{
  hasBadMapPolyfill = false;

  try {
    var frozenObject = Object.freeze({});
    var testMap = new Map([[frozenObject, null]]);
    var testSet = new Set([frozenObject]); // This is necessary for Rollup to not consider these unused.
    // https://github.com/rollup/rollup/issues/1771
    // TODO: we can remove these if Rollup fixes the bug.

    testMap.set(0, 0);
    testSet.add(0);
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

function createFundamentalComponent(impl) {
  // We use responder as a Map key later on. When we have a bad
  // polyfill, then we can't use it as a key as the polyfill tries
  // to add a property to the object.
  if ( true && !hasBadMapPolyfill) {
    Object.freeze(impl);
  }

  var fundamantalComponent = {
    $$typeof: REACT_FUNDAMENTAL_TYPE,
    impl: impl
  };

  {
    Object.freeze(fundamantalComponent);
  }

  return fundamantalComponent;
}

function createEventResponder(displayName, responderConfig) {
  var getInitialState = responderConfig.getInitialState,
      onEvent = responderConfig.onEvent,
      onMount = responderConfig.onMount,
      onUnmount = responderConfig.onUnmount,
      onRootEvent = responderConfig.onRootEvent,
      rootEventTypes = responderConfig.rootEventTypes,
      targetEventTypes = responderConfig.targetEventTypes,
      targetPortalPropagation = responderConfig.targetPortalPropagation;
  var eventResponder = {
    $$typeof: REACT_RESPONDER_TYPE,
    displayName: displayName,
    getInitialState: getInitialState || null,
    onEvent: onEvent || null,
    onMount: onMount || null,
    onRootEvent: onRootEvent || null,
    onUnmount: onUnmount || null,
    rootEventTypes: rootEventTypes || null,
    targetEventTypes: targetEventTypes || null,
    targetPortalPropagation: targetPortalPropagation || false
  }; // We use responder as a Map key later on. When we have a bad
  // polyfill, then we can't use it as a key as the polyfill tries
  // to add a property to the object.

  if ( true && !hasBadMapPolyfill) {
    Object.freeze(eventResponder);
  }

  return eventResponder;
}

function createScope() {
  var scopeComponent = {
    $$typeof: REACT_SCOPE_TYPE
  };

  {
    Object.freeze(scopeComponent);
  }

  return scopeComponent;
}

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:

 // In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:

 // To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.

 // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:

 // Gather advanced timing metrics for Profiler subtrees.

 // Trace which interactions trigger each commit.

 // SSR experiments


 // Only used in www builds.

 // Only used in www builds.

 // Disable javascript: URL strings in href for XSS protection.

 // React Fire: prevent the value and checked attributes from syncing
// with their related DOM properties

 // These APIs will no longer be "unstable" in the upcoming 16.7 release,
// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.

var exposeConcurrentModeAPIs = false;
 // Experimental React Flare event system and event components support.

var enableFlareAPI = false; // Experimental Host Component support.

var enableFundamentalAPI = false; // Experimental Scope support.

var enableScopeAPI = false; // New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107

var enableJSXTransformAPI = false; // We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v17?)
// Till then, we warn about the missing mock, but still fallback to a sync mode compatible version

 // For tests, we flush suspense fallbacks in an act scope;
// *except* in some of our own tests, where we test incremental loading states.

 // Add a callback property to suspense to notify which promises are currently
// in the update queue. This allows reporting and tracing of what is causing
// the user to see a loading state.
// Also allows hydration callbacks to fire when a dehydrated boundary gets
// hydrated or deleted.

 // Part of the simplification of React.createElement so we can eventually move
// from React.createElement to React.jsx
// https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },
  createRef: createRef,
  Component: Component,
  PureComponent: PureComponent,
  createContext: createContext,
  forwardRef: forwardRef,
  lazy: lazy,
  memo: memo,
  useCallback: useCallback,
  useContext: useContext,
  useEffect: useEffect,
  useImperativeHandle: useImperativeHandle,
  useDebugValue: useDebugValue,
  useLayoutEffect: useLayoutEffect,
  useMemo: useMemo,
  useReducer: useReducer,
  useRef: useRef,
  useState: useState,
  Fragment: REACT_FRAGMENT_TYPE,
  Profiler: REACT_PROFILER_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  Suspense: REACT_SUSPENSE_TYPE,
  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,
  version: ReactVersion,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
};

if (exposeConcurrentModeAPIs) {
  React.useTransition = useTransition;
  React.useDeferredValue = useDeferredValue;
  React.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  React.unstable_withSuspenseConfig = withSuspenseConfig;
}

if (enableFlareAPI) {
  React.unstable_useResponder = useResponder;
  React.unstable_createResponder = createEventResponder;
}

if (enableFundamentalAPI) {
  React.unstable_createFundamental = createFundamentalComponent;
}

if (enableScopeAPI) {
  React.unstable_createScope = createScope;
} // Note: some APIs are added with feature flags.
// Make sure that stable builds for open source
// don't modify the React object to avoid deopts.
// Also let's not expose their names in stable builds.


if (enableJSXTransformAPI) {
  {
    React.jsxDEV = jsxWithValidation;
    React.jsx = jsxWithValidationDynamic;
    React.jsxs = jsxWithValidationStatic;
  }
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.


var react = React$3.default || React$3;

module.exports = react;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/resolve-pathname/esm/resolve-pathname.js":
/*!***************************************************************!*\
  !*** ./node_modules/resolve-pathname/esm/resolve-pathname.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to, from) {
  if (from === undefined) from = '';

  var toParts = (to && to.split('/')) || [];
  var fromParts = (from && from.split('/')) || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) fromParts.unshift('..');

  if (
    mustEndAbs &&
    fromParts[0] !== '' &&
    (!fromParts[0] || !isAbsolute(fromParts[0]))
  )
    fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);


/***/ }),

/***/ "./node_modules/tiny-invariant/dist/tiny-invariant.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/tiny-invariant/dist/tiny-invariant.esm.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isProduction = "development" === 'production';
var prefix = 'Invariant failed';
function invariant(condition, message) {
  if (condition) {
    return;
  }

  if (isProduction) {
    throw new Error(prefix);
  } else {
    throw new Error(prefix + ": " + (message || ''));
  }
}

/* harmony default export */ __webpack_exports__["default"] = (invariant);


/***/ }),

/***/ "./node_modules/tiny-warning/dist/tiny-warning.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/tiny-warning/dist/tiny-warning.esm.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var isProduction = "development" === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ __webpack_exports__["default"] = (warning);


/***/ }),

/***/ "./node_modules/value-equal/esm/value-equal.js":
/*!*****************************************************!*\
  !*** ./node_modules/value-equal/esm/value-equal.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function valueOf(obj) {
  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
}

function valueEqual(a, b) {
  // Test for strict equality first.
  if (a === b) return true;

  // Otherwise, if either of them == null they are not equal.
  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return (
      Array.isArray(b) &&
      a.length === b.length &&
      a.every(function(item, index) {
        return valueEqual(item, b[index]);
      })
    );
  }

  if (typeof a === 'object' || typeof b === 'object') {
    var aValue = valueOf(a);
    var bValue = valueOf(b);

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    return Object.keys(Object.assign({}, a, b)).every(function(key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);


/***/ }),

/***/ "./src/client/components/Home.jsx":
/*!****************************************!*\
  !*** ./src/client/components/Home.jsx ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var Home = function Home() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h1", null, "React-SSR Boilerplate"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "This is a minimal SSR boilerplate with ReactJS, NodeJS, HapiJS, Webpack."), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
    onClick: function onClick() {
      return console.log("Click Works === Hydrate Works");
    }
  }, "Click !"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "Use console to validate Events / Hydrate is working... "), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h2", null, "Features & Examples: "), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "Example routing: ", react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("a", {
    href: "/test"
  }, "Test")));
};

/* harmony default export */ __webpack_exports__["default"] = (Home);

/***/ }),

/***/ "./src/client/components/Test.jsx":
/*!****************************************!*\
  !*** ./src/client/components/Test.jsx ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);


var Test = function Test() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h1", null, "React-SSR Boilerplate"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "This is a test route."), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
    onClick: function onClick() {
      return console.log("Click Works === Hydrate Works");
    }
  }, "Click !"));
};

/* harmony default export */ __webpack_exports__["default"] = (Test);

/***/ }),

/***/ "./src/client/routes.jsx":
/*!*******************************!*\
  !*** ./src/client/routes.jsx ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_Home__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Home */ "./src/client/components/Home.jsx");
/* harmony import */ var _components_Test__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Test */ "./src/client/components/Test.jsx");


var routesList = [{
  path: '/',
  exact: true,
  component: _components_Home__WEBPACK_IMPORTED_MODULE_0__["default"]
}, {
  path: '/test',
  component: _components_Test__WEBPACK_IMPORTED_MODULE_1__["default"]
}];
/* harmony default export */ __webpack_exports__["default"] = (routesList);

/***/ }),

/***/ "./src/server/htmlTemplate.jsx":
/*!*************************************!*\
  !*** ./src/server/htmlTemplate.jsx ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js");
/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/esm/react-router-dom.js");
/* harmony import */ var _client_routes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../client/routes */ "./src/client/routes.jsx");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./src/server/utils.js");





/* harmony default export */ __webpack_exports__["default"] = (function (req) {
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("html", {
    lang: "en"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("head", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("meta", {
    charSet: "UTF-8"
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("title", null, "Boilerplate - SSR with HapiJS, React")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("body", null, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
    id: "app"
  }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_2__["StaticRouter"], {
    location: req.path,
    context: {}
  }, _client_routes__WEBPACK_IMPORTED_MODULE_3__["default"].map(function (route) {
    return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0___default()({
      key: route.path
    }, route));
  }))), _utils__WEBPACK_IMPORTED_MODULE_4__["vendorScripts"].map(function (scriptPath) {
    return scriptPath && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("script", {
      key: scriptPath,
      src: scriptPath
    });
  }), _utils__WEBPACK_IMPORTED_MODULE_4__["clientScripts"].map(function (scriptPath) {
    return scriptPath && react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("script", {
      key: scriptPath,
      src: scriptPath
    });
  })));
});

/***/ }),

/***/ "./src/server/index.js":
/*!*****************************!*\
  !*** ./src/server/index.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _hapi_hapi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hapi/hapi */ "./node_modules/@hapi/hapi/lib/index.js");
/* harmony import */ var _hapi_hapi__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_hapi_hapi__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _hapi_inert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @hapi/inert */ "./node_modules/@hapi/inert/lib/index.js");
/* harmony import */ var _hapi_inert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_hapi_inert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _routes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./routes */ "./src/server/routes.js");






var init =
/*#__PURE__*/
function () {
  var _ref = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1___default()(
  /*#__PURE__*/
  _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
    var server;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            server = _hapi_hapi__WEBPACK_IMPORTED_MODULE_2___default.a.server({
              port: 3000
            });
            _context.next = 3;
            return server.register(_hapi_inert__WEBPACK_IMPORTED_MODULE_3___default.a);

          case 3:
            _context.next = 5;
            return server.route(_routes__WEBPACK_IMPORTED_MODULE_4__["default"]);

          case 5:
            _context.next = 7;
            return server.start();

          case 7:
            console.log("\n------------------------------");
            console.log("  SERVER up and running...");
            console.log("------------------------------");
            console.dir(server.info);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function init() {
    return _ref.apply(this, arguments);
  };
}();

process.on("unhandledRejection", function (err) {
  console.log(err);
  process.exit(1);
});
init();

/***/ }),

/***/ "./src/server/reactHandler.js":
/*!************************************!*\
  !*** ./src/server/reactHandler.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom/server */ "./node_modules/react-dom/server.js");
/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom_server__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _htmlTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./htmlTemplate */ "./src/server/htmlTemplate.jsx");



var reactHandler = function reactHandler(request, h) {
  return "<!DOCTYPE html>" + Object(react_dom_server__WEBPACK_IMPORTED_MODULE_0__["renderToString"])(Object(_htmlTemplate__WEBPACK_IMPORTED_MODULE_1__["default"])(request));
};

/* harmony default export */ __webpack_exports__["default"] = (reactHandler);

/***/ }),

/***/ "./src/server/routes.js":
/*!******************************!*\
  !*** ./src/server/routes.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reactHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reactHandler */ "./src/server/reactHandler.js");

/* harmony default export */ __webpack_exports__["default"] = ([// Static Files
{
  path: "/{param*}",
  method: "GET",
  config: {
    handler: {
      directory: {
        path: 'dist'
      }
    }
  }
}, // Default Route
{
  method: "GET",
  path: "/",
  handler: _reactHandler__WEBPACK_IMPORTED_MODULE_0__["default"]
}, {
  method: "GET",
  path: "/test",
  handler: _reactHandler__WEBPACK_IMPORTED_MODULE_0__["default"]
}]);

/***/ }),

/***/ "./src/server/utils.js":
/*!*****************************!*\
  !*** ./src/server/utils.js ***!
  \*****************************/
/*! exports provided: clientScripts, vendorScripts */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clientScripts", function() { return clientScripts; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vendorScripts", function() { return vendorScripts; });
var fs = __webpack_require__(/*! fs */ "fs");

var clientScripts = fs.readdirSync('dist', {
  withFileTypes: true
}).filter(function (item) {
  return item && /client/.test(item);
});
var vendorScripts = fs.readdirSync('dist', {
  withFileTypes: true
}).filter(function (item) {
  return item && /vendor/.test(item);
});


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("zlib");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmVyL2luZGV4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvYWNjZXB0L2xpYi9oZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FjY2VwdC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FjY2VwdC9saWIvbWVkaWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FkZHJlc3MvbGliL2RvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvYWRkcmVzcy9saWIvZW1haWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2FkZHJlc3MvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9hZGRyZXNzL2xpYi90bGRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9hbW1vL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvYjY0L2xpYi9kZWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9iNjQvbGliL2VuY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2I2NC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2Jvb20vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ib3VuY2UvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ib3VybmUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9jYWxsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY2FsbC9saWIvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2NhbGwvbGliL3NlZ21lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2NhdGJveC1tZW1vcnkvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9jYXRib3gvbGliL2NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY2F0Ym94L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY2F0Ym94L2xpYi9wZW5kaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9jYXRib3gvbGliL3BvbGljeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvY29udGVudC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2NyeXB0aWxlcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2ZpbGUvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9mb3JtdWxhL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvYXV0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvY29tcHJlc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbGliL2NvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvY29ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9oZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvbWV0aG9kcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbGliL3JvdXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9zZWN1cml0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvc2VydmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi9zdHJlYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi90b29sa2l0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL2xpYi90cmFuc21pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9saWIvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9jYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL2Vycm9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9sYW5ndWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9yZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvc2NoZW1hcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYWx0ZXJuYXRpdmVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2FueS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9hbnkvc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYmluYXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2Jvb2xlYW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvZGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9mdW5jL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2xhenkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvbnVtYmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL29iamVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaGFwaS9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9zdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3RyaW5nL2lwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy9yZmMzOTg2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy91cmkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hhcGkvbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9oYXBpL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hlYXZ5L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvYXBwbHlUb0RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2JlbmNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9ibG9jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2NvbnRhaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2RlZXBFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2VzY2FwZUhlYWRlckF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlSHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlSnNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2lnbm9yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL2ludGVyc2VjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL29uY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3JlYWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9yZWFjaFRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi9zdHJpbmdpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2hvZWsvbGliL3R5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9ob2VrL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaG9lay9saWIvd2FpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaW5lcnQvbGliL2RpcmVjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaW5lcnQvbGliL2V0YWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2luZXJ0L2xpYi9maWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9pbmVydC9saWIvZnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2luZXJ0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvaXJvbi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvY29tcGlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvZXh0ZW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL21hbmlmZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL21lc3NhZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL21vZGlmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9yZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvc2NoZW1hcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90ZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90cmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9hbHRlcm5hdGl2ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvYW55LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9ib29sZWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL2RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9saW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL251bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdHlwZXMvc3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N0cmluZy9pcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi90eXBlcy9zdHJpbmcvdXJpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9qb2kvbGliL3R5cGVzL3N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvam9pL2xpYi92YWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL2pvaS9saWIvdmFsdWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9taW1vcy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL25pZ2VsL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvcGV6L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvcGlucG9pbnQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9wb2RpdW0vbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9zaG90L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvc2hvdC9saWIvcmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvc2hvdC9saWIvcmVzcG9uc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3Nob3QvbGliL3N5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3NvbWV2ZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9zdGF0ZWhvb2QvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS9zdWJ0ZXh0L2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvdGVhbXdvcmsvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaGFwaS90b3BvL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvdmlzZS9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3dyZWNrL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvd3JlY2svbGliL3BheWxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BoYXBpL3dyZWNrL2xpYi9yZWNvcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhhcGkvd3JlY2svbGliL3RhcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ3VkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzbS9oaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9scnUtY2FjaGUvbm9kZV9tb2R1bGVzL3lhbGxpc3QveWFsbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWluaS1jcmVhdGUtcmVhY3QtY29udGV4dC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHNldWRvbWFwL3BzZXVkb21hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20tc2VydmVyLm5vZGUuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9zZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9zZXJ2ZXIubm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lc20vcmVhY3Qtcm91dGVyLWRvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzbS9yZWFjdC1yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9lc20vcmVzb2x2ZS1wYXRobmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlueS1pbnZhcmlhbnQvZGlzdC90aW55LWludmFyaWFudC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Rpbnktd2FybmluZy9kaXN0L3Rpbnktd2FybmluZy5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2VzbS92YWx1ZS1lcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2xpZW50L2NvbXBvbmVudHMvSG9tZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NsaWVudC9jb21wb25lbnRzL1Rlc3QuanN4Iiwid2VicGFjazovLy8uL3NyYy9jbGllbnQvcm91dGVzLmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyL2h0bWxUZW1wbGF0ZS5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL3NlcnZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyL3JlYWN0SGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyL3JvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2VydmVyL3V0aWxzLmpzIiwid2VicGFjazovLy9leHRlcm5hbCBcImFzc2VydFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImNyeXB0b1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImV2ZW50c1wiIiwid2VicGFjazovLy9leHRlcm5hbCBcImZzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiaHR0cFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcImh0dHBzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwibmV0XCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwib3NcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwicXVlcnlzdHJpbmdcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHJlYW1cIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1cmxcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiemxpYlwiIl0sInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9zZXJ2ZXIvaW5kZXguanNcIik7XG4iLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2V4dGVuZHM7IiwiZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0c0xvb3NlOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuc2VsZWN0aW9uID0gZnVuY3Rpb24gKGhlYWRlciwgcHJlZmVyZW5jZXMsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHNlbGVjdGlvbnMgPSBleHBvcnRzLnNlbGVjdGlvbnMoaGVhZGVyLCBwcmVmZXJlbmNlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbnMubGVuZ3RoID8gc2VsZWN0aW9uc1swXSA6ICcnO1xufTtcblxuXG5leHBvcnRzLnNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoaGVhZGVyLCBwcmVmZXJlbmNlcywgb3B0aW9ucykge1xuXG4gICAgSG9lay5hc3NlcnQoIXByZWZlcmVuY2VzIHx8IEFycmF5LmlzQXJyYXkocHJlZmVyZW5jZXMpLCAnUHJlZmVyZW5jZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuXG4gICAgcmV0dXJuIGludGVybmFscy5wYXJzZShoZWFkZXIgfHwgJycsIHByZWZlcmVuY2VzLCBvcHRpb25zKTtcbn07XG5cblxuLy8gICAgICBSRkMgNzIzMSBTZWN0aW9uIDUuMy4zIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTUuMy4zKVxuLy9cbi8vICAgICAgQWNjZXB0LUNoYXJzZXQgID0gKiggXCIsXCIgT1dTICkgKCAoIGNoYXJzZXQgLyBcIipcIiApIFsgd2VpZ2h0IF0gKSAqKCBPV1MgXCIsXCIgWyBPV1MgKCAoIGNoYXJzZXQgLyBcIipcIiApIFsgd2VpZ2h0IF0gKSBdIClcbi8vICAgICAgY2hhcnNldCAgICAgICAgID0gdG9rZW5cbi8vXG4vLyAgICAgIEFjY2VwdC1DaGFyc2V0OiBpc28tODg1OS01LCB1bmljb2RlLTEtMTtxPTAuOFxuXG5cbi8vICAgICAgUkZDIDcyMzEgU2VjdGlvbiA1LjMuNCAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi01LjMuNClcbi8vXG4vLyAgICAgIEFjY2VwdC1FbmNvZGluZyA9IFsgKCBcIixcIiAvICggY29kaW5ncyBbIHdlaWdodCBdICkgKSAqKCBPV1MgXCIsXCIgWyBPV1MgKCBjb2RpbmdzIFsgd2VpZ2h0IF0gKSBdICkgXVxuLy8gICAgICBjb2RpbmdzICAgICAgICAgPSBjb250ZW50LWNvZGluZyAvIFwiaWRlbnRpdHlcIiAvIFwiKlwiXG4vLyAgICAgIGNvbnRlbnQtY29kaW5nICA9IHRva2VuXG4vL1xuLy8gICAgICBBY2NlcHQtRW5jb2Rpbmc6IGNvbXByZXNzLCBnemlwXG4vLyAgICAgIEFjY2VwdC1FbmNvZGluZzpcbi8vICAgICAgQWNjZXB0LUVuY29kaW5nOiAqXG4vLyAgICAgIEFjY2VwdC1FbmNvZGluZzogY29tcHJlc3M7cT0wLjUsIGd6aXA7cT0xLjBcbi8vICAgICAgQWNjZXB0LUVuY29kaW5nOiBnemlwO3E9MS4wLCBpZGVudGl0eTsgcT0wLjUsICo7cT0wXG5cblxuLy8gICAgICBSRkMgNzIzMSBTZWN0aW9uIDUuMy41IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTUuMy41KVxuLy9cbi8vICAgICAgQWNjZXB0LUxhbmd1YWdlID0gKiggXCIsXCIgT1dTICkgKCBsYW5ndWFnZS1yYW5nZSBbIHdlaWdodCBdICkgKiggT1dTIFwiLFwiIFsgT1dTICggbGFuZ3VhZ2UtcmFuZ2UgWyB3ZWlnaHQgXSApIF0gKVxuLy8gICAgICBsYW5ndWFnZS1yYW5nZSAgPSAoIDEqOEFMUEhBICooIFwiLVwiIDEqOGFscGhhbnVtICkgKSAvIFwiKlwiICAgOyBbUkZDNDY0N10sIFNlY3Rpb24gMi4xXG4vLyAgICAgIGFscGhhbnVtICAgICAgICA9IEFMUEhBIC8gRElHSVRcbi8vXG4vLyAgICAgICBBY2NlcHQtTGFuZ3VhZ2U6IGRhLCBlbi1nYjtxPTAuOCwgZW47cT0wLjdcblxuXG4vLyAgICAgIHRva2VuICAgICAgICAgICA9IDEqdGNoYXJcbi8vICAgICAgdGNoYXIgICAgICAgICAgID0gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIqXCJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgLyBcIl5cIiAvIFwiX1wiIC8gXCJgXCIgLyBcInxcIiAvIFwiflwiXG4vLyAgICAgICAgICAgICAgICAgICAgICAgIC8gRElHSVQgLyBBTFBIQVxuLy8gICAgICAgICAgICAgICAgICAgICAgICA7IGFueSBWQ0hBUiwgZXhjZXB0IGRlbGltaXRlcnNcbi8vICAgICAgT1dTICAgICAgICAgICAgID0gKiggU1AgLyBIVEFCIClcblxuXG4vLyAgICAgIFJGQyA3MjMxIFNlY3Rpb24gNS4zLjEgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNS4zLjEpXG4vL1xuLy8gICAgICBUaGUgd2VpZ2h0IGlzIG5vcm1hbGl6ZWQgdG8gYSByZWFsIG51bWJlciBpbiB0aGUgcmFuZ2UgMCB0aHJvdWdoIDEsXG4vLyAgICAgIHdoZXJlIDAuMDAxIGlzIHRoZSBsZWFzdCBwcmVmZXJyZWQgYW5kIDEgaXMgdGhlIG1vc3QgcHJlZmVycmVkOyBhXG4vLyAgICAgIHZhbHVlIG9mIDAgbWVhbnMgXCJub3QgYWNjZXB0YWJsZVwiLiAgSWYgbm8gXCJxXCIgcGFyYW1ldGVyIGlzIHByZXNlbnQsXG4vLyAgICAgIHRoZSBkZWZhdWx0IHdlaWdodCBpcyAxLlxuLy9cbi8vICAgICAgIHdlaWdodCA9IE9XUyBcIjtcIiBPV1MgXCJxPVwiIHF2YWx1ZVxuLy8gICAgICAgcXZhbHVlID0gKCBcIjBcIiBbIFwiLlwiIDAqM0RJR0lUIF0gKSAvICggXCIxXCIgWyBcIi5cIiAwKjMoXCIwXCIpIF0gKVxuXG5cbmludGVybmFscy5wYXJzZSA9IGZ1bmN0aW9uIChyYXcsIHByZWZlcmVuY2VzLCBvcHRpb25zKSB7XG5cbiAgICAvLyBOb3JtYWxpemUgaGVhZGVyIChyZW1vdmUgc3BhY2VzIGFuZCB0YWJzKVxuXG4gICAgY29uc3QgaGVhZGVyID0gcmF3LnJlcGxhY2UoL1sgXFx0XS9nLCAnJyk7XG5cbiAgICAvLyBOb3JtYWxpemUgcHJlZmVyZW5jZXNcblxuICAgIGNvbnN0IGxvd2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKHByZWZlcmVuY2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZmVyZW5jZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZlcmVuY2UgPSBwcmVmZXJlbmNlc1tpXTtcbiAgICAgICAgICAgIGxvd2Vyc1twcmVmZXJlbmNlLnRvTG93ZXJDYXNlKCldID0geyBvcmlnOiBwcmVmZXJlbmNlLCBwb3M6IGkgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcnNlIHNlbGVjdGlvbnNcblxuICAgIGNvbnN0IHBhcnRzID0gaGVhZGVyLnNwbGl0KCcsJyk7XG4gICAgY29uc3Qgc2VsZWN0aW9ucyA9IFtdO1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZW1wdHkgcGFydHMgb3IgbGVhZGluZyBjb21tYXNcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2UgcGFyYW1ldGVyc1xuXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHBhcnQuc3BsaXQoJzsnKTtcbiAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoYEludmFsaWQgJHtvcHRpb25zLnR5cGV9IGhlYWRlcmApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRva2VuID0gcGFyYW1zWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdChgSW52YWxpZCAke29wdGlvbnMudHlwZX0gaGVhZGVyYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5lcXVpdmFsZW50cyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5lcXVpdmFsZW50c1t0b2tlbl0pIHtcblxuICAgICAgICAgICAgdG9rZW4gPSBvcHRpb25zLmVxdWl2YWxlbnRzW3Rva2VuXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgcG9zOiBpLFxuICAgICAgICAgICAgcTogMSxcbiAgICAgICAgICAgIHNwZWNpZmljaXR5OiBvcHRpb25zLnNwZWNpZmljaXR5ID8gdG9rZW4uc3BsaXQoJy0nKSA6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJlZmVyZW5jZXMgJiZcbiAgICAgICAgICAgIGxvd2Vyc1t0b2tlbl0pIHtcblxuICAgICAgICAgICAgc2VsZWN0aW9uLnByZWYgPSBsb3dlcnNbdG9rZW5dLnBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcFtzZWxlY3Rpb24udG9rZW5dID0gc2VsZWN0aW9uO1xuXG4gICAgICAgIC8vIFBhcnNlIHE9dmFsdWVcblxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3QgcSA9IHBhcmFtc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHEuc3BsaXQoJz0nKTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgICAgIChrZXkgIT09ICdxJyAmJiBrZXkgIT09ICdRJykpIHtcblxuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdChgSW52YWxpZCAke29wdGlvbnMudHlwZX0gaGVhZGVyYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoc2NvcmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzY29yZSkgJiZcbiAgICAgICAgICAgICAgICBzY29yZSA8PSAxICYmXG4gICAgICAgICAgICAgICAgc2NvcmUgPj0gMC4wMDEpIHtcblxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5xID0gc2NvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3Rpb25zLnB1c2goc2VsZWN0aW9uKTsgICAgICAgICAgICAgLy8gT25seSBhZGQgYWxsb3dlZCBzZWxlY3Rpb25zIChxICE9PSAwKVxuICAgIH1cblxuICAgIC8vIFNvcnQgc2VsZWN0aW9uIGJhc2VkIG9uIHEgYW5kIHRoZW4gcG9zaXRpb24gaW4gaGVhZGVyXG5cbiAgICBzZWxlY3Rpb25zLnNvcnQoaW50ZXJuYWxzLnNvcnQpO1xuXG4gICAgLy8gRXh0cmFjdCB0b2tlbnNcblxuICAgIGNvbnN0IHZhbHVlcyA9IHNlbGVjdGlvbnMubWFwKChzZWxlY3Rpb24pID0+IHNlbGVjdGlvbi50b2tlbik7XG5cbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0ICYmXG4gICAgICAgICFtYXBbb3B0aW9ucy5kZWZhdWx0XSkge1xuXG4gICAgICAgIHZhbHVlcy5wdXNoKG9wdGlvbnMuZGVmYXVsdCk7XG4gICAgfVxuXG4gICAgaWYgKCFwcmVmZXJlbmNlcyB8fFxuICAgICAgICAhcHJlZmVyZW5jZXMubGVuZ3RoKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgICBjb25zdCBwcmVmZXJyZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gJyonKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZWZlcmVuY2Ugb2YgT2JqZWN0LmtleXMobG93ZXJzKSkge1xuICAgICAgICAgICAgICAgIGlmICghbWFwW3ByZWZlcmVuY2VdKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZlcnJlZC5wdXNoKGxvd2Vyc1twcmVmZXJlbmNlXS5vcmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsb3dlciA9IHNlbGVjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGxvd2Vyc1tsb3dlcl0pIHtcbiAgICAgICAgICAgICAgICBwcmVmZXJyZWQucHVzaChsb3dlcnNbbG93ZXJdLm9yaWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZlcnJlZDtcbn07XG5cblxuaW50ZXJuYWxzLnNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgYUZpcnN0ID0gLTE7XG4gICAgY29uc3QgYkZpcnN0ID0gMTtcblxuICAgIGlmIChiLnEgIT09IGEucSkge1xuICAgICAgICByZXR1cm4gYi5xIC0gYS5xO1xuICAgIH1cblxuICAgIGlmIChiLnByZWYgIT09IGEucHJlZikge1xuICAgICAgICBpZiAoYS5wcmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiRmlyc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYi5wcmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhRmlyc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYS5wcmVmIC0gYi5wcmVmO1xuICAgIH1cblxuICAgIGlmIChhLnNwZWNpZmljaXR5ICYmXG4gICAgICAgIGEuc3BlY2lmaWNpdHlbMF0gPT09IGIuc3BlY2lmaWNpdHlbMF0gJiZcbiAgICAgICAgYS5zcGVjaWZpY2l0eS5sZW5ndGggIT09IGIuc3BlY2lmaWNpdHkubGVuZ3RoKSB7XG5cbiAgICAgICAgcmV0dXJuIGIuc3BlY2lmaWNpdHkubGVuZ3RoIC0gYS5zcGVjaWZpY2l0eS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEucG9zIC0gYi5wb3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlcicpO1xuY29uc3QgTWVkaWEgPSByZXF1aXJlKCcuL21lZGlhJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgY2hhcnNldDoge1xuICAgICAgICAgICAgdHlwZTogJ2FjY2VwdC1jaGFyc2V0J1xuICAgICAgICB9LFxuICAgICAgICBlbmNvZGluZzoge1xuICAgICAgICAgICAgdHlwZTogJ2FjY2VwdC1lbmNvZGluZycsXG4gICAgICAgICAgICBkZWZhdWx0OiAnaWRlbnRpdHknLFxuICAgICAgICAgICAgZXF1aXZhbGVudHM6IHtcbiAgICAgICAgICAgICAgICAneC1jb21wcmVzcyc6ICdjb21wcmVzcycsXG4gICAgICAgICAgICAgICAgJ3gtZ3ppcCc6ICdnemlwJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgdHlwZTogJ2FjY2VwdC1sYW5ndWFnZScsXG4gICAgICAgICAgICBzcGVjaWZpY2l0eTogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5mb3IgKGNvbnN0IHR5cGUgaW4gaW50ZXJuYWxzLm9wdGlvbnMpIHtcbiAgICBleHBvcnRzW3R5cGVdID0gKGhlYWRlciwgcHJlZmVyZW5jZXMpID0+IEhlYWRlci5zZWxlY3Rpb24oaGVhZGVyLCBwcmVmZXJlbmNlcywgaW50ZXJuYWxzLm9wdGlvbnNbdHlwZV0pO1xuXG4gICAgZXhwb3J0c1tgJHt0eXBlfXNgXSA9IChoZWFkZXIsIHByZWZlcmVuY2VzKSA9PiBIZWFkZXIuc2VsZWN0aW9ucyhoZWFkZXIsIHByZWZlcmVuY2VzLCBpbnRlcm5hbHMub3B0aW9uc1t0eXBlXSk7XG59XG5cblxuZXhwb3J0cy5tZWRpYVR5cGUgPSAoaGVhZGVyLCBwcmVmZXJlbmNlcykgPT4gTWVkaWEuc2VsZWN0aW9uKGhlYWRlciwgcHJlZmVyZW5jZXMpO1xuXG5leHBvcnRzLm1lZGlhVHlwZXMgPSAoaGVhZGVyLCBwcmVmZXJlbmNlcykgPT4gTWVkaWEuc2VsZWN0aW9ucyhoZWFkZXIsIHByZWZlcmVuY2VzKTtcblxuXG5leHBvcnRzLnBhcnNlQWxsID0gZnVuY3Rpb24gKHJlcXVlc3RIZWFkZXJzKSB7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFyc2V0czogZXhwb3J0cy5jaGFyc2V0cyhyZXF1ZXN0SGVhZGVyc1snYWNjZXB0LWNoYXJzZXQnXSksXG4gICAgICAgIGVuY29kaW5nczogZXhwb3J0cy5lbmNvZGluZ3MocmVxdWVzdEhlYWRlcnNbJ2FjY2VwdC1lbmNvZGluZyddKSxcbiAgICAgICAgbGFuZ3VhZ2VzOiBleHBvcnRzLmxhbmd1YWdlcyhyZXF1ZXN0SGVhZGVyc1snYWNjZXB0LWxhbmd1YWdlJ10pLFxuICAgICAgICBtZWRpYVR5cGVzOiBleHBvcnRzLm1lZGlhVHlwZXMocmVxdWVzdEhlYWRlcnMuYWNjZXB0KVxuICAgIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuc2VsZWN0aW9uID0gZnVuY3Rpb24gKGhlYWRlciwgcHJlZmVyZW5jZXMpIHtcblxuICAgIGNvbnN0IHNlbGVjdGlvbnMgPSBleHBvcnRzLnNlbGVjdGlvbnMoaGVhZGVyLCBwcmVmZXJlbmNlcyk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbnMubGVuZ3RoID8gc2VsZWN0aW9uc1swXSA6ICcnO1xufTtcblxuXG5leHBvcnRzLnNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoaGVhZGVyLCBwcmVmZXJlbmNlcykge1xuXG4gICAgSG9lay5hc3NlcnQoIXByZWZlcmVuY2VzIHx8IEFycmF5LmlzQXJyYXkocHJlZmVyZW5jZXMpLCAnUHJlZmVyZW5jZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuXG4gICAgcmV0dXJuIGludGVybmFscy5wYXJzZShoZWFkZXIsIHByZWZlcmVuY2VzKTtcbn07XG5cblxuLy8gICAgICBSRkMgNzIzMSBTZWN0aW9uIDUuMy4yIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTUuMy4yKVxuLy9cbi8vICAgICAgQWNjZXB0ICAgICAgICAgID0gWyAoIFwiLFwiIC8gKCBtZWRpYS1yYW5nZSBbIGFjY2VwdC1wYXJhbXMgXSApICkgKiggT1dTIFwiLFwiIFsgT1dTICggbWVkaWEtcmFuZ2UgWyBhY2NlcHQtcGFyYW1zIF0gKSBdICkgXVxuLy8gICAgICBtZWRpYS1yYW5nZSAgICAgPSAoIFwiKi8qXCIgLyAoIHR5cGUgXCIvKlwiICkgLyAoIHR5cGUgXCIvXCIgc3VidHlwZSApICkgKiggT1dTIFwiO1wiIE9XUyBwYXJhbWV0ZXIgKVxuLy8gICAgICBhY2NlcHQtcGFyYW1zICAgPSB3ZWlnaHQgKmFjY2VwdC1leHRcbi8vICAgICAgYWNjZXB0LWV4dCAgICAgID0gT1dTIFwiO1wiIE9XUyB0b2tlbiBbIFwiPVwiICggdG9rZW4gLyBxdW90ZWQtc3RyaW5nICkgXVxuLy8gICAgICB0eXBlICAgICAgICAgICAgPSB0b2tlblxuLy8gICAgICBzdWJ0eXBlICAgICAgICAgPSB0b2tlblxuLy8gICAgICBwYXJhbWV0ZXIgICAgICAgPSB0b2tlbiBcIj1cIiAoIHRva2VuIC8gcXVvdGVkLXN0cmluZyApXG4vL1xuLy8gICAgICBxdW90ZWQtc3RyaW5nICAgPSBEUVVPVEUgKiggcWR0ZXh0IC8gcXVvdGVkLXBhaXIgKSBEUVVPVEVcbi8vICAgICAgcWR0ZXh0ICAgICAgICAgID0gSFRBQiAvIFNQIC8leDIxIC8gJXgyMy01QiAvICV4NUQtN0UgLyBvYnMtdGV4dFxuLy8gICAgICBvYnMtdGV4dCAgICAgICAgPSAleDgwLUZGXG4vLyAgICAgIHF1b3RlZC1wYWlyICAgICA9IFwiXFxcIiAoIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVxuLy8gICAgICBWQ0hBUiAgICAgICAgICAgPSAleDIxLTdFICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IHZpc2libGUgKHByaW50aW5nKSBjaGFyYWN0ZXJzXG4vLyAgICAgIHRva2VuICAgICAgICAgICA9IDEqdGNoYXJcbi8vICAgICAgdGNoYXIgICAgICAgICAgID0gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIqXCIgLyBcIitcIiAvIFwiLVwiIC8gXCIuXCIgLyBcIl5cIiAvIFwiX1wiIC8gXCJgXCIgLyBcInxcIiAvIFwiflwiIC8gRElHSVQgLyBBTFBIQVxuLy8gICAgICBPV1MgICAgICAgICAgICAgPSAqKCBTUCAvIEhUQUIgKVxuLy9cbi8vICAgICAgQWNjZXB0OiBhdWRpby8qOyBxPTAuMiwgYXVkaW8vYmFzaWNcbi8vICAgICAgQWNjZXB0OiB0ZXh0L3BsYWluOyBxPTAuNSwgdGV4dC9odG1sLCB0ZXh0L3gtZHZpOyBxPTAuOCwgdGV4dC94LWNcbi8vICAgICAgQWNjZXB0OiB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qc29uO3E9MC41LCB0ZXh0L2h0bWwsICovKjsgcSA9IDAuMVxuLy8gICAgICBBY2NlcHQ6IHRleHQvcGxhaW4sIGFwcGxpY2F0aW9uL2pzb247cT0wLjUsIHRleHQvaHRtbCwgdGV4dC9kcm9wO3E9MFxuLy8gICAgICBBY2NlcHQ6IHRleHQvKiwgdGV4dC9wbGFpbiwgdGV4dC9wbGFpbjtmb3JtYXQ9Zmxvd2VkLCAqLypcbi8vICAgICAgQWNjZXB0OiB0ZXh0Lyo7cT0wLjMsIHRleHQvaHRtbDtxPTAuNywgdGV4dC9odG1sO2xldmVsPTEsIHRleHQvaHRtbDtsZXZlbD0yO3E9MC40LCAqLyo7cT0wLjVcblxuXG4vLyAgICAgIFJGQyA3MjMxIFNlY3Rpb24gNS4zLjEgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNS4zLjEpXG4vL1xuLy8gICAgICBUaGUgd2VpZ2h0IGlzIG5vcm1hbGl6ZWQgdG8gYSByZWFsIG51bWJlciBpbiB0aGUgcmFuZ2UgMCB0aHJvdWdoIDEsXG4vLyAgICAgIHdoZXJlIDAuMDAxIGlzIHRoZSBsZWFzdCBwcmVmZXJyZWQgYW5kIDEgaXMgdGhlIG1vc3QgcHJlZmVycmVkOyBhXG4vLyAgICAgIHZhbHVlIG9mIDAgbWVhbnMgXCJub3QgYWNjZXB0YWJsZVwiLiAgSWYgbm8gXCJxXCIgcGFyYW1ldGVyIGlzIHByZXNlbnQsXG4vLyAgICAgIHRoZSBkZWZhdWx0IHdlaWdodCBpcyAxLlxuLy9cbi8vICAgICAgIHdlaWdodCA9IE9XUyBcIjtcIiBPV1MgXCJxPVwiIHF2YWx1ZVxuLy8gICAgICAgcXZhbHVlID0gKCBcIjBcIiBbIFwiLlwiIDAqM0RJR0lUIF0gKSAvICggXCIxXCIgWyBcIi5cIiAwKjMoXCIwXCIpIF0gKVxuXG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICovKiAgICAgICAgdHlwZS8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZS9zdWJ0eXBlXG5pbnRlcm5hbHMudmFsaWRNZWRpYVJ4ID0gL14oPzpcXCpcXC9cXCopfCg/OltcXHdcXCEjXFwkJSYnXFwqXFwrXFwtXFwuXFxeYFxcfH5dK1xcL1xcKil8KD86W1xcd1xcISNcXCQlJidcXCpcXCtcXC1cXC5cXF5gXFx8fl0rXFwvW1xcd1xcISNcXCQlJidcXCpcXCtcXC1cXC5cXF5gXFx8fl0rKSQvO1xuXG5cbmludGVybmFscy5wYXJzZSA9IGZ1bmN0aW9uIChyYXcsIHByZWZlcmVuY2VzKSB7XG5cbiAgICAvLyBOb3JtYWxpemUgaGVhZGVyIChyZW1vdmUgc3BhY2VzIGFuZCB0ZW1wb3JhcnkgcmVtb3ZlIHF1b3RlZCBzdHJpbmdzKVxuXG4gICAgY29uc3QgeyBoZWFkZXIsIHF1b3RlZCB9ID0gaW50ZXJuYWxzLm5vcm1hbGl6ZShyYXcpO1xuXG4gICAgLy8gUGFyc2Ugc2VsZWN0aW9uc1xuXG4gICAgY29uc3QgcGFydHMgPSBoZWFkZXIuc3BsaXQoJywnKTtcbiAgICBjb25zdCBzZWxlY3Rpb25zID0gW107XG4gICAgY29uc3QgbWFwID0ge307XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVtcHR5IHBhcnRzIG9yIGxlYWRpbmcgY29tbWFzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIHBhcmFtZXRlcnNcblxuICAgICAgICBjb25zdCBwYWlycyA9IHBhcnQuc3BsaXQoJzsnKTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYWlycy5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKCFpbnRlcm5hbHMudmFsaWRNZWRpYVJ4LnRlc3QodG9rZW4pKSB7ICAgICAgIC8vIElnbm9yZSBpbnZhbGlkIHR5cGVzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgIGV4dHM6IHt9LFxuICAgICAgICAgICAgcG9zOiBpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUGFyc2Uga2V5PXZhbHVlXG5cbiAgICAgICAgbGV0IHRhcmdldCA9ICdwYXJhbXMnO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGt2ID0gcGFpci5zcGxpdCgnPScpO1xuICAgICAgICAgICAgaWYgKGt2Lmxlbmd0aCAhPT0gMiB8fFxuICAgICAgICAgICAgICAgICFrdlsxXSkge1xuXG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KGBJbnZhbGlkIGFjY2VwdCBoZWFkZXJgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5ID0ga3ZbMF07XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBrdlsxXTtcblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3EnIHx8XG4gICAgICAgICAgICAgICAga2V5ID09PSAnUScpIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldCA9ICdleHRzJztcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID4gMSB8fFxuICAgICAgICAgICAgICAgICAgICAodmFsdWUgPCAwLjAwMSAmJiB2YWx1ZSAhPT0gMCkpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLnEgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGBcIiR7cXVvdGVkW3ZhbHVlXX1cImA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW3RhcmdldF1ba3ZbMF1dID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhzZWxlY3Rpb24ucGFyYW1zKTtcbiAgICAgICAgc2VsZWN0aW9uLm9yaWdpbmFsID0gWycnXS5jb25jYXQocGFyYW1zLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7c2VsZWN0aW9uLnBhcmFtc1trZXldfWApKS5qb2luKCc7Jyk7XG4gICAgICAgIHNlbGVjdGlvbi5zcGVjaWZpY2l0eSA9IHBhcmFtcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5xID09PSB1bmRlZmluZWQpIHsgICAgIC8vIERlZmF1bHQgbm8gcHJlZmVyZW5jZSB0byBxPTEgKHRvcCBwcmVmZXJlbmNlKVxuICAgICAgICAgICAgc2VsZWN0aW9uLnEgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHBhcnRzID0gc2VsZWN0aW9uLnRva2VuLnNwbGl0KCcvJyk7XG4gICAgICAgIHNlbGVjdGlvbi50eXBlID0gdHBhcnRzWzBdO1xuICAgICAgICBzZWxlY3Rpb24uc3VidHlwZSA9IHRwYXJ0c1sxXTtcblxuICAgICAgICBtYXBbc2VsZWN0aW9uLnRva2VuXSA9IHNlbGVjdGlvbjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uLnEpIHsgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBkZW5pZWQgc2VsZWN0aW9ucyAocT0wKVxuICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3J0IHNlbGVjdGlvbiBiYXNlZCBvbiBxIGFuZCB0aGVuIHBvc2l0aW9uIGluIGhlYWRlclxuXG4gICAgc2VsZWN0aW9ucy5zb3J0KGludGVybmFscy5zb3J0KTtcblxuICAgIHJldHVybiBpbnRlcm5hbHMucHJlZmVyZW5jZXMobWFwLCBzZWxlY3Rpb25zLCBwcmVmZXJlbmNlcyk7XG59O1xuXG5cbmludGVybmFscy5ub3JtYWxpemUgPSBmdW5jdGlvbiAocmF3KSB7XG5cbiAgICByYXcgPSByYXcgfHwgJyovKic7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgICBoZWFkZXI6IHJhdyxcbiAgICAgICAgcXVvdGVkOiB7fVxuICAgIH07XG5cbiAgICBpZiAocmF3LmluY2x1ZGVzKCdcIicpKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbm9ybWFsaXplZC5oZWFkZXIgPSByYXcucmVwbGFjZSgvPVwiKFteXCJdKilcIi9nLCAoJDAsICQxKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9ICdcIicgKyArK2k7XG4gICAgICAgICAgICBub3JtYWxpemVkLnF1b3RlZFtrZXldID0gJDE7XG4gICAgICAgICAgICByZXR1cm4gJz0nICsga2V5O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBub3JtYWxpemVkLmhlYWRlciA9IG5vcm1hbGl6ZWQuaGVhZGVyLnJlcGxhY2UoL1sgXFx0XS9nLCAnJyk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG5cbmludGVybmFscy5zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIC8vIFNvcnQgYnkgcXVhbGl0eSBzY29yZVxuXG4gICAgaWYgKGIucSAhPT0gYS5xKSB7XG4gICAgICAgIHJldHVybiBiLnEgLSBhLnE7XG4gICAgfVxuXG4gICAgLy8gU29ydCBieSB0eXBlXG5cbiAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5pbm5lclNvcnQoYSwgYiwgJ3R5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBTb3J0IGJ5IHN1YnR5cGVcblxuICAgIGlmIChhLnN1YnR5cGUgIT09IGIuc3VidHlwZSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmlubmVyU29ydChhLCBiLCAnc3VidHlwZScpO1xuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgc3BlY2lmaWNpdHlcblxuICAgIGlmIChhLnNwZWNpZmljaXR5ICE9PSBiLnNwZWNpZmljaXR5KSB7XG4gICAgICAgIHJldHVybiBiLnNwZWNpZmljaXR5IC0gYS5zcGVjaWZpY2l0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gYS5wb3MgLSBiLnBvcztcbn07XG5cblxuaW50ZXJuYWxzLmlubmVyU29ydCA9IGZ1bmN0aW9uIChhLCBiLCBrZXkpIHtcblxuICAgIGNvbnN0IGFGaXJzdCA9IC0xO1xuICAgIGNvbnN0IGJGaXJzdCA9IDE7XG5cbiAgICBpZiAoYVtrZXldID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIGJGaXJzdDtcbiAgICB9XG5cbiAgICBpZiAoYltrZXldID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIGFGaXJzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYVtrZXldIDwgYltrZXldID8gYUZpcnN0IDogYkZpcnN0OyAgICAgICAvLyBHcm91cCBhbHBoYWJldGljYWxseVxufTtcblxuXG5pbnRlcm5hbHMucHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAobWFwLCBzZWxlY3Rpb25zLCBwcmVmZXJlbmNlcykge1xuXG4gICAgLy8gUmV0dXJuIHNlbGVjdGlvbnMgaWYgbm8gcHJlZmVyZW5jZXNcblxuICAgIGlmICghcHJlZmVyZW5jZXMgfHxcbiAgICAgICAgIXByZWZlcmVuY2VzLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25zLm1hcCgoc2VsZWN0aW9uKSA9PiBzZWxlY3Rpb24udG9rZW4gKyBzZWxlY3Rpb24ub3JpZ2luYWwpO1xuICAgIH1cblxuICAgIC8vIE1hcCB3aWxkY2FyZHMgYW5kIGZpbHRlciBzZWxlY3Rpb25zIHRvIHByZWZlcmVuY2VzXG5cbiAgICBjb25zdCBsb3dlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGZsYXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBhbnkgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgcHJlZmVyZW5jZSBvZiBwcmVmZXJlbmNlcykge1xuICAgICAgICBjb25zdCBsb3dlciA9IHByZWZlcmVuY2UudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgZmxhdFtsb3dlcl0gPSBwcmVmZXJlbmNlO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGxvd2VyLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJ0c1swXTtcbiAgICAgICAgY29uc3Qgc3VidHlwZSA9IHBhcnRzWzFdO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnKicpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHN1YnR5cGUgPT09ICcqJywgJ0ludmFsaWQgbWVkaWEgdHlwZSBwcmVmZXJlbmNlIGNvbnRhaW5zIHdpbGRjYXJkIHR5cGUgd2l0aCBhIHN1YnR5cGUnKTtcbiAgICAgICAgICAgIGFueSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvd2Vyc1t0eXBlXSA9IGxvd2Vyc1t0eXBlXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsb3dlcnNbdHlwZV1bc3VidHlwZV0gPSBwcmVmZXJlbmNlO1xuICAgIH1cblxuICAgIGNvbnN0IHByZWZlcnJlZCA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBzZWxlY3Rpb24udG9rZW47XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgc3VidHlwZSB9ID0gbWFwW3Rva2VuXTtcbiAgICAgICAgY29uc3Qgc3VidHlwZXMgPSBsb3dlcnNbdHlwZV07XG5cbiAgICAgICAgLy8gKi8qXG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICcqJykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcmVmZXJlbmNlIG9mIE9iamVjdC5rZXlzKGZsYXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXBbcHJlZmVyZW5jZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkLnB1c2goZmxhdFtwcmVmZXJlbmNlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW55KSB7XG4gICAgICAgICAgICAgICAgcHJlZmVycmVkLnB1c2goJyovKicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFueVxuXG4gICAgICAgIGlmIChhbnkpIHtcbiAgICAgICAgICAgIHByZWZlcnJlZC5wdXNoKChmbGF0W3Rva2VuXSB8fCB0b2tlbikgKyBzZWxlY3Rpb24ub3JpZ2luYWwpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0eXBlL3N1YnR5cGVcblxuICAgICAgICBpZiAoc3VidHlwZSAhPT0gJyonKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmID0gZmxhdFt0b2tlbl07XG4gICAgICAgICAgICBpZiAocHJlZiB8fFxuICAgICAgICAgICAgICAgIChzdWJ0eXBlcyAmJiBzdWJ0eXBlc1snKiddKSkge1xuXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkLnB1c2goKHByZWYgfHwgdG9rZW4pICsgc2VsZWN0aW9uLm9yaWdpbmFsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0eXBlLypcblxuICAgICAgICBpZiAoc3VidHlwZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHN1YiBvZiBPYmplY3Qua2V5cyhzdWJ0eXBlcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcFtgJHt0eXBlfS8ke3BzdWJ9YF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZmVycmVkLnB1c2goc3VidHlwZXNbcHN1Yl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcmVmZXJyZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWluRG9tYWluU2VnbWVudHM6IDIsXG4gICAgbm9uQXNjaWlSeDogL1teXFx4MDAtXFx4N2ZdLyxcbiAgICBkb21haW5Db250cm9sUng6IC9bXFx4MDAtXFx4MjBdLywgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyb2wgKyBzcGFjZVxuICAgIHRsZFNlZ21lbnRSeDogL15bYS16QS1aXSg/OlthLXpBLVowLTlcXC1dKlthLXpBLVowLTldKT8kLyxcbiAgICBkb21haW5TZWdtZW50Ung6IC9eW2EtekEtWjAtOV0oPzpbYS16QS1aMC05XFwtXSpbYS16QS1aMC05XSk/JC8sXG4gICAgVVJMOiBVcmwuVVJMIHx8IFVSTCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG59O1xuXG5cbmV4cG9ydHMuYW5hbHl6ZSA9IGZ1bmN0aW9uIChkb21haW4sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKHR5cGVvZiBkb21haW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dDogZG9tYWluIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogJ0RvbWFpbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycgfTtcbiAgICB9XG5cbiAgICBpZiAoZG9tYWluLmxlbmd0aCA+IDI1Nikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogJ0RvbWFpbiB0b28gbG9uZycgfTtcbiAgICB9XG5cbiAgICBjb25zdCBhc2NpaSA9ICFpbnRlcm5hbHMubm9uQXNjaWlSeC50ZXN0KGRvbWFpbik7XG4gICAgaWYgKCFhc2NpaSkge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1VuaWNvZGUgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnRG9tYWluIGNvbnRhaW5zIGZvcmJpZGRlbiBVbmljb2RlIGNoYXJhY3RlcnMnIH07XG4gICAgICAgIH1cblxuICAgICAgICBkb21haW4gPSBkb21haW4ubm9ybWFsaXplKCdORkMnKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxzLmRvbWFpbkNvbnRyb2xSeC50ZXN0KGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdEb21haW4gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXInIH07XG4gICAgfVxuXG4gICAgZG9tYWluID0gaW50ZXJuYWxzLnB1bnljb2RlKGRvbWFpbik7XG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMTAzNSBzZWN0aW9uIDIuMy4xXG5cbiAgICBjb25zdCBtaW5Eb21haW5TZWdtZW50cyA9IG9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgfHwgaW50ZXJuYWxzLm1pbkRvbWFpblNlZ21lbnRzO1xuXG4gICAgY29uc3Qgc2VnbWVudHMgPSBkb21haW4uc3BsaXQoJy4nKTtcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoIDwgbWluRG9tYWluU2VnbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdEb21haW4gbGFja3MgdGhlIG1pbmltdW0gcmVxdWlyZWQgbnVtYmVyIG9mIHNlZ21lbnRzJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHRsZHMgPSBvcHRpb25zLnRsZHM7XG4gICAgaWYgKHRsZHMpIHtcbiAgICAgICAgY29uc3QgdGxkID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRsZHMuZGVueSAmJiB0bGRzLmRlbnkuaGFzKHRsZCkgfHxcbiAgICAgICAgICAgIHRsZHMuYWxsb3cgJiYgIXRsZHMuYWxsb3cuaGFzKHRsZCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdEb21haW4gdXNlcyBmb3JiaWRkZW4gVExEJyB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cbiAgICAgICAgaWYgKCFzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdEb21haW4gY29udGFpbnMgZW1wdHkgZG90LXNlcGFyYXRlZCBzZWdtZW50JyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNjMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnRG9tYWluIGNvbnRhaW5zIGRvdC1zZXBhcmF0ZWQgc2VnbWVudCB0aGF0IGlzIHRvbyBsb25nJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPCBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5kb21haW5TZWdtZW50UngudGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnRG9tYWluIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMudGxkU2VnbWVudFJ4LnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ0RvbWFpbiBjb250YWlucyBpbnZhbGlkIHRsZCBjaGFyYWN0ZXInIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIChkb21haW4sIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiAhZXhwb3J0cy5hbmFseXplKGRvbWFpbiwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5wdW55Y29kZSA9IGZ1bmN0aW9uIChkb21haW4pIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlVSTChgaHR0cDovLyR7ZG9tYWlufWApLmhvc3Q7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBEb21haW4gPSByZXF1aXJlKCcuL2RvbWFpbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBub25Bc2NpaVJ4OiAvW15cXHgwMC1cXHg3Zl0vLFxuICAgIGVuY29kZXI6IG5ldyAoVXRpbC5UZXh0RW5jb2RlciB8fCBUZXh0RW5jb2RlcikoKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG59O1xuXG5cbmV4cG9ydHMuYW5hbHl6ZSA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5lbWFpbChlbWFpbCwgb3B0aW9ucyk7XG59O1xuXG5cbmV4cG9ydHMuaXNWYWxpZCA9IGZ1bmN0aW9uIChlbWFpbCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuICFpbnRlcm5hbHMuZW1haWwoZW1haWwsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuZW1haWwgPSBmdW5jdGlvbiAoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0OiBlbWFpbCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKCFlbWFpbCkge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogJ0FkZHJlc3MgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnIH07XG4gICAgfVxuXG4gICAgLy8gVW5pY29kZVxuXG4gICAgY29uc3QgYXNjaWkgPSAhaW50ZXJuYWxzLm5vbkFzY2lpUngudGVzdChlbWFpbCk7XG4gICAgaWYgKCFhc2NpaSkge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1VuaWNvZGUgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdBZGRyZXNzIGNvbnRhaW5zIGZvcmJpZGRlbiBVbmljb2RlIGNoYXJhY3RlcnMnIH07XG4gICAgICAgIH1cblxuICAgICAgICBlbWFpbCA9IGVtYWlsLm5vcm1hbGl6ZSgnTkZDJyk7XG4gICAgfVxuXG4gICAgLy8gQmFzaWMgc3RydWN0dXJlXG5cbiAgICBjb25zdCBwYXJ0cyA9IGVtYWlsLnNwbGl0KCdAJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4geyBlcnJvcjogcGFydHMubGVuZ3RoID4gMiA/ICdBZGRyZXNzIGNhbm5vdCBjb250YWluIG1vcmUgdGhhbiBvbmUgQCBjaGFyYWN0ZXInIDogJ0FkZHJlc3MgbXVzdCBjb250YWluIG9uZSBAIGNoYXJhY3RlcicgfTtcbiAgICB9XG5cbiAgICBjb25zdCBbbG9jYWwsIGRvbWFpbl0gPSBwYXJ0cztcblxuICAgIGlmICghbG9jYWwpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdBZGRyZXNzIGxvY2FsIHBhcnQgY2Fubm90IGJlIGVtcHR5JyB9O1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5pZ25vcmVMZW5ndGgpIHtcbiAgICAgICAgaWYgKGVtYWlsLmxlbmd0aCA+IDI1NCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM1MzIxI3NlY3Rpb24tNC41LjMuMS4zXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogJ0FkZHJlc3MgdG9vIGxvbmcnIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZXJuYWxzLmVuY29kZXIuZW5jb2RlKGxvY2FsKS5sZW5ndGggPiA2NCkgeyAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzUzMjEjc2VjdGlvbi00LjUuMy4xLjFcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IHRvbyBsb25nJyB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcGFydHNcblxuICAgIHJldHVybiBpbnRlcm5hbHMubG9jYWwobG9jYWwsIGFzY2lpKSB8fCBEb21haW4uYW5hbHl6ZShkb21haW4sIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMubG9jYWwgPSBmdW5jdGlvbiAobG9jYWwsIGFzY2lpKSB7XG5cbiAgICBjb25zdCBzZWdtZW50cyA9IGxvY2FsLnNwbGl0KCcuJyk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIGlmICghc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiAnQWRkcmVzcyBsb2NhbCBwYXJ0IGNvbnRhaW5zIGVtcHR5IGRvdC1zZXBhcmF0ZWQgc2VnbWVudCcgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhc2NpaSkge1xuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuYXRleHRSeC50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdBZGRyZXNzIGxvY2FsIHBhcnQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXInIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBjaGFyIG9mIHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuYXRleHRSeC50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGJpbmFyeSA9IGludGVybmFscy5iaW5hcnkoY2hhcik7XG4gICAgICAgICAgICBpZiAoIWludGVybmFscy5hdG9tUngudGVzdChiaW5hcnkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICdBZGRyZXNzIGxvY2FsIHBhcnQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXInIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5iaW5hcnkgPSBmdW5jdGlvbiAoY2hhcikge1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oaW50ZXJuYWxzLmVuY29kZXIuZW5jb2RlKGNoYXIpKS5tYXAoKHYpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUodikpLmpvaW4oJycpO1xufTtcblxuXG4vKlxuICAgIEZyb20gUkZDIDUzMjE6XG5cbiAgICAgICAgTWFpbGJveCAgICAgICAgID0gICBMb2NhbC1wYXJ0IFwiQFwiICggRG9tYWluIC8gYWRkcmVzcy1saXRlcmFsIClcblxuICAgICAgICBMb2NhbC1wYXJ0ICAgICAgPSAgIERvdC1zdHJpbmcgLyBRdW90ZWQtc3RyaW5nXG4gICAgICAgIERvdC1zdHJpbmcgICAgICA9ICAgQXRvbSAqKFwiLlwiICBBdG9tKVxuICAgICAgICBBdG9tICAgICAgICAgICAgPSAgIDEqYXRleHRcbiAgICAgICAgYXRleHQgICAgICAgICAgID0gICBBTFBIQSAvIERJR0lUIC8gXCIhXCIgLyBcIiNcIiAvIFwiJFwiIC8gXCIlXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIqXCIgLyBcIitcIiAvIFwiLVwiIC8gXCIvXCIgLyBcIj1cIiAvIFwiP1wiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ7XCIgLyBcInxcIiAvIFwifVwiIC8gXCJ+XCJcblxuICAgICAgICBEb21haW4gICAgICAgICAgPSAgIHN1Yi1kb21haW4gKihcIi5cIiBzdWItZG9tYWluKVxuICAgICAgICBzdWItZG9tYWluICAgICAgPSAgIExldC1kaWcgW0xkaC1zdHJdXG4gICAgICAgIExldC1kaWcgICAgICAgICA9ICAgQUxQSEEgLyBESUdJVFxuICAgICAgICBMZGgtc3RyICAgICAgICAgPSAgICooIEFMUEhBIC8gRElHSVQgLyBcIi1cIiApIExldC1kaWdcblxuICAgICAgICBBTFBIQSAgICAgICAgICAgPSAgICV4NDEtNUEgLyAleDYxLTdBICAgICAgICA7IGEteiwgQS1aXG4gICAgICAgIERJR0lUICAgICAgICAgICA9ICAgJXgzMC0zOSAgICAgICAgICAgICAgICAgIDsgMC05XG5cbiAgICBGcm9tIFJGQyA2NTMxOlxuXG4gICAgICAgIHN1Yi1kb21haW4gICAgICA9LyAgVS1sYWJlbFxuICAgICAgICBhdGV4dCAgICAgICAgICAgPS8gIFVURjgtbm9uLWFzY2lpXG5cbiAgICAgICAgVVRGOC1ub24tYXNjaWkgID0gICBVVEY4LTIgLyBVVEY4LTMgLyBVVEY4LTRcblxuICAgICAgICBVVEY4LTIgICAgICAgICAgPSAgICV4QzItREYgVVRGOC10YWlsXG4gICAgICAgIFVURjgtMyAgICAgICAgICA9ICAgJXhFMCAleEEwLUJGIFVURjgtdGFpbCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhFMS1FQyAyKCBVVEY4LXRhaWwgKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhFRCAleDgwLTlGIFVURjgtdGFpbCAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhFRS1FRiAyKCBVVEY4LXRhaWwgKVxuICAgICAgICBVVEY4LTQgICAgICAgICAgPSAgICV4RjAgJXg5MC1CRiAyKCBVVEY4LXRhaWwgKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhGMS1GMyAzKCBVVEY4LXRhaWwgKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJXhGNCAleDgwLThGIDIoIFVURjgtdGFpbCApXG5cbiAgICAgICAgVVRGOC10YWlsICAgICAgID0gICAleDgwLUJGXG5cbiAgICBOb3RlOiBUaGUgZm9sbG93aW5nIGFyZSBub3Qgc3VwcG9ydGVkOlxuXG4gICAgICAgIFJGQyA1MzIxOiBhZGRyZXNzLWxpdGVyYWwsIFF1b3RlZC1zdHJpbmdcbiAgICAgICAgUkZDIDUzMjI6IG9icy0qLCBDRldTXG4qL1xuXG5cbmludGVybmFscy5hdGV4dFJ4ID0gL15bXFx3ISNcXCQlJidcXCpcXCtcXC0vPVxcP1xcXmBcXHtcXHxcXH1+XSskLzsgICAgICAgICAgICAgICAvLyBfIGluY2x1ZGVkIGluIFxcd1xuXG5cbmludGVybmFscy5hdG9tUnggPSBuZXcgUmVnRXhwKFtcblxuICAgIC8vICAleEMyLURGIFVURjgtdGFpbFxuICAgICcoPzpbXFxcXHhjMi1cXFxceGRmXVtcXFxceDgwLVxcXFx4YmZdKScsXG5cbiAgICAvLyAgJXhFMCAleEEwLUJGIFVURjgtdGFpbCAgICAgICAgICAgICAgJXhFMS1FQyAyKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RUQgJXg4MC05RiBVVEY4LXRhaWwgICAgICAgICAgICAgICV4RUUtRUYgMiggVVRGOC10YWlsIClcbiAgICAnKD86XFxcXHhlMFtcXFxceGEwLVxcXFx4YmZdW1xcXFx4ODAtXFxcXHhiZl0pfCg/OltcXFxceGUxLVxcXFx4ZWNdW1xcXFx4ODAtXFxcXHhiZl17Mn0pfCg/OlxcXFx4ZWRbXFxcXHg4MC1cXFxceDlmXVtcXFxceDgwLVxcXFx4YmZdKXwoPzpbXFxcXHhlZS1cXFxceGVmXVtcXFxceDgwLVxcXFx4YmZdezJ9KScsXG5cbiAgICAvLyAgJXhGMCAleDkwLUJGIDIoIFVURjgtdGFpbCApICAgICAgICAgICAgJXhGMS1GMyAzKCBVVEY4LXRhaWwgKSAgICAgICAgICAgICV4RjQgJXg4MC04RiAyKCBVVEY4LXRhaWwgKVxuICAgICcoPzpcXFxceGYwW1xcXFx4OTAtXFxcXHhiZl1bXFxcXHg4MC1cXFxceGJmXXsyfSl8KD86W1xcXFx4ZjEtXFxcXHhmM11bXFxcXHg4MC1cXFxceGJmXXszfSl8KD86XFxcXHhmNFtcXFxceDgwLVxcXFx4OGZdW1xcXFx4ODAtXFxcXHhiZl17Mn0pJ1xuXG5dLmpvaW4oJ3wnKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IERvbWFpbiA9IHJlcXVpcmUoJy4vZG9tYWluJyk7XG5jb25zdCBFbWFpbCA9IHJlcXVpcmUoJy4vZW1haWwnKTtcbmNvbnN0IFRsZHMgPSByZXF1aXJlKCcuL3RsZHMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgZGVmYXVsdFRsZHM6IHsgYWxsb3c6IFRsZHMsIGRlbnk6IG51bGwgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBkb21haW46IHtcbiAgICAgICAgYW5hbHl6ZShkb21haW4sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IGludGVybmFscy5vcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIERvbWFpbi5hbmFseXplKGRvbWFpbiwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNWYWxpZChkb21haW4sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IGludGVybmFscy5vcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIERvbWFpbi5pc1ZhbGlkKGRvbWFpbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVtYWlsOiB7XG4gICAgICAgIGFuYWx5emUoZW1haWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IGludGVybmFscy5vcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIEVtYWlsLmFuYWx5emUoZW1haWwsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzVmFsaWQoZW1haWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IGludGVybmFscy5vcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIEVtYWlsLmlzVmFsaWQoZW1haWwsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMub3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGxkczogaW50ZXJuYWxzLmRlZmF1bHRUbGRzIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGxkcyA9PT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMudGxkcyB8fFxuICAgICAgICBvcHRpb25zLnRsZHMgPT09IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyB0bGRzOiBpbnRlcm5hbHMuZGVmYXVsdFRsZHMgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRsZHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcHRpb25zOiB0bGRzIG11c3QgYmUgYSBib29sZWFuIG9yIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMuZGVueSkge1xuICAgICAgICBpZiAob3B0aW9ucy50bGRzLmRlbnkgaW5zdGFuY2VvZiBTZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uczogdGxkcy5kZW55IG11c3QgYmUgYSBTZXQgb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy50bGRzLmFsbG93KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uczogY2Fubm90IHNwZWNpZnkgYm90aCB0bGRzLmFsbG93IGFuZCB0bGRzLmRlbnkgbGlzdHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMuYWxsb3cgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogaW50ZXJuYWxzLmRlZmF1bHRUbGRzIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnRsZHMuYWxsb3cgaW5zdGFuY2VvZiBTZXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcHRpb25zOiB0bGRzLmFsbG93IG11c3QgYmUgYSBTZXQgb2JqZWN0IG9yIHRydWUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbi8vIGh0dHA6Ly9kYXRhLmlhbmEub3JnL1RMRC90bGRzLWFscGhhLWJ5LWRvbWFpbi50eHRcbi8vICMgVmVyc2lvbiAyMDE5MDkxOTAyLCBMYXN0IFVwZGF0ZWQgRnJpIFNlcCAyMCAwNzogMDc6IDAyIDIwMTkgVVRDXG5cblxuaW50ZXJuYWxzLnRsZHMgPSBbXG4gICAgJ0FBQScsXG4gICAgJ0FBUlAnLFxuICAgICdBQkFSVEgnLFxuICAgICdBQkInLFxuICAgICdBQkJPVFQnLFxuICAgICdBQkJWSUUnLFxuICAgICdBQkMnLFxuICAgICdBQkxFJyxcbiAgICAnQUJPR0FETycsXG4gICAgJ0FCVURIQUJJJyxcbiAgICAnQUMnLFxuICAgICdBQ0FERU1ZJyxcbiAgICAnQUNDRU5UVVJFJyxcbiAgICAnQUNDT1VOVEFOVCcsXG4gICAgJ0FDQ09VTlRBTlRTJyxcbiAgICAnQUNPJyxcbiAgICAnQUNUT1InLFxuICAgICdBRCcsXG4gICAgJ0FEQUMnLFxuICAgICdBRFMnLFxuICAgICdBRFVMVCcsXG4gICAgJ0FFJyxcbiAgICAnQUVHJyxcbiAgICAnQUVSTycsXG4gICAgJ0FFVE5BJyxcbiAgICAnQUYnLFxuICAgICdBRkFNSUxZQ09NUEFOWScsXG4gICAgJ0FGTCcsXG4gICAgJ0FGUklDQScsXG4gICAgJ0FHJyxcbiAgICAnQUdBS0hBTicsXG4gICAgJ0FHRU5DWScsXG4gICAgJ0FJJyxcbiAgICAnQUlHJyxcbiAgICAnQUlHTycsXG4gICAgJ0FJUkJVUycsXG4gICAgJ0FJUkZPUkNFJyxcbiAgICAnQUlSVEVMJyxcbiAgICAnQUtETicsXG4gICAgJ0FMJyxcbiAgICAnQUxGQVJPTUVPJyxcbiAgICAnQUxJQkFCQScsXG4gICAgJ0FMSVBBWScsXG4gICAgJ0FMTEZJTkFOWicsXG4gICAgJ0FMTFNUQVRFJyxcbiAgICAnQUxMWScsXG4gICAgJ0FMU0FDRScsXG4gICAgJ0FMU1RPTScsXG4gICAgJ0FNJyxcbiAgICAnQU1FUklDQU5FWFBSRVNTJyxcbiAgICAnQU1FUklDQU5GQU1JTFknLFxuICAgICdBTUVYJyxcbiAgICAnQU1GQU0nLFxuICAgICdBTUlDQScsXG4gICAgJ0FNU1RFUkRBTScsXG4gICAgJ0FOQUxZVElDUycsXG4gICAgJ0FORFJPSUQnLFxuICAgICdBTlFVQU4nLFxuICAgICdBTlonLFxuICAgICdBTycsXG4gICAgJ0FPTCcsXG4gICAgJ0FQQVJUTUVOVFMnLFxuICAgICdBUFAnLFxuICAgICdBUFBMRScsXG4gICAgJ0FRJyxcbiAgICAnQVFVQVJFTExFJyxcbiAgICAnQVInLFxuICAgICdBUkFCJyxcbiAgICAnQVJBTUNPJyxcbiAgICAnQVJDSEknLFxuICAgICdBUk1ZJyxcbiAgICAnQVJQQScsXG4gICAgJ0FSVCcsXG4gICAgJ0FSVEUnLFxuICAgICdBUycsXG4gICAgJ0FTREEnLFxuICAgICdBU0lBJyxcbiAgICAnQVNTT0NJQVRFUycsXG4gICAgJ0FUJyxcbiAgICAnQVRITEVUQScsXG4gICAgJ0FUVE9STkVZJyxcbiAgICAnQVUnLFxuICAgICdBVUNUSU9OJyxcbiAgICAnQVVESScsXG4gICAgJ0FVRElCTEUnLFxuICAgICdBVURJTycsXG4gICAgJ0FVU1BPU1QnLFxuICAgICdBVVRIT1InLFxuICAgICdBVVRPJyxcbiAgICAnQVVUT1MnLFxuICAgICdBVklBTkNBJyxcbiAgICAnQVcnLFxuICAgICdBV1MnLFxuICAgICdBWCcsXG4gICAgJ0FYQScsXG4gICAgJ0FaJyxcbiAgICAnQVpVUkUnLFxuICAgICdCQScsXG4gICAgJ0JBQlknLFxuICAgICdCQUlEVScsXG4gICAgJ0JBTkFNRVgnLFxuICAgICdCQU5BTkFSRVBVQkxJQycsXG4gICAgJ0JBTkQnLFxuICAgICdCQU5LJyxcbiAgICAnQkFSJyxcbiAgICAnQkFSQ0VMT05BJyxcbiAgICAnQkFSQ0xBWUNBUkQnLFxuICAgICdCQVJDTEFZUycsXG4gICAgJ0JBUkVGT09UJyxcbiAgICAnQkFSR0FJTlMnLFxuICAgICdCQVNFQkFMTCcsXG4gICAgJ0JBU0tFVEJBTEwnLFxuICAgICdCQVVIQVVTJyxcbiAgICAnQkFZRVJOJyxcbiAgICAnQkInLFxuICAgICdCQkMnLFxuICAgICdCQlQnLFxuICAgICdCQlZBJyxcbiAgICAnQkNHJyxcbiAgICAnQkNOJyxcbiAgICAnQkQnLFxuICAgICdCRScsXG4gICAgJ0JFQVRTJyxcbiAgICAnQkVBVVRZJyxcbiAgICAnQkVFUicsXG4gICAgJ0JFTlRMRVknLFxuICAgICdCRVJMSU4nLFxuICAgICdCRVNUJyxcbiAgICAnQkVTVEJVWScsXG4gICAgJ0JFVCcsXG4gICAgJ0JGJyxcbiAgICAnQkcnLFxuICAgICdCSCcsXG4gICAgJ0JIQVJUSScsXG4gICAgJ0JJJyxcbiAgICAnQklCTEUnLFxuICAgICdCSUQnLFxuICAgICdCSUtFJyxcbiAgICAnQklORycsXG4gICAgJ0JJTkdPJyxcbiAgICAnQklPJyxcbiAgICAnQklaJyxcbiAgICAnQkonLFxuICAgICdCTEFDSycsXG4gICAgJ0JMQUNLRlJJREFZJyxcbiAgICAnQkxPQ0tCVVNURVInLFxuICAgICdCTE9HJyxcbiAgICAnQkxPT01CRVJHJyxcbiAgICAnQkxVRScsXG4gICAgJ0JNJyxcbiAgICAnQk1TJyxcbiAgICAnQk1XJyxcbiAgICAnQk4nLFxuICAgICdCTlBQQVJJQkFTJyxcbiAgICAnQk8nLFxuICAgICdCT0FUUycsXG4gICAgJ0JPRUhSSU5HRVInLFxuICAgICdCT0ZBJyxcbiAgICAnQk9NJyxcbiAgICAnQk9ORCcsXG4gICAgJ0JPTycsXG4gICAgJ0JPT0snLFxuICAgICdCT09LSU5HJyxcbiAgICAnQk9TQ0gnLFxuICAgICdCT1NUSUsnLFxuICAgICdCT1NUT04nLFxuICAgICdCT1QnLFxuICAgICdCT1VUSVFVRScsXG4gICAgJ0JPWCcsXG4gICAgJ0JSJyxcbiAgICAnQlJBREVTQ08nLFxuICAgICdCUklER0VTVE9ORScsXG4gICAgJ0JST0FEV0FZJyxcbiAgICAnQlJPS0VSJyxcbiAgICAnQlJPVEhFUicsXG4gICAgJ0JSVVNTRUxTJyxcbiAgICAnQlMnLFxuICAgICdCVCcsXG4gICAgJ0JVREFQRVNUJyxcbiAgICAnQlVHQVRUSScsXG4gICAgJ0JVSUxEJyxcbiAgICAnQlVJTERFUlMnLFxuICAgICdCVVNJTkVTUycsXG4gICAgJ0JVWScsXG4gICAgJ0JVWlonLFxuICAgICdCVicsXG4gICAgJ0JXJyxcbiAgICAnQlknLFxuICAgICdCWicsXG4gICAgJ0JaSCcsXG4gICAgJ0NBJyxcbiAgICAnQ0FCJyxcbiAgICAnQ0FGRScsXG4gICAgJ0NBTCcsXG4gICAgJ0NBTEwnLFxuICAgICdDQUxWSU5LTEVJTicsXG4gICAgJ0NBTScsXG4gICAgJ0NBTUVSQScsXG4gICAgJ0NBTVAnLFxuICAgICdDQU5DRVJSRVNFQVJDSCcsXG4gICAgJ0NBTk9OJyxcbiAgICAnQ0FQRVRPV04nLFxuICAgICdDQVBJVEFMJyxcbiAgICAnQ0FQSVRBTE9ORScsXG4gICAgJ0NBUicsXG4gICAgJ0NBUkFWQU4nLFxuICAgICdDQVJEUycsXG4gICAgJ0NBUkUnLFxuICAgICdDQVJFRVInLFxuICAgICdDQVJFRVJTJyxcbiAgICAnQ0FSUycsXG4gICAgJ0NBUlRJRVInLFxuICAgICdDQVNBJyxcbiAgICAnQ0FTRScsXG4gICAgJ0NBU0VJSCcsXG4gICAgJ0NBU0gnLFxuICAgICdDQVNJTk8nLFxuICAgICdDQVQnLFxuICAgICdDQVRFUklORycsXG4gICAgJ0NBVEhPTElDJyxcbiAgICAnQ0JBJyxcbiAgICAnQ0JOJyxcbiAgICAnQ0JSRScsXG4gICAgJ0NCUycsXG4gICAgJ0NDJyxcbiAgICAnQ0QnLFxuICAgICdDRUInLFxuICAgICdDRU5URVInLFxuICAgICdDRU8nLFxuICAgICdDRVJOJyxcbiAgICAnQ0YnLFxuICAgICdDRkEnLFxuICAgICdDRkQnLFxuICAgICdDRycsXG4gICAgJ0NIJyxcbiAgICAnQ0hBTkVMJyxcbiAgICAnQ0hBTk5FTCcsXG4gICAgJ0NIQVJJVFknLFxuICAgICdDSEFTRScsXG4gICAgJ0NIQVQnLFxuICAgICdDSEVBUCcsXG4gICAgJ0NISU5UQUknLFxuICAgICdDSFJJU1RNQVMnLFxuICAgICdDSFJPTUUnLFxuICAgICdDSFJZU0xFUicsXG4gICAgJ0NIVVJDSCcsXG4gICAgJ0NJJyxcbiAgICAnQ0lQUklBTkknLFxuICAgICdDSVJDTEUnLFxuICAgICdDSVNDTycsXG4gICAgJ0NJVEFERUwnLFxuICAgICdDSVRJJyxcbiAgICAnQ0lUSUMnLFxuICAgICdDSVRZJyxcbiAgICAnQ0lUWUVBVFMnLFxuICAgICdDSycsXG4gICAgJ0NMJyxcbiAgICAnQ0xBSU1TJyxcbiAgICAnQ0xFQU5JTkcnLFxuICAgICdDTElDSycsXG4gICAgJ0NMSU5JQycsXG4gICAgJ0NMSU5JUVVFJyxcbiAgICAnQ0xPVEhJTkcnLFxuICAgICdDTE9VRCcsXG4gICAgJ0NMVUInLFxuICAgICdDTFVCTUVEJyxcbiAgICAnQ00nLFxuICAgICdDTicsXG4gICAgJ0NPJyxcbiAgICAnQ09BQ0gnLFxuICAgICdDT0RFUycsXG4gICAgJ0NPRkZFRScsXG4gICAgJ0NPTExFR0UnLFxuICAgICdDT0xPR05FJyxcbiAgICAnQ09NJyxcbiAgICAnQ09NQ0FTVCcsXG4gICAgJ0NPTU1CQU5LJyxcbiAgICAnQ09NTVVOSVRZJyxcbiAgICAnQ09NUEFOWScsXG4gICAgJ0NPTVBBUkUnLFxuICAgICdDT01QVVRFUicsXG4gICAgJ0NPTVNFQycsXG4gICAgJ0NPTkRPUycsXG4gICAgJ0NPTlNUUlVDVElPTicsXG4gICAgJ0NPTlNVTFRJTkcnLFxuICAgICdDT05UQUNUJyxcbiAgICAnQ09OVFJBQ1RPUlMnLFxuICAgICdDT09LSU5HJyxcbiAgICAnQ09PS0lOR0NIQU5ORUwnLFxuICAgICdDT09MJyxcbiAgICAnQ09PUCcsXG4gICAgJ0NPUlNJQ0EnLFxuICAgICdDT1VOVFJZJyxcbiAgICAnQ09VUE9OJyxcbiAgICAnQ09VUE9OUycsXG4gICAgJ0NPVVJTRVMnLFxuICAgICdDUicsXG4gICAgJ0NSRURJVCcsXG4gICAgJ0NSRURJVENBUkQnLFxuICAgICdDUkVESVRVTklPTicsXG4gICAgJ0NSSUNLRVQnLFxuICAgICdDUk9XTicsXG4gICAgJ0NSUycsXG4gICAgJ0NSVUlTRScsXG4gICAgJ0NSVUlTRVMnLFxuICAgICdDU0MnLFxuICAgICdDVScsXG4gICAgJ0NVSVNJTkVMTEEnLFxuICAgICdDVicsXG4gICAgJ0NXJyxcbiAgICAnQ1gnLFxuICAgICdDWScsXG4gICAgJ0NZTVJVJyxcbiAgICAnQ1lPVScsXG4gICAgJ0NaJyxcbiAgICAnREFCVVInLFxuICAgICdEQUQnLFxuICAgICdEQU5DRScsXG4gICAgJ0RBVEEnLFxuICAgICdEQVRFJyxcbiAgICAnREFUSU5HJyxcbiAgICAnREFUU1VOJyxcbiAgICAnREFZJyxcbiAgICAnRENMSycsXG4gICAgJ0REUycsXG4gICAgJ0RFJyxcbiAgICAnREVBTCcsXG4gICAgJ0RFQUxFUicsXG4gICAgJ0RFQUxTJyxcbiAgICAnREVHUkVFJyxcbiAgICAnREVMSVZFUlknLFxuICAgICdERUxMJyxcbiAgICAnREVMT0lUVEUnLFxuICAgICdERUxUQScsXG4gICAgJ0RFTU9DUkFUJyxcbiAgICAnREVOVEFMJyxcbiAgICAnREVOVElTVCcsXG4gICAgJ0RFU0knLFxuICAgICdERVNJR04nLFxuICAgICdERVYnLFxuICAgICdESEwnLFxuICAgICdESUFNT05EUycsXG4gICAgJ0RJRVQnLFxuICAgICdESUdJVEFMJyxcbiAgICAnRElSRUNUJyxcbiAgICAnRElSRUNUT1JZJyxcbiAgICAnRElTQ09VTlQnLFxuICAgICdESVNDT1ZFUicsXG4gICAgJ0RJU0gnLFxuICAgICdESVknLFxuICAgICdESicsXG4gICAgJ0RLJyxcbiAgICAnRE0nLFxuICAgICdETlAnLFxuICAgICdETycsXG4gICAgJ0RPQ1MnLFxuICAgICdET0NUT1InLFxuICAgICdET0RHRScsXG4gICAgJ0RPRycsXG4gICAgJ0RPTUFJTlMnLFxuICAgICdET1QnLFxuICAgICdET1dOTE9BRCcsXG4gICAgJ0RSSVZFJyxcbiAgICAnRFRWJyxcbiAgICAnRFVCQUknLFxuICAgICdEVUNLJyxcbiAgICAnRFVOTE9QJyxcbiAgICAnRFVQT05UJyxcbiAgICAnRFVSQkFOJyxcbiAgICAnRFZBRycsXG4gICAgJ0RWUicsXG4gICAgJ0RaJyxcbiAgICAnRUFSVEgnLFxuICAgICdFQVQnLFxuICAgICdFQycsXG4gICAgJ0VDTycsXG4gICAgJ0VERUtBJyxcbiAgICAnRURVJyxcbiAgICAnRURVQ0FUSU9OJyxcbiAgICAnRUUnLFxuICAgICdFRycsXG4gICAgJ0VNQUlMJyxcbiAgICAnRU1FUkNLJyxcbiAgICAnRU5FUkdZJyxcbiAgICAnRU5HSU5FRVInLFxuICAgICdFTkdJTkVFUklORycsXG4gICAgJ0VOVEVSUFJJU0VTJyxcbiAgICAnRVBTT04nLFxuICAgICdFUVVJUE1FTlQnLFxuICAgICdFUicsXG4gICAgJ0VSSUNTU09OJyxcbiAgICAnRVJOSScsXG4gICAgJ0VTJyxcbiAgICAnRVNRJyxcbiAgICAnRVNUQVRFJyxcbiAgICAnRVNVUkFOQ0UnLFxuICAgICdFVCcsXG4gICAgJ0VUSVNBTEFUJyxcbiAgICAnRVUnLFxuICAgICdFVVJPVklTSU9OJyxcbiAgICAnRVVTJyxcbiAgICAnRVZFTlRTJyxcbiAgICAnRVZFUkJBTksnLFxuICAgICdFWENIQU5HRScsXG4gICAgJ0VYUEVSVCcsXG4gICAgJ0VYUE9TRUQnLFxuICAgICdFWFBSRVNTJyxcbiAgICAnRVhUUkFTUEFDRScsXG4gICAgJ0ZBR0UnLFxuICAgICdGQUlMJyxcbiAgICAnRkFJUldJTkRTJyxcbiAgICAnRkFJVEgnLFxuICAgICdGQU1JTFknLFxuICAgICdGQU4nLFxuICAgICdGQU5TJyxcbiAgICAnRkFSTScsXG4gICAgJ0ZBUk1FUlMnLFxuICAgICdGQVNISU9OJyxcbiAgICAnRkFTVCcsXG4gICAgJ0ZFREVYJyxcbiAgICAnRkVFREJBQ0snLFxuICAgICdGRVJSQVJJJyxcbiAgICAnRkVSUkVSTycsXG4gICAgJ0ZJJyxcbiAgICAnRklBVCcsXG4gICAgJ0ZJREVMSVRZJyxcbiAgICAnRklETycsXG4gICAgJ0ZJTE0nLFxuICAgICdGSU5BTCcsXG4gICAgJ0ZJTkFOQ0UnLFxuICAgICdGSU5BTkNJQUwnLFxuICAgICdGSVJFJyxcbiAgICAnRklSRVNUT05FJyxcbiAgICAnRklSTURBTEUnLFxuICAgICdGSVNIJyxcbiAgICAnRklTSElORycsXG4gICAgJ0ZJVCcsXG4gICAgJ0ZJVE5FU1MnLFxuICAgICdGSicsXG4gICAgJ0ZLJyxcbiAgICAnRkxJQ0tSJyxcbiAgICAnRkxJR0hUUycsXG4gICAgJ0ZMSVInLFxuICAgICdGTE9SSVNUJyxcbiAgICAnRkxPV0VSUycsXG4gICAgJ0ZMWScsXG4gICAgJ0ZNJyxcbiAgICAnRk8nLFxuICAgICdGT08nLFxuICAgICdGT09EJyxcbiAgICAnRk9PRE5FVFdPUksnLFxuICAgICdGT09UQkFMTCcsXG4gICAgJ0ZPUkQnLFxuICAgICdGT1JFWCcsXG4gICAgJ0ZPUlNBTEUnLFxuICAgICdGT1JVTScsXG4gICAgJ0ZPVU5EQVRJT04nLFxuICAgICdGT1gnLFxuICAgICdGUicsXG4gICAgJ0ZSRUUnLFxuICAgICdGUkVTRU5JVVMnLFxuICAgICdGUkwnLFxuICAgICdGUk9HQU5TJyxcbiAgICAnRlJPTlRET09SJyxcbiAgICAnRlJPTlRJRVInLFxuICAgICdGVFInLFxuICAgICdGVUpJVFNVJyxcbiAgICAnRlVKSVhFUk9YJyxcbiAgICAnRlVOJyxcbiAgICAnRlVORCcsXG4gICAgJ0ZVUk5JVFVSRScsXG4gICAgJ0ZVVEJPTCcsXG4gICAgJ0ZZSScsXG4gICAgJ0dBJyxcbiAgICAnR0FMJyxcbiAgICAnR0FMTEVSWScsXG4gICAgJ0dBTExPJyxcbiAgICAnR0FMTFVQJyxcbiAgICAnR0FNRScsXG4gICAgJ0dBTUVTJyxcbiAgICAnR0FQJyxcbiAgICAnR0FSREVOJyxcbiAgICAnR0FZJyxcbiAgICAnR0InLFxuICAgICdHQklaJyxcbiAgICAnR0QnLFxuICAgICdHRE4nLFxuICAgICdHRScsXG4gICAgJ0dFQScsXG4gICAgJ0dFTlQnLFxuICAgICdHRU5USU5HJyxcbiAgICAnR0VPUkdFJyxcbiAgICAnR0YnLFxuICAgICdHRycsXG4gICAgJ0dHRUUnLFxuICAgICdHSCcsXG4gICAgJ0dJJyxcbiAgICAnR0lGVCcsXG4gICAgJ0dJRlRTJyxcbiAgICAnR0lWRVMnLFxuICAgICdHSVZJTkcnLFxuICAgICdHTCcsXG4gICAgJ0dMQURFJyxcbiAgICAnR0xBU1MnLFxuICAgICdHTEUnLFxuICAgICdHTE9CQUwnLFxuICAgICdHTE9CTycsXG4gICAgJ0dNJyxcbiAgICAnR01BSUwnLFxuICAgICdHTUJIJyxcbiAgICAnR01PJyxcbiAgICAnR01YJyxcbiAgICAnR04nLFxuICAgICdHT0RBRERZJyxcbiAgICAnR09MRCcsXG4gICAgJ0dPTERQT0lOVCcsXG4gICAgJ0dPTEYnLFxuICAgICdHT08nLFxuICAgICdHT09EWUVBUicsXG4gICAgJ0dPT0cnLFxuICAgICdHT09HTEUnLFxuICAgICdHT1AnLFxuICAgICdHT1QnLFxuICAgICdHT1YnLFxuICAgICdHUCcsXG4gICAgJ0dRJyxcbiAgICAnR1InLFxuICAgICdHUkFJTkdFUicsXG4gICAgJ0dSQVBISUNTJyxcbiAgICAnR1JBVElTJyxcbiAgICAnR1JFRU4nLFxuICAgICdHUklQRScsXG4gICAgJ0dST0NFUlknLFxuICAgICdHUk9VUCcsXG4gICAgJ0dTJyxcbiAgICAnR1QnLFxuICAgICdHVScsXG4gICAgJ0dVQVJESUFOJyxcbiAgICAnR1VDQ0knLFxuICAgICdHVUdFJyxcbiAgICAnR1VJREUnLFxuICAgICdHVUlUQVJTJyxcbiAgICAnR1VSVScsXG4gICAgJ0dXJyxcbiAgICAnR1knLFxuICAgICdIQUlSJyxcbiAgICAnSEFNQlVSRycsXG4gICAgJ0hBTkdPVVQnLFxuICAgICdIQVVTJyxcbiAgICAnSEJPJyxcbiAgICAnSERGQycsXG4gICAgJ0hERkNCQU5LJyxcbiAgICAnSEVBTFRIJyxcbiAgICAnSEVBTFRIQ0FSRScsXG4gICAgJ0hFTFAnLFxuICAgICdIRUxTSU5LSScsXG4gICAgJ0hFUkUnLFxuICAgICdIRVJNRVMnLFxuICAgICdIR1RWJyxcbiAgICAnSElQSE9QJyxcbiAgICAnSElTQU1JVFNVJyxcbiAgICAnSElUQUNISScsXG4gICAgJ0hJVicsXG4gICAgJ0hLJyxcbiAgICAnSEtUJyxcbiAgICAnSE0nLFxuICAgICdITicsXG4gICAgJ0hPQ0tFWScsXG4gICAgJ0hPTERJTkdTJyxcbiAgICAnSE9MSURBWScsXG4gICAgJ0hPTUVERVBPVCcsXG4gICAgJ0hPTUVHT09EUycsXG4gICAgJ0hPTUVTJyxcbiAgICAnSE9NRVNFTlNFJyxcbiAgICAnSE9OREEnLFxuICAgICdIT1JTRScsXG4gICAgJ0hPU1BJVEFMJyxcbiAgICAnSE9TVCcsXG4gICAgJ0hPU1RJTkcnLFxuICAgICdIT1QnLFxuICAgICdIT1RFTEVTJyxcbiAgICAnSE9URUxTJyxcbiAgICAnSE9UTUFJTCcsXG4gICAgJ0hPVVNFJyxcbiAgICAnSE9XJyxcbiAgICAnSFInLFxuICAgICdIU0JDJyxcbiAgICAnSFQnLFxuICAgICdIVScsXG4gICAgJ0hVR0hFUycsXG4gICAgJ0hZQVRUJyxcbiAgICAnSFlVTkRBSScsXG4gICAgJ0lCTScsXG4gICAgJ0lDQkMnLFxuICAgICdJQ0UnLFxuICAgICdJQ1UnLFxuICAgICdJRCcsXG4gICAgJ0lFJyxcbiAgICAnSUVFRScsXG4gICAgJ0lGTScsXG4gICAgJ0lLQU5PJyxcbiAgICAnSUwnLFxuICAgICdJTScsXG4gICAgJ0lNQU1BVCcsXG4gICAgJ0lNREInLFxuICAgICdJTU1PJyxcbiAgICAnSU1NT0JJTElFTicsXG4gICAgJ0lOJyxcbiAgICAnSU5DJyxcbiAgICAnSU5EVVNUUklFUycsXG4gICAgJ0lORklOSVRJJyxcbiAgICAnSU5GTycsXG4gICAgJ0lORycsXG4gICAgJ0lOSycsXG4gICAgJ0lOU1RJVFVURScsXG4gICAgJ0lOU1VSQU5DRScsXG4gICAgJ0lOU1VSRScsXG4gICAgJ0lOVCcsXG4gICAgJ0lOVEVMJyxcbiAgICAnSU5URVJOQVRJT05BTCcsXG4gICAgJ0lOVFVJVCcsXG4gICAgJ0lOVkVTVE1FTlRTJyxcbiAgICAnSU8nLFxuICAgICdJUElSQU5HQScsXG4gICAgJ0lRJyxcbiAgICAnSVInLFxuICAgICdJUklTSCcsXG4gICAgJ0lTJyxcbiAgICAnSVNNQUlMSScsXG4gICAgJ0lTVCcsXG4gICAgJ0lTVEFOQlVMJyxcbiAgICAnSVQnLFxuICAgICdJVEFVJyxcbiAgICAnSVRWJyxcbiAgICAnSVZFQ08nLFxuICAgICdKQUdVQVInLFxuICAgICdKQVZBJyxcbiAgICAnSkNCJyxcbiAgICAnSkNQJyxcbiAgICAnSkUnLFxuICAgICdKRUVQJyxcbiAgICAnSkVUWlQnLFxuICAgICdKRVdFTFJZJyxcbiAgICAnSklPJyxcbiAgICAnSkxMJyxcbiAgICAnSk0nLFxuICAgICdKTVAnLFxuICAgICdKTkonLFxuICAgICdKTycsXG4gICAgJ0pPQlMnLFxuICAgICdKT0JVUkcnLFxuICAgICdKT1QnLFxuICAgICdKT1knLFxuICAgICdKUCcsXG4gICAgJ0pQTU9SR0FOJyxcbiAgICAnSlBSUycsXG4gICAgJ0pVRUdPUycsXG4gICAgJ0pVTklQRVInLFxuICAgICdLQVVGRU4nLFxuICAgICdLRERJJyxcbiAgICAnS0UnLFxuICAgICdLRVJSWUhPVEVMUycsXG4gICAgJ0tFUlJZTE9HSVNUSUNTJyxcbiAgICAnS0VSUllQUk9QRVJUSUVTJyxcbiAgICAnS0ZIJyxcbiAgICAnS0cnLFxuICAgICdLSCcsXG4gICAgJ0tJJyxcbiAgICAnS0lBJyxcbiAgICAnS0lNJyxcbiAgICAnS0lOREVSJyxcbiAgICAnS0lORExFJyxcbiAgICAnS0lUQ0hFTicsXG4gICAgJ0tJV0knLFxuICAgICdLTScsXG4gICAgJ0tOJyxcbiAgICAnS09FTE4nLFxuICAgICdLT01BVFNVJyxcbiAgICAnS09TSEVSJyxcbiAgICAnS1AnLFxuICAgICdLUE1HJyxcbiAgICAnS1BOJyxcbiAgICAnS1InLFxuICAgICdLUkQnLFxuICAgICdLUkVEJyxcbiAgICAnS1VPS0dST1VQJyxcbiAgICAnS1cnLFxuICAgICdLWScsXG4gICAgJ0tZT1RPJyxcbiAgICAnS1onLFxuICAgICdMQScsXG4gICAgJ0xBQ0FJWEEnLFxuICAgICdMQURCUk9LRVMnLFxuICAgICdMQU1CT1JHSElOSScsXG4gICAgJ0xBTUVSJyxcbiAgICAnTEFOQ0FTVEVSJyxcbiAgICAnTEFOQ0lBJyxcbiAgICAnTEFOQ09NRScsXG4gICAgJ0xBTkQnLFxuICAgICdMQU5EUk9WRVInLFxuICAgICdMQU5YRVNTJyxcbiAgICAnTEFTQUxMRScsXG4gICAgJ0xBVCcsXG4gICAgJ0xBVElOTycsXG4gICAgJ0xBVFJPQkUnLFxuICAgICdMQVcnLFxuICAgICdMQVdZRVInLFxuICAgICdMQicsXG4gICAgJ0xDJyxcbiAgICAnTERTJyxcbiAgICAnTEVBU0UnLFxuICAgICdMRUNMRVJDJyxcbiAgICAnTEVGUkFLJyxcbiAgICAnTEVHQUwnLFxuICAgICdMRUdPJyxcbiAgICAnTEVYVVMnLFxuICAgICdMR0JUJyxcbiAgICAnTEknLFxuICAgICdMSUFJU09OJyxcbiAgICAnTElETCcsXG4gICAgJ0xJRkUnLFxuICAgICdMSUZFSU5TVVJBTkNFJyxcbiAgICAnTElGRVNUWUxFJyxcbiAgICAnTElHSFRJTkcnLFxuICAgICdMSUtFJyxcbiAgICAnTElMTFknLFxuICAgICdMSU1JVEVEJyxcbiAgICAnTElNTycsXG4gICAgJ0xJTkNPTE4nLFxuICAgICdMSU5ERScsXG4gICAgJ0xJTksnLFxuICAgICdMSVBTWScsXG4gICAgJ0xJVkUnLFxuICAgICdMSVZJTkcnLFxuICAgICdMSVhJTCcsXG4gICAgJ0xLJyxcbiAgICAnTExDJyxcbiAgICAnTE9BTicsXG4gICAgJ0xPQU5TJyxcbiAgICAnTE9DS0VSJyxcbiAgICAnTE9DVVMnLFxuICAgICdMT0ZUJyxcbiAgICAnTE9MJyxcbiAgICAnTE9ORE9OJyxcbiAgICAnTE9UVEUnLFxuICAgICdMT1RUTycsXG4gICAgJ0xPVkUnLFxuICAgICdMUEwnLFxuICAgICdMUExGSU5BTkNJQUwnLFxuICAgICdMUicsXG4gICAgJ0xTJyxcbiAgICAnTFQnLFxuICAgICdMVEQnLFxuICAgICdMVERBJyxcbiAgICAnTFUnLFxuICAgICdMVU5EQkVDSycsXG4gICAgJ0xVUElOJyxcbiAgICAnTFVYRScsXG4gICAgJ0xVWFVSWScsXG4gICAgJ0xWJyxcbiAgICAnTFknLFxuICAgICdNQScsXG4gICAgJ01BQ1lTJyxcbiAgICAnTUFEUklEJyxcbiAgICAnTUFJRicsXG4gICAgJ01BSVNPTicsXG4gICAgJ01BS0VVUCcsXG4gICAgJ01BTicsXG4gICAgJ01BTkFHRU1FTlQnLFxuICAgICdNQU5HTycsXG4gICAgJ01BUCcsXG4gICAgJ01BUktFVCcsXG4gICAgJ01BUktFVElORycsXG4gICAgJ01BUktFVFMnLFxuICAgICdNQVJSSU9UVCcsXG4gICAgJ01BUlNIQUxMUycsXG4gICAgJ01BU0VSQVRJJyxcbiAgICAnTUFUVEVMJyxcbiAgICAnTUJBJyxcbiAgICAnTUMnLFxuICAgICdNQ0tJTlNFWScsXG4gICAgJ01EJyxcbiAgICAnTUUnLFxuICAgICdNRUQnLFxuICAgICdNRURJQScsXG4gICAgJ01FRVQnLFxuICAgICdNRUxCT1VSTkUnLFxuICAgICdNRU1FJyxcbiAgICAnTUVNT1JJQUwnLFxuICAgICdNRU4nLFxuICAgICdNRU5VJyxcbiAgICAnTUVSQ0tNU0QnLFxuICAgICdNRVRMSUZFJyxcbiAgICAnTUcnLFxuICAgICdNSCcsXG4gICAgJ01JQU1JJyxcbiAgICAnTUlDUk9TT0ZUJyxcbiAgICAnTUlMJyxcbiAgICAnTUlOSScsXG4gICAgJ01JTlQnLFxuICAgICdNSVQnLFxuICAgICdNSVRTVUJJU0hJJyxcbiAgICAnTUsnLFxuICAgICdNTCcsXG4gICAgJ01MQicsXG4gICAgJ01MUycsXG4gICAgJ01NJyxcbiAgICAnTU1BJyxcbiAgICAnTU4nLFxuICAgICdNTycsXG4gICAgJ01PQkknLFxuICAgICdNT0JJTEUnLFxuICAgICdNT0RBJyxcbiAgICAnTU9FJyxcbiAgICAnTU9JJyxcbiAgICAnTU9NJyxcbiAgICAnTU9OQVNIJyxcbiAgICAnTU9ORVknLFxuICAgICdNT05TVEVSJyxcbiAgICAnTU9QQVInLFxuICAgICdNT1JNT04nLFxuICAgICdNT1JUR0FHRScsXG4gICAgJ01PU0NPVycsXG4gICAgJ01PVE8nLFxuICAgICdNT1RPUkNZQ0xFUycsXG4gICAgJ01PVicsXG4gICAgJ01PVklFJyxcbiAgICAnTU9WSVNUQVInLFxuICAgICdNUCcsXG4gICAgJ01RJyxcbiAgICAnTVInLFxuICAgICdNUycsXG4gICAgJ01TRCcsXG4gICAgJ01UJyxcbiAgICAnTVROJyxcbiAgICAnTVRSJyxcbiAgICAnTVUnLFxuICAgICdNVVNFVU0nLFxuICAgICdNVVRVQUwnLFxuICAgICdNVicsXG4gICAgJ01XJyxcbiAgICAnTVgnLFxuICAgICdNWScsXG4gICAgJ01aJyxcbiAgICAnTkEnLFxuICAgICdOQUInLFxuICAgICdOQURFWCcsXG4gICAgJ05BR09ZQScsXG4gICAgJ05BTUUnLFxuICAgICdOQVRJT05XSURFJyxcbiAgICAnTkFUVVJBJyxcbiAgICAnTkFWWScsXG4gICAgJ05CQScsXG4gICAgJ05DJyxcbiAgICAnTkUnLFxuICAgICdORUMnLFxuICAgICdORVQnLFxuICAgICdORVRCQU5LJyxcbiAgICAnTkVURkxJWCcsXG4gICAgJ05FVFdPUksnLFxuICAgICdORVVTVEFSJyxcbiAgICAnTkVXJyxcbiAgICAnTkVXSE9MTEFORCcsXG4gICAgJ05FV1MnLFxuICAgICdORVhUJyxcbiAgICAnTkVYVERJUkVDVCcsXG4gICAgJ05FWFVTJyxcbiAgICAnTkYnLFxuICAgICdORkwnLFxuICAgICdORycsXG4gICAgJ05HTycsXG4gICAgJ05ISycsXG4gICAgJ05JJyxcbiAgICAnTklDTycsXG4gICAgJ05JS0UnLFxuICAgICdOSUtPTicsXG4gICAgJ05JTkpBJyxcbiAgICAnTklTU0FOJyxcbiAgICAnTklTU0FZJyxcbiAgICAnTkwnLFxuICAgICdOTycsXG4gICAgJ05PS0lBJyxcbiAgICAnTk9SVEhXRVNURVJOTVVUVUFMJyxcbiAgICAnTk9SVE9OJyxcbiAgICAnTk9XJyxcbiAgICAnTk9XUlVaJyxcbiAgICAnTk9XVFYnLFxuICAgICdOUCcsXG4gICAgJ05SJyxcbiAgICAnTlJBJyxcbiAgICAnTlJXJyxcbiAgICAnTlRUJyxcbiAgICAnTlUnLFxuICAgICdOWUMnLFxuICAgICdOWicsXG4gICAgJ09CSScsXG4gICAgJ09CU0VSVkVSJyxcbiAgICAnT0ZGJyxcbiAgICAnT0ZGSUNFJyxcbiAgICAnT0tJTkFXQScsXG4gICAgJ09MQVlBTicsXG4gICAgJ09MQVlBTkdST1VQJyxcbiAgICAnT0xETkFWWScsXG4gICAgJ09MTE8nLFxuICAgICdPTScsXG4gICAgJ09NRUdBJyxcbiAgICAnT05FJyxcbiAgICAnT05HJyxcbiAgICAnT05MJyxcbiAgICAnT05MSU5FJyxcbiAgICAnT05ZT1VSU0lERScsXG4gICAgJ09PTycsXG4gICAgJ09QRU4nLFxuICAgICdPUkFDTEUnLFxuICAgICdPUkFOR0UnLFxuICAgICdPUkcnLFxuICAgICdPUkdBTklDJyxcbiAgICAnT1JJR0lOUycsXG4gICAgJ09TQUtBJyxcbiAgICAnT1RTVUtBJyxcbiAgICAnT1RUJyxcbiAgICAnT1ZIJyxcbiAgICAnUEEnLFxuICAgICdQQUdFJyxcbiAgICAnUEFOQVNPTklDJyxcbiAgICAnUEFSSVMnLFxuICAgICdQQVJTJyxcbiAgICAnUEFSVE5FUlMnLFxuICAgICdQQVJUUycsXG4gICAgJ1BBUlRZJyxcbiAgICAnUEFTU0FHRU5TJyxcbiAgICAnUEFZJyxcbiAgICAnUENDVycsXG4gICAgJ1BFJyxcbiAgICAnUEVUJyxcbiAgICAnUEYnLFxuICAgICdQRklaRVInLFxuICAgICdQRycsXG4gICAgJ1BIJyxcbiAgICAnUEhBUk1BQ1knLFxuICAgICdQSEQnLFxuICAgICdQSElMSVBTJyxcbiAgICAnUEhPTkUnLFxuICAgICdQSE9UTycsXG4gICAgJ1BIT1RPR1JBUEhZJyxcbiAgICAnUEhPVE9TJyxcbiAgICAnUEhZU0lPJyxcbiAgICAnUElBR0VUJyxcbiAgICAnUElDUycsXG4gICAgJ1BJQ1RFVCcsXG4gICAgJ1BJQ1RVUkVTJyxcbiAgICAnUElEJyxcbiAgICAnUElOJyxcbiAgICAnUElORycsXG4gICAgJ1BJTksnLFxuICAgICdQSU9ORUVSJyxcbiAgICAnUElaWkEnLFxuICAgICdQSycsXG4gICAgJ1BMJyxcbiAgICAnUExBQ0UnLFxuICAgICdQTEFZJyxcbiAgICAnUExBWVNUQVRJT04nLFxuICAgICdQTFVNQklORycsXG4gICAgJ1BMVVMnLFxuICAgICdQTScsXG4gICAgJ1BOJyxcbiAgICAnUE5DJyxcbiAgICAnUE9ITCcsXG4gICAgJ1BPS0VSJyxcbiAgICAnUE9MSVRJRScsXG4gICAgJ1BPUk4nLFxuICAgICdQT1NUJyxcbiAgICAnUFInLFxuICAgICdQUkFNRVJJQ0EnLFxuICAgICdQUkFYSScsXG4gICAgJ1BSRVNTJyxcbiAgICAnUFJJTUUnLFxuICAgICdQUk8nLFxuICAgICdQUk9EJyxcbiAgICAnUFJPRFVDVElPTlMnLFxuICAgICdQUk9GJyxcbiAgICAnUFJPR1JFU1NJVkUnLFxuICAgICdQUk9NTycsXG4gICAgJ1BST1BFUlRJRVMnLFxuICAgICdQUk9QRVJUWScsXG4gICAgJ1BST1RFQ1RJT04nLFxuICAgICdQUlUnLFxuICAgICdQUlVERU5USUFMJyxcbiAgICAnUFMnLFxuICAgICdQVCcsXG4gICAgJ1BVQicsXG4gICAgJ1BXJyxcbiAgICAnUFdDJyxcbiAgICAnUFknLFxuICAgICdRQScsXG4gICAgJ1FQT04nLFxuICAgICdRVUVCRUMnLFxuICAgICdRVUVTVCcsXG4gICAgJ1FWQycsXG4gICAgJ1JBQ0lORycsXG4gICAgJ1JBRElPJyxcbiAgICAnUkFJRCcsXG4gICAgJ1JFJyxcbiAgICAnUkVBRCcsXG4gICAgJ1JFQUxFU1RBVEUnLFxuICAgICdSRUFMVE9SJyxcbiAgICAnUkVBTFRZJyxcbiAgICAnUkVDSVBFUycsXG4gICAgJ1JFRCcsXG4gICAgJ1JFRFNUT05FJyxcbiAgICAnUkVEVU1CUkVMTEEnLFxuICAgICdSRUhBQicsXG4gICAgJ1JFSVNFJyxcbiAgICAnUkVJU0VOJyxcbiAgICAnUkVJVCcsXG4gICAgJ1JFTElBTkNFJyxcbiAgICAnUkVOJyxcbiAgICAnUkVOVCcsXG4gICAgJ1JFTlRBTFMnLFxuICAgICdSRVBBSVInLFxuICAgICdSRVBPUlQnLFxuICAgICdSRVBVQkxJQ0FOJyxcbiAgICAnUkVTVCcsXG4gICAgJ1JFU1RBVVJBTlQnLFxuICAgICdSRVZJRVcnLFxuICAgICdSRVZJRVdTJyxcbiAgICAnUkVYUk9USCcsXG4gICAgJ1JJQ0gnLFxuICAgICdSSUNIQVJETEknLFxuICAgICdSSUNPSCcsXG4gICAgJ1JJR0hUQVRIT01FJyxcbiAgICAnUklMJyxcbiAgICAnUklPJyxcbiAgICAnUklQJyxcbiAgICAnUk1JVCcsXG4gICAgJ1JPJyxcbiAgICAnUk9DSEVSJyxcbiAgICAnUk9DS1MnLFxuICAgICdST0RFTycsXG4gICAgJ1JPR0VSUycsXG4gICAgJ1JPT00nLFxuICAgICdSUycsXG4gICAgJ1JTVlAnLFxuICAgICdSVScsXG4gICAgJ1JVR0JZJyxcbiAgICAnUlVIUicsXG4gICAgJ1JVTicsXG4gICAgJ1JXJyxcbiAgICAnUldFJyxcbiAgICAnUllVS1lVJyxcbiAgICAnU0EnLFxuICAgICdTQUFSTEFORCcsXG4gICAgJ1NBRkUnLFxuICAgICdTQUZFVFknLFxuICAgICdTQUtVUkEnLFxuICAgICdTQUxFJyxcbiAgICAnU0FMT04nLFxuICAgICdTQU1TQ0xVQicsXG4gICAgJ1NBTVNVTkcnLFxuICAgICdTQU5EVklLJyxcbiAgICAnU0FORFZJS0NPUk9NQU5UJyxcbiAgICAnU0FOT0ZJJyxcbiAgICAnU0FQJyxcbiAgICAnU0FSTCcsXG4gICAgJ1NBUycsXG4gICAgJ1NBVkUnLFxuICAgICdTQVhPJyxcbiAgICAnU0InLFxuICAgICdTQkknLFxuICAgICdTQlMnLFxuICAgICdTQycsXG4gICAgJ1NDQScsXG4gICAgJ1NDQicsXG4gICAgJ1NDSEFFRkZMRVInLFxuICAgICdTQ0hNSURUJyxcbiAgICAnU0NIT0xBUlNISVBTJyxcbiAgICAnU0NIT09MJyxcbiAgICAnU0NIVUxFJyxcbiAgICAnU0NIV0FSWicsXG4gICAgJ1NDSUVOQ0UnLFxuICAgICdTQ0pPSE5TT04nLFxuICAgICdTQ09SJyxcbiAgICAnU0NPVCcsXG4gICAgJ1NEJyxcbiAgICAnU0UnLFxuICAgICdTRUFSQ0gnLFxuICAgICdTRUFUJyxcbiAgICAnU0VDVVJFJyxcbiAgICAnU0VDVVJJVFknLFxuICAgICdTRUVLJyxcbiAgICAnU0VMRUNUJyxcbiAgICAnU0VORVInLFxuICAgICdTRVJWSUNFUycsXG4gICAgJ1NFUycsXG4gICAgJ1NFVkVOJyxcbiAgICAnU0VXJyxcbiAgICAnU0VYJyxcbiAgICAnU0VYWScsXG4gICAgJ1NGUicsXG4gICAgJ1NHJyxcbiAgICAnU0gnLFxuICAgICdTSEFOR1JJTEEnLFxuICAgICdTSEFSUCcsXG4gICAgJ1NIQVcnLFxuICAgICdTSEVMTCcsXG4gICAgJ1NISUEnLFxuICAgICdTSElLU0hBJyxcbiAgICAnU0hPRVMnLFxuICAgICdTSE9QJyxcbiAgICAnU0hPUFBJTkcnLFxuICAgICdTSE9VSkknLFxuICAgICdTSE9XJyxcbiAgICAnU0hPV1RJTUUnLFxuICAgICdTSFJJUkFNJyxcbiAgICAnU0knLFxuICAgICdTSUxLJyxcbiAgICAnU0lOQScsXG4gICAgJ1NJTkdMRVMnLFxuICAgICdTSVRFJyxcbiAgICAnU0onLFxuICAgICdTSycsXG4gICAgJ1NLSScsXG4gICAgJ1NLSU4nLFxuICAgICdTS1knLFxuICAgICdTS1lQRScsXG4gICAgJ1NMJyxcbiAgICAnU0xJTkcnLFxuICAgICdTTScsXG4gICAgJ1NNQVJUJyxcbiAgICAnU01JTEUnLFxuICAgICdTTicsXG4gICAgJ1NOQ0YnLFxuICAgICdTTycsXG4gICAgJ1NPQ0NFUicsXG4gICAgJ1NPQ0lBTCcsXG4gICAgJ1NPRlRCQU5LJyxcbiAgICAnU09GVFdBUkUnLFxuICAgICdTT0hVJyxcbiAgICAnU09MQVInLFxuICAgICdTT0xVVElPTlMnLFxuICAgICdTT05HJyxcbiAgICAnU09OWScsXG4gICAgJ1NPWScsXG4gICAgJ1NQQUNFJyxcbiAgICAnU1BPUlQnLFxuICAgICdTUE9UJyxcbiAgICAnU1BSRUFEQkVUVElORycsXG4gICAgJ1NSJyxcbiAgICAnU1JMJyxcbiAgICAnU1JUJyxcbiAgICAnU1MnLFxuICAgICdTVCcsXG4gICAgJ1NUQURBJyxcbiAgICAnU1RBUExFUycsXG4gICAgJ1NUQVInLFxuICAgICdTVEFURUJBTksnLFxuICAgICdTVEFURUZBUk0nLFxuICAgICdTVEMnLFxuICAgICdTVENHUk9VUCcsXG4gICAgJ1NUT0NLSE9MTScsXG4gICAgJ1NUT1JBR0UnLFxuICAgICdTVE9SRScsXG4gICAgJ1NUUkVBTScsXG4gICAgJ1NUVURJTycsXG4gICAgJ1NUVURZJyxcbiAgICAnU1RZTEUnLFxuICAgICdTVScsXG4gICAgJ1NVQ0tTJyxcbiAgICAnU1VQUExJRVMnLFxuICAgICdTVVBQTFknLFxuICAgICdTVVBQT1JUJyxcbiAgICAnU1VSRicsXG4gICAgJ1NVUkdFUlknLFxuICAgICdTVVpVS0knLFxuICAgICdTVicsXG4gICAgJ1NXQVRDSCcsXG4gICAgJ1NXSUZUQ09WRVInLFxuICAgICdTV0lTUycsXG4gICAgJ1NYJyxcbiAgICAnU1knLFxuICAgICdTWURORVknLFxuICAgICdTWU1BTlRFQycsXG4gICAgJ1NZU1RFTVMnLFxuICAgICdTWicsXG4gICAgJ1RBQicsXG4gICAgJ1RBSVBFSScsXG4gICAgJ1RBTEsnLFxuICAgICdUQU9CQU8nLFxuICAgICdUQVJHRVQnLFxuICAgICdUQVRBTU9UT1JTJyxcbiAgICAnVEFUQVInLFxuICAgICdUQVRUT08nLFxuICAgICdUQVgnLFxuICAgICdUQVhJJyxcbiAgICAnVEMnLFxuICAgICdUQ0knLFxuICAgICdURCcsXG4gICAgJ1RESycsXG4gICAgJ1RFQU0nLFxuICAgICdURUNIJyxcbiAgICAnVEVDSE5PTE9HWScsXG4gICAgJ1RFTCcsXG4gICAgJ1RFTEVGT05JQ0EnLFxuICAgICdURU1BU0VLJyxcbiAgICAnVEVOTklTJyxcbiAgICAnVEVWQScsXG4gICAgJ1RGJyxcbiAgICAnVEcnLFxuICAgICdUSCcsXG4gICAgJ1RIRCcsXG4gICAgJ1RIRUFURVInLFxuICAgICdUSEVBVFJFJyxcbiAgICAnVElBQScsXG4gICAgJ1RJQ0tFVFMnLFxuICAgICdUSUVOREEnLFxuICAgICdUSUZGQU5ZJyxcbiAgICAnVElQUycsXG4gICAgJ1RJUkVTJyxcbiAgICAnVElST0wnLFxuICAgICdUSicsXG4gICAgJ1RKTUFYWCcsXG4gICAgJ1RKWCcsXG4gICAgJ1RLJyxcbiAgICAnVEtNQVhYJyxcbiAgICAnVEwnLFxuICAgICdUTScsXG4gICAgJ1RNQUxMJyxcbiAgICAnVE4nLFxuICAgICdUTycsXG4gICAgJ1RPREFZJyxcbiAgICAnVE9LWU8nLFxuICAgICdUT09MUycsXG4gICAgJ1RPUCcsXG4gICAgJ1RPUkFZJyxcbiAgICAnVE9TSElCQScsXG4gICAgJ1RPVEFMJyxcbiAgICAnVE9VUlMnLFxuICAgICdUT1dOJyxcbiAgICAnVE9ZT1RBJyxcbiAgICAnVE9ZUycsXG4gICAgJ1RSJyxcbiAgICAnVFJBREUnLFxuICAgICdUUkFESU5HJyxcbiAgICAnVFJBSU5JTkcnLFxuICAgICdUUkFWRUwnLFxuICAgICdUUkFWRUxDSEFOTkVMJyxcbiAgICAnVFJBVkVMRVJTJyxcbiAgICAnVFJBVkVMRVJTSU5TVVJBTkNFJyxcbiAgICAnVFJVU1QnLFxuICAgICdUUlYnLFxuICAgICdUVCcsXG4gICAgJ1RVQkUnLFxuICAgICdUVUknLFxuICAgICdUVU5FUycsXG4gICAgJ1RVU0hVJyxcbiAgICAnVFYnLFxuICAgICdUVlMnLFxuICAgICdUVycsXG4gICAgJ1RaJyxcbiAgICAnVUEnLFxuICAgICdVQkFOSycsXG4gICAgJ1VCUycsXG4gICAgJ1VDT05ORUNUJyxcbiAgICAnVUcnLFxuICAgICdVSycsXG4gICAgJ1VOSUNPTScsXG4gICAgJ1VOSVZFUlNJVFknLFxuICAgICdVTk8nLFxuICAgICdVT0wnLFxuICAgICdVUFMnLFxuICAgICdVUycsXG4gICAgJ1VZJyxcbiAgICAnVVonLFxuICAgICdWQScsXG4gICAgJ1ZBQ0FUSU9OUycsXG4gICAgJ1ZBTkEnLFxuICAgICdWQU5HVUFSRCcsXG4gICAgJ1ZDJyxcbiAgICAnVkUnLFxuICAgICdWRUdBUycsXG4gICAgJ1ZFTlRVUkVTJyxcbiAgICAnVkVSSVNJR04nLFxuICAgICdWRVJTSUNIRVJVTkcnLFxuICAgICdWRVQnLFxuICAgICdWRycsXG4gICAgJ1ZJJyxcbiAgICAnVklBSkVTJyxcbiAgICAnVklERU8nLFxuICAgICdWSUcnLFxuICAgICdWSUtJTkcnLFxuICAgICdWSUxMQVMnLFxuICAgICdWSU4nLFxuICAgICdWSVAnLFxuICAgICdWSVJHSU4nLFxuICAgICdWSVNBJyxcbiAgICAnVklTSU9OJyxcbiAgICAnVklTVEFQUklOVCcsXG4gICAgJ1ZJVkEnLFxuICAgICdWSVZPJyxcbiAgICAnVkxBQU5ERVJFTicsXG4gICAgJ1ZOJyxcbiAgICAnVk9ES0EnLFxuICAgICdWT0xLU1dBR0VOJyxcbiAgICAnVk9MVk8nLFxuICAgICdWT1RFJyxcbiAgICAnVk9USU5HJyxcbiAgICAnVk9UTycsXG4gICAgJ1ZPWUFHRScsXG4gICAgJ1ZVJyxcbiAgICAnVlVFTE9TJyxcbiAgICAnV0FMRVMnLFxuICAgICdXQUxNQVJUJyxcbiAgICAnV0FMVEVSJyxcbiAgICAnV0FORycsXG4gICAgJ1dBTkdHT1UnLFxuICAgICdXQVJNQU4nLFxuICAgICdXQVRDSCcsXG4gICAgJ1dBVENIRVMnLFxuICAgICdXRUFUSEVSJyxcbiAgICAnV0VBVEhFUkNIQU5ORUwnLFxuICAgICdXRUJDQU0nLFxuICAgICdXRUJFUicsXG4gICAgJ1dFQlNJVEUnLFxuICAgICdXRUQnLFxuICAgICdXRURESU5HJyxcbiAgICAnV0VJQk8nLFxuICAgICdXRUlSJyxcbiAgICAnV0YnLFxuICAgICdXSE9TV0hPJyxcbiAgICAnV0lFTicsXG4gICAgJ1dJS0knLFxuICAgICdXSUxMSUFNSElMTCcsXG4gICAgJ1dJTicsXG4gICAgJ1dJTkRPV1MnLFxuICAgICdXSU5FJyxcbiAgICAnV0lOTkVSUycsXG4gICAgJ1dNRScsXG4gICAgJ1dPTFRFUlNLTFVXRVInLFxuICAgICdXT09EU0lERScsXG4gICAgJ1dPUksnLFxuICAgICdXT1JLUycsXG4gICAgJ1dPUkxEJyxcbiAgICAnV09XJyxcbiAgICAnV1MnLFxuICAgICdXVEMnLFxuICAgICdXVEYnLFxuICAgICdYQk9YJyxcbiAgICAnWEVST1gnLFxuICAgICdYRklOSVRZJyxcbiAgICAnWElIVUFOJyxcbiAgICAnWElOJyxcbiAgICAnWE4tLTExQjRDM0QnLFxuICAgICdYTi0tMUNLMkUxQicsXG4gICAgJ1hOLS0xUVFXMjNBJyxcbiAgICAnWE4tLTJTQ1JKOUMnLFxuICAgICdYTi0tMzBSUjdZJyxcbiAgICAnWE4tLTNCU1QwME0nLFxuICAgICdYTi0tM0RTNDQzRycsXG4gICAgJ1hOLS0zRTBCNzA3RScsXG4gICAgJ1hOLS0zSENSSjlDJyxcbiAgICAnWE4tLTNPUTE4Vkw4UE4zNkEnLFxuICAgICdYTi0tM1BYVThLJyxcbiAgICAnWE4tLTQyQzJEOUEnLFxuICAgICdYTi0tNDVCUjVDWUwnLFxuICAgICdYTi0tNDVCUko5QycsXG4gICAgJ1hOLS00NVExMUMnLFxuICAgICdYTi0tNEdCUklNJyxcbiAgICAnWE4tLTU0QjdGVEEwQ0MnLFxuICAgICdYTi0tNTVRVzQyRycsXG4gICAgJ1hOLS01NVFYNUQnLFxuICAgICdYTi0tNVNVMzRKOTM2QkdTRycsXG4gICAgJ1hOLS01VFpNNUcnLFxuICAgICdYTi0tNkZSWjgyRycsXG4gICAgJ1hOLS02UVE5ODZCM1hMJyxcbiAgICAnWE4tLTgwQURYSEtTJyxcbiAgICAnWE4tLTgwQU8yMUEnLFxuICAgICdYTi0tODBBUUVDRFIxQScsXG4gICAgJ1hOLS04MEFTRUhEQicsXG4gICAgJ1hOLS04MEFTV0cnLFxuICAgICdYTi0tOFkwQTA2M0EnLFxuICAgICdYTi0tOTBBM0FDJyxcbiAgICAnWE4tLTkwQUUnLFxuICAgICdYTi0tOTBBSVMnLFxuICAgICdYTi0tOURCUTJBJyxcbiAgICAnWE4tLTlFVDUyVScsXG4gICAgJ1hOLS05S1JUMDBBJyxcbiAgICAnWE4tLUI0VzYwNUZFUkQnLFxuICAgICdYTi0tQkNLMUI5QTVEUkU0QycsXG4gICAgJ1hOLS1DMUFWRycsXG4gICAgJ1hOLS1DMkJSN0cnLFxuICAgICdYTi0tQ0NLMkIzQicsXG4gICAgJ1hOLS1DRzRCS0knLFxuICAgICdYTi0tQ0xDSEMwRUEwQjJHMkE5R0NEJyxcbiAgICAnWE4tLUNaUjY5NEInLFxuICAgICdYTi0tQ1pSUzBUJyxcbiAgICAnWE4tLUNaUlUyRCcsXG4gICAgJ1hOLS1EMUFDSjNCJyxcbiAgICAnWE4tLUQxQUxGJyxcbiAgICAnWE4tLUUxQTRDJyxcbiAgICAnWE4tLUVDS1ZEVEM5RCcsXG4gICAgJ1hOLS1FRlZZODhIJyxcbiAgICAnWE4tLUVTVFY3NUcnLFxuICAgICdYTi0tRkNUNDI5SycsXG4gICAgJ1hOLS1GSEJFSScsXG4gICAgJ1hOLS1GSVEyMjhDNUhTJyxcbiAgICAnWE4tLUZJUTY0QicsXG4gICAgJ1hOLS1GSVFTOFMnLFxuICAgICdYTi0tRklRWjlTJyxcbiAgICAnWE4tLUZKUTcyMEEnLFxuICAgICdYTi0tRkxXMzUxRScsXG4gICAgJ1hOLS1GUENSSjlDM0QnLFxuICAgICdYTi0tRlpDMkM5RTJDJyxcbiAgICAnWE4tLUZaWVM4RDY5VVZHTScsXG4gICAgJ1hOLS1HMlhYNDhDJyxcbiAgICAnWE4tLUdDS1IzRjBGJyxcbiAgICAnWE4tLUdFQ1JKOUMnLFxuICAgICdYTi0tR0szQVQxRScsXG4gICAgJ1hOLS1IMkJSRUczRVZFJyxcbiAgICAnWE4tLUgyQlJKOUMnLFxuICAgICdYTi0tSDJCUko5QzhDJyxcbiAgICAnWE4tLUhYVDgxNEUnLFxuICAgICdYTi0tSTFCNkIxQTZBMkUnLFxuICAgICdYTi0tSU1SNTEzTicsXG4gICAgJ1hOLS1JTzBBN0knLFxuICAgICdYTi0tSjFBRUYnLFxuICAgICdYTi0tSjFBTUgnLFxuICAgICdYTi0tSjZXMTkzRycsXG4gICAgJ1hOLS1KTFE2MVU5VzdCJyxcbiAgICAnWE4tLUpWUjE4OU0nLFxuICAgICdYTi0tS0NSWDc3RDFYNEEnLFxuICAgICdYTi0tS1BSVzEzRCcsXG4gICAgJ1hOLS1LUFJZNTdEJyxcbiAgICAnWE4tLUtQVTcxNkYnLFxuICAgICdYTi0tS1BVVDNJJyxcbiAgICAnWE4tLUwxQUNDJyxcbiAgICAnWE4tLUxHQkJBVDFBRDhKJyxcbiAgICAnWE4tLU1HQjlBV0JGJyxcbiAgICAnWE4tLU1HQkEzQTNFSlQnLFxuICAgICdYTi0tTUdCQTNBNEYxNkEnLFxuICAgICdYTi0tTUdCQTdDMEJCTjBBJyxcbiAgICAnWE4tLU1HQkFBS0M3RFZGJyxcbiAgICAnWE4tLU1HQkFBTTdBOEgnLFxuICAgICdYTi0tTUdCQUIyQkQnLFxuICAgICdYTi0tTUdCQUgxQTNISktSRCcsXG4gICAgJ1hOLS1NR0JBSTlBWkdRUDZKJyxcbiAgICAnWE4tLU1HQkFZSDdHUEEnLFxuICAgICdYTi0tTUdCQkgxQScsXG4gICAgJ1hOLS1NR0JCSDFBNzFFJyxcbiAgICAnWE4tLU1HQkMwQTlBWkNHJyxcbiAgICAnWE4tLU1HQkNBN0RaRE8nLFxuICAgICdYTi0tTUdCRVJQNEE1RDRBUicsXG4gICAgJ1hOLS1NR0JHVTgyQScsXG4gICAgJ1hOLS1NR0JJNEVDRVhQJyxcbiAgICAnWE4tLU1HQlBMMkZIJyxcbiAgICAnWE4tLU1HQlQzREhEJyxcbiAgICAnWE4tLU1HQlRYMkInLFxuICAgICdYTi0tTUdCWDRDRDBBQicsXG4gICAgJ1hOLS1NSVg4OTFGJyxcbiAgICAnWE4tLU1LMUJVNDRDJyxcbiAgICAnWE4tLU1YVFExTScsXG4gICAgJ1hOLS1OR0JDNUFaRCcsXG4gICAgJ1hOLS1OR0JFOUUwQScsXG4gICAgJ1hOLS1OR0JSWCcsXG4gICAgJ1hOLS1OT0RFJyxcbiAgICAnWE4tLU5RVjdGJyxcbiAgICAnWE4tLU5RVjdGUzAwRU1BJyxcbiAgICAnWE4tLU5ZUVkyNkEnLFxuICAgICdYTi0tTzNDVzRIJyxcbiAgICAnWE4tLU9HQlBGOEZMJyxcbiAgICAnWE4tLU9UVTc5NkQnLFxuICAgICdYTi0tUDFBQ0YnLFxuICAgICdYTi0tUDFBSScsXG4gICAgJ1hOLS1QQlQ5NzdDJyxcbiAgICAnWE4tLVBHQlMwREgnLFxuICAgICdYTi0tUFNTWTJVJyxcbiAgICAnWE4tLVE5SllCNEMnLFxuICAgICdYTi0tUUNLQTFQTUMnLFxuICAgICdYTi0tUVhBNkEnLFxuICAgICdYTi0tUVhBTScsXG4gICAgJ1hOLS1SSFFWOTZHJyxcbiAgICAnWE4tLVJPVlU4OEInLFxuICAgICdYTi0tUlZDMUUwQU0zRScsXG4gICAgJ1hOLS1TOUJSSjlDJyxcbiAgICAnWE4tLVNFUzU1NEcnLFxuICAgICdYTi0tVDYwQjU2QScsXG4gICAgJ1hOLS1UQ0tXRScsXG4gICAgJ1hOLS1USVE0OVhRWUonLFxuICAgICdYTi0tVU5VUDRZJyxcbiAgICAnWE4tLVZFUk1HRU5TQkVSQVRFUi1DVEInLFxuICAgICdYTi0tVkVSTUdFTlNCRVJBVFVORy1QV0InLFxuICAgICdYTi0tVkhRVVYnLFxuICAgICdYTi0tVlVRODYxQicsXG4gICAgJ1hOLS1XNFI4NUVMOEZIVTVETlJBJyxcbiAgICAnWE4tLVc0UlM0MEwnLFxuICAgICdYTi0tV0dCSDFDJyxcbiAgICAnWE4tLVdHQkw2QScsXG4gICAgJ1hOLS1YSFE1MjFCJyxcbiAgICAnWE4tLVhLQzJBTDNIWUUyQScsXG4gICAgJ1hOLS1YS0MyREwzQTVFRTBIJyxcbiAgICAnWE4tLVk5QTNBUScsXG4gICAgJ1hOLS1ZRlJPNEk2N08nLFxuICAgICdYTi0tWUdCSTJBTU1YJyxcbiAgICAnWE4tLVpGUjE2NEInLFxuICAgICdYWFgnLFxuICAgICdYWVonLFxuICAgICdZQUNIVFMnLFxuICAgICdZQUhPTycsXG4gICAgJ1lBTUFYVU4nLFxuICAgICdZQU5ERVgnLFxuICAgICdZRScsXG4gICAgJ1lPRE9CQVNISScsXG4gICAgJ1lPR0EnLFxuICAgICdZT0tPSEFNQScsXG4gICAgJ1lPVScsXG4gICAgJ1lPVVRVQkUnLFxuICAgICdZVCcsXG4gICAgJ1lVTicsXG4gICAgJ1pBJyxcbiAgICAnWkFQUE9TJyxcbiAgICAnWkFSQScsXG4gICAgJ1pFUk8nLFxuICAgICdaSVAnLFxuICAgICdaTScsXG4gICAgJ1pPTkUnLFxuICAgICdaVUVSSUNIJyxcbiAgICAnWlcnXG5dO1xuXG5cbi8vIEtlZXAgYXMgdXBwZXItY2FzZSB0byBtYWtlIHVwZGF0aW5nIGZyb20gc291cmNlIGVhc2llclxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTZXQoaW50ZXJuYWxzLnRsZHMubWFwKCh0bGQpID0+IHRsZC50b0xvd2VyQ2FzZSgpKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5SYW5nZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGZyb20sIHRvKSB7XG5cbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5oZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyLCBsZW5ndGgpIHtcblxuICAgIC8vIFBhcnNlIGhlYWRlclxuXG4gICAgY29uc3QgcGFydHMgPSBoZWFkZXIuc3BsaXQoJz0nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyIHx8XG4gICAgICAgIHBhcnRzWzBdICE9PSAnYnl0ZXMnKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbGFzdFBvcyA9IGxlbmd0aCAtIDE7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCByYW5nZXMgPSBwYXJ0c1sxXS5tYXRjaCgvXFxkKlxcLVxcZCovZyk7XG5cbiAgICAvLyBIYW5kbGUgaGVhZGVycyB3aXRoIG11bHRpcGxlIHJhbmdlc1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID09PSAxKSB7ICAgICAgICAgICAgICAgLy8gJy0nXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmcm9tO1xuICAgICAgICBsZXQgdG87XG4gICAgICAgIHJhbmdlID0gcmFuZ2Uuc3BsaXQoJy0nKTtcbiAgICAgICAgaWYgKHJhbmdlWzBdKSB7XG4gICAgICAgICAgICBmcm9tID0gcGFyc2VJbnQocmFuZ2VbMF0sIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyYW5nZVsxXSkge1xuICAgICAgICAgICAgdG8gPSBwYXJzZUludChyYW5nZVsxXSwgMTApO1xuICAgICAgICAgICAgaWYgKGZyb20gIT09IHVuZGVmaW5lZCkgeyAgICAgIC8vIENhbiBiZSAwXG4gICAgICAgICAgICAgICAgLy8gRnJvbS1Ub1xuICAgICAgICAgICAgICAgIGlmICh0byA+IGxhc3RQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBsYXN0UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC1Ub1xuICAgICAgICAgICAgICAgIGZyb20gPSBsZW5ndGggLSB0bztcbiAgICAgICAgICAgICAgICB0byA9IGxhc3RQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGcm9tLVxuICAgICAgICAgICAgdG8gPSBsYXN0UG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZyb20gPiB0bykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChuZXcgaW50ZXJuYWxzLlJhbmdlKGZyb20sIHRvKSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBTb3J0IGFuZCBjb25zb2xpZGF0ZSByYW5nZXNcblxuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhLmZyb20gLSBiLmZyb20pO1xuXG4gICAgY29uc3QgY29uc29saWRhdGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID4gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSByZXN1bHRbaV07XG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IHJlc3VsdFtpIC0gMV07XG4gICAgICAgIGlmIChjdXJyZW50LmZyb20gPD0gYmVmb3JlLnRvICsgMSkge1xuICAgICAgICAgICAgYmVmb3JlLnRvID0gY3VycmVudC50bztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGlkYXRlZC51bnNoaWZ0KGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc29saWRhdGVkLnVuc2hpZnQocmVzdWx0WzBdKTtcblxuICAgIHJldHVybiBjb25zb2xpZGF0ZWQ7XG59O1xuXG5cbmV4cG9ydHMuU3RyZWFtID0gaW50ZXJuYWxzLlN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtLlRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihyYW5nZSkge1xuXG4gICAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgaW50ZXJuYWxzLlJhbmdlKSkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHJhbmdlID09PSAnb2JqZWN0JywgJ0V4cGVjdGVkIFwicmFuZ2VcIiBvYmplY3QnKTtcblxuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLmZyb20gfHwgMDtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnbnVtYmVyJywgJ1wicmFuZ2UuZnJvbVwiIG11c3QgYmUgZmFsc3ksIG9yIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChmcm9tID09PSBwYXJzZUludChmcm9tLCAxMCkgJiYgZnJvbSA+PSAwLCAnXCJyYW5nZS5mcm9tXCIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgY29uc3QgdG8gPSByYW5nZS50byB8fCAwO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHRvID09PSAnbnVtYmVyJywgJ1wicmFuZ2UudG9cIiBtdXN0IGJlIGZhbHN5LCBvciBhIG51bWJlcicpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodG8gPT09IHBhcnNlSW50KHRvLCAxMCkgJiYgdG8gPj0gMCwgJ1wicmFuZ2UudG9cIiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0byA+PSBmcm9tLCAnXCJyYW5nZS50b1wiIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwicmFuZ2UuZnJvbVwiJyk7XG5cbiAgICAgICAgICAgIHJhbmdlID0gbmV3IGludGVybmFscy5SYW5nZShmcm9tLCB0byk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMuX25leHQgPSAwO1xuICAgIH1cblxuICAgIHByb2Nlc3NDaHVuayhjaHVuaykge1xuXG4gICAgICAgIC8vIFJlYWQgZGVzaXJlZCByYW5nZSBmcm9tIGEgc3RyZWFtXG5cbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5fbmV4dDtcbiAgICAgICAgdGhpcy5fbmV4dCA9IHRoaXMuX25leHQgKyBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX25leHQgPD0gdGhpcy5fcmFuZ2UuZnJvbSB8fCAgICAgICAvLyBCZWZvcmUgcmFuZ2VcbiAgICAgICAgICAgIHBvcyA+IHRoaXMuX3JhbmdlLnRvKSB7ICAgICAgICAgICAgICAgICAvLyBBZnRlciByYW5nZVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxjIGJvdW5kcyBvZiBjaHVuayB0byByZWFkXG5cbiAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWF4KDAsIHRoaXMuX3JhbmdlLmZyb20gLSBwb3MpO1xuICAgICAgICBjb25zdCB0byA9IE1hdGgubWluKGNodW5rLmxlbmd0aCwgdGhpcy5fcmFuZ2UudG8gLSBwb3MgKyAxKTtcblxuICAgICAgICB0aGlzLnB1c2goY2h1bmsuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLypcbiAgICBEZWNvZGUgZnVuY3Rpb25zIGFkYXB0ZWQgZnJvbTpcbiAgICBWZXJzaW9uIDEuMCAxMi8yNS85OSBDb3B5cmlnaHQgKEMpIDE5OTkgTWFzYW5hbyBJenVtbyA8aXpAb25pY29zLmNvLmpwPlxuICAgIGh0dHA6Ly93d3cub25pY29zLmNvbS9zdGFmZi9pei9hbXVzZS9qYXZhc2NyaXB0L2V4cGVydC9iYXNlNjQudHh0XG4qL1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgZGVjb2RlQ2hhcnM6IFtcbiAgICAgICAgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDYyLCAtMSwgLTEsIC0xLCA2MyxcbiAgICAgICAgNTIsIDUzLCA1NCwgNTUsIDU2LCA1NywgNTgsIDU5LCA2MCwgNjEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsXG4gICAgICAgIC0xLCAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsXG4gICAgICAgIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjAsIDIxLCAyMiwgMjMsIDI0LCAyNSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxuICAgICAgICAtMSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2LCAzNywgMzgsIDM5LCA0MCxcbiAgICAgICAgNDEsIDQyLCA0MywgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxLCAtMSwgLTEsIC0xLCAtMSwgLTFcbiAgICBdXG59O1xuXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuXG4gICAgY29uc3QgZGVjb2RlQ2hhcnMgPSBpbnRlcm5hbHMuZGVjb2RlQ2hhcnM7XG4gICAgY29uc3QgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICBjb25zdCBhbGxvY2F0ZWQgPSBNYXRoLmNlaWwobGVuIC8gNCkgKiAzO1xuICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhhbGxvY2F0ZWQpO1xuXG4gICAgbGV0IGMxO1xuICAgIGxldCBjMjtcbiAgICBsZXQgYzM7XG4gICAgbGV0IGM0O1xuICAgIGxldCBqID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyApIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYzEgPSBkZWNvZGVDaGFyc1tidWZmZXJbaSsrXSAmIDB4ZmZdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgbGVuICYmIGMxID09PSAtMSk7XG5cbiAgICAgICAgaWYgKGMxID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjMiA9IGRlY29kZUNoYXJzW2J1ZmZlcltpKytdICYgMHhmZl07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgYzIgPT09IC0xKTtcblxuICAgICAgICBpZiAoYzIgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdFtqKytdID0gKGMxIDw8IDIpIHwgKChjMiAmIDB4MzApID4+IDQpO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGMzID0gYnVmZmVyW2krK10gJiAweGZmO1xuICAgICAgICAgICAgaWYgKGMzID09PSA2MSkgeyAgICAgICAgICAgICAgICAgICAgICAgIC8vID1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDAsIGopO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjMyA9IGRlY29kZUNoYXJzW2MzXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGxlbiAmJiBjMyA9PT0gLTEpO1xuXG4gICAgICAgIGlmIChjMyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2orK10gPSAoKGMyICYgMHgwZikgPDwgNCkgfCAoKGMzICYgMHgzYykgPj4gMik7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgYzQgPSBidWZmZXJbaSsrXSAmIDB4ZmY7XG4gICAgICAgICAgICBpZiAoYzQgPT09IDYxKSB7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gPVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2xpY2UoMCwgaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGM0ID0gZGVjb2RlQ2hhcnNbYzRdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgbGVuICYmIGM0ID09PSAtMSk7XG5cbiAgICAgICAgaWYgKGM0ICE9PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0W2orK10gPSAoKGMzICYgMHgwMykgPDwgNikgfCBjNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoaiA9PT0gYWxsb2NhdGVkID8gcmVzdWx0IDogcmVzdWx0LnNsaWNlKDAsIGopKTtcbn07XG5cblxuZXhwb3J0cy5EZWNvZGVyID0gY2xhc3MgRGVjb2RlciBleHRlbmRzIFN0cmVhbS5UcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3JlbWluZGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblxuICAgICAgICBsZXQgcGFydCA9IHRoaXMuX3JlbWluZGVyID8gQnVmZmVyLmNvbmNhdChbdGhpcy5fcmVtaW5kZXIsIGNodW5rXSkgOiBjaHVuaztcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gcGFydC5sZW5ndGggJSA0O1xuICAgICAgICBpZiAocmVtYWluaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1pbmRlciA9IHBhcnQuc2xpY2UocGFydC5sZW5ndGggLSByZW1haW5pbmcpO1xuICAgICAgICAgICAgcGFydCA9IHBhcnQuc2xpY2UoMCwgcGFydC5sZW5ndGggLSByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVtaW5kZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdXNoKGV4cG9ydHMuZGVjb2RlKHBhcnQpKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKGNhbGxiYWNrKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlbWluZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2goZXhwb3J0cy5kZWNvZGUodGhpcy5fcmVtaW5kZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG4gICAgRW5jb2RlIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb206XG4gICAgVmVyc2lvbiAxLjAgMTIvMjUvOTkgQ29weXJpZ2h0IChDKSAxOTk5IE1hc2FuYW8gSXp1bW8gPGl6QG9uaWNvcy5jby5qcD5cbiAgICBodHRwOi8vd3d3Lm9uaWNvcy5jb20vc3RhZmYvaXovYW11c2UvamF2YXNjcmlwdC9leHBlcnQvYmFzZTY0LnR4dFxuKi9cblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG59O1xuXG5cbmV4cG9ydHMuRW5jb2RlciA9IGNsYXNzIEVuY29kZXIgZXh0ZW5kcyBTdHJlYW0uVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9yZW1pbmRlciA9IG51bGw7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgbGV0IHBhcnQgPSB0aGlzLl9yZW1pbmRlciA/IEJ1ZmZlci5jb25jYXQoW3RoaXMuX3JlbWluZGVyLCBjaHVua10pIDogY2h1bms7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHBhcnQubGVuZ3RoICUgMztcbiAgICAgICAgaWYgKHJlbWFpbmluZykge1xuICAgICAgICAgICAgdGhpcy5fcmVtaW5kZXIgPSBwYXJ0LnNsaWNlKHBhcnQubGVuZ3RoIC0gcmVtYWluaW5nKTtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0LnNsaWNlKDAsIHBhcnQubGVuZ3RoIC0gcmVtYWluaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbWluZGVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHVzaChleHBvcnRzLmVuY29kZShwYXJ0KSk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIF9mbHVzaChjYWxsYmFjaykge1xuXG4gICAgICAgIGlmICh0aGlzLl9yZW1pbmRlcikge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGV4cG9ydHMuZW5jb2RlKHRoaXMuX3JlbWluZGVyKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBEZWNvZGVyID0gcmVxdWlyZSgnLi9kZWNvZGVyJyk7XG5jb25zdCBFbmNvZGVyID0gcmVxdWlyZSgnLi9lbmNvZGVyJyk7XG5cblxuZXhwb3J0cy5kZWNvZGUgPSBEZWNvZGVyLmRlY29kZTtcblxuZXhwb3J0cy5lbmNvZGUgPSBFbmNvZGVyLmVuY29kZTtcblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2Rlci5EZWNvZGVyO1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyLkVuY29kZXI7XG5cblxuLy8gQmFzZTY0dXJsIChSRkMgNDY0OCkgZW5jb2RlXG5cbmV4cG9ydHMuYmFzZTY0dXJsRW5jb2RlID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZykge1xuXG4gICAgSG9lay5hc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBCdWZmZXIuaXNCdWZmZXIodmFsdWUpLCAndmFsdWUgbXVzdCBiZSBzdHJpbmcgb3IgYnVmZmVyJyk7XG4gICAgY29uc3QgYnVmID0gKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgPyB2YWx1ZSA6IEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZyB8fCAnYmluYXJ5JykpO1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoL1xcPS9nLCAnJyk7XG59O1xuXG5cbi8vIEJhc2U2NHVybCAoUkZDIDQ2NDgpIGRlY29kZVxuXG5leHBvcnRzLmJhc2U2NHVybERlY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmcpIHtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBub3QgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIS9eW1xcd1xcLV0qJC8udGVzdCh2YWx1ZSkpIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKTtcbiAgICByZXR1cm4gKGVuY29kaW5nID09PSAnYnVmZmVyJyA/IGJ1ZiA6IGJ1Zi50b1N0cmluZyhlbmNvZGluZyB8fCAnYmluYXJ5JykpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgY29kZXM6IG5ldyBNYXAoW1xuICAgICAgICBbMTAwLCAnQ29udGludWUnXSxcbiAgICAgICAgWzEwMSwgJ1N3aXRjaGluZyBQcm90b2NvbHMnXSxcbiAgICAgICAgWzEwMiwgJ1Byb2Nlc3NpbmcnXSxcbiAgICAgICAgWzIwMCwgJ09LJ10sXG4gICAgICAgIFsyMDEsICdDcmVhdGVkJ10sXG4gICAgICAgIFsyMDIsICdBY2NlcHRlZCddLFxuICAgICAgICBbMjAzLCAnTm9uLUF1dGhvcml0YXRpdmUgSW5mb3JtYXRpb24nXSxcbiAgICAgICAgWzIwNCwgJ05vIENvbnRlbnQnXSxcbiAgICAgICAgWzIwNSwgJ1Jlc2V0IENvbnRlbnQnXSxcbiAgICAgICAgWzIwNiwgJ1BhcnRpYWwgQ29udGVudCddLFxuICAgICAgICBbMjA3LCAnTXVsdGktU3RhdHVzJ10sXG4gICAgICAgIFszMDAsICdNdWx0aXBsZSBDaG9pY2VzJ10sXG4gICAgICAgIFszMDEsICdNb3ZlZCBQZXJtYW5lbnRseSddLFxuICAgICAgICBbMzAyLCAnTW92ZWQgVGVtcG9yYXJpbHknXSxcbiAgICAgICAgWzMwMywgJ1NlZSBPdGhlciddLFxuICAgICAgICBbMzA0LCAnTm90IE1vZGlmaWVkJ10sXG4gICAgICAgIFszMDUsICdVc2UgUHJveHknXSxcbiAgICAgICAgWzMwNywgJ1RlbXBvcmFyeSBSZWRpcmVjdCddLFxuICAgICAgICBbNDAwLCAnQmFkIFJlcXVlc3QnXSxcbiAgICAgICAgWzQwMSwgJ1VuYXV0aG9yaXplZCddLFxuICAgICAgICBbNDAyLCAnUGF5bWVudCBSZXF1aXJlZCddLFxuICAgICAgICBbNDAzLCAnRm9yYmlkZGVuJ10sXG4gICAgICAgIFs0MDQsICdOb3QgRm91bmQnXSxcbiAgICAgICAgWzQwNSwgJ01ldGhvZCBOb3QgQWxsb3dlZCddLFxuICAgICAgICBbNDA2LCAnTm90IEFjY2VwdGFibGUnXSxcbiAgICAgICAgWzQwNywgJ1Byb3h5IEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJ10sXG4gICAgICAgIFs0MDgsICdSZXF1ZXN0IFRpbWUtb3V0J10sXG4gICAgICAgIFs0MDksICdDb25mbGljdCddLFxuICAgICAgICBbNDEwLCAnR29uZSddLFxuICAgICAgICBbNDExLCAnTGVuZ3RoIFJlcXVpcmVkJ10sXG4gICAgICAgIFs0MTIsICdQcmVjb25kaXRpb24gRmFpbGVkJ10sXG4gICAgICAgIFs0MTMsICdSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2UnXSxcbiAgICAgICAgWzQxNCwgJ1JlcXVlc3QtVVJJIFRvbyBMYXJnZSddLFxuICAgICAgICBbNDE1LCAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZSddLFxuICAgICAgICBbNDE2LCAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZSddLFxuICAgICAgICBbNDE3LCAnRXhwZWN0YXRpb24gRmFpbGVkJ10sXG4gICAgICAgIFs0MTgsICdJXFwnbSBhIHRlYXBvdCddLFxuICAgICAgICBbNDIyLCAnVW5wcm9jZXNzYWJsZSBFbnRpdHknXSxcbiAgICAgICAgWzQyMywgJ0xvY2tlZCddLFxuICAgICAgICBbNDI0LCAnRmFpbGVkIERlcGVuZGVuY3knXSxcbiAgICAgICAgWzQyNSwgJ1Vub3JkZXJlZCBDb2xsZWN0aW9uJ10sXG4gICAgICAgIFs0MjYsICdVcGdyYWRlIFJlcXVpcmVkJ10sXG4gICAgICAgIFs0MjgsICdQcmVjb25kaXRpb24gUmVxdWlyZWQnXSxcbiAgICAgICAgWzQyOSwgJ1RvbyBNYW55IFJlcXVlc3RzJ10sXG4gICAgICAgIFs0MzEsICdSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlJ10sXG4gICAgICAgIFs0NTEsICdVbmF2YWlsYWJsZSBGb3IgTGVnYWwgUmVhc29ucyddLFxuICAgICAgICBbNTAwLCAnSW50ZXJuYWwgU2VydmVyIEVycm9yJ10sXG4gICAgICAgIFs1MDEsICdOb3QgSW1wbGVtZW50ZWQnXSxcbiAgICAgICAgWzUwMiwgJ0JhZCBHYXRld2F5J10sXG4gICAgICAgIFs1MDMsICdTZXJ2aWNlIFVuYXZhaWxhYmxlJ10sXG4gICAgICAgIFs1MDQsICdHYXRld2F5IFRpbWUtb3V0J10sXG4gICAgICAgIFs1MDUsICdIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZCddLFxuICAgICAgICBbNTA2LCAnVmFyaWFudCBBbHNvIE5lZ290aWF0ZXMnXSxcbiAgICAgICAgWzUwNywgJ0luc3VmZmljaWVudCBTdG9yYWdlJ10sXG4gICAgICAgIFs1MDksICdCYW5kd2lkdGggTGltaXQgRXhjZWVkZWQnXSxcbiAgICAgICAgWzUxMCwgJ05vdCBFeHRlbmRlZCddLFxuICAgICAgICBbNTExLCAnTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCddXG4gICAgXSlcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuQm9vbSA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5Cb29tLmJvb21pZnkoSG9lay5jbG9uZShtZXNzYWdlKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGUgPSA1MDAsIGRhdGEgPSBudWxsLCBjdG9yID0gaW50ZXJuYWxzLkJvb20gfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UgPyBtZXNzYWdlIDogdW5kZWZpbmVkKTsgICAgICAgICAvLyBBdm9pZHMgc2V0dGluZ3MgbnVsbCBtZXNzYWdlXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBjdG9yKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIHN0YWNrIHRvIG91ciBleHRlcm5hbCBBUElcbiAgICAgICAgZXJyb3IuZGF0YSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGJvb20gPSBpbnRlcm5hbHMuaW5pdGlhbGl6ZShlcnJvciwgc3RhdHVzQ29kZSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGJvb20sICd0eXBlb2YnLCB7IHZhbHVlOiBjdG9yIH0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRlY29yYXRlKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGJvb20sIG9wdGlvbnMuZGVjb3JhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvb207XG4gICAgfVxuXG4gICAgc3RhdGljIFtTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3RhbmNlKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5Cb29tLmlzQm9vbShpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzQm9vbShlcnIpIHtcblxuICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgISFlcnIuaXNCb29tO1xuICAgIH1cblxuICAgIHN0YXRpYyBib29taWZ5KGVyciwgb3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGVyciBpbnN0YW5jZW9mIEVycm9yLCAnQ2Fubm90IHdyYXAgbm9uLUVycm9yIG9iamVjdCcpO1xuXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyLmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5kZWNvcmF0ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlcnIsIG9wdGlvbnMuZGVjb3JhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcnIuaXNCb29tKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmluaXRpYWxpemUoZXJyLCBvcHRpb25zLnN0YXR1c0NvZGUgfHwgNTAwLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMub3ZlcnJpZGUgPT09IGZhbHNlIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgIW9wdGlvbnMuc3RhdHVzQ29kZSAmJiAhb3B0aW9ucy5tZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmluaXRpYWxpemUoZXJyLCBvcHRpb25zLnN0YXR1c0NvZGUgfHwgZXJyLm91dHB1dC5zdGF0dXNDb2RlLCBvcHRpb25zLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8vIDR4eCBDbGllbnQgRXJyb3JzXG5cbiAgICBzdGF0aWMgYmFkUmVxdWVzdChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwMCwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20uYmFkUmVxdWVzdCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdW5hdXRob3JpemVkKG1lc3NhZ2UsIHNjaGVtZSwgYXR0cmlidXRlcykgeyAgICAgICAgICAvLyBPciAobWVzc2FnZSwgd3d3QXV0aGVudGljYXRlW10pXG5cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDAxLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS51bmF1dGhvcml6ZWQgfSk7XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gKG1lc3NhZ2UpXG5cbiAgICAgICAgaWYgKCFzY2hlbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmdW5jdGlvbiAobWVzc2FnZSwgd3d3QXV0aGVudGljYXRlW10pXG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnIub3V0cHV0LmhlYWRlcnNbJ1dXVy1BdXRoZW50aWNhdGUnXSA9IHNjaGVtZS5qb2luKCcsICcpO1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIChtZXNzYWdlLCBzY2hlbWUsIGF0dHJpYnV0ZXMpXG5cbiAgICAgICAgbGV0IHd3d0F1dGhlbnRpY2F0ZSA9IGAke3NjaGVtZX0gYDtcblxuICAgICAgICBpZiAoYXR0cmlidXRlcyB8fFxuICAgICAgICAgICAgbWVzc2FnZSkge1xuXG4gICAgICAgICAgICBlcnIub3V0cHV0LnBheWxvYWQuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB3d3dBdXRoZW50aWNhdGUgKz0gSG9lay5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgZXJyLm91dHB1dC5wYXlsb2FkLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgobmFtZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyLm91dHB1dC5wYXlsb2FkLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9PVwiJHtIb2VrLmVzY2FwZUhlYWRlckF0dHJpYnV0ZSh2YWx1ZS50b1N0cmluZygpKX1cImA7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB3d3dBdXRoZW50aWNhdGUgKz0gJywgJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3d3QXV0aGVudGljYXRlICs9IGBlcnJvcj1cIiR7SG9lay5lc2NhcGVIZWFkZXJBdHRyaWJ1dGUobWVzc2FnZSl9XCJgO1xuICAgICAgICAgICAgZXJyLm91dHB1dC5wYXlsb2FkLmF0dHJpYnV0ZXMuZXJyb3IgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyLmlzTWlzc2luZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBlcnIub3V0cHV0LmhlYWRlcnNbJ1dXVy1BdXRoZW50aWNhdGUnXSA9IHd3d0F1dGhlbnRpY2F0ZTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGF5bWVudFJlcXVpcmVkKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDAyLCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5wYXltZW50UmVxdWlyZWQgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGZvcmJpZGRlbihtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwMywgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20uZm9yYmlkZGVuIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBub3RGb3VuZChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwNCwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20ubm90Rm91bmQgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIG1ldGhvZE5vdEFsbG93ZWQobWVzc2FnZSwgZGF0YSwgYWxsb3cpIHtcblxuICAgICAgICBjb25zdCBlcnIgPSBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDUsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLm1ldGhvZE5vdEFsbG93ZWQgfSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhbGxvdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFsbG93ID0gW2FsbG93XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFsbG93KSkge1xuICAgICAgICAgICAgZXJyLm91dHB1dC5oZWFkZXJzLkFsbG93ID0gYWxsb3cuam9pbignLCAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgc3RhdGljIG5vdEFjY2VwdGFibGUobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDYsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLm5vdEFjY2VwdGFibGUgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHByb3h5QXV0aFJlcXVpcmVkKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDA3LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5wcm94eUF1dGhSZXF1aXJlZCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2xpZW50VGltZW91dChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQwOCwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20uY2xpZW50VGltZW91dCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY29uZmxpY3QobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MDksIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmNvbmZsaWN0IH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyByZXNvdXJjZUdvbmUobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTAsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLnJlc291cmNlR29uZSB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbGVuZ3RoUmVxdWlyZWQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTEsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmxlbmd0aFJlcXVpcmVkIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmVjb25kaXRpb25GYWlsZWQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTIsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLnByZWNvbmRpdGlvbkZhaWxlZCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZW50aXR5VG9vTGFyZ2UobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTMsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmVudGl0eVRvb0xhcmdlIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1cmlUb29Mb25nKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE0LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS51cmlUb29Mb25nIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyB1bnN1cHBvcnRlZE1lZGlhVHlwZShtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQxNSwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20udW5zdXBwb3J0ZWRNZWRpYVR5cGUgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHJhbmdlTm90U2F0aXNmaWFibGUobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MTYsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLnJhbmdlTm90U2F0aXNmaWFibGUgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGV4cGVjdGF0aW9uRmFpbGVkKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE3LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5leHBlY3RhdGlvbkZhaWxlZCB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdGVhcG90KG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDE4LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS50ZWFwb3QgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGJhZERhdGEobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlOiA0MjIsIGRhdGEsIGN0b3I6IGludGVybmFscy5Cb29tLmJhZERhdGEgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGxvY2tlZChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQyMywgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20ubG9ja2VkIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBmYWlsZWREZXBlbmRlbmN5KG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDI0LCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5mYWlsZWREZXBlbmRlbmN5IH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBwcmVjb25kaXRpb25SZXF1aXJlZChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQyOCwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20ucHJlY29uZGl0aW9uUmVxdWlyZWQgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHRvb01hbnlSZXF1ZXN0cyhtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQm9vbShtZXNzYWdlLCB7IHN0YXR1c0NvZGU6IDQyOSwgZGF0YSwgY3RvcjogaW50ZXJuYWxzLkJvb20udG9vTWFueVJlcXVlc3RzIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBpbGxlZ2FsKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5Cb29tKG1lc3NhZ2UsIHsgc3RhdHVzQ29kZTogNDUxLCBkYXRhLCBjdG9yOiBpbnRlcm5hbHMuQm9vbS5pbGxlZ2FsIH0pO1xuICAgIH1cblxuICAgIC8vIDV4eCBTZXJ2ZXIgRXJyb3JzXG5cbiAgICBzdGF0aWMgaW50ZXJuYWwobWVzc2FnZSwgZGF0YSwgc3RhdHVzQ29kZSA9IDUwMCkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgc3RhdHVzQ29kZSwgaW50ZXJuYWxzLkJvb20uaW50ZXJuYWwpO1xuICAgIH1cblxuICAgIHN0YXRpYyBub3RJbXBsZW1lbnRlZChtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zZXJ2ZXJFcnJvcihtZXNzYWdlLCBkYXRhLCA1MDEsIGludGVybmFscy5Cb29tLm5vdEltcGxlbWVudGVkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYmFkR2F0ZXdheShtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zZXJ2ZXJFcnJvcihtZXNzYWdlLCBkYXRhLCA1MDIsIGludGVybmFscy5Cb29tLmJhZEdhdGV3YXkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXJ2ZXJVbmF2YWlsYWJsZShtZXNzYWdlLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zZXJ2ZXJFcnJvcihtZXNzYWdlLCBkYXRhLCA1MDMsIGludGVybmFscy5Cb29tLnNlcnZlclVuYXZhaWxhYmxlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2F0ZXdheVRpbWVvdXQobWVzc2FnZSwgZGF0YSkge1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgNTA0LCBpbnRlcm5hbHMuQm9vbS5nYXRld2F5VGltZW91dCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGJhZEltcGxlbWVudGF0aW9uKG1lc3NhZ2UsIGRhdGEpIHtcblxuICAgICAgICBjb25zdCBlcnIgPSBpbnRlcm5hbHMuc2VydmVyRXJyb3IobWVzc2FnZSwgZGF0YSwgNTAwLCBpbnRlcm5hbHMuQm9vbS5iYWRJbXBsZW1lbnRhdGlvbik7XG4gICAgICAgIGVyci5pc0RldmVsb3BlckVycm9yID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5Cb29tLmRlZmF1bHQgPSBpbnRlcm5hbHMuQm9vbTsgICAgICAgIC8vIFN1cHBvcnQgRVM2IG1vZHVsZSBpbXBvcnRcblxuXG5pbnRlcm5hbHMuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChlcnIsIHN0YXR1c0NvZGUsIG1lc3NhZ2UpIHtcblxuICAgIGNvbnN0IG51bWJlckNvZGUgPSBwYXJzZUludChzdGF0dXNDb2RlLCAxMCk7XG4gICAgSG9lay5hc3NlcnQoIWlzTmFOKG51bWJlckNvZGUpICYmIG51bWJlckNvZGUgPj0gNDAwLCAnRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlciAoNDAwKyk6Jywgc3RhdHVzQ29kZSk7XG5cbiAgICBlcnIuaXNCb29tID0gdHJ1ZTtcbiAgICBlcnIuaXNTZXJ2ZXIgPSBudW1iZXJDb2RlID49IDUwMDtcblxuICAgIGlmICghZXJyLmhhc093blByb3BlcnR5KCdkYXRhJykpIHtcbiAgICAgICAgZXJyLmRhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIGVyci5vdXRwdXQgPSB7XG4gICAgICAgIHN0YXR1c0NvZGU6IG51bWJlckNvZGUsXG4gICAgICAgIHBheWxvYWQ6IHt9LFxuICAgICAgICBoZWFkZXJzOiB7fVxuICAgIH07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAncmVmb3JtYXQnLCB7IHZhbHVlOiBpbnRlcm5hbHMucmVmb3JtYXQgfSk7XG5cbiAgICBpZiAoIW1lc3NhZ2UgJiZcbiAgICAgICAgIWVyci5tZXNzYWdlKSB7XG5cbiAgICAgICAgZXJyLnJlZm9ybWF0KCk7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnIub3V0cHV0LnBheWxvYWQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGVyciwgJ21lc3NhZ2UnKSB8fCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5nZXRQcm90b3R5cGVPZihlcnIpLCAnbWVzc2FnZScpO1xuICAgICAgICBIb2VrLmFzc2VydChwcm9wcy5jb25maWd1cmFibGUgJiYgIXByb3BzLmdldCwgJ1RoZSBlcnJvciBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGJvb20nKTtcblxuICAgICAgICBlcnIubWVzc2FnZSA9IG1lc3NhZ2UgKyAoZXJyLm1lc3NhZ2UgPyAnOiAnICsgZXJyLm1lc3NhZ2UgOiAnJyk7XG4gICAgICAgIGVyci5vdXRwdXQucGF5bG9hZC5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgZXJyLnJlZm9ybWF0KCk7XG4gICAgcmV0dXJuIGVycjtcbn07XG5cblxuaW50ZXJuYWxzLnJlZm9ybWF0ID0gZnVuY3Rpb24gKGRlYnVnID0gZmFsc2UpIHtcblxuICAgIHRoaXMub3V0cHV0LnBheWxvYWQuc3RhdHVzQ29kZSA9IHRoaXMub3V0cHV0LnN0YXR1c0NvZGU7XG4gICAgdGhpcy5vdXRwdXQucGF5bG9hZC5lcnJvciA9IGludGVybmFscy5jb2Rlcy5nZXQodGhpcy5vdXRwdXQuc3RhdHVzQ29kZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgaWYgKHRoaXMub3V0cHV0LnN0YXR1c0NvZGUgPT09IDUwMCAmJiBkZWJ1ZyAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm91dHB1dC5wYXlsb2FkLm1lc3NhZ2UgPSAnQW4gaW50ZXJuYWwgc2VydmVyIGVycm9yIG9jY3VycmVkJzsgICAgICAgICAgICAgIC8vIEhpZGUgYWN0dWFsIGVycm9yIGZyb20gdXNlclxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLm1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5vdXRwdXQucGF5bG9hZC5tZXNzYWdlID0gdGhpcy5tZXNzYWdlO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNlcnZlckVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGRhdGEsIHN0YXR1c0NvZGUsIGN0b3IpIHtcblxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgIWRhdGEuaXNCb29tKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5Cb29tLmJvb21pZnkoZGF0YSwgeyBzdGF0dXNDb2RlLCBtZXNzYWdlIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLkJvb20obWVzc2FnZSwgeyBzdGF0dXNDb2RlLCBkYXRhLCBjdG9yIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeXN0ZW06IFtcblxuICAgICAgICAvLyBKYXZhU2NyaXB0XG5cbiAgICAgICAgRXZhbEVycm9yLFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICBSZWZlcmVuY2VFcnJvcixcbiAgICAgICAgU3ludGF4RXJyb3IsXG4gICAgICAgIFR5cGVFcnJvcixcbiAgICAgICAgVVJJRXJyb3IsXG5cbiAgICAgICAgLy8gTm9kZVxuXG4gICAgICAgIEFzc2VydC5Bc3NlcnRpb25FcnJvcixcblxuICAgICAgICAvLyBIb2VrXG5cbiAgICAgICAgSG9lay5FcnJvclxuICAgIF1cbn07XG5cblxuZXhwb3J0cy5yZXRocm93ID0gZnVuY3Rpb24gKGVyciwgdHlwZXMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5jYXRjaChlcnIsIHR5cGVzLCBvcHRpb25zLCB0cnVlKTtcbn07XG5cblxuZXhwb3J0cy5pZ25vcmUgPSBmdW5jdGlvbiAoZXJyLCB0eXBlcywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmNhdGNoKGVyciwgdHlwZXMsIG9wdGlvbnMsIGZhbHNlKTtcbn07XG5cblxuaW50ZXJuYWxzLmNhdGNoID0gZnVuY3Rpb24gKGVyciwgdHlwZXMsIG9wdGlvbnMsIG1hdGNoKSB7XG5cbiAgICBpZiAoaW50ZXJuYWxzLm1hdGNoKGVyciwgdHlwZXMpICE9PSBtYXRjaCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRXJyb3IgcmVwbGFjZW1lbnRcblxuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlKSB7XG4gICAgICAgIGVyciA9IG9wdGlvbnMub3ZlcnJpZGU7XG4gICAgfVxuXG4gICAgLy8gRXJyb3IgZGVjb3JhdGlvbnNcblxuICAgIGlmIChvcHRpb25zLmRlY29yYXRlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyLCBvcHRpb25zLmRlY29yYXRlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yZXR1cm4pIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG59O1xuXG5cbmV4cG9ydHMuYmFja2dyb3VuZCA9IGFzeW5jIGZ1bmN0aW9uIChvcGVyYXRpb24sIGFjdGlvbiA9ICdyZXRocm93JywgdHlwZXMgPSAnc3lzdGVtJywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIG9wZXJhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBvcGVyYXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBleHBvcnRzW2FjdGlvbl0oZXJyLCB0eXBlcywgb3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLmlzQm9vbSA9IGZ1bmN0aW9uIChlcnIpIHtcblxuICAgIHJldHVybiBCb29tLmlzQm9vbShlcnIpO1xufTtcblxuXG5leHBvcnRzLmlzRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cbiAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3I7XG59O1xuXG5cbmV4cG9ydHMuaXNTeXN0ZW0gPSBmdW5jdGlvbiAoZXJyKSB7XG5cbiAgICBpZiAoIWVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGVyci5pc0Jvb20pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIGludGVybmFscy5zeXN0ZW0pIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIHN5c3RlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbmludGVybmFscy5ydWxlcyA9IHtcbiAgICBzeXN0ZW06IGV4cG9ydHMuaXNTeXN0ZW0sXG4gICAgYm9vbTogZXhwb3J0cy5pc0Jvb21cbn07XG5cblxuaW50ZXJuYWxzLm1hdGNoID0gZnVuY3Rpb24gKGVyciwgdHlwZXMpIHtcblxuICAgIGlmICghdHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHlwZXMgPSBBcnJheS5pc0FycmF5KHR5cGVzKSA/IHR5cGVzIDogW3R5cGVzXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5ydWxlc1t0eXBlXShlcnIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoSG9lay5jb250YWluKGVyciwgdHlwZSwgeyBkZWVwOiB0cnVlLCBwYXJ0OiB0cnVlIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbmNvbnN0IGludGVybmFscyA9IHtcclxuICAgIHN1c3BlY3RSeDogL1wiKD86X3xcXFxcdTAwNVtGZl0pKD86X3xcXFxcdTAwNVtGZl0pKD86cHxcXFxcdTAwNzApKD86cnxcXFxcdTAwNzIpKD86b3xcXFxcdTAwNltGZl0pKD86dHxcXFxcdTAwNzQpKD86b3xcXFxcdTAwNltGZl0pKD86X3xcXFxcdTAwNVtGZl0pKD86X3xcXFxcdTAwNVtGZl0pXCJcXHMqXFw6L1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAodGV4dCwgcmV2aXZlciwgb3B0aW9ucykge1xyXG5cclxuICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHNcclxuXHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICBpZiAocmV2aXZlciAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgcmV2aXZlciA9PT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXZpdmVyO1xyXG4gICAgICAgICAgICByZXZpdmVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQYXJzZSBub3JtYWxseSwgYWxsb3dpbmcgZXhjZXB0aW9uc1xyXG5cclxuICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UodGV4dCwgcmV2aXZlcik7XHJcblxyXG4gICAgLy8gb3B0aW9ucy5wcm90b0FjdGlvbjogJ2Vycm9yJyAoZGVmYXVsdCkgLyAncmVtb3ZlJyAvICdpZ25vcmUnXHJcblxyXG4gICAgaWYgKG9wdGlvbnMucHJvdG9BY3Rpb24gPT09ICdpZ25vcmUnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZ25vcmUgbnVsbCBhbmQgbm9uLW9iamVjdHNcclxuXHJcbiAgICBpZiAoIW9iaiB8fFxyXG4gICAgICAgIHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgb3JpZ2luYWwgc3RyaW5nIGZvciBwb3RlbnRpYWwgZXhwbG9pdFxyXG5cclxuICAgIGlmICghdGV4dC5tYXRjaChpbnRlcm5hbHMuc3VzcGVjdFJ4KSkge1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2NhbiByZXN1bHQgZm9yIHByb3RvIGtleXNcclxuXHJcbiAgICBleHBvcnRzLnNjYW4ob2JqLCBvcHRpb25zKTtcclxuXHJcbiAgICByZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuc2NhbiA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMpIHtcclxuXHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICBsZXQgbmV4dCA9IFtvYmpdO1xyXG5cclxuICAgIHdoaWxlIChuZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gbmV4dDtcclxuICAgICAgICBuZXh0ID0gW107XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsICdfX3Byb3RvX18nKSkgeyAgICAgIC8vIEF2b2lkIGNhbGxpbmcgbm9kZS5oYXNPd25Qcm9wZXJ0eSBkaXJlY3RseVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvdG9BY3Rpb24gIT09ICdyZW1vdmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdPYmplY3QgY29udGFpbnMgZm9yYmlkZGVuIHByb3RvdHlwZSBwcm9wZXJ0eScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLl9fcHJvdG9fXztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiZcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQucHVzaChub2RlW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmV4cG9ydHMuc2FmZVBhcnNlID0gZnVuY3Rpb24gKHRleHQsIHJldml2ZXIpIHtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLnBhcnNlKHRleHQsIHJldml2ZXIpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGlnbm9yZUVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5cbmNvbnN0IFJlZ2V4ID0gcmVxdWlyZSgnLi9yZWdleCcpO1xuY29uc3QgU2VnbWVudCA9IHJlcXVpcmUoJy4vc2VnbWVudCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBwYXRoUmVnZXg6IFJlZ2V4LmdlbmVyYXRlKCksXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgaXNDYXNlU2Vuc2l0aXZlOiB0cnVlXG4gICAgfVxufTtcblxuXG5leHBvcnRzLlJvdXRlciA9IGludGVybmFscy5Sb3V0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgdGhpcy5zZXR0aW5ncyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLnJvdXRlcyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZXk6IEhUVFAgbWV0aG9kIG9yICogZm9yIGNhdGNoLWFsbCwgdmFsdWU6IHNvcnRlZCBhcnJheSBvZiByb3V0ZXNcbiAgICB0aGlzLmlkcyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZXk6IHJvdXRlIGlkLCB2YWx1ZTogcmVjb3JkXG4gICAgdGhpcy52aG9zdHMgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ge30gd2hlcmUgS2V5OiBob3N0bmFtZSwgdmFsdWU6IHNlZSB0aGlzLnJvdXRlc1xuXG4gICAgdGhpcy5zcGVjaWFscyA9IHtcbiAgICAgICAgYmFkUmVxdWVzdDogbnVsbCxcbiAgICAgICAgbm90Rm91bmQ6IG51bGwsXG4gICAgICAgIG9wdGlvbnM6IG51bGxcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuUm91dGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY29uZmlnLCByb3V0ZSkge1xuXG4gICAgY29uc3QgbWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgY29uc3Qgdmhvc3QgPSBjb25maWcudmhvc3QgfHwgJyonO1xuICAgIGlmICh2aG9zdCAhPT0gJyonKSB7XG4gICAgICAgIHRoaXMudmhvc3RzID0gdGhpcy52aG9zdHMgfHwge307XG4gICAgICAgIHRoaXMudmhvc3RzW3Zob3N0XSA9IHRoaXMudmhvc3RzW3Zob3N0XSB8fCB7fTtcbiAgICB9XG5cbiAgICBjb25zdCB0YWJsZSA9ICh2aG9zdCA9PT0gJyonID8gdGhpcy5yb3V0ZXMgOiB0aGlzLnZob3N0c1t2aG9zdF0pO1xuICAgIHRhYmxlW21ldGhvZF0gPSB0YWJsZVttZXRob2RdIHx8IHsgcm91dGVzOiBbXSwgcm91dGVyOiBuZXcgU2VnbWVudCgpIH07XG5cbiAgICBjb25zdCBhbmFseXNpcyA9IGNvbmZpZy5hbmFseXNpcyB8fCB0aGlzLmFuYWx5emUoY29uZmlnLnBhdGgpO1xuICAgIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgICAgcGF0aDogY29uZmlnLnBhdGgsXG4gICAgICAgIHJvdXRlOiByb3V0ZSB8fCBjb25maWcucGF0aCxcbiAgICAgICAgc2VnbWVudHM6IGFuYWx5c2lzLnNlZ21lbnRzLFxuICAgICAgICBwYXJhbXM6IGFuYWx5c2lzLnBhcmFtcyxcbiAgICAgICAgZmluZ2VycHJpbnQ6IGFuYWx5c2lzLmZpbmdlcnByaW50LFxuICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5nc1xuICAgIH07XG5cbiAgICAvLyBBZGQgcm91dGVcblxuICAgIHRhYmxlW21ldGhvZF0ucm91dGVyLmFkZChhbmFseXNpcy5zZWdtZW50cywgcmVjb3JkKTtcbiAgICB0YWJsZVttZXRob2RdLnJvdXRlcy5wdXNoKHJlY29yZCk7XG4gICAgdGFibGVbbWV0aG9kXS5yb3V0ZXMuc29ydChpbnRlcm5hbHMuc29ydCk7XG5cbiAgICBjb25zdCBsYXN0ID0gcmVjb3JkLnNlZ21lbnRzW3JlY29yZC5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdC5lbXB0eSkge1xuICAgICAgICB0YWJsZVttZXRob2RdLnJvdXRlci5hZGQoYW5hbHlzaXMuc2VnbWVudHMuc2xpY2UoMCwgLTEpLCByZWNvcmQpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuaWQpIHtcbiAgICAgICAgSG9lay5hc3NlcnQoIXRoaXMuaWRzW2NvbmZpZy5pZF0sICdSb3V0ZSBpZCcsIGNvbmZpZy5pZCwgJ2ZvciBwYXRoJywgY29uZmlnLnBhdGgsICdjb25mbGljdHMgd2l0aCBleGlzdGluZyBwYXRoJywgdGhpcy5pZHNbY29uZmlnLmlkXSAmJiB0aGlzLmlkc1tjb25maWcuaWRdLnBhdGgpO1xuICAgICAgICB0aGlzLmlkc1tjb25maWcuaWRdID0gcmVjb3JkO1xuICAgIH1cblxuICAgIHJldHVybiByZWNvcmQ7XG59O1xuXG5cbmludGVybmFscy5Sb3V0ZXIucHJvdG90eXBlLnNwZWNpYWwgPSBmdW5jdGlvbiAodHlwZSwgcm91dGUpIHtcblxuICAgIEhvZWsuYXNzZXJ0KE9iamVjdC5rZXlzKHRoaXMuc3BlY2lhbHMpLmluZGV4T2YodHlwZSkgIT09IC0xLCAnVW5rbm93biBzcGVjaWFsIHJvdXRlIHR5cGU6JywgdHlwZSk7XG5cbiAgICB0aGlzLnNwZWNpYWxzW3R5cGVdID0geyByb3V0ZSB9O1xufTtcblxuXG5pbnRlcm5hbHMuUm91dGVyLnByb3RvdHlwZS5yb3V0ZSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhdGgsIGhvc3RuYW1lKSB7XG5cbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy8nKS5zbGljZSgxKTtcblxuICAgIGNvbnN0IHZob3N0ID0gKHRoaXMudmhvc3RzICYmIGhvc3RuYW1lICYmIHRoaXMudmhvc3RzW2hvc3RuYW1lXSk7XG4gICAgY29uc3Qgcm91dGUgPSAodmhvc3QgJiYgdGhpcy5fbG9va3VwKHBhdGgsIHNlZ21lbnRzLCB2aG9zdCwgbWV0aG9kKSkgfHxcbiAgICAgICAgdGhpcy5fbG9va3VwKHBhdGgsIHNlZ21lbnRzLCB0aGlzLnJvdXRlcywgbWV0aG9kKSB8fFxuICAgICAgICAobWV0aG9kID09PSAnaGVhZCcgJiYgdmhvc3QgJiYgdGhpcy5fbG9va3VwKHBhdGgsIHNlZ21lbnRzLCB2aG9zdCwgJ2dldCcpKSB8fFxuICAgICAgICAobWV0aG9kID09PSAnaGVhZCcgJiYgdGhpcy5fbG9va3VwKHBhdGgsIHNlZ21lbnRzLCB0aGlzLnJvdXRlcywgJ2dldCcpKSB8fFxuICAgICAgICAobWV0aG9kID09PSAnb3B0aW9ucycgJiYgdGhpcy5zcGVjaWFscy5vcHRpb25zKSB8fFxuICAgICAgICAodmhvc3QgJiYgdGhpcy5fbG9va3VwKHBhdGgsIHNlZ21lbnRzLCB2aG9zdCwgJyonKSkgfHxcbiAgICAgICAgdGhpcy5fbG9va3VwKHBhdGgsIHNlZ21lbnRzLCB0aGlzLnJvdXRlcywgJyonKSB8fFxuICAgICAgICB0aGlzLnNwZWNpYWxzLm5vdEZvdW5kIHx8IEJvb20ubm90Rm91bmQoKTtcblxuICAgIHJldHVybiByb3V0ZTtcbn07XG5cblxuaW50ZXJuYWxzLlJvdXRlci5wcm90b3R5cGUuX2xvb2t1cCA9IGZ1bmN0aW9uIChwYXRoLCBzZWdtZW50cywgdGFibGUsIG1ldGhvZCkge1xuXG4gICAgY29uc3Qgc2V0ID0gdGFibGVbbWV0aG9kXTtcbiAgICBpZiAoIXNldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9IHNldC5yb3V0ZXIubG9va3VwKHBhdGgsIHNlZ21lbnRzLCB0aGlzLnNldHRpbmdzKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGFzc2lnbm1lbnRzID0ge307XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaC5yZWNvcmQucGFyYW1zW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGludGVybmFscy5kZWNvZGUobWF0Y2guYXJyYXlbaV0pO1xuICAgICAgICBpZiAodmFsdWUuaXNCb29tKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVjaWFscy5iYWRSZXF1ZXN0IHx8IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFzc2lnbm1lbnRzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzW25hbWVdID0gYXNzaWdubWVudHNbbmFtZV0gKyAnLycgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSArIDEgPT09IG1hdGNoLmFycmF5Lmxlbmd0aCB8fCAgICAgICAgICAgICAgICAgLy8gT25seSBpbmNsdWRlIHRoZSBsYXN0IHNlZ21lbnQgb2YgYSBtdWx0aS1zZWdtZW50IHBhcmFtXG4gICAgICAgICAgICBuYW1lICE9PSBtYXRjaC5yZWNvcmQucGFyYW1zW2kgKyAxXSkge1xuXG4gICAgICAgICAgICBhcnJheS5wdXNoKGFzc2lnbm1lbnRzW25hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHBhcmFtczogYXNzaWdubWVudHMsIHBhcmFtc0FycmF5OiBhcnJheSwgcm91dGU6IG1hdGNoLnJlY29yZC5yb3V0ZSB9O1xufTtcblxuXG5pbnRlcm5hbHMuZGVjb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIHJlcXVlc3QgcGF0aCcpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlJvdXRlci5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKHBhdGgpIHtcblxuICAgIGlmIChwYXRoICYmXG4gICAgICAgIHBhdGguaW5kZXhPZignJScpICE9PSAtMSkge1xuXG4gICAgICAgIC8vIFVwcGVyY2FzZSAlZW5jb2RlZCB2YWx1ZXNcblxuICAgICAgICBjb25zdCB1cHBlcmNhc2UgPSBwYXRoLnJlcGxhY2UoLyVbMC05YS1mQS1GXVswLTlhLWZBLUZdL2csIChlbmNvZGVkKSA9PiBlbmNvZGVkLnRvVXBwZXJDYXNlKCkpO1xuXG4gICAgICAgIC8vIERlY29kZSBub24tcmVzZXJ2ZWQgcGF0aCBjaGFyYWN0ZXJzOiBhLXogQS1aIDAtOSBfISQmJygpKissOz06QC0uflxuICAgICAgICAvLyAhICglMjEpICQgKCUyNCkgJiAoJTI2KSAnICglMjcpICggKCUyOCkgKSAoJTI5KSAqICglMkEpICsgKCUyQikgLCAoJTJDKSAtICglMkQpIC4gKCUyRSlcbiAgICAgICAgLy8gMC05ICglMzAtMzkpIDogKCUzQSkgOyAoJTNCKSA9ICglM0QpXG4gICAgICAgIC8vIEAgKCU0MCkgQS1aICglNDEtNUEpIF8gKCU1RikgYS16ICglNjEtN0EpIH4gKCU3RSlcblxuICAgICAgICBjb25zdCBkZWNvZGVkID0gdXBwZXJjYXNlLnJlcGxhY2UoLyUoPzoyWzE0Ni05QS1FXXwzW1xcZEFCRF18NFtcXGRBLUZdfDVbXFxkQUZdfDZbMS05QS1GXXw3W1xcZEFFXSkvZywgKGVuY29kZWQpID0+IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZW5jb2RlZC5zdWJzdHJpbmcoMSksIDE2KSkpO1xuXG4gICAgICAgIHBhdGggPSBkZWNvZGVkO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBwYXRoIHNlZ21lbnRzXG5cbiAgICBpZiAocGF0aCAmJlxuICAgICAgICAocGF0aC5pbmRleE9mKCcvLicpICE9PSAtMSB8fCBwYXRoWzBdID09PSAnLicpKSB7XG5cbiAgICAgICAgY29uc3QgaGFzTGVhZGluZ0Rhc2ggPSBwYXRoWzBdID09PSAnLyc7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgICAgIGxldCBzZWdtZW50O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdtZW50ID09PSAnLicgfHxcbiAgICAgICAgICAgIHNlZ21lbnQgPT09ICcuLicpIHsgICAgICAgICAvLyBBZGQgdHJhaWxpbmcgc2xhc2ggd2hlbiBuZWVkZWRcblxuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBub3JtYWxpemVkLmpvaW4oJy8nKTtcblxuICAgICAgICBpZiAocGF0aFswXSAhPT0gJy8nICYmXG4gICAgICAgICAgICBoYXNMZWFkaW5nRGFzaCkge1xuXG4gICAgICAgICAgICBwYXRoID0gJy8nICsgcGF0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufTtcblxuXG5pbnRlcm5hbHMuUm91dGVyLnByb3RvdHlwZS5hbmFseXplID0gZnVuY3Rpb24gKHBhdGgpIHtcblxuICAgIEhvZWsuYXNzZXJ0KGludGVybmFscy5wYXRoUmVnZXgudmFsaWRhdGVQYXRoLnRlc3QocGF0aCksICdJbnZhbGlkIHBhdGg6JywgcGF0aCk7XG4gICAgSG9lay5hc3NlcnQoIWludGVybmFscy5wYXRoUmVnZXgudmFsaWRhdGVQYXRoRW5jb2RlZC50ZXN0KHBhdGgpLCAnUGF0aCBjYW5ub3QgY29udGFpbiBlbmNvZGVkIG5vbi1yZXNlcnZlZCBwYXRoIGNoYXJhY3RlcnM6JywgcGF0aCk7XG5cbiAgICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBjb25zdCBmaW5nZXJzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhdGhQYXJ0cy5sZW5ndGg7ICsraSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGZpcnN0IGVtcHR5IHNlZ21lbnRcbiAgICAgICAgbGV0IHNlZ21lbnQgPSBwYXRoUGFydHNbaV07XG5cbiAgICAgICAgLy8gTGl0ZXJhbFxuXG4gICAgICAgIGlmIChzZWdtZW50LmluZGV4T2YoJ3snKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSB0aGlzLnNldHRpbmdzLmlzQ2FzZVNlbnNpdGl2ZSA/IHNlZ21lbnQgOiBzZWdtZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmaW5nZXJzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICBzZWdtZW50cy5wdXNoKHsgbGl0ZXJhbDogc2VnbWVudCB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyYW1ldGVyXG5cbiAgICAgICAgY29uc3QgcGFydHMgPSBpbnRlcm5hbHMucGFyc2VQYXJhbXMoc2VnbWVudCk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEpIHtcblxuICAgICAgICAgICAgLy8gU2ltcGxlIHBhcmFtZXRlclxuXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gcGFydHNbMF07XG4gICAgICAgICAgICBIb2VrLmFzc2VydChwYXJhbXMuaW5kZXhPZihpdGVtLm5hbWUpID09PSAtMSwgJ0Nhbm5vdCByZXBlYXQgdGhlIHNhbWUgcGFyYW1ldGVyIG5hbWU6JywgaXRlbS5uYW1lLCAnaW46JywgcGF0aCk7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChpdGVtLm5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS53aWxjYXJkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpdGVtLmNvdW50OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnMucHVzaCgnPycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGl0ZW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnMucHVzaCgnIycpO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHsgd2lsZGNhcmQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluZ2Vycy5wdXNoKCc/Jyk7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7IGVtcHR5OiBpdGVtLmVtcHR5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBNaXhlZCBwYXJhbWV0ZXJcblxuICAgICAgICAgICAgY29uc3Qgc2VnID0ge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogcGFydHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGZpcnN0OiB0eXBlb2YgcGFydHNbMF0gIT09ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbGV0IGZpbmdlciA9ICcnO1xuICAgICAgICAgICAgbGV0IHJlZ2V4ID0gJ14nO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tqXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmdlciA9IGZpbmdlciArIHBhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gcmVnZXggKyBIb2VrLmVzY2FwZVJlZ2V4KHBhcnQpO1xuICAgICAgICAgICAgICAgICAgICBzZWcuc2VnbWVudHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHBhcmFtcy5pbmRleE9mKHBhcnQubmFtZSkgPT09IC0xLCAnQ2Fubm90IHJlcGVhdCB0aGUgc2FtZSBwYXJhbWV0ZXIgbmFtZTonLCBwYXJ0Lm5hbWUsICdpbjonLCBwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFydC5uYW1lKTtcblxuICAgICAgICAgICAgICAgICAgICBmaW5nZXIgPSBmaW5nZXIgKyAnPyc7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4ID0gcmVnZXggKyAnKC4nICsgKHBhcnQuZW1wdHkgPyAnKicgOiAnKycpICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VnLm1peGVkID0gbmV3IFJlZ0V4cChyZWdleCArICckJywgKCF0aGlzLnNldHRpbmdzLmlzQ2FzZVNlbnNpdGl2ZSA/ICdpJyA6ICcnKSk7XG4gICAgICAgICAgICBmaW5nZXJzLnB1c2goZmluZ2VyKTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICBmaW5nZXJwcmludDogJy8nICsgZmluZ2Vycy5qb2luKCcvJyksXG4gICAgICAgIHBhcmFtc1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5wYXJzZVBhcmFtcyA9IGZ1bmN0aW9uIChzZWdtZW50KSB7XG5cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIHNlZ21lbnQucmVwbGFjZShpbnRlcm5hbHMucGF0aFJlZ2V4LnBhcnNlUGFyYW0sIChtYXRjaCwgbGl0ZXJhbCwgbmFtZSwgd2lsY2FyZCwgY291bnQsIGVtcHR5KSA9PiB7XG5cbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gobGl0ZXJhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHdpbGNhcmQ6ICEhd2lsY2FyZCxcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQgJiYgcGFyc2VJbnQoY291bnQsIDEwKSxcbiAgICAgICAgICAgICAgICBlbXB0eTogISFlbXB0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFydHM7XG59O1xuXG5cbmludGVybmFscy5Sb3V0ZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24gKGhvc3QpIHtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGNvbGxlY3QgPSAodGFibGUpID0+IHtcblxuICAgICAgICBpZiAoIXRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyh0YWJsZSkuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG5cbiAgICAgICAgICAgIHRhYmxlW21ldGhvZF0ucm91dGVzLmZvckVhY2goKHJlY29yZCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVjb3JkLnJvdXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudmhvc3RzKSB7XG4gICAgICAgIGNvbnN0IHZob3N0cyA9IGhvc3QgPyBbXS5jb25jYXQoaG9zdCkgOiBPYmplY3Qua2V5cyh0aGlzLnZob3N0cyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmhvc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb2xsZWN0KHRoaXMudmhvc3RzW3Zob3N0c1tpXV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29sbGVjdCh0aGlzLnJvdXRlcyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5pbnRlcm5hbHMuc29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBjb25zdCBhRmlyc3QgPSAtMTtcbiAgICBjb25zdCBiRmlyc3QgPSAxO1xuXG4gICAgY29uc3QgYXMgPSBhLnNlZ21lbnRzO1xuICAgIGNvbnN0IGJzID0gYi5zZWdtZW50cztcblxuICAgIGlmIChhcy5sZW5ndGggIT09IGJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gKGFzLmxlbmd0aCA+IGJzLmxlbmd0aCA/IGJGaXJzdCA6IGFGaXJzdCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IDsgKytpKSB7XG4gICAgICAgIGlmIChhc1tpXS5saXRlcmFsKSB7XG4gICAgICAgICAgICBpZiAoYnNbaV0ubGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChhc1tpXS5saXRlcmFsID09PSBic1tpXS5saXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAoYXNbaV0ubGl0ZXJhbCA+IGJzW2ldLmxpdGVyYWwgPyBiRmlyc3QgOiBhRmlyc3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYUZpcnN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJzW2ldLmxpdGVyYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBiRmlyc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGFzW2ldLndpbGRjYXJkID8gYkZpcnN0IDogYUZpcnN0KTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmdlbmVyYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLypcbiAgICAgICAgL3BhdGgve3BhcmFtfS9wYXRoL3twYXJhbT99XG4gICAgICAgIC9wYXRoL3twYXJhbSoyfS9wYXRoXG4gICAgICAgIC9wYXRoL3twYXJhbSoyfVxuICAgICAgICAvcGF0aC94e3BhcmFtfXhcbiAgICAgICAgL3twYXJhbSp9XG4gICAgKi9cblxuICAgIGNvbnN0IGVtcHR5ID0gJyg/Ol5cXFxcLyQpJztcblxuICAgIGNvbnN0IGxlZ2FsQ2hhcnMgPSAnW1xcXFx3XFxcXCFcXFxcJCZcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsO1xcXFw9XFxcXDpAXFxcXC1cXFxcLn5dJztcbiAgICBjb25zdCBlbmNvZGVkID0gJyVbQS1GMC05XXsyfSc7XG5cbiAgICBjb25zdCBsaXRlcmFsQ2hhciA9ICcoPzonICsgbGVnYWxDaGFycyArICd8JyArIGVuY29kZWQgKyAnKSc7XG4gICAgY29uc3QgbGl0ZXJhbCA9IGxpdGVyYWxDaGFyICsgJysnO1xuICAgIGNvbnN0IGxpdGVyYWxPcHRpb25hbCA9IGxpdGVyYWxDaGFyICsgJyonO1xuXG4gICAgY29uc3QgbWlkUGFyYW0gPSAnKD86XFxcXHtcXFxcdysoPzpcXFxcKlsxLTldXFxcXGQqKT9cXFxcfSknOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB7cH0sIHtwKjJ9XG4gICAgY29uc3QgZW5kUGFyYW0gPSAnKD86XFxcXC8oPzpcXFxce1xcXFx3Kyg/Oig/OlxcXFwqKD86WzEtOV1cXFxcZCopPyl8KD86XFxcXD8pKT9cXFxcfSk/KT8nOyAgICAgLy8ge3B9LCB7cCoyfSwge3AqfSwge3A/fVxuXG4gICAgY29uc3QgcGFydGlhbFBhcmFtID0gJyg/OlxcXFx7XFxcXHcrXFxcXD8/XFxcXH0pJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ge3B9LCB7cD99XG4gICAgY29uc3QgbWl4ZWRQYXJhbSA9ICcoPzooPzonICsgbGl0ZXJhbCArIHBhcnRpYWxQYXJhbSArICcpKycgKyBsaXRlcmFsT3B0aW9uYWwgKyAnKXwoPzonICsgcGFydGlhbFBhcmFtICsgJyg/OicgKyBsaXRlcmFsICsgcGFydGlhbFBhcmFtICsgJykrJyArIGxpdGVyYWxPcHRpb25hbCArICcpfCg/OicgKyBwYXJ0aWFsUGFyYW0gKyBsaXRlcmFsICsgJyknO1xuXG4gICAgY29uc3Qgc2VnbWVudENvbnRlbnQgPSAnKD86JyArIGxpdGVyYWwgKyAnfCcgKyBtaWRQYXJhbSArICd8JyArIG1peGVkUGFyYW0gKyAnKSc7XG4gICAgY29uc3Qgc2VnbWVudCA9ICdcXFxcLycgKyBzZWdtZW50Q29udGVudDtcbiAgICBjb25zdCBzZWdtZW50cyA9ICcoPzonICsgc2VnbWVudCArICcpKic7XG5cbiAgICBjb25zdCBwYXRoID0gJyg/Ol4nICsgc2VnbWVudHMgKyBlbmRQYXJhbSArICckKSc7XG5cbiAgICAvLyAgICAgICAgICAgICAgICAxOmxpdGVyYWwgICAgICAgICAgICAgICAyOm5hbWUgICAzOiogIDQ6Y291bnQgIDU6P1xuICAgIGNvbnN0IHBhcnNlUGFyYW0gPSAnKCcgKyBsaXRlcmFsICsgJyl8KD86XFxcXHsoXFxcXHcrKSg/OihcXFxcKikoXFxcXGQrKT8pPyhcXFxcPyk/XFxcXH0pJztcblxuICAgIGNvbnN0IGV4cHJlc3Npb25zID0ge1xuICAgICAgICBwYXJzZVBhcmFtOiBuZXcgUmVnRXhwKHBhcnNlUGFyYW0sICdnJyksXG4gICAgICAgIHZhbGlkYXRlUGF0aDogbmV3IFJlZ0V4cChlbXB0eSArICd8JyArIHBhdGgpLFxuICAgICAgICB2YWxpZGF0ZVBhdGhFbmNvZGVkOiAvJSg/OjJbMTQ2LTlBLUVdfDNbXFxkQUJEXXw0W1xcZEEtRl18NVtcXGRBRl18NlsxLTlBLUZdfDdbXFxkQUVdKS9nXG4gICAgfTtcblxuICAgIHJldHVybiBleHByZXNzaW9ucztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl9lZGdlID0gbnVsbDsgICAgICAgICAgICAgIC8vIHsgc2VnbWVudCwgcmVjb3JkIH1cbiAgICB0aGlzLl9mdWxscyA9IG51bGw7ICAgICAgICAgICAgIC8vIHsgcGF0aDogeyBzZWdtZW50LCByZWNvcmQgfVxuICAgIHRoaXMuX2xpdGVyYWxzID0gbnVsbDsgICAgICAgICAgLy8geyBsaXRlcmFsOiB7IHNlZ21lbnQsIDxub2RlPiB9IH1cbiAgICB0aGlzLl9wYXJhbSA9IG51bGw7ICAgICAgICAgICAgIC8vIDxub2RlPlxuICAgIHRoaXMuX21peGVkID0gbnVsbDsgICAgICAgICAgICAgLy8gW3sgc2VnbWVudCwgPG5vZGU+IH1dXG4gICAgdGhpcy5fd2lsZGNhcmQgPSBudWxsOyAgICAgICAgICAvLyB7IHNlZ21lbnQsIHJlY29yZCB9XG59O1xuXG5cbmludGVybmFscy5TZWdtZW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoc2VnbWVudHMsIHJlY29yZCkge1xuXG4gICAgLypcbiAgICAgICAgeyBsaXRlcmFsOiAneCcgfSAgICAgICAgLT4geFxuICAgICAgICB7IGVtcHR5OiBmYWxzZSB9ICAgICAgICAtPiB7cH1cbiAgICAgICAgeyB3aWxkY2FyZDogdHJ1ZSB9ICAgICAgLT4ge3AqfVxuICAgICAgICB7IG1peGVkOiAvcmVnZXgvIH0gICAgICAtPiBhe3B9YlxuICAgICovXG5cbiAgICBjb25zdCBjdXJyZW50ID0gc2VnbWVudHNbMF07XG4gICAgY29uc3QgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoMSk7XG4gICAgY29uc3QgaXNFZGdlID0gIXJlbWFpbmluZy5sZW5ndGg7XG5cbiAgICBjb25zdCBsaXRlcmFscyA9IFtdO1xuICAgIGxldCBpc0xpdGVyYWwgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoICYmIGlzTGl0ZXJhbDsgKytpKSB7XG4gICAgICAgIGlzTGl0ZXJhbCA9IHNlZ21lbnRzW2ldLmxpdGVyYWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGl0ZXJhbHMucHVzaChzZWdtZW50c1tpXS5saXRlcmFsKTtcbiAgICB9XG5cbiAgICBpZiAoaXNMaXRlcmFsKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxzID0gdGhpcy5fZnVsbHMgfHwge307XG4gICAgICAgIGxldCBsaXRlcmFsID0gJy8nICsgbGl0ZXJhbHMuam9pbignLycpO1xuICAgICAgICBpZiAoIXJlY29yZC5zZXR0aW5ncy5pc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIGxpdGVyYWwgPSBsaXRlcmFsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5fZnVsbHNbbGl0ZXJhbF0sICdOZXcgcm91dGUnLCByZWNvcmQucGF0aCwgJ2NvbmZsaWN0cyB3aXRoIGV4aXN0aW5nJywgdGhpcy5fZnVsbHNbbGl0ZXJhbF0gJiYgdGhpcy5fZnVsbHNbbGl0ZXJhbF0ucmVjb3JkLnBhdGgpO1xuICAgICAgICB0aGlzLl9mdWxsc1tsaXRlcmFsXSA9IHsgc2VnbWVudDogY3VycmVudCwgcmVjb3JkIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbnQubGl0ZXJhbCAhPT0gdW5kZWZpbmVkKSB7ICAgICAgICAgICAgICAgLy8gQ2FuIGJlIGVtcHR5IHN0cmluZ1xuXG4gICAgICAgIC8vIExpdGVyYWxcblxuICAgICAgICB0aGlzLl9saXRlcmFscyA9IHRoaXMuX2xpdGVyYWxzIHx8IHt9O1xuICAgICAgICBjb25zdCBjdXJyZW50TGl0ZXJhbCA9IChyZWNvcmQuc2V0dGluZ3MuaXNDYXNlU2Vuc2l0aXZlID8gY3VycmVudC5saXRlcmFsIDogY3VycmVudC5saXRlcmFsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB0aGlzLl9saXRlcmFsc1tjdXJyZW50TGl0ZXJhbF0gPSB0aGlzLl9saXRlcmFsc1tjdXJyZW50TGl0ZXJhbF0gfHwgbmV3IGludGVybmFscy5TZWdtZW50KCk7XG4gICAgICAgIHRoaXMuX2xpdGVyYWxzW2N1cnJlbnRMaXRlcmFsXS5hZGQocmVtYWluaW5nLCByZWNvcmQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW50LndpbGRjYXJkKSB7XG5cbiAgICAgICAgLy8gV2lsZGNhcmRcblxuICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5fd2lsZGNhcmQsICdOZXcgcm91dGUnLCByZWNvcmQucGF0aCwgJ2NvbmZsaWN0cyB3aXRoIGV4aXN0aW5nJywgdGhpcy5fd2lsZGNhcmQgJiYgdGhpcy5fd2lsZGNhcmQucmVjb3JkLnBhdGgpO1xuICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5fcGFyYW0gfHwgIXRoaXMuX3BhcmFtLl93aWxkY2FyZCwgJ05ldyByb3V0ZScsIHJlY29yZC5wYXRoLCAnY29uZmxpY3RzIHdpdGggZXhpc3RpbmcnLCB0aGlzLl9wYXJhbSAmJiB0aGlzLl9wYXJhbS5fd2lsZGNhcmQgJiYgdGhpcy5fcGFyYW0uX3dpbGRjYXJkLnJlY29yZC5wYXRoKTtcbiAgICAgICAgdGhpcy5fd2lsZGNhcmQgPSB7IHNlZ21lbnQ6IGN1cnJlbnQsIHJlY29yZCB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJyZW50Lm1peGVkKSB7XG5cbiAgICAgICAgLy8gTWl4ZWRcblxuICAgICAgICB0aGlzLl9taXhlZCA9IHRoaXMuX21peGVkIHx8IFtdO1xuXG4gICAgICAgIGxldCBtaXhlZCA9IHRoaXMuX21peGVkTG9va3VwKGN1cnJlbnQpO1xuICAgICAgICBpZiAoIW1peGVkKSB7XG4gICAgICAgICAgICBtaXhlZCA9IHsgc2VnbWVudDogY3VycmVudCwgbm9kZTogbmV3IGludGVybmFscy5TZWdtZW50KCkgfTtcbiAgICAgICAgICAgIHRoaXMuX21peGVkLnB1c2gobWl4ZWQpO1xuICAgICAgICAgICAgdGhpcy5fbWl4ZWQuc29ydChpbnRlcm5hbHMubWl4ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIW1peGVkLm5vZGUuX2VkZ2UsICdOZXcgcm91dGUnLCByZWNvcmQucGF0aCwgJ2NvbmZsaWN0cyB3aXRoIGV4aXN0aW5nJywgbWl4ZWQubm9kZS5fZWRnZSAmJiBtaXhlZC5ub2RlLl9lZGdlLnJlY29yZC5wYXRoKTtcbiAgICAgICAgICAgIG1peGVkLm5vZGUuX2VkZ2UgPSB7IHNlZ21lbnQ6IGN1cnJlbnQsIHJlY29yZCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWl4ZWQubm9kZS5hZGQocmVtYWluaW5nLCByZWNvcmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIC8vIFBhcmFtZXRlclxuXG4gICAgICAgIHRoaXMuX3BhcmFtID0gdGhpcy5fcGFyYW0gfHwgbmV3IGludGVybmFscy5TZWdtZW50KCk7XG5cbiAgICAgICAgaWYgKGlzRWRnZSkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIXRoaXMuX3BhcmFtLl9lZGdlLCAnTmV3IHJvdXRlJywgcmVjb3JkLnBhdGgsICdjb25mbGljdHMgd2l0aCBleGlzdGluZycsIHRoaXMuX3BhcmFtLl9lZGdlICYmIHRoaXMuX3BhcmFtLl9lZGdlLnJlY29yZC5wYXRoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtLl9lZGdlID0geyBzZWdtZW50OiBjdXJyZW50LCByZWNvcmQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCF0aGlzLl93aWxkY2FyZCB8fCAhcmVtYWluaW5nWzBdLndpbGRjYXJkLCAnTmV3IHJvdXRlJywgcmVjb3JkLnBhdGgsICdjb25mbGljdHMgd2l0aCBleGlzdGluZycsIHRoaXMuX3dpbGRjYXJkICYmIHRoaXMuX3dpbGRjYXJkLnJlY29yZC5wYXRoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmFtLmFkZChyZW1haW5pbmcsIHJlY29yZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5TZWdtZW50LnByb3RvdHlwZS5fbWl4ZWRMb29rdXAgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9taXhlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoaW50ZXJuYWxzLm1peGVkKHsgc2VnbWVudCB9LCB0aGlzLl9taXhlZFtpXSkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taXhlZFtpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuXG5pbnRlcm5hbHMubWl4ZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgY29uc3QgYUZpcnN0ID0gLTE7XG4gICAgY29uc3QgYkZpcnN0ID0gMTtcblxuICAgIGNvbnN0IGFzID0gYS5zZWdtZW50O1xuICAgIGNvbnN0IGJzID0gYi5zZWdtZW50O1xuXG4gICAgaWYgKGFzLmxlbmd0aCAhPT0gYnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAoYXMubGVuZ3RoID4gYnMubGVuZ3RoID8gYUZpcnN0IDogYkZpcnN0KTtcbiAgICB9XG5cbiAgICBpZiAoYXMuZmlyc3QgIT09IGJzLmZpcnN0KSB7XG4gICAgICAgIHJldHVybiAoYXMuZmlyc3QgPyBiRmlyc3QgOiBhRmlyc3QpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXMuc2VnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYW0gPSBhcy5zZWdtZW50c1tpXTtcbiAgICAgICAgY29uc3QgYm0gPSBicy5zZWdtZW50c1tpXTtcblxuICAgICAgICBpZiAoYW0gPT09IGJtKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbS5sZW5ndGggPT09IGJtLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChhbSA+IGJtID8gYkZpcnN0IDogYUZpcnN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoYW0ubGVuZ3RoIDwgYm0ubGVuZ3RoID8gYkZpcnN0IDogYUZpcnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn07XG5cblxuaW50ZXJuYWxzLlNlZ21lbnQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChwYXRoLCBzZWdtZW50cywgb3B0aW9ucykge1xuXG4gICAgbGV0IG1hdGNoID0gbnVsbDtcblxuICAgIC8vIExpdGVyYWwgZWRnZVxuXG4gICAgaWYgKHRoaXMuX2Z1bGxzKSB7XG4gICAgICAgIG1hdGNoID0gdGhpcy5fZnVsbHNbb3B0aW9ucy5pc0Nhc2VTZW5zaXRpdmUgPyBwYXRoIDogcGF0aC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZWNvcmQ6IG1hdGNoLnJlY29yZCwgYXJyYXk6IFtdIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMaXRlcmFsIG5vZGVcblxuICAgIGNvbnN0IGN1cnJlbnQgPSBzZWdtZW50c1swXTtcbiAgICBjb25zdCBuZXh0UGF0aCA9IHBhdGguc2xpY2UoY3VycmVudC5sZW5ndGggKyAxKTtcbiAgICBjb25zdCByZW1haW5kZXIgPSAoc2VnbWVudHMubGVuZ3RoID4gMSA/IHNlZ21lbnRzLnNsaWNlKDEpIDogbnVsbCk7XG5cbiAgICBpZiAodGhpcy5fbGl0ZXJhbHMpIHtcbiAgICAgICAgY29uc3QgbGl0ZXJhbCA9IG9wdGlvbnMuaXNDYXNlU2Vuc2l0aXZlID8gY3VycmVudCA6IGN1cnJlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbWF0Y2ggPSB0aGlzLl9saXRlcmFscy5oYXNPd25Qcm9wZXJ0eShsaXRlcmFsKSAmJiB0aGlzLl9saXRlcmFsc1tsaXRlcmFsXTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCByZWNvcmQgPSBpbnRlcm5hbHMuZGVlcGVyKG1hdGNoLCBuZXh0UGF0aCwgcmVtYWluZGVyLCBbXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1peGVkXG5cbiAgICBpZiAodGhpcy5fbWl4ZWQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9taXhlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLl9taXhlZFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGN1cnJlbnQubWF0Y2gobWF0Y2guc2VnbWVudC5taXhlZCk7XG4gICAgICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHBhcmFtcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHBhcmFtc1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gaW50ZXJuYWxzLmRlZXBlcihtYXRjaC5ub2RlLCBuZXh0UGF0aCwgcmVtYWluZGVyLCBhcnJheSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFBhcmFtXG5cbiAgICBpZiAodGhpcy5fcGFyYW0pIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgfHxcbiAgICAgICAgICAgICh0aGlzLl9wYXJhbS5fZWRnZSAmJiB0aGlzLl9wYXJhbS5fZWRnZS5zZWdtZW50LmVtcHR5KSkge1xuXG4gICAgICAgICAgICBjb25zdCByZWNvcmQgPSBpbnRlcm5hbHMuZGVlcGVyKHRoaXMuX3BhcmFtLCBuZXh0UGF0aCwgcmVtYWluZGVyLCBbY3VycmVudF0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaWxkY2FyZFxuXG4gICAgaWYgKHRoaXMuX3dpbGRjYXJkKSB7XG4gICAgICAgIHJldHVybiB7IHJlY29yZDogdGhpcy5fd2lsZGNhcmQucmVjb3JkLCBhcnJheTogW3BhdGguc2xpY2UoMSldIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5kZWVwZXIgPSBmdW5jdGlvbiAobWF0Y2gsIHBhdGgsIHNlZ21lbnRzLCBhcnJheSwgb3B0aW9ucykge1xuXG4gICAgaWYgKCFzZWdtZW50cykge1xuICAgICAgICBpZiAobWF0Y2guX2VkZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlY29yZDogbWF0Y2guX2VkZ2UucmVjb3JkLCBhcnJheSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoLl93aWxkY2FyZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVjb3JkOiBtYXRjaC5fd2lsZGNhcmQucmVjb3JkLCBhcnJheSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBtYXRjaC5sb29rdXAocGF0aCwgc2VnbWVudHMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4geyByZWNvcmQ6IHJlc3VsdC5yZWNvcmQsIGFycmF5OiBhcnJheS5jb25jYXQocmVzdWx0LmFycmF5KSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWF4VGltZXI6IDIxNDc0ODM2NDcsICAgLy8gMiBeIDMxIC0gMVxuICAgIGVudHJ5U2l6ZTogMTQ0ICAgICAgICAgIC8vIEFwcHJveGltYXRlIGNhY2hlIGVudHJ5IHNpemUgd2l0aG91dCB2YWx1ZTogMTQ0IGJ5dGVzXG59O1xuXG5cbmludGVybmFscy5kZWZhdWx0cyA9IHtcbiAgICBtYXhCeXRlU2l6ZTogMTAwICogMTAyNCAqIDEwMjQsICAgICAgICAgIC8vIDEwME1CXG4gICAgbWluQ2xlYW51cEludGVydmFsTXNlYzogMTAwMCxcbiAgICBjbG9uZUJ1ZmZlcnNPbkdldDogZmFsc2Vcbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkNvbm5lY3Rpb24gPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLmNvbnN0cnVjdG9yID09PSBpbnRlcm5hbHMuQ29ubmVjdGlvbiwgJ01lbW9yeSBjYWNoZSBjbGllbnQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgdXNpbmcgbmV3Jyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMubWF4Qnl0ZVNpemUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heEJ5dGVTaXplID49IDAsICdJbnZhbGlkIGNhY2hlIG1heEJ5dGVTaXplIHZhbHVlJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMuYWxsb3dNaXhlZENvbnRlbnQgPT09IHVuZGVmaW5lZCwgJ2FsbG93TWl4ZWRDb250ZW50IG5vIGxvbmdlciBzdXBwb3J0ZWQnKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5taW5DbGVhbnVwSW50ZXJ2YWxNc2VjID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5taW5DbGVhbnVwSW50ZXJ2YWxNc2VjIDwgaW50ZXJuYWxzLm1heFRpbWVyLCAnSW52YWxpZCBjYWNoZSBtaW5DbGVhbnVwSW50ZXJ2YWxNc2VjIHZhbHVlJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMuY2xvbmVCdWZmZXJzT25HZXQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucy5jbG9uZUJ1ZmZlcnNPbkdldCA9PT0gJ2Jvb2xlYW4nLCAnSW52YWxpZCBjbG9uZUJ1ZmZlcnNPbkdldCB2YWx1ZScpO1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNhY2hlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpbWVyRHVlID0gbnVsbDtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmJ5dGVTaXplID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zY2hlZHVsZUNsZWFudXAobXNlYykge1xuXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyRHVlID0gbnVsbDtcblxuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHNlZ21lbnRdIG9mIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZW52ZWxvcGVdIG9mIHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHRsID0gZW52ZWxvcGUuc3RvcmVkICsgZW52ZWxvcGUudHRsIC0gbm93O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHRsIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgLT0gZW52ZWxvcGUuYnl0ZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gTWF0aC5taW4obmV4dCwgdHRsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHQgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVDbGVhbnVwKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLnNldHRpbmdzLm1pbkNsZWFudXBJbnRlcnZhbE1zZWMsIG1zZWMpLCBpbnRlcm5hbHMubWF4VGltZXIpO1xuICAgICAgICBpZiAodGhpcy5fdGltZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90aW1lckR1ZSAtIG5vdyA8IG1zZWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90aW1lckR1ZSA9IG5vdyArIHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChjbGVhbnVwLCB0aW1lb3V0KTtcbiAgICB9XG5cbiAgICBzdG9wKCkge1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGltZXJEdWUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuY2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLmJ5dGVTaXplID0gMDtcbiAgICB9XG5cbiAgICBpc1JlYWR5KCkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMuY2FjaGU7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVTZWdtZW50TmFtZShuYW1lKSB7XG5cbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnRW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdcXHUwMDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnSW5jbHVkZXMgbnVsbCBjaGFyYWN0ZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcblxuICAgICAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb29tKCdDb25uZWN0aW9uIG5vdCBzdGFydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5jYWNoZS5nZXQoa2V5LnNlZ21lbnQpO1xuICAgICAgICBpZiAoIXNlZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBzZWdtZW50LmdldChrZXkuaWQpO1xuICAgICAgICBpZiAoIWVudmVsb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnZlbG9wZS5zdG9yZWQgKyBlbnZlbG9wZS50dGwgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICB0aGlzLmRyb3Aoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl0ZW0gPSBudWxsO1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVudmVsb3BlLml0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gZW52ZWxvcGUuaXRlbTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNsb25lQnVmZmVyc09uR2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29weSA9IEJ1ZmZlci5hbGxvYyhpdGVtLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaXRlbS5jb3B5KGNvcHkpO1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBjb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpdGVtID0gSlNPTi5wYXJzZShlbnZlbG9wZS5pdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnQmFkIHZhbHVlIGNvbnRlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBzdG9yZWQ6IGVudmVsb3BlLnN0b3JlZCxcbiAgICAgICAgICAgIHR0bDogZW52ZWxvcGUudHRsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSwgdHRsKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnQ29ubmVjdGlvbiBub3Qgc3RhcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBuZXcgaW50ZXJuYWxzLk1lbW9yeUNhY2hlRW50cnkoa2V5LCB2YWx1ZSwgdHRsKTtcblxuICAgICAgICBsZXQgc2VnbWVudCA9IHRoaXMuY2FjaGUuZ2V0KGtleS5zZWdtZW50KTtcbiAgICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgICAgICBzZWdtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LnNlZ21lbnQsIHNlZ21lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2FjaGVkSXRlbSA9IHNlZ21lbnQuZ2V0KGtleS5pZCk7XG4gICAgICAgIGlmIChjYWNoZWRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVTaXplIC09IGNhY2hlZEl0ZW0uYnl0ZVNpemU7ICAgICAgIC8vIElmIHRoZSBpdGVtIGV4aXN0ZWQsIGRlY3JlbWVudCB0aGUgYnl0ZVNpemUgYXMgdGhlIHZhbHVlIGNvdWxkIGJlIGRpZmZlcmVudFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4Qnl0ZVNpemUgJiZcbiAgICAgICAgICAgICh0aGlzLmJ5dGVTaXplICsgZW52ZWxvcGUuYnl0ZVNpemUgPiB0aGlzLnNldHRpbmdzLm1heEJ5dGVTaXplKSkge1xuXG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnQ2FjaGUgc2l6ZSBsaW1pdCByZWFjaGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zY2hlZHVsZUNsZWFudXAodHRsKTtcbiAgICAgICAgc2VnbWVudC5zZXQoa2V5LmlkLCBlbnZlbG9wZSk7XG4gICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gZW52ZWxvcGUuYnl0ZVNpemU7XG4gICAgfVxuXG4gICAgZHJvcChrZXkpIHtcblxuICAgICAgICBpZiAoIXRoaXMuY2FjaGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb29tKCdDb25uZWN0aW9uIG5vdCBzdGFydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5jYWNoZS5nZXQoa2V5LnNlZ21lbnQpO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHNlZ21lbnQuZ2V0KGtleS5pZCk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgLT0gaXRlbS5ieXRlU2l6ZTtcbiAgICAgICAgICAgICAgICBzZWdtZW50LmRlbGV0ZShrZXkuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuTWVtb3J5Q2FjaGVFbnRyeSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIHR0bCkge1xuXG4gICAgICAgIGxldCB2YWx1ZUJ5dGVTaXplID0gMDtcblxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtID0gQnVmZmVyLmFsbG9jKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB2YWx1ZS5jb3B5KHRoaXMuaXRlbSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgYnVmZmVyIHRvIHByZXZlbnQgdmFsdWUgZnJvbSBjaGFuZ2luZyB3aGlsZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgICAgIHZhbHVlQnl0ZVNpemUgPSB0aGlzLml0ZW0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pdGVtID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpOyAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmdpZnkoKSB0byBwcmV2ZW50IHZhbHVlIGZyb20gY2hhbmdpbmcgd2hpbGUgaW4gdGhlIGNhY2hlXG4gICAgICAgICAgICB2YWx1ZUJ5dGVTaXplID0gQnVmZmVyLmJ5dGVMZW5ndGgodGhpcy5pdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RvcmVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy50dGwgPSB0dGw7XG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSBpbnRlcm5hbHMuZW50cnlTaXplICsgdmFsdWVCeXRlU2l6ZSArIEJ1ZmZlci5ieXRlTGVuZ3RoKGtleS5zZWdtZW50KSArIEJ1ZmZlci5ieXRlTGVuZ3RoKGtleS5pZCk7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdmFsaWRhdGU6IFN5bWJvbCgndmFsaWRhdGUnKVxufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdHMgPSB7XG4gICAgcGFydGl0aW9uOiAnY2F0Ym94J1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgb3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGVuZ2luZSwgJ01pc3NpbmcgY2F0Ym94IGNsaWVudCBlbmdpbmUnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGVuZ2luZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGVuZ2luZSA9PT0gJ2Z1bmN0aW9uJywgJ2VuZ2luZSBtdXN0IGJlIGFuIGVuZ2luZSBvYmplY3Qgb3IgZW5naW5lIHByb3RvdHlwZSAoZnVuY3Rpb24pJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBlbmdpbmUgPT09ICdmdW5jdGlvbicgfHwgIW9wdGlvbnMsICdDYW4gb25seSBzcGVjaWZ5IG9wdGlvbnMgd2l0aCBmdW5jdGlvbiBlbmdpbmUgY29uZmlnJyk7XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICBIb2VrLmFzc2VydChzZXR0aW5ncy5wYXJ0aXRpb24ubWF0Y2goL15bXFx3XFwtXSskLyksICdJbnZhbGlkIHBhcnRpdGlvbiBuYW1lOicgKyBzZXR0aW5ncy5wYXJ0aXRpb24pO1xuXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9ICh0eXBlb2YgZW5naW5lID09PSAnb2JqZWN0JyA/IGVuZ2luZSA6IG5ldyBlbmdpbmUoc2V0dGluZ3MpKTtcbiAgICB9XG5cbiAgICBhc3luYyBzdGFydCgpIHtcblxuICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uc3RhcnQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBzdG9wKCkge1xuXG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5zdG9wKCk7XG4gICAgfVxuXG4gICAgaXNSZWFkeSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmlzUmVhZHkoKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZVNlZ21lbnROYW1lKG5hbWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnZhbGlkYXRlU2VnbWVudE5hbWUobmFtZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0KGtleSkge1xuXG4gICAgICAgIHRoaXNbaW50ZXJuYWxzLnZhbGlkYXRlXShrZXksIG51bGwpO1xuXG4gICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmdldChrZXkpO1xuICAgICAgICBpZiAoIXJlc3VsdCB8fFxuICAgICAgICAgICAgcmVzdWx0Lml0ZW0gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgcmVzdWx0Lml0ZW0gPT09IG51bGwpIHtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGV4cGlyZXMgPSByZXN1bHQuc3RvcmVkICsgcmVzdWx0LnR0bDtcbiAgICAgICAgY29uc3QgdHRsID0gZXhwaXJlcyAtIG5vdztcbiAgICAgICAgaWYgKHR0bCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGlyZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IHtcbiAgICAgICAgICAgIGl0ZW06IHJlc3VsdC5pdGVtLFxuICAgICAgICAgICAgc3RvcmVkOiByZXN1bHQuc3RvcmVkLFxuICAgICAgICAgICAgdHRsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRcbiAgICB9XG5cbiAgICBhc3luYyBzZXQoa2V5LCB2YWx1ZSwgdHRsKSB7XG5cbiAgICAgICAgdGhpc1tpbnRlcm5hbHMudmFsaWRhdGVdKGtleSk7XG5cbiAgICAgICAgaWYgKHR0bCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBjYWNoYWJsZSAob3IgYmFkIHJ1bGVzKVxuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnNldChrZXksIHZhbHVlLCB0dGwpO1xuICAgIH1cblxuICAgIGFzeW5jIGRyb3Aoa2V5KSB7XG5cbiAgICAgICAgdGhpc1tpbnRlcm5hbHMudmFsaWRhdGVdKGtleSk7XG5cbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmRyb3Aoa2V5KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHdheXMgZHJvcCwgcmVnYXJkbGVzcyBvZiBjYWNoaW5nIHJ1bGVzXG4gICAgfVxuXG4gICAgW2ludGVybmFscy52YWxpZGF0ZV0oa2V5LCBhbGxvdyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5pbnRlcm5hbCgnRGlzY29ubmVjdGVkJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNjb25uZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzVmFsaWRLZXkgPSAoa2V5ICYmIHR5cGVvZiBrZXkuaWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LnNlZ21lbnQgJiYgdHlwZW9mIGtleS5zZWdtZW50ID09PSAnc3RyaW5nJyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkS2V5ICYmIGtleSAhPT0gYWxsb3cpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uaW50ZXJuYWwoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDbGllbnQgPSByZXF1aXJlKCcuL2NsaWVudCcpO1xuY29uc3QgUG9saWN5ID0gcmVxdWlyZSgnLi9wb2xpY3knKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcblxuXG5leHBvcnRzLlBvbGljeSA9IGV4cG9ydHMucG9saWN5ID0gUG9saWN5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihpZCwgcnVsZSkge1xuXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcblxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgam9pbigpIHtcblxuICAgICAgICArK3RoaXMuY291bnQ7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfVxuXG4gICAgc2VuZChlcnIsIHZhbHVlLCBjYWNoZWQsIHJlcG9ydCkge1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcik7XG5cbiAgICAgICAgaWYgKGVyciAmJlxuICAgICAgICAgICAgIWNhY2hlZCkge1xuXG4gICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnJ1bGUuZ2V0RGVjb3JhdGVkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXBvcnQuZXJyb3IgPSBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc29sdmUoeyB2YWx1ZSwgY2FjaGVkLCByZXBvcnQgfSk7XG4gICAgfVxuXG4gICAgc2V0VGltZW91dChmbiwgdGltZW91dE1zKSB7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZuLCB0aW1lb3V0TXMpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5jb25zdCBQb2RpdW0gPSByZXF1aXJlKCdAaGFwaS9wb2RpdW0nKTtcblxuY29uc3QgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBkYXk6IDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgZXZlbnRzOiBQb2RpdW0udmFsaWRhdGUoW1xuICAgICAgICB7IG5hbWU6ICdlcnJvcicsIGNoYW5uZWxzOiBbJ2dlbmVyYXRlJywgJ3BlcnNpc3QnXSB9XG4gICAgXSlcbn07XG5cblxuaW50ZXJuYWxzLnNjaGVtYSA9IEpvaS5vYmplY3Qoe1xuICAgIGV4cGlyZXNJbjogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMSksXG4gICAgZXhwaXJlc0F0OiBKb2kuc3RyaW5nKCkucmVnZXgoL15cXGRcXGQ/XFw6XFxkXFxkJC8pLFxuICAgIHN0YWxlSW46IFtcbiAgICAgICAgSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMSkud2hlbignZXhwaXJlc0F0JywgeyBpczogSm9pLnJlcXVpcmVkKCksIHRoZW46IEpvaS5udW1iZXIoKS5tYXgoODY0MDAwMDAgLSAxKSB9KSwgICAgICAgLy8gT25lIGRheSAtIDEgKG1heCBpcyBpbmNsdXNpdmUpXG4gICAgICAgIEpvaS5mdW5jKClcbiAgICBdLFxuICAgIHN0YWxlVGltZW91dDogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMSksXG4gICAgZ2VuZXJhdGVGdW5jOiBKb2kuZnVuYygpLFxuICAgIGdlbmVyYXRlVGltZW91dDogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMSkuYWxsb3coZmFsc2UpLFxuICAgIGdlbmVyYXRlT25SZWFkRXJyb3I6IEpvaS5ib29sZWFuKCksXG4gICAgZ2VuZXJhdGVJZ25vcmVXcml0ZUVycm9yOiBKb2kuYm9vbGVhbigpLFxuICAgIGRyb3BPbkVycm9yOiBKb2kuYm9vbGVhbigpLFxuICAgIHBlbmRpbmdHZW5lcmF0ZVRpbWVvdXQ6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKDEpLFxuICAgIGdldERlY29yYXRlZFZhbHVlOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuXG4gICAgLy8gSWdub3JlZCBleHRlcm5hbCBrZXlzIChoYXBpKVxuXG4gICAgcHJpdmFjeTogSm9pLmFueSgpLFxuICAgIGNhY2hlOiBKb2kuYW55KCksXG4gICAgc2VnbWVudDogSm9pLmFueSgpLFxuICAgIHNoYXJlZDogSm9pLmFueSgpXG59KVxuICAgIC53aXRob3V0KCdleHBpcmVzSW4nLCAnZXhwaXJlc0F0JylcbiAgICAud2l0aCgnc3RhbGVJbicsICdnZW5lcmF0ZUZ1bmMnKVxuICAgIC53aXRoKCdnZW5lcmF0ZU9uUmVhZEVycm9yJywgJ2dlbmVyYXRlRnVuYycpXG4gICAgLndpdGgoJ2dlbmVyYXRlSWdub3JlV3JpdGVFcnJvcicsICdnZW5lcmF0ZUZ1bmMnKVxuICAgIC53aXRoKCdkcm9wT25FcnJvcicsICdnZW5lcmF0ZUZ1bmMnKVxuICAgIC5hbmQoJ2dlbmVyYXRlRnVuYycsICdnZW5lcmF0ZVRpbWVvdXQnKVxuICAgIC5hbmQoJ3N0YWxlSW4nLCAnc3RhbGVUaW1lb3V0Jyk7XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlBvbGljeSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhY2hlLCBzZWdtZW50KSB7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ3MgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBpZCAtPiBQZW5kaW5nXG4gICAgICAgIHRoaXMuX3BlbmRpbmdHZW5lcmF0ZUNhbGwgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgLy8gaWQgLT4gdGltZXJcbiAgICAgICAgdGhpcy5ydWxlcyhvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnN0YXRzID0ge1xuICAgICAgICAgICAgc2V0czogMCxcbiAgICAgICAgICAgIGdldHM6IDAsXG4gICAgICAgICAgICBoaXRzOiAwLFxuICAgICAgICAgICAgc3RhbGVzOiAwLFxuICAgICAgICAgICAgZ2VuZXJhdGVzOiAwLFxuICAgICAgICAgICAgZXJyb3JzOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lRXJyID0gY2FjaGUudmFsaWRhdGVTZWdtZW50TmFtZShzZWdtZW50KTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KG5hbWVFcnIgPT09IG51bGwsICdJbnZhbGlkIHNlZ21lbnQgbmFtZTogJyArIHNlZ21lbnQgKyAobmFtZUVyciA/ICcgKCcgKyBuYW1lRXJyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuXG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBldmVudHMoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBQb2RpdW0oaW50ZXJuYWxzLmV2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzO1xuICAgIH1cblxuICAgIF9lcnJvcihzb3VyY2UsIGVycm9yKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2ZW50cy5lbWl0KHsgbmFtZTogJ2Vycm9yJywgY2hhbm5lbDogc291cmNlIH0sIHsgc291cmNlLCBlcnJvciB9KTtcbiAgICB9XG5cbiAgICBydWxlcyhvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5ydWxlID0gaW50ZXJuYWxzLlBvbGljeS5jb21waWxlKG9wdGlvbnMsICEhdGhpcy5fY2FjaGUpO1xuICAgIH1cblxuICAgIGFzeW5jIGdldChrZXkpIHsgICAgIC8vIGtleTogc3RyaW5nIG9yIHsgaWQ6ICdpZCcgfVxuXG4gICAgICAgICsrdGhpcy5zdGF0cy5nZXRzO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgYWxyZWFkeSBwZW5kaW5nXG5cbiAgICAgICAgY29uc3QgaWQgPSAoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSA/IGtleS5pZCA6IGtleTtcbiAgICAgICAgbGV0IHBlbmRpbmcgPSB0aGlzLl9wZW5kaW5ncy5nZXQoaWQpO1xuICAgICAgICBpZiAocGVuZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcGVuZGluZy5qb2luKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nID0gbmV3IFBlbmRpbmcoaWQsIHRoaXMucnVsZSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdzLnNldChpZCwgcGVuZGluZyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2dldChwZW5kaW5nLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmQocGVuZGluZywgZXJyKTsgICAgICAgICAgICAgICAvLyBTYWZlZ3VhcmQgdG8gZW5zdXJlIHRoYXQgdGhlIHBlbmRpbmcgcmVqZWN0cyBvbiBhbnkgcHJvY2Vzc2luZyBlcnJvcnNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwZW5kaW5nLnByb21pc2U7XG4gICAgfVxuXG4gICAgYXN5bmMgX2dldChwZW5kaW5nLCBrZXkpIHtcblxuICAgICAgICAvLyBQcmVwYXJlIHJlcG9ydFxuXG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IHt9O1xuXG4gICAgICAgIC8vIExvb2t1cCBpbiBjYWNoZVxuXG4gICAgICAgIGNvbnN0IHRpbWVyID0gbmV3IEhvZWsuQmVuY2goKTtcblxuICAgICAgICBsZXQgY2FjaGVkID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhY2hlZCA9IGF3YWl0IHRoaXMuX2NhY2hlLmdldCh7IHNlZ21lbnQ6IHRoaXMuX3NlZ21lbnQsIGlkOiBwZW5kaW5nLmlkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlcG9ydC5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICArK3RoaXMuc3RhdHMuZXJyb3JzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yKCdwZXJzaXN0JywgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlcG9ydC5tc2VjID0gdGltZXIuZWxhcHNlZCgpO1xuXG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJlcG9ydC5zdG9yZWQgPSBjYWNoZWQuc3RvcmVkO1xuICAgICAgICAgICAgcmVwb3J0LnR0bCA9IGNhY2hlZC50dGw7XG4gICAgICAgICAgICBjb25zdCBzdGFsZUluID0gdHlwZW9mIHRoaXMucnVsZS5zdGFsZUluID09PSAnZnVuY3Rpb24nID8gdGhpcy5ydWxlLnN0YWxlSW4oY2FjaGVkLnN0b3JlZCwgY2FjaGVkLnR0bCkgOiB0aGlzLnJ1bGUuc3RhbGVJbjtcbiAgICAgICAgICAgIGNhY2hlZC5pc1N0YWxlID0gKHN0YWxlSW4gPyAoRGF0ZS5ub3coKSAtIGNhY2hlZC5zdG9yZWQpID49IHN0YWxlSW4gOiBmYWxzZSk7XG4gICAgICAgICAgICByZXBvcnQuaXNTdGFsZSA9IGNhY2hlZC5pc1N0YWxlO1xuXG4gICAgICAgICAgICBpZiAoY2FjaGVkLmlzU3RhbGUpIHtcbiAgICAgICAgICAgICAgICArK3RoaXMuc3RhdHMuc3RhbGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm8gZ2VuZXJhdGUgbWV0aG9kXG5cbiAgICAgICAgaWYgKCF0aGlzLnJ1bGUuZ2VuZXJhdGVGdW5jIHx8XG4gICAgICAgICAgICAocmVwb3J0LmVycm9yICYmICF0aGlzLnJ1bGUuZ2VuZXJhdGVPblJlYWRFcnJvcikpIHtcblxuICAgICAgICAgICAgdGhpcy5fc2VuZChwZW5kaW5nLCByZXBvcnQuZXJyb3IsIGNhY2hlZCA/IGNhY2hlZC5pdGVtIDogbnVsbCwgY2FjaGVkLCByZXBvcnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZm91bmQgYW5kIGZyZXNoXG5cbiAgICAgICAgaWYgKGNhY2hlZCAmJlxuICAgICAgICAgICAgIWNhY2hlZC5pc1N0YWxlKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3NlbmQocGVuZGluZywgbnVsbCwgY2FjaGVkLml0ZW0sIGNhY2hlZCwgcmVwb3J0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdhaXQgdW50aWwgZ2VuZXJhdGVkIG9yIG90aGVyd2lzZSByZXNvbHZlZFxuXG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBwZW5kaW5nLnByb21pc2UsXG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZShwZW5kaW5nLCBrZXksIGNhY2hlZCwgcmVwb3J0KVxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGUocGVuZGluZywga2V5LCBjYWNoZWQsIHJlcG9ydCkge1xuXG4gICAgICAgIGlmIChjYWNoZWQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIHN0YWxlXG5cbiAgICAgICAgICAgIC8vIFNldCBzdGFsZSB0aW1lb3V0XG5cbiAgICAgICAgICAgIGNhY2hlZC50dGwgPSBjYWNoZWQudHRsIC0gdGhpcy5ydWxlLnN0YWxlVGltZW91dDsgICAgICAgLy8gQWRqdXN0IFRUTCBmb3Igd2hlbiB0aGUgdGltZW91dCBpcyBpbnZva2VkIChzdGFsZVRpbWVvdXQgbXVzdCBiZSB2YWxpZCBpZiBpc1N0YWxlIGlzIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FjaGVkICYmXG4gICAgICAgICAgICBjYWNoZWQudHRsID4gMCkge1xuXG4gICAgICAgICAgICBwZW5kaW5nLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2VuZChwZW5kaW5nLCBudWxsLCBjYWNoZWQuaXRlbSwgY2FjaGVkLCByZXBvcnQpLCB0aGlzLnJ1bGUuc3RhbGVUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJ1bGUuZ2VuZXJhdGVUaW1lb3V0KSB7XG5cbiAgICAgICAgICAgIC8vIFNldCBpdGVtIGdlbmVyYXRpb24gdGltZW91dCAod2hlbiBub3QgaW4gY2FjaGUpXG5cbiAgICAgICAgICAgIHBlbmRpbmcuc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zZW5kKHBlbmRpbmcsIEJvb20uc2VydmVyVW5hdmFpbGFibGUoKSwgbnVsbCwgbnVsbCwgcmVwb3J0KSwgdGhpcy5ydWxlLmdlbmVyYXRlVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBhIGdlbmVyYXRlIGNhbGwgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nR2VuZXJhdGVDYWxsLmhhcyhwZW5kaW5nLmlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgbmV3IHZhbHVlXG5cbiAgICAgICAgKyt0aGlzLnN0YXRzLmdlbmVyYXRlczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgZ2VuZXJhdGlvbiBiZWZvcmUgY2FsbCBpbiBjYXNlIGl0IHRpbWVzIG91dFxuXG4gICAgICAgIGlmICh0aGlzLnJ1bGUucGVuZGluZ0dlbmVyYXRlVGltZW91dCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcGVuZGluZ0dlbmVyYXRlQ2FsbC5kZWxldGUocGVuZGluZy5pZCksIHRoaXMucnVsZS5wZW5kaW5nR2VuZXJhdGVUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdHZW5lcmF0ZUNhbGwuc2V0KHBlbmRpbmcuaWQsIHRpbWVvdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxHZW5lcmF0ZUZ1bmMocGVuZGluZywga2V5LCBjYWNoZWQsIHJlcG9ydCk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2NhbGxHZW5lcmF0ZUZ1bmMocGVuZGluZywga2V5LCBjYWNoZWQsIHJlcG9ydCkge1xuXG4gICAgICAgIGNvbnN0IGZsYWdzID0ge307XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGF3YWl0IHRoaXMucnVsZS5nZW5lcmF0ZUZ1bmMoa2V5LCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdmFyIGdlbmVyYXRlRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcignZ2VuZXJhdGUnLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGVuZGluZ1RpbWVvdXQgPSB0aGlzLl9wZW5kaW5nR2VuZXJhdGVDYWxsLmdldChwZW5kaW5nLmlkKTtcbiAgICAgICAgaWYgKHBlbmRpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocGVuZGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0dlbmVyYXRlQ2FsbC5kZWxldGUocGVuZGluZy5pZCk7XG5cbiAgICAgICAgICAgIHBlbmRpbmcgPSB0aGlzLl9wZW5kaW5ncy5nZXQocGVuZGluZy5pZCkgfHwgcGVuZGluZzsgICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIGxhdGVzdCAtIGl0IG1pZ2h0IGhhdmUgY2hhbmdlZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXJyb3IgKGlmIGRyb3BPbkVycm9yIGlzIG5vdCBzZXQgdG8gZmFsc2UpIG9yIG5vdCBjYWNoZWRcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGZsYWdzLnR0bCA9PT0gMCB8fCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBvciB1bmRlZmluZWQgbWVhbnMgdXNlIHBvbGljeVxuICAgICAgICAgICAgICAgIChnZW5lcmF0ZUVycm9yICYmIHRoaXMucnVsZS5kcm9wT25FcnJvcikpIHtcblxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZHJvcChwZW5kaW5nLmlkKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBjYWNoZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWdlbmVyYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldChwZW5kaW5nLmlkLCB2YWx1ZSwgZmxhZ3MudHRsKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2Ugc3RhbGUgY2FjaGUgY29weSB3aXRoIGxhdGUtY29taW5nIGZyZXNoIGNvcHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdEVycm9yID0gZXJyO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoJ3BlcnNpc3QnLCBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3IgPSBnZW5lcmF0ZUVycm9yIHx8ICh0aGlzLnJ1bGUuZ2VuZXJhdGVJZ25vcmVXcml0ZUVycm9yID8gbnVsbCA6IHBlcnNpc3RFcnJvcik7XG4gICAgICAgIGlmIChjYWNoZWQgJiZcbiAgICAgICAgICAgIGVycm9yICYmXG4gICAgICAgICAgICAhdGhpcy5ydWxlLmRyb3BPbkVycm9yKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3NlbmQocGVuZGluZywgZXJyb3IsIGNhY2hlZC5pdGVtLCBjYWNoZWQsIHJlcG9ydCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZW5kKHBlbmRpbmcsIGVycm9yLCB2YWx1ZSwgbnVsbCwgcmVwb3J0KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlZCBpZiBzdGFsZSB2YWx1ZSBhbHJlYWR5IHJldHVybmVkXG4gICAgfVxuXG4gICAgX3NlbmQocGVuZGluZywgZXJyLCB2YWx1ZSwgY2FjaGVkLCByZXBvcnQpIHtcblxuICAgICAgICBwZW5kaW5nLnNlbmQoZXJyLCB2YWx1ZSwgY2FjaGVkLCByZXBvcnQpO1xuICAgICAgICB0aGlzLl9wZW5kaW5ncy5kZWxldGUocGVuZGluZy5pZCk7XG5cbiAgICAgICAgaWYgKHJlcG9ydCAmJiByZXBvcnQuaXNTdGFsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRzLmhpdHMgPSB0aGlzLnN0YXRzLmhpdHMgKyBwZW5kaW5nLmNvdW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgc2V0KGtleSwgdmFsdWUsIHR0bCkge1xuXG4gICAgICAgICsrdGhpcy5zdGF0cy5zZXRzO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHR0bCA9IHR0bCB8fCBpbnRlcm5hbHMuUG9saWN5LnR0bCh0aGlzLnJ1bGUpO1xuICAgICAgICBjb25zdCBpZCA9IChrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpID8ga2V5LmlkIDoga2V5O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWNoZS5zZXQoeyBzZWdtZW50OiB0aGlzLl9zZWdtZW50LCBpZCB9LCB2YWx1ZSwgdHRsKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdHMuZXJyb3JzO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZHJvcChrZXkpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZCA9IChrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpID8ga2V5LmlkIDoga2V5O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWNoZS5kcm9wKHsgc2VnbWVudDogdGhpcy5fc2VnbWVudCwgaWQgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRzLmVycm9ycztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHR0bChjcmVhdGVkKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5Qb2xpY3kudHRsKHRoaXMucnVsZSwgY3JlYXRlZCk7XG4gICAgfVxuXG4gICAgaXNSZWFkeSgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuY29ubmVjdGlvbi5pc1JlYWR5KCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbXBpbGUob3B0aW9ucywgc2VydmVyU2lkZSkge1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0luOiAzMDAwMCxcbiAgICAgICAgICAgICAgICBleHBpcmVzQXQ6ICcxMzowMCcsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVGdW5jOiAoaWQsIGZsYWdzKSA9PiB7IHRocm93IGVycjsgfSAvIHsgcmV0dXJuIHJlc3VsdDsgfSAvIHsgZmxhZ3MudHRsID0gdHRsOyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVUaW1lb3V0OiA1MDAsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVPblJlYWRFcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUlnbm9yZVdyaXRlRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgc3RhbGVJbjogMjAwMDAsXG4gICAgICAgICAgICAgICAgc3RhbGVUaW1lb3V0OiA1MDAsXG4gICAgICAgICAgICAgICAgZHJvcE9uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0RGVjb3JhdGVkVmFsdWU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbnN0IHJ1bGUgPSB7fTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMgfHxcbiAgICAgICAgICAgICFPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBydWxlXG5cbiAgICAgICAgb3B0aW9ucyA9IEpvaS5hdHRlbXB0KG9wdGlvbnMsIGludGVybmFscy5zY2hlbWEsICdJbnZhbGlkIGNhY2hlIHBvbGljeSBjb25maWd1cmF0aW9uJyk7XG5cbiAgICAgICAgY29uc3QgaGFzRXhwaXJlc0luID0gb3B0aW9ucy5leHBpcmVzSW4gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmV4cGlyZXNJbiAhPT0gbnVsbDtcbiAgICAgICAgY29uc3QgaGFzRXhwaXJlc0F0ID0gb3B0aW9ucy5leHBpcmVzQXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmV4cGlyZXNBdCAhPT0gbnVsbDtcblxuICAgICAgICBIb2VrLmFzc2VydCghaGFzRXhwaXJlc0luIHx8ICFvcHRpb25zLnN0YWxlSW4gfHwgdHlwZW9mIG9wdGlvbnMuc3RhbGVJbiA9PT0gJ2Z1bmN0aW9uJyB8fCBvcHRpb25zLnN0YWxlSW4gPCBvcHRpb25zLmV4cGlyZXNJbiwgJ3N0YWxlSW4gbXVzdCBiZSBsZXNzIHRoYW4gZXhwaXJlc0luJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLnN0YWxlSW4gfHwgc2VydmVyU2lkZSwgJ0Nhbm5vdCB1c2Ugc3RhbGUgb3B0aW9ucyB3aXRob3V0IHNlcnZlci1zaWRlIGNhY2hpbmcnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuc3RhbGVUaW1lb3V0IHx8ICFoYXNFeHBpcmVzSW4gfHwgb3B0aW9ucy5zdGFsZVRpbWVvdXQgPCBvcHRpb25zLmV4cGlyZXNJbiwgJ3N0YWxlVGltZW91dCBtdXN0IGJlIGxlc3MgdGhhbiBleHBpcmVzSW4nKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuc3RhbGVUaW1lb3V0IHx8ICFoYXNFeHBpcmVzSW4gfHwgdHlwZW9mIG9wdGlvbnMuc3RhbGVJbiA9PT0gJ2Z1bmN0aW9uJyB8fCBvcHRpb25zLnN0YWxlVGltZW91dCA8IChvcHRpb25zLmV4cGlyZXNJbiAtIG9wdGlvbnMuc3RhbGVJbiksICdzdGFsZVRpbWVvdXQgbXVzdCBiZSBsZXNzIHRoYW4gdGhlIGRlbHRhIGJldHdlZW4gZXhwaXJlc0luIGFuZCBzdGFsZUluJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLnN0YWxlVGltZW91dCB8fCAhb3B0aW9ucy5wZW5kaW5nR2VuZXJhdGVUaW1lb3V0IHx8IG9wdGlvbnMuc3RhbGVUaW1lb3V0IDwgb3B0aW9ucy5wZW5kaW5nR2VuZXJhdGVUaW1lb3V0LCAncGVuZGluZ0dlbmVyYXRlVGltZW91dCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdGFsZVRpbWVvdXQgaWYgc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgLy8gRXhwaXJhdGlvblxuXG4gICAgICAgIGlmIChoYXNFeHBpcmVzQXQpIHtcblxuICAgICAgICAgICAgLy8gZXhwaXJlc0F0XG5cbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSAvXihcXGRcXGQ/KTooXFxkXFxkKSQvLmV4ZWMob3B0aW9ucy5leHBpcmVzQXQpO1xuICAgICAgICAgICAgcnVsZS5leHBpcmVzQXQgPSB7XG4gICAgICAgICAgICAgICAgaG91cnM6IHBhcnNlSW50KHRpbWVbMV0sIDEwKSxcbiAgICAgICAgICAgICAgICBtaW51dGVzOiBwYXJzZUludCh0aW1lWzJdLCAxMClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGV4cGlyZXNJblxuXG4gICAgICAgICAgICBydWxlLmV4cGlyZXNJbiA9IG9wdGlvbnMuZXhwaXJlc0luIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZW5lcmF0ZVRpbWVvdXRcblxuICAgICAgICBpZiAob3B0aW9ucy5nZW5lcmF0ZUZ1bmMpIHtcbiAgICAgICAgICAgIHJ1bGUuZ2VuZXJhdGVGdW5jID0gb3B0aW9ucy5nZW5lcmF0ZUZ1bmM7XG4gICAgICAgICAgICBydWxlLmdlbmVyYXRlVGltZW91dCA9IG9wdGlvbnMuZ2VuZXJhdGVUaW1lb3V0O1xuXG4gICAgICAgICAgICAvLyBTdGFsZVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFsZUluKSB7XG4gICAgICAgICAgICAgICAgcnVsZS5zdGFsZUluID0gb3B0aW9ucy5zdGFsZUluO1xuICAgICAgICAgICAgICAgIHJ1bGUuc3RhbGVUaW1lb3V0ID0gb3B0aW9ucy5zdGFsZVRpbWVvdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJ1bGUuZHJvcE9uRXJyb3IgPSBvcHRpb25zLmRyb3BPbkVycm9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRyb3BPbkVycm9yIDogdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICBydWxlLnBlbmRpbmdHZW5lcmF0ZVRpbWVvdXQgPSBvcHRpb25zLnBlbmRpbmdHZW5lcmF0ZVRpbWVvdXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucGVuZGluZ0dlbmVyYXRlVGltZW91dCA6IDA7ICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gemVyb1xuICAgICAgICB9XG5cbiAgICAgICAgcnVsZS5nZW5lcmF0ZU9uUmVhZEVycm9yID0gb3B0aW9ucy5nZW5lcmF0ZU9uUmVhZEVycm9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmdlbmVyYXRlT25SZWFkRXJyb3IgOiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgIHJ1bGUuZ2VuZXJhdGVJZ25vcmVXcml0ZUVycm9yID0gb3B0aW9ucy5nZW5lcmF0ZUlnbm9yZVdyaXRlRXJyb3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZ2VuZXJhdGVJZ25vcmVXcml0ZUVycm9yIDogdHJ1ZTsgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuXG4gICAgICAgIC8vIERlY29yYXRpb25zXG5cbiAgICAgICAgcnVsZS5nZXREZWNvcmF0ZWRWYWx1ZSA9IG9wdGlvbnMuZ2V0RGVjb3JhdGVkVmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgc3RhdGljIHR0bChydWxlLCBjcmVhdGVkLCBub3cpIHtcblxuICAgICAgICBub3cgPSBub3cgfHwgRGF0ZS5ub3coKTtcbiAgICAgICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgbm93O1xuICAgICAgICBjb25zdCBhZ2UgPSBub3cgLSBjcmVhdGVkO1xuXG4gICAgICAgIGlmIChhZ2UgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlZCBpbiB0aGUgZnV0dXJlLCBhc3N1bWUgZXhwaXJlZC9iYWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlLmV4cGlyZXNJbikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJ1bGUuZXhwaXJlc0luIC0gYWdlLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlLmV4cGlyZXNBdCkge1xuICAgICAgICAgICAgaWYgKGFnZSA+IGludGVybmFscy5kYXkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIHdhcyBjcmVhdGVkIG1vcmUgdGhhbiBhIDI0IGhvdXJzIGFnb1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShjcmVhdGVkKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHNhbWUgZGF5XG4gICAgICAgICAgICBleHBpcmVzQXQuc2V0SG91cnMocnVsZS5leHBpcmVzQXQuaG91cnMpO1xuICAgICAgICAgICAgZXhwaXJlc0F0LnNldE1pbnV0ZXMocnVsZS5leHBpcmVzQXQubWludXRlcyk7XG4gICAgICAgICAgICBleHBpcmVzQXQuc2V0U2Vjb25kcygwKTtcbiAgICAgICAgICAgIGV4cGlyZXNBdC5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgICAgICBsZXQgZXhwaXJlcyA9IGV4cGlyZXNBdC5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgIGlmIChleHBpcmVzIDw9IGNyZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBleHBpcmVzID0gZXhwaXJlcyArIGludGVybmFscy5kYXk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gdG9tb3Jyb3dcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vdyA+PSBleHBpcmVzKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwaXJlZFxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZXhwaXJlcyAtIG5vdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gcnVsZVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuLypcbiAgICBSRkMgNzIzMSBTZWN0aW9uIDMuMS4xLjFcblxuICAgIG1lZGlhLXR5cGUgPSB0eXBlIFwiL1wiIHN1YnR5cGUgKiggT1dTIFwiO1wiIE9XUyBwYXJhbWV0ZXIgKVxuICAgIHR5cGUgICAgICAgPSB0b2tlblxuICAgIHN1YnR5cGUgICAgPSB0b2tlblxuICAgIHBhcmFtZXRlciAgPSB0b2tlbiBcIj1cIiAoIHRva2VuIC8gcXVvdGVkLXN0cmluZyApXG4qL1xuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTogdHlwZS9zdWJ0eXBlICAgIDI6IHBhcmFtc1xuaW50ZXJuYWxzLmNvbnRlbnRUeXBlUmVnZXggPSAvXihbXlxcL1xcc10rXFwvW15cXHM7XSspKC4qKT8kLztcblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTogXCJiXCIgICAyOiBiXG5pbnRlcm5hbHMucGFyYW1zUmVnZXggPSAvO1xccypib3VuZGFyeT0oPzpcIihbXlwiXSspXCJ8KFteO1wiXFxzXSspKS9pO1xuXG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcblxuICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb250ZW50LXR5cGUgaGVhZGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBoZWFkZXIubWF0Y2goaW50ZXJuYWxzLmNvbnRlbnRUeXBlUmVnZXgpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGNvbnRlbnQtdHlwZSBoZWFkZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG1pbWU6IG1hdGNoWzFdLnRvTG93ZXJDYXNlKClcbiAgICB9O1xuXG4gICAgaWYgKHJlc3VsdC5taW1lLmluZGV4T2YoJ211bHRpcGFydC8nKSA9PT0gMCkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBtYXRjaFsyXTtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbXMubWF0Y2goaW50ZXJuYWxzLnBhcmFtc1JlZ2V4KTtcbiAgICAgICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ib3VuZGFyeSA9IHBhcmFtWzFdIHx8IHBhcmFtWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXN1bHQuYm91bmRhcnkpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb250ZW50LXR5cGUgaGVhZGVyOiBtdWx0aXBhcnQgbWlzc2luZyBib3VuZGFyeScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLypcbiAgICBSRkMgNjI2NiBTZWN0aW9uIDQuMSAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjI2NiNzZWN0aW9uLTQuMSlcblxuICAgIGNvbnRlbnQtZGlzcG9zaXRpb24gPSBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIiBcIjpcIiBkaXNwb3NpdGlvbi10eXBlICooIFwiO1wiIGRpc3Bvc2l0aW9uLXBhcm0gKVxuICAgIGRpc3Bvc2l0aW9uLXR5cGUgICAgPSBcImlubGluZVwiIHwgXCJhdHRhY2htZW50XCIgfCB0b2tlbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA7IGNhc2UtaW5zZW5zaXRpdmVcbiAgICBkaXNwb3NpdGlvbi1wYXJtICAgID0gZmlsZW5hbWUtcGFybSB8IHRva2VuIFsgXCIqXCIgXSBcIj1cIiAoIHRva2VuIHwgcXVvdGVkLXN0cmluZyB8IGV4dC12YWx1ZSkgICAgOyBleHQtdmFsdWUgZGVmaW5lZCBpbiBbUkZDNTk4N10sIFNlY3Rpb24gMy4yXG5cbiAgICBDb250ZW50LURpc3Bvc2l0aW9uIGhlYWRlciBmaWVsZCB2YWx1ZXMgd2l0aCBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgdGhlIHNhbWUgcGFyYW1ldGVyIG5hbWUgYXJlIGludmFsaWQuXG5cbiAgICBOb3RlIHRoYXQgZHVlIHRvIHRoZSBydWxlcyBmb3IgaW1wbGllZCBsaW5lYXIgd2hpdGVzcGFjZSAoU2VjdGlvbiAyLjEgb2YgW1JGQzI2MTZdKSwgT1BUSU9OQUwgd2hpdGVzcGFjZVxuICAgIGNhbiBhcHBlYXIgYmV0d2VlbiB3b3JkcyAodG9rZW4gb3IgcXVvdGVkLXN0cmluZykgYW5kIHNlcGFyYXRvciBjaGFyYWN0ZXJzLlxuXG4gICAgRnVydGhlcm1vcmUsIG5vdGUgdGhhdCB0aGUgZm9ybWF0IHVzZWQgZm9yIGV4dC12YWx1ZSBhbGxvd3Mgc3BlY2lmeWluZyBhIG5hdHVyYWwgbGFuZ3VhZ2UgKGUuZy4sIFwiZW5cIik7IHRoaXMgaXMgb2YgbGltaXRlZCB1c2VcbiAgICBmb3IgZmlsZW5hbWVzIGFuZCBpcyBsaWtlbHkgdG8gYmUgaWdub3JlZCBieSByZWNpcGllbnRzLlxuKi9cblxuXG5pbnRlcm5hbHMuY29udGVudERpc3Bvc2l0aW9uUmVnZXggPSAvXlxccypmb3JtLWRhdGFcXHMqKD86O1xccyooLispKT8kL2k7XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE6IG5hbWUgICAgIDI6ICogICAgICAgICAgICAzOiBleHQtdmFsdWUgICAgICAgICAgICAgICAgICAgICAgNDogcXVvdGVkICA1OiB0b2tlblxuaW50ZXJuYWxzLmNvbnRlbnREaXNwb3NpdGlvblBhcmFtUmVnZXggPSAvKFteXFw9XFwqXFxzXSspKFxcKik/XFxzKlxcPVxccyooPzooW147J1wiXFxzXStcXCdbXFx3LV0qXFwnW147XFxzXSspfCg/OlxcXCIoW15cIl0qKVxcXCIpfChbXjtcXHNdKikpKD86XFxzKig/OjtcXHMqKXwkKS9nO1xuXG5leHBvcnRzLmRpc3Bvc2l0aW9uID0gZnVuY3Rpb24gKGhlYWRlcikge1xuXG4gICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdNaXNzaW5nIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF0Y2ggPSBoZWFkZXIubWF0Y2goaW50ZXJuYWxzLmNvbnRlbnREaXNwb3NpdGlvblJlZ2V4KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciBmb3JtYXQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gbWF0Y2hbMV07XG4gICAgaWYgKCFwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb250ZW50LWRpc3Bvc2l0aW9uIGhlYWRlciBtaXNzaW5nIHBhcmFtZXRlcnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBwYXJhbWV0ZXJzLnJlcGxhY2UoaW50ZXJuYWxzLmNvbnRlbnREaXNwb3NpdGlvblBhcmFtUmVnZXgsICgkMCwgJDEsICQyLCAkMywgJDQsICQ1KSA9PiB7XG5cbiAgICAgICAgaWYgKCQyKSB7XG4gICAgICAgICAgICBpZiAoISQzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIGZvcm1hdCBpbmNsdWRlcyBpbnZhbGlkIHBhcmFtZXRlcnMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHRbJDFdID0gZGVjb2RlVVJJQ29tcG9uZW50KCQzLnNwbGl0KCdcXCcnKVsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGNvbnRlbnQtZGlzcG9zaXRpb24gaGVhZGVyIGZvcm1hdCBpbmNsdWRlcyBpbnZhbGlkIHBhcmFtZXRlcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFskMV0gPSAkNCB8fCAkNSB8fCAnJztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQubmFtZSkge1xuICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29udGVudC1kaXNwb3NpdGlvbiBoZWFkZXIgbWlzc2luZyBuYW1lIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vLyBHZW5lcmF0ZSBhIGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZyBwc2V1ZG8tcmFuZG9tIGRhdGFcblxuZXhwb3J0cy5yYW5kb21TdHJpbmcgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXG4gICAgY29uc3QgYnVmZmVyID0gZXhwb3J0cy5yYW5kb21CaXRzKChzaXplICsgMSkgKiA2KTtcbiAgICBjb25zdCBzdHJpbmcgPSBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpLnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoL1xcPS9nLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCBzaXplKTtcbn07XG5cblxuLy8gUmV0dXJuIGEgcmFuZG9tIHN0cmluZyBvZiBkaWdpdHNcblxuZXhwb3J0cy5yYW5kb21EaWdpdHMgPSBmdW5jdGlvbiAoc2l6ZSkge1xuXG4gICAgY29uc3QgZGlnaXRzID0gW107XG5cbiAgICBsZXQgYnVmZmVyID0gaW50ZXJuYWxzLnJhbmRvbShzaXplICogMik7ICAgICAgICAgICAgLy8gUHJvdmlzaW9uIHR3aWNlIHRoZSBhbW91bnQgb2YgYnl0ZXMgbmVlZGVkIHRvIGluY3JlYXNlIGNoYW5jZSBvZiBzaW5nbGUgcGFzc1xuICAgIGxldCBwb3MgPSAwO1xuXG4gICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIGlmIChwb3MgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgYnVmZmVyID0gaW50ZXJuYWxzLnJhbmRvbShzaXplICogMik7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ1ZmZlcltwb3NdIDwgMjUwKSB7XG4gICAgICAgICAgICBkaWdpdHMucHVzaChidWZmZXJbcG9zXSAlIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgICsrcG9zO1xuICAgIH1cblxuICAgIHJldHVybiBkaWdpdHMuam9pbignJyk7XG59O1xuXG5cbi8vIEdlbmVyYXRlIGEgYnVmZmVyIG9mIHJhbmRvbSBiaXRzXG5cbmV4cG9ydHMucmFuZG9tQml0cyA9IGZ1bmN0aW9uIChiaXRzKSB7XG5cbiAgICBpZiAoIWJpdHMgfHxcbiAgICAgICAgYml0cyA8IDApIHtcblxuICAgICAgICB0aHJvdyBCb29tLmludGVybmFsKCdJbnZhbGlkIHJhbmRvbSBiaXRzIGNvdW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgYnl0ZXMgPSBNYXRoLmNlaWwoYml0cyAvIDgpO1xuICAgIHJldHVybiBpbnRlcm5hbHMucmFuZG9tKGJ5dGVzKTtcbn07XG5cblxuZXhwb3J0cy5maXhlZFRpbWVDb21wYXJpc29uID0gZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBDcnlwdG8udGltaW5nU2FmZUVxdWFsKEJ1ZmZlci5mcm9tKGEpLCBCdWZmZXIuZnJvbShiKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJhbmRvbSA9IGZ1bmN0aW9uIChieXRlcykge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIENyeXB0by5yYW5kb21CeXRlcyhieXRlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5pbnRlcm5hbCgnRmFpbGVkIGdlbmVyYXRpbmcgcmFuZG9tIGJpdHM6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBQYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMudW5pcXVlRmlsZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0ZW5zaW9uKSB7XG5cbiAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvblswXSAhPT0gJy4nID8gJy4nICsgZXh0ZW5zaW9uIDogZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXh0ZW5zaW9uID0gJyc7XG4gICAgfVxuXG4gICAgcGF0aCA9IFBhdGgucmVzb2x2ZShwYXRoKTtcbiAgICBjb25zdCBuYW1lID0gW0RhdGUubm93KCksIHByb2Nlc3MucGlkLCBDcnlwdG8ucmFuZG9tQnl0ZXMoOCkudG9TdHJpbmcoJ2hleCcpXS5qb2luKCctJykgKyBleHRlbnNpb247XG4gICAgcmV0dXJuIFBhdGguam9pbihwYXRoLCBuYW1lKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBvcGVyYXRvcnM6IFsnIScsICdeJywgJyonLCAnLycsICclJywgJysnLCAnLScsICc8JywgJzw9JywgJz4nLCAnPj0nLCAnPT0nLCAnIT0nLCAnJiYnLCAnfHwnLCAnPz8nXSxcbiAgICBvcGVyYXRvckNoYXJhY3RlcnM6IFsnIScsICdeJywgJyonLCAnLycsICclJywgJysnLCAnLScsICc8JywgJz0nLCAnPicsICcmJywgJ3wnLCAnPyddLFxuICAgIG9wZXJhdG9yc09yZGVyOiBbWydeJ10sIFsnKicsICcvJywgJyUnXSwgWycrJywgJy0nXSwgWyc8JywgJzw9JywgJz4nLCAnPj0nXSwgWyc9PScsICchPSddLCBbJyYmJ10sIFsnfHwnLCAnPz8nXV0sXG4gICAgb3BlcmF0b3JzUHJlZml4OiBbJyEnLCAnbiddLFxuXG4gICAgbGl0ZXJhbHM6IHtcbiAgICAgICAgJ1wiJzogJ1wiJyxcbiAgICAgICAgJ2AnOiAnYCcsXG4gICAgICAgICdcXCcnOiAnXFwnJyxcbiAgICAgICAgJ1snOiAnXSdcbiAgICB9LFxuXG4gICAgbnVtYmVyUng6IC9eKD86WzAtOV0qXFwuP1swLTldKil7MX0kLyxcbiAgICB0b2tlblJ4OiAvXltcXHdcXCRcXCNcXC5cXEBcXDpcXHtcXH1dKyQvLFxuXG4gICAgc3ltYm9sOiBTeW1ib2woJ2Zvcm11bGEnKSxcbiAgICBzZXR0aW5nczogU3ltYm9sKCdzZXR0aW5ncycpXG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Gb3JtdWxhID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBpZiAoIW9wdGlvbnNbaW50ZXJuYWxzLnNldHRpbmdzXSAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb25zdGFudHMpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBjb25zdGFudCBpbiBvcHRpb25zLmNvbnN0YW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5jb25zdGFudHNbY29uc3RhbnRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhWydib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXS5pbmNsdWRlcyh0eXBlb2YgdmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnN0YW50ICR7Y29uc3RhbnR9IGNvbnRhaW5zIGludmFsaWQgJHt0eXBlb2YgdmFsdWV9IHZhbHVlIHR5cGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gb3B0aW9uc1tpbnRlcm5hbHMuc2V0dGluZ3NdID8gb3B0aW9ucyA6IE9iamVjdC5hc3NpZ24oeyBbaW50ZXJuYWxzLnNldHRpbmdzXTogdHJ1ZSwgY29uc3RhbnRzOiB7fSwgZnVuY3Rpb25zOiB7fSB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zaW5nbGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3BhcnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyc2Uoc3RyaW5nKTtcbiAgICB9XG5cbiAgICBfcGFyc2Uoc3RyaW5nKSB7XG5cbiAgICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgIGxldCBwYXJlbnRoZXNpcyA9IDA7XG4gICAgICAgIGxldCBsaXRlcmFsID0gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgZmx1c2ggPSAoaW5uZXIpID0+IHtcblxuICAgICAgICAgICAgaWYgKHBhcmVudGhlc2lzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtdWxhIG1pc3NpbmcgY2xvc2luZyBwYXJlbnRoZXNpcycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsYXN0ID0gcGFydHMubGVuZ3RoID8gcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIWxpdGVyYWwgJiZcbiAgICAgICAgICAgICAgICAhY3VycmVudCAmJlxuICAgICAgICAgICAgICAgICFpbm5lcikge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgIGxhc3QudHlwZSA9PT0gJ3JlZmVyZW5jZScgJiZcbiAgICAgICAgICAgICAgICBpbm5lciA9PT0gJyknKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uXG5cbiAgICAgICAgICAgICAgICBsYXN0LnR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgIGxhc3QudmFsdWUgPSB0aGlzLl9zdWJGb3JtdWxhKGN1cnJlbnQsIGxhc3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbm5lciA9PT0gJyknKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZ21lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgaW50ZXJuYWxzLkZvcm11bGEoY3VycmVudCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdzZWdtZW50JywgdmFsdWU6IHN1YiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobGl0ZXJhbCA9PT0gJ10nKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ3JlZmVyZW5jZScsIHZhbHVlOiBjdXJyZW50IH0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogY3VycmVudCB9KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpdGVyYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGludGVybmFscy5vcGVyYXRvckNoYXJhY3RlcnMuaW5jbHVkZXMoY3VycmVudCkpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wZXJhdG9yXG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdC50eXBlID09PSAnb3BlcmF0b3InICYmXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5vcGVyYXRvcnMuaW5jbHVkZXMobGFzdC52YWx1ZSArIGN1cnJlbnQpKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyAyIGNoYXJhY3RlcnMgb3BlcmF0b3JcblxuICAgICAgICAgICAgICAgICAgICBsYXN0LnZhbHVlICs9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudC5tYXRjaChpbnRlcm5hbHMubnVtYmVyUngpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTnVtYmVyXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7IHR5cGU6ICdjb25zdGFudCcsIHZhbHVlOiBwYXJzZUZsb2F0KGN1cnJlbnQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5jb25zdGFudHNbY3VycmVudF0gIT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnRcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsgdHlwZTogJ2NvbnN0YW50JywgdmFsdWU6IHRoaXMuc2V0dGluZ3MuY29uc3RhbnRzW2N1cnJlbnRdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Lm1hdGNoKGludGVybmFscy50b2tlblJ4KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgaW52YWxpZCB0b2tlbjogJHtjdXJyZW50fWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAncmVmZXJlbmNlJywgdmFsdWU6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1wYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRoZXNpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIGluIGludGVybmFscy5saXRlcmFscykge1xuICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBpbnRlcm5hbHMubGl0ZXJhbHNbY107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKCcpIHtcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgICsrcGFyZW50aGVzaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbnRlcm5hbHMub3BlcmF0b3JDaGFyYWN0ZXJzLmluY2x1ZGVzKGMpKSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gYztcbiAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZsdXNoKCk7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBwcmVmaXggLSB0byBpbnRlcm5hbCBuZWdhdGl2ZSBvcGVyYXRvclxuXG4gICAgICAgIHBhcnRzID0gcGFydHMubWFwKChwYXJ0LCBpKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdvcGVyYXRvcicgfHxcbiAgICAgICAgICAgICAgICBwYXJ0LnZhbHVlICE9PSAnLScgfHxcbiAgICAgICAgICAgICAgICBpICYmIHBhcnRzW2kgLSAxXS50eXBlICE9PSAnb3BlcmF0b3InKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ29wZXJhdG9yJywgdmFsdWU6ICduJyB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0b2tlbnMgb3JkZXJcblxuICAgICAgICBsZXQgb3BlcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5vcGVyYXRvcnNQcmVmaXguaW5jbHVkZXMocGFydC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgY29udGFpbnMgYW4gb3BlcmF0b3IgaW4gaW52YWxpZCBwb3NpdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLm9wZXJhdG9ycy5pbmNsdWRlcyhwYXJ0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgYW4gdW5rbm93biBvcGVyYXRvciAke3BhcnQudmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm11bGEgbWlzc2luZyBleHBlY3RlZCBvcGVyYXRvcicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcGVyYXRvciA9ICFvcGVyYXRvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybXVsYSBjb250YWlucyBpbnZhbGlkIHRyYWlsaW5nIG9wZXJhdG9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZGVudGlmeSBzaW5nbGUgcGFydFxuXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIFsncmVmZXJlbmNlJywgJ2xpdGVyYWwnLCAnY29uc3RhbnQnXS5pbmNsdWRlcyhwYXJ0c1swXS50eXBlKSkge1xuXG4gICAgICAgICAgICB0aGlzLnNpbmdsZSA9IHsgdHlwZTogcGFydHNbMF0udHlwZSA9PT0gJ3JlZmVyZW5jZScgPyAncmVmZXJlbmNlJyA6ICd2YWx1ZScsIHZhbHVlOiBwYXJ0c1swXS52YWx1ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJ0c1xuXG4gICAgICAgIHRoaXMuX3BhcnRzID0gcGFydHMubWFwKChwYXJ0KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIE9wZXJhdG9yc1xuXG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSAnb3BlcmF0b3InKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5vcGVyYXRvcnNQcmVmaXguaW5jbHVkZXMocGFydC52YWx1ZSkgPyBwYXJ0IDogcGFydC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTGl0ZXJhbHMsIGNvbnN0YW50cywgc2VnbWVudHNcblxuICAgICAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydC52YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVmZXJlbmNlc1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50b2tlblJ4ICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuc2V0dGluZ3MudG9rZW5SeC50ZXN0KHBhcnQudmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvcm11bGEgY29udGFpbnMgaW52YWxpZCByZWZlcmVuY2UgJHtwYXJ0LnZhbHVlfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZWZlcmVuY2UocGFydC52YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVmZXJlbmNlKHBhcnQudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfc3ViRm9ybXVsYShzdHJpbmcsIG5hbWUpIHtcblxuICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzLnNldHRpbmdzLmZ1bmN0aW9uc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9ybXVsYSBjb250YWlucyB1bmtub3duIGZ1bmN0aW9uICR7bmFtZX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gJyc7XG4gICAgICAgICAgICBsZXQgcGFyZW50aGVzaXMgPSAwO1xuICAgICAgICAgICAgbGV0IGxpdGVyYWwgPSBmYWxzZTtcblxuICAgICAgICAgICAgY29uc3QgZmx1c2ggPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3JtdWxhIGNvbnRhaW5zIGZ1bmN0aW9uICR7bmFtZX0gd2l0aCBpbnZhbGlkIGFyZ3VtZW50cyAke3N0cmluZ31gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc3RyaW5nW2ldO1xuICAgICAgICAgICAgICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IGxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjIGluIGludGVybmFscy5saXRlcmFscyAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFyZW50aGVzaXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBpbnRlcm5hbHMubGl0ZXJhbHNbY107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcsJyAmJlxuICAgICAgICAgICAgICAgICAgICAhcGFyZW50aGVzaXMpIHtcblxuICAgICAgICAgICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCArPSBjO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJygnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3BhcmVudGhlc2lzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLS1wYXJlbnRoZXNpcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MgPSBhcmdzLm1hcCgoYXJnKSA9PiBuZXcgaW50ZXJuYWxzLkZvcm11bGEoYXJnLCB0aGlzLnNldHRpbmdzKSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlubmVyVmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJWYWx1ZXMucHVzaChhcmcuZXZhbHVhdGUoY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmNhbGwoY29udGV4dCwgLi4uaW5uZXJWYWx1ZXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGV2YWx1YXRlKGNvbnRleHQpIHtcblxuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMuX3BhcnRzLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gUHJlZml4IG9wZXJhdG9yc1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJ0cy5sZW5ndGggLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgaWYgKHBhcnQgJiZcbiAgICAgICAgICAgICAgICBwYXJ0LnR5cGUgPT09ICdvcGVyYXRvcicpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGludGVybmFscy5ldmFsdWF0ZShjdXJyZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGludGVybmFscy5zaW5nbGUocGFydC52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGVmdC1yaWdodCBvcGVyYXRvcnNcblxuICAgICAgICBpbnRlcm5hbHMub3BlcmF0b3JzT3JkZXIuZm9yRWFjaCgoc2V0KSA9PiB7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFydHMubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0LmluY2x1ZGVzKHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzW2kgLSAxXSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaW50ZXJuYWxzLmV2YWx1YXRlKHBhcnRzW2kgKyAxXSwgY29udGV4dCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnRlcm5hbHMuY2FsY3VsYXRlKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW2kgLSAxXSA9IHJlc3VsdCA9PT0gMCA/IDAgOiByZXN1bHQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgLTBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuZXZhbHVhdGUocGFydHNbMF0sIGNvbnRleHQpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkZvcm11bGEucHJvdG90eXBlW2ludGVybmFscy5zeW1ib2xdID0gdHJ1ZTtcblxuXG5pbnRlcm5hbHMucmVmZXJlbmNlID0gZnVuY3Rpb24gKG5hbWUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgICAgIHJldHVybiBjb250ZXh0ICYmIGNvbnRleHRbbmFtZV0gIT09IHVuZGVmaW5lZCA/IGNvbnRleHRbbmFtZV0gOiBudWxsO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5ldmFsdWF0ZSA9IGZ1bmN0aW9uIChwYXJ0LCBjb250ZXh0KSB7XG5cbiAgICBpZiAocGFydCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQoY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcnRbaW50ZXJuYWxzLnN5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuIHBhcnQuZXZhbHVhdGUoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnQ7XG59O1xuXG5cbmludGVybmFscy5zaW5nbGUgPSBmdW5jdGlvbiAob3BlcmF0b3IsIHZhbHVlKSB7XG5cbiAgICBpZiAob3BlcmF0b3IgPT09ICchJykge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuXG4gICAgLy8gb3BlcmF0b3IgPT09ICduJ1xuXG4gICAgY29uc3QgbmVnYXRpdmUgPSAtdmFsdWU7XG4gICAgaWYgKG5lZ2F0aXZlID09PSAwKSB7ICAgICAgIC8vIE92ZXJyaWRlIC0wXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZWdhdGl2ZTtcbn07XG5cblxuaW50ZXJuYWxzLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcblxuICAgIGlmIChvcGVyYXRvciA9PT0gJz8/Jykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmV4aXN0cyhsZWZ0KSA/IGxlZnQgOiByaWdodDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiByaWdodCA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICcrJykge1xuICAgICAgICAgICAgbGVmdCA9IGludGVybmFscy5leGlzdHMobGVmdCkgPyBsZWZ0IDogJyc7XG4gICAgICAgICAgICByaWdodCA9IGludGVybmFscy5leGlzdHMocmlnaHQpID8gcmlnaHQgOiAnJztcbiAgICAgICAgICAgIHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJ14nOiByZXR1cm4gTWF0aC5wb3cobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICcvJzogcmV0dXJuIGxlZnQgLyByaWdodDtcbiAgICAgICAgICAgIGNhc2UgJyUnOiByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuICAgICAgICAgICAgY2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICBjYXNlICctJzogcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSAnPCc6IHJldHVybiBsZWZ0IDwgcmlnaHQ7XG4gICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJz4nOiByZXR1cm4gbGVmdCA+IHJpZ2h0O1xuICAgICAgICBjYXNlICc+PSc6IHJldHVybiBsZWZ0ID49IHJpZ2h0O1xuICAgICAgICBjYXNlICc9PSc6IHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICAgICAgY2FzZSAnIT0nOiByZXR1cm4gbGVmdCAhPT0gcmlnaHQ7XG4gICAgICAgIGNhc2UgJyYmJzogcmV0dXJuIGxlZnQgJiYgcmlnaHQ7XG4gICAgICAgIGNhc2UgJ3x8JzogcmV0dXJuIGxlZnQgfHwgcmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5leGlzdHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQ29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWlzc2luZzogU3ltYm9sKCdtaXNzaW5nJylcbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkF1dGggPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb3JlKSB7XG5cbiAgICAgICAgdGhpcy5fY29yZSA9IGNvcmU7XG4gICAgICAgIHRoaXMuX3NjaGVtZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fc3RyYXRlZ2llcyA9IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCAgICAgICAgICAgLy8gU3RyYXRlZ3kgdXNlZCBhcyBkZWZhdWx0IGlmIHJvdXRlIGhhcyBubyBhdXRoIHNldHRpbmdzXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hcGkgPSB7fTtcbiAgICB9XG5cbiAgICBzY2hlbWUobmFtZSwgc2NoZW1lKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQobmFtZSwgJ0F1dGhlbnRpY2F0aW9uIHNjaGVtZSBtdXN0IGhhdmUgYSBuYW1lJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCF0aGlzLl9zY2hlbWVzW25hbWVdLCAnQXV0aGVudGljYXRpb24gc2NoZW1lIG5hbWUgYWxyZWFkeSBleGlzdHM6JywgbmFtZSk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBzY2hlbWUgPT09ICdmdW5jdGlvbicsICdzY2hlbWUgbXVzdCBiZSBhIGZ1bmN0aW9uOicsIG5hbWUpO1xuXG4gICAgICAgIHRoaXMuX3NjaGVtZXNbbmFtZV0gPSBzY2hlbWU7XG4gICAgfVxuXG4gICAgX3N0cmF0ZWd5KHNlcnZlciwgbmFtZSwgc2NoZW1lLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBIb2VrLmFzc2VydChuYW1lLCAnQXV0aGVudGljYXRpb24gc3RyYXRlZ3kgbXVzdCBoYXZlIGEgbmFtZScpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCF0aGlzLl9zdHJhdGVnaWVzW25hbWVdLCAnQXV0aGVudGljYXRpb24gc3RyYXRlZ3kgbmFtZSBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgICBIb2VrLmFzc2VydChzY2hlbWUsICdBdXRoZW50aWNhdGlvbiBzdHJhdGVneScsIG5hbWUsICdtaXNzaW5nIHNjaGVtZScpO1xuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLl9zY2hlbWVzW3NjaGVtZV0sICdBdXRoZW50aWNhdGlvbiBzdHJhdGVneScsIG5hbWUsICd1c2VzIHVua25vd24gc2NoZW1lOicsIHNjaGVtZSk7XG5cbiAgICAgICAgc2VydmVyID0gc2VydmVyLl9jbG9uZSgpO1xuICAgICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuX3NjaGVtZXNbc2NoZW1lXShzZXJ2ZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHN0cmF0ZWd5LmF1dGhlbnRpY2F0ZSwgJ0ludmFsaWQgc2NoZW1lOicsIG5hbWUsICdtaXNzaW5nIGF1dGhlbnRpY2F0ZSgpIG1ldGhvZCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Ygc3RyYXRlZ3kuYXV0aGVudGljYXRlID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBzY2hlbWU6JywgbmFtZSwgJ2ludmFsaWQgYXV0aGVudGljYXRlKCkgbWV0aG9kJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFzdHJhdGVneS5wYXlsb2FkIHx8IHR5cGVvZiBzdHJhdGVneS5wYXlsb2FkID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBzY2hlbWU6JywgbmFtZSwgJ2ludmFsaWQgcGF5bG9hZCgpIG1ldGhvZCcpO1xuICAgICAgICBIb2VrLmFzc2VydCghc3RyYXRlZ3kucmVzcG9uc2UgfHwgdHlwZW9mIHN0cmF0ZWd5LnJlc3BvbnNlID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBzY2hlbWU6JywgbmFtZSwgJ2ludmFsaWQgcmVzcG9uc2UoKSBtZXRob2QnKTtcbiAgICAgICAgc3RyYXRlZ3kub3B0aW9ucyA9IHN0cmF0ZWd5Lm9wdGlvbnMgfHwge307XG4gICAgICAgIEhvZWsuYXNzZXJ0KHN0cmF0ZWd5LnBheWxvYWQgfHwgIXN0cmF0ZWd5Lm9wdGlvbnMucGF5bG9hZCwgJ0Nhbm5vdCByZXF1aXJlIHBheWxvYWQgdmFsaWRhdGlvbiB3aXRob3V0IGEgcGF5bG9hZCBtZXRob2QnKTtcblxuICAgICAgICB0aGlzLl9zdHJhdGVnaWVzW25hbWVdID0ge1xuICAgICAgICAgICAgbWV0aG9kczogc3RyYXRlZ3ksXG4gICAgICAgICAgICByZWFsbTogc2VydmVyLnJlYWxtXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0cmF0ZWd5LmFwaSkge1xuICAgICAgICAgICAgdGhpcy5hcGlbbmFtZV0gPSBzdHJhdGVneS5hcGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWZhdWx0KG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCghdGhpcy5zZXR0aW5ncy5kZWZhdWx0LCAnQ2Fubm90IHNldCBkZWZhdWx0IHN0cmF0ZWd5IG1vcmUgdGhhbiBvbmNlJyk7XG4gICAgICAgIG9wdGlvbnMgPSBDb25maWcuYXBwbHkoJ2F1dGgnLCBvcHRpb25zLCAnZGVmYXVsdCBzdHJhdGVneScpO1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZGVmYXVsdCA9IHRoaXMuX3NldHVwUm91dGUoSG9lay5jbG9uZShvcHRpb25zKSk7ICAgICAgLy8gUHJldmVudCBjaGFuZ2VzIHRvIG9wdGlvbnNcblxuICAgICAgICBjb25zdCByb3V0ZXMgPSB0aGlzLl9jb3JlLnJvdXRlci50YWJsZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdXRlIG9mIHJvdXRlcykge1xuICAgICAgICAgICAgcm91dGUucmVidWlsZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgdGVzdChuYW1lLCByZXF1ZXN0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQobmFtZSwgJ01pc3NpbmcgYXV0aGVudGljYXRpb24gc3RyYXRlZ3kgbmFtZScpO1xuICAgICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWdpZXNbbmFtZV07XG4gICAgICAgIEhvZWsuYXNzZXJ0KHN0cmF0ZWd5LCAnVW5rbm93biBhdXRoZW50aWNhdGlvbiBzdHJhdGVneTonLCBuYW1lKTtcblxuICAgICAgICBjb25zdCBiaW5kID0gc3RyYXRlZ3kubWV0aG9kcztcbiAgICAgICAgY29uc3QgcmVhbG0gPSBzdHJhdGVneS5yZWFsbTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0Ll9jb3JlLnRvb2xraXQuZXhlY3V0ZShzdHJhdGVneS5tZXRob2RzLmF1dGhlbnRpY2F0ZSwgcmVxdWVzdCwgeyBiaW5kLCByZWFsbSwgYXV0aDogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLmlzQXV0aCkge1xuICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfVxuXG4gICAgYXN5bmMgdmVyaWZ5KHJlcXVlc3QpIHtcblxuICAgICAgICBjb25zdCBhdXRoID0gcmVxdWVzdC5hdXRoO1xuXG4gICAgICAgIGlmIChhdXRoLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBhdXRoLmVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhdXRoLmlzQXV0aGVudGljYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVnaWVzW2F1dGguc3RyYXRlZ3ldO1xuICAgICAgICBIb2VrLmFzc2VydChzdHJhdGVneSwgJ1Vua25vd24gYXV0aGVudGljYXRpb24gc3RyYXRlZ3k6JywgYXV0aC5zdHJhdGVneSk7XG5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5tZXRob2RzLnZlcmlmeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmluZCA9IHN0cmF0ZWd5Lm1ldGhvZHM7XG4gICAgICAgIGF3YWl0IHN0cmF0ZWd5Lm1ldGhvZHMudmVyaWZ5LmNhbGwoYmluZCwgYXV0aCk7XG4gICAgfVxuXG4gICAgc3RhdGljIHRlc3RBY2Nlc3MocmVxdWVzdCwgcm91dGUpIHtcblxuICAgICAgICBjb25zdCBhdXRoID0gcmVxdWVzdC5fY29yZS5hdXRoO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXV0aC5fYWNjZXNzKHJlcXVlc3QsIHJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXR1cFJvdXRlKG9wdGlvbnMsIHBhdGgpIHtcblxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zOyAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdW5kZWZpbmVkIGFuZCBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgc3RyYXRlZ2llczogW29wdGlvbnNdIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zdHJhdGVneSkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdHJhdGVnaWVzID0gW29wdGlvbnMuc3RyYXRlZ3ldO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuc3RyYXRlZ3k7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aCAmJlxuICAgICAgICAgICAgIW9wdGlvbnMuc3RyYXRlZ2llcykge1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0aGlzLnNldHRpbmdzLmRlZmF1bHQsICdSb3V0ZSBtaXNzaW5nIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5IGFuZCBubyBkZWZhdWx0IGRlZmluZWQ6JywgcGF0aCk7XG4gICAgICAgICAgICBvcHRpb25zID0gSG9lay5hcHBseVRvRGVmYXVsdHModGhpcy5zZXR0aW5ncy5kZWZhdWx0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBwYXRoIHx8ICdkZWZhdWx0IHN0cmF0ZWd5JztcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5zdHJhdGVnaWVzICYmIG9wdGlvbnMuc3RyYXRlZ2llcy5sZW5ndGgsICdNaXNzaW5nIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5OicsIHBhdGgpO1xuXG4gICAgICAgIG9wdGlvbnMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCAncmVxdWlyZWQnO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmVudGl0eSAhPT0gdW5kZWZpbmVkIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCA8PSAxMS54LnhcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGUgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBvcHRpb25zLmFjY2VzcyA9IFt7IGVudGl0eTogb3B0aW9ucy5lbnRpdHksIHNjb3BlOiBvcHRpb25zLnNjb3BlIH1dO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZW50aXR5O1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuc2NvcGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hY2Nlc3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWNjZXNzIG9mIG9wdGlvbnMuYWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzLnNjb3BlID0gaW50ZXJuYWxzLnNldHVwU2NvcGUoYWNjZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnBheWxvYWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGF5bG9hZCA9ICdyZXF1aXJlZCc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGFzQXV0aGVudGljYXRlUGF5bG9hZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb3B0aW9ucy5zdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWdpZXNbbmFtZV07XG4gICAgICAgICAgICBIb2VrLmFzc2VydChzdHJhdGVneSwgJ1Vua25vd24gYXV0aGVudGljYXRpb24gc3RyYXRlZ3knLCBuYW1lLCAnaW4nLCBwYXRoKTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQoc3RyYXRlZ3kubWV0aG9kcy5wYXlsb2FkIHx8IG9wdGlvbnMucGF5bG9hZCAhPT0gJ3JlcXVpcmVkJywgJ1BheWxvYWQgdmFsaWRhdGlvbiBjYW4gb25seSBiZSByZXF1aXJlZCB3aGVuIGFsbCBzdHJhdGVnaWVzIHN1cHBvcnQgaXQgaW4nLCBwYXRoKTtcbiAgICAgICAgICAgIGhhc0F1dGhlbnRpY2F0ZVBheWxvYWQgPSBoYXNBdXRoZW50aWNhdGVQYXlsb2FkIHx8IHN0cmF0ZWd5Lm1ldGhvZHMucGF5bG9hZDtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFzdHJhdGVneS5tZXRob2RzLm9wdGlvbnMucGF5bG9hZCB8fCBvcHRpb25zLnBheWxvYWQgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBheWxvYWQgPT09ICdyZXF1aXJlZCcsICdDYW5ub3Qgc2V0IGF1dGhlbnRpY2F0aW9uIHBheWxvYWQgdG8nLCBvcHRpb25zLnBheWxvYWQsICd3aGVuIGEgc3RyYXRlZ3kgcmVxdWlyZXMgcGF5bG9hZCB2YWxpZGF0aW9uIGluJywgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5wYXlsb2FkIHx8IGhhc0F1dGhlbnRpY2F0ZVBheWxvYWQsICdQYXlsb2FkIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBzdHJhdGVneSB3aXRoIHBheWxvYWQgc3VwcG9ydCBpbicsIHBhdGgpO1xuXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIGxvb2t1cChyb3V0ZSkge1xuXG4gICAgICAgIGlmIChyb3V0ZS5zZXR0aW5ncy5hdXRoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvdXRlLnNldHRpbmdzLmF1dGggfHwgdGhpcy5zZXR0aW5ncy5kZWZhdWx0O1xuICAgIH1cblxuICAgIF9lbmFibGVkKHJvdXRlLCB0eXBlKSB7XG5cbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5sb29rdXAocm91dGUpO1xuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdhdXRoZW50aWNhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYWNjZXNzJykge1xuICAgICAgICAgICAgcmV0dXJuICEhY29uZmlnLmFjY2VzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBjb25maWcuc3RyYXRlZ2llcykge1xuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVnaWVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHN0cmF0ZWd5Lm1ldGhvZHNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXV0aGVudGljYXRlKHJlcXVlc3QpIHtcblxuICAgICAgICBjb25zdCBhdXRoID0gcmVxdWVzdC5fY29yZS5hdXRoO1xuICAgICAgICByZXR1cm4gYXV0aC5fYXV0aGVudGljYXRlKHJlcXVlc3QpO1xuICAgIH1cblxuICAgIGFzeW5jIF9hdXRoZW50aWNhdGUocmVxdWVzdCkge1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMubG9va3VwKHJlcXVlc3Qucm91dGUpO1xuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICByZXF1ZXN0LmF1dGgubW9kZSA9IGNvbmZpZy5tb2RlO1xuXG4gICAgICAgIC8vIEluamVjdGlvbiBieXBhc3NcblxuICAgICAgICBpZiAocmVxdWVzdC5hdXRoLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGUobnVsbCwgeyBjcmVkZW50aWFsczogcmVxdWVzdC5hdXRoLmNyZWRlbnRpYWxzLCBhcnRpZmFjdHM6IHJlcXVlc3QuYXV0aC5hcnRpZmFjdHMgfSwgcmVxdWVzdC5hdXRoLnN0cmF0ZWd5LCBjb25maWcsIHJlcXVlc3QsIGVycm9ycyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgZWFjaCBzdHJhdGVneVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBjb25maWcuc3RyYXRlZ2llcykge1xuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVnaWVzW25hbWVdO1xuXG4gICAgICAgICAgICBjb25zdCBiaW5kID0gc3RyYXRlZ3kubWV0aG9kcztcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gc3RyYXRlZ3kucmVhbG07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuX2NvcmUudG9vbGtpdC5leGVjdXRlKHN0cmF0ZWd5Lm1ldGhvZHMuYXV0aGVudGljYXRlLCByZXF1ZXN0LCB7IGJpbmQsIHJlYWxtLCBhdXRoOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gKHJlc3BvbnNlLmlzQXV0aCA/IGludGVybmFscy52YWxpZGF0ZShyZXNwb25zZS5lcnJvciwgcmVzcG9uc2UuZGF0YSwgbmFtZSwgY29uZmlnLCByZXF1ZXN0LCBlcnJvcnMpIDogaW50ZXJuYWxzLnZhbGlkYXRlKHJlc3BvbnNlLCBudWxsLCBuYW1lLCBjb25maWcsIHJlcXVlc3QsIGVycm9ycykpO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWVzc2FnZSAhPT0gaW50ZXJuYWxzLm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vIG1vcmUgc3RyYXRlZ2llc1xuXG4gICAgICAgIGNvbnN0IGVyciA9IEJvb20udW5hdXRob3JpemVkKCdNaXNzaW5nIGF1dGhlbnRpY2F0aW9uJywgZXJyb3JzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5tb2RlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmF1dGguaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgIHJlcXVlc3QuYXV0aC5jcmVkZW50aWFscyA9IG51bGw7XG4gICAgICAgIHJlcXVlc3QuYXV0aC5lcnJvciA9IGVycjtcbiAgICAgICAgcmVxdWVzdC5fbG9nKFsnYXV0aCcsICd1bmF1dGhlbnRpY2F0ZWQnXSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFjY2VzcyhyZXF1ZXN0KSB7XG5cbiAgICAgICAgY29uc3QgYXV0aCA9IHJlcXVlc3QuX2NvcmUuYXV0aDtcbiAgICAgICAgcmVxdWVzdC5hdXRoLmlzQXV0aG9yaXplZCA9IGF1dGguX2FjY2VzcyhyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBfYWNjZXNzKHJlcXVlc3QsIHJvdXRlKSB7XG5cbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5sb29rdXAocm91dGUgfHwgcmVxdWVzdC5yb3V0ZSk7XG4gICAgICAgIGlmICghY29uZmlnIHx8XG4gICAgICAgICAgICAhY29uZmlnLmFjY2Vzcykge1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gcmVxdWVzdC5hdXRoLmNyZWRlbnRpYWxzO1xuICAgICAgICBpZiAoIWNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1vZGUgIT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IEJvb20uZm9yYmlkZGVuKCdSZXF1ZXN0IGlzIHVuYXV0aGVudGljYXRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdEVudGl0eSA9IChjcmVkZW50aWFscy51c2VyID8gJ3VzZXInIDogJ2FwcCcpO1xuXG4gICAgICAgIGNvbnN0IHNjb3BlRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYWNjZXNzIG9mIGNvbmZpZy5hY2Nlc3MpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgZW50aXR5XG5cbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IGFjY2Vzcy5lbnRpdHk7XG4gICAgICAgICAgICBpZiAoZW50aXR5ICYmXG4gICAgICAgICAgICAgICAgZW50aXR5ICE9PSAnYW55JyAmJlxuICAgICAgICAgICAgICAgIGVudGl0eSAhPT0gcmVxdWVzdEVudGl0eSkge1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHNjb3BlXG5cbiAgICAgICAgICAgIGxldCBzY29wZSA9IGFjY2Vzcy5zY29wZTtcbiAgICAgICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgICAgIGlmICghY3JlZGVudGlhbHMuc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVFcnJvcnMucHVzaChzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNjb3BlID0gaW50ZXJuYWxzLmV4cGFuZFNjb3BlKHJlcXVlc3QsIHNjb3BlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWludGVybmFscy52YWxpZGF0ZVNjb3BlKGNyZWRlbnRpYWxzLCBzY29wZSwgJ3JlcXVpcmVkJykgfHxcbiAgICAgICAgICAgICAgICAgICAgIWludGVybmFscy52YWxpZGF0ZVNjb3BlKGNyZWRlbnRpYWxzLCBzY29wZSwgJ3NlbGVjdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICFpbnRlcm5hbHMudmFsaWRhdGVTY29wZShjcmVkZW50aWFscywgc2NvcGUsICdmb3JiaWRkZW4nKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlRXJyb3JzLnB1c2goc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NvcGUgZXJyb3JcblxuICAgICAgICBpZiAoc2NvcGVFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXF1ZXN0Ll9sb2coWydhdXRoJywgJ3Njb3BlJywgJ2Vycm9yJ10pO1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5mb3JiaWRkZW4oJ0luc3VmZmljaWVudCBzY29wZScsIHsgZ290OiBjcmVkZW50aWFscy5zY29wZSwgbmVlZDogc2NvcGVFcnJvcnMgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbnRpdHkgZXJyb3JcblxuICAgICAgICBpZiAocmVxdWVzdEVudGl0eSA9PT0gJ2FwcCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuX2xvZyhbJ2F1dGgnLCAnZW50aXR5JywgJ3VzZXInLCAnZXJyb3InXSk7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmZvcmJpZGRlbignQXBwbGljYXRpb24gY3JlZGVudGlhbHMgY2Fubm90IGJlIHVzZWQgb24gYSB1c2VyIGVuZHBvaW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0Ll9sb2coWydhdXRoJywgJ2VudGl0eScsICdhcHAnLCAnZXJyb3InXSk7XG4gICAgICAgIHRocm93IEJvb20uZm9yYmlkZGVuKCdVc2VyIGNyZWRlbnRpYWxzIGNhbm5vdCBiZSB1c2VkIG9uIGFuIGFwcGxpY2F0aW9uIGVuZHBvaW50Jyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGFzeW5jIHBheWxvYWQocmVxdWVzdCkge1xuXG4gICAgICAgIGlmICghcmVxdWVzdC5hdXRoLmlzQXV0aGVudGljYXRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXV0aCA9IHJlcXVlc3QuX2NvcmUuYXV0aDtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBhdXRoLl9zdHJhdGVnaWVzW3JlcXVlc3QuYXV0aC5zdHJhdGVneV07XG4gICAgICAgIEhvZWsuYXNzZXJ0KHN0cmF0ZWd5LCAnVW5rbm93biBhdXRoZW50aWNhdGlvbiBzdHJhdGVneTonLCByZXF1ZXN0LmF1dGguc3RyYXRlZ3kpO1xuXG4gICAgICAgIGlmICghc3RyYXRlZ3kubWV0aG9kcy5wYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb25maWcgPSBhdXRoLmxvb2t1cChyZXF1ZXN0LnJvdXRlKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZyA9IGNvbmZpZy5wYXlsb2FkIHx8IChzdHJhdGVneS5tZXRob2RzLm9wdGlvbnMucGF5bG9hZCA/ICdyZXF1aXJlZCcgOiBmYWxzZSk7XG4gICAgICAgIGlmICghc2V0dGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmluZCA9IHN0cmF0ZWd5Lm1ldGhvZHM7XG4gICAgICAgIGNvbnN0IHJlYWxtID0gc3RyYXRlZ3kucmVhbG07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5fY29yZS50b29sa2l0LmV4ZWN1dGUoc3RyYXRlZ3kubWV0aG9kcy5wYXlsb2FkLCByZXF1ZXN0LCB7IGJpbmQsIHJlYWxtIH0pO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5pc0Jvb20gJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLmlzTWlzc2luZykge1xuXG4gICAgICAgICAgICByZXR1cm4gKHNldHRpbmcgPT09ICdvcHRpb25hbCcgPyB1bmRlZmluZWQgOiBCb29tLnVuYXV0aG9yaXplZCgnTWlzc2luZyBwYXlsb2FkIGF1dGhlbnRpY2F0aW9uJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHN0YXRpYyBhc3luYyByZXNwb25zZShyZXF1ZXN0KSB7XG5cbiAgICAgICAgY29uc3QgYXV0aCA9IHJlcXVlc3QuX2NvcmUuYXV0aDtcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmF1dGguaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdHJhdGVneSA9IGF1dGguX3N0cmF0ZWdpZXNbcmVxdWVzdC5hdXRoLnN0cmF0ZWd5XTtcbiAgICAgICAgSG9lay5hc3NlcnQoc3RyYXRlZ3ksICdVbmtub3duIGF1dGhlbnRpY2F0aW9uIHN0cmF0ZWd5OicsIHJlcXVlc3QuYXV0aC5zdHJhdGVneSk7XG5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5tZXRob2RzLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBiaW5kID0gc3RyYXRlZ3kubWV0aG9kcztcbiAgICAgICAgY29uc3QgcmVhbG0gPSBzdHJhdGVneS5yZWFsbTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCByZXF1ZXN0Ll9jb3JlLnRvb2xraXQuZXhlY3V0ZShzdHJhdGVneS5tZXRob2RzLnJlc3BvbnNlLCByZXF1ZXN0LCB7IGJpbmQsIHJlYWxtLCBjb250aW51ZTogJ3VuZGVmaW5lZCcgfSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zZXR1cFNjb3BlID0gZnVuY3Rpb24gKGFjY2Vzcykge1xuXG4gICAgaWYgKCFhY2Nlc3Muc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlID0ge307XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhY2Nlc3Muc2NvcGUpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdmFsdWVbMF07XG4gICAgICAgIGNvbnN0IHR5cGUgPSAocHJlZml4ID09PSAnKycgPyAncmVxdWlyZWQnIDogKHByZWZpeCA9PT0gJyEnID8gJ2ZvcmJpZGRlbicgOiAnc2VsZWN0aW9uJykpO1xuICAgICAgICBjb25zdCBjbGVhbiA9ICh0eXBlID09PSAnc2VsZWN0aW9uJyA/IHZhbHVlIDogdmFsdWUuc2xpY2UoMSkpO1xuICAgICAgICBzY29wZVt0eXBlXSA9IHNjb3BlW3R5cGVdIHx8IFtdO1xuICAgICAgICBzY29wZVt0eXBlXS5wdXNoKGNsZWFuKTtcblxuICAgICAgICBpZiAoKCFzY29wZS5faGFzUGFyYW1ldGVycyB8fCAhc2NvcGUuX2hhc1BhcmFtZXRlcnNbdHlwZV0pICYmXG4gICAgICAgICAgICAveyhbXn1dKyl9Ly50ZXN0KGNsZWFuKSkge1xuXG4gICAgICAgICAgICBzY29wZS5faGFzUGFyYW1ldGVycyA9IHNjb3BlLl9oYXNQYXJhbWV0ZXJzIHx8IHt9O1xuICAgICAgICAgICAgc2NvcGUuX2hhc1BhcmFtZXRlcnNbdHlwZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3BlO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoZXJyLCByZXN1bHQsIG5hbWUsIGNvbmZpZywgcmVxdWVzdCwgZXJyb3JzKSB7ICAgICAgICAgICAgICAgICAvLyBlcnIgY2FuIGJlIEJvb20sIEVycm9yLCBvciBhIHZhbGlkIHJlc3BvbnNlIG9iamVjdFxuXG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHt9O1xuXG4gICAgLy8gVW5hdXRoZW50aWNhdGVkXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuX2xvZyhbJ2F1dGgnLCAndW5hdXRoZW50aWNhdGVkJywgJ3Jlc3BvbnNlJywgbmFtZV0sIHsgc3RhdHVzQ29kZTogZXJyLnN0YXR1c0NvZGUgfSk7XG4gICAgICAgICAgICByZXR1cm4gZXJyOyAgICAgLy8gTm9uLWVycm9yIHJlc3BvbnNlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyLmlzTWlzc2luZykge1xuXG4gICAgICAgICAgICAvLyBUcnkgbmV4dCBzdHJhdGVneVxuXG4gICAgICAgICAgICByZXF1ZXN0Ll9sb2coWydhdXRoJywgJ3VuYXV0aGVudGljYXRlZCcsICdtaXNzaW5nJywgbmFtZV0sIGVycik7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChlcnIub3V0cHV0LmhlYWRlcnNbJ1dXVy1BdXRoZW50aWNhdGUnXSk7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLm1pc3Npbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLm1vZGUgPT09ICd0cnknKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmF1dGguaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXF1ZXN0LmF1dGguc3RyYXRlZ3kgPSBuYW1lO1xuICAgICAgICAgICAgcmVxdWVzdC5hdXRoLmNyZWRlbnRpYWxzID0gcmVzdWx0LmNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgcmVxdWVzdC5hdXRoLmFydGlmYWN0cyA9IHJlc3VsdC5hcnRpZmFjdHM7XG4gICAgICAgICAgICByZXF1ZXN0LmF1dGguZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICByZXF1ZXN0Ll9sb2coWydhdXRoJywgJ3VuYXV0aGVudGljYXRlZCcsICd0cnknLCBuYW1lXSwgZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuX2xvZyhbJ2F1dGgnLCAndW5hdXRoZW50aWNhdGVkJywgJ2Vycm9yJywgbmFtZV0sIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICAvLyBBdXRoZW50aWNhdGVkXG5cbiAgICBjb25zdCBjcmVkZW50aWFscyA9IHJlc3VsdC5jcmVkZW50aWFscztcbiAgICByZXF1ZXN0LmF1dGguc3RyYXRlZ3kgPSBuYW1lO1xuICAgIHJlcXVlc3QuYXV0aC5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgIHJlcXVlc3QuYXV0aC5hcnRpZmFjdHMgPSByZXN1bHQuYXJ0aWZhY3RzO1xuICAgIHJlcXVlc3QuYXV0aC5pc0F1dGhlbnRpY2F0ZWQgPSB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuZXhwYW5kU2NvcGUgPSBmdW5jdGlvbiAocmVxdWVzdCwgc2NvcGUpIHtcblxuICAgIGlmICghc2NvcGUuX2hhc1BhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGFuZGVkID0ge1xuICAgICAgICByZXF1aXJlZDogaW50ZXJuYWxzLmV4cGFuZFNjb3BlVHlwZShyZXF1ZXN0LCBzY29wZSwgJ3JlcXVpcmVkJyksXG4gICAgICAgIHNlbGVjdGlvbjogaW50ZXJuYWxzLmV4cGFuZFNjb3BlVHlwZShyZXF1ZXN0LCBzY29wZSwgJ3NlbGVjdGlvbicpLFxuICAgICAgICBmb3JiaWRkZW46IGludGVybmFscy5leHBhbmRTY29wZVR5cGUocmVxdWVzdCwgc2NvcGUsICdmb3JiaWRkZW4nKVxuICAgIH07XG5cbiAgICByZXR1cm4gZXhwYW5kZWQ7XG59O1xuXG5cbmludGVybmFscy5leHBhbmRTY29wZVR5cGUgPSBmdW5jdGlvbiAocmVxdWVzdCwgc2NvcGUsIHR5cGUpIHtcblxuICAgIGlmICghc2NvcGUuX2hhc1BhcmFtZXRlcnNbdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlW3R5cGVdO1xuICAgIH1cblxuICAgIGNvbnN0IGV4cGFuZGVkID0gW107XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgcGFyYW1zOiByZXF1ZXN0LnBhcmFtcyxcbiAgICAgICAgcXVlcnk6IHJlcXVlc3QucXVlcnksXG4gICAgICAgIHBheWxvYWQ6IHJlcXVlc3QucGF5bG9hZCxcbiAgICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QuYXV0aC5jcmVkZW50aWFsc1xuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IHRlbXBsYXRlIG9mIHNjb3BlW3R5cGVdKSB7XG4gICAgICAgIGV4cGFuZGVkLnB1c2goSG9lay5yZWFjaFRlbXBsYXRlKGNvbnRleHQsIHRlbXBsYXRlKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGFuZGVkO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGVTY29wZSA9IGZ1bmN0aW9uIChjcmVkZW50aWFscywgc2NvcGUsIHR5cGUpIHtcblxuICAgIGlmICghc2NvcGVbdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgY291bnQgPSB0eXBlb2YgY3JlZGVudGlhbHMuc2NvcGUgPT09ICdzdHJpbmcnID9cbiAgICAgICAgKHNjb3BlW3R5cGVdLmluZGV4T2YoY3JlZGVudGlhbHMuc2NvcGUpICE9PSAtMSA/IDEgOiAwKSA6XG4gICAgICAgIEhvZWsuaW50ZXJzZWN0KHNjb3BlW3R5cGVdLCBjcmVkZW50aWFscy5zY29wZSkubGVuZ3RoO1xuXG4gICAgaWYgKHR5cGUgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgIHJldHVybiBjb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICByZXR1cm4gY291bnQgPT09IHNjb3BlLnJlcXVpcmVkLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gISFjb3VudDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IEFjY2VwdCA9IHJlcXVpcmUoJ0BoYXBpL2FjY2VwdCcpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBjb21tb246IFsnZ3ppcCwgZGVmbGF0ZScsICdkZWZsYXRlLCBnemlwJywgJ2d6aXAnLCAnZGVmbGF0ZScsICdnemlwLCBkZWZsYXRlLCBiciddXG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Db21wcmVzc2lvbiA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuZW5jb2RpbmdzID0gWydpZGVudGl0eScsICdnemlwJywgJ2RlZmxhdGUnXTtcbiAgICAgICAgdGhpcy5fZW5jb2RlcnMgPSB7XG4gICAgICAgICAgICBpZGVudGl0eTogbnVsbCxcbiAgICAgICAgICAgIGd6aXA6IChvcHRpb25zKSA9PiBabGliLmNyZWF0ZUd6aXAob3B0aW9ucyksXG4gICAgICAgICAgICBkZWZsYXRlOiAob3B0aW9ucykgPT4gWmxpYi5jcmVhdGVEZWZsYXRlKG9wdGlvbnMpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fZGVjb2RlcnMgPSB7XG4gICAgICAgICAgICBnemlwOiAob3B0aW9ucykgPT4gWmxpYi5jcmVhdGVHdW56aXAob3B0aW9ucyksXG4gICAgICAgICAgICBkZWZsYXRlOiAob3B0aW9ucykgPT4gWmxpYi5jcmVhdGVJbmZsYXRlKG9wdGlvbnMpXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQ29tbW9ucygpO1xuICAgIH1cblxuICAgIF91cGRhdGVDb21tb25zKCkge1xuXG4gICAgICAgIHRoaXMuX2NvbW1vbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgaW50ZXJuYWxzLmNvbW1vbi5mb3JFYWNoKChoZWFkZXIpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5fY29tbW9uLnNldChoZWFkZXIsIEFjY2VwdC5lbmNvZGluZyhoZWFkZXIsIHRoaXMuZW5jb2RpbmdzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZEVuY29kZXIoZW5jb2RpbmcsIGVuY29kZXIpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLl9lbmNvZGVyc1tlbmNvZGluZ10gPT09IHVuZGVmaW5lZCwgYENhbm5vdCBvdmVycmlkZSBleGlzdGluZyBlbmNvZGVyIGZvciAke2VuY29kaW5nfWApO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZW5jb2RlciA9PT0gJ2Z1bmN0aW9uJywgYEludmFsaWQgZW5jb2RlciBmdW5jdGlvbiBmb3IgJHtlbmNvZGluZ31gKTtcbiAgICAgICAgdGhpcy5fZW5jb2RlcnNbZW5jb2RpbmddID0gZW5jb2RlcjtcbiAgICAgICAgdGhpcy5lbmNvZGluZ3MudW5zaGlmdChlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbW1vbnMoKTtcbiAgICB9XG5cbiAgICBhZGREZWNvZGVyKGVuY29kaW5nLCBkZWNvZGVyKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5fZGVjb2RlcnNbZW5jb2RpbmddID09PSB1bmRlZmluZWQsIGBDYW5ub3Qgb3ZlcnJpZGUgZXhpc3RpbmcgZGVjb2RlciBmb3IgJHtlbmNvZGluZ31gKTtcbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGRlY29kZXIgPT09ICdmdW5jdGlvbicsIGBJbnZhbGlkIGRlY29kZXIgZnVuY3Rpb24gZm9yICR7ZW5jb2Rpbmd9YCk7XG4gICAgICAgIHRoaXMuX2RlY29kZXJzW2VuY29kaW5nXSA9IGRlY29kZXI7XG4gICAgfVxuXG4gICAgYWNjZXB0KHJlcXVlc3QpIHtcblxuICAgICAgICBjb25zdCBoZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnNbJ2FjY2VwdC1lbmNvZGluZyddO1xuICAgICAgICBjb25zdCBjb21tb24gPSB0aGlzLl9jb21tb24uZ2V0KGhlYWRlcik7XG4gICAgICAgIGlmIChjb21tb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb247XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEFjY2VwdC5lbmNvZGluZyhoZWFkZXIsIHRoaXMuZW5jb2RpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgIGVyci5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgICAgICByZXF1ZXN0Ll9sb2coWydhY2NlcHQtZW5jb2RpbmcnLCAnZXJyb3InXSwgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiAnaWRlbnRpdHknO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZW5jb2RpbmcocmVzcG9uc2UsIGxlbmd0aCkge1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zZXR0aW5ncy5jb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gPSByZXNwb25zZS5zZXR0aW5ncy5jb21wcmVzc2VkO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVzcG9uc2UucmVxdWVzdDtcbiAgICAgICAgaWYgKCFyZXF1ZXN0Ll9jb3JlLnNldHRpbmdzLmNvbXByZXNzaW9uIHx8XG4gICAgICAgICAgICBsZW5ndGggIT09IG51bGwgJiYgbGVuZ3RoIDwgcmVxdWVzdC5fY29yZS5zZXR0aW5ncy5jb21wcmVzc2lvbi5taW5CeXRlcykge1xuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1pbWUgPSByZXF1ZXN0Ll9jb3JlLm1pbWUudHlwZShyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIGlmICghbWltZS5jb21wcmVzc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzcG9uc2UudmFyeSgnYWNjZXB0LWVuY29kaW5nJyk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVxdWVzdC5pbmZvLmFjY2VwdEVuY29kaW5nID09PSAnaWRlbnRpdHknID8gbnVsbCA6IHJlcXVlc3QuaW5mby5hY2NlcHRFbmNvZGluZztcbiAgICB9XG5cbiAgICBlbmNvZGVyKHJlcXVlc3QsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgY29uc3QgZW5jb2RlciA9IHRoaXMuX2VuY29kZXJzW2VuY29kaW5nXTtcbiAgICAgICAgSG9lay5hc3NlcnQoZW5jb2RlciAhPT0gdW5kZWZpbmVkLCBgVW5rbm93biBlbmNvZGluZyAke2VuY29kaW5nfWApO1xuICAgICAgICByZXR1cm4gZW5jb2RlcihyZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmNvbXByZXNzaW9uW2VuY29kaW5nXSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgT3MgPSByZXF1aXJlKCdvcycpO1xuXG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnN5bWJvbCA9IFN5bWJvbCgnaGFwaS1yZXNwb25zZScpO1xuXG5cbmV4cG9ydHMuYXBwbHkgPSBmdW5jdGlvbiAodHlwZSwgb3B0aW9ucywgLi4ubWVzc2FnZSkge1xuXG4gICAgY29uc3QgcmVzdWx0ID0gSm9pLnZhbGlkYXRlKG9wdGlvbnMsIGludGVybmFsc1t0eXBlXSk7XG5cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke3R5cGV9IG9wdGlvbnMgJHttZXNzYWdlLmxlbmd0aCA/ICcoJyArIG1lc3NhZ2Uuam9pbignICcpICsgJyknIDogJyd9ICR7cmVzdWx0LmVycm9yLmFubm90YXRlKCl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG5cblxuZXhwb3J0cy5lbmFibGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSAob3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpIDoge30pOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuXG4gICAgaWYgKHNldHRpbmdzLnNlY3VyaXR5ID09PSB0cnVlKSB7XG4gICAgICAgIHNldHRpbmdzLnNlY3VyaXR5ID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLmNvcnMgPT09IHRydWUpIHtcbiAgICAgICAgc2V0dGluZ3MuY29ycyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBzZXR0aW5ncztcbn07XG5cblxuaW50ZXJuYWxzLmFjY2VzcyA9IEpvaS5vYmplY3Qoe1xuICAgIGVudGl0eTogSm9pLnZhbGlkKCd1c2VyJywgJ2FwcCcsICdhbnknKSxcbiAgICBzY29wZTogW2ZhbHNlLCBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLm1pbigxKV1cbn0pO1xuXG5cbmludGVybmFscy5hdXRoID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLnN0cmluZygpLFxuICAgIGludGVybmFscy5hY2Nlc3Mua2V5cyh7XG4gICAgICAgIG1vZGU6IEpvaS52YWxpZCgncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAndHJ5JyksXG4gICAgICAgIHN0cmF0ZWd5OiBKb2kuc3RyaW5nKCksXG4gICAgICAgIHN0cmF0ZWdpZXM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkubWluKDEpLFxuICAgICAgICBhY2Nlc3M6IEpvaS5hcnJheSgpLml0ZW1zKGludGVybmFscy5hY2Nlc3MubWluKDEpKS5zaW5nbGUoKS5taW4oMSksXG4gICAgICAgIHBheWxvYWQ6IFtcbiAgICAgICAgICAgIEpvaS52YWxpZCgncmVxdWlyZWQnLCAnb3B0aW9uYWwnKSxcbiAgICAgICAgICAgIEpvaS5ib29sZWFuKClcbiAgICAgICAgXVxuICAgIH0pXG4gICAgICAgIC53aXRob3V0KCdzdHJhdGVneScsICdzdHJhdGVnaWVzJylcbiAgICAgICAgLndpdGhvdXQoJ2FjY2VzcycsIFsnc2NvcGUnLCAnZW50aXR5J10pXG5dKTtcblxuXG5pbnRlcm5hbHMuZXZlbnQgPSBKb2kub2JqZWN0KHtcbiAgICBtZXRob2Q6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5mdW5jKCkpLnNpbmdsZSgpLFxuICAgIG9wdGlvbnM6IEpvaS5vYmplY3Qoe1xuICAgICAgICBiZWZvcmU6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCksXG4gICAgICAgIGFmdGVyOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLFxuICAgICAgICBiaW5kOiBKb2kuYW55KCksXG4gICAgICAgIHNhbmRib3g6IEpvaS52YWxpZCgnc2VydmVyJywgJ3BsdWdpbicpLFxuICAgICAgICB0aW1lb3V0OiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLm1pbigxKVxuICAgIH0pXG4gICAgICAgIC5kZWZhdWx0KHt9KVxufSk7XG5cblxuaW50ZXJuYWxzLmV4dHMgPSBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuZXZlbnQua2V5cyh7IHR5cGU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpIH0pKS5zaW5nbGUoKTtcblxuXG5pbnRlcm5hbHMuZmFpbEFjdGlvbiA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS52YWxpZCgnZXJyb3InLCAnbG9nJywgJ2lnbm9yZScpLFxuICAgIEpvaS5mdW5jKClcbl0pXG4gICAgLmRlZmF1bHQoJ2Vycm9yJyk7XG5cblxuaW50ZXJuYWxzLnJvdXRlQmFzZSA9IEpvaS5vYmplY3Qoe1xuICAgIGFwcDogSm9pLm9iamVjdCgpLmFsbG93KG51bGwpLFxuICAgIGF1dGg6IGludGVybmFscy5hdXRoLmFsbG93KGZhbHNlKSxcbiAgICBiaW5kOiBKb2kub2JqZWN0KCkuYWxsb3cobnVsbCksXG4gICAgY2FjaGU6IEpvaS5vYmplY3Qoe1xuICAgICAgICBleHBpcmVzSW46IEpvaS5udW1iZXIoKSxcbiAgICAgICAgZXhwaXJlc0F0OiBKb2kuc3RyaW5nKCksXG4gICAgICAgIHByaXZhY3k6IEpvaS52YWxpZCgnZGVmYXVsdCcsICdwdWJsaWMnLCAncHJpdmF0ZScpLFxuICAgICAgICBzdGF0dXNlczogSm9pLmFycmF5KCkuaXRlbXMoSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMjAwKSkubWluKDEpLnNpbmdsZSgpLmRlZmF1bHQoWzIwMCwgMjA0XSksXG4gICAgICAgIG90aGVyd2lzZTogSm9pLnN0cmluZygpLmRlZmF1bHQoJ25vLWNhY2hlJylcbiAgICB9KVxuICAgICAgICAuYWxsb3coZmFsc2UpXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAgY29tcHJlc3Npb246IEpvaS5vYmplY3QoKVxuICAgICAgICAucGF0dGVybigvLisvLCBKb2kub2JqZWN0KCkpXG4gICAgICAgIC5kZWZhdWx0KCksXG4gICAgY29yczogSm9pLm9iamVjdCh7XG4gICAgICAgIG9yaWdpbjogSm9pLmFycmF5KCkubWluKDEpLmFsbG93KCdpZ25vcmUnKS5kZWZhdWx0KFsnKiddKSxcbiAgICAgICAgbWF4QWdlOiBKb2kubnVtYmVyKCkuZGVmYXVsdCg4NjQwMCksXG4gICAgICAgIGhlYWRlcnM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuZGVmYXVsdChbJ0FjY2VwdCcsICdBdXRob3JpemF0aW9uJywgJ0NvbnRlbnQtVHlwZScsICdJZi1Ob25lLU1hdGNoJ10pLFxuICAgICAgICBhZGRpdGlvbmFsSGVhZGVyczogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5kZWZhdWx0KFtdKSxcbiAgICAgICAgZXhwb3NlZEhlYWRlcnM6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuZGVmYXVsdChbJ1dXVy1BdXRoZW50aWNhdGUnLCAnU2VydmVyLUF1dGhvcml6YXRpb24nXSksXG4gICAgICAgIGFkZGl0aW9uYWxFeHBvc2VkSGVhZGVyczogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5kZWZhdWx0KFtdKSxcbiAgICAgICAgY3JlZGVudGlhbHM6IEpvaS5ib29sZWFuKCkud2hlbignb3JpZ2luJywgeyBpczogJ2lnbm9yZScsIHRoZW46IGZhbHNlIH0pLmRlZmF1bHQoZmFsc2UpXG4gICAgfSlcbiAgICAgICAgLmFsbG93KGZhbHNlLCB0cnVlKVxuICAgICAgICAuZGVmYXVsdChmYWxzZSksXG4gICAgZXh0OiBKb2kub2JqZWN0KHtcbiAgICAgICAgb25QcmVBdXRoOiBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuZXZlbnQpLnNpbmdsZSgpLFxuICAgICAgICBvbkNyZWRlbnRpYWxzOiBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuZXZlbnQpLnNpbmdsZSgpLFxuICAgICAgICBvblBvc3RBdXRoOiBKb2kuYXJyYXkoKS5pdGVtcyhpbnRlcm5hbHMuZXZlbnQpLnNpbmdsZSgpLFxuICAgICAgICBvblByZUhhbmRsZXI6IEpvaS5hcnJheSgpLml0ZW1zKGludGVybmFscy5ldmVudCkuc2luZ2xlKCksXG4gICAgICAgIG9uUG9zdEhhbmRsZXI6IEpvaS5hcnJheSgpLml0ZW1zKGludGVybmFscy5ldmVudCkuc2luZ2xlKCksXG4gICAgICAgIG9uUHJlUmVzcG9uc2U6IEpvaS5hcnJheSgpLml0ZW1zKGludGVybmFscy5ldmVudCkuc2luZ2xlKClcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCh7fSksXG4gICAgZmlsZXM6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWxhdGl2ZVRvOiBKb2kuc3RyaW5nKCkucmVnZXgoL14oW1xcL1xcLl0pfChbQS1aYS16XTpcXFxcKXwoXFxcXFxcXFwpLykuZGVmYXVsdCgnLicpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBqc29uOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcmVwbGFjZXI6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLmZ1bmMoKSwgSm9pLmFycmF5KCkpLmFsbG93KG51bGwpLmRlZmF1bHQobnVsbCksXG4gICAgICAgIHNwYWNlOiBKb2kubnVtYmVyKCkuYWxsb3cobnVsbCkuZGVmYXVsdChudWxsKSxcbiAgICAgICAgc3VmZml4OiBKb2kuc3RyaW5nKCkuYWxsb3cobnVsbCkuZGVmYXVsdChudWxsKSxcbiAgICAgICAgZXNjYXBlOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBqc29ucDogSm9pLnN0cmluZygpLFxuICAgIGxvZzogSm9pLm9iamVjdCh7XG4gICAgICAgIGNvbGxlY3Q6IEpvaS5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSlcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIHBheWxvYWQ6IEpvaS5vYmplY3Qoe1xuICAgICAgICBvdXRwdXQ6IEpvaS52YWxpZCgnZGF0YScsICdzdHJlYW0nLCAnZmlsZScpLmRlZmF1bHQoJ2RhdGEnKSxcbiAgICAgICAgcGFyc2U6IEpvaS5ib29sZWFuKCkuYWxsb3coJ2d1bnppcCcpLmRlZmF1bHQodHJ1ZSksXG4gICAgICAgIG11bHRpcGFydDogSm9pLm9iamVjdCh7XG4gICAgICAgICAgICBvdXRwdXQ6IEpvaS52YWxpZCgnZGF0YScsICdzdHJlYW0nLCAnZmlsZScsICdhbm5vdGF0ZWQnKS5yZXF1aXJlZCgpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuYWxsb3coZmFsc2UpLFxuICAgICAgICBhbGxvdzogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSxcbiAgICAgICAgb3ZlcnJpZGU6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgcHJvdG9BY3Rpb246IEpvaS52YWxpZCgnZXJyb3InLCAncmVtb3ZlJywgJ2lnbm9yZScpLmRlZmF1bHQoJ2Vycm9yJyksXG4gICAgICAgIG1heEJ5dGVzOiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLnBvc2l0aXZlKCkuZGVmYXVsdCgxMDI0ICogMTAyNCksXG4gICAgICAgIHVwbG9hZHM6IEpvaS5zdHJpbmcoKS5kZWZhdWx0KE9zLnRtcGRpcigpKSxcbiAgICAgICAgZmFpbEFjdGlvbjogaW50ZXJuYWxzLmZhaWxBY3Rpb24sXG4gICAgICAgIHRpbWVvdXQ6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkucG9zaXRpdmUoKS5hbGxvdyhmYWxzZSkuZGVmYXVsdCgxMCAqIDEwMDApLFxuICAgICAgICBkZWZhdWx0Q29udGVudFR5cGU6IEpvaS5zdHJpbmcoKS5kZWZhdWx0KCdhcHBsaWNhdGlvbi9qc29uJyksXG4gICAgICAgIGNvbXByZXNzaW9uOiBKb2kub2JqZWN0KClcbiAgICAgICAgICAgIC5wYXR0ZXJuKC8uKy8sIEpvaS5vYmplY3QoKSlcbiAgICAgICAgICAgIC5kZWZhdWx0KClcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIHBsdWdpbnM6IEpvaS5vYmplY3QoKSxcbiAgICByZXNwb25zZTogSm9pLm9iamVjdCh7XG4gICAgICAgIGRpc2Nvbm5lY3RTdGF0dXNDb2RlOiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLm1pbig0MDApLmRlZmF1bHQoNDk5KSxcbiAgICAgICAgZW1wdHlTdGF0dXNDb2RlOiBKb2kudmFsaWQoMjAwLCAyMDQpLmRlZmF1bHQoMjAwKSxcbiAgICAgICAgZmFpbEFjdGlvbjogaW50ZXJuYWxzLmZhaWxBY3Rpb24sXG4gICAgICAgIG1vZGlmeTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgb3B0aW9uczogSm9pLm9iamVjdCgpLmRlZmF1bHQoKSxcbiAgICAgICAgcmFuZ2VzOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQodHJ1ZSksXG4gICAgICAgIHNhbXBsZTogSm9pLm51bWJlcigpLm1pbigwKS5tYXgoMTAwKS53aGVuKCdtb2RpZnknLCB7IGlzOiB0cnVlLCB0aGVuOiBKb2kuZm9yYmlkZGVuKCkgfSksXG4gICAgICAgIHNjaGVtYTogSm9pLmFsdGVybmF0aXZlcyhKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpLCBKb2kuZnVuYygpKS5hbGxvdyh0cnVlLCBmYWxzZSksXG4gICAgICAgIHN0YXR1czogSm9pLm9iamVjdCgpLnBhdHRlcm4oL1xcZFxcZFxcZC8sIEpvaS5hbHRlcm5hdGl2ZXMoSm9pLm9iamVjdCgpLCBKb2kuYXJyYXkoKSwgSm9pLmZ1bmMoKSkuYWxsb3codHJ1ZSwgZmFsc2UpKVxuICAgIH0pXG4gICAgICAgIC5kZWZhdWx0KClcbiAgICAgICAgLmFzc2VydCgnb3B0aW9ucy5zdHJpcFVua25vd24nLCBKb2kud2hlbignbW9kaWZ5JywgeyBpczogdHJ1ZSwgb3RoZXJ3aXNlOiBmYWxzZSB9KSwgJ21lZXQgcmVxdWlyZW1lbnQgb2YgaGF2aW5nIHBlZXIgbW9kaWZ5IHNldCB0byB0cnVlJyksXG4gICAgc2VjdXJpdHk6IEpvaS5vYmplY3Qoe1xuICAgICAgICBoc3RzOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG1heEFnZTogSm9pLm51bWJlcigpLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVTdWJkb21haW5zOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVTdWJEb21haW5zOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgICAgIHByZWxvYWQ6IEpvaS5ib29sZWFuKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIEpvaS5udW1iZXIoKVxuICAgICAgICBdKVxuICAgICAgICAgICAgLmRlZmF1bHQoMTU3NjgwMDApLFxuICAgICAgICB4ZnJhbWU6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICAgICAgSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIEpvaS52YWxpZCgnc2FtZW9yaWdpbicsICdkZW55JyksXG4gICAgICAgICAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBydWxlOiBKb2kudmFsaWQoJ3NhbWVvcmlnaW4nLCAnZGVueScsICdhbGxvdy1mcm9tJyksXG4gICAgICAgICAgICAgICAgc291cmNlOiBKb2kuc3RyaW5nKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF0pXG4gICAgICAgICAgICAuZGVmYXVsdCgnZGVueScpLFxuICAgICAgICB4c3M6IEpvaS5ib29sZWFuKCkuZGVmYXVsdCh0cnVlKSxcbiAgICAgICAgbm9PcGVuOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQodHJ1ZSksXG4gICAgICAgIG5vU25pZmY6IEpvaS5ib29sZWFuKCkuZGVmYXVsdCh0cnVlKSxcbiAgICAgICAgcmVmZXJyZXI6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICAgICAgSm9pLmJvb2xlYW4oKS52YWxpZChmYWxzZSksXG4gICAgICAgICAgICBKb2kudmFsaWQoJycsICduby1yZWZlcnJlcicsICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgICAgICAgICAgICAgJ3Vuc2FmZS11cmwnLCAnc2FtZS1vcmlnaW4nLCAnb3JpZ2luJywgJ3N0cmljdC1vcmlnaW4nLFxuICAgICAgICAgICAgICAgICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nLCAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicpXG4gICAgICAgIF0pXG4gICAgICAgICAgICAuZGVmYXVsdChmYWxzZSlcbiAgICB9KVxuICAgICAgICAuYWxsb3cobnVsbCwgZmFsc2UsIHRydWUpXG4gICAgICAgIC5kZWZhdWx0KGZhbHNlKSxcbiAgICBzdGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHBhcnNlOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQodHJ1ZSksXG4gICAgICAgIGZhaWxBY3Rpb246IGludGVybmFscy5mYWlsQWN0aW9uXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICB0aW1lb3V0OiBKb2kub2JqZWN0KHtcbiAgICAgICAgc29ja2V0OiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLnBvc2l0aXZlKCkuYWxsb3coZmFsc2UpLFxuICAgICAgICBzZXJ2ZXI6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkucG9zaXRpdmUoKS5hbGxvdyhmYWxzZSkuZGVmYXVsdChmYWxzZSlcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIHZhbGlkYXRlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgaGVhZGVyczogSm9pLmFsdGVybmF0aXZlcyhKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpLCBKb2kuZnVuYygpKS5hbGxvdyhudWxsLCB0cnVlKSxcbiAgICAgICAgcGFyYW1zOiBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5vYmplY3QoKSwgSm9pLmFycmF5KCksIEpvaS5mdW5jKCkpLmFsbG93KG51bGwsIHRydWUpLFxuICAgICAgICBxdWVyeTogSm9pLmFsdGVybmF0aXZlcyhKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpLCBKb2kuZnVuYygpKS5hbGxvdyhudWxsLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIHBheWxvYWQ6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLm9iamVjdCgpLCBKb2kuYXJyYXkoKSwgSm9pLmZ1bmMoKSkuYWxsb3cobnVsbCwgZmFsc2UsIHRydWUpLFxuICAgICAgICBzdGF0ZTogSm9pLmFsdGVybmF0aXZlcyhKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpLCBKb2kuZnVuYygpKS5hbGxvdyhudWxsLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIGZhaWxBY3Rpb246IGludGVybmFscy5mYWlsQWN0aW9uLFxuICAgICAgICBlcnJvckZpZWxkczogSm9pLm9iamVjdCgpLFxuICAgICAgICBvcHRpb25zOiBKb2kub2JqZWN0KCkuZGVmYXVsdCgpXG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoKVxufSk7XG5cblxuaW50ZXJuYWxzLnNlcnZlciA9IEpvaS5vYmplY3Qoe1xuICAgIGFkZHJlc3M6IEpvaS5zdHJpbmcoKS5ob3N0bmFtZSgpLFxuICAgIGFwcDogSm9pLm9iamVjdCgpLmFsbG93KG51bGwpLFxuICAgIGF1dG9MaXN0ZW46IEpvaS5ib29sZWFuKCksXG4gICAgY2FjaGU6IEpvaS5hbGxvdyhudWxsKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZWQgZWxzZXdoZXJlXG4gICAgY29tcHJlc3Npb246IEpvaS5vYmplY3Qoe1xuICAgICAgICBtaW5CeXRlczogSm9pLm51bWJlcigpLm1pbigxKS5pbnRlZ2VyKCkuZGVmYXVsdCgxMDI0KVxuICAgIH0pXG4gICAgICAgIC5hbGxvdyhmYWxzZSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBkZWJ1ZzogSm9pLm9iamVjdCh7XG4gICAgICAgIHJlcXVlc3Q6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCkuYWxsb3coZmFsc2UpLmRlZmF1bHQoWydpbXBsZW1lbnRhdGlvbiddKSxcbiAgICAgICAgbG9nOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpLmFsbG93KGZhbHNlKVxuICAgIH0pXG4gICAgICAgIC5hbGxvdyhmYWxzZSlcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBob3N0OiBKb2kuc3RyaW5nKCkuaG9zdG5hbWUoKS5hbGxvdyhudWxsKSxcbiAgICBsaXN0ZW5lcjogSm9pLmFueSgpLFxuICAgIGxvYWQ6IEpvaS5vYmplY3Qoe1xuICAgICAgICBzYW1wbGVJbnRlcnZhbDogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMCkuZGVmYXVsdCgwKSxcbiAgICAgICAgY29uY3VycmVudDogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMCkuZGVmYXVsdCgwKVxuICAgIH0pXG4gICAgICAgIC51bmtub3duKClcbiAgICAgICAgLmRlZmF1bHQoKSxcbiAgICBtaW1lOiBKb2kub2JqZWN0KCkuYWxsb3cobnVsbCkuZGVmYXVsdChudWxsKSxcbiAgICBvcGVyYXRpb25zOiBKb2kub2JqZWN0KHtcbiAgICAgICAgY2xlYW5TdG9wOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQodHJ1ZSlcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIHBsdWdpbnM6IEpvaS5vYmplY3QoKSxcbiAgICBwb3J0OiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMCksICAgICAgICAgIC8vIFRDUCBwb3J0XG4gICAgICAgIEpvaS5zdHJpbmcoKS5yZWdleCgvXFwvLyksICAgICAgICAgICAgICAgLy8gVW5peCBkb21haW4gc29ja2V0XG4gICAgICAgIEpvaS5zdHJpbmcoKS5yZWdleCgvXlxcXFxcXFxcXFwuXFxcXHBpcGVcXFxcLykgICAvLyBXaW5kb3dzIG5hbWVkIHBpcGVcbiAgICBdKVxuICAgICAgICAuYWxsb3cobnVsbCksXG4gICAgcXVlcnk6IEpvaS5vYmplY3Qoe1xuICAgICAgICBwYXJzZXI6IEpvaS5mdW5jKClcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIHJvdXRlcjogSm9pLm9iamVjdCh7XG4gICAgICAgIGlzQ2FzZVNlbnNpdGl2ZTogSm9pLmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLFxuICAgICAgICBzdHJpcFRyYWlsaW5nU2xhc2g6IEpvaS5ib29sZWFuKCkuZGVmYXVsdChmYWxzZSlcbiAgICB9KVxuICAgICAgICAuZGVmYXVsdCgpLFxuICAgIHJvdXRlczogaW50ZXJuYWxzLnJvdXRlQmFzZS5kZWZhdWx0KCksXG4gICAgc3RhdGU6IEpvaS5vYmplY3QoKSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb29raWUgZGVmYXVsdHNcbiAgICB0bHM6IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgICAgICBKb2kub2JqZWN0KCkuYWxsb3cobnVsbCksXG4gICAgICAgIEpvaS5ib29sZWFuKClcbiAgICBdKSxcbiAgICB1cmk6IEpvaS5zdHJpbmcoKS5yZWdleCgvW14vXSQvKVxufSk7XG5cblxuaW50ZXJuYWxzLnZob3N0ID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLnN0cmluZygpLmhvc3RuYW1lKCksXG4gICAgSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpLmhvc3RuYW1lKCkpLm1pbigxKVxuXSk7XG5cblxuaW50ZXJuYWxzLmhhbmRsZXIgPSBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICBKb2kuZnVuYygpLFxuICAgIEpvaS5vYmplY3QoKS5sZW5ndGgoMSlcbl0pO1xuXG5cbmludGVybmFscy5yb3V0ZSA9IEpvaS5vYmplY3Qoe1xuICAgIG1ldGhvZDogSm9pLnN0cmluZygpLnJlZ2V4KC9eW2EtekEtWjAtOSEjXFwkJSYnXFwqXFwrXFwtXFwuXl9gXFx8fl0rJC8pLnJlcXVpcmVkKCksXG4gICAgcGF0aDogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgcnVsZXM6IEpvaS5vYmplY3QoKSxcbiAgICB2aG9zdDogaW50ZXJuYWxzLnZob3N0LFxuXG4gICAgLy8gVmFsaWRhdGVkIGluIHJvdXRlIGNvbnN0cnVjdGlvblxuXG4gICAgaGFuZGxlcjogSm9pLmFueSgpLFxuICAgIG9wdGlvbnM6IEpvaS5hbnkoKSxcbiAgICBjb25maWc6IEpvaS5hbnkoKSAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG59KVxuICAgIC53aXRob3V0KCdjb25maWcnLCAnb3B0aW9ucycpO1xuXG5cbmludGVybmFscy5wcmUgPSBbXG4gICAgSm9pLmZ1bmMoKSxcbiAgICBKb2kub2JqZWN0KHtcbiAgICAgICAgbWV0aG9kOiBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5zdHJpbmcoKSwgSm9pLmZ1bmMoKSkucmVxdWlyZWQoKSxcbiAgICAgICAgYXNzaWduOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG1vZGU6IEpvaS52YWxpZCgnc2VyaWFsJywgJ3BhcmFsbGVsJyksXG4gICAgICAgIGZhaWxBY3Rpb246IGludGVybmFscy5mYWlsQWN0aW9uXG4gICAgfSlcbl07XG5cblxuaW50ZXJuYWxzLnJvdXRlQ29uZmlnID0gaW50ZXJuYWxzLnJvdXRlQmFzZS5rZXlzKHtcbiAgICBkZXNjcmlwdGlvbjogSm9pLnN0cmluZygpLFxuICAgIGlkOiBKb2kuc3RyaW5nKCksXG4gICAgaXNJbnRlcm5hbDogSm9pLmJvb2xlYW4oKSxcbiAgICBub3RlczogW1xuICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSlcbiAgICBdLFxuICAgIHByZTogSm9pLmFycmF5KCkuaXRlbXMoaW50ZXJuYWxzLnByZS5jb25jYXQoSm9pLmFycmF5KCkuaXRlbXMoaW50ZXJuYWxzLnByZSkubWluKDEpKSksXG4gICAgdGFnczogW1xuICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSlcbiAgICBdXG59KTtcblxuXG5pbnRlcm5hbHMuY2FjaGVDb25maWcgPSBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICBKb2kuZnVuYygpLFxuICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkuaW52YWxpZCgnX2RlZmF1bHQnKSxcbiAgICAgICAgc2hhcmVkOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBwcm92aWRlcjogW1xuICAgICAgICAgICAgSm9pLmZ1bmMoKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogSm9pLmZ1bmMoKS5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aXRpb246IEpvaS5zdHJpbmcoKS5kZWZhdWx0KCdoYXBpLWNhY2hlJylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudW5rbm93bigpICAgICAgLy8gQ2F0Ym94IGNsaWVudCB2YWxpZGF0ZXMgb3RoZXIga2V5c1xuICAgICAgICAgICAgICAgICAgICAuZGVmYXVsdCh7fSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgZW5naW5lOiBKb2kub2JqZWN0KClcbiAgICB9KVxuICAgICAgICAueG9yKCdwcm92aWRlcicsICdlbmdpbmUnKVxuXSk7XG5cblxuaW50ZXJuYWxzLmNhY2hlID0gSm9pLmFycmF5KCkuaXRlbXMoaW50ZXJuYWxzLmNhY2hlQ29uZmlnKS5taW4oMSkuc2luZ2xlKCk7XG5cblxuaW50ZXJuYWxzLmNhY2hlUG9saWN5ID0gSm9pLm9iamVjdCh7XG4gICAgY2FjaGU6IEpvaS5zdHJpbmcoKS5hbGxvdyhudWxsKS5hbGxvdygnJyksXG4gICAgc2VnbWVudDogSm9pLnN0cmluZygpLFxuICAgIHNoYXJlZDogSm9pLmJvb2xlYW4oKVxufSlcbiAgICAudW5rbm93bigpOyAgICAgICAgICAgICAgICAgICAgIC8vIENhdGJveCBwb2xpY3kgdmFsaWRhdGVzIG90aGVyIGtleXNcblxuXG5pbnRlcm5hbHMubWV0aG9kID0gSm9pLm9iamVjdCh7XG4gICAgYmluZDogSm9pLm9iamVjdCgpLmFsbG93KG51bGwpLFxuICAgIGdlbmVyYXRlS2V5OiBKb2kuZnVuYygpLFxuICAgIGNhY2hlOiBpbnRlcm5hbHMuY2FjaGVQb2xpY3lcbn0pO1xuXG5cbmludGVybmFscy5tZXRob2RPYmplY3QgPSBKb2kub2JqZWN0KHtcbiAgICBuYW1lOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICBtZXRob2Q6IEpvaS5mdW5jKCkucmVxdWlyZWQoKSxcbiAgICBvcHRpb25zOiBKb2kub2JqZWN0KClcbn0pO1xuXG5cbmludGVybmFscy5yZWdpc3RlciA9IEpvaS5vYmplY3Qoe1xuICAgIG9uY2U6IHRydWUsXG4gICAgcm91dGVzOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcHJlZml4OiBKb2kuc3RyaW5nKCkucmVnZXgoL15cXC8uKy8pLFxuICAgICAgICB2aG9zdDogaW50ZXJuYWxzLnZob3N0XG4gICAgfSlcbiAgICAgICAgLmRlZmF1bHQoe30pXG59KTtcblxuXG5pbnRlcm5hbHMuc2VtdmVyID0gSm9pLnN0cmluZygpO1xuXG5cbmludGVybmFscy5wbHVnaW4gPSBpbnRlcm5hbHMucmVnaXN0ZXIua2V5cyh7XG4gICAgb3B0aW9uczogSm9pLmFueSgpLFxuICAgIHBsdWdpbjogSm9pLm9iamVjdCh7XG4gICAgICAgIHJlZ2lzdGVyOiBKb2kuZnVuYygpLnJlcXVpcmVkKCksXG4gICAgICAgIG5hbWU6IEpvaS5zdHJpbmcoKS53aGVuKCdwa2cubmFtZScsIHsgaXM6IEpvaS5leGlzdCgpLCBvdGhlcndpc2U6IEpvaS5yZXF1aXJlZCgpIH0pLFxuICAgICAgICB2ZXJzaW9uOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG11bHRpcGxlOiBKb2kuYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgICAgICAgIEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCksXG4gICAgICAgICAgICBKb2kub2JqZWN0KCkucGF0dGVybigvLisvLCBpbnRlcm5hbHMuc2VtdmVyKVxuICAgICAgICBdLFxuICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICByZXF1aXJlbWVudHM6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgaGFwaTogSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgbm9kZTogSm9pLnN0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZGVmYXVsdCgpLFxuICAgICAgICBwa2c6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgdmVyc2lvbjogSm9pLnN0cmluZygpLmRlZmF1bHQoJzAuMC4wJylcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC51bmtub3duKClcbiAgICAgICAgICAgIC5kZWZhdWx0KHt9KVxuICAgIH0pXG4gICAgICAgIC51bmtub3duKClcbn0pXG4gICAgLndpdGhvdXQoJ29uY2UnLCAnb3B0aW9ucycpXG4gICAgLnVua25vd24oKTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBKb2kub2JqZWN0KHtcbiAgICB2YWxpZGF0ZTogSm9pLm9iamVjdCh7XG4gICAgICAgIHNjaGVtYTogSm9pLmFsdGVybmF0aXZlcyhKb2kub2JqZWN0KCksIEpvaS5hcnJheSgpKS5yZXF1aXJlZCgpLFxuICAgICAgICBvcHRpb25zOiBKb2kub2JqZWN0KClcbiAgICAgICAgICAgIC5kZWZhdWx0KHsgYWxsb3dVbmtub3duOiB0cnVlIH0pXG4gICAgfSlcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIdHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgSHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgT3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgQ2FsbCA9IHJlcXVpcmUoJ0BoYXBpL2NhbGwnKTtcbmNvbnN0IENhdGJveCA9IHJlcXVpcmUoJ0BoYXBpL2NhdGJveCcpO1xuY29uc3QgQ2F0Ym94TWVtb3J5ID0gcmVxdWlyZSgnQGhhcGkvY2F0Ym94LW1lbW9yeScpO1xuY29uc3QgSGVhdnkgPSByZXF1aXJlKCdAaGFwaS9oZWF2eScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IE1pbW9zID0gcmVxdWlyZSgnQGhhcGkvbWltb3MnKTtcbmNvbnN0IFBvZGl1bSA9IHJlcXVpcmUoJ0BoYXBpL3BvZGl1bScpO1xuY29uc3QgU29tZXZlciA9IHJlcXVpcmUoJ0BoYXBpL3NvbWV2ZXInKTtcbmNvbnN0IFN0YXRlaG9vZCA9IHJlcXVpcmUoJ0BoYXBpL3N0YXRlaG9vZCcpO1xuXG5jb25zdCBBdXRoID0gcmVxdWlyZSgnLi9hdXRoJyk7XG5jb25zdCBDb21wcmVzc2lvbiA9IHJlcXVpcmUoJy4vY29tcHJlc3Npb24nKTtcbmNvbnN0IENvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5jb25zdCBDb3JzID0gcmVxdWlyZSgnLi9jb3JzJyk7XG5jb25zdCBFeHQgPSByZXF1aXJlKCcuL2V4dCcpO1xuY29uc3QgTWV0aG9kcyA9IHJlcXVpcmUoJy4vbWV0aG9kcycpO1xuY29uc3QgUmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xuY29uc3QgUm91dGUgPSByZXF1aXJlKCcuL3JvdXRlJyk7XG5jb25zdCBUb29sa2l0ID0gcmVxdWlyZSgnLi90b29sa2l0Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGNvdW50ZXI6IHtcbiAgICAgICAgbWluOiAxMDAwMCxcbiAgICAgICAgbWF4OiA5OTk5OVxuICAgIH0sXG4gICAgZXZlbnRzOiBbXG4gICAgICAgIHsgbmFtZTogJ2xvZycsIGNoYW5uZWxzOiBbJ2FwcCcsICdpbnRlcm5hbCddLCB0YWdzOiB0cnVlIH0sXG4gICAgICAgIHsgbmFtZTogJ3JlcXVlc3QnLCBjaGFubmVsczogWydhcHAnLCAnaW50ZXJuYWwnLCAnZXJyb3InXSwgdGFnczogdHJ1ZSwgc3ByZWFkOiB0cnVlIH0sXG4gICAgICAgICdyZXNwb25zZScsXG4gICAgICAgICdyb3V0ZScsXG4gICAgICAgICdzdGFydCcsXG4gICAgICAgICdzdG9wJ1xuICAgIF0sXG4gICAgYmFkUmVxdWVzdFJlc3BvbnNlOiBCdWZmZXIuZnJvbSgnSFRUUC8xLjEgNDAwIEJhZCBSZXF1ZXN0XFxyXFxuXFxyXFxuJywgJ2FzY2lpJylcbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLkNvcmUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNwYXRjaCByZWZlcmVuY2Ugb2YgdGhlIHJvb3Qgc2VydmVyXG5cbiAgICAgICAgY29uc3QgeyBzZXR0aW5ncywgdHlwZSB9ID0gaW50ZXJuYWxzLnNldHVwKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgICAgICB0aGlzLmFwcCA9IHt9O1xuICAgICAgICB0aGlzLmF1dGggPSBuZXcgQXV0aCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWNoZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSBjbGllbnRzXG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSBuZXcgQ29tcHJlc3Npb24oKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVkID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlciBzZXJ2ZXJzIGxpbmtlZCB0byB0aGUgcGhhc2VzIG9mIHRoaXMgc2VydmVyXG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB7IGhhbmRsZXI6IFtdLCByZXF1ZXN0OiBbXSwgc2VydmVyOiBbXSwgdG9vbGtpdDogW10gfTsgICAgICAgLy8gUHVibGljIGRlY29yYXRpb24gbmFtZXNcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQbHVnaW4gZGVwZW5kZW5jaWVzXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IFBvZGl1bShpbnRlcm5hbHMuZXZlbnRzKTtcbiAgICAgICAgdGhpcy5oZWF2eSA9IG5ldyBIZWF2eSh0aGlzLnNldHRpbmdzLmxvYWQpO1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5tZXRob2RzID0gbmV3IE1ldGhvZHModGhpcyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXJ2ZXIgbWV0aG9kc1xuICAgICAgICB0aGlzLm1pbWUgPSBuZXcgTWltb3ModGhpcy5zZXR0aW5ncy5taW1lKTtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb24gPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VkIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBvbiBzdG9wXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwb3NlZCBwbHVnaW4gcHJvcGVydGllcyBieSBuYW1lXG4gICAgICAgIHRoaXMucXVldWUgPSBuZXcgaW50ZXJuYWxzLlF1ZXVlKHRoaXMuc2V0dGluZ3MubG9hZCk7XG4gICAgICAgIHRoaXMucmVnaXN0cmF0aW9ucyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2tzIHBsdWdpbiBmb3IgZGVwZW5kZW5jeSB2YWxpZGF0aW9uIHsgbmFtZSAtPiB7IHZlcnNpb24gfSB9XG4gICAgICAgIHRoaXMucmVnaXN0cmluZyA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPiAwIHdoaWxlIHJlZ2lzdGVyKCkgaXMgd2FpdGluZyBmb3IgcGx1Z2luIGNhbGxiYWNrc1xuICAgICAgICB0aGlzLnJlcXVlc3RDb3VudGVyID0geyB2YWx1ZTogaW50ZXJuYWxzLmNvdW50ZXIubWluLCBtaW46IGludGVybmFscy5jb3VudGVyLm1pbiwgbWF4OiBpbnRlcm5hbHMuY291bnRlci5tYXggfTtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSBuZXcgQ2FsbC5Sb3V0ZXIodGhpcy5zZXR0aW5ncy5yb3V0ZXIpO1xuICAgICAgICB0aGlzLnBoYXNlID0gJ3N0b3BwZWQnOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICdzdG9wcGVkJywgJ2luaXRpYWxpemluZycsICdpbml0aWFsaXplZCcsICdzdGFydGluZycsICdzdGFydGVkJywgJ3N0b3BwaW5nJywgJ2ludmFsaWQnXG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhY2sgb3BlbiBzb2NrZXRzIGZvciBncmFjZWZ1bCBzaHV0ZG93blxuICAgICAgICB0aGlzLmFjdGl2ZXMgPSBuZXcgV2Vha01hcCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjdGl2ZSByZXF1ZXN0cyBiZWluZyBwcm9jZXNzZWRcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlaG9vZC5EZWZpbml0aW9ucyh0aGlzLnNldHRpbmdzLnN0YXRlKTtcbiAgICAgICAgdGhpcy50b29sa2l0ID0gbmV3IFRvb2xraXQoKTtcblxuICAgICAgICB0aGlzLmV4dGVuc2lvbnNTZXEgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgdG8ga2VlcCBhYnNvbHV0ZSBvcmRlciBvZiBleHRlbnNpb25zIGJhc2VkIG9uIHRoZSBvcmRlciBhZGRlZCBhY3Jvc3MgbG9jYXRpb25zXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHNlcnZlcjoge1xuICAgICAgICAgICAgICAgIG9uUHJlU3RhcnQ6IG5ldyBFeHQoJ29uUHJlU3RhcnQnLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBvblBvc3RTdGFydDogbmV3IEV4dCgnb25Qb3N0U3RhcnQnLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBvblByZVN0b3A6IG5ldyBFeHQoJ29uUHJlU3RvcCcsIHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uUG9zdFN0b3A6IG5ldyBFeHQoJ29uUG9zdFN0b3AnLCB0aGlzKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgICAgICAgb25SZXF1ZXN0OiBuZXcgRXh0KCdvblJlcXVlc3QnLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBvblByZUF1dGg6IG5ldyBFeHQoJ29uUHJlQXV0aCcsIHRoaXMpLFxuICAgICAgICAgICAgICAgIG9uQ3JlZGVudGlhbHM6IG5ldyBFeHQoJ29uQ3JlZGVudGlhbHMnLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBvblBvc3RBdXRoOiBuZXcgRXh0KCdvblBvc3RBdXRoJywgdGhpcyksXG4gICAgICAgICAgICAgICAgb25QcmVIYW5kbGVyOiBuZXcgRXh0KCdvblByZUhhbmRsZXInLCB0aGlzKSxcbiAgICAgICAgICAgICAgICBvblBvc3RIYW5kbGVyOiBuZXcgRXh0KCdvblBvc3RIYW5kbGVyJywgdGhpcyksXG4gICAgICAgICAgICAgICAgb25QcmVSZXNwb25zZTogbmV3IEV4dCgnb25QcmVSZXNwb25zZScsIHRoaXMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5SZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBSZXF1ZXN0IHsgfTtcblxuICAgICAgICB0aGlzLl9kZWJ1ZygpO1xuICAgICAgICB0aGlzLl9kZWNvcmF0aW9ucyA9IHsgaGFuZGxlcjoge30sIHJlcXVlc3Q6IHt9LCBzZXJ2ZXI6IHt9LCB0b29sa2l0OiB7fSwgcmVxdWVzdEFwcGx5OiBudWxsIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVDYWNoZSgpO1xuXG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSB0aGlzLl9jcmVhdGVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5pbmZvID0gdGhpcy5faW5mbygpO1xuICAgIH1cblxuICAgIF9kZWJ1ZygpIHtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gc2VydmVyIGxvZyBldmVudHNcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc3QgZGVidWcgPSAocmVxdWVzdCwgZXZlbnQpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5lcnJvciB8fCBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RlYnVnOicsIGV2ZW50LnRhZ3Muam9pbignLCAnKSwgZGF0YSA/ICdcXG4gICAgJyArIChkYXRhLnN0YWNrIHx8ICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBIb2VrLnN0cmluZ2lmeShkYXRhKSA6IGRhdGEpKSA6ICcnKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmRlYnVnLmxvZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuc2V0dGluZ3MuZGVidWcubG9nLnNvbWUoKHRhZykgPT4gdGFnID09PSAnKicpID8gdW5kZWZpbmVkIDogdGhpcy5zZXR0aW5ncy5kZWJ1Zy5sb2c7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMub24oeyBuYW1lOiAnbG9nJywgZmlsdGVyIH0sIChldmVudCkgPT4gZGVidWcobnVsbCwgZXZlbnQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZGVidWcucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuc2V0dGluZ3MuZGVidWcucmVxdWVzdC5zb21lKCh0YWcpID0+IHRhZyA9PT0gJyonKSA/IHVuZGVmaW5lZCA6IHRoaXMuc2V0dGluZ3MuZGVidWcucmVxdWVzdDtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5vbih7IG5hbWU6ICdyZXF1ZXN0JywgZmlsdGVyIH0sIGRlYnVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9pbml0aWFsaXplQ2FjaGUoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlKHRoaXMuc2V0dGluZ3MuY2FjaGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlcy5oYXMoJ19kZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNhY2hlKFt7IHByb3ZpZGVyOiBDYXRib3hNZW1vcnkgfV0pOyAgICAgICAgLy8gRGVmYXVsdHMgdG8gbWVtb3J5LWJhc2VkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaW5mbygpIHtcblxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHRoaXMudHlwZSA9PT0gJ3RjcCcgPyAodGhpcy5zZXR0aW5ncy50bHMgPyAnaHR0cHMnIDogJ2h0dHAnKSA6IHRoaXMudHlwZTtcbiAgICAgICAgY29uc3QgaG9zdCA9IHRoaXMuc2V0dGluZ3MuaG9zdCB8fCBPcy5ob3N0bmFtZSgpIHx8ICdsb2NhbGhvc3QnO1xuICAgICAgICBjb25zdCBwb3J0ID0gdGhpcy5zZXR0aW5ncy5wb3J0O1xuXG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgICBjcmVhdGVkOiBub3csXG4gICAgICAgICAgICBzdGFydGVkOiAwLFxuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgIGlkOiBPcy5ob3N0bmFtZSgpICsgJzonICsgcHJvY2Vzcy5waWQgKyAnOicgKyBub3cudG9TdHJpbmcoMzYpLFxuICAgICAgICAgICAgdXJpOiB0aGlzLnNldHRpbmdzLnVyaSB8fCAocHJvdG9jb2wgKyAnOicgKyAodGhpcy50eXBlID09PSAndGNwJyA/ICcvLycgKyBob3N0ICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpIDogcG9ydCkpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNhY2hlKGNvbmZpZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLnBoYXNlICE9PSAnaW5pdGlhbGl6aW5nJywgJ0Nhbm5vdCBwcm92aXNpb24gc2VydmVyIGNhY2hlIHdoaWxlIHNlcnZlciBpcyBpbml0aWFsaXppbmcnKTtcblxuICAgICAgICBjb25maWdzID0gQ29uZmlnLmFwcGx5KCdjYWNoZScsIGNvbmZpZ3MpO1xuXG4gICAgICAgIGNvbnN0IGFkZGVkID0gW107XG4gICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKSB7XG5cbiAgICAgICAgICAgIC8vIDxmdW5jdGlvbj5cbiAgICAgICAgICAgIC8vIHsgcHJvdmlkZXI6IDxmdW5jdGlvbj4gfVxuICAgICAgICAgICAgLy8geyBwcm92aWRlcjogeyBjb25zdHJ1Y3RvcjogPGZ1bmN0aW9uPiwgb3B0aW9ucyB9IH1cbiAgICAgICAgICAgIC8vIHsgZW5naW5lIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25maWcgPSB7IHByb3ZpZGVyOiB7IGNvbnN0cnVjdG9yOiBjb25maWcgfSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29uZmlnLm5hbWUgfHwgJ19kZWZhdWx0JztcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCF0aGlzLmNhY2hlcy5oYXMobmFtZSksICdDYW5ub3QgY29uZmlndXJlIHRoZSBzYW1lIGNhY2hlIG1vcmUgdGhhbiBvbmNlOiAnLCBuYW1lID09PSAnX2RlZmF1bHQnID8gJ2RlZmF1bHQgY2FjaGUnIDogbmFtZSk7XG5cbiAgICAgICAgICAgIGxldCBjbGllbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoY29uZmlnLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3ZpZGVyID0gY29uZmlnLnByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB7IGNvbnN0cnVjdG9yOiBwcm92aWRlciB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsaWVudCA9IG5ldyBDYXRib3guQ2xpZW50KHByb3ZpZGVyLmNvbnN0cnVjdG9yLCBwcm92aWRlci5vcHRpb25zIHx8IHsgcGFydGl0aW9uOiAnaGFwaS1jYWNoZScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGllbnQgPSBuZXcgQ2F0Ym94LkNsaWVudChjb25maWcuZW5naW5lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jYWNoZXMuc2V0KG5hbWUsIHsgY2xpZW50LCBzZWdtZW50czoge30sIHNoYXJlZDogY29uZmlnLnNoYXJlZCB8fCBmYWxzZSB9KTtcbiAgICAgICAgICAgIGFkZGVkLnB1c2goY2xpZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGRlZDtcbiAgICB9XG5cbiAgICByZWdpc3RlclNlcnZlcihzZXJ2ZXIpIHtcblxuICAgICAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gc2VydmVyO1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFJvdXRlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnN0YW5jZXMuYWRkKHNlcnZlcik7XG4gICAgfVxuXG4gICAgYXN5bmMgX3N0YXJ0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLnBoYXNlID09PSAnaW5pdGlhbGl6ZWQnIHx8XG4gICAgICAgICAgICB0aGlzLnBoYXNlID09PSAnc3RhcnRlZCcpIHtcblxuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVEZXBzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5waGFzZSA9PT0gJ3N0YXJ0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5waGFzZSAhPT0gJ3N0b3BwZWQnICYmXG4gICAgICAgICAgICB0aGlzLnBoYXNlICE9PSAnaW5pdGlhbGl6ZWQnKSB7XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN0YXJ0IHNlcnZlciB3aGlsZSBpdCBpcyBpbiAnICsgdGhpcy5waGFzZSArICcgcGhhc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBoYXNlICE9PSAnaW5pdGlhbGl6ZWQnKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBoYXNlID0gJ3N0YXJ0aW5nJztcbiAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbmZvLnN0YXJ0ZWQgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9saXN0ZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucGhhc2UgPSAnaW52YWxpZCc7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBoYXNlID0gJ3N0YXJ0ZWQnO1xuICAgICAgICBhd2FpdCB0aGlzLmV2ZW50cy5lbWl0KCdzdGFydCcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jb250cm9sbGVkLm1hcCgoY29udHJvbCkgPT4gY29udHJvbC5zdGFydCgpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2ludm9rZSgnb25Qb3N0U3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnBoYXNlID0gJ2ludmFsaWQnO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2xpc3RlbigpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuYXV0b0xpc3Rlbikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG5cbiAgICAgICAgICAgIGNvbnN0IGZpbmFsaXplID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3RjcCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLmxpc3Rlbih0aGlzLnNldHRpbmdzLnBvcnQsIGZpbmFsaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLnNldHRpbmdzLmFkZHJlc3MgfHwgdGhpcy5zZXR0aW5ncy5ob3N0IHx8ICcwLjAuMC4wJztcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLmxpc3Rlbih0aGlzLnNldHRpbmdzLnBvcnQsIGFkZHJlc3MsIGZpbmFsaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2luaXRpYWxpemUoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucmVnaXN0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3RhcnQgc2VydmVyIGJlZm9yZSBwbHVnaW5zIGZpbmlzaGVkIHJlZ2lzdHJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGhhc2UgPT09ICdpbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBoYXNlICE9PSAnc3RvcHBlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGluaXRpYWxpemUgc2VydmVyIHdoaWxlIGl0IGlzIGluICcgKyB0aGlzLnBoYXNlICsgJyBwaGFzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsaWRhdGVEZXBzKCk7XG4gICAgICAgIHRoaXMucGhhc2UgPSAnaW5pdGlhbGl6aW5nJztcblxuICAgICAgICAvLyBTdGFydCBjYWNoZVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVzLmZvckVhY2goKGNhY2hlKSA9PiBjYWNoZXMucHVzaChjYWNoZS5jbGllbnQuc3RhcnQoKSkpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGVzKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2ludm9rZSgnb25QcmVTdGFydCcpO1xuICAgICAgICAgICAgdGhpcy5oZWF2eS5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5waGFzZSA9ICdpbml0aWFsaXplZCc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNvbnRyb2xsZWQubWFwKChjb250cm9sKSA9PiBjb250cm9sLmluaXRpYWxpemUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucGhhc2UgPSAnaW52YWxpZCc7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdmFsaWRhdGVEZXBzKCkge1xuXG4gICAgICAgIGZvciAoY29uc3QgeyBkZXBzLCBwbHVnaW4gfSBvZiB0aGlzLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXAgaW4gZGVwcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBkZXBzW2RlcF07XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodGhpcy5yZWdpc3RyYXRpb25zW2RlcF0sICdQbHVnaW4nLCBwbHVnaW4sICdtaXNzaW5nIGRlcGVuZGVuY3knLCBkZXApO1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZlcnNpb24gPT09ICcqJyB8fCBTb21ldmVyLm1hdGNoKHRoaXMucmVnaXN0cmF0aW9uc1tkZXBdLnZlcnNpb24sIHZlcnNpb24pLCAnUGx1Z2luJywgcGx1Z2luLCAncmVxdWlyZXMnLCBkZXAsICd2ZXJzaW9uJywgdmVyc2lvbiwgJ2J1dCBmb3VuZCcsIHRoaXMucmVnaXN0cmF0aW9uc1tkZXBdLnZlcnNpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgX3N0b3Aob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgb3B0aW9ucy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDUwMDA7ICAgICAgICAgIC8vIERlZmF1bHQgdGltZW91dCB0byA1IHNlY29uZHNcblxuICAgICAgICBpZiAoWydzdG9wcGVkJywgJ2luaXRpYWxpemVkJywgJ3N0YXJ0ZWQnLCAnaW52YWxpZCddLmluZGV4T2YodGhpcy5waGFzZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdG9wIHNlcnZlciB3aGlsZSBpbiAnICsgdGhpcy5waGFzZSArICcgcGhhc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGhhc2UgPSAnc3RvcHBpbmcnO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9pbnZva2UoJ29uUHJlU3RvcCcpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmZvLnN0YXJ0ZWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdW5saXN0ZW4ob3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2FjaGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmNhY2hlcy5mb3JFYWNoKChjYWNoZSkgPT4gY2FjaGVzLnB1c2goY2FjaGUuY2xpZW50LnN0b3AoKSkpO1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2FjaGVzKTtcblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5ldmVudHMuZW1pdCgnc3RvcCcpO1xuICAgICAgICAgICAgdGhpcy5oZWF2eS5zdG9wKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNvbnRyb2xsZWQubWFwKChjb250cm9sKSA9PiBjb250cm9sLnN0b3Aob3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgdGhpcy5faW52b2tlKCdvblBvc3RTdG9wJyk7XG4gICAgICAgICAgICB0aGlzLnBoYXNlID0gJ3N0b3BwZWQnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucGhhc2UgPSAnaW52YWxpZCc7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdW5saXN0ZW4odGltZW91dCkge1xuXG4gICAgICAgIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vcGVyYXRpb25zLmNsZWFuU3RvcCkge1xuXG4gICAgICAgICAgICAvLyBTZXQgY29ubmVjdGlvbnMgdGltZW91dFxuXG4gICAgICAgICAgICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmZvckVhY2goKGNvbm5lY3Rpb24pID0+IGNvbm5lY3Rpb24uZGVzdHJveSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldHMuY2xlYXIoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVzdHJveSwgdGltZW91dCk7XG5cbiAgICAgICAgICAgIC8vIFRlbGwgaWRsZSBrZWVwLWFsaXZlIGNvbm5lY3Rpb25zIHRvIGNsb3NlXG5cbiAgICAgICAgICAgIHRoaXMuc29ja2V0cy5mb3JFYWNoKChjb25uZWN0aW9uKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlcy5oYXMoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsb3NlIGNvbm5lY3Rpb25cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5jbG9zZSgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5vcGVyYXRpb25zLmNsZWFuU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuc2V0dGluZ3MudGxzID8gJ3NlY3VyZUNvbm5lY3Rpb24nIDogJ2Nvbm5lY3Rpb24nLCB0aGlzLm9uQ29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBfaW52b2tlKHR5cGUpIHtcblxuICAgICAgICBjb25zdCBleHRzID0gdGhpcy5leHRlbnNpb25zLnNlcnZlclt0eXBlXTtcbiAgICAgICAgaWYgKCFleHRzLm5vZGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGVjdXRlIGV4dGVuc2lvbnNcblxuICAgICAgICBmb3IgKGNvbnN0IGV4dCBvZiBleHRzLm5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBiaW5kID0gZXh0LmJpbmQgfHwgZXh0LnJlYWxtLnNldHRpbmdzLmJpbmQ7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBleHQuZnVuYy5jYWxsKGJpbmQsIGV4dC5zZXJ2ZXIsIGJpbmQpO1xuICAgICAgICAgICAgYXdhaXQgVG9vbGtpdC50aW1lZChvcGVyYXRpb24sIHsgdGltZW91dDogZXh0LnRpbWVvdXQsIG5hbWU6IHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGVmYXVsdFJvdXRlcygpIHtcblxuICAgICAgICB0aGlzLnJvdXRlci5zcGVjaWFsKCdub3RGb3VuZCcsIG5ldyBSb3V0ZSh7IG1ldGhvZDogJ19zcGVjaWFsJywgcGF0aDogJy97cCp9JywgaGFuZGxlcjogaW50ZXJuYWxzLm5vdEZvdW5kIH0sIHRoaXMucm9vdCwgeyBzcGVjaWFsOiB0cnVlIH0pKTtcbiAgICAgICAgdGhpcy5yb3V0ZXIuc3BlY2lhbCgnYmFkUmVxdWVzdCcsIG5ldyBSb3V0ZSh7IG1ldGhvZDogJ19zcGVjaWFsJywgcGF0aDogJy97cCp9JywgaGFuZGxlcjogaW50ZXJuYWxzLmJhZFJlcXVlc3QgfSwgdGhpcy5yb290LCB7IHNwZWNpYWw6IHRydWUgfSkpO1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJvdXRlcy5jb3JzKSB7XG4gICAgICAgICAgICBDb3JzLmhhbmRsZXIodGhpcy5yb290KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNwYXRjaChvcHRpb25zID0ge30pIHtcblxuICAgICAgICByZXR1cm4gKHJlcSwgcmVzKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSByZXF1ZXN0XG5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBSZXF1ZXN0LmdlbmVyYXRlKHRoaXMucm9vdCwgcmVxLCByZXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBUcmFjayBzb2NrZXQgcmVxdWVzdCBwcm9jZXNzaW5nIHN0YXRlXG5cbiAgICAgICAgICAgIGlmIChyZXEuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVzLnNldChyZXEuc29ja2V0LCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSB7IGNvcmU6IHRoaXMsIHJlcSB9O1xuICAgICAgICAgICAgICAgIHJlcy5vbignZmluaXNoJywgaW50ZXJuYWxzLm9uRmluaXNoLmJpbmQocmVzLCBlbnYpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgbG9hZFxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5sb2FkLnNhbXBsZUludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWF2eS5jaGVjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2coWydsb2FkJ10sIHRoaXMuaGVhdnkubG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuX3JlcGx5KGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucXVldWUuYWRkKHJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jcmVhdGVMaXN0ZW5lcigpIHtcblxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuc2V0dGluZ3MubGlzdGVuZXIgfHwgKHRoaXMuc2V0dGluZ3MudGxzID8gSHR0cHMuY3JlYXRlU2VydmVyKHRoaXMuc2V0dGluZ3MudGxzKSA6IEh0dHAuY3JlYXRlU2VydmVyKCkpO1xuICAgICAgICBsaXN0ZW5lci5vbigncmVxdWVzdCcsIHRoaXMuX2Rpc3BhdGNoKCkpO1xuICAgICAgICBsaXN0ZW5lci5vbignY2hlY2tDb250aW51ZScsIHRoaXMuX2Rpc3BhdGNoKHsgZXhwZWN0Q29udGludWU6IHRydWUgfSkpO1xuXG4gICAgICAgIGxpc3RlbmVyLm9uKCdjbGllbnRFcnJvcicsIChlcnIsIHNvY2tldCkgPT4ge1xuXG4gICAgICAgICAgICB0aGlzLl9sb2coWydjb25uZWN0aW9uJywgJ2NsaWVudCcsICdlcnJvciddLCBlcnIpO1xuXG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuYWN0aXZlcy5nZXQoc29ja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IEJvb20uYmFkUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5vdXRwdXQuaGVhZGVycyA9IHsgY29ubmVjdGlvbjogJ2Nsb3NlJyB9O1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Ll9yZXBseShlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZW5kKGludGVybmFscy5iYWRSZXF1ZXN0UmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZUxpc3RlbmVyKCkge1xuXG4gICAgICAgIHRoaXMubGlzdGVuZXIub25jZSgnbGlzdGVuaW5nJywgKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGFkZHJlc3MsIHBvcnQsIGFuZCB1cmkgd2l0aCBhY3RpdmUgdmFsdWVzXG5cbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd0Y3AnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMubGlzdGVuZXIuYWRkcmVzcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5hZGRyZXNzID0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgICAgICAgICAgICAgIHRoaXMuaW5mby51cmkgPSB0aGlzLnNldHRpbmdzLnVyaSB8fCB0aGlzLmluZm8ucHJvdG9jb2wgKyAnOi8vJyArIHRoaXMuaW5mby5ob3N0ICsgJzonICsgdGhpcy5pbmZvLnBvcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm9wZXJhdGlvbnMuY2xlYW5TdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25DbG9zZSA9IGZ1bmN0aW9uICgpIHsgICAgICAgICAgIC8vICd0aGlzJyBpcyBib3VuZCB0byB0aGUgZW1pdHRlclxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc29ja2V0cy5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uID0gKGNvbm5lY3Rpb24pID0+IHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldHMuYWRkKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLm9uKCdjbG9zZScsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uKHRoaXMuc2V0dGluZ3MudGxzID8gJ3NlY3VyZUNvbm5lY3Rpb24nIDogJ2Nvbm5lY3Rpb24nLCB0aGlzLm9uQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jYWNoZVBvbGljeShvcHRpb25zLCBfc2VnbWVudCwgcmVhbG0pIHtcblxuICAgICAgICBvcHRpb25zID0gQ29uZmlnLmFwcGx5KCdjYWNoZVBvbGljeScsIG9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHJlYWxtICYmIHJlYWxtLnBsdWdpbjtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IG9wdGlvbnMuc2VnbWVudCB8fCBfc2VnbWVudCB8fCAocGx1Z2luID8gYCEke3BsdWdpbn1gIDogJycpO1xuICAgICAgICBIb2VrLmFzc2VydChzZWdtZW50LCAnTWlzc2luZyBjYWNoZSBzZWdtZW50IG5hbWUnKTtcblxuICAgICAgICBjb25zdCBjYWNoZU5hbWUgPSBvcHRpb25zLmNhY2hlIHx8ICdfZGVmYXVsdCc7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZXMuZ2V0KGNhY2hlTmFtZSk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KGNhY2hlLCAnVW5rbm93biBjYWNoZScsIGNhY2hlTmFtZSk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFjYWNoZS5zZWdtZW50c1tzZWdtZW50XSB8fCBjYWNoZS5zaGFyZWQgfHwgb3B0aW9ucy5zaGFyZWQsICdDYW5ub3QgcHJvdmlzaW9uIHRoZSBzYW1lIGNhY2hlIHNlZ21lbnQgbW9yZSB0aGFuIG9uY2UnKTtcbiAgICAgICAgY2FjaGUuc2VnbWVudHNbc2VnbWVudF0gPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBuZXcgQ2F0Ym94LlBvbGljeShvcHRpb25zLCBjYWNoZS5jbGllbnQsIHNlZ21lbnQpO1xuICAgIH1cblxuICAgIGxvZyh0YWdzLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZyh0YWdzLCBkYXRhLCAnYXBwJyk7XG4gICAgfVxuXG4gICAgX2xvZyh0YWdzLCBkYXRhLCBjaGFubmVsID0gJ2ludGVybmFsJykge1xuXG4gICAgICAgIGlmICghdGhpcy5ldmVudHMuaGFzTGlzdGVuZXJzKCdsb2cnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKSB7XG4gICAgICAgICAgICB0YWdzID0gW3RhZ3NdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBkYXRhIGluc3RhbmNlb2YgRXJyb3IgPyAnZXJyb3InIDogJ2RhdGEnO1xuXG4gICAgICAgIGxldCBldmVudCA9IHsgdGltZXN0YW1wLCB0YWdzLCBbZmllbGRdOiBkYXRhLCBjaGFubmVsIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBldmVudCA9ICgpID0+ICh7IHRpbWVzdGFtcCwgdGFncywgZGF0YTogZGF0YSgpLCBjaGFubmVsIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdCh7IG5hbWU6ICdsb2cnLCB0YWdzLCBjaGFubmVsIH0sIGV2ZW50KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zZXR1cCA9IGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IEhvZWsuY2xvbmUob3B0aW9ucywgeyBzaGFsbG93OiBbJ2NhY2hlJywgJ2xpc3RlbmVyJywgJ3JvdXRlcy5iaW5kJ10gfSk7XG4gICAgc2V0dGluZ3Mucm91dGVzID0gQ29uZmlnLmVuYWJsZShzZXR0aW5ncy5yb3V0ZXMpO1xuICAgIHNldHRpbmdzID0gQ29uZmlnLmFwcGx5KCdzZXJ2ZXInLCBzZXR0aW5ncyk7XG5cbiAgICBpZiAoc2V0dGluZ3MucG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldHRpbmdzLnBvcnQgPSAwO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSAodHlwZW9mIHNldHRpbmdzLnBvcnQgPT09ICdzdHJpbmcnID8gJ3NvY2tldCcgOiAndGNwJyk7XG4gICAgaWYgKHR5cGUgPT09ICdzb2NrZXQnKSB7XG4gICAgICAgIHNldHRpbmdzLnBvcnQgPSAoc2V0dGluZ3MucG9ydC5pbmRleE9mKCcvJykgIT09IC0xID8gUGF0aC5yZXNvbHZlKHNldHRpbmdzLnBvcnQpIDogc2V0dGluZ3MucG9ydC50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuYXV0b0xpc3RlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNldHRpbmdzLmF1dG9MaXN0ZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIEhvZWsuYXNzZXJ0KHNldHRpbmdzLmF1dG9MaXN0ZW4gfHwgIXNldHRpbmdzLnBvcnQsICdDYW5ub3Qgc3BlY2lmeSBwb3J0IHdoZW4gYXV0b0xpc3RlbiBpcyBmYWxzZScpO1xuICAgIEhvZWsuYXNzZXJ0KHNldHRpbmdzLmF1dG9MaXN0ZW4gfHwgIXNldHRpbmdzLmFkZHJlc3MsICdDYW5ub3Qgc3BlY2lmeSBhZGRyZXNzIHdoZW4gYXV0b0xpc3RlbiBpcyBmYWxzZScpO1xuXG4gICAgcmV0dXJuIHsgc2V0dGluZ3MsIHR5cGUgfTtcbn07XG5cblxuaW50ZXJuYWxzLm5vdEZvdW5kID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhyb3cgQm9vbS5ub3RGb3VuZCgpO1xufTtcblxuXG5pbnRlcm5hbHMuYmFkUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgpO1xufTtcblxuXG5pbnRlcm5hbHMub25GaW5pc2ggPSBmdW5jdGlvbiAoZW52KSB7XG5cbiAgICBjb25zdCB7IGNvcmUsIHJlcSB9ID0gZW52O1xuXG4gICAgY29yZS5hY3RpdmVzLmRlbGV0ZShyZXEuc29ja2V0KTtcbiAgICBpZiAoIWNvcmUuc3RhcnRlZCkge1xuICAgICAgICByZXEuc29ja2V0LmVuZCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlF1ZXVlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zO1xuXG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH1cblxuICAgIGFkZChyZXF1ZXN0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0Ll9leGVjdXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0KCkge1xuXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCAmJlxuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPCB0aGlzLnNldHRpbmdzLmNvbmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICsrdGhpcy5hY3RpdmU7XG4gICAgICAgICAgICByZXF1ZXN0Ll9leGVjdXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWxlYXNlKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC0tdGhpcy5hY3RpdmU7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5sZXQgUm91dGUgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGF5ZWQgbG9hZCBkdWUgdG8gY2lyY3VsYXIgZGVwZW5kZW5jeVxuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMucm91dGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IEhvZWsuY2xvbmUob3B0aW9ucyk7XG4gICAgc2V0dGluZ3MuX2hlYWRlcnMgPSBzZXR0aW5ncy5oZWFkZXJzLmNvbmNhdChzZXR0aW5ncy5hZGRpdGlvbmFsSGVhZGVycyk7XG4gICAgc2V0dGluZ3MuX2hlYWRlcnNTdHJpbmcgPSBzZXR0aW5ncy5faGVhZGVycy5qb2luKCcsJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXR0aW5ncy5faGVhZGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBzZXR0aW5ncy5faGVhZGVyc1tpXSA9IHNldHRpbmdzLl9oZWFkZXJzW2ldLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLl9oZWFkZXJzLmluZGV4T2YoJ29yaWdpbicpID09PSAtMSkge1xuICAgICAgICBzZXR0aW5ncy5faGVhZGVycy5wdXNoKCdvcmlnaW4nKTtcbiAgICB9XG5cbiAgICBzZXR0aW5ncy5fZXhwb3NlZEhlYWRlcnMgPSBzZXR0aW5ncy5leHBvc2VkSGVhZGVycy5jb25jYXQoc2V0dGluZ3MuYWRkaXRpb25hbEV4cG9zZWRIZWFkZXJzKS5qb2luKCcsJyk7XG5cbiAgICBpZiAoc2V0dGluZ3Mub3JpZ2luID09PSAnaWdub3JlJykge1xuICAgICAgICBzZXR0aW5ncy5fb3JpZ2luID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNldHRpbmdzLm9yaWdpbi5pbmRleE9mKCcqJykgIT09IC0xKSB7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHNldHRpbmdzLm9yaWdpbi5sZW5ndGggPT09IDEsICdDYW5ub3Qgc3BlY2lmeSBjb3JzLm9yaWdpbiAqIHRvZ2V0aGVyIHdpdGggb3RoZXIgdmFsdWVzJyk7XG4gICAgICAgIHNldHRpbmdzLl9vcmlnaW4gPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0dGluZ3MuX29yaWdpbiA9IHtcbiAgICAgICAgICAgIHF1YWxpZmllZDogW10sXG4gICAgICAgICAgICB3aWxkY2FyZHM6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBvcmlnaW4gb2Ygc2V0dGluZ3Mub3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luLmluZGV4T2YoJyonKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5fb3JpZ2luLndpbGRjYXJkcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgSG9lay5lc2NhcGVSZWdleChvcmlnaW4pLnJlcGxhY2UoL1xcXFxcXCovZywgJy4qJykucmVwbGFjZSgvXFxcXFxcPy9nLCAnLicpICsgJyQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5fb3JpZ2luLnF1YWxpZmllZC5wdXNoKG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59O1xuXG5cbmV4cG9ydHMub3B0aW9ucyA9IGZ1bmN0aW9uIChyb3V0ZSwgc2VydmVyKSB7XG5cbiAgICBpZiAocm91dGUubWV0aG9kID09PSAnb3B0aW9ucycgfHxcbiAgICAgICAgIXJvdXRlLnNldHRpbmdzLmNvcnMpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXhwb3J0cy5oYW5kbGVyKHNlcnZlcik7XG59O1xuXG5cbmV4cG9ydHMuaGFuZGxlciA9IGZ1bmN0aW9uIChzZXJ2ZXIpIHtcblxuICAgIFJvdXRlID0gUm91dGUgfHwgcmVxdWlyZSgnLi9yb3V0ZScpO1xuXG4gICAgaWYgKHNlcnZlci5fY29yZS5yb3V0ZXIuc3BlY2lhbHMub3B0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgbWV0aG9kOiAnX3NwZWNpYWwnLFxuICAgICAgICBwYXRoOiAnL3twKn0nLFxuICAgICAgICBoYW5kbGVyOiBpbnRlcm5hbHMuaGFuZGxlcixcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgY29yczogZmFsc2VcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCByb3V0ZSA9IG5ldyBSb3V0ZShkZWZpbml0aW9uLCBzZXJ2ZXIsIHsgc3BlY2lhbDogdHJ1ZSB9KTtcbiAgICBzZXJ2ZXIuX2NvcmUucm91dGVyLnNwZWNpYWwoJ29wdGlvbnMnLCByb3V0ZSk7XG59O1xuXG5cbmludGVybmFscy5oYW5kbGVyID0gZnVuY3Rpb24gKHJlcXVlc3QsIGgpIHtcblxuICAgIC8vIFZhbGlkYXRlIENPUlMgcHJlZmxpZ2h0IHJlcXVlc3RcblxuICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QuaGVhZGVyc1snYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnXTtcbiAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICB0aHJvdyBCb29tLm5vdEZvdW5kKCdDT1JTIGVycm9yOiBNaXNzaW5nIEFjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kIGhlYWRlcicpO1xuICAgIH1cblxuICAgIC8vIExvb2t1cCByb3V0ZVxuXG4gICAgY29uc3Qgcm91dGUgPSByZXF1ZXN0LnNlcnZlci5tYXRjaChtZXRob2QsIHJlcXVlc3QucGF0aCwgcmVxdWVzdC5pbmZvLmhvc3RuYW1lKTtcbiAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgIHRocm93IEJvb20ubm90Rm91bmQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHJvdXRlLnNldHRpbmdzLmNvcnM7XG4gICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAnQ09SUyBpcyBkaXNhYmxlZCBmb3IgdGhpcyByb3V0ZScgfTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBPcmlnaW4gaGVhZGVyXG5cbiAgICBjb25zdCBvcmlnaW4gPSByZXF1ZXN0LmhlYWRlcnMub3JpZ2luO1xuXG4gICAgaWYgKCFvcmlnaW4gJiZcbiAgICAgICAgc2V0dGluZ3MuX29yaWdpbiAhPT0gZmFsc2UpIHtcblxuICAgICAgICB0aHJvdyBCb29tLm5vdEZvdW5kKCdDT1JTIGVycm9yOiBNaXNzaW5nIE9yaWdpbiBoZWFkZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4cG9ydHMubWF0Y2hPcmlnaW4ob3JpZ2luLCBzZXR0aW5ncykpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogJ0NPUlMgZXJyb3I6IE9yaWdpbiBub3QgYWxsb3dlZCcgfTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBhbGxvd2VkIGhlYWRlcnNcblxuICAgIGxldCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzWydhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnXTtcbiAgICBpZiAoaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycy50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgaWYgKEhvZWsuaW50ZXJzZWN0KGhlYWRlcnMsIHNldHRpbmdzLl9oZWFkZXJzKS5sZW5ndGggIT09IGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiAnQ09SUyBlcnJvcjogU29tZSBoZWFkZXJzIGFyZSBub3QgYWxsb3dlZCcgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcGx5IHdpdGggdGhlIHJvdXRlIENPUlMgaGVhZGVyc1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBoLnJlc3BvbnNlKCk7XG4gICAgcmVzcG9uc2UuX2hlYWRlcignYWNjZXNzLWNvbnRyb2wtYWxsb3ctb3JpZ2luJywgc2V0dGluZ3MuX29yaWdpbiA/IG9yaWdpbiA6ICcqJyk7XG4gICAgcmVzcG9uc2UuX2hlYWRlcignYWNjZXNzLWNvbnRyb2wtYWxsb3ctbWV0aG9kcycsIG1ldGhvZCk7XG4gICAgcmVzcG9uc2UuX2hlYWRlcignYWNjZXNzLWNvbnRyb2wtYWxsb3ctaGVhZGVycycsIHNldHRpbmdzLl9oZWFkZXJzU3RyaW5nKTtcbiAgICByZXNwb25zZS5faGVhZGVyKCdhY2Nlc3MtY29udHJvbC1tYXgtYWdlJywgc2V0dGluZ3MubWF4QWdlKTtcblxuICAgIGlmIChzZXR0aW5ncy5jcmVkZW50aWFscykge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdhY2Nlc3MtY29udHJvbC1hbGxvdy1jcmVkZW50aWFscycsICd0cnVlJyk7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLl9leHBvc2VkSGVhZGVycykge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdhY2Nlc3MtY29udHJvbC1leHBvc2UtaGVhZGVycycsIHNldHRpbmdzLl9leHBvc2VkSGVhZGVycyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufTtcblxuXG5leHBvcnRzLmhlYWRlcnMgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmNvcnM7XG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuXG4gICAgaWYgKHNldHRpbmdzLl9vcmlnaW4gIT09IGZhbHNlKSB7XG4gICAgICAgIHJlc3BvbnNlLnZhcnkoJ29yaWdpbicpO1xuICAgIH1cblxuICAgIGlmICgocmVxdWVzdC5pbmZvLmNvcnMgJiYgIXJlcXVlc3QuaW5mby5jb3JzLmlzT3JpZ2luTWF0Y2gpIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciByb3V0ZSBsb29rdXBcbiAgICAgICAgIWV4cG9ydHMubWF0Y2hPcmlnaW4ocmVxdWVzdC5oZWFkZXJzLm9yaWdpbiwgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5jb3JzKSkgeyAgICAgICAgLy8gUmVzcG9uc2UgZnJvbSBvblJlcXVlc3RcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzcG9uc2UuX2hlYWRlcignYWNjZXNzLWNvbnRyb2wtYWxsb3ctb3JpZ2luJywgc2V0dGluZ3MuX29yaWdpbiA/IHJlcXVlc3QuaGVhZGVycy5vcmlnaW4gOiAnKicpO1xuXG4gICAgaWYgKHNldHRpbmdzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2FjY2Vzcy1jb250cm9sLWFsbG93LWNyZWRlbnRpYWxzJywgJ3RydWUnKTtcbiAgICB9XG5cbiAgICBpZiAoc2V0dGluZ3MuX2V4cG9zZWRIZWFkZXJzKSB7XG4gICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2FjY2Vzcy1jb250cm9sLWV4cG9zZS1oZWFkZXJzJywgc2V0dGluZ3MuX2V4cG9zZWRIZWFkZXJzLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMubWF0Y2hPcmlnaW4gPSBmdW5jdGlvbiAob3JpZ2luLCBzZXR0aW5ncykge1xuXG4gICAgaWYgKHNldHRpbmdzLl9vcmlnaW4gPT09IHRydWUgfHxcbiAgICAgICAgc2V0dGluZ3MuX29yaWdpbiA9PT0gZmFsc2UpIHtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIW9yaWdpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzLl9vcmlnaW4ucXVhbGlmaWVkLmluZGV4T2Yob3JpZ2luKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB3aWxkY2FyZCBvZiBzZXR0aW5ncy5fb3JpZ2luLndpbGRjYXJkcykge1xuICAgICAgICBpZiAob3JpZ2luLm1hdGNoKHdpbGRjYXJkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgVG9wbyA9IHJlcXVpcmUoJ0BoYXBpL3RvcG8nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuRXh0ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodHlwZSwgY29yZSkge1xuXG4gICAgICAgIHRoaXMuX3RvcG8gPSBuZXcgVG9wbygpO1xuICAgICAgICB0aGlzLl9jb3JlID0gY29yZTtcbiAgICAgICAgdGhpcy5fcm91dGVzID0gW107XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgYWRkKGV2ZW50KSB7XG5cbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IFtdLmNvbmNhdChldmVudC5tZXRob2QpO1xuICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGV2ZW50Lm9wdGlvbnMuYmVmb3JlLFxuICAgICAgICAgICAgICAgIGFmdGVyOiBldmVudC5vcHRpb25zLmFmdGVyLFxuICAgICAgICAgICAgICAgIGdyb3VwOiBldmVudC5yZWFsbS5wbHVnaW4sXG4gICAgICAgICAgICAgICAgc29ydDogdGhpcy5fY29yZS5leHRlbnNpb25zU2VxKytcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgZnVuYzogbWV0aG9kLCAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVxdWVzdDogZnVuY3Rpb24gKHJlcXVlc3QsIGgpLCBTZXJ2ZXI6IGZ1bmN0aW9uIChzZXJ2ZXIpXG4gICAgICAgICAgICAgICAgYmluZDogZXZlbnQub3B0aW9ucy5iaW5kLFxuICAgICAgICAgICAgICAgIHNlcnZlcjogZXZlbnQuc2VydmVyLCAgICAgICAgICAgICAgIC8vIFNlcnZlciBldmVudFxuICAgICAgICAgICAgICAgIHJlYWxtOiBldmVudC5yZWFsbSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBldmVudC5vcHRpb25zLnRpbWVvdXRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX3RvcG8uYWRkKG5vZGUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubm9kZXMgPSB0aGlzLl90b3BvLm5vZGVzO1xuXG4gICAgICAgIC8vIE5vdGlmeSByb3V0ZXNcblxuICAgICAgICBmb3IgKGNvbnN0IHJvdXRlIG9mIHRoaXMuX3JvdXRlcykge1xuICAgICAgICAgICAgcm91dGUucmVidWlsZChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtZXJnZShvdGhlcnMpIHtcblxuICAgICAgICBjb25zdCBtZXJnZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG90aGVyIG9mIG90aGVycykge1xuICAgICAgICAgICAgbWVyZ2UucHVzaChvdGhlci5fdG9wbyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90b3BvLm1lcmdlKG1lcmdlKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9ICh0aGlzLl90b3BvLm5vZGVzLmxlbmd0aCA/IHRoaXMuX3RvcG8ubm9kZXMgOiBudWxsKTtcbiAgICB9XG5cbiAgICBzdWJzY3JpYmUocm91dGUpIHtcblxuICAgICAgICB0aGlzLl9yb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbWJpbmUocm91dGUsIHR5cGUpIHtcblxuICAgICAgICBjb25zdCBleHQgPSBuZXcgaW50ZXJuYWxzLkV4dCh0eXBlLCByb3V0ZS5fY29yZSk7XG5cbiAgICAgICAgY29uc3QgZXZlbnRzID0gcm91dGUuc2V0dGluZ3MuZXh0W3R5cGVdO1xuICAgICAgICBpZiAoZXZlbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBldmVudCA9IE9iamVjdC5hc3NpZ24oe30sIGV2ZW50KTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCghZXZlbnQub3B0aW9ucy5zYW5kYm94LCAnQ2Fubm90IHNwZWNpZnkgc2FuZGJveCBvcHRpb24gZm9yIHJvdXRlIGV4dGVuc2lvbicpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnJlYWxtID0gcm91dGUucmVhbG07XG4gICAgICAgICAgICAgICAgZXh0LmFkZChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZXJ2ZXIgPSByb3V0ZS5fY29yZS5leHRlbnNpb25zLnJvdXRlW3R5cGVdO1xuICAgICAgICBjb25zdCByZWFsbSA9IHJvdXRlLnJlYWxtLl9leHRlbnNpb25zW3R5cGVdO1xuXG4gICAgICAgIGV4dC5tZXJnZShbc2VydmVyLCByZWFsbV0pO1xuXG4gICAgICAgIHNlcnZlci5zdWJzY3JpYmUocm91dGUpO1xuICAgICAgICByZWFsbS5zdWJzY3JpYmUocm91dGUpO1xuXG4gICAgICAgIHJldHVybiBleHQ7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmV4ZWN1dGUgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgLy8gUHJlcmVxdWlzaXRlc1xuXG4gICAgaWYgKHJlcXVlc3QuX3JvdXRlLl9wcmVyZXF1aXNpdGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2V0IG9mIHJlcXVlc3QuX3JvdXRlLl9wcmVyZXF1aXNpdGVzKSB7ICAgICAgLy8gU2VyaWFsIGV4ZWN1dGlvbiBvZiBlYWNoIHNldFxuICAgICAgICAgICAgY29uc3QgcHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNldCkge1xuICAgICAgICAgICAgICAgIHByZXMucHVzaChpbnRlcm5hbHMuaGFuZGxlcihyZXF1ZXN0LCBpdGVtLm1ldGhvZCwgaXRlbSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcmVzKTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcmFsbGVsIGV4ZWN1dGlvbiB3aXRoaW4gc2V0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlclxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW50ZXJuYWxzLmhhbmRsZXIocmVxdWVzdCwgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5oYW5kbGVyKTtcbiAgICBpZiAocmVzdWx0Ll90YWtlb3ZlciB8fFxuICAgICAgICB0eXBlb2YgcmVzdWx0ID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5fc2V0UmVzcG9uc2UocmVzdWx0KTtcbn07XG5cblxuaW50ZXJuYWxzLmhhbmRsZXIgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCwgbWV0aG9kLCBwcmUpIHtcblxuICAgIGNvbnN0IGJpbmQgPSByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmJpbmQ7XG4gICAgY29uc3QgcmVhbG0gPSByZXF1ZXN0LnJvdXRlLnJlYWxtO1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuX2NvcmUudG9vbGtpdC5leGVjdXRlKG1ldGhvZCwgcmVxdWVzdCwgeyBiaW5kLCByZWFsbSwgY29udGludWU6ICdudWxsJyB9KTtcblxuICAgIC8vIEhhbmRsZXJcblxuICAgIGlmICghcHJlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5pc0Jvb20pIHtcbiAgICAgICAgICAgIHJlcXVlc3QuX2xvZyhbJ2hhbmRsZXInLCAnZXJyb3InXSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgLy8gUHJlXG5cbiAgICBpZiAocmVzcG9uc2UuaXNCb29tKSB7XG4gICAgICAgIHJlc3BvbnNlLmFzc2lnbiA9IHByZS5hc3NpZ247XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5fY29yZS50b29sa2l0LmZhaWxBY3Rpb24ocmVxdWVzdCwgcHJlLmZhaWxBY3Rpb24sIHJlc3BvbnNlLCB7IHRhZ3M6IFsncHJlJywgJ2Vycm9yJ10sIHJldGFpbjogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgaWYgKHByZS5hc3NpZ24pIHtcbiAgICAgICAgcmVxdWVzdC5wcmVbcHJlLmFzc2lnbl0gPSAocmVzcG9uc2UuaXNCb29tID8gcmVzcG9uc2UgOiByZXNwb25zZS5zb3VyY2UpO1xuICAgICAgICByZXF1ZXN0LnByZVJlc3BvbnNlc1twcmUuYXNzaWduXSA9IHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5fdGFrZW92ZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5kZWZhdWx0cyA9IGZ1bmN0aW9uIChtZXRob2QsIGhhbmRsZXIsIGNvcmUpIHtcblxuICAgIGxldCBkZWZhdWx0cyA9IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBPYmplY3Qua2V5cyhoYW5kbGVyKVswXTtcbiAgICAgICAgY29uc3Qgc2VydmVySGFuZGxlciA9IGNvcmUuX2RlY29yYXRpb25zLmhhbmRsZXJbdHlwZV07XG5cbiAgICAgICAgSG9lay5hc3NlcnQoc2VydmVySGFuZGxlciwgJ1Vua25vd24gaGFuZGxlcjonLCB0eXBlKTtcblxuICAgICAgICBpZiAoc2VydmVySGFuZGxlci5kZWZhdWx0cykge1xuICAgICAgICAgICAgZGVmYXVsdHMgPSAodHlwZW9mIHNlcnZlckhhbmRsZXIuZGVmYXVsdHMgPT09ICdmdW5jdGlvbicgPyBzZXJ2ZXJIYW5kbGVyLmRlZmF1bHRzKG1ldGhvZCkgOiBzZXJ2ZXJIYW5kbGVyLmRlZmF1bHRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWZhdWx0cyB8fCB7fTtcbn07XG5cblxuZXhwb3J0cy5jb25maWd1cmUgPSBmdW5jdGlvbiAoaGFuZGxlciwgcm91dGUpIHtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IE9iamVjdC5rZXlzKGhhbmRsZXIpWzBdO1xuICAgICAgICBjb25zdCBzZXJ2ZXJIYW5kbGVyID0gcm91dGUuX2NvcmUuX2RlY29yYXRpb25zLmhhbmRsZXJbdHlwZV07XG5cbiAgICAgICAgSG9lay5hc3NlcnQoc2VydmVySGFuZGxlciwgJ1Vua25vd24gaGFuZGxlcjonLCB0eXBlKTtcblxuICAgICAgICByZXR1cm4gc2VydmVySGFuZGxlcihyb3V0ZS5wdWJsaWMsIGhhbmRsZXJbdHlwZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGVyO1xufTtcblxuXG5leHBvcnRzLnByZXJlcXVpc2l0ZXNDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG5cbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKlxuICAgICAgICBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHJlcXVlc3QsIGgpIHsgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHJlcXVlc3QsIGgpIHsgfVxuICAgICAgICAgICAgICAgICAgICBhc3NpZ246IGtleTFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAocmVxdWVzdCwgaCkgeyB9LFxuICAgICAgICAgICAgICAgICAgICBhc3NpZ246IGtleTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKHJlcXVlc3QsIGgpIHsgfSxcbiAgICAgICAgICAgICAgICBhc3NpZ246IGtleTNcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICovXG5cbiAgICBjb25zdCBwcmVyZXF1aXNpdGVzID0gW107XG5cbiAgICBmb3IgKGxldCBwcmVzIG9mIGNvbmZpZykge1xuICAgICAgICBwcmVzID0gW10uY29uY2F0KHByZXMpO1xuXG4gICAgICAgIGNvbnN0IHNldCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwcmUgb2YgcHJlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcHJlID0geyBtZXRob2Q6IHByZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcHJlLm1ldGhvZCxcbiAgICAgICAgICAgICAgICBhc3NpZ246IHByZS5hc3NpZ24sXG4gICAgICAgICAgICAgICAgZmFpbEFjdGlvbjogcHJlLmZhaWxBY3Rpb24gfHwgJ2Vycm9yJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc2V0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmVyZXF1aXNpdGVzLnB1c2goc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlcmVxdWlzaXRlcy5sZW5ndGggPyBwcmVyZXF1aXNpdGVzIDogbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5cbmNvbnN0IFJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuY2FjaGUgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZS5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNldHRpbmdzID0gcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5jYWNoZTtcbiAgICBjb25zdCBwb2xpY3kgPSBzZXR0aW5ncyAmJiByZXF1ZXN0Ll9yb3V0ZS5fY2FjaGUgJiYgKHNldHRpbmdzLl9zdGF0dXNlcy5oYXMocmVzcG9uc2Uuc3RhdHVzQ29kZSkgfHwgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNCAmJiBzZXR0aW5ncy5fc3RhdHVzZXMuaGFzKDIwMCkpKTtcblxuICAgIGlmIChwb2xpY3kgfHxcbiAgICAgICAgcmVzcG9uc2Uuc2V0dGluZ3MudHRsKSB7XG5cbiAgICAgICAgY29uc3QgdHRsID0gKHJlc3BvbnNlLnNldHRpbmdzLnR0bCAhPT0gbnVsbCA/IHJlc3BvbnNlLnNldHRpbmdzLnR0bCA6IHJlcXVlc3QuX3JvdXRlLl9jYWNoZS50dGwoKSk7XG4gICAgICAgIGNvbnN0IHByaXZhY3kgPSAocmVxdWVzdC5hdXRoLmlzQXV0aGVudGljYXRlZCB8fCByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10gPyAncHJpdmF0ZScgOiBzZXR0aW5ncy5wcml2YWN5IHx8ICdkZWZhdWx0Jyk7XG4gICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2NhY2hlLWNvbnRyb2wnLCAnbWF4LWFnZT0nICsgTWF0aC5mbG9vcih0dGwgLyAxMDAwKSArICcsIG11c3QtcmV2YWxpZGF0ZScgKyAocHJpdmFjeSAhPT0gJ2RlZmF1bHQnID8gJywgJyArIHByaXZhY3kgOiAnJykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZXR0aW5ncykge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdjYWNoZS1jb250cm9sJywgc2V0dGluZ3Mub3RoZXJ3aXNlKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY29udGVudCA9IGFzeW5jIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlLl9pc1BheWxvYWRTdXBwb3J0ZWQoKSB8fFxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9PT0gJ2hlYWQnKSB7XG5cbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuX21hcnNoYWwoKTtcblxuICAgICAgICBpZiAocmVxdWVzdC5qc29ucCAmJlxuICAgICAgICAgICAgcmVzcG9uc2UuX3BheWxvYWQuanNvbnApIHtcblxuICAgICAgICAgICAgcmVzcG9uc2UuX2hlYWRlcignY29udGVudC10eXBlJywgJ3RleHQvamF2YXNjcmlwdCcgKyAocmVzcG9uc2Uuc2V0dGluZ3MuY2hhcnNldCA/ICc7IGNoYXJzZXQ9JyArIHJlc3BvbnNlLnNldHRpbmdzLmNoYXJzZXQgOiAnJykpO1xuICAgICAgICAgICAgcmVzcG9uc2UuX2hlYWRlcigneC1jb250ZW50LXR5cGUtb3B0aW9ucycsICdub3NuaWZmJyk7XG4gICAgICAgICAgICByZXNwb25zZS5fcGF5bG9hZC5qc29ucChyZXF1ZXN0Lmpzb25wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZS5fcGF5bG9hZC5zaXplICYmXG4gICAgICAgICAgICB0eXBlb2YgcmVzcG9uc2UuX3BheWxvYWQuc2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICByZXNwb25zZS5faGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIHJlc3BvbnNlLl9wYXlsb2FkLnNpemUoKSwgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3BvbnNlLl9pc1BheWxvYWRTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgcmVzcG9uc2UuX2Nsb3NlKHJlcXVlc3QpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgdW51c2VkIGZpbGUgc3RyZWFtc1xuICAgICAgICAgICAgcmVzcG9uc2UuX3BheWxvYWQgPSBuZXcgaW50ZXJuYWxzLkVtcHR5KCk7ICAgICAgLy8gU2V0IGVtcHR5IHN0cmVhbVxuICAgICAgICB9XG5cbiAgICAgICAgZXhwb3J0cy50eXBlKHJlcXVlc3QsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgICAvLyBTZXQgZW1wdHkgc3RyZWFtXG5cbiAgICAgICAgcmVzcG9uc2UuX2Nsb3NlKHJlcXVlc3QpOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsb3NlIHVudXNlZCBmaWxlIHN0cmVhbXNcbiAgICAgICAgcmVzcG9uc2UuX3BheWxvYWQgPSBuZXcgaW50ZXJuYWxzLkVtcHR5KCk7XG4gICAgICAgIGRlbGV0ZSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5zdGF0ZSA9IGFzeW5jIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgY29uc3Qgc3RhdGVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHN0YXRlTmFtZSBpbiByZXF1ZXN0Ll9zdGF0ZXMpIHtcbiAgICAgICAgc3RhdGVzLnB1c2gocmVxdWVzdC5fc3RhdGVzW3N0YXRlTmFtZV0pO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiByZXF1ZXN0Ll9jb3JlLnN0YXRlcy5jb29raWVzKSB7XG4gICAgICAgICAgICBjb25zdCBhdXRvVmFsdWUgPSByZXF1ZXN0Ll9jb3JlLnN0YXRlcy5jb29raWVzW25hbWVdLmF1dG9WYWx1ZTtcbiAgICAgICAgICAgIGlmICghYXV0b1ZhbHVlIHx8IG5hbWUgaW4gcmVxdWVzdC5fc3RhdGVzIHx8IG5hbWUgaW4gcmVxdWVzdC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1dG9WYWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHsgbmFtZSwgdmFsdWU6IGF1dG9WYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBhdXRvVmFsdWUocmVxdWVzdCk7XG4gICAgICAgICAgICBzdGF0ZXMucHVzaCh7IG5hbWUsIHZhbHVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGVhZGVyID0gYXdhaXQgcmVxdWVzdC5fY29yZS5zdGF0ZXMuZm9ybWF0KHN0YXRlcyk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmVzcG9uc2UuaGVhZGVyc1snc2V0LWNvb2tpZSddO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGhlYWRlciA9IChBcnJheS5pc0FycmF5KGV4aXN0aW5nKSA/IGV4aXN0aW5nIDogW2V4aXN0aW5nXSkuY29uY2F0KGhlYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdzZXQtY29va2llJywgaGVhZGVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvciA9IEJvb20uYm9vbWlmeShlcnIpO1xuICAgICAgICByZXF1ZXN0Ll9sb2coWydzdGF0ZScsICdyZXNwb25zZScsICdlcnJvciddLCBlcnJvcik7XG4gICAgICAgIHJlcXVlc3QuX3N0YXRlcyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBicm9rZW4gc3RhdGVcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAocmVxdWVzdCwgcG9zdE1hcnNoYWwpIHtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICBsZXQgdHlwZSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UuX2NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyc2V0ID0gKHJlc3BvbnNlLnNldHRpbmdzLmNoYXJzZXQgJiYgcmVzcG9uc2UuX2NvbnRlbnRUeXBlICE9PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyA/ICc7IGNoYXJzZXQ9JyArIHJlc3BvbnNlLnNldHRpbmdzLmNoYXJzZXQgOiAnJyk7XG4gICAgICAgICAgICByZXNwb25zZS50eXBlKHJlc3BvbnNlLl9jb250ZW50VHlwZSArIGNoYXJzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0eXBlID0gdHlwZS50cmltKCk7XG4gICAgICAgIGlmICgoIXJlc3BvbnNlLl9jb250ZW50VHlwZSB8fCAhcG9zdE1hcnNoYWwpICYmXG4gICAgICAgICAgICByZXNwb25zZS5zZXR0aW5ncy5jaGFyc2V0ICYmXG4gICAgICAgICAgICB0eXBlLm1hdGNoKC9eKD86dGV4dFxcLyl8KD86YXBwbGljYXRpb25cXC8oPzpqc29uKXwoPzpqYXZhc2NyaXB0KSkvKSkge1xuXG4gICAgICAgICAgICBpZiAoIXR5cGUubWF0Y2goLzsgKmNoYXJzZXQ9LykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZW1pID0gKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gJzsnKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS50eXBlKHR5cGUgKyAoc2VtaSA/ICcgJyA6ICc7ICcpICsgJ2NoYXJzZXQ9JyArIChyZXNwb25zZS5zZXR0aW5ncy5jaGFyc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuZW50aXR5ID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIGlmICghcmVxdWVzdC5fZW50aXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG5cbiAgICBpZiAocmVxdWVzdC5fZW50aXR5LmV0YWcgJiZcbiAgICAgICAgIXJlc3BvbnNlLmhlYWRlcnMuZXRhZykge1xuXG4gICAgICAgIHJlc3BvbnNlLmV0YWcocmVxdWVzdC5fZW50aXR5LmV0YWcsIHsgdmFyeTogcmVxdWVzdC5fZW50aXR5LnZhcnkgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QuX2VudGl0eS5tb2RpZmllZCAmJlxuICAgICAgICAhcmVzcG9uc2UuaGVhZGVyc1snbGFzdC1tb2RpZmllZCddKSB7XG5cbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyKCdsYXN0LW1vZGlmaWVkJywgcmVxdWVzdC5fZW50aXR5Lm1vZGlmaWVkKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMudW5tb2RpZmllZCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZW50aXR5ID0ge1xuICAgICAgICBldGFnOiByZXNwb25zZS5oZWFkZXJzLmV0YWcsXG4gICAgICAgIHZhcnk6IHJlc3BvbnNlLnNldHRpbmdzLnZhcnlFdGFnLFxuICAgICAgICBtb2RpZmllZDogcmVzcG9uc2UuaGVhZGVyc1snbGFzdC1tb2RpZmllZCddXG4gICAgfTtcblxuICAgIGNvbnN0IGV0YWcgPSBSZXNwb25zZS51bm1vZGlmaWVkKHJlcXVlc3QsIGVudGl0eSk7XG4gICAgaWYgKGV0YWcpIHtcbiAgICAgICAgcmVzcG9uc2UuY29kZSgzMDQpO1xuXG4gICAgICAgIGlmIChldGFnICE9PSB0cnVlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBldGFnIHdpdGggaW5jb21pbmcgd2VhayBtYXRjaFxuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5ldGFnID0gZXRhZztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkVtcHR5ID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW0uUmVhZGFibGUge1xuXG4gICAgX3JlYWQoLyogc2l6ZSAqLykge1xuXG4gICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICB9XG5cbiAgICB3cml0ZVRvU3RyZWFtKHN0cmVhbSkge1xuXG4gICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTZXJ2ZXIgPSByZXF1aXJlKCcuL3NlcnZlcicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuXG5leHBvcnRzLnNlcnZlciA9IFNlcnZlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IENvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1ldGhvZE5hbWVSeDogL15bXyRhLXpBLVpdWyRcXHddKig/OlxcLltfJGEtekEtWl1bJFxcd10qKSokL1xufTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuTWV0aG9kcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvcmUpIHtcblxuICAgICAgICB0aGlzLmNvcmUgPSBjb3JlO1xuICAgICAgICB0aGlzLm1ldGhvZHMgPSB7fTtcbiAgICB9XG5cbiAgICBhZGQobmFtZSwgbWV0aG9kLCBvcHRpb25zLCByZWFsbSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGQobmFtZSwgbWV0aG9kLCBvcHRpb25zLCByZWFsbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB7fSBvciBbe30sIHt9XVxuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW10uY29uY2F0KG5hbWUpO1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpdGVtID0gQ29uZmlnLmFwcGx5KCdtZXRob2RPYmplY3QnLCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZChpdGVtLm5hbWUsIGl0ZW0ubWV0aG9kLCBpdGVtLm9wdGlvbnMgfHwge30sIHJlYWxtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hZGQobmFtZSwgbWV0aG9kLCBvcHRpb25zLCByZWFsbSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicsICdtZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICBIb2VrLmFzc2VydChuYW1lLm1hdGNoKGludGVybmFscy5tZXRob2ROYW1lUngpLCAnSW52YWxpZCBuYW1lOicsIG5hbWUpO1xuICAgICAgICBIb2VrLmFzc2VydCghSG9lay5yZWFjaCh0aGlzLm1ldGhvZHMsIG5hbWUsIHsgZnVuY3Rpb25zOiBmYWxzZSB9KSwgJ1NlcnZlciBtZXRob2QgZnVuY3Rpb24gbmFtZSBhbHJlYWR5IGV4aXN0czonLCBuYW1lKTtcblxuICAgICAgICBvcHRpb25zID0gQ29uZmlnLmFwcGx5KCdtZXRob2QnLCBvcHRpb25zLCBuYW1lKTtcblxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IEhvZWsuY2xvbmUob3B0aW9ucywgeyBzaGFsbG93OiBbJ2JpbmQnXSB9KTtcbiAgICAgICAgc2V0dGluZ3MuZ2VuZXJhdGVLZXkgPSBzZXR0aW5ncy5nZW5lcmF0ZUtleSB8fCBpbnRlcm5hbHMuZ2VuZXJhdGVLZXk7XG5cbiAgICAgICAgY29uc3QgYmluZCA9IHNldHRpbmdzLmJpbmQgfHwgcmVhbG0uc2V0dGluZ3MuYmluZCB8fCBudWxsO1xuICAgICAgICBjb25zdCBib3VuZCA9ICFiaW5kID8gbWV0aG9kIDogKC4uLmFyZ3MpID0+IG1ldGhvZC5hcHBseShiaW5kLCBhcmdzKTtcblxuICAgICAgICAvLyBOb3QgY2FjaGVkXG5cbiAgICAgICAgaWYgKCFzZXR0aW5ncy5jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihuYW1lLCBib3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZWRcblxuICAgICAgICBIb2VrLmFzc2VydCghc2V0dGluZ3MuY2FjaGUuZ2VuZXJhdGVGdW5jLCAnQ2Fubm90IHNldCBnZW5lcmF0ZUZ1bmMgd2l0aCBtZXRob2QgY2FjaGluZzonLCBuYW1lKTtcbiAgICAgICAgSG9lay5hc3NlcnQoc2V0dGluZ3MuY2FjaGUuZ2VuZXJhdGVUaW1lb3V0ICE9PSB1bmRlZmluZWQsICdNZXRob2QgY2FjaGluZyByZXF1aXJlcyBhIHRpbWVvdXQgdmFsdWUgaW4gZ2VuZXJhdGVUaW1lb3V0OicsIG5hbWUpO1xuXG4gICAgICAgIHNldHRpbmdzLmNhY2hlLmdlbmVyYXRlRnVuYyA9IChpZCwgZmxhZ3MpID0+IGJvdW5kKC4uLmlkLmFyZ3MsIGZsYWdzKTtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLmNvcmUuX2NhY2hlUG9saWN5KHNldHRpbmdzLmNhY2hlLCAnIycgKyBuYW1lKTtcblxuICAgICAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gc2V0dGluZ3MuZ2VuZXJhdGVLZXkuYXBwbHkoYmluZCwgYXJncyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignSW52YWxpZCBtZXRob2Qga2V5IHdoZW4gaW52b2tpbmc6ICcgKyBuYW1lLCB7IG5hbWUsIGFyZ3MgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KHsgaWQ6IGtleSwgYXJncyB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jLmNhY2hlID0ge1xuICAgICAgICAgICAgZHJvcDogZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHNldHRpbmdzLmdlbmVyYXRlS2V5LmFwcGx5KGJpbmQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignSW52YWxpZCBtZXRob2Qga2V5IHdoZW4gaW52b2tpbmc6ICcgKyBuYW1lLCB7IG5hbWUsIGFyZ3MgfSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5kcm9wKGtleSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3RhdHM6IGNhY2hlLnN0YXRzXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fYXNzaWduKG5hbWUsIGZ1bmMsIGZ1bmMpO1xuICAgIH1cblxuICAgIF9hc3NpZ24obmFtZSwgbWV0aG9kKSB7XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IHJlZiA9IHRoaXMubWV0aG9kcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIXJlZltwYXRoW2ldXSkge1xuICAgICAgICAgICAgICAgIHJlZltwYXRoW2ldXSA9IChpICsgMSA9PT0gcGF0aC5sZW5ndGggPyBtZXRob2QgOiB7fSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZiA9IHJlZltwYXRoW2ldXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnN1cHBvcnRlZEFyZ3MgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuXG5cbmludGVybmFscy5nZW5lcmF0ZUtleSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICBsZXQga2V5ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIGlmICghaW50ZXJuYWxzLnN1cHBvcnRlZEFyZ3MuaW5jbHVkZXModHlwZW9mIGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0ga2V5ICsgKGkgPyAnOicgOiAnJykgKyBlbmNvZGVVUklDb21wb25lbnQoYXJnLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IFBvZGl1bSA9IHJlcXVpcmUoJ0BoYXBpL3BvZGl1bScpO1xuXG5jb25zdCBDb3JzID0gcmVxdWlyZSgnLi9jb3JzJyk7XG5jb25zdCBSZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKTtcbmNvbnN0IFRyYW5zbWl0ID0gcmVxdWlyZSgnLi90cmFuc21pdCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBldmVudHM6IFBvZGl1bS52YWxpZGF0ZShbJ2ZpbmlzaCcsIHsgbmFtZTogJ3BlZWsnLCBzcHJlYWQ6IHRydWUgfSwgJ2Rpc2Nvbm5lY3QnXSksXG4gICAgcmVzZXJ2ZWQ6IFsnc2VydmVyJywgJ3VybCcsICdxdWVyeScsICdwYXRoJywgJ21ldGhvZCcsICdtaW1lJywgJ3NldFVybCcsICdzZXRNZXRob2QnLCAnaGVhZGVycycsICdpZCcsICdhcHAnLCAncGx1Z2lucycsICdyb3V0ZScsICdhdXRoJywgJ3ByZScsICdwcmVSZXNwb25zZXMnLCAnaW5mbycsICdvcmlnJywgJ3BhcmFtcycsICdwYXJhbXNBcnJheScsICdwYXlsb2FkJywgJ3N0YXRlJywgJ2pzb25wJywgJ3Jlc3BvbnNlJywgJ3JhdycsICdkb21haW4nLCAnbG9nJywgJ2xvZ3MnLCAnZ2VuZXJhdGVSZXNwb25zZSddXG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5SZXF1ZXN0ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc2VydmVyLCByZXEsIHJlcywgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX2FsbG93SW50ZXJuYWxzID0gISFvcHRpb25zLmFsbG93SW50ZXJuYWxzO1xuICAgICAgICB0aGlzLl9jb3JlID0gc2VydmVyLl9jb3JlO1xuICAgICAgICB0aGlzLl9lbnRpdHkgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW50aXR5IGluZm9ybWF0aW9uIHNldCB2aWEgaC5lbnRpdHkoKVxuICAgICAgICB0aGlzLl9ldmVudENvbnRleHQgPSB7IHJlcXVlc3Q6IHRoaXMgfTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbmVkIGFuIGVtaXR0ZXIgd2hlbiByZXF1ZXN0LmV2ZW50cyBpcyBhY2Nlc3NlZFxuICAgICAgICB0aGlzLl9leHBlY3RDb250aW51ZSA9ICEhb3B0aW9ucy5leHBlY3RDb250aW51ZTtcbiAgICAgICAgdGhpcy5faXNQYXlsb2FkUGVuZGluZyA9ICEhKHJlcS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddIHx8IHJlcS5oZWFkZXJzWyd0cmFuc2Zlci1lbmNvZGluZyddKTsgICAgIC8vIENoYW5nZXMgdG8gZmFsc2Ugd2hlbiBpbmNvbWluZyBwYXlsb2FkIGZ1bGx5IHByb2Nlc3NlZFxuICAgICAgICB0aGlzLl9pc1JlcGxpZWQgPSBmYWxzZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSB3aGVuIHJlc3BvbnNlIHByb2Nlc3Npbmcgc3RhcnRlZFxuICAgICAgICB0aGlzLl9yb3V0ZSA9IHRoaXMuX2NvcmUucm91dGVyLnNwZWNpYWxzLm5vdEZvdW5kLnJvdXRlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBwcmlvciB0byByb3V0aW5nIChvbmx5IHNldHRpbmdzIGFyZSB1c2VkLCBub3QgdGhlIGhhbmRsZXIpXG4gICAgICAgIHRoaXMuX3NlcnZlclRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLl91cmxFcnJvciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5hcHAgPSBvcHRpb25zLmFwcCA/IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYXBwKSA6IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGZvciBhcHBsaWNhdGlvbi1zcGVjaWZpYyBzdGF0ZSB3aXRob3V0IGNvbmZsaWN0cyB3aXRoIGhhcGksIHNob3VsZCBub3QgYmUgdXNlZCBieSBwbHVnaW5zIChzaGFsbG93IGNsb25lZClcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gcmVxLmhlYWRlcnM7XG4gICAgICAgIHRoaXMuaW5mbyA9IGludGVybmFscy5pbmZvKHRoaXMuX2NvcmUsIHJlcSk7XG4gICAgICAgIHRoaXMuanNvbnAgPSBudWxsO1xuICAgICAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSByZXEubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMubWltZSA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZyA9IHt9O1xuICAgICAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyYW1zQXJyYXkgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBvZiBwYXRoIHBhcmFtZXRlcnMgaW4gcGF0aCBvcmRlclxuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBudWxsO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnMgPyBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnBsdWdpbnMpIDoge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgZm9yIHBsdWdpbnMgdG8gc3RvcmUgc3RhdGUgd2l0aG91dCBjb25mbGljdHMgd2l0aCBoYXBpLCBzaG91bGQgYmUgbmFtZXNwYWNlZCB1c2luZyBwbHVnaW4gbmFtZSAoc2hhbGxvdyBjbG9uZWQpXG4gICAgICAgIHRoaXMucHJlID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmUgcmF3IHZhbHVlc1xuICAgICAgICB0aGlzLnByZVJlc3BvbnNlcyA9IHt9OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlIHJlc3BvbnNlIHZhbHVlc1xuICAgICAgICB0aGlzLnJhdyA9IHsgcmVxLCByZXMgfTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IG51bGw7XG4gICAgICAgIHRoaXMucm91dGUgPSB0aGlzLl9yb3V0ZS5wdWJsaWM7XG4gICAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMudXJsID0gbnVsbDtcblxuICAgICAgICB0aGlzLmF1dGggPSB7XG4gICAgICAgICAgICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNBdXRob3JpemVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLmF1dGggPyBvcHRpb25zLmF1dGguY3JlZGVudGlhbHMgOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwga2V5czogJ2FwcCcsICd1c2VyJywgJ3Njb3BlJ1xuICAgICAgICAgICAgYXJ0aWZhY3RzOiBvcHRpb25zLmF1dGggJiYgb3B0aW9ucy5hdXRoLmFydGlmYWN0cyB8fCBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2NoZW1lLXNwZWNpZmljIGFydGlmYWN0c1xuICAgICAgICAgICAgc3RyYXRlZ3k6IG9wdGlvbnMuYXV0aCA/IG9wdGlvbnMuYXV0aC5zdHJhdGVneSA6IG51bGwsXG4gICAgICAgICAgICBtb2RlOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdXRoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dGguaXNJbmplY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSByZXF1ZXN0IHVybFxuXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVVcmwoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2VuZXJhdGUoc2VydmVyLCByZXEsIHJlcywgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgc2VydmVyLl9jb3JlLlJlcXVlc3Qoc2VydmVyLCByZXEsIHJlcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gRGVjb3JhdGVcblxuICAgICAgICBpZiAoc2VydmVyLl9jb3JlLl9kZWNvcmF0aW9ucy5yZXF1ZXN0QXBwbHkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gc2VydmVyLl9jb3JlLl9kZWNvcmF0aW9ucy5yZXF1ZXN0QXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50ID0gc2VydmVyLl9jb3JlLl9kZWNvcmF0aW9ucy5yZXF1ZXN0QXBwbHlbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RbcHJvcGVydHldID0gYXNzaWdubWVudChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuX2xpc3RlbigpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbiAgICBnZXQgZXZlbnRzKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgUG9kaXVtKGludGVybmFscy5ldmVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cztcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZVVybCgpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VXJsKHRoaXMucmF3LnJlcS51cmwsIHRoaXMuX2NvcmUuc2V0dGluZ3Mucm91dGVyLnN0cmlwVHJhaWxpbmdTbGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gdGhpcy5yYXcucmVxLnVybDtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fTtcblxuICAgICAgICAgICAgdGhpcy5fdXJsRXJyb3IgPSBCb29tLmJvb21pZnkoZXJyLCB7IHN0YXR1c0NvZGU6IDQwMCwgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VXJsKHVybCwgc3RyaXBUcmFpbGluZ1NsYXNoKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5wYXJhbXMgPT09IG51bGwsICdDYW5ub3QgY2hhbmdlIHJlcXVlc3QgVVJMIGFmdGVyIHJvdXRpbmcnKTtcblxuICAgICAgICBpZiAodXJsIGluc3RhbmNlb2YgVXJsLlVSTCkge1xuICAgICAgICAgICAgdXJsID0gdXJsLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgdXJsID09PSAnc3RyaW5nJywgJ1VybCBtdXN0IGJlIGEgc3RyaW5nIG9yIFVSTCBvYmplY3QnKTtcblxuICAgICAgICB0aGlzLl9zZXRVcmwodXJsLCBzdHJpcFRyYWlsaW5nU2xhc2gpO1xuICAgICAgICB0aGlzLl91cmxFcnJvciA9IG51bGw7XG4gICAgfVxuXG4gICAgX3NldFVybCh1cmwsIHN0cmlwVHJhaWxpbmdTbGFzaCkge1xuXG4gICAgICAgIGNvbnN0IGJhc2UgPSB1cmxbMF0gPT09ICcvJyA/IGAke3RoaXMuX2NvcmUuaW5mby5wcm90b2NvbH06Ly8ke3RoaXMuaW5mby5ob3N0IHx8IGAke3RoaXMuX2NvcmUuaW5mby5ob3N0fToke3RoaXMuX2NvcmUuaW5mby5wb3J0fWB9YCA6ICcnO1xuXG4gICAgICAgIHVybCA9IG5ldyBVcmwuVVJMKGJhc2UgKyB1cmwpO1xuXG4gICAgICAgIC8vIEFwcGx5IHBhdGggbW9kaWZpY2F0aW9uc1xuXG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5fY29yZS5yb3V0ZXIubm9ybWFsaXplKHVybC5wYXRobmFtZSk7ICAgICAgICAvLyBwYXRobmFtZSBleGNsdWRlcyBxdWVyeVxuXG4gICAgICAgIGlmIChzdHJpcFRyYWlsaW5nU2xhc2ggJiZcbiAgICAgICAgICAgIHBhdGgubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycpIHtcblxuICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsLnBhdGhuYW1lID0gcGF0aDtcblxuICAgICAgICAvLyBQYXJzZSBxdWVyeSAobXVzdCBiZSBkb25lIGJlZm9yZSB0aGlzLnVybCBpcyBzZXQgaW4gY2FzZSBxdWVyeSBwYXJzaW5nIHRocm93cylcblxuICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5fcGFyc2VRdWVyeSh1cmwuc2VhcmNoUGFyYW1zKTtcblxuICAgICAgICAvLyBTdG9yZSByZXF1ZXN0IHByb3BlcnRpZXNcblxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcblxuICAgICAgICB0aGlzLmluZm8uaG9zdG5hbWUgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHRoaXMuaW5mby5ob3N0ID0gdXJsLmhvc3Q7XG4gICAgfVxuXG4gICAgX3BhcnNlUXVlcnkoc2VhcmNoUGFyYW1zKSB7XG5cbiAgICAgICAgLy8gRmxhdHRlbiBtYXBcblxuICAgICAgICBsZXQgcXVlcnkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHF1ZXJ5W2tleV07XG4gICAgICAgICAgICBpZiAoZW50cnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KGVudHJ5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1c3RvbSBwYXJzZXJcblxuICAgICAgICBjb25zdCBwYXJzZXIgPSB0aGlzLl9jb3JlLnNldHRpbmdzLnF1ZXJ5LnBhcnNlcjtcbiAgICAgICAgaWYgKHBhcnNlcikge1xuICAgICAgICAgICAgcXVlcnkgPSBwYXJzZXIocXVlcnkpO1xuICAgICAgICAgICAgaWYgKCFxdWVyeSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBxdWVyeSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ1BhcnNlZCBxdWVyeSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH1cblxuICAgIHNldE1ldGhvZChtZXRob2QpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLnBhcmFtcyA9PT0gbnVsbCwgJ0Nhbm5vdCBjaGFuZ2UgcmVxdWVzdCBtZXRob2QgYWZ0ZXIgcm91dGluZycpO1xuICAgICAgICBIb2VrLmFzc2VydChtZXRob2QgJiYgdHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycsICdNaXNzaW5nIG1ldGhvZCcpO1xuXG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgYWN0aXZlKCkge1xuXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2V2ZW50Q29udGV4dC5yZXF1ZXN0O1xuICAgIH1cblxuICAgIGFzeW5jIF9leGVjdXRlKCkge1xuXG4gICAgICAgIHRoaXMuaW5mby5hY2NlcHRFbmNvZGluZyA9IHRoaXMuX2NvcmUuY29tcHJlc3Npb24uYWNjZXB0KHRoaXMpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vblJlcXVlc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXBseShlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9va3VwKCk7XG4gICAgICAgIHRoaXMuX3NldFRpbWVvdXRzKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuX2xpZmVjeWNsZSgpO1xuICAgICAgICB0aGlzLl9yZXBseSgpO1xuICAgIH1cblxuICAgIGFzeW5jIF9vblJlcXVlc3QoKSB7XG5cbiAgICAgICAgLy8gb25SZXF1ZXN0IChjYW4gY2hhbmdlIHJlcXVlc3QgbWV0aG9kIGFuZCB1cmwpXG5cbiAgICAgICAgaWYgKHRoaXMuX2NvcmUuZXh0ZW5zaW9ucy5yb3V0ZS5vblJlcXVlc3Qubm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5faW52b2tlKHRoaXMuX2NvcmUuZXh0ZW5zaW9ucy5yb3V0ZS5vblJlcXVlc3QpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuc2tpcChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignb25SZXF1ZXN0IGV4dGVuc2lvbiBtZXRob2RzIG11c3QgcmV0dXJuIGFuIGVycm9yLCBhIHRha2VvdmVyIHJlc3BvbnNlLCBvciBhIGNvbnRpbnVlIHNpZ25hbCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcGF0aFxuXG4gICAgICAgIGlmICh0aGlzLl91cmxFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fdXJsRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbGlzdGVuKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1BheWxvYWRQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJhdy5yZXEub24oJ2VuZCcsIGludGVybmFscy5ldmVudC5iaW5kKHRoaXMucmF3LnJlcSwgdGhpcy5fZXZlbnRDb250ZXh0LCAnZW5kJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yYXcucmVxLm9uKCdjbG9zZScsIGludGVybmFscy5ldmVudC5iaW5kKHRoaXMucmF3LnJlcSwgdGhpcy5fZXZlbnRDb250ZXh0LCAnY2xvc2UnKSk7XG4gICAgICAgIHRoaXMucmF3LnJlcS5vbignZXJyb3InLCBpbnRlcm5hbHMuZXZlbnQuYmluZCh0aGlzLnJhdy5yZXEsIHRoaXMuX2V2ZW50Q29udGV4dCwgJ2Vycm9yJykpO1xuICAgICAgICB0aGlzLnJhdy5yZXEub24oJ2Fib3J0ZWQnLCBpbnRlcm5hbHMuZXZlbnQuYmluZCh0aGlzLnJhdy5yZXEsIHRoaXMuX2V2ZW50Q29udGV4dCwgJ2Fib3J0JykpO1xuICAgIH1cblxuICAgIF9sb29rdXAoKSB7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLl9jb3JlLnJvdXRlci5yb3V0ZSh0aGlzLm1ldGhvZCwgdGhpcy5wYXRoLCB0aGlzLmluZm8uaG9zdG5hbWUpO1xuICAgICAgICBpZiAoIW1hdGNoLnJvdXRlLnNldHRpbmdzLmlzSW50ZXJuYWwgfHxcbiAgICAgICAgICAgIHRoaXMuX2FsbG93SW50ZXJuYWxzKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3JvdXRlID0gbWF0Y2gucm91dGU7XG4gICAgICAgICAgICB0aGlzLnJvdXRlID0gdGhpcy5fcm91dGUucHVibGljO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJhbXMgPSBtYXRjaC5wYXJhbXMgfHwge307XG4gICAgICAgIHRoaXMucGFyYW1zQXJyYXkgPSBtYXRjaC5wYXJhbXNBcnJheSB8fCBbXTtcblxuICAgICAgICBpZiAodGhpcy5yb3V0ZS5zZXR0aW5ncy5jb3JzKSB7XG4gICAgICAgICAgICB0aGlzLmluZm8uY29ycyA9IHtcbiAgICAgICAgICAgICAgICBpc09yaWdpbk1hdGNoOiBDb3JzLm1hdGNoT3JpZ2luKHRoaXMuaGVhZGVycy5vcmlnaW4sIHRoaXMucm91dGUuc2V0dGluZ3MuY29ycylcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0VGltZW91dHMoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucmF3LnJlcS5zb2NrZXQgJiZcbiAgICAgICAgICAgIHRoaXMucm91dGUuc2V0dGluZ3MudGltZW91dC5zb2NrZXQgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICB0aGlzLnJhdy5yZXEuc29ja2V0LnNldFRpbWVvdXQodGhpcy5yb3V0ZS5zZXR0aW5ncy50aW1lb3V0LnNvY2tldCB8fCAwKTsgICAgLy8gVmFsdWUgY2FuIGJlIGZhbHNlIG9yIHBvc2l0aXZlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VydmVyVGltZW91dCA9IHRoaXMucm91dGUuc2V0dGluZ3MudGltZW91dC5zZXJ2ZXI7XG4gICAgICAgIGlmICghc2VydmVyVGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSB0aGlzLmluZm8ucmVjZWl2ZWQ7XG4gICAgICAgIHNlcnZlclRpbWVvdXQgPSBNYXRoLmZsb29yKHNlcnZlclRpbWVvdXQgLSBlbGFwc2VkKTsgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRpbWVvdXQgZnJvbSB3aGVuIHRoZSByZXF1ZXN0IHdhcyBjb25zdHJ1Y3RlZFxuXG4gICAgICAgIGlmIChzZXJ2ZXJUaW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIGludGVybmFscy50aW1lb3V0UmVwbHkodGhpcywgc2VydmVyVGltZW91dCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXJ2ZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGludGVybmFscy50aW1lb3V0UmVwbHksIHNlcnZlclRpbWVvdXQsIHRoaXMsIHNlcnZlclRpbWVvdXQpO1xuICAgIH1cblxuICAgIGFzeW5jIF9saWZlY3ljbGUoKSB7XG5cbiAgICAgICAgZm9yIChjb25zdCBmdW5jIG9mIHRoaXMuX3JvdXRlLl9jeWNsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmVwbGllZCB8fFxuICAgICAgICAgICAgICAgICF0aGlzLl9ldmVudENvbnRleHQucmVxdWVzdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGF3YWl0ICh0eXBlb2YgZnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmModGhpcykgOiB0aGlzLl9pbnZva2UoZnVuYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gUmVzcG9uc2Uud3JhcChlcnIsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlIHx8XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPT09IHRoaXMuX2NvcmUudG9vbGtpdC5jb250aW51ZSkgeyAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuc2tpcChyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0xpZmVjeWNsZSBtZXRob2RzIGNhbGxlZCBiZWZvcmUgdGhlIGhhbmRsZXIgY2FuIG9ubHkgcmV0dXJuIGFuIGVycm9yLCBhIHRha2VvdmVyIHJlc3BvbnNlLCBvciBhIGNvbnRpbnVlIHNpZ25hbCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXRSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBfaW52b2tlKGV2ZW50KSB7XG5cbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgZXZlbnQubm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxtID0gZXh0LnJlYWxtO1xuICAgICAgICAgICAgY29uc3QgYmluZCA9IGV4dC5iaW5kIHx8IHJlYWxtLnNldHRpbmdzLmJpbmQ7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2NvcmUudG9vbGtpdC5leGVjdXRlKGV4dC5mdW5jLCB0aGlzLCB7IGJpbmQsIHJlYWxtLCB0aW1lb3V0OiBleHQudGltZW91dCwgbmFtZTogZXZlbnQudHlwZSB9KTtcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB0aGlzLl9jb3JlLnRvb2xraXQuY29udGludWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGludGVybmFscy5za2lwKHJlc3BvbnNlKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2V0UmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgX3JlcGx5KGV4aXQpIHtcblxuICAgICAgICBpZiAodGhpcy5faXNSZXBsaWVkKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBhbnkgZnV0dXJlIHJlc3BvbnNlcyB0byB0aGlzIHJlcXVlc3RcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lzUmVwbGllZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NlcnZlclRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3NlcnZlclRpbWVvdXRJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50Q29udGV4dC5yZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4aXQpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbiBiZSBhIHZhbGlkIHJlc3BvbnNlIG9yIGVycm9yIChpZiByZXR1cm5lZCBmcm9tIGFuIGV4dCwgYWxyZWFkeSBoYW5kbGVkIGJlY2F1c2UgdGhpcy5yZXNwb25zZSBpcyBhbHNvIHNldClcbiAgICAgICAgICAgIHRoaXMuX3NldFJlc3BvbnNlKFJlc3BvbnNlLndyYXAoZXhpdCwgdGhpcykpOyAgICAgICAgICAgICAgIC8vIFdyYXAgdG8gZW5zdXJlIGFueSBvYmplY3QgdGhyb3duIGlzIGFsd2F5cyBhIHZhbGlkIEJvb20gb3IgUmVzcG9uc2Ugb2JqZWN0XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucmVzcG9uc2UgPT09ICdzeW1ib2wnKSB7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2Ugb3IgYWJhbmRvblxuICAgICAgICAgICAgdGhpcy5fYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RDeWNsZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZXZlbnRDb250ZXh0LnJlcXVlc3QgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLnJlc3BvbnNlID09PSAnc3ltYm9sJykgeyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsb3NlIG9yIGFiYW5kb25cblxuICAgICAgICAgICAgdGhpcy5fYWJvcnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IFRyYW5zbWl0LnNlbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplKCk7XG4gICAgfVxuXG4gICAgYXN5bmMgX3Bvc3RDeWNsZSgpIHtcblxuICAgICAgICBmb3IgKGNvbnN0IGZ1bmMgb2YgdGhpcy5fcm91dGUuX3Bvc3RDeWNsZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ldmVudENvbnRleHQucmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBhd2FpdCAodHlwZW9mIGZ1bmMgPT09ICdmdW5jdGlvbicgPyBmdW5jKHRoaXMpIDogdGhpcy5faW52b2tlKGZ1bmMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IFJlc3BvbnNlLndyYXAoZXJyLCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgIT09IHRoaXMuX2NvcmUudG9vbGtpdC5jb250aW51ZSkgeyAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlXG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWJvcnQoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UgPT09IHRoaXMuX2NvcmUudG9vbGtpdC5jbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5yYXcucmVzLmVuZCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgdGhlIHJlc3BvbnNlIGluIGNhc2UgaXQgd2Fzbid0IGFscmVhZHkgY2xvc2VkXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9maW5hbGl6ZSgpO1xuICAgIH1cblxuICAgIF9maW5hbGl6ZSgpIHtcblxuICAgICAgICBpZiAodGhpcy5yZXNwb25zZSAmJlxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA1MDAgJiZcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UuX2Vycm9yKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLnJlc3BvbnNlLl9lcnJvci5pc0RldmVsb3BlckVycm9yID8gWydpbnRlcm5hbCcsICdpbXBsZW1lbnRhdGlvbicsICdlcnJvciddIDogWydpbnRlcm5hbCcsICdlcnJvciddO1xuICAgICAgICAgICAgdGhpcy5fbG9nKHRhZ3MsIHRoaXMucmVzcG9uc2UuX2Vycm9yLCAnZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsZWFudXBcblxuICAgICAgICB0aGlzLl9ldmVudENvbnRleHQucmVxdWVzdCA9IG51bGw7ICAgICAgICAgICAgICAvLyBEaXNhYmxlIHJlcSBldmVudHNcblxuICAgICAgICBpZiAodGhpcy5yZXNwb25zZSAmJlxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5fY2xvc2UpIHtcblxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5fY2xvc2UodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluZm8uY29tcGxldGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5fY29yZS5ldmVudHMuZW1pdCgncmVzcG9uc2UnLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fY29yZS5xdWV1ZS5yZWxlYXNlKCk7XG4gICAgfVxuXG4gICAgX3NldFJlc3BvbnNlKHJlc3BvbnNlKSB7XG5cbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2UgJiZcbiAgICAgICAgICAgICF0aGlzLnJlc3BvbnNlLmlzQm9vbSAmJlxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSAhPT0gcmVzcG9uc2UgJiZcbiAgICAgICAgICAgIChyZXNwb25zZS5pc0Jvb20gfHwgdGhpcy5yZXNwb25zZS5zb3VyY2UgIT09IHJlc3BvbnNlLnNvdXJjZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5yZXNwb25zZS5fY2xvc2UodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbmZvLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLl9jbG9zZSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLl9jbG9zZSh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cblxuICAgIF9zZXRTdGF0ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0geyBuYW1lLCB2YWx1ZSB9O1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuYXV0b1ZhbHVlLCAnQ2Fubm90IHNldCBhdXRvVmFsdWUgZGlyZWN0bHkgaW4gYSByZXNwb25zZScpO1xuICAgICAgICAgICAgc3RhdGUub3B0aW9ucyA9IEhvZWsuY2xvbmUob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0ZXNbbmFtZV0gPSBzdGF0ZTtcbiAgICB9XG5cbiAgICBfY2xlYXJTdGF0ZShuYW1lLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHsgbmFtZSB9O1xuXG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBIb2VrLmNsb25lKG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zLnR0bCA9IDA7XG5cbiAgICAgICAgdGhpcy5fc3RhdGVzW25hbWVdID0gc3RhdGU7XG4gICAgfVxuXG4gICAgX3RhcCgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmhhc0xpc3RlbmVycygncGVlaycpIHx8XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuaGFzTGlzdGVuZXJzKCdmaW5pc2gnKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlLlBlZWsodGhpcy5fZXZlbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxvZyh0YWdzLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZyh0YWdzLCBkYXRhLCAnYXBwJyk7XG4gICAgfVxuXG4gICAgX2xvZyh0YWdzLCBkYXRhLCBjaGFubmVsID0gJ2ludGVybmFsJykge1xuXG4gICAgICAgIGlmICghdGhpcy5fY29yZS5ldmVudHMuaGFzTGlzdGVuZXJzKCdyZXF1ZXN0JykgJiZcbiAgICAgICAgICAgICF0aGlzLnJvdXRlLnNldHRpbmdzLmxvZy5jb2xsZWN0KSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgICAgICAgICAgdGFncyA9IFt0YWdzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZGF0YSBpbnN0YW5jZW9mIEVycm9yID8gJ2Vycm9yJyA6ICdkYXRhJztcblxuICAgICAgICBsZXQgZXZlbnQgPSBbdGhpcywgeyByZXF1ZXN0OiB0aGlzLmluZm8uaWQsIHRpbWVzdGFtcCwgdGFncywgW2ZpZWxkXTogZGF0YSwgY2hhbm5lbCB9XTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBldmVudCA9ICgpID0+IFt0aGlzLCB7IHJlcXVlc3Q6IHRoaXMuaW5mby5pZCwgdGltZXN0YW1wLCB0YWdzLCBkYXRhOiBkYXRhKCksIGNoYW5uZWwgfV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yb3V0ZS5zZXR0aW5ncy5sb2cuY29sbGVjdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvZ3MucHVzaChldmVudFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb3JlLmV2ZW50cy5lbWl0KHsgbmFtZTogJ3JlcXVlc3QnLCBjaGFubmVsLCB0YWdzIH0sIGV2ZW50KTtcbiAgICB9XG5cbiAgICBnZW5lcmF0ZVJlc3BvbnNlKHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2Uoc291cmNlLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5SZXF1ZXN0LnJlc2VydmVkID0gaW50ZXJuYWxzLnJlc2VydmVkO1xuXG5cbmludGVybmFscy5pbmZvID0gZnVuY3Rpb24gKGNvcmUsIHJlcSkge1xuXG4gICAgY29uc3QgaG9zdCA9IHJlcS5oZWFkZXJzLmhvc3QgPyByZXEuaGVhZGVycy5ob3N0LnRyaW0oKSA6ICcnO1xuICAgIGNvbnN0IHJlY2VpdmVkID0gRGF0ZS5ub3coKTtcblxuICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgIHJlY2VpdmVkLFxuICAgICAgICByZW1vdGVBZGRyZXNzOiByZXEuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICByZW1vdGVQb3J0OiByZXEuY29ubmVjdGlvbi5yZW1vdGVQb3J0IHx8ICcnLFxuICAgICAgICByZWZlcnJlcjogcmVxLmhlYWRlcnMucmVmZXJyZXIgfHwgcmVxLmhlYWRlcnMucmVmZXJlciB8fCAnJyxcbiAgICAgICAgaG9zdCxcbiAgICAgICAgaG9zdG5hbWU6IGhvc3Quc3BsaXQoJzonKVswXSxcbiAgICAgICAgaWQ6IGAke3JlY2VpdmVkfToke2NvcmUuaW5mby5pZH06JHtjb3JlLnJlcXVlc3RDb3VudGVyLnZhbHVlKyt9YCxcblxuICAgICAgICAvLyBBc3NpZ25lZCBsYXRlclxuXG4gICAgICAgIGFjY2VwdEVuY29kaW5nOiBudWxsLFxuICAgICAgICBjb3JzOiBudWxsLFxuICAgICAgICByZXNwb25kZWQ6IDAsXG4gICAgICAgIGNvbXBsZXRlZDogMFxuICAgIH07XG5cbiAgICBpZiAoY29yZS5yZXF1ZXN0Q291bnRlci52YWx1ZSA+IGNvcmUucmVxdWVzdENvdW50ZXIubWF4KSB7XG4gICAgICAgIGNvcmUucmVxdWVzdENvdW50ZXIudmFsdWUgPSBjb3JlLnJlcXVlc3RDb3VudGVyLm1pbjtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbn07XG5cblxuaW50ZXJuYWxzLmV2ZW50ID0gZnVuY3Rpb24gKHsgcmVxdWVzdCB9LCBldmVudCwgZXJyKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcXVlc3QuX2lzUGF5bG9hZFBlbmRpbmcgPSBmYWxzZTtcblxuICAgIGlmIChldmVudCA9PT0gJ2Nsb3NlJyAmJlxuICAgICAgICByZXF1ZXN0LnJhdy5yZXMuZmluaXNoZWQpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ID09PSAnZW5kJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxdWVzdC5fbG9nKGVyciA/IFsncmVxdWVzdCcsICdlcnJvciddIDogWydyZXF1ZXN0JywgJ2Vycm9yJywgZXZlbnRdLCBlcnIpO1xuXG4gICAgaWYgKGV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXF1ZXN0Ll9ldmVudENvbnRleHQucmVxdWVzdCA9IG51bGw7XG5cbiAgICBpZiAoZXZlbnQgPT09ICdhYm9ydCcgJiZcbiAgICAgICAgcmVxdWVzdC5fZXZlbnRzKSB7XG5cbiAgICAgICAgcmVxdWVzdC5fZXZlbnRzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy50aW1lb3V0UmVwbHkgPSBmdW5jdGlvbiAocmVxdWVzdCwgdGltZW91dCkge1xuXG4gICAgY29uc3QgZWxhcHNlZCA9IERhdGUubm93KCkgLSByZXF1ZXN0LmluZm8ucmVjZWl2ZWQ7XG4gICAgcmVxdWVzdC5fbG9nKFsncmVxdWVzdCcsICdzZXJ2ZXInLCAndGltZW91dCcsICdlcnJvciddLCB7IHRpbWVvdXQsIGVsYXBzZWQgfSk7XG4gICAgcmVxdWVzdC5fcmVwbHkoQm9vbS5zZXJ2ZXJVbmF2YWlsYWJsZSgpKTtcbn07XG5cblxuaW50ZXJuYWxzLnNraXAgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIHJldHVybiByZXNwb25zZS5pc0Jvb20gfHwgcmVzcG9uc2UuX3Rha2VvdmVyIHx8IHR5cGVvZiByZXNwb25zZSA9PT0gJ3N5bWJvbCc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdW5jZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdW5jZScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IFBvZGl1bSA9IHJlcXVpcmUoJ0BoYXBpL3BvZGl1bScpO1xuXG5jb25zdCBTdHJlYW1zID0gcmVxdWlyZSgnLi9zdHJlYW1zJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGV2ZW50czogUG9kaXVtLnZhbGlkYXRlKFsnZmluaXNoJywgeyBuYW1lOiAncGVlaycsIHNwcmVhZDogdHJ1ZSB9XSksXG4gICAgaG9wQnlIb3A6IHtcbiAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgJ2tlZXAtYWxpdmUnOiB0cnVlLFxuICAgICAgICAncHJveHktYXV0aGVudGljYXRlJzogdHJ1ZSxcbiAgICAgICAgJ3Byb3h5LWF1dGhvcml6YXRpb24nOiB0cnVlLFxuICAgICAgICAndGUnOiB0cnVlLFxuICAgICAgICAndHJhaWxlcic6IHRydWUsXG4gICAgICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IHRydWUsXG4gICAgICAgICd1cGdyYWRlJzogdHJ1ZVxuICAgIH1cbn07XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlJlc3BvbnNlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCByZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICB0aGlzLmFwcCA9IHt9O1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY29tcGxldGUgYXMgc29tZSBoZWFkZXJzIGFyZSBzdG9yZWQgaW4gZmxhZ3NcbiAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy52YXJpZXR5ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0ge1xuICAgICAgICAgICAgY2hhcnNldDogJ3V0Zi04JywgICAgICAgICAgICAgICAgICAgICAgIC8vICctJyByZXF1aXJlZCBieSBJQU5BXG4gICAgICAgICAgICBjb21wcmVzc2VkOiBudWxsLFxuICAgICAgICAgICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG51bGwsXG4gICAgICAgICAgICBwYXNzVGhyb3VnaDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmluZ2lmeTogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAvLyBKU09OLnN0cmluZ2lmeSBvcHRpb25zXG4gICAgICAgICAgICB0dGw6IG51bGwsXG4gICAgICAgICAgICB2YXJ5RXRhZzogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9ldmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXlsb2FkID0gbnVsbDsgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlYWRhYmxlIHN0cmVhbVxuICAgICAgICB0aGlzLl9lcnJvciA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBib29tIG9iamVjdCB3aGVuIGNyZWF0ZWQgZnJvbSBhbiBlcnJvciAodXNlZCBmb3IgbG9nZ2luZylcbiAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSBudWxsOyAgICAgICAgICAgICAgICAgICAvLyBVc2VkIGlmIG5vIGV4cGxpY2l0IGNvbnRlbnQtdHlwZSBpcyBzZXQgYW5kIHR5cGUgaXMga25vd25cbiAgICAgICAgdGhpcy5fdGFrZW92ZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdHVzQ29kZSA9IGZhbHNlOyAgICAgICAgICAgICAgICAgICAvLyB0cnVlIHdoZW4gY29kZSgpIGNhbGxlZFxuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NvcnMgPSB7XG4gICAgICAgICAgICBtYXJzaGFsOiBvcHRpb25zLm1hcnNoYWwsXG4gICAgICAgICAgICBwcmVwYXJlOiBvcHRpb25zLnByZXBhcmUsXG4gICAgICAgICAgICBjbG9zZTogb3B0aW9ucy5jbG9zZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZXJtYW5lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnJld3JpdGFibGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NldFNvdXJjZShzb3VyY2UsIG9wdGlvbnMudmFyaWV0eSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHdyYXAocmVzdWx0LCByZXF1ZXN0KSB7XG5cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIGludGVybmFscy5SZXNwb25zZSB8fFxuICAgICAgICAgICAgdHlwZW9mIHJlc3VsdCA9PT0gJ3N5bWJvbCcpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIEJvb20uYm9vbWlmeShyZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVzcG9uc2UocmVzdWx0LCByZXF1ZXN0KTtcbiAgICB9XG5cbiAgICBfc2V0U291cmNlKHNvdXJjZSwgdmFyaWV0eSkge1xuXG4gICAgICAgIC8vIE1ldGhvZCBtdXN0IG5vdCBzZXQgYW55IGhlYWRlcnMgb3Igb3RoZXIgcHJvcGVydGllcyBhcyBzb3VyY2UgY2FuIGNoYW5nZSBsYXRlclxuXG4gICAgICAgIHRoaXMudmFyaWV0eSA9IHZhcmlldHkgfHwgJ3BsYWluJztcblxuICAgICAgICBpZiAoc291cmNlID09PSBudWxsIHx8XG4gICAgICAgICAgICBzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBzb3VyY2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlldHkgPSAnYnVmZmVyJztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoU3RyZWFtcy5pc1N0cmVhbShzb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlldHkgPSAnc3RyZWFtJztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgICAgICBpZiAodGhpcy52YXJpZXR5ID09PSAncGxhaW4nICYmXG4gICAgICAgICAgICB0aGlzLnNvdXJjZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50VHlwZSA9ICh0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdzdHJpbmcnID8gJ3RleHQvaHRtbCcgOiAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGV2ZW50cygpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IFBvZGl1bShpbnRlcm5hbHMuZXZlbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHM7XG4gICAgfVxuXG4gICAgY29kZShzdGF0dXNDb2RlKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIoc3RhdHVzQ29kZSksICdTdGF0dXMgY29kZSBtdXN0IGJlIGFuIGludGVnZXInKTtcblxuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICB0aGlzLl9zdGF0dXNDb2RlID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtZXNzYWdlKGh0dHBNZXNzYWdlKSB7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5tZXNzYWdlID0gaHR0cE1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGhlYWRlcihrZXksIHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChrZXkgPT09ICd2YXJ5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFyeSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyKGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9oZWFkZXIoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgYXBwZW5kID0gb3B0aW9ucy5hcHBlbmQgfHwgZmFsc2U7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnMuc2VwYXJhdG9yIHx8ICcsJztcbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSBvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlID0gb3B0aW9ucy5kdXBsaWNhdGUgIT09IGZhbHNlO1xuXG4gICAgICAgIGlmICghYXBwZW5kICYmIG92ZXJyaWRlIHx8XG4gICAgICAgICAgICAhdGhpcy5oZWFkZXJzW2tleV0pIHtcblxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkZXJzW2tleV0gPSBbXS5jb25jYXQodGhpcy5oZWFkZXJzW2tleV0sIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFkdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZXhpc3Rpbmcuc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnNba2V5XSA9IGV4aXN0aW5nICsgc2VwYXJhdG9yICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXJ5KHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnKicpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy52YXJ5ID0gJyonO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmhlYWRlcnMudmFyeSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnZhcnkgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhlYWRlcnMudmFyeSAhPT0gJyonKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXIoJ3ZhcnknLCB2YWx1ZSwgeyBhcHBlbmQ6IHRydWUsIGR1cGxpY2F0ZTogZmFsc2UgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBldGFnKHRhZywgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGVudGl0eSA9IGludGVybmFscy5SZXNwb25zZS5lbnRpdHkodGFnLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5faGVhZGVyKCdldGFnJywgZW50aXR5LmV0YWcpO1xuICAgICAgICB0aGlzLnNldHRpbmdzLnZhcnlFdGFnID0gZW50aXR5LnZhcnk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRpYyBlbnRpdHkodGFnLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0YWcgIT09ICcqJywgJ0VUYWcgY2Fubm90IGJlIConKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXRhZzogKG9wdGlvbnMud2VhayA/ICdXLycgOiAnJykgKyAnXCInICsgdGFnICsgJ1wiJyxcbiAgICAgICAgICAgIHZhcnk6IG9wdGlvbnMudmFyeSAhPT0gZmFsc2UgJiYgIW9wdGlvbnMud2VhaywgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyeSBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICBtb2RpZmllZDogb3B0aW9ucy5tb2RpZmllZFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyB1bm1vZGlmaWVkKHJlcXVlc3QsIGVudGl0eSkge1xuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ2dldCcgJiZcbiAgICAgICAgICAgIHJlcXVlc3QubWV0aG9kICE9PSAnaGVhZCcpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3Ryb25nIHZlcmlmaWVyXG5cbiAgICAgICAgaWYgKGVudGl0eS5ldGFnICYmXG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ2lmLW5vbmUtbWF0Y2gnXSkge1xuXG4gICAgICAgICAgICBjb25zdCBpZk5vbmVNYXRjaCA9IHJlcXVlc3QuaGVhZGVyc1snaWYtbm9uZS1tYXRjaCddLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXRhZyBvZiBpZk5vbmVNYXRjaCkge1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSB0YWdzIChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuMy4yKVxuXG4gICAgICAgICAgICAgICAgaWYgKGV0YWcgPT09IGVudGl0eS5ldGFnKSB7ICAgICAgICAgICAgIC8vIFN0cm9uZyBjb21wYXJpc29uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZW50aXR5LnZhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGV0YWcgPT09IGBXLyR7ZW50aXR5LmV0YWd9YCkgeyAgICAgIC8vIFdlYWsgY29tcGFyaXNvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXRhZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBldGFnQmFzZSA9IGVudGl0eS5ldGFnLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVycyA9IHJlcXVlc3QuX2NvcmUuY29tcHJlc3Npb24uZW5jb2RpbmdzO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2RlciBvZiBlbmNvZGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXRhZyA9PT0gZXRhZ0Jhc2UgKyBgLSR7ZW5jb2Rlcn1cImApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZWFrIHZlcmlmaWVyXG5cbiAgICAgICAgaWYgKCFlbnRpdHkubW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlmTW9kaWZpZWRTaW5jZUhlYWRlciA9IHJlcXVlc3QuaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXTtcbiAgICAgICAgaWYgKCFpZk1vZGlmaWVkU2luY2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlmTW9kaWZpZWRTaW5jZSA9IGludGVybmFscy5wYXJzZURhdGUoaWZNb2RpZmllZFNpbmNlSGVhZGVyKTtcbiAgICAgICAgaWYgKCFpZk1vZGlmaWVkU2luY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IGludGVybmFscy5wYXJzZURhdGUoZW50aXR5Lm1vZGlmaWVkKTtcbiAgICAgICAgaWYgKCFsYXN0TW9kaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZk1vZGlmaWVkU2luY2UgPj0gbGFzdE1vZGlmaWVkO1xuICAgIH1cblxuICAgIHR5cGUodHlwZSkge1xuXG4gICAgICAgIHRoaXMuX2hlYWRlcignY29udGVudC10eXBlJywgdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGJ5dGVzKGJ5dGVzKSB7XG5cbiAgICAgICAgdGhpcy5faGVhZGVyKCdjb250ZW50LWxlbmd0aCcsIGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbG9jYXRpb24odXJpKSB7XG5cbiAgICAgICAgdGhpcy5faGVhZGVyKCdsb2NhdGlvbicsIHVyaSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNyZWF0ZWQobG9jYXRpb24pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLnJlcXVlc3QubWV0aG9kID09PSAncG9zdCcgfHxcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5tZXRob2QgPT09ICdwdXQnIHx8XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QubWV0aG9kID09PSAncGF0Y2gnLCAnQ2Fubm90IHJldHVybiAyMDEgc3RhdHVzIGNvZGVzIGZvciAnICsgdGhpcy5yZXF1ZXN0Lm1ldGhvZC50b1VwcGVyQ2FzZSgpKTtcblxuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAyMDE7XG4gICAgICAgIHRoaXMubG9jYXRpb24obG9jYXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb21wcmVzc2VkKGVuY29kaW5nKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoZW5jb2RpbmcgJiYgdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJywgJ0ludmFsaWQgY29udGVudC1lbmNvZGluZycpO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmNvbXByZXNzZWQgPSBlbmNvZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVwbGFjZXIobWV0aG9kKSB7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkgPSB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeSB8fCB7fTtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkucmVwbGFjZXIgPSBtZXRob2Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNwYWNlcyhjb3VudCkge1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5ID0gdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkgfHwge307XG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5LnNwYWNlID0gY291bnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN1ZmZpeChzdWZmaXgpIHtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeSA9IHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5IHx8IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeS5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGVzY2FwZShlc2NhcGUpIHtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeSA9IHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5IHx8IHt9O1xuICAgICAgICB0aGlzLnNldHRpbmdzLnN0cmluZ2lmeS5lc2NhcGUgPSBlc2NhcGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHBhc3NUaHJvdWdoKGVuYWJsZWQpIHtcblxuICAgICAgICB0aGlzLnNldHRpbmdzLnBhc3NUaHJvdWdoID0gZW5hYmxlZCAhPT0gZmFsc2U7ICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZWRpcmVjdChsb2NhdGlvbikge1xuXG4gICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IDMwMjtcbiAgICAgICAgdGhpcy5sb2NhdGlvbihsb2NhdGlvbik7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5ID0gdGhpcy5fdGVtcG9yYXJ5O1xuICAgICAgICB0aGlzLnBlcm1hbmVudCA9IHRoaXMuX3Blcm1hbmVudDtcbiAgICAgICAgdGhpcy5yZXdyaXRhYmxlID0gdGhpcy5fcmV3cml0YWJsZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgX3RlbXBvcmFyeShpc1RlbXBvcmFyeSkge1xuXG4gICAgICAgIHRoaXMuX3NldFRlbXBvcmFyeShpc1RlbXBvcmFyeSAhPT0gZmFsc2UpOyAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfcGVybWFuZW50KGlzUGVybWFuZW50KSB7XG5cbiAgICAgICAgdGhpcy5fc2V0VGVtcG9yYXJ5KGlzUGVybWFuZW50ID09PSBmYWxzZSk7ICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9yZXdyaXRhYmxlKGlzUmV3cml0YWJsZSkge1xuXG4gICAgICAgIHRoaXMuX3NldFJld3JpdGFibGUoaXNSZXdyaXRhYmxlICE9PSBmYWxzZSk7ICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfaXNUZW1wb3JhcnkoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzQ29kZSA9PT0gMzAyIHx8IHRoaXMuc3RhdHVzQ29kZSA9PT0gMzA3O1xuICAgIH1cblxuICAgIF9pc1Jld3JpdGFibGUoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHRoaXMuc3RhdHVzQ29kZSA9PT0gMzAyO1xuICAgIH1cblxuICAgIF9zZXRUZW1wb3JhcnkoaXNUZW1wb3JhcnkpIHtcblxuICAgICAgICBpZiAoaXNUZW1wb3JhcnkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jld3JpdGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IDMwMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IDMwNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1Jld3JpdGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IDMwMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQ29kZSA9IDMwODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRSZXdyaXRhYmxlKGlzUmV3cml0YWJsZSkge1xuXG4gICAgICAgIGlmIChpc1Jld3JpdGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1RlbXBvcmFyeSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gMzAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gMzAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGVtcG9yYXJ5KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAzMDc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSAzMDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmNvZGluZyhlbmNvZGluZykge1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY2hhcnNldChjaGFyc2V0KSB7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5jaGFyc2V0ID0gY2hhcnNldCB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0dGwodHRsKSB7XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy50dGwgPSB0dGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHN0YXRlKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0Ll9zZXRTdGF0ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHVuc3RhdGUobmFtZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMucmVxdWVzdC5fY2xlYXJTdGF0ZShuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGFrZW92ZXIoKSB7XG5cbiAgICAgICAgdGhpcy5fdGFrZW92ZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfcHJlcGFyZSgpIHtcblxuICAgICAgICB0aGlzLl9wYXNzVGhyb3VnaCgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcHJvY2Vzc29ycy5wcmVwYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc29ycy5wcmVwYXJlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uYm9vbWlmeShlcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Bhc3NUaHJvdWdoKCkge1xuXG4gICAgICAgIGlmICh0aGlzLnZhcmlldHkgPT09ICdzdHJlYW0nICYmXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnBhc3NUaHJvdWdoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5zdGF0dXNDb2RlICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuc3RhdHVzQ29kZSkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gdGhpcy5zb3VyY2Uuc3RhdHVzQ29kZTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJlYW0gaXMgYW4gSFRUUCByZXNwb25zZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGxldCBoZWFkZXJLZXlzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2UuaGVhZGVycyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxIZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5zb3VyY2UuaGVhZGVycy5jb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieUhvcCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zcGxpdCgvXFxzKixcXHMqLykuZm9yRWFjaCgoaGVhZGVyKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieUhvcFtoZWFkZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaGVhZGVyS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmhvcEJ5SG9wW2xvd2VyXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFieUhvcFtsb3dlcl0pIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVyKGxvd2VyLCBIb2VrLmNsb25lKHRoaXMuc291cmNlLmhlYWRlcnNba2V5XSkpOyAgICAgLy8gQ2xvbmUgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJLZXlzID0gT2JqZWN0LmtleXMobG9jYWxIZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaGVhZGVyS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFkZXIoa2V5LCBsb2NhbEhlYWRlcnNba2V5XSwgeyBhcHBlbmQ6IGtleSA9PT0gJ3NldC1jb29raWUnIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gdGhpcy5zdGF0dXNDb2RlIHx8IDIwMDtcbiAgICB9XG5cbiAgICBhc3luYyBfbWFyc2hhbCgpIHtcblxuICAgICAgICBsZXQgc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgICAgICAgLy8gUHJvY2Vzc29yIG1hcnNoYWxcblxuICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc29ycy5tYXJzaGFsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGF3YWl0IHRoaXMuX3Byb2Nlc3NvcnMubWFyc2hhbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmJvb21pZnkoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0cmVhbSBzb3VyY2VcblxuICAgICAgICBpZiAoU3RyZWFtcy5pc1N0cmVhbShzb3VyY2UpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZS5fcmVhZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ1N0cmVhbSBtdXN0IGhhdmUgYSByZWFkYWJsZSBpbnRlcmZhY2UnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNvdXJjZS5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignQ2Fubm90IHJlcGx5IHdpdGggc3RyZWFtIGluIG9iamVjdCBtb2RlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3BheWxvYWQgPSBzb3VyY2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQbGFpbiBzb3VyY2UgKG5vbiBzdHJpbmcgb3IgbnVsbClcblxuICAgICAgICBjb25zdCBqc29uaWZ5ID0gdGhpcy52YXJpZXR5ID09PSAncGxhaW4nICYmIHNvdXJjZSAhPT0gbnVsbCAmJiB0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJztcblxuICAgICAgICBpZiAoIWpzb25pZnkgJiZcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc3RyaW5naWZ5KSB7XG5cbiAgICAgICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0Nhbm5vdCBzZXQgZm9ybWF0dGluZyBvcHRpb25zIG9uIG5vbiBvYmplY3QgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXlsb2FkID0gc291cmNlO1xuXG4gICAgICAgIGlmIChqc29uaWZ5KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5zZXR0aW5ncy5zdHJpbmdpZnkgfHwge307XG4gICAgICAgICAgICBjb25zdCBzcGFjZSA9IG9wdGlvbnMuc3BhY2UgfHwgdGhpcy5yZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmpzb24uc3BhY2U7XG4gICAgICAgICAgICBjb25zdCByZXBsYWNlciA9IG9wdGlvbnMucmVwbGFjZXIgfHwgdGhpcy5yZXF1ZXN0LnJvdXRlLnNldHRpbmdzLmpzb24ucmVwbGFjZXI7XG4gICAgICAgICAgICBjb25zdCBzdWZmaXggPSBvcHRpb25zLnN1ZmZpeCB8fCB0aGlzLnJlcXVlc3Qucm91dGUuc2V0dGluZ3MuanNvbi5zdWZmaXggfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBlc2NhcGUgPSB0aGlzLnJlcXVlc3Qucm91dGUuc2V0dGluZ3MuanNvbi5lc2NhcGUgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VyIHx8IHNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkLCByZXBsYWNlciwgc3BhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmJvb21pZnkoZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkICsgc3VmZml4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEhvZWsuZXNjYXBlSnNvbihwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BheWxvYWQgPSBuZXcgaW50ZXJuYWxzLlJlc3BvbnNlLlBheWxvYWQocGF5bG9hZCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgX3RhcCgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmhhc0xpc3RlbmVycygncGVlaycpIHx8XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuaGFzTGlzdGVuZXJzKCdmaW5pc2gnKSkge1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5SZXNwb25zZS5QZWVrKHRoaXMuX2V2ZW50cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBfY2xvc2UocmVxdWVzdCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9wcm9jZXNzb3JzLmNsb3NlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NvcnMuY2xvc2UodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5fbG9nKFsncmVzcG9uc2UnLCAnY2xlYW51cCcsICdlcnJvciddLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fcGF5bG9hZCB8fCB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKFN0cmVhbXMuaXNTdHJlYW0oc3RyZWFtKSkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLlJlc3BvbnNlLmRyYWluKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaXNQYXlsb2FkU3VwcG9ydGVkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QubWV0aG9kICE9PSAnaGVhZCcgJiYgdGhpcy5zdGF0dXNDb2RlICE9PSAzMDQgJiYgdGhpcy5zdGF0dXNDb2RlICE9PSAyMDQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGRyYWluKHN0cmVhbSkge1xuXG4gICAgICAgIGlmIChzdHJlYW0udW5waXBlKSB7XG4gICAgICAgICAgICBzdHJlYW0udW5waXBlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyZWFtLmNsb3NlKSB7XG4gICAgICAgICAgICBzdHJlYW0uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZGVzdHJveSkge1xuICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFN0cmVhbXMuZHJhaW4oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnBhcnNlRGF0ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBEYXRlLnBhcnNlKHN0cmluZyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJJZ25vcmUpIHsgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVzcG9uc2UuUGF5bG9hZCA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtLlJlYWRhYmxlIHtcblxuICAgIGNvbnN0cnVjdG9yKHBheWxvYWQsIG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLl9wcmVmaXggPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWZmaXggPSBudWxsO1xuICAgICAgICB0aGlzLl9zaXplT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5fZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICAgIH1cblxuICAgIF9yZWFkKHNpemUpIHtcblxuICAgICAgICBpZiAodGhpcy5fcHJlZml4KSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5fcHJlZml4LCB0aGlzLl9lbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuX2RhdGEsIHRoaXMuX2VuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdWZmaXgpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9zdWZmaXgsIHRoaXMuX2VuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICB9XG5cbiAgICBzaXplKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKEJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9kYXRhKSA/IHRoaXMuX2RhdGEubGVuZ3RoIDogQnVmZmVyLmJ5dGVMZW5ndGgodGhpcy5fZGF0YSwgdGhpcy5fZW5jb2RpbmcpKSArIHRoaXMuX3NpemVPZmZzZXQ7XG4gICAgfVxuXG4gICAganNvbnAodmFyaWFibGUpIHtcblxuICAgICAgICB0aGlzLl9zaXplT2Zmc2V0ID0gdGhpcy5fc2l6ZU9mZnNldCArIHZhcmlhYmxlLmxlbmd0aCArIDc7XG4gICAgICAgIHRoaXMuX3ByZWZpeCA9ICcvKiovJyArIHZhcmlhYmxlICsgJygnOyAgICAgICAgICAgICAgICAgLy8gJy8qKi8nIHByZWZpeCBwcmV2ZW50cyBDVkUtMjAxNC00NjcxIHNlY3VyaXR5IGV4cGxvaXRcbiAgICAgICAgdGhpcy5fZGF0YSA9ICh0aGlzLl9kYXRhID09PSBudWxsIHx8IEJ1ZmZlci5pc0J1ZmZlcih0aGlzLl9kYXRhKSkgPyB0aGlzLl9kYXRhIDogdGhpcy5fZGF0YS5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKS5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKTtcbiAgICAgICAgdGhpcy5fc3VmZml4ID0gJyk7JztcbiAgICB9XG5cbiAgICB3cml0ZVRvU3RyZWFtKHN0cmVhbSkge1xuXG4gICAgICAgIGlmICh0aGlzLl9wcmVmaXgpIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZSh0aGlzLl9wcmVmaXgsIHRoaXMuX2VuY29kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICBzdHJlYW0ud3JpdGUodGhpcy5fZGF0YSwgdGhpcy5fZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N1ZmZpeCkge1xuICAgICAgICAgICAgc3RyZWFtLndyaXRlKHRoaXMuX3N1ZmZpeCwgdGhpcy5fZW5jb2RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtLmVuZCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlJlc3BvbnNlLlBlZWsgPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5UcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3IocG9kaXVtKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9wb2RpdW0gPSBwb2RpdW07XG4gICAgICAgIHRoaXMub24oJ2ZpbmlzaCcsICgpID0+IHBvZGl1bS5lbWl0KCdmaW5pc2gnKSk7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgdGhpcy5fcG9kaXVtLmVtaXQoJ3BlZWsnLCBbY2h1bmssIGVuY29kaW5nXSk7XG4gICAgICAgIHRoaXMucHVzaChjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBDYXRib3ggPSByZXF1aXJlKCdAaGFwaS9jYXRib3gnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcbmNvbnN0IFN1YnRleHQgPSByZXF1aXJlKCdAaGFwaS9zdWJ0ZXh0Jyk7XG5cbmNvbnN0IEF1dGggPSByZXF1aXJlKCcuL2F1dGgnKTtcbmNvbnN0IENvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5jb25zdCBDb3JzID0gcmVxdWlyZSgnLi9jb3JzJyk7XG5jb25zdCBFeHQgPSByZXF1aXJlKCcuL2V4dCcpO1xuY29uc3QgSGFuZGxlciA9IHJlcXVpcmUoJy4vaGFuZGxlcicpO1xuY29uc3QgSGVhZGVycyA9IHJlcXVpcmUoJy4vaGVhZGVycycpO1xuY29uc3QgU2VjdXJpdHkgPSByZXF1aXJlKCcuL3NlY3VyaXR5Jyk7XG5jb25zdCBTdHJlYW1zID0gcmVxdWlyZSgnLi9zdHJlYW1zJyk7XG5jb25zdCBWYWxpZGF0aW9uID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlJvdXRlID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iocm91dGUsIHNlcnZlciwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgY29uc3QgY29yZSA9IHNlcnZlci5fY29yZTtcbiAgICAgICAgY29uc3QgcmVhbG0gPSBzZXJ2ZXIucmVhbG07XG5cbiAgICAgICAgLy8gUm91dGluZyBpbmZvcm1hdGlvblxuXG4gICAgICAgIENvbmZpZy5hcHBseSgncm91dGUnLCByb3V0ZSwgcm91dGUubWV0aG9kLCByb3V0ZS5wYXRoKTtcblxuICAgICAgICBjb25zdCBtZXRob2QgPSByb3V0ZS5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgSG9lay5hc3NlcnQobWV0aG9kICE9PSAnaGVhZCcsICdDYW5ub3Qgc2V0IEhFQUQgcm91dGU6Jywgcm91dGUucGF0aCk7XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IChyZWFsbS5tb2RpZmllcnMucm91dGUucHJlZml4ID8gcmVhbG0ubW9kaWZpZXJzLnJvdXRlLnByZWZpeCArIChyb3V0ZS5wYXRoICE9PSAnLycgPyByb3V0ZS5wYXRoIDogJycpIDogcm91dGUucGF0aCk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHBhdGggPT09ICcvJyB8fCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09ICcvJyB8fCAhY29yZS5zZXR0aW5ncy5yb3V0ZXIuc3RyaXBUcmFpbGluZ1NsYXNoLCAnUGF0aCBjYW5ub3QgZW5kIHdpdGggYSB0cmFpbGluZyBzbGFzaCB3aGVuIGNvbmZpZ3VyZWQgdG8gc3RyaXA6Jywgcm91dGUubWV0aG9kLCByb3V0ZS5wYXRoKTtcblxuICAgICAgICBjb25zdCB2aG9zdCA9IChyZWFsbS5tb2RpZmllcnMucm91dGUudmhvc3QgfHwgcm91dGUudmhvc3QpO1xuXG4gICAgICAgIC8vIFNldCBpZGVudGlmeWluZyBtZW1iZXJzIChhc3NlcnQpXG5cbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG5cbiAgICAgICAgLy8gUHJlcGFyZSBjb25maWd1cmF0aW9uXG5cbiAgICAgICAgbGV0IGNvbmZpZyA9IHJvdXRlLm9wdGlvbnMgfHwgcm91dGUuY29uZmlnIHx8IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uZmlnID0gY29uZmlnLmNhbGwocmVhbG0uc2V0dGluZ3MuYmluZCwgc2VydmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZyA9IENvbmZpZy5lbmFibGUoY29uZmlnKTsgICAgIC8vIFNoYWxsb3cgY2xvbmVcblxuICAgICAgICAvLyBWZXJpZnkgcm91dGUgbGV2ZWwgY29uZmlnIChhcyBvcHBvc2VkIHRvIHRoZSBtZXJnZWQgc2V0dGluZ3MpXG5cbiAgICAgICAgdGhpcy5fYXNzZXJ0KG1ldGhvZCAhPT0gJ2dldCcgfHwgIWNvbmZpZy5wYXlsb2FkLCAnQ2Fubm90IHNldCBwYXlsb2FkIHNldHRpbmdzIG9uIEhFQUQgb3IgR0VUIHJlcXVlc3QnKTtcbiAgICAgICAgdGhpcy5fYXNzZXJ0KG1ldGhvZCAhPT0gJ2dldCcgfHwgIWNvbmZpZy52YWxpZGF0ZSB8fCAhY29uZmlnLnZhbGlkYXRlLnBheWxvYWQsICdDYW5ub3QgdmFsaWRhdGUgSEVBRCBvciBHRVQgcmVxdWVzdCBwYXlsb2FkJyk7XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICB0aGlzLl9hc3NlcnQoIXJvdXRlLnJ1bGVzIHx8ICFjb25maWcucnVsZXMsICdSb3V0ZSBydWxlcyBjYW4gb25seSBhcHBlYXIgb25jZScpOyAgICAgICAgICAgICAgICAgICAgLy8gWE9SXG4gICAgICAgIGNvbnN0IHJ1bGVzID0gKHJvdXRlLnJ1bGVzIHx8IGNvbmZpZy5ydWxlcyk7XG4gICAgICAgIGNvbnN0IHJ1bGVzQ29uZmlnID0gaW50ZXJuYWxzLnJ1bGVzKHJ1bGVzLCB7IG1ldGhvZCwgcGF0aCwgdmhvc3QgfSwgc2VydmVyKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5ydWxlcztcblxuICAgICAgICAvLyBIYW5kbGVyXG5cbiAgICAgICAgdGhpcy5fYXNzZXJ0KHJvdXRlLmhhbmRsZXIgfHwgY29uZmlnLmhhbmRsZXIsICdNaXNzaW5nIG9yIHVuZGVmaW5lZCBoYW5kbGVyJyk7XG4gICAgICAgIHRoaXMuX2Fzc2VydCghIXJvdXRlLmhhbmRsZXIgXiAhIWNvbmZpZy5oYW5kbGVyLCAnSGFuZGxlciBtdXN0IG9ubHkgYXBwZWFyIG9uY2UnKTsgICAgICAgICAgICAgICAgICAvLyBYT1JcblxuICAgICAgICBjb25zdCBoYW5kbGVyID0gQ29uZmlnLmFwcGx5KCdoYW5kbGVyJywgcm91dGUuaGFuZGxlciB8fCBjb25maWcuaGFuZGxlcik7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaGFuZGxlcjtcblxuICAgICAgICBjb25zdCBoYW5kbGVyRGVmYXVsdHMgPSBIYW5kbGVyLmRlZmF1bHRzKG1ldGhvZCwgaGFuZGxlciwgY29yZSk7XG5cbiAgICAgICAgLy8gQXBwbHkgc2V0dGluZ3MgaW4gb3JkZXI6IHNlcnZlciA8LSBoYW5kbGVyIDwtIHJlYWxtIDwtIHJvdXRlXG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBpbnRlcm5hbHMuY29uZmlnKFtjb3JlLnNldHRpbmdzLnJvdXRlcywgaGFuZGxlckRlZmF1bHRzLCByZWFsbS5zZXR0aW5ncywgcnVsZXNDb25maWcsIGNvbmZpZ10pO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gQ29uZmlnLmFwcGx5KCdyb3V0ZUNvbmZpZycsIHNldHRpbmdzLCBtZXRob2QsIHBhdGgpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRpbWVvdXRzXG5cbiAgICAgICAgY29uc3Qgc29ja2V0VGltZW91dCA9ICh0aGlzLnNldHRpbmdzLnRpbWVvdXQuc29ja2V0ID09PSB1bmRlZmluZWQgPyAyICogNjAgKiAxMDAwIDogdGhpcy5zZXR0aW5ncy50aW1lb3V0LnNvY2tldCk7XG4gICAgICAgIHRoaXMuX2Fzc2VydCghdGhpcy5zZXR0aW5ncy50aW1lb3V0LnNlcnZlciB8fCAhc29ja2V0VGltZW91dCB8fCB0aGlzLnNldHRpbmdzLnRpbWVvdXQuc2VydmVyIDwgc29ja2V0VGltZW91dCwgJ1NlcnZlciB0aW1lb3V0IG11c3QgYmUgc2hvcnRlciB0aGFuIHNvY2tldCB0aW1lb3V0Jyk7XG4gICAgICAgIHRoaXMuX2Fzc2VydCghdGhpcy5zZXR0aW5ncy5wYXlsb2FkLnRpbWVvdXQgfHwgIXNvY2tldFRpbWVvdXQgfHwgdGhpcy5zZXR0aW5ncy5wYXlsb2FkLnRpbWVvdXQgPCBzb2NrZXRUaW1lb3V0LCAnUGF5bG9hZCB0aW1lb3V0IG11c3QgYmUgc2hvcnRlciB0aGFuIHNvY2tldCB0aW1lb3V0Jyk7XG5cbiAgICAgICAgLy8gUm91dGUgbWVtYmVyc1xuXG4gICAgICAgIHRoaXMuX2NvcmUgPSBjb3JlO1xuICAgICAgICB0aGlzLnJlYWxtID0gcmVhbG07XG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy52aG9zdCA9IHZob3N0O1xuICAgICAgICB0aGlzLnNldHRpbmdzLnBsdWdpbnMgPSB0aGlzLnNldHRpbmdzLnBsdWdpbnMgfHwge307ICAgICAgICAgICAgLy8gUm91dGUtc3BlY2lmaWMgcGx1Z2lucyBzZXR0aW5ncywgbmFtZXNwYWNlZCB1c2luZyBwbHVnaW4gbmFtZVxuICAgICAgICB0aGlzLnNldHRpbmdzLmFwcCA9IHRoaXMuc2V0dGluZ3MuYXBwIHx8IHt9OyAgICAgICAgICAgICAgICAgICAgLy8gUm91dGUtc3BlY2lmaWMgYXBwbGljYXRpb24gc2V0dGluZ3NcblxuICAgICAgICAvLyBQYXRoIHBhcnNpbmdcblxuICAgICAgICB0aGlzLl9zcGVjaWFsID0gISFvcHRpb25zLnNwZWNpYWw7XG4gICAgICAgIHRoaXMuX2FuYWx5c2lzID0gdGhpcy5fY29yZS5yb3V0ZXIuYW5hbHl6ZSh0aGlzLnBhdGgpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2FuYWx5c2lzLnBhcmFtcztcbiAgICAgICAgdGhpcy5maW5nZXJwcmludCA9IHRoaXMuX2FuYWx5c2lzLmZpbmdlcnByaW50O1xuXG4gICAgICAgIHRoaXMucHVibGljID0ge1xuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICAgICAgICAgIHZob3N0LFxuICAgICAgICAgICAgcmVhbG0sXG4gICAgICAgICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgICAgIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LFxuICAgICAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgICAgIGFjY2VzczogKHJlcXVlc3QpID0+IEF1dGgudGVzdEFjY2VzcyhyZXF1ZXN0LCB0aGlzLnB1YmxpYylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBWYWxpZGF0aW9uXG5cbiAgICAgICAgdGhpcy5fc2V0dXBWYWxpZGF0aW9uKCk7XG5cbiAgICAgICAgLy8gUGF5bG9hZCBwYXJzaW5nXG5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnZ2V0Jykge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5wYXlsb2FkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucGF5bG9hZC5kZWNvZGVycyA9IHRoaXMuX2NvcmUuY29tcHJlc3Npb24uX2RlY29kZXJzOyAgICAgICAgLy8gUmVmZXJlbmNlIHRoZSBzaGFyZWQgb2JqZWN0IHRvIGtlZXAgdXAgdG8gZGF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXNzZXJ0KCF0aGlzLnNldHRpbmdzLnZhbGlkYXRlLnBheWxvYWQgfHwgdGhpcy5zZXR0aW5ncy5wYXlsb2FkLnBhcnNlLCAnUm91dGUgcGF5bG9hZCBtdXN0IGJlIHNldCB0byBcXCdwYXJzZVxcJyB3aGVuIHBheWxvYWQgdmFsaWRhdGlvbiBlbmFibGVkJyk7XG4gICAgICAgIHRoaXMuX2Fzc2VydCghdGhpcy5zZXR0aW5ncy52YWxpZGF0ZS5zdGF0ZSB8fCB0aGlzLnNldHRpbmdzLnN0YXRlLnBhcnNlLCAnUm91dGUgc3RhdGUgbXVzdCBiZSBzZXQgdG8gXFwncGFyc2VcXCcgd2hlbiBzdGF0ZSB2YWxpZGF0aW9uIGVuYWJsZWQnKTtcbiAgICAgICAgdGhpcy5fYXNzZXJ0KCF0aGlzLnNldHRpbmdzLmpzb25wIHx8IHR5cGVvZiB0aGlzLnNldHRpbmdzLmpzb25wID09PSAnc3RyaW5nJywgJ0JhZCByb3V0ZSBKU09OUCBwYXJhbWV0ZXIgbmFtZScpO1xuXG4gICAgICAgIC8vIEF1dGhlbnRpY2F0aW9uIGNvbmZpZ3VyYXRpb25cblxuICAgICAgICB0aGlzLnNldHRpbmdzLmF1dGggPSAodGhpcy5fc3BlY2lhbCA/IGZhbHNlIDogdGhpcy5fY29yZS5hdXRoLl9zZXR1cFJvdXRlKHRoaXMuc2V0dGluZ3MuYXV0aCwgcGF0aCkpO1xuXG4gICAgICAgIC8vIENhY2hlXG5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnZ2V0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuc2V0dGluZ3MuY2FjaGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAodGhpcy5zZXR0aW5ncy5jYWNoZS5leHBpcmVzSW4gfHwgdGhpcy5zZXR0aW5ncy5jYWNoZS5leHBpcmVzQXQpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuY2FjaGUuX3N0YXR1c2VzID0gbmV3IFNldCh0aGlzLnNldHRpbmdzLmNhY2hlLnN0YXR1c2VzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IENhdGJveC5Qb2xpY3koeyBleHBpcmVzSW46IHRoaXMuc2V0dGluZ3MuY2FjaGUuZXhwaXJlc0luLCBleHBpcmVzQXQ6IHRoaXMuc2V0dGluZ3MuY2FjaGUuZXhwaXJlc0F0IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ09SU1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY29ycyA9IENvcnMucm91dGUodGhpcy5zZXR0aW5ncy5jb3JzKTtcblxuICAgICAgICAvLyBTZWN1cml0eVxuXG4gICAgICAgIHRoaXMuc2V0dGluZ3Muc2VjdXJpdHkgPSBTZWN1cml0eS5yb3V0ZSh0aGlzLnNldHRpbmdzLnNlY3VyaXR5KTtcblxuICAgICAgICAvLyBIYW5kbGVyXG5cbiAgICAgICAgdGhpcy5zZXR0aW5ncy5oYW5kbGVyID0gSGFuZGxlci5jb25maWd1cmUoaGFuZGxlciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3ByZXJlcXVpc2l0ZXMgPSBIYW5kbGVyLnByZXJlcXVpc2l0ZXNDb25maWcodGhpcy5zZXR0aW5ncy5wcmUpO1xuXG4gICAgICAgIC8vIFJvdXRlIGxpZmVjeWNsZVxuXG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7XG4gICAgICAgICAgICBvblByZVJlc3BvbnNlOiBFeHQuY29tYmluZSh0aGlzLCAnb25QcmVSZXNwb25zZScpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuX3NwZWNpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlID0gW2ludGVybmFscy5kcmFpbiwgSGFuZGxlci5leGVjdXRlXTtcbiAgICAgICAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXh0ZW5zaW9ucy5vblByZUF1dGggPSBFeHQuY29tYmluZSh0aGlzLCAnb25QcmVBdXRoJyk7XG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbnMub25DcmVkZW50aWFscyA9IEV4dC5jb21iaW5lKHRoaXMsICdvbkNyZWRlbnRpYWxzJyk7XG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbnMub25Qb3N0QXV0aCA9IEV4dC5jb21iaW5lKHRoaXMsICdvblBvc3RBdXRoJyk7XG4gICAgICAgIHRoaXMuX2V4dGVuc2lvbnMub25QcmVIYW5kbGVyID0gRXh0LmNvbWJpbmUodGhpcywgJ29uUHJlSGFuZGxlcicpO1xuICAgICAgICB0aGlzLl9leHRlbnNpb25zLm9uUG9zdEhhbmRsZXIgPSBFeHQuY29tYmluZSh0aGlzLCAnb25Qb3N0SGFuZGxlcicpO1xuXG4gICAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgIH1cblxuICAgIF9zZXR1cFZhbGlkYXRpb24oKSB7XG5cbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IHRoaXMuc2V0dGluZ3MudmFsaWRhdGU7XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ2dldCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24ucGF5bG9hZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hc3NlcnQoIXZhbGlkYXRpb24ucGFyYW1zIHx8IHRoaXMucGFyYW1zLmxlbmd0aCwgJ0Nhbm5vdCBzZXQgcGF0aCBwYXJhbWV0ZXJzIHZhbGlkYXRpb25zIHdpdGhvdXQgcGF0aCBwYXJhbWV0ZXJzJyk7XG5cbiAgICAgICAgWydoZWFkZXJzJywgJ3BhcmFtcycsICdxdWVyeScsICdwYXlsb2FkJywgJ3N0YXRlJ10uZm9yRWFjaCgodHlwZSkgPT4ge1xuXG4gICAgICAgICAgICB2YWxpZGF0aW9uW3R5cGVdID0gVmFsaWRhdGlvbi5jb21waWxlKHZhbGlkYXRpb25bdHlwZV0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZXNwb25zZS5zY2hlbWEgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXNwb25zZS5zdGF0dXMpIHtcblxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXNwb25zZS5fdmFsaWRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBjb25zdCBydWxlID0gdGhpcy5zZXR0aW5ncy5yZXNwb25zZS5zY2hlbWE7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlc3BvbnNlLnN0YXR1cyA9IHRoaXMuc2V0dGluZ3MucmVzcG9uc2Uuc3RhdHVzIHx8IHt9O1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNldHRpbmdzLnJlc3BvbnNlLnN0YXR1cyk7XG5cbiAgICAgICAgICAgIGlmIChydWxlID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgIXN0YXR1c2VzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXNwb25zZS5fdmFsaWRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVzcG9uc2Uuc2NoZW1hID0gVmFsaWRhdGlvbi5jb21waWxlKHJ1bGUpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29kZSBvZiBzdGF0dXNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlc3BvbnNlLnN0YXR1c1tjb2RlXSA9IFZhbGlkYXRpb24uY29tcGlsZSh0aGlzLnNldHRpbmdzLnJlc3BvbnNlLnN0YXR1c1tjb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVidWlsZChldmVudCkge1xuXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tldmVudC50eXBlXS5hZGQoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NwZWNpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3RDeWNsZSA9ICh0aGlzLl9leHRlbnNpb25zLm9uUHJlUmVzcG9uc2Uubm9kZXMgPyBbdGhpcy5fZXh0ZW5zaW9ucy5vblByZVJlc3BvbnNlXSA6IFtdKTtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkTWFyc2hhbEN5Y2xlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsZCBsaWZlY3ljbGUgYXJyYXlcblxuICAgICAgICB0aGlzLl9jeWNsZSA9IFtdO1xuXG4gICAgICAgIC8vICdvblJlcXVlc3QnXG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuanNvbnApIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goaW50ZXJuYWxzLnBhcnNlSlNPTlApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RhdGUucGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goaW50ZXJuYWxzLnN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9leHRlbnNpb25zLm9uUHJlQXV0aC5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaCh0aGlzLl9leHRlbnNpb25zLm9uUHJlQXV0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29yZS5hdXRoLl9lbmFibGVkKHRoaXMsICdhdXRoZW50aWNhdGUnKSkge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaChBdXRoLmF1dGhlbnRpY2F0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdnZXQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKGludGVybmFscy5wYXlsb2FkKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NvcmUuYXV0aC5fZW5hYmxlZCh0aGlzLCAncGF5bG9hZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaChBdXRoLnBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvcmUuYXV0aC5fZW5hYmxlZCh0aGlzLCAnYXV0aGVudGljYXRlJykgJiZcbiAgICAgICAgICAgIHRoaXMuX2V4dGVuc2lvbnMub25DcmVkZW50aWFscy5ub2Rlcykge1xuXG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKHRoaXMuX2V4dGVuc2lvbnMub25DcmVkZW50aWFscyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29yZS5hdXRoLl9lbmFibGVkKHRoaXMsICdhY2Nlc3MnKSkge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaChBdXRoLmFjY2Vzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucy5vblBvc3RBdXRoLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKHRoaXMuX2V4dGVuc2lvbnMub25Qb3N0QXV0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZGF0ZS5oZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKFZhbGlkYXRpb24uaGVhZGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZGF0ZS5wYXJhbXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goVmFsaWRhdGlvbi5wYXJhbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuanNvbnApIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goaW50ZXJuYWxzLmNsZWFudXBKU09OUCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy52YWxpZGF0ZS5xdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5fY3ljbGUucHVzaChWYWxpZGF0aW9uLnF1ZXJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkYXRlLnBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goVmFsaWRhdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnZhbGlkYXRlLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKFZhbGlkYXRpb24uc3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4dGVuc2lvbnMub25QcmVIYW5kbGVyLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKHRoaXMuX2V4dGVuc2lvbnMub25QcmVIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N5Y2xlLnB1c2goSGFuZGxlci5leGVjdXRlKTtcblxuICAgICAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucy5vblBvc3RIYW5kbGVyLm5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9jeWNsZS5wdXNoKHRoaXMuX2V4dGVuc2lvbnMub25Qb3N0SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3N0Q3ljbGUgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZXNwb25zZS5fdmFsaWRhdGUgJiZcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MucmVzcG9uc2Uuc2FtcGxlICE9PSAwKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3Bvc3RDeWNsZS5wdXNoKFZhbGlkYXRpb24ucmVzcG9uc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2V4dGVuc2lvbnMub25QcmVSZXNwb25zZS5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5fcG9zdEN5Y2xlLnB1c2godGhpcy5fZXh0ZW5zaW9ucy5vblByZVJlc3BvbnNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1aWxkTWFyc2hhbEN5Y2xlKCk7XG4gICAgfVxuXG4gICAgX2J1aWxkTWFyc2hhbEN5Y2xlKCkge1xuXG4gICAgICAgIHRoaXMuX21hcnNoYWxDeWNsZSA9IFtIZWFkZXJzLnR5cGVdO1xuXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmNvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcnNoYWxDeWNsZS5wdXNoKENvcnMuaGVhZGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zZWN1cml0eSkge1xuICAgICAgICAgICAgdGhpcy5fbWFyc2hhbEN5Y2xlLnB1c2goU2VjdXJpdHkuaGVhZGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYXJzaGFsQ3ljbGUucHVzaChIZWFkZXJzLmVudGl0eSk7XG5cbiAgICAgICAgaWYgKHRoaXMubWV0aG9kID09PSAnZ2V0JyB8fFxuICAgICAgICAgICAgdGhpcy5tZXRob2QgPT09ICcqJykge1xuXG4gICAgICAgICAgICB0aGlzLl9tYXJzaGFsQ3ljbGUucHVzaChIZWFkZXJzLnVubW9kaWZpZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFyc2hhbEN5Y2xlLnB1c2goSGVhZGVycy5jYWNoZSk7XG4gICAgICAgIHRoaXMuX21hcnNoYWxDeWNsZS5wdXNoKEhlYWRlcnMuc3RhdGUpO1xuICAgICAgICB0aGlzLl9tYXJzaGFsQ3ljbGUucHVzaChIZWFkZXJzLmNvbnRlbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jb3JlLmF1dGguX2VuYWJsZWQodGhpcywgJ3Jlc3BvbnNlJykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcnNoYWxDeWNsZS5wdXNoKEF1dGgucmVzcG9uc2UpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIGxhc3QgaW4gY2FzZSByZXF1aXJlcyBhY2Nlc3MgdG8gaGVhZGVyc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Fzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcblxuICAgICAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tZXRob2RbMF0gIT09ICdfJykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9OiAke3RoaXMubWV0aG9kLnRvVXBwZXJDYXNlKCl9ICR7dGhpcy5wYXRofWA7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBhY3R1YWw6IGZhbHNlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBvcGVyYXRvcjogJz09JyxcbiAgICAgICAgICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogdGhpcy5fYXNzZXJ0XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnN0YXRlID0gYXN5bmMgZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIHJlcXVlc3Quc3RhdGUgPSB7fTtcblxuICAgIGNvbnN0IHJlcSA9IHJlcXVlc3QucmF3LnJlcTtcbiAgICBjb25zdCBjb29raWVzID0gcmVxLmhlYWRlcnMuY29va2llO1xuICAgIGlmICghY29va2llcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGF3YWl0IHJlcXVlc3QuX2NvcmUuc3RhdGVzLnBhcnNlKGNvb2tpZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICB2YXIgcGFyc2VFcnJvciA9IGVycjtcbiAgICB9XG5cbiAgICBjb25zdCB7IHN0YXRlcywgZmFpbGVkID0gW10gfSA9IHJlc3VsdCB8fCBwYXJzZUVycm9yO1xuICAgIHJlcXVlc3Quc3RhdGUgPSBzdGF0ZXMgfHwge307XG5cbiAgICAvLyBDbGVhciBjb29raWVzXG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZmFpbGVkKSB7XG4gICAgICAgIGlmIChpdGVtLnNldHRpbmdzLmNsZWFySW52YWxpZCkge1xuICAgICAgICAgICAgcmVxdWVzdC5fY2xlYXJTdGF0ZShpdGVtLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZUVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYXJzZUVycm9yLmhlYWRlciA9IGNvb2tpZXM7XG5cbiAgICByZXR1cm4gcmVxdWVzdC5fY29yZS50b29sa2l0LmZhaWxBY3Rpb24ocmVxdWVzdCwgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5zdGF0ZS5mYWlsQWN0aW9uLCBwYXJzZUVycm9yLCB7IHRhZ3M6IFsnc3RhdGUnLCAnZXJyb3InXSB9KTtcbn07XG5cblxuaW50ZXJuYWxzLnBheWxvYWQgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnZ2V0JyB8fFxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9PT0gJ2hlYWQnKSB7ICAgICAgICAgICAgLy8gV2hlbiByb3V0ZS5tZXRob2QgaXMgJyonXG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Ll9leHBlY3RDb250aW51ZSkge1xuICAgICAgICByZXF1ZXN0LnJhdy5yZXMud3JpdGVDb250aW51ZSgpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgcGF5bG9hZCwgbWltZSB9ID0gYXdhaXQgU3VidGV4dC5wYXJzZShyZXF1ZXN0LnJhdy5yZXEsIHJlcXVlc3QuX3RhcCgpLCByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnBheWxvYWQpO1xuXG4gICAgICAgIHJlcXVlc3QuX2lzUGF5bG9hZFBlbmRpbmcgPSAhIShwYXlsb2FkICYmIHBheWxvYWQuX3JlYWRhYmxlU3RhdGUpO1xuICAgICAgICByZXF1ZXN0Lm1pbWUgPSBtaW1lO1xuICAgICAgICByZXF1ZXN0LnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0Ll9pc1BheWxvYWRQZW5kaW5nKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnRlcm5hbHMuZHJhaW4ocmVxdWVzdCk7XG4gICAgICAgICAgICByZXF1ZXN0Ll9pc1BheWxvYWRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0Ll9pc1BheWxvYWRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QubWltZSA9IGVyci5taW1lO1xuICAgICAgICByZXF1ZXN0LnBheWxvYWQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0Ll9jb3JlLnRvb2xraXQuZmFpbEFjdGlvbihyZXF1ZXN0LCByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnBheWxvYWQuZmFpbEFjdGlvbiwgZXJyLCB7IHRhZ3M6IFsncGF5bG9hZCcsICdlcnJvciddIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmRyYWluID0gYXN5bmMgZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIC8vIEZsdXNoIG91dCBhbnkgcGVuZGluZyByZXF1ZXN0IHBheWxvYWQgbm90IGNvbnN1bWVkIGR1ZSB0byBlcnJvcnNcblxuICAgIGF3YWl0IFN0cmVhbXMuZHJhaW4ocmVxdWVzdC5yYXcucmVxKTtcbiAgICByZXF1ZXN0Ll9pc1BheWxvYWRQZW5kaW5nID0gZmFsc2U7XG59O1xuXG5cbmludGVybmFscy5qc29ucFJlZ2V4ID0gL15bXFx3XFwkXFxbXFxdXFwuXSskLztcblxuXG5pbnRlcm5hbHMucGFyc2VKU09OUCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBjb25zdCBqc29ucCA9IHJlcXVlc3QucXVlcnlbcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5qc29ucF07XG4gICAgaWYgKGpzb25wKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbHMuanNvbnBSZWdleC50ZXN0KGpzb25wKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBKU09OUCBwYXJhbWV0ZXIgdmFsdWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuanNvbnAgPSBqc29ucDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5jbGVhbnVwSlNPTlAgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgaWYgKHJlcXVlc3QuanNvbnApIHtcbiAgICAgICAgZGVsZXRlIHJlcXVlc3QucXVlcnlbcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5qc29ucF07XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuY29uZmlnID0gZnVuY3Rpb24gKGNoYWluKSB7XG5cbiAgICBpZiAoIWNoYWluLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgbGV0IGNvbmZpZyA9IGNoYWluWzBdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjaGFpbikge1xuICAgICAgICBjb25maWcgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyhjb25maWcsIGl0ZW0sIHsgc2hhbGxvdzogWydiaW5kJywgJ3ZhbGlkYXRlLmhlYWRlcnMnLCAndmFsaWRhdGUucGF5bG9hZCcsICd2YWxpZGF0ZS5wYXJhbXMnLCAndmFsaWRhdGUucXVlcnknLCAndmFsaWRhdGUuc3RhdGUnXSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZXMgPSBmdW5jdGlvbiAocnVsZXMsIGluZm8sIHNlcnZlcikge1xuXG4gICAgY29uc3QgY29uZmlncyA9IFtdO1xuXG4gICAgbGV0IHJlYWxtID0gc2VydmVyLnJlYWxtO1xuICAgIHdoaWxlIChyZWFsbSkge1xuICAgICAgICBpZiAocmVhbG0uX3J1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSAoIXJlYWxtLl9ydWxlcy5zZXR0aW5ncy52YWxpZGF0ZSA/IHJ1bGVzIDogSm9pLmF0dGVtcHQocnVsZXMsIHJlYWxtLl9ydWxlcy5zZXR0aW5ncy52YWxpZGF0ZS5zY2hlbWEsIHJlYWxtLl9ydWxlcy5zZXR0aW5ncy52YWxpZGF0ZS5vcHRpb25zKSk7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSByZWFsbS5fcnVsZXMucHJvY2Vzc29yKHNvdXJjZSwgaW5mbyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uZmlncy51bnNoaWZ0KGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZWFsbSA9IHJlYWxtLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmZpZyhjb25maWdzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMucm91dGUgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcblxuICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VjdXJpdHkgPSBzZXR0aW5ncztcbiAgICBpZiAoc2VjdXJpdHkuaHN0cykge1xuICAgICAgICBpZiAoc2VjdXJpdHkuaHN0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2VjdXJpdHkuX2hzdHMgPSAnbWF4LWFnZT0xNTc2ODAwMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlY3VyaXR5LmhzdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBzZWN1cml0eS5faHN0cyA9ICdtYXgtYWdlPScgKyBzZWN1cml0eS5oc3RzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VjdXJpdHkuX2hzdHMgPSAnbWF4LWFnZT0nICsgKHNlY3VyaXR5LmhzdHMubWF4QWdlIHx8IDE1NzY4MDAwKTtcbiAgICAgICAgICAgIGlmIChzZWN1cml0eS5oc3RzLmluY2x1ZGVTdWJkb21haW5zIHx8IHNlY3VyaXR5LmhzdHMuaW5jbHVkZVN1YkRvbWFpbnMpIHtcbiAgICAgICAgICAgICAgICBzZWN1cml0eS5faHN0cyA9IHNlY3VyaXR5Ll9oc3RzICsgJzsgaW5jbHVkZVN1YkRvbWFpbnMnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VjdXJpdHkuaHN0cy5wcmVsb2FkKSB7XG4gICAgICAgICAgICAgICAgc2VjdXJpdHkuX2hzdHMgPSBzZWN1cml0eS5faHN0cyArICc7IHByZWxvYWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlY3VyaXR5LnhmcmFtZSkge1xuICAgICAgICBpZiAoc2VjdXJpdHkueGZyYW1lID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzZWN1cml0eS5feGZyYW1lID0gJ0RFTlknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWN1cml0eS54ZnJhbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZWN1cml0eS5feGZyYW1lID0gc2VjdXJpdHkueGZyYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VjdXJpdHkueGZyYW1lLnJ1bGUgPT09ICdhbGxvdy1mcm9tJykge1xuICAgICAgICAgICAgaWYgKCFzZWN1cml0eS54ZnJhbWUuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgc2VjdXJpdHkuX3hmcmFtZSA9ICdTQU1FT1JJR0lOJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlY3VyaXR5Ll94ZnJhbWUgPSAnQUxMT1ctRlJPTSAnICsgc2VjdXJpdHkueGZyYW1lLnNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlY3VyaXR5Ll94ZnJhbWUgPSBzZWN1cml0eS54ZnJhbWUucnVsZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3VyaXR5O1xufTtcblxuXG5leHBvcnRzLmhlYWRlcnMgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSByZXF1ZXN0LnJlc3BvbnNlO1xuICAgIGNvbnN0IHNlY3VyaXR5ID0gcmVzcG9uc2UucmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5zZWN1cml0eTtcblxuICAgIGlmIChzZWN1cml0eS5faHN0cykge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdzdHJpY3QtdHJhbnNwb3J0LXNlY3VyaXR5Jywgc2VjdXJpdHkuX2hzdHMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGlmIChzZWN1cml0eS5feGZyYW1lKSB7XG4gICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ3gtZnJhbWUtb3B0aW9ucycsIHNlY3VyaXR5Ll94ZnJhbWUsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGlmIChzZWN1cml0eS54c3MpIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcigneC14c3MtcHJvdGVjdGlvbicsICcxOyBtb2RlPWJsb2NrJywgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKHNlY3VyaXR5Lm5vT3Blbikge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCd4LWRvd25sb2FkLW9wdGlvbnMnLCAnbm9vcGVuJywgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKHNlY3VyaXR5Lm5vU25pZmYpIHtcbiAgICAgICAgcmVzcG9uc2UuX2hlYWRlcigneC1jb250ZW50LXR5cGUtb3B0aW9ucycsICdub3NuaWZmJywgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKHNlY3VyaXR5LnJlZmVycmVyICE9PSBmYWxzZSkge1xuICAgICAgICByZXNwb25zZS5faGVhZGVyKCdyZWZlcnJlci1wb2xpY3knLCBzZWN1cml0eS5yZWZlcnJlciwgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IEpvaSA9IHJlcXVpcmUoJ0BoYXBpL2pvaScpO1xuY29uc3QgU2hvdCA9IHJlcXVpcmUoJ0BoYXBpL3Nob3QnKTtcbmNvbnN0IFNvbWV2ZXIgPSByZXF1aXJlKCdAaGFwaS9zb21ldmVyJyk7XG5cbmNvbnN0IENvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5jb25zdCBDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5jb25zdCBDb3JzID0gcmVxdWlyZSgnLi9jb3JzJyk7XG5jb25zdCBFeHQgPSByZXF1aXJlKCcuL2V4dCcpO1xuY29uc3QgUGFja2FnZSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3QgUmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xuY29uc3QgUm91dGUgPSByZXF1aXJlKCcuL3JvdXRlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGNvcmUgPSBuZXcgQ29yZShvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IGludGVybmFscy5TZXJ2ZXIoY29yZSk7XG59O1xuXG5cbmludGVybmFscy5TZXJ2ZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb3JlLCBuYW1lLCBwYXJlbnQpIHtcblxuICAgICAgICB0aGlzLl9jb3JlID0gY29yZTtcblxuICAgICAgICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgICAgICAgdGhpcy5hcHAgPSBjb3JlLmFwcDtcbiAgICAgICAgdGhpcy5hdXRoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jb3JlLmF1dGgpO1xuICAgICAgICB0aGlzLmF1dGguc3RyYXRlZ3kgPSB0aGlzLmF1dGguX3N0cmF0ZWd5LmJpbmQodGhpcy5hdXRoLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGNvcmUuZGVjb3JhdGlvbnM7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBpbnRlcm5hbHMuY2FjaGUodGhpcyk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gY29yZS5ldmVudHM7XG4gICAgICAgIHRoaXMuaW5mbyA9IGNvcmUuaW5mbztcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGNvcmUubGlzdGVuZXI7XG4gICAgICAgIHRoaXMubG9hZCA9IGNvcmUuaGVhdnkubG9hZDtcbiAgICAgICAgdGhpcy5tZXRob2RzID0gY29yZS5tZXRob2RzLm1ldGhvZHM7XG4gICAgICAgIHRoaXMubWltZSA9IGNvcmUubWltZTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gY29yZS5wbHVnaW5zO1xuICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvbnMgPSBjb3JlLnJlZ2lzdHJhdGlvbnM7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBjb3JlLnNldHRpbmdzO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IGNvcmUuc3RhdGVzO1xuICAgICAgICB0aGlzLnR5cGUgPSBjb3JlLnR5cGU7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFBhY2thZ2UudmVyc2lvbjtcblxuICAgICAgICB0aGlzLnJlYWxtID0ge1xuICAgICAgICAgICAgX2V4dGVuc2lvbnM6IHtcbiAgICAgICAgICAgICAgICBvblByZUF1dGg6IG5ldyBFeHQoJ29uUHJlQXV0aCcsIGNvcmUpLFxuICAgICAgICAgICAgICAgIG9uQ3JlZGVudGlhbHM6IG5ldyBFeHQoJ29uQ3JlZGVudGlhbHMnLCBjb3JlKSxcbiAgICAgICAgICAgICAgICBvblBvc3RBdXRoOiBuZXcgRXh0KCdvblBvc3RBdXRoJywgY29yZSksXG4gICAgICAgICAgICAgICAgb25QcmVIYW5kbGVyOiBuZXcgRXh0KCdvblByZUhhbmRsZXInLCBjb3JlKSxcbiAgICAgICAgICAgICAgICBvblBvc3RIYW5kbGVyOiBuZXcgRXh0KCdvblBvc3RIYW5kbGVyJywgY29yZSksXG4gICAgICAgICAgICAgICAgb25QcmVSZXNwb25zZTogbmV3IEV4dCgnb25QcmVSZXNwb25zZScsIGNvcmUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgICAgICAgICAgcm91dGU6IHt9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFyZW50OiAocGFyZW50ID8gcGFyZW50LnJlYWxtIDogbnVsbCksXG4gICAgICAgICAgICBwbHVnaW46IG5hbWUsXG4gICAgICAgICAgICBwbHVnaW5PcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgICAgICAgX3J1bGVzOiBudWxsLFxuICAgICAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICAgICAgICBiaW5kOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZmlsZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVUbzogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERlY29yYXRpb25zXG5cbiAgICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgY29yZS5kZWNvcmF0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IGNvcmUuX2RlY29yYXRpb25zLnNlcnZlclttZXRob2RdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29yZS5yZWdpc3RlclNlcnZlcih0aGlzKTtcbiAgICB9XG5cbiAgICBfY2xvbmUobmFtZSkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlNlcnZlcih0aGlzLl9jb3JlLCBuYW1lLCB0aGlzKTtcbiAgICB9XG5cbiAgICBiaW5kKGNvbnRleHQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcsICdiaW5kIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIHRoaXMucmVhbG0uc2V0dGluZ3MuYmluZCA9IGNvbnRleHQ7XG4gICAgfVxuXG4gICAgY29udHJvbChzZXJ2ZXIpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChzZXJ2ZXIgaW5zdGFuY2VvZiBpbnRlcm5hbHMuU2VydmVyLCAnQ2FuIG9ubHkgY29udHJvbCBTZXJ2ZXIgb2JqZWN0cycpO1xuXG4gICAgICAgIHRoaXMuX2NvcmUuY29udHJvbGxlZCA9IHRoaXMuX2NvcmUuY29udHJvbGxlZCB8fCBbXTtcbiAgICAgICAgdGhpcy5fY29yZS5jb250cm9sbGVkLnB1c2goc2VydmVyKTtcbiAgICB9XG5cbiAgICBkZWNvZGVyKGVuY29kaW5nLCBkZWNvZGVyKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUuY29tcHJlc3Npb24uYWRkRGVjb2RlcihlbmNvZGluZywgZGVjb2Rlcik7XG4gICAgfVxuXG4gICAgZGVjb3JhdGUodHlwZSwgcHJvcGVydHksIG1ldGhvZCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodGhpcy5fY29yZS5kZWNvcmF0aW9uc1t0eXBlXSwgJ1Vua25vd24gZGVjb3JhdGlvbiB0eXBlOicsIHR5cGUpO1xuICAgICAgICBIb2VrLmFzc2VydChwcm9wZXJ0eSwgJ01pc3NpbmcgZGVjb3JhdGlvbiBwcm9wZXJ0eSBuYW1lJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BlcnR5ID09PSAnc3ltYm9sJywgJ0RlY29yYXRpb24gcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZyBvciBhIHN5bWJvbCcpO1xuXG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHByb3BlcnR5LnRvU3RyaW5nKCk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHByb3BlcnR5TmFtZVswXSAhPT0gJ18nLCAnUHJvcGVydHkgbmFtZSBjYW5ub3QgYmVnaW4gd2l0aCBhbiB1bmRlcnNjb3JlOicsIHByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLl9jb3JlLl9kZWNvcmF0aW9uc1t0eXBlXVtwcm9wZXJ0eV07XG4gICAgICAgIGlmIChvcHRpb25zLmV4dGVuZCkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZSAhPT0gJ2hhbmRsZXInLCAnQ2Fubm90IGV4dGVudCBoYW5kbGVyIGRlY29yYXRpb246JywgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KGV4aXN0aW5nLCBgQ2Fubm90IGV4dGVuZCBtaXNzaW5nICR7dHlwZX0gZGVjb3JhdGlvbjogJHtwcm9wZXJ0eU5hbWV9YCk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCBgRXh0ZW5kZWQgJHt0eXBlfSBkZWNvcmF0aW9uIG1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb246ICR7cHJvcGVydHlOYW1lfWApO1xuXG4gICAgICAgICAgICBtZXRob2QgPSBtZXRob2QoZXhpc3RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCwgYCR7dHlwZVswXS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zbGljZSgxKX0gZGVjb3JhdGlvbiBhbHJlYWR5IGRlZmluZWQ6ICR7cHJvcGVydHlOYW1lfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdoYW5kbGVyJykge1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVyXG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicsICdIYW5kbGVyIG11c3QgYmUgYSBmdW5jdGlvbjonLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIW1ldGhvZC5kZWZhdWx0cyB8fCB0eXBlb2YgbWV0aG9kLmRlZmF1bHRzID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbWV0aG9kLmRlZmF1bHRzID09PSAnZnVuY3Rpb24nLCAnSGFuZGxlciBkZWZhdWx0cyBwcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdCBvciBmdW5jdGlvbicpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuZXh0ZW5kLCAnQ2Fubm90IGV4dGVuZCBoYW5kbGVyIGRlY29yYXRpb246JywgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAncmVxdWVzdCcpIHtcblxuICAgICAgICAgICAgLy8gUmVxdWVzdFxuXG4gICAgICAgICAgICBIb2VrLmFzc2VydChSZXF1ZXN0LnJlc2VydmVkLmluZGV4T2YocHJvcGVydHkpID09PSAtMSwgJ0Nhbm5vdCBvdmVycmlkZSBidWlsdC1pbiByZXF1ZXN0IGludGVyZmFjZSBkZWNvcmF0aW9uOicsIHByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29yZS5fZGVjb3JhdGlvbnMucmVxdWVzdEFwcGx5ID0gdGhpcy5fY29yZS5fZGVjb3JhdGlvbnMucmVxdWVzdEFwcGx5IHx8IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvcmUuX2RlY29yYXRpb25zLnJlcXVlc3RBcHBseVtwcm9wZXJ0eV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLlJlcXVlc3QucHJvdG90eXBlW3Byb3BlcnR5XSA9IG1ldGhvZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAndG9vbGtpdCcpIHtcblxuICAgICAgICAgICAgLy8gVG9vbGtpdFxuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0aGlzLl9jb3JlLnRvb2xraXQucmVzZXJ2ZWQuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xLCAnQ2Fubm90IG92ZXJyaWRlIGJ1aWx0LWluIHRvb2xraXQgZGVjb3JhdGlvbjonLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBTZXJ2ZXJcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnRlcm5hbHMuU2VydmVyLnByb3RvdHlwZSkuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xLCAnQ2Fubm90IG92ZXJyaWRlIHRoZSBidWlsdC1pbiBzZXJ2ZXIgaW50ZXJmYWNlIG1ldGhvZDonLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhpbnRlcm5hbHMuU2VydmVyLnByb3RvdHlwZSkuaW5kZXhPZihwcm9wZXJ0eSkgPT09IC0xLCAnQ2Fubm90IG92ZXJyaWRlIHRoZSBidWlsdC1pbiBzZXJ2ZXIgaW50ZXJmYWNlIG1ldGhvZDonLCBwcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jb3JlLmluc3RhbmNlcy5mb3JFYWNoKChzZXJ2ZXIpID0+IHtcblxuICAgICAgICAgICAgICAgIHNlcnZlcltwcm9wZXJ0eV0gPSBtZXRob2Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvcmUuX2RlY29yYXRpb25zW3R5cGVdW3Byb3BlcnR5XSA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5fY29yZS5kZWNvcmF0aW9uc1t0eXBlXS5wdXNoKHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICBkZXBlbmRlbmN5KGRlcGVuZGVuY2llcywgYWZ0ZXIpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLnJlYWxtLnBsdWdpbiwgJ0Nhbm5vdCBjYWxsIGRlcGVuZGVuY3koKSBvdXRzaWRlIG9mIGEgcGx1Z2luJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFhZnRlciB8fCB0eXBlb2YgYWZ0ZXIgPT09ICdmdW5jdGlvbicsICdJbnZhbGlkIGFmdGVyIG1ldGhvZCcpO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0byB7IHBsdWdpbjogdmVyc2lvbiB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXBlbmRlbmNpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSB7IFtkZXBlbmRlbmNpZXNdOiAnKicgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXBlbmRlbmN5IG9mIGRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIG1hcFtkZXBlbmRlbmN5XSA9ICcqJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzID0gbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29yZS5kZXBlbmRlbmNpZXMucHVzaCh7IHBsdWdpbjogdGhpcy5yZWFsbS5wbHVnaW4sIGRlcHM6IGRlcGVuZGVuY2llcyB9KTtcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0KCdvblByZVN0YXJ0JywgYWZ0ZXIsIHsgYWZ0ZXI6IE9iamVjdC5rZXlzKGRlcGVuZGVuY2llcykgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmNvZGVyKGVuY29kaW5nLCBlbmNvZGVyKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUuY29tcHJlc3Npb24uYWRkRW5jb2RlcihlbmNvZGluZywgZW5jb2Rlcik7XG4gICAgfVxuXG4gICAgZXZlbnQoZXZlbnQpIHtcblxuICAgICAgICB0aGlzLl9jb3JlLmV2ZW50cy5yZWdpc3RlckV2ZW50KGV2ZW50KTtcbiAgICB9XG5cbiAgICBleHBvc2Uoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHRoaXMucmVhbG0ucGx1Z2luLCAnQ2Fubm90IGNhbGwgZXhwb3NlKCkgb3V0c2lkZSBvZiBhIHBsdWdpbicpO1xuXG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMucmVhbG0ucGx1Z2luO1xuICAgICAgICB0aGlzLl9jb3JlLnBsdWdpbnNbcGx1Z2luXSA9IHRoaXMuX2NvcmUucGx1Z2luc1twbHVnaW5dIHx8IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fY29yZS5wbHVnaW5zW3BsdWdpbl1ba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgSG9lay5tZXJnZSh0aGlzLl9jb3JlLnBsdWdpbnNbcGx1Z2luXSwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4dChldmVudHMsIG1ldGhvZCwgb3B0aW9ucykgeyAgICAgICAgLy8gKGV2ZW50LCBtZXRob2QsIG9wdGlvbnMpIC1PUi0gKGV2ZW50cylcblxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHsgdHlwZTogZXZlbnRzLCBtZXRob2QsIG9wdGlvbnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50cyA9IENvbmZpZy5hcHBseSgnZXh0cycsIGV2ZW50cyk7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9leHQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2V4dChldmVudCkge1xuXG4gICAgICAgIGV2ZW50ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnQpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBldmVudC5yZWFsbSA9IHRoaXMucmVhbG07XG4gICAgICAgIGNvbnN0IHR5cGUgPSBldmVudC50eXBlO1xuXG4gICAgICAgIGlmICghdGhpcy5fY29yZS5leHRlbnNpb25zLnNlcnZlclt0eXBlXSkge1xuXG4gICAgICAgICAgICAvLyBSZWFsbSByb3V0ZSBleHRlbnNpb25zXG5cbiAgICAgICAgICAgIGlmIChldmVudC5vcHRpb25zLnNhbmRib3ggPT09ICdwbHVnaW4nKSB7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodGhpcy5yZWFsbS5fZXh0ZW5zaW9uc1t0eXBlXSwgJ1Vua25vd24gZXZlbnQgdHlwZScsIHR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWxtLl9leHRlbnNpb25zW3R5cGVdLmFkZChldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbm5lY3Rpb24gcm91dGUgZXh0ZW5zaW9uc1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0aGlzLl9jb3JlLmV4dGVuc2lvbnMucm91dGVbdHlwZV0sICdVbmtub3duIGV2ZW50IHR5cGUnLCB0eXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb3JlLmV4dGVuc2lvbnMucm91dGVbdHlwZV0uYWRkKGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlcnZlciBleHRlbnNpb25zXG5cbiAgICAgICAgSG9lay5hc3NlcnQoIWV2ZW50Lm9wdGlvbnMuc2FuZGJveCwgJ0Nhbm5vdCBzcGVjaWZ5IHNhbmRib3ggb3B0aW9uIGZvciBzZXJ2ZXIgZXh0ZW5zaW9uJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGUgIT09ICdvblByZVN0YXJ0JyB8fCB0aGlzLl9jb3JlLnBoYXNlID09PSAnc3RvcHBlZCcsICdDYW5ub3QgYWRkIG9uUHJlU3RhcnQgKGFmdGVyKSBleHRlbnNpb24gYWZ0ZXIgdGhlIHNlcnZlciB3YXMgaW5pdGlhbGl6ZWQnKTtcblxuICAgICAgICBldmVudC5zZXJ2ZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jb3JlLmV4dGVuc2lvbnMuc2VydmVyW3R5cGVdLmFkZChldmVudCk7XG4gICAgfVxuXG4gICAgYXN5bmMgaW5qZWN0KG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgc2V0dGluZ3MgPSBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0dGluZ3MgPSB7IHVybDogc2V0dGluZ3MgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2V0dGluZ3MuYXV0aG9yaXR5IHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5hdXRoIHx8XG4gICAgICAgICAgICBzZXR0aW5ncy5hcHAgfHxcbiAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbnMgfHxcbiAgICAgICAgICAgIHNldHRpbmdzLmFsbG93SW50ZXJuYWxzICE9PSB1bmRlZmluZWQpIHsgICAgICAgIC8vIENhbiBiZSBmYWxzZVxuXG4gICAgICAgICAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTsgICAgICAgICAvLyBvcHRpb25zIGNhbiBiZSByZXVzZWQgKHNoYWxsb3cgY2xvbmVkKVxuICAgICAgICAgICAgZGVsZXRlIHNldHRpbmdzLmF1dGg7XG4gICAgICAgICAgICBkZWxldGUgc2V0dGluZ3MuYXBwO1xuICAgICAgICAgICAgZGVsZXRlIHNldHRpbmdzLnBsdWdpbnM7XG4gICAgICAgICAgICBkZWxldGUgc2V0dGluZ3MuYWxsb3dJbnRlcm5hbHM7XG5cbiAgICAgICAgICAgIHNldHRpbmdzLmF1dGhvcml0eSA9IHNldHRpbmdzLmF1dGhvcml0eSB8fCAodGhpcy5fY29yZS5pbmZvLmhvc3QgKyAnOicgKyB0aGlzLl9jb3JlLmluZm8ucG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5jcmVkZW50aWFscywgJ29wdGlvbnMuY3JlZGVudGlhbHMgbm8gbG9uZ2VyIHN1cHBvcnRlZCAodXNlIG9wdGlvbnMuYXV0aCknKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdXRoKSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Ygb3B0aW9ucy5hdXRoID09PSAnb2JqZWN0JywgJ29wdGlvbnMuYXV0aCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy5hdXRoLmNyZWRlbnRpYWxzLCAnb3B0aW9ucy5hdXRoLmNyZWRlbnRpYWxzIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMuYXV0aC5zdHJhdGVneSwgJ29wdGlvbnMuYXV0aC5zdHJhdGVneSBpcyBtaXNzaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZWVkbGUgPSB0aGlzLl9jb3JlLl9kaXNwYXRjaCh7XG4gICAgICAgICAgICBhdXRoOiBvcHRpb25zLmF1dGgsXG4gICAgICAgICAgICBhbGxvd0ludGVybmFsczogb3B0aW9ucy5hbGxvd0ludGVybmFscyxcbiAgICAgICAgICAgIGFwcDogb3B0aW9ucy5hcHAsXG4gICAgICAgICAgICBwbHVnaW5zOiBvcHRpb25zLnBsdWdpbnNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgU2hvdC5pbmplY3QobmVlZGxlLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IHJlcy5yYXcucmVzW0NvbmZpZy5zeW1ib2xdO1xuICAgICAgICBpZiAoY3VzdG9tKSB7XG4gICAgICAgICAgICByZXMucmVzdWx0ID0gY3VzdG9tLnJlc3VsdDtcbiAgICAgICAgICAgIHJlcy5yZXF1ZXN0ID0gY3VzdG9tLnJlcXVlc3Q7XG4gICAgICAgICAgICBkZWxldGUgcmVzLnJhdy5yZXNbQ29uZmlnLnN5bWJvbF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzLnJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMucmVzdWx0ID0gcmVzLnBheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGxvZyh0YWdzLCBkYXRhKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUubG9nKHRhZ3MsIGRhdGEpO1xuICAgIH1cblxuICAgIGxvb2t1cChpZCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGlkICYmIHR5cGVvZiBpZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHJvdXRlIGlkOicsIGlkKTtcblxuICAgICAgICBjb25zdCByZWNvcmQgPSB0aGlzLl9jb3JlLnJvdXRlci5pZHNbaWRdO1xuICAgICAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjb3JkLnJvdXRlLnB1YmxpYztcbiAgICB9XG5cbiAgICBtYXRjaChtZXRob2QsIHBhdGgsIGhvc3QpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChtZXRob2QgJiYgdHlwZW9mIG1ldGhvZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIG1ldGhvZDonLCBtZXRob2QpO1xuICAgICAgICBIb2VrLmFzc2VydChwYXRoICYmIHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyAmJiBwYXRoWzBdID09PSAnLycsICdJbnZhbGlkIHBhdGg6JywgcGF0aCk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFob3N0IHx8IHR5cGVvZiBob3N0ID09PSAnc3RyaW5nJywgJ0ludmFsaWQgaG9zdDonLCBob3N0KTtcblxuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMuX2NvcmUucm91dGVyLnJvdXRlKG1ldGhvZC50b0xvd2VyQ2FzZSgpLCBwYXRoLCBob3N0KTtcbiAgICAgICAgSG9lay5hc3NlcnQobWF0Y2ggIT09IHRoaXMuX2NvcmUucm91dGVyLnNwZWNpYWxzLmJhZFJlcXVlc3QsICdJbnZhbGlkIHBhdGg6JywgcGF0aCk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gdGhpcy5fY29yZS5yb3V0ZXIuc3BlY2lhbHMubm90Rm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoLnJvdXRlLnB1YmxpYztcbiAgICB9XG5cbiAgICBtZXRob2QobmFtZSwgbWV0aG9kLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5tZXRob2RzLmFkZChuYW1lLCBtZXRob2QsIG9wdGlvbnMsIHRoaXMucmVhbG0pO1xuICAgIH1cblxuICAgIHBhdGgocmVsYXRpdmVUbykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHJlbGF0aXZlVG8gJiYgdHlwZW9mIHJlbGF0aXZlVG8gPT09ICdzdHJpbmcnLCAncmVsYXRpdmVUbyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICAgICAgICB0aGlzLnJlYWxtLnNldHRpbmdzLmZpbGVzLnJlbGF0aXZlVG8gPSByZWxhdGl2ZVRvO1xuICAgIH1cblxuICAgIGFzeW5jIHJlZ2lzdGVyKHBsdWdpbnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICh0aGlzLnJlYWxtLm1vZGlmaWVycy5yb3V0ZS5wcmVmaXggfHxcbiAgICAgICAgICAgIHRoaXMucmVhbG0ubW9kaWZpZXJzLnJvdXRlLnZob3N0KSB7XG5cbiAgICAgICAgICAgIG9wdGlvbnMgPSBIb2VrLmNsb25lKG9wdGlvbnMpO1xuICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXMgPSBvcHRpb25zLnJvdXRlcyB8fCB7fTtcblxuICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXMucHJlZml4ID0gKHRoaXMucmVhbG0ubW9kaWZpZXJzLnJvdXRlLnByZWZpeCB8fCAnJykgKyAob3B0aW9ucy5yb3V0ZXMucHJlZml4IHx8ICcnKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvcHRpb25zLnJvdXRlcy52aG9zdCA9IHRoaXMucmVhbG0ubW9kaWZpZXJzLnJvdXRlLnZob3N0IHx8IG9wdGlvbnMucm91dGVzLnZob3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5hcHBseSgncmVnaXN0ZXInLCBvcHRpb25zKTtcblxuICAgICAgICArK3RoaXMuX2NvcmUucmVnaXN0cmluZztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBbXS5jb25jYXQocGx1Z2lucyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKSB7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICB7IHJlZ2lzdGVyLCAuLi5hdHRyaWJ1dGVzIH1cbiAgICAgICAgICAgICAgICAgICAgeyBwbHVnaW46IHsgcmVnaXN0ZXIsIC4uLmF0dHJpYnV0ZXMgfSwgb3B0aW9ucywgb25jZSwgcm91dGVzIH1cbiAgICAgICAgICAgICAgICAgICAgeyBwbHVnaW46IHsgcGx1Z2luOiB7IHJlZ2lzdGVyLCAuLi5hdHRyaWJ1dGVzIH0gfSwgb3B0aW9ucywgb25jZSwgcm91dGVzIH0gICAgICAvLyBSZXF1aXJlZCBtb2R1bGVcbiAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLnBsdWdpbikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luOiBpdGVtXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpdGVtLnBsdWdpbi5yZWdpc3Rlcikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogaXRlbS5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgb25jZTogaXRlbS5vbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVzOiBpdGVtLnJvdXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjogaXRlbS5wbHVnaW4ucGx1Z2luXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTsgICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl0ZW0gPSBDb25maWcuYXBwbHkoJ3BsdWdpbicsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ucGx1Z2luLm5hbWUgfHwgaXRlbS5wbHVnaW4ucGtnLm5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvbmUgPSB0aGlzLl9jbG9uZShuYW1lKTtcblxuICAgICAgICAgICAgICAgIGNsb25lLnJlYWxtLm1vZGlmaWVycy5yb3V0ZS5wcmVmaXggPSBpdGVtLnJvdXRlcy5wcmVmaXggfHwgb3B0aW9ucy5yb3V0ZXMucHJlZml4O1xuICAgICAgICAgICAgICAgIGNsb25lLnJlYWxtLm1vZGlmaWVycy5yb3V0ZS52aG9zdCA9IGl0ZW0ucm91dGVzLnZob3N0IHx8IG9wdGlvbnMucm91dGVzLnZob3N0O1xuICAgICAgICAgICAgICAgIGNsb25lLnJlYWxtLnBsdWdpbk9wdGlvbnMgPSBpdGVtLm9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlbWVudHNcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVtZW50cyA9IGl0ZW0ucGx1Z2luLnJlcXVpcmVtZW50cztcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCghcmVxdWlyZW1lbnRzLm5vZGUgfHwgU29tZXZlci5tYXRjaChwcm9jZXNzLnZlcnNpb24sIHJlcXVpcmVtZW50cy5ub2RlKSwgJ1BsdWdpbicsIG5hbWUsICdyZXF1aXJlcyBub2RlIHZlcnNpb24nLCByZXF1aXJlbWVudHMubm9kZSwgJ2J1dCBmb3VuZCcsIHByb2Nlc3MudmVyc2lvbik7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoIXJlcXVpcmVtZW50cy5oYXBpIHx8IFNvbWV2ZXIubWF0Y2godGhpcy52ZXJzaW9uLCByZXF1aXJlbWVudHMuaGFwaSksICdQbHVnaW4nLCBuYW1lLCAncmVxdWlyZXMgaGFwaSB2ZXJzaW9uJywgcmVxdWlyZW1lbnRzLmhhcGksICdidXQgZm91bmQnLCB0aGlzLnZlcnNpb24pO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG11bHRpcGxlIHJlZ2lzdHJhdGlvbnNcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb3JlLnJlZ2lzdHJhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucGx1Z2luLm9uY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub25jZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoaXRlbS5wbHVnaW4ubXVsdGlwbGUsICdQbHVnaW4nLCBuYW1lLCAnYWxyZWFkeSByZWdpc3RlcmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb3JlLnJlZ2lzdHJhdGlvbnNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBpdGVtLnBsdWdpbi52ZXJzaW9uIHx8IGl0ZW0ucGx1Z2luLnBrZy52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IGl0ZW0ub3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnBsdWdpbi5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUuZGVwZW5kZW5jeShpdGVtLnBsdWdpbi5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlZ2lzdGVyXG5cbiAgICAgICAgICAgICAgICBhd2FpdCBpdGVtLnBsdWdpbi5yZWdpc3RlcihjbG9uZSwgaXRlbS5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAtLXRoaXMuX2NvcmUucmVnaXN0cmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJvdXRlKG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJvdXRlIG9wdGlvbnMnKTtcblxuICAgICAgICBvcHRpb25zID0gW10uY29uY2F0KG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcubWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGNvbmZpZy5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpOyAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRSb3V0ZShzZXR0aW5ncywgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkUm91dGUoY29uZmlnLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hZGRSb3V0ZShjb25maWcsIHNlcnZlcikge1xuXG4gICAgICAgIGNvbnN0IHJvdXRlID0gbmV3IFJvdXRlKGNvbmZpZywgc2VydmVyKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBubyB1c2UgY29uZmlnIGJleW9uZCB0aGlzIHBvaW50LCB1c2Ugcm91dGUgbWVtYmVyc1xuICAgICAgICBjb25zdCB2aG9zdHMgPSBbXS5jb25jYXQocm91dGUuc2V0dGluZ3Mudmhvc3QgfHwgJyonKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHZob3N0IG9mIHZob3N0cykge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fY29yZS5yb3V0ZXIuYWRkKHsgbWV0aG9kOiByb3V0ZS5tZXRob2QsIHBhdGg6IHJvdXRlLnBhdGgsIHZob3N0LCBhbmFseXNpczogcm91dGUuX2FuYWx5c2lzLCBpZDogcm91dGUuc2V0dGluZ3MuaWQgfSwgcm91dGUpO1xuICAgICAgICAgICAgcm91dGUuZmluZ2VycHJpbnQgPSByZWNvcmQuZmluZ2VycHJpbnQ7XG4gICAgICAgICAgICByb3V0ZS5wYXJhbXMgPSByZWNvcmQucGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgncm91dGUnLCByb3V0ZS5wdWJsaWMpO1xuICAgICAgICBDb3JzLm9wdGlvbnMocm91dGUucHVibGljLCBzZXJ2ZXIpO1xuICAgIH1cblxuICAgIHJ1bGVzKHByb2Nlc3Nvciwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIXRoaXMucmVhbG0uX3J1bGVzLCAnU2VydmVyIHJlYWxtIHJ1bGVzIGFscmVhZHkgZGVmaW5lZCcpO1xuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gQ29uZmlnLmFwcGx5KCdydWxlcycsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoc2V0dGluZ3MudmFsaWRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHNldHRpbmdzLnZhbGlkYXRlLnNjaGVtYTtcbiAgICAgICAgICAgIHNldHRpbmdzLnZhbGlkYXRlLnNjaGVtYSA9IEpvaS5jb21waWxlKHNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlYWxtLl9ydWxlcyA9IHsgcHJvY2Vzc29yLCBzZXR0aW5ncyB9O1xuICAgIH1cblxuICAgIHN0YXRlKG5hbWUsIG9wdGlvbnMpIHtcblxuICAgICAgICB0aGlzLnN0YXRlcy5hZGQobmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGFibGUoaG9zdCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLnJvdXRlci50YWJsZShob3N0KTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5fc3RhcnQoKTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9jb3JlLl9pbml0aWFsaXplKCk7XG4gICAgfVxuXG4gICAgc3RvcChvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvcmUuX3N0b3Aob3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuY2FjaGUgPSAocGx1Z2luKSA9PiB7XG5cbiAgICBjb25zdCBwb2xpY3kgPSBmdW5jdGlvbiAob3B0aW9ucywgX3NlZ21lbnQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY29yZS5fY2FjaGVQb2xpY3kob3B0aW9ucywgX3NlZ21lbnQsIHBsdWdpbi5yZWFsbSk7XG4gICAgfTtcblxuICAgIHBvbGljeS5wcm92aXNpb24gPSBhc3luYyAob3B0cykgPT4ge1xuXG4gICAgICAgIGNvbnN0IGNsaWVudHMgPSBwbHVnaW4uX2NvcmUuX2NyZWF0ZUNhY2hlKG9wdHMpO1xuXG4gICAgICAgIC8vIFN0YXJ0IGNhY2hlXG5cbiAgICAgICAgaWYgKFsnaW5pdGlhbGl6ZWQnLCAnc3RhcnRpbmcnLCAnc3RhcnRlZCddLmluZGV4T2YocGx1Z2luLl9jb3JlLnBoYXNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGNsaWVudHMubWFwKChjbGllbnQpID0+IGNsaWVudC5zdGFydCgpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHBvbGljeTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFRlYW13b3JrID0gcmVxdWlyZSgnQGhhcGkvdGVhbXdvcmsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdGVhbTogU3ltYm9sKCd0ZWFtJylcbn07XG5cblxuZXhwb3J0cy5pc1N0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcblxuICAgIHJldHVybiBzdHJlYW0gJiZcbiAgICAgICAgdHlwZW9mIHN0cmVhbSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIHN0cmVhbS5waXBlID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG5leHBvcnRzLmRyYWluID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuXG4gICAgY29uc3QgdGVhbSA9IG5ldyBUZWFtd29yaygpO1xuICAgIHN0cmVhbVtpbnRlcm5hbHMudGVhbV0gPSB0ZWFtO1xuXG4gICAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGludGVybmFscy5yZWFkKTtcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgaW50ZXJuYWxzLmVuZCk7XG4gICAgc3RyZWFtLm9uKCdlbmQnLCBpbnRlcm5hbHMuZW5kKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgaW50ZXJuYWxzLmVuZCk7XG5cbiAgICByZXR1cm4gdGVhbS53b3JrO1xufTtcblxuXG5pbnRlcm5hbHMucmVhZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHdoaWxlICh0aGlzLnJlYWQoKSkgeyB9XG59O1xuXG5cbmludGVybmFscy5lbmQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdyZWFkYWJsZScsIGludGVybmFscy5yZWFkKTtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGludGVybmFscy5lbmQpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGludGVybmFscy5lbmQpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgaW50ZXJuYWxzLmVuZCk7XG5cbiAgICB0aGlzW2ludGVybmFscy50ZWFtXS5hdHRlbmQoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IFJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICByZXNlcnZlZDogWydhYmFuZG9uJywgJ2F1dGhlbnRpY2F0ZWQnLCAnY2xvc2UnLCAnY29udGV4dCcsICdjb250aW51ZScsICdlbnRpdHknLCAncmVkaXJlY3QnLCAncmVhbG0nLCAncmVxdWVzdCcsICdyZXNwb25zZScsICdzdGF0ZScsICd1bmF1dGhlbnRpY2F0ZWQnLCAndW5zdGF0ZSddXG59O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5NYW5hZ2VyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgdGhpcy5hYmFuZG9uID0gU3ltYm9sKCdhYmFuZG9uJyk7XG4gICAgICAgIHRoaXMuY2xvc2UgPSBTeW1ib2woJ2Nsb3NlJyk7XG4gICAgICAgIHRoaXMuY29udGludWUgPSBTeW1ib2woJ2NvbnRpbnVlJyk7XG4gICAgICAgIHRoaXMucmVzZXJ2ZWQgPSBpbnRlcm5hbHMucmVzZXJ2ZWQ7XG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZShtZXRob2QsIHJlcXVlc3QsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCBoID0gbmV3IGludGVybmFscy5Ub29sa2l0KHJlcXVlc3QsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBiaW5kID0gb3B0aW9ucy5iaW5kIHx8IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBvcGVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChiaW5kKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbWV0aG9kLmNhbGwoYmluZCwgcmVxdWVzdCwgaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG1ldGhvZChyZXF1ZXN0LCBoLCAuLi5vcHRpb25zLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gbWV0aG9kKHJlcXVlc3QsIGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gYXdhaXQgaW50ZXJuYWxzLk1hbmFnZXIudGltZWQob3BlcmF0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoQm91bmNlLmlzU3lzdGVtKGVycikpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEJvb20uYmFkSW1wbGVtZW50YXRpb24oZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFCb3VuY2UuaXNFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdDYW5ub3QgdGhyb3cgbm9uLWVycm9yIG9iamVjdCcsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IEJvb20uYm9vbWlmeShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJvY2VzcyByZXNwb25zZVxuXG4gICAgICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IEJvb20uYmFkSW1wbGVtZW50YXRpb24oYCR7bWV0aG9kLm5hbWV9IG1ldGhvZCBkaWQgbm90IHJldHVybiBhIHZhbHVlLCBhIHByb21pc2UsIG9yIHRocm93IGFuIGVycm9yYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5jb250aW51ZSAmJlxuICAgICAgICAgICAgcmVzcG9uc2UgPT09IHRoaXMuY29udGludWUpIHtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29udGludWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAnbnVsbCdcblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0aCAmJlxuICAgICAgICAgICAgcmVzcG9uc2UgaW5zdGFuY2VvZiBpbnRlcm5hbHMuQXV0aCkge1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlICE9PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBSZXNwb25zZS53cmFwKHJlc3BvbnNlLCByZXF1ZXN0KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UuaXNCb29tKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5fcHJlcGFyZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGZhaWxBY3Rpb24ocmVxdWVzdCwgZmFpbEFjdGlvbiwgZXJyLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcmV0YWluID0gb3B0aW9ucy5yZXRhaW4gPyBlcnIgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChmYWlsQWN0aW9uID09PSAnaWdub3JlJykge1xuICAgICAgICAgICAgcmV0dXJuIHJldGFpbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmYWlsQWN0aW9uID09PSAnbG9nJykge1xuICAgICAgICAgICAgcmVxdWVzdC5fbG9nKG9wdGlvbnMudGFncywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiByZXRhaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmFpbEFjdGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZShmYWlsQWN0aW9uLCByZXF1ZXN0LCB7IHJlYWxtOiByZXF1ZXN0LnJvdXRlLnJlYWxtLCBhcmdzOiBbb3B0aW9ucy5kZXRhaWxzIHx8IGVycl0gfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHRpbWVkKG1ldGhvZCwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmICghb3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGltZXIgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZWplY3QoQm9vbS5pbnRlcm5hbChgJHtvcHRpb25zLm5hbWV9IHRpbWVkIG91dGApKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoaGFuZGxlciwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbdGltZXIsIG1ldGhvZF0pO1xuICAgIH1cbn07XG5cblxuLypcbiAgICBjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24gKHJlcXVlc3QsIGgpIHtcblxuICAgICAgICByZXN1bHQgLyBoLnJlc3BvbnNlKHJlc3VsdCkgICAgICAgICAtPiByZXN1bHQgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWxsb3dlZCBiZWZvcmUgaGFuZGxlclxuICAgICAgICBoLnJlc3BvbnNlKHJlc3VsdCkudGFrZW92ZXIoKSAgICAgICAtPiByZXN1bHQgKHJlc3BvbmQpXG4gICAgICAgIGguY29udGludWUgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IG51bGwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIG51bGwgb25seSBpbiBoYW5kbGVyIGFuZCBwcmUsIG5vdCBhbGxvd2VkIGluIGF1dGhcblxuICAgICAgICB0aHJvdyBlcnJvciAvIGgucmVzcG9uc2UoZXJyb3IpICAgICAtPiBlcnJvciAocmVzcG9uZCkgICAgICAgICAgICAgICAgICAvLyBmYWlsQWN0aW9uIG92ZXJyaWRlIGluIHByZVxuICAgICAgICA8dW5kZWZpbmVkPiAgICAgICAgICAgICAgICAgICAgICAgICAtPiBiYWRJbXBsZW1lbnRhdGlvbiAocmVzcG9uZClcblxuICAgICAgICAvLyBBdXRoIG9ubHkgKHNjaGVtZS5wYXlsb2FkIGFuZCBzY2hlbWUucmVzcG9uc2UgdXNlIHRoZSBzYW1lIGludGVyZmFjZSBhcyBwcmUtaGFuZGxlciBleHRlbnNpb24gbWV0aG9kcylcblxuICAgICAgICBoLnVuYXV0aGVudGljYXRlZChlcnJvciwgZGF0YSkgICAgICAtPiBlcnJvciAocmVzcG9uZCkgKyBkYXRhXG4gICAgICAgIGguYXV0aGVudGljYXRlZChkYXRhICkgICAgICAgICAgICAgIC0+IChjb250aW51ZSkgKyBkYXRhXG4gICAgfTtcbiovXG5cbmludGVybmFscy5Ub29sa2l0ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IocmVxdWVzdCwgbWFuYWdlciwgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuYWJhbmRvbiA9IG1hbmFnZXIuYWJhbmRvbjtcbiAgICAgICAgdGhpcy5jbG9zZSA9IG1hbmFnZXIuY2xvc2U7XG4gICAgICAgIHRoaXMuY29udGludWUgPSBtYW5hZ2VyLmNvbnRpbnVlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBvcHRpb25zLmJpbmQ7XG4gICAgICAgIHRoaXMucmVhbG0gPSBvcHRpb25zLnJlYWxtO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuXG4gICAgICAgIGlmIChvcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGludGVybmFscy5hdXRoZW50aWNhdGVkO1xuICAgICAgICAgICAgdGhpcy51bmF1dGhlbnRpY2F0ZWQgPSBpbnRlcm5hbHMudW5hdXRoZW50aWNhdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgcmVxdWVzdC5fY29yZS5kZWNvcmF0aW9ucy50b29sa2l0KSB7XG4gICAgICAgICAgICB0aGlzW21ldGhvZF0gPSByZXF1ZXN0Ll9jb3JlLl9kZWNvcmF0aW9ucy50b29sa2l0W21ldGhvZF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNwb25zZShyZXN1bHQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCghcmVzdWx0IHx8IHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXN1bHQudGhlbiAhPT0gJ2Z1bmN0aW9uJywgJ0Nhbm5vdCB3cmFwIGEgcHJvbWlzZScpO1xuICAgICAgICBIb2VrLmFzc2VydChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvciA9PT0gZmFsc2UsICdDYW5ub3Qgd3JhcCBhbiBlcnJvcicpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgcmVzdWx0ICE9PSAnc3ltYm9sJywgJ0Nhbm5vdCB3cmFwIGEgc3ltYm9sJyk7XG5cbiAgICAgICAgcmV0dXJuIFJlc3BvbnNlLndyYXAocmVzdWx0LCB0aGlzLnJlcXVlc3QpO1xuICAgIH1cblxuICAgIHJlZGlyZWN0KGxvY2F0aW9uKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2UoJycpLnJlZGlyZWN0KGxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICBlbnRpdHkob3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMsICdFbnRpdHkgbWV0aG9kIG1pc3NpbmcgcmVxdWlyZWQgb3B0aW9ucycpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmV0YWcgfHwgb3B0aW9ucy5tb2RpZmllZCwgJ0VudGl0eSBtZXRob2RzIG1pc3NpbmcgcmVxdWlyZWQgb3B0aW9ucyBrZXknKTtcblxuICAgICAgICB0aGlzLnJlcXVlc3QuX2VudGl0eSA9IG9wdGlvbnM7XG5cbiAgICAgICAgY29uc3QgZW50aXR5ID0gUmVzcG9uc2UuZW50aXR5KG9wdGlvbnMuZXRhZywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChSZXNwb25zZS51bm1vZGlmaWVkKHRoaXMucmVxdWVzdCwgZW50aXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2UoKS5jb2RlKDMwNCkudGFrZW92ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0Ll9zZXRTdGF0ZShuYW1lLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdW5zdGF0ZShuYW1lLCBvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5yZXF1ZXN0Ll9jbGVhclN0YXRlKG5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmF1dGhlbnRpY2F0ZWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgSG9lay5hc3NlcnQoZGF0YSAmJiBkYXRhLmNyZWRlbnRpYWxzLCAnQXV0aGVudGljYXRpb24gZGF0YSBtaXNzaW5nIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uJyk7XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5BdXRoKG51bGwsIGRhdGEpO1xufTtcblxuXG5pbnRlcm5hbHMudW5hdXRoZW50aWNhdGVkID0gZnVuY3Rpb24gKGVycm9yLCBkYXRhKSB7XG5cbiAgICBIb2VrLmFzc2VydCghZGF0YSB8fCBkYXRhLmNyZWRlbnRpYWxzLCAnQXV0aGVudGljYXRpb24gZGF0YSBtaXNzaW5nIGNyZWRlbnRpYWxzIGluZm9ybWF0aW9uJyk7XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5BdXRoKGVycm9yLCBkYXRhKTtcbn07XG5cblxuaW50ZXJuYWxzLkF1dGggPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihlcnJvciwgZGF0YSkge1xuXG4gICAgICAgIHRoaXMuaXNBdXRoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5cbmNvbnN0IEFtbW8gPSByZXF1aXJlKCdAaGFwaS9hbW1vJyk7XG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgU2hvdCA9IHJlcXVpcmUoJ0BoYXBpL3Nob3QnKTtcbmNvbnN0IFRlYW13b3JrID0gcmVxdWlyZSgnQGhhcGkvdGVhbXdvcmsnKTtcblxuY29uc3QgQ29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbmNvbnN0IFJlc3BvbnNlID0gcmVxdWlyZSgnLi9yZXNwb25zZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuc2VuZCA9IGFzeW5jIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG5cbiAgICB0cnkge1xuICAgICAgICBpZiAocmVzcG9uc2UuaXNCb29tKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnRlcm5hbHMuZmFpbChyZXF1ZXN0LCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBpbnRlcm5hbHMubWFyc2hhbChyZXF1ZXN0KTtcbiAgICAgICAgYXdhaXQgaW50ZXJuYWxzLnRyYW5zbWl0KHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgcmVxdWVzdC5fc2V0UmVzcG9uc2UoZXJyKTtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5mYWlsKHJlcXVlc3QsIGVycik7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMubWFyc2hhbCA9IGFzeW5jIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBmb3IgKGNvbnN0IGZ1bmMgb2YgcmVxdWVzdC5fcm91dGUuX21hcnNoYWxDeWNsZSkge1xuICAgICAgICBhd2FpdCBmdW5jKHJlcXVlc3QpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZhaWwgPSBhc3luYyBmdW5jdGlvbiAocmVxdWVzdCwgYm9vbSkge1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBpbnRlcm5hbHMuZXJyb3IocmVxdWVzdCwgYm9vbSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZSA9IHJlc3BvbnNlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IHVzaW5nIHJlcXVlc3QuX3NldFJlc3BvbnNlKCkgdG8gYXZvaWQgZG91YmxlIGxvZ1xuXG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgaW50ZXJuYWxzLm1hcnNoYWwocmVxdWVzdCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG5cbiAgICAgICAgLy8gRmFpbGVkIHRvIG1hcnNoYWwgYW4gZXJyb3IgLSByZXBsYWNlIHdpdGggbWluaW1hbCByZXByZXNlbnRhdGlvbiBvZiBvcmlnaW5hbCBlcnJvclxuXG4gICAgICAgIGNvbnN0IG1pbmltYWwgPSB7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgZXJyb3I6IEh0dHAuU1RBVFVTX0NPREVTW3Jlc3BvbnNlLnN0YXR1c0NvZGVdLFxuICAgICAgICAgICAgbWVzc2FnZTogYm9vbS5tZXNzYWdlXG4gICAgICAgIH07XG5cbiAgICAgICAgcmVzcG9uc2UuX3BheWxvYWQgPSBuZXcgUmVzcG9uc2UuUGF5bG9hZChKU09OLnN0cmluZ2lmeShtaW5pbWFsKSwge30pO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMudHJhbnNtaXQocmVzcG9uc2UpO1xufTtcblxuXG5pbnRlcm5hbHMuZXJyb3IgPSBmdW5jdGlvbiAocmVxdWVzdCwgYm9vbSkge1xuXG4gICAgY29uc3QgZXJyb3IgPSBib29tLm91dHB1dDtcbiAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZShlcnJvci5wYXlsb2FkLCByZXF1ZXN0KTtcbiAgICByZXNwb25zZS5fZXJyb3IgPSBib29tO1xuICAgIHJlc3BvbnNlLmNvZGUoZXJyb3Iuc3RhdHVzQ29kZSk7XG4gICAgcmVzcG9uc2UuaGVhZGVycyA9IEhvZWsuY2xvbmUoZXJyb3IuaGVhZGVycyk7ICAgICAgICAgICAgICAgLy8gUHJldmVudCBzb3VyY2UgZnJvbSBiZWluZyBtb2RpZmllZFxuICAgIHJldHVybiByZXNwb25zZTtcbn07XG5cblxuaW50ZXJuYWxzLnRyYW5zbWl0ID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gcmVzcG9uc2UucmVxdWVzdDtcbiAgICBjb25zdCBsZW5ndGggPSBpbnRlcm5hbHMubGVuZ3RoKHJlc3BvbnNlKTtcblxuICAgIC8vIFBpcGVzXG5cbiAgICBjb25zdCBlbmNvZGluZyA9IHJlcXVlc3QuX2NvcmUuY29tcHJlc3Npb24uZW5jb2RpbmcocmVzcG9uc2UsIGxlbmd0aCk7XG4gICAgY29uc3QgcmFuZ2VyID0gZW5jb2RpbmcgPyBudWxsIDogaW50ZXJuYWxzLnJhbmdlKHJlc3BvbnNlLCBsZW5ndGgpO1xuICAgIGNvbnN0IGNvbXByZXNzb3IgPSBpbnRlcm5hbHMuZW5jb2RpbmcocmVzcG9uc2UsIGVuY29kaW5nKTtcblxuICAgIC8vIENvbm5lY3Rpb246IGNsb3NlXG5cbiAgICBjb25zdCBpc0luamVjdGlvbiA9IFNob3QuaXNJbmplY3Rpb24ocmVxdWVzdC5yYXcucmVxKTtcbiAgICBpZiAoIShpc0luamVjdGlvbiB8fCByZXF1ZXN0Ll9jb3JlLnN0YXJ0ZWQpIHx8XG4gICAgICAgIHJlcXVlc3QuX2lzUGF5bG9hZFBlbmRpbmcgJiYgIXJlcXVlc3QucmF3LnJlcS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkge1xuXG4gICAgICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2Nvbm5lY3Rpb24nLCAnY2xvc2UnKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBoZWFkZXJzXG5cbiAgICBpbnRlcm5hbHMud3JpdGVIZWFkKHJlc3BvbnNlKTtcblxuICAgIC8vIEluamVjdGlvblxuXG4gICAgaWYgKGlzSW5qZWN0aW9uKSB7XG4gICAgICAgIHJlcXVlc3QucmF3LnJlc1tDb25maWcuc3ltYm9sXSA9IHsgcmVxdWVzdCB9O1xuXG4gICAgICAgIGlmIChyZXNwb25zZS52YXJpZXR5ID09PSAncGxhaW4nKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnJhdy5yZXNbQ29uZmlnLnN5bWJvbF0ucmVzdWx0ID0gcmVzcG9uc2UuX2lzUGF5bG9hZFN1cHBvcnRlZCgpID8gcmVzcG9uc2Uuc291cmNlIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmFsaXplIHJlc3BvbnNlIHN0cmVhbVxuXG4gICAgY29uc3Qgc3RyZWFtID0gaW50ZXJuYWxzLmNoYWluKFtyZXNwb25zZS5fcGF5bG9hZCwgcmVzcG9uc2UuX3RhcCgpLCBjb21wcmVzc29yLCByYW5nZXJdKTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLnBpcGUocmVxdWVzdCwgc3RyZWFtKTtcbn07XG5cblxuaW50ZXJuYWxzLmxlbmd0aCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuXG4gICAgY29uc3QgcmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3Q7XG5cbiAgICBjb25zdCBoZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgIGlmIChoZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgbGVuZ3RoID0gaGVhZGVyO1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZW5ndGggPSBwYXJzZUludChoZWFkZXIsIDEwKTtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW1wdHkgcmVzcG9uc2VcblxuICAgIGlmIChsZW5ndGggPT09IDAgJiZcbiAgICAgICAgIXJlc3BvbnNlLl9zdGF0dXNDb2RlICYmXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCAmJlxuICAgICAgICByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLmVtcHR5U3RhdHVzQ29kZSA9PT0gMjA0KSB7XG5cbiAgICAgICAgcmVzcG9uc2UuY29kZSgyMDQpO1xuICAgICAgICBkZWxldGUgcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuZ3RoO1xufTtcblxuXG5pbnRlcm5hbHMucmFuZ2UgPSBmdW5jdGlvbiAocmVzcG9uc2UsIGxlbmd0aCkge1xuXG4gICAgY29uc3QgcmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3Q7XG5cbiAgICBpZiAoIWxlbmd0aCB8fFxuICAgICAgICAhcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5yZXNwb25zZS5yYW5nZXMgfHxcbiAgICAgICAgcmVxdWVzdC5tZXRob2QgIT09ICdnZXQnIHx8XG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2FjY2VwdC1yYW5nZXMnLCAnYnl0ZXMnKTtcblxuICAgIGlmICghcmVxdWVzdC5oZWFkZXJzLnJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENoZWNrIElmLVJhbmdlXG5cbiAgICBpZiAocmVxdWVzdC5oZWFkZXJzWydpZi1yYW5nZSddICYmXG4gICAgICAgIHJlcXVlc3QuaGVhZGVyc1snaWYtcmFuZ2UnXSAhPT0gcmVzcG9uc2UuaGVhZGVycy5ldGFnKSB7ICAgICAgICAgICAgLy8gSWdub3JpbmcgbGFzdC1tb2RpZmllZCBkYXRlICh3ZWFrKVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGhlYWRlclxuXG4gICAgY29uc3QgcmFuZ2VzID0gQW1tby5oZWFkZXIocmVxdWVzdC5oZWFkZXJzLnJhbmdlLCBsZW5ndGgpO1xuICAgIGlmICghcmFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gQm9vbS5yYW5nZU5vdFNhdGlzZmlhYmxlKCk7XG4gICAgICAgIGVycm9yLm91dHB1dC5oZWFkZXJzWydjb250ZW50LXJhbmdlJ10gPSAnYnl0ZXMgKi8nICsgbGVuZ3RoO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHRyYW5zZm9ybVxuXG4gICAgaWYgKHJhbmdlcy5sZW5ndGggIT09IDEpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHJlcXVlc3RzIGZvciBtdWx0aXBsZSByYW5nZXNcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbMF07XG4gICAgcmVzcG9uc2UuY29kZSgyMDYpO1xuICAgIHJlc3BvbnNlLmJ5dGVzKHJhbmdlLnRvIC0gcmFuZ2UuZnJvbSArIDEpO1xuICAgIHJlc3BvbnNlLl9oZWFkZXIoJ2NvbnRlbnQtcmFuZ2UnLCAnYnl0ZXMgJyArIHJhbmdlLmZyb20gKyAnLScgKyByYW5nZS50byArICcvJyArIGxlbmd0aCk7XG5cbiAgICByZXR1cm4gbmV3IEFtbW8uU3RyZWFtKHJhbmdlKTtcbn07XG5cblxuaW50ZXJuYWxzLmVuY29kaW5nID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBlbmNvZGluZykge1xuXG4gICAgY29uc3QgcmVxdWVzdCA9IHJlc3BvbnNlLnJlcXVlc3Q7XG5cbiAgICBjb25zdCBoZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gfHwgZW5jb2Rpbmc7XG4gICAgaWYgKGhlYWRlciAmJlxuICAgICAgICByZXNwb25zZS5oZWFkZXJzLmV0YWcgJiZcbiAgICAgICAgcmVzcG9uc2Uuc2V0dGluZ3MudmFyeUV0YWcpIHtcblxuICAgICAgICByZXNwb25zZS5oZWFkZXJzLmV0YWcgPSByZXNwb25zZS5oZWFkZXJzLmV0YWcuc2xpY2UoMCwgLTEpICsgJy0nICsgaGVhZGVyICsgJ1wiJztcbiAgICB9XG5cbiAgICBpZiAoIWVuY29kaW5nIHx8XG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwNiB8fFxuICAgICAgICAhcmVzcG9uc2UuX2lzUGF5bG9hZFN1cHBvcnRlZCgpKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlIHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgcmVzcG9uc2UuX2hlYWRlcignY29udGVudC1lbmNvZGluZycsIGVuY29kaW5nKTtcbiAgICBjb25zdCBjb21wcmVzc29yID0gcmVxdWVzdC5fY29yZS5jb21wcmVzc2lvbi5lbmNvZGVyKHJlcXVlc3QsIGVuY29kaW5nKTtcbiAgICBpZiAocmVzcG9uc2UudmFyaWV0eSA9PT0gJ3N0cmVhbScgJiZcbiAgICAgICAgdHlwZW9mIHJlc3BvbnNlLl9wYXlsb2FkLnNldENvbXByZXNzb3IgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICByZXNwb25zZS5fcGF5bG9hZC5zZXRDb21wcmVzc29yKGNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wcmVzc29yO1xufTtcblxuXG5pbnRlcm5hbHMucGlwZSA9IGZ1bmN0aW9uIChyZXF1ZXN0LCBzdHJlYW0pIHtcblxuICAgIGNvbnN0IHRlYW0gPSBuZXcgVGVhbXdvcmsoKTtcblxuICAgIC8vIFdyaXRlIHBheWxvYWRcblxuICAgIGNvbnN0IGVudiA9IHsgc3RyZWFtLCByZXF1ZXN0LCB0ZWFtIH07XG5cbiAgICBjb25zdCBhYm9ydGVkID0gaW50ZXJuYWxzLmVuZC5iaW5kKG51bGwsIGVudiwgJ2Fib3J0ZWQnKTtcbiAgICBjb25zdCBjbG9zZSA9IGludGVybmFscy5lbmQuYmluZChudWxsLCBlbnYsICdjbG9zZScpO1xuICAgIGNvbnN0IGVuZCA9IGludGVybmFscy5lbmQuYmluZChudWxsLCBlbnYsIG51bGwpO1xuXG4gICAgcmVxdWVzdC5yYXcucmVxLm9uKCdhYm9ydGVkJywgYWJvcnRlZCk7XG4gICAgcmVxdWVzdC5yYXcucmVxLm9uKCdjbG9zZScsIGNsb3NlKTtcblxuICAgIHJlcXVlc3QucmF3LnJlcy5vbignY2xvc2UnLCBjbG9zZSk7XG4gICAgcmVxdWVzdC5yYXcucmVzLm9uKCdlcnJvcicsIGVuZCk7XG4gICAgcmVxdWVzdC5yYXcucmVzLm9uKCdmaW5pc2gnLCBlbmQpO1xuXG4gICAgaWYgKHN0cmVhbS53cml0ZVRvU3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS53cml0ZVRvU3RyZWFtKHJlcXVlc3QucmF3LnJlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZW5kKTtcbiAgICAgICAgc3RyZWFtLnBpcGUocmVxdWVzdC5yYXcucmVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVhbS53b3JrO1xufTtcblxuXG5pbnRlcm5hbHMuZW5kID0gZnVuY3Rpb24gKGVudiwgZXZlbnQsIGVycikge1xuXG4gICAgY29uc3QgeyByZXF1ZXN0LCBzdHJlYW0sIHRlYW0gfSA9IGVudjtcblxuICAgIGlmICghdGVhbSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlZCBpbnN0ZWFkIG9mIGNsZWFuaW5nIHVwIGVtaXR0ZXIgbGlzdGVuZXJzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbnYudGVhbSA9IG51bGw7XG5cbiAgICBpZiAocmVxdWVzdC5yYXcucmVzLmZpbmlzaGVkKSB7XG4gICAgICAgIGlmIChldmVudCAhPT0gJ2Fib3J0ZWQnKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmluZm8ucmVzcG9uZGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlYW0uYXR0ZW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlcXVlc3QucmF3LnJlcy5kZXN0cm95KCk7XG4gICAgICAgIFJlc3BvbnNlLmRyYWluKHN0cmVhbSk7XG4gICAgfVxuXG4gICAgZXJyID0gZXJyIHx8IG5ldyBCb29tKGBSZXF1ZXN0ICR7ZXZlbnR9YCwgeyBzdGF0dXNDb2RlOiByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLmRpc2Nvbm5lY3RTdGF0dXNDb2RlIH0pO1xuICAgIGNvbnN0IGVycm9yID0gaW50ZXJuYWxzLmVycm9yKHJlcXVlc3QsIEJvb20uYm9vbWlmeShlcnIpKTtcbiAgICByZXF1ZXN0Ll9zZXRSZXNwb25zZShlcnJvcik7XG5cbiAgICBpZiAocmVxdWVzdC5yYXcucmVzW0NvbmZpZy5zeW1ib2xdKSB7XG4gICAgICAgIHJlcXVlc3QucmF3LnJlcy5zdGF0dXNDb2RlID0gZXJyb3Iuc3RhdHVzQ29kZTtcbiAgICAgICAgcmVxdWVzdC5yYXcucmVzW0NvbmZpZy5zeW1ib2xdLnJlc3VsdCA9IGVycm9yLnNvdXJjZTsgICAgICAgLy8gRm9yY2UgaW5qZWN0ZWQgcmVzcG9uc2UgdG8gZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgcmVxdWVzdC5fbG9nKFsncmVzcG9uc2UnLCAnZXJyb3InLCBldmVudF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5fbG9nKFsncmVzcG9uc2UnLCAnZXJyb3InXSwgZXJyKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0LnJhdy5yZXMuZW5kKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlcnMgaW5qZWN0aW9uIHByb21pc2UgcmVzb2x2ZVxuICAgIHRlYW0uYXR0ZW5kKCk7XG59O1xuXG5cbmludGVybmFscy53cml0ZUhlYWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIGNvbnN0IHJlcyA9IHJlc3BvbnNlLnJlcXVlc3QucmF3LnJlcztcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmtleXMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IGkgPCBoZWFkZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXNwb25zZS5oZWFkZXJzW2hlYWRlcl07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy5zZXRIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBmb3IgKC0taTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHJlcy5yZW1vdmVIZWFkZXIoaGVhZGVyc1tpXSk7ICAgICAgIC8vIFVuZG8gaGVhZGVyc1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVycik7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLnNldHRpbmdzLm1lc3NhZ2UpIHtcbiAgICAgICAgcmVzLnN0YXR1c01lc3NhZ2UgPSByZXNwb25zZS5zZXR0aW5ncy5tZXNzYWdlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJlcy53cml0ZUhlYWQocmVzcG9uc2Uuc3RhdHVzQ29kZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVycik7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuY2hhaW4gPSBmdW5jdGlvbiAoc291cmNlcykge1xuXG4gICAgbGV0IGZyb20gPSBzb3VyY2VzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0byA9IHNvdXJjZXNbaV07XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgZnJvbS5vbignZXJyb3InLCBpbnRlcm5hbHMuZXJyb3JQaXBlLmJpbmQoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIGZyb20gPSBmcm9tLnBpcGUodG8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb207XG59O1xuXG5cbmludGVybmFscy5lcnJvclBpcGUgPSBmdW5jdGlvbiAodG8sIGVycikge1xuXG4gICAgdG8uZW1pdCgnZXJyb3InLCBlcnIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAocnVsZSkge1xuXG4gICAgLy8gZmFsc2UgLSBub3RoaW5nIGFsbG93ZWRcblxuICAgIGlmIChydWxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gSm9pLm9iamVjdCh7fSkuYWxsb3cobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIGZ1bmN0aW9uXG5cbiAgICBpZiAodHlwZW9mIHJ1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfVxuXG4gICAgLy8gbnVsbCwgdW5kZWZpbmVkLCB0cnVlIC0gYW55dGhpbmcgYWxsb3dlZFxuXG4gICAgaWYgKCFydWxlIHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbHNlIHRlc3RlZCBhYm92ZVxuICAgICAgICBydWxlID09PSB0cnVlKSB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gey4uLn0gLSAuLi4gYWxsb3dlZFxuXG4gICAgaWYgKHR5cGVvZiBydWxlLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH1cblxuICAgIHJldHVybiBKb2kuY29tcGlsZShydWxlKTtcbn07XG5cblxuZXhwb3J0cy5oZWFkZXJzID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuaW5wdXQoJ2hlYWRlcnMnLCByZXF1ZXN0KTtcbn07XG5cblxuZXhwb3J0cy5wYXJhbXMgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXG4gICAgcmV0dXJuIGludGVybmFscy5pbnB1dCgncGFyYW1zJywgcmVxdWVzdCk7XG59O1xuXG5cbmV4cG9ydHMucGF5bG9hZCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdnZXQnIHx8XG4gICAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnaGVhZCcpIHsgICAgICAgICAgICAgICAgLy8gV2hlbiByb3V0ZS5tZXRob2QgaXMgJyonXG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMuaW5wdXQoJ3BheWxvYWQnLCByZXF1ZXN0KTtcbn07XG5cblxuZXhwb3J0cy5xdWVyeSA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmlucHV0KCdxdWVyeScsIHJlcXVlc3QpO1xufTtcblxuXG5leHBvcnRzLnN0YXRlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuaW5wdXQoJ3N0YXRlJywgcmVxdWVzdCk7XG59O1xuXG5cbmludGVybmFscy5pbnB1dCA9IGFzeW5jIGZ1bmN0aW9uIChzb3VyY2UsIHJlcXVlc3QpIHtcblxuICAgIGNvbnN0IGxvY2FsT3B0aW9ucyA9IHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICAgICAgcGFyYW1zOiByZXF1ZXN0LnBhcmFtcyxcbiAgICAgICAgICAgIHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxuICAgICAgICAgICAgcGF5bG9hZDogcmVxdWVzdC5wYXlsb2FkLFxuICAgICAgICAgICAgc3RhdGU6IHJlcXVlc3Quc3RhdGUsXG4gICAgICAgICAgICBhdXRoOiByZXF1ZXN0LmF1dGgsXG4gICAgICAgICAgICBhcHA6IHtcbiAgICAgICAgICAgICAgICByb3V0ZTogcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5hcHAsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdC5hcHBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZWxldGUgbG9jYWxPcHRpb25zLmNvbnRleHRbc291cmNlXTtcbiAgICBIb2VrLm1lcmdlKGxvY2FsT3B0aW9ucywgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy52YWxpZGF0ZS5vcHRpb25zKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MudmFsaWRhdGVbc291cmNlXTtcbiAgICAgICAgY29uc3QgYmluZCA9IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuYmluZDtcblxuICAgICAgICB2YXIgdmFsdWUgPSBhd2FpdCAodHlwZW9mIHNjaGVtYSAhPT0gJ2Z1bmN0aW9uJyA/IGludGVybmFscy52YWxpZGF0ZShyZXF1ZXN0W3NvdXJjZV0sIHNjaGVtYSwgbG9jYWxPcHRpb25zKSA6IHNjaGVtYS5jYWxsKGJpbmQsIHJlcXVlc3Rbc291cmNlXSwgbG9jYWxPcHRpb25zKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB2YXIgdmFsaWRhdGlvbkVycm9yID0gZXJyO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcmVxdWVzdC5vcmlnW3NvdXJjZV0gPSByZXF1ZXN0W3NvdXJjZV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXF1ZXN0W3NvdXJjZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnZhbGlkYXRlLmZhaWxBY3Rpb24gPT09ICdpZ25vcmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIGVycm9yXG5cbiAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSB2YWxpZGF0aW9uRXJyb3IuaXNCb29tID8gdmFsaWRhdGlvbkVycm9yIDogQm9vbS5iYWRSZXF1ZXN0KGBJbnZhbGlkIHJlcXVlc3QgJHtzb3VyY2V9IGlucHV0YCk7XG4gICAgY29uc3QgZGV0YWlsZWRFcnJvciA9IEJvb20uYm9vbWlmeSh2YWxpZGF0aW9uRXJyb3IsIHsgc3RhdHVzQ29kZTogNDAwLCBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgZGV0YWlsZWRFcnJvci5vdXRwdXQucGF5bG9hZC52YWxpZGF0aW9uID0geyBzb3VyY2UsIGtleXM6IFtdIH07XG4gICAgaWYgKHZhbGlkYXRpb25FcnJvci5kZXRhaWxzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGV0YWlscyBvZiB2YWxpZGF0aW9uRXJyb3IuZGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGRldGFpbHMucGF0aDtcbiAgICAgICAgICAgIGRldGFpbGVkRXJyb3Iub3V0cHV0LnBheWxvYWQudmFsaWRhdGlvbi5rZXlzLnB1c2goSG9lay5lc2NhcGVIdG1sKHBhdGguam9pbignLicpKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy52YWxpZGF0ZS5lcnJvckZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIGluIHJlcXVlc3Qucm91dGUuc2V0dGluZ3MudmFsaWRhdGUuZXJyb3JGaWVsZHMpIHtcbiAgICAgICAgICAgIGRldGFpbGVkRXJyb3Iub3V0cHV0LnBheWxvYWRbZmllbGRdID0gcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy52YWxpZGF0ZS5lcnJvckZpZWxkc1tmaWVsZF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdC5fY29yZS50b29sa2l0LmZhaWxBY3Rpb24ocmVxdWVzdCwgcmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy52YWxpZGF0ZS5mYWlsQWN0aW9uLCBkZWZhdWx0RXJyb3IsIHsgZGV0YWlsczogZGV0YWlsZWRFcnJvciwgdGFnczogWyd2YWxpZGF0aW9uJywgJ2Vycm9yJywgc291cmNlXSB9KTtcbn07XG5cblxuZXhwb3J0cy5yZXNwb25zZSA9IGFzeW5jIGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG5cbiAgICBpZiAocmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5yZXNwb25zZS5zYW1wbGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNhbXBsZSA9IE1hdGguY2VpbCgoTWF0aC5yYW5kb20oKSAqIDEwMCkpO1xuICAgICAgICBpZiAoY3VycmVudFNhbXBsZSA+IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MucmVzcG9uc2Uuc2FtcGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlc3BvbnNlLmlzQm9vbSA/IHJlc3BvbnNlLm91dHB1dC5zdGF0dXNDb2RlIDogcmVzcG9uc2Uuc3RhdHVzQ29kZTtcblxuICAgIGNvbnN0IHN0YXR1c1NjaGVtYSA9IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MucmVzcG9uc2Uuc3RhdHVzW3N0YXR1c0NvZGVdO1xuICAgIGlmIChzdGF0dXNDb2RlID49IDQwMCAmJlxuICAgICAgICAhc3RhdHVzU2NoZW1hKSB7XG5cbiAgICAgICAgcmV0dXJuOyAgICAgICAgICAgICAgICAgLy8gRG8gbm90IHZhbGlkYXRlIGVycm9ycyBieSBkZWZhdWx0XG4gICAgfVxuXG4gICAgY29uc3Qgc2NoZW1hID0gc3RhdHVzU2NoZW1hICE9PSB1bmRlZmluZWQgPyBzdGF0dXNTY2hlbWEgOiByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLnNjaGVtYTtcbiAgICBpZiAoc2NoZW1hID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAgIC8vIE5vIHJ1bGVzXG4gICAgfVxuXG4gICAgaWYgKCFyZXNwb25zZS5pc0Jvb20gJiZcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZS52YXJpZXR5ICE9PSAncGxhaW4nKSB7XG5cbiAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignQ2Fubm90IHZhbGlkYXRlIG5vbi1vYmplY3QgcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbE9wdGlvbnMgPSB7XG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgICAgICAgIHBhcmFtczogcmVxdWVzdC5wYXJhbXMsXG4gICAgICAgICAgICBxdWVyeTogcmVxdWVzdC5xdWVyeSxcbiAgICAgICAgICAgIHBheWxvYWQ6IHJlcXVlc3QucGF5bG9hZCxcbiAgICAgICAgICAgIHN0YXRlOiByZXF1ZXN0LnN0YXRlLFxuICAgICAgICAgICAgYXV0aDogcmVxdWVzdC5hdXRoLFxuICAgICAgICAgICAgYXBwOiB7XG4gICAgICAgICAgICAgICAgcm91dGU6IHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuYXBwLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QuYXBwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc291cmNlID0gcmVzcG9uc2UuaXNCb29tID8gcmVzcG9uc2Uub3V0cHV0LnBheWxvYWQgOiByZXNwb25zZS5zb3VyY2U7XG4gICAgSG9lay5tZXJnZShsb2NhbE9wdGlvbnMsIHJlcXVlc3Qucm91dGUuc2V0dGluZ3MucmVzcG9uc2Uub3B0aW9ucyk7XG5cbiAgICB0cnkge1xuICAgICAgICBsZXQgdmFsdWU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXdhaXQgaW50ZXJuYWxzLnZhbGlkYXRlKHNvdXJjZSwgc2NoZW1hLCBsb2NhbE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBhd2FpdCBzY2hlbWEoc291cmNlLCBsb2NhbE9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJlcXVlc3Qucm91dGUuc2V0dGluZ3MucmVzcG9uc2UubW9kaWZ5KSB7XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5pc0Jvb20pIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vdXRwdXQucGF5bG9hZCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc291cmNlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuXG4gICAgICAgIHJldHVybiByZXF1ZXN0Ll9jb3JlLnRvb2xraXQuZmFpbEFjdGlvbihyZXF1ZXN0LCByZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLmZhaWxBY3Rpb24sIGVyciwgeyB0YWdzOiBbJ3ZhbGlkYXRpb24nLCAncmVzcG9uc2UnLCAnZXJyb3InXSB9KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYS52YWxpZGF0ZUFzeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEudmFsaWRhdGVBc3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuc2NoZW1hID0gZnVuY3Rpb24gKEpvaSwgY29uZmlnKSB7XG5cbiAgICBpZiAoY29uZmlnICE9PSB1bmRlZmluZWQgJiYgY29uZmlnICE9PSBudWxsICYmIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pc0pvaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybiBKb2kuYWx0ZXJuYXRpdmVzKCkudHJ5KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gSm9pLnN0cmluZygpLnJlZ2V4KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIEpvaS5kYXRlKCkudmFsaWQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKb2kub2JqZWN0KCkua2V5cyhjb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gSm9pLnN0cmluZygpLnZhbGlkKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBKb2kubnVtYmVyKCkudmFsaWQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBKb2kuYm9vbGVhbigpLnZhbGlkKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKFJlZi5pc1JlZihjb25maWcpKSB7XG4gICAgICAgIHJldHVybiBKb2kudmFsaWQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBIb2VrLmFzc2VydChjb25maWcgPT09IG51bGwsICdJbnZhbGlkIHNjaGVtYSBjb250ZW50OicsIGNvbmZpZyk7XG5cbiAgICByZXR1cm4gSm9pLnZhbGlkKG51bGwpO1xufTtcblxuXG5leHBvcnRzLnJlZiA9IGZ1bmN0aW9uIChpZCkge1xuXG4gICAgcmV0dXJuIFJlZi5pc1JlZihpZCkgPyBpZCA6IFJlZi5jcmVhdGUoaWQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgTGFuZ3VhZ2UgPSByZXF1aXJlKCcuL2xhbmd1YWdlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGFubm90YXRpb25zOiBTeW1ib2woJ2pvaS1hbm5vdGF0aW9ucycpXG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHdyYXBBcnJheXMpIHtcblxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGV4cG9ydHMuRXJyIHx8IHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHBhcnRpYWwgPSAnJztcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWwgPSBwYXJ0aWFsICsgKHBhcnRpYWwubGVuZ3RoID8gJywgJyA6ICcnKSArIGludGVybmFscy5zdHJpbmdpZnkodmFsdWVbaV0sIHdyYXBBcnJheXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gd3JhcEFycmF5cyA/ICdbJyArIHBhcnRpYWwgKyAnXScgOiBwYXJ0aWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy5FcnIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZmxhZ3MsIG1lc3NhZ2UsIHRlbXBsYXRlKSB7XG5cbiAgICAgICAgdGhpcy5pc0pvaSA9IHRydWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwge307XG4gICAgICAgIHRoaXMuY29udGV4dC5rZXkgPSBzdGF0ZS5wYXRoW3N0YXRlLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY29udGV4dC5sYWJlbCA9IHN0YXRlLmtleTtcbiAgICAgICAgdGhpcy5wYXRoID0gc3RhdGUucGF0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cbiAgICAgICAgY29uc3QgbG9jYWxpemVkID0gdGhpcy5vcHRpb25zLmxhbmd1YWdlO1xuXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQubGFiZWwgPSB0aGlzLmZsYWdzLmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvY2FsaXplZCAmJiAgICAgICAgICAgICAgICAgICAvLyBsYW5ndWFnZSBjYW4gYmUgbnVsbCBmb3IgYXJyYXlzIGV4Y2x1c2lvbiBjaGVja1xuICAgICAgICAgICAgKHRoaXMuY29udGV4dC5sYWJlbCA9PT0gJycgfHxcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbCA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5sYWJlbCA9IGxvY2FsaXplZC5yb290IHx8IExhbmd1YWdlLmVycm9ycy5yb290O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3JtYXQ7XG5cbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IHRoaXMudGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSB0aGlzLm9wdGlvbnMubGFuZ3VhZ2U7XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IEhvZWsucmVhY2gobG9jYWxpemVkLCB0aGlzLnR5cGUpIHx8IEhvZWsucmVhY2goTGFuZ3VhZ2UuZXJyb3JzLCB0aGlzLnR5cGUpO1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBjb2RlIFwiJHt0aGlzLnR5cGV9XCIgaXMgbm90IGRlZmluZWQsIHlvdXIgY3VzdG9tIHR5cGUgaXMgbWlzc2luZyB0aGUgY29ycmVjdCBsYW5ndWFnZSBkZWZpbml0aW9uYDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB3cmFwQXJyYXlzID0gSG9lay5yZWFjaChsb2NhbGl6ZWQsICdtZXNzYWdlcy53cmFwQXJyYXlzJyk7XG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcEFycmF5cyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3cmFwQXJyYXlzID0gTGFuZ3VhZ2UuZXJyb3JzLm1lc3NhZ2VzLndyYXBBcnJheXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlblN0cmluZyA9IGludGVybmFscy5zdHJpbmdpZnkodGhpcy5jb250ZXh0LnJlYXNvbiwgd3JhcEFycmF5cyk7XG4gICAgICAgICAgICBpZiAod3JhcEFycmF5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlblN0cmluZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlblN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhc0tleSA9IC97eyE/bGFiZWx9fS8udGVzdChmb3JtYXQpO1xuICAgICAgICBjb25zdCBza2lwS2V5ID0gZm9ybWF0Lmxlbmd0aCA+IDIgJiYgZm9ybWF0WzBdID09PSAnIScgJiYgZm9ybWF0WzFdID09PSAnISc7XG5cbiAgICAgICAgaWYgKHNraXBLZXkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zbGljZSgyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzS2V5ICYmICFza2lwS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWRLZXkgPSBIb2VrLnJlYWNoKGxvY2FsaXplZCwgJ2tleScpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGl6ZWRLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxpemVkS2V5ICsgZm9ybWF0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gSG9lay5yZWFjaChMYW5ndWFnZS5lcnJvcnMsICdrZXknKSArIGZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAgZm9ybWF0LnJlcGxhY2UoL3t7KCE/KShbXn1dKyl9fS9nLCAoJDAsIGlzU2VjdXJlLCBuYW1lKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gSG9lay5yZWFjaCh0aGlzLmNvbnRleHQsIG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGludGVybmFscy5zdHJpbmdpZnkodmFsdWUsIHdyYXBBcnJheXMpO1xuICAgICAgICAgICAgcmV0dXJuIChpc1NlY3VyZSAmJiB0aGlzLm9wdGlvbnMuZXNjYXBlSHRtbCA/IEhvZWsuZXNjYXBlSHRtbChub3JtYWxpemVkKSA6IG5vcm1hbGl6ZWQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRvU3RyaW5nID0gKCkgPT4gbWVzc2FnZTsgIC8vIFBlcnNpc3QgcmVzdWx0IG9mIGxhc3QgdG9TdHJpbmcgY2FsbCwgaXQgd29uJ3QgY2hhbmdlXG5cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG59O1xuXG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHR5cGUsIGNvbnRleHQsIHN0YXRlLCBvcHRpb25zLCBmbGFncywgbWVzc2FnZSwgdGVtcGxhdGUpIHtcblxuICAgIHJldHVybiBuZXcgZXhwb3J0cy5FcnIodHlwZSwgY29udGV4dCwgc3RhdGUsIG9wdGlvbnMsIGZsYWdzLCBtZXNzYWdlLCB0ZW1wbGF0ZSk7XG59O1xuXG5cbmV4cG9ydHMucHJvY2VzcyA9IGZ1bmN0aW9uIChlcnJvcnMsIG9iamVjdCkge1xuXG4gICAgaWYgKCFlcnJvcnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IGVycm9yXG5cbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgIGNvbnN0IGRldGFpbHMgPSBbXTtcblxuICAgIGNvbnN0IHByb2Nlc3NFcnJvcnMgPSBmdW5jdGlvbiAobG9jYWxFcnJvcnMsIHBhcmVudCwgb3ZlcnJpZGVNZXNzYWdlKSB7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbEVycm9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGxvY2FsRXJyb3JzW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpdGVtLmZsYWdzLmVycm9yICYmIHR5cGVvZiBpdGVtLmZsYWdzLmVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmZsYWdzLnNlbGZFcnJvciB8fCAhaXRlbS5jb250ZXh0LnJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5mbGFncy5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpdGVtTWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGl0ZW1NZXNzYWdlID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlICsgKG1lc3NhZ2UgPyAnLiAnIDogJycpICsgaXRlbU1lc3NhZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERvIG5vdCBwdXNoIGludGVybWVkaWF0ZSBlcnJvcnMsIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBsZWFmc1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5jb250ZXh0LnJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlID0gcHJvY2Vzc0Vycm9ycyhpdGVtLmNvbnRleHQucmVhc29uLCBpdGVtLnBhdGgsIGl0ZW0udHlwZSA9PT0gJ292ZXJyaWRlJyA/IGl0ZW0ubWVzc2FnZSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogb3ZlcnJpZGVNZXNzYWdlIHx8IGl0ZW1NZXNzYWdlIHx8IGl0ZW0udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGl0ZW0uY29udGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG92ZXJyaWRlID0gcHJvY2Vzc0Vycm9ycyhlcnJvcnMpO1xuICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuaXNKb2kgPSB0cnVlO1xuICAgIGVycm9yLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcbiAgICBlcnJvci5kZXRhaWxzID0gZGV0YWlscztcbiAgICBlcnJvci5fb2JqZWN0ID0gb2JqZWN0O1xuICAgIGVycm9yLmFubm90YXRlID0gaW50ZXJuYWxzLmFubm90YXRlO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG5cblxuLy8gSW5zcGlyZWQgYnkganNvbi1zdHJpbmdpZnktc2FmZVxuXG5pbnRlcm5hbHMuc2FmZVN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmosIHNwYWNlcykge1xuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgaW50ZXJuYWxzLnNlcmlhbGl6ZXIoKSwgc3BhY2VzKTtcbn07XG5cblxuaW50ZXJuYWxzLnNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICAgIGNvbnN0IGN5Y2xlUmVwbGFjZXIgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuXG4gICAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH5dJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyIH4uJyArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oJy4nKSArICddJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgaWYgKH50aGlzUG9zKSB7XG4gICAgICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gdGhpc1BvcyArIDE7XG4gICAgICAgICAgICAgICAga2V5cy5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzW3RoaXNQb3NdID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY3ljbGVSZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFubm90YXRpb25zID0gdmFsdWVbaW50ZXJuYWxzLmFubm90YXRpb25zXTtcbiAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbm5vdGF0ZWQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ub3RhdGlvbnMuZXJyb3JzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2goYF8kaWR4JF8ke2Fubm90YXRpb25zLmVycm9yc1tpXS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlZC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYW5ub3RhdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JLZXlzID0gT2JqZWN0LmtleXMoYW5ub3RhdGlvbnMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcnJvcktleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yS2V5ID0gZXJyb3JLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYCR7ZXJyb3JLZXl9XyRrZXkkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2Vycm9yS2V5XS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYF0gPSB2YWx1ZVtlcnJvcktleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtlcnJvcktleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nS2V5cyA9IE9iamVjdC5rZXlzKGFubm90YXRpb25zLm1pc3NpbmcpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pc3NpbmdLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nS2V5ID0gbWlzc2luZ0tleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtgXyRtaXNzJF8ke21pc3NpbmdLZXl9fCR7YW5ub3RhdGlvbnMubWlzc2luZ1ttaXNzaW5nS2V5XX1fJGVuZCRfYF0gPSAnX19taXNzaW5nX18nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fCB2YWx1ZSA9PT0gLUluZmluaXR5IHx8IE51bWJlci5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdmFsdWUudG9TdHJpbmcoKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuYW5ub3RhdGUgPSBmdW5jdGlvbiAoc3RyaXBDb2xvckNvZGVzKSB7XG5cbiAgICBjb25zdCByZWRGZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMzFtJztcbiAgICBjb25zdCByZWRCZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbNDFtJztcbiAgICBjb25zdCBlbmRDb2xvciA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMG0nO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRldGFpbHNbMF0ubWVzc2FnZTtcbiAgICB9XG5cbiAgICBjb25zdCBvYmogPSBIb2VrLmNsb25lKHRoaXMuX29iamVjdCB8fCB7fSk7XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5kZXRhaWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7ICAgICAgICAvLyBSZXZlcnNlIG9yZGVyIHRvIHByb2Nlc3MgZGVlcGVzdCBjaGlsZCBmaXJzdFxuICAgICAgICBjb25zdCBwb3MgPSBpICsgMTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmRldGFpbHNbaV07XG4gICAgICAgIGNvbnN0IHBhdGggPSBlcnJvci5wYXRoO1xuICAgICAgICBsZXQgcmVmID0gb2JqO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IHBhdGhbal07XG5cbiAgICAgICAgICAgIGlmIChyZWYuaXNJbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICByZWYgPSByZWYuY2xvbmUoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqb2kgc2NoZW1hcyBhcmUgbm90IGNsb25lZCBieSBob2VrLCB3ZSBoYXZlIHRvIHRha2UgdGhpcyBleHRyYSBzdGVwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqICsgMSA8IHBhdGgubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgcmVmW3NlZ10gJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgcmVmW3NlZ10gIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICByZWYgPSByZWZbc2VnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZkFubm90YXRpb25zID0gcmVmW2ludGVybmFscy5hbm5vdGF0aW9uc10gPSByZWZbaW50ZXJuYWxzLmFubm90YXRpb25zXSB8fCB7IGVycm9yczoge30sIG1pc3Npbmc6IHt9IH07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWZbc2VnXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNlZyB8fCBlcnJvci5jb250ZXh0LmxhYmVsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSA9IHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0ucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMubWlzc2luZ1tjYWNoZUtleV0gPSBwb3M7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByZXBsYWNlcnMgPSB7XG4gICAgICAgIGtleTogL19cXCRrZXlcXCRfKFssIFxcZF0rKV9cXCRlbmRcXCRfXCIvZyxcbiAgICAgICAgbWlzc2luZzogL1wiX1xcJG1pc3NcXCRfKFtefF0rKVxcfChcXGQrKV9cXCRlbmRcXCRfXCI6IFwiX19taXNzaW5nX19cIi9nLFxuICAgICAgICBhcnJheUluZGV4OiAvXFxzKlwiX1xcJGlkeFxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIiw/XFxuKC4qKS9nLFxuICAgICAgICBzcGVjaWFsczogL1wiXFxbKE5hTnxTeW1ib2wuKnwtP0luZmluaXR5fGZ1bmN0aW9uLip8XFwoLiopXVwiL2dcbiAgICB9O1xuXG4gICAgbGV0IG1lc3NhZ2UgPSBpbnRlcm5hbHMuc2FmZVN0cmluZ2lmeShvYmosIDIpXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5rZXksICgkMCwgJDEpID0+IGBcIiAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5taXNzaW5nLCAoJDAsICQxLCAkMikgPT4gYCR7cmVkQmdFc2NhcGV9XCIkeyQxfVwiJHtlbmRDb2xvcn0ke3JlZEZnRXNjYXBlfSBbJHskMn1dOiAtLSBtaXNzaW5nIC0tJHtlbmRDb2xvcn1gKVxuICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuYXJyYXlJbmRleCwgKCQwLCAkMSwgJDIpID0+IGBcXG4keyQyfSAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgIC5yZXBsYWNlKHJlcGxhY2Vycy5zcGVjaWFscywgKCQwLCAkMSkgPT4gJDEpO1xuXG4gICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuJHtyZWRGZ0VzY2FwZX1gO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRldGFpbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcG9zID0gaSArIDE7XG4gICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfVxcblske3Bvc31dICR7dGhpcy5kZXRhaWxzW2ldLm1lc3NhZ2V9YDtcbiAgICB9XG5cbiAgICBtZXNzYWdlID0gbWVzc2FnZSArIGVuZENvbG9yO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL3R5cGVzL2FueScpO1xuY29uc3QgQ2FzdCA9IHJlcXVpcmUoJy4vY2FzdCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IExhenkgPSByZXF1aXJlKCcuL3R5cGVzL2xhenknKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGFsdGVybmF0aXZlczogcmVxdWlyZSgnLi90eXBlcy9hbHRlcm5hdGl2ZXMnKSxcbiAgICBhcnJheTogcmVxdWlyZSgnLi90eXBlcy9hcnJheScpLFxuICAgIGJvb2xlYW46IHJlcXVpcmUoJy4vdHlwZXMvYm9vbGVhbicpLFxuICAgIGJpbmFyeTogcmVxdWlyZSgnLi90eXBlcy9iaW5hcnknKSxcbiAgICBkYXRlOiByZXF1aXJlKCcuL3R5cGVzL2RhdGUnKSxcbiAgICBmdW5jOiByZXF1aXJlKCcuL3R5cGVzL2Z1bmMnKSxcbiAgICBudW1iZXI6IHJlcXVpcmUoJy4vdHlwZXMvbnVtYmVyJyksXG4gICAgb2JqZWN0OiByZXF1aXJlKCcuL3R5cGVzL29iamVjdCcpLFxuICAgIHN0cmluZzogcmVxdWlyZSgnLi90eXBlcy9zdHJpbmcnKSxcbiAgICBzeW1ib2w6IHJlcXVpcmUoJy4vdHlwZXMvc3ltYm9sJylcbn07XG5cblxuaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBhcmdzKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLCAnTXVzdCBiZSBpbnZva2VkIG9uIGEgSm9pIGluc3RhbmNlLicpO1xuXG4gICAgaWYgKHRoaXMuX2RlZmF1bHRzKSB7XG4gICAgICAgIHNjaGVtYSA9IHRoaXMuX2RlZmF1bHRzKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgc2NoZW1hLl9jdXJyZW50Sm9pID0gdGhpcztcblxuICAgIHJldHVybiBzY2hlbWEuX2luaXQoLi4uYXJncyk7XG59O1xuXG5cbmludGVybmFscy5yb290ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3QgYW55ID0gbmV3IEFueSgpO1xuXG4gICAgY29uc3Qgcm9vdCA9IGFueS5jbG9uZSgpO1xuICAgIEFueS5wcm90b3R5cGUuX2N1cnJlbnRKb2kgPSByb290O1xuICAgIHJvb3QuX2N1cnJlbnRKb2kgPSByb290O1xuICAgIHJvb3QuX2JpbmRzID0gbmV3IFNldChbJ2FueScsICdhbHRlcm5hdGl2ZXMnLCAnYWx0JywgJ2FycmF5JywgJ2Jvb2wnLCAnYm9vbGVhbicsICdiaW5hcnknLCAnZGF0ZScsICdmdW5jJywgJ251bWJlcicsICdvYmplY3QnLCAnc3RyaW5nJywgJ3N5bWJvbCcsICd2YWxpZGF0ZScsICdkZXNjcmliZScsICdjb21waWxlJywgJ2Fzc2VydCcsICdhdHRlbXB0JywgJ2xhenknLCAnZGVmYXVsdHMnLCAnZXh0ZW5kJywgJ2FsbG93JywgJ3ZhbGlkJywgJ29ubHknLCAnZXF1YWwnLCAnaW52YWxpZCcsICdkaXNhbGxvdycsICdub3QnLCAncmVxdWlyZWQnLCAnZXhpc3QnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJywgJ3N0cmlwJywgJ3doZW4nLCAnZW1wdHknLCAnZGVmYXVsdCddKTtcblxuICAgIHJvb3QuYW55ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5hbnkoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgYW55LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5hbHRlcm5hdGl2ZXMgPSByb290LmFsdCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLmFsdGVybmF0aXZlcywgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuYXJyYXkgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLmFycmF5KCkgZG9lcyBub3QgYWxsb3cgYXJndW1lbnRzLicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2FsbFdpdGhEZWZhdWx0cy5jYWxsKHRoaXMsIGludGVybmFscy5hcnJheSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuYm9vbGVhbiA9IHJvb3QuYm9vbCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuYm9vbGVhbigpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuYm9vbGVhbiwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuYmluYXJ5ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5iaW5hcnkoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLmJpbmFyeSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuZGF0ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuZGF0ZSgpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuZGF0ZSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuZnVuYyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJncy5sZW5ndGggPT09IDAsICdKb2kuZnVuYygpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuZnVuYywgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QubnVtYmVyID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChhcmdzLmxlbmd0aCA9PT0gMCwgJ0pvaS5udW1iZXIoKSBkb2VzIG5vdCBhbGxvdyBhcmd1bWVudHMuJyk7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgaW50ZXJuYWxzLm51bWJlciwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3Qub2JqZWN0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMub2JqZWN0LCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5zdHJpbmcgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLnN0cmluZygpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuc3RyaW5nLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5zeW1ib2wgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3MubGVuZ3RoID09PSAwLCAnSm9pLnN5bWJvbCgpIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cy4nKTtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnRlcm5hbHMuc3ltYm9sLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgcm9vdC5yZWYgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBSZWYuY3JlYXRlKC4uLmFyZ3MpO1xuICAgIH07XG5cbiAgICByb290LmlzUmVmID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgICAgIHJldHVybiBSZWYuaXNSZWYocmVmKTtcbiAgICB9O1xuXG4gICAgcm9vdC52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgLi4uYXJncyAvKiwgW3NjaGVtYV0sIFtvcHRpb25zXSwgY2FsbGJhY2sgKi8pIHtcblxuICAgICAgICBjb25zdCBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBsYXN0ID09PSAnZnVuY3Rpb24nID8gbGFzdCA6IG51bGw7XG5cbiAgICAgICAgY29uc3QgY291bnQgPSBhcmdzLmxlbmd0aCAtIChjYWxsYmFjayA/IDEgOiAwKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYW55LnZhbGlkYXRlKHZhbHVlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvcHRpb25zID0gY291bnQgPT09IDIgPyBhcmdzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLmNvbXBpbGUoYXJnc1swXSk7XG5cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5fdmFsaWRhdGVXaXRoT3B0aW9ucyh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICByb290LmRlc2NyaWJlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICBjb25zdCBzY2hlbWEgPSBhcmdzLmxlbmd0aCA/IHRoaXMuY29tcGlsZShhcmdzWzBdKSA6IGFueTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5kZXNjcmliZSgpO1xuICAgIH07XG5cbiAgICByb290LmNvbXBpbGUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBDYXN0LnNjaGVtYSh0aGlzLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UgKyAnKCcgKyBlcnIucGF0aCArICcpJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJvb3QuYXNzZXJ0ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIG1lc3NhZ2UpIHtcblxuICAgICAgICB0aGlzLmF0dGVtcHQodmFsdWUsIHNjaGVtYSwgbWVzc2FnZSk7XG4gICAgfTtcblxuICAgIHJvb3QuYXR0ZW1wdCA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBtZXNzYWdlKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy52YWxpZGF0ZSh2YWx1ZSwgc2NoZW1hKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnJvci5hbm5vdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gZXJyb3IuYW5ub3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3IuYW5ub3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGAke21lc3NhZ2V9ICR7ZXJyb3IuYW5ub3RhdGUoKX1gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9O1xuXG4gICAgcm9vdC5yZWFjaCA9IGZ1bmN0aW9uIChzY2hlbWEsIHBhdGgpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChzY2hlbWEgJiYgc2NoZW1hIGluc3RhbmNlb2YgQW55LCAneW91IG11c3QgcHJvdmlkZSBhIGpvaSBzY2hlbWEnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSB8fCB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncycpO1xuXG4gICAgICAgIGNvbnN0IHJlYWNoID0gKHNvdXJjZVNjaGVtYSwgc2NoZW1hUGF0aCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYVBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZVNjaGVtYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBzb3VyY2VTY2hlbWEuX2lubmVyLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gc2NoZW1hUGF0aC5zaGlmdCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFjaChjaGlsZC5zY2hlbWEsIHNjaGVtYVBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnID8gKHBhdGggPyBwYXRoLnNwbGl0KCcuJykgOiBbXSkgOiBwYXRoLnNsaWNlKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlYWNoKHNjaGVtYSwgc2NoZW1hUGF0aCk7XG4gICAgfTtcblxuICAgIHJvb3QubGF6eSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jYWxsV2l0aERlZmF1bHRzLmNhbGwodGhpcywgTGF6eSwgYXJncyk7XG4gICAgfTtcblxuICAgIHJvb3QuZGVmYXVsdHMgPSBmdW5jdGlvbiAoZm4pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicsICdEZWZhdWx0cyBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBsZXQgam9pID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmFueSgpKTtcbiAgICAgICAgam9pID0gZm4oam9pKTtcblxuICAgICAgICBIb2VrLmFzc2VydChqb2kgJiYgam9pIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciwgJ2RlZmF1bHRzKCkgbXVzdCByZXR1cm4gYSBzY2hlbWEnKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGpvaSwgdGhpcywgam9pLmNsb25lKCkpOyAvLyBSZS1hZGQgdGhlIHR5cGVzIGZyb20gYHRoaXNgIGJ1dCBhbHNvIGtlZXAgdGhlIHNldHRpbmdzIGZyb20gam9pJ3MgcG90ZW50aWFsIG5ldyBkZWZhdWx0c1xuXG4gICAgICAgIGpvaS5fZGVmYXVsdHMgPSAoc2NoZW1hKSA9PiB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuX2RlZmF1bHRzKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciwgJ2RlZmF1bHRzKCkgbXVzdCByZXR1cm4gYSBzY2hlbWEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZW1hID0gZm4oc2NoZW1hKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHNjaGVtYSBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IsICdkZWZhdWx0cygpIG11c3QgcmV0dXJuIGEgc2NoZW1hJyk7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfTtcblxuICAgIHJvb3QuYmluZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuXG4gICAgICAgIGpvaS5fYmluZHMuZm9yRWFjaCgoYmluZCkgPT4ge1xuXG4gICAgICAgICAgICBqb2lbYmluZF0gPSBqb2lbYmluZF0uYmluZChqb2kpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH07XG5cbiAgICByb290LmV4dGVuZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IEhvZWsuZmxhdHRlbihhcmdzKTtcbiAgICAgICAgSG9lay5hc3NlcnQoZXh0ZW5zaW9ucy5sZW5ndGggPiAwLCAnWW91IG5lZWQgdG8gcHJvdmlkZSBhdCBsZWFzdCBvbmUgZXh0ZW5zaW9uJyk7XG5cbiAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9ucywgcm9vdC5leHRlbnNpb25zU2NoZW1hKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuY3JlYXRlKHRoaXMuYW55KCkpO1xuICAgICAgICBPYmplY3QuYXNzaWduKGpvaSwgdGhpcyk7XG4gICAgICAgIGpvaS5fY3VycmVudEpvaSA9IGpvaTtcbiAgICAgICAgam9pLl9iaW5kcyA9IG5ldyBTZXQoam9pLl9iaW5kcyk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oam9pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9uLCByb290LmV4dGVuc2lvblNjaGVtYSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSAoZXh0ZW5zaW9uLmJhc2UgfHwgdGhpcy5hbnkoKSkuY2xvbmUoKTsgLy8gQ2xvbmluZyBiZWNhdXNlIHdlJ3JlIGdvaW5nIHRvIG92ZXJyaWRlIGxhbmd1YWdlIGFmdGVyd2FyZHNcbiAgICAgICAgICAgIGNvbnN0IGN0b3IgPSBiYXNlLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNsYXNzIGV4dGVuZHMgY3RvciB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG5cbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90eXBlID0gZXh0ZW5zaW9uLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFuZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgW2V4dGVuc2lvbi5uYW1lXTogZXh0ZW5zaW9uLmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5fbGFuZ3VhZ2UgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyh0eXBlLnByb3RvdHlwZS5fbGFuZ3VhZ2UgfHwgKGJhc2UuX3NldHRpbmdzICYmIGJhc2UuX3NldHRpbmdzLmxhbmd1YWdlKSB8fCB7fSwgbGFuZyk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5jb2VyY2UpIHtcbiAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5fY29lcmNlID0gZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdG9yLnByb3RvdHlwZS5fY29lcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUmV0ID0gY3Rvci5wcm90b3R5cGUuX2NvZXJjZS5jYWxsKHRoaXMsIHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUmV0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlUmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VSZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBleHRlbnNpb24uY29lcmNlLmNhbGwodGhpcywgdmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldCBpbnN0YW5jZW9mIEVycm9ycy5FcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJldCB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJldCB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb24ucHJlKSB7XG4gICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuX2Jhc2UgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN0b3IucHJvdG90eXBlLl9iYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlUmV0ID0gY3Rvci5wcm90b3R5cGUuX2Jhc2UuY2FsbCh0aGlzLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJldC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlUmV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gZXh0ZW5zaW9uLnByZS5jYWxsKHRoaXMsIHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcnMuRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXQgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRlbnNpb24ucnVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVsZSA9IGV4dGVuc2lvbi5ydWxlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVsZUFyZ3MgPSBydWxlLnBhcmFtcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAocnVsZS5wYXJhbXMgaW5zdGFuY2VvZiBBbnkgPyBydWxlLnBhcmFtcy5faW5uZXIuY2hpbGRyZW4ubWFwKChrKSA9PiBrLmtleSkgOiBPYmplY3Qua2V5cyhydWxlLnBhcmFtcykpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0ZUFyZ3MgPSBydWxlLnBhcmFtcyA/IENhc3Quc2NoZW1hKHRoaXMsIHJ1bGUucGFyYW1zKSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm90b3R5cGVbcnVsZS5uYW1lXSA9IGZ1bmN0aW9uICguLi5yQXJncykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvb3AtZnVuY1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAockFyZ3MubGVuZ3RoID4gcnVsZUFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG51bWJlciBvZiBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhhc1JlZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFyZyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJ1bGVBcmdzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnW3J1bGVBcmdzW2tdXSA9IHJBcmdzW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzUmVmICYmIFJlZi5pc1JlZihyQXJnc1trXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBqb2kuYXR0ZW1wdChhcmcsIHZhbGlkYXRlQXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS52YWxpZGF0ZSAmJiAhcnVsZS5zZXR1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLnZhbGlkYXRlLmNhbGwodGhpcywgYXJnLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLl90ZXN0KHJ1bGUubmFtZSwgYXJnLCB2YWxpZGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogcnVsZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnNldHVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3U2NoZW1hID0gcnVsZS5zZXR1cC5jYWxsKHNjaGVtYSwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSG9lay5hc3NlcnQobmV3U2NoZW1hIGluc3RhbmNlb2YgQW55LCBgU2V0dXAgb2YgZXh0ZW5zaW9uIEpvaS4ke3RoaXMuX3R5cGV9KCkuJHtydWxlLm5hbWV9KCkgbXVzdCByZXR1cm4gdW5kZWZpbmVkIG9yIGEgSm9pIG9iamVjdGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSBuZXdTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUudmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLnZhbGlkYXRlLmNhbGwodGhpcywgYXJnLCB2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYS5fdGVzdChydWxlLm5hbWUsIGFyZywgdmFsaWRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBydWxlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlbnNpb24uZGVzY3JpYmUpIHtcbiAgICAgICAgICAgICAgICB0eXBlLnByb3RvdHlwZS5kZXNjcmliZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGN0b3IucHJvdG90eXBlLmRlc2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRlbnNpb24uZGVzY3JpYmUuY2FsbCh0aGlzLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgdHlwZSgpO1xuICAgICAgICAgICAgam9pW2V4dGVuc2lvbi5uYW1lXSA9IGZ1bmN0aW9uICguLi5leHRBcmdzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNhbGxXaXRoRGVmYXVsdHMuY2FsbCh0aGlzLCBpbnN0YW5jZSwgZXh0QXJncyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBqb2kuX2JpbmRzLmFkZChleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gam9pO1xuICAgIH07XG5cbiAgICByb290LmV4dGVuc2lvblNjaGVtYSA9IGludGVybmFscy5vYmplY3Qua2V5cyh7XG4gICAgICAgIGJhc2U6IGludGVybmFscy5vYmplY3QudHlwZShBbnksICdKb2kgb2JqZWN0JyksXG4gICAgICAgIG5hbWU6IGludGVybmFscy5zdHJpbmcucmVxdWlyZWQoKSxcbiAgICAgICAgY29lcmNlOiBpbnRlcm5hbHMuZnVuYy5hcml0eSgzKSxcbiAgICAgICAgcHJlOiBpbnRlcm5hbHMuZnVuYy5hcml0eSgzKSxcbiAgICAgICAgbGFuZ3VhZ2U6IGludGVybmFscy5vYmplY3QsXG4gICAgICAgIGRlc2NyaWJlOiBpbnRlcm5hbHMuZnVuYy5hcml0eSgxKSxcbiAgICAgICAgcnVsZXM6IGludGVybmFscy5hcnJheS5pdGVtcyhpbnRlcm5hbHMub2JqZWN0LmtleXMoe1xuICAgICAgICAgICAgbmFtZTogaW50ZXJuYWxzLnN0cmluZy5yZXF1aXJlZCgpLFxuICAgICAgICAgICAgc2V0dXA6IGludGVybmFscy5mdW5jLmFyaXR5KDEpLFxuICAgICAgICAgICAgdmFsaWRhdGU6IGludGVybmFscy5mdW5jLmFyaXR5KDQpLFxuICAgICAgICAgICAgcGFyYW1zOiBbXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzLm9iamVjdC5wYXR0ZXJuKC8uKi8sIGludGVybmFscy5vYmplY3QudHlwZShBbnksICdKb2kgb2JqZWN0JykpLFxuICAgICAgICAgICAgICAgIGludGVybmFscy5vYmplY3QudHlwZShpbnRlcm5hbHMub2JqZWN0LmNvbnN0cnVjdG9yLCAnSm9pIG9iamVjdCcpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IFtpbnRlcm5hbHMuc3RyaW5nLCBpbnRlcm5hbHMuZnVuYy5hcml0eSgxKV1cbiAgICAgICAgfSkub3IoJ3NldHVwJywgJ3ZhbGlkYXRlJykpXG4gICAgfSkuc3RyaWN0KCk7XG5cbiAgICByb290LmV4dGVuc2lvbnNTY2hlbWEgPSBpbnRlcm5hbHMuYXJyYXkuaXRlbXMoW2ludGVybmFscy5vYmplY3QsIGludGVybmFscy5mdW5jLmFyaXR5KDEpXSkuc3RyaWN0KCk7XG5cbiAgICByb290LnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuXG4gICAgcmV0dXJuIHJvb3Q7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLnJvb3QoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5lcnJvcnMgPSB7XG4gICAgcm9vdDogJ3ZhbHVlJyxcbiAgICBrZXk6ICdcInt7IWxhYmVsfX1cIiAnLFxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgIHdyYXBBcnJheXM6IHRydWVcbiAgICB9LFxuICAgIGFueToge1xuICAgICAgICB1bmtub3duOiAnaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICBpbnZhbGlkOiAnY29udGFpbnMgYW4gaW52YWxpZCB2YWx1ZScsXG4gICAgICAgIGVtcHR5OiAnaXMgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHknLFxuICAgICAgICByZXF1aXJlZDogJ2lzIHJlcXVpcmVkJyxcbiAgICAgICAgYWxsb3dPbmx5OiAnbXVzdCBiZSBvbmUgb2Yge3t2YWxpZHN9fScsXG4gICAgICAgIGRlZmF1bHQ6ICd0aHJldyBhbiBlcnJvciB3aGVuIHJ1bm5pbmcgZGVmYXVsdCBtZXRob2QnXG4gICAgfSxcbiAgICBhbHRlcm5hdGl2ZXM6IHtcbiAgICAgICAgYmFzZTogJ25vdCBtYXRjaGluZyBhbnkgb2YgdGhlIGFsbG93ZWQgYWx0ZXJuYXRpdmVzJyxcbiAgICAgICAgY2hpbGQ6IG51bGxcbiAgICB9LFxuICAgIGFycmF5OiB7XG4gICAgICAgIGJhc2U6ICdtdXN0IGJlIGFuIGFycmF5JyxcbiAgICAgICAgaW5jbHVkZXM6ICdhdCBwb3NpdGlvbiB7e3Bvc319IGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgIGluY2x1ZGVzU2luZ2xlOiAnc2luZ2xlIHZhbHVlIG9mIFwie3shbGFiZWx9fVwiIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgIGluY2x1ZGVzT25lOiAnYXQgcG9zaXRpb24ge3twb3N9fSBmYWlscyBiZWNhdXNlIHt7cmVhc29ufX0nLFxuICAgICAgICBpbmNsdWRlc09uZVNpbmdsZTogJ3NpbmdsZSB2YWx1ZSBvZiBcInt7IWxhYmVsfX1cIiBmYWlscyBiZWNhdXNlIHt7cmVhc29ufX0nLFxuICAgICAgICBpbmNsdWRlc1JlcXVpcmVkVW5rbm93bnM6ICdkb2VzIG5vdCBjb250YWluIHt7dW5rbm93bk1pc3Nlc319IHJlcXVpcmVkIHZhbHVlKHMpJyxcbiAgICAgICAgaW5jbHVkZXNSZXF1aXJlZEtub3duczogJ2RvZXMgbm90IGNvbnRhaW4ge3trbm93bk1pc3Nlc319JyxcbiAgICAgICAgaW5jbHVkZXNSZXF1aXJlZEJvdGg6ICdkb2VzIG5vdCBjb250YWluIHt7a25vd25NaXNzZXN9fSBhbmQge3t1bmtub3duTWlzc2VzfX0gb3RoZXIgcmVxdWlyZWQgdmFsdWUocyknLFxuICAgICAgICBleGNsdWRlczogJ2F0IHBvc2l0aW9uIHt7cG9zfX0gY29udGFpbnMgYW4gZXhjbHVkZWQgdmFsdWUnLFxuICAgICAgICBleGNsdWRlc1NpbmdsZTogJ3NpbmdsZSB2YWx1ZSBvZiBcInt7IWxhYmVsfX1cIiBjb250YWlucyBhbiBleGNsdWRlZCB2YWx1ZScsXG4gICAgICAgIGhhc0tub3duOiAnZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2ggZm9yIHR5cGUgXCJ7eyFwYXR0ZXJuTGFiZWx9fVwiJyxcbiAgICAgICAgaGFzVW5rbm93bjogJ2RvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoJyxcbiAgICAgICAgbWluOiAnbXVzdCBjb250YWluIGF0IGxlYXN0IHt7bGltaXR9fSBpdGVtcycsXG4gICAgICAgIG1heDogJ211c3QgY29udGFpbiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3tsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgbGVuZ3RoOiAnbXVzdCBjb250YWluIHt7bGltaXR9fSBpdGVtcycsXG4gICAgICAgIG9yZGVyZWQ6ICdhdCBwb3NpdGlvbiB7e3Bvc319IGZhaWxzIGJlY2F1c2Uge3tyZWFzb259fScsXG4gICAgICAgIG9yZGVyZWRMZW5ndGg6ICdhdCBwb3NpdGlvbiB7e3Bvc319IGZhaWxzIGJlY2F1c2UgYXJyYXkgbXVzdCBjb250YWluIGF0IG1vc3Qge3tsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgcmVmOiAncmVmZXJlbmNlcyBcInt7cmVmfX1cIiB3aGljaCBpcyBub3QgYSBwb3NpdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgc3BhcnNlOiAnbXVzdCBub3QgYmUgYSBzcGFyc2UgYXJyYXknLFxuICAgICAgICB1bmlxdWU6ICdwb3NpdGlvbiB7e3Bvc319IGNvbnRhaW5zIGEgZHVwbGljYXRlIHZhbHVlJ1xuICAgIH0sXG4gICAgYm9vbGVhbjoge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhIGJvb2xlYW4nXG4gICAgfSxcbiAgICBiaW5hcnk6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBidWZmZXIgb3IgYSBzdHJpbmcnLFxuICAgICAgICBtaW46ICdtdXN0IGJlIGF0IGxlYXN0IHt7bGltaXR9fSBieXRlcycsXG4gICAgICAgIG1heDogJ211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fSBieXRlcycsXG4gICAgICAgIGxlbmd0aDogJ211c3QgYmUge3tsaW1pdH19IGJ5dGVzJ1xuICAgIH0sXG4gICAgZGF0ZToge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3IgdmFsaWQgZGF0ZSBzdHJpbmcnLFxuICAgICAgICBzdHJpY3Q6ICdtdXN0IGJlIGEgdmFsaWQgZGF0ZScsXG4gICAgICAgIG1pbjogJ211c3QgYmUgbGFyZ2VyIHRoYW4gb3IgZXF1YWwgdG8gXCJ7e2xpbWl0fX1cIicsXG4gICAgICAgIG1heDogJ211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIFwie3tsaW1pdH19XCInLFxuICAgICAgICBsZXNzOiAnbXVzdCBiZSBsZXNzIHRoYW4gXCJ7e2xpbWl0fX1cIicsXG4gICAgICAgIGdyZWF0ZXI6ICdtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcInt7bGltaXR9fVwiJyxcbiAgICAgICAgaXNvRGF0ZTogJ211c3QgYmUgYSB2YWxpZCBJU08gODYwMSBkYXRlJyxcbiAgICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgICAgICBqYXZhc2NyaXB0OiAnbXVzdCBiZSBhIHZhbGlkIHRpbWVzdGFtcCBvciBudW1iZXIgb2YgbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgIHVuaXg6ICdtdXN0IGJlIGEgdmFsaWQgdGltZXN0YW1wIG9yIG51bWJlciBvZiBzZWNvbmRzJ1xuICAgICAgICB9LFxuICAgICAgICByZWY6ICdyZWZlcmVuY2VzIFwie3tyZWZ9fVwiIHdoaWNoIGlzIG5vdCBhIGRhdGUnXG4gICAgfSxcbiAgICBmdW5jdGlvbjoge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhIEZ1bmN0aW9uJyxcbiAgICAgICAgYXJpdHk6ICdtdXN0IGhhdmUgYW4gYXJpdHkgb2Yge3tufX0nLFxuICAgICAgICBtaW5Bcml0eTogJ211c3QgaGF2ZSBhbiBhcml0eSBncmVhdGVyIG9yIGVxdWFsIHRvIHt7bn19JyxcbiAgICAgICAgbWF4QXJpdHk6ICdtdXN0IGhhdmUgYW4gYXJpdHkgbGVzc2VyIG9yIGVxdWFsIHRvIHt7bn19JyxcbiAgICAgICAgcmVmOiAnbXVzdCBiZSBhIEpvaSByZWZlcmVuY2UnLFxuICAgICAgICBjbGFzczogJ211c3QgYmUgYSBjbGFzcydcbiAgICB9LFxuICAgIGxhenk6IHtcbiAgICAgICAgYmFzZTogJyEhc2NoZW1hIGVycm9yOiBsYXp5IHNjaGVtYSBtdXN0IGJlIHNldCcsXG4gICAgICAgIHNjaGVtYTogJyEhc2NoZW1hIGVycm9yOiBsYXp5IHNjaGVtYSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHNjaGVtYSdcbiAgICB9LFxuICAgIG9iamVjdDoge1xuICAgICAgICBiYXNlOiAnbXVzdCBiZSBhbiBvYmplY3QnLFxuICAgICAgICBjaGlsZDogJyEhY2hpbGQgXCJ7eyFjaGlsZH19XCIgZmFpbHMgYmVjYXVzZSB7e3JlYXNvbn19JyxcbiAgICAgICAgbWluOiAnbXVzdCBoYXZlIGF0IGxlYXN0IHt7bGltaXR9fSBjaGlsZHJlbicsXG4gICAgICAgIG1heDogJ211c3QgaGF2ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3tsaW1pdH19IGNoaWxkcmVuJyxcbiAgICAgICAgbGVuZ3RoOiAnbXVzdCBoYXZlIHt7bGltaXR9fSBjaGlsZHJlbicsXG4gICAgICAgIGFsbG93VW5rbm93bjogJyEhXCJ7eyFjaGlsZH19XCIgaXMgbm90IGFsbG93ZWQnLFxuICAgICAgICB3aXRoOiAnISFcInt7bWFpbldpdGhMYWJlbH19XCIgbWlzc2luZyByZXF1aXJlZCBwZWVyIFwie3twZWVyV2l0aExhYmVsfX1cIicsXG4gICAgICAgIHdpdGhvdXQ6ICchIVwie3ttYWluV2l0aExhYmVsfX1cIiBjb25mbGljdCB3aXRoIGZvcmJpZGRlbiBwZWVyIFwie3twZWVyV2l0aExhYmVsfX1cIicsXG4gICAgICAgIG1pc3Npbmc6ICdtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHt7cGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICB4b3I6ICdjb250YWlucyBhIGNvbmZsaWN0IGJldHdlZW4gZXhjbHVzaXZlIHBlZXJzIHt7cGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICBveG9yOiAnY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIG9wdGlvbmFsIGV4Y2x1c2l2ZSBwZWVycyB7e3BlZXJzV2l0aExhYmVsc319JyxcbiAgICAgICAgYW5kOiAnY29udGFpbnMge3twcmVzZW50V2l0aExhYmVsc319IHdpdGhvdXQgaXRzIHJlcXVpcmVkIHBlZXJzIHt7bWlzc2luZ1dpdGhMYWJlbHN9fScsXG4gICAgICAgIG5hbmQ6ICchIVwie3ttYWluV2l0aExhYmVsfX1cIiBtdXN0IG5vdCBleGlzdCBzaW11bHRhbmVvdXNseSB3aXRoIHt7cGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICBhc3NlcnQ6ICchIVwie3tyZWZ9fVwiIHZhbGlkYXRpb24gZmFpbGVkIGJlY2F1c2UgXCJ7e3JlZn19XCIgZmFpbGVkIHRvIHt7bWVzc2FnZX19JyxcbiAgICAgICAgcmVuYW1lOiB7XG4gICAgICAgICAgICBtdWx0aXBsZTogJ2Nhbm5vdCByZW5hbWUgY2hpbGQgXCJ7e2Zyb219fVwiIGJlY2F1c2UgbXVsdGlwbGUgcmVuYW1lcyBhcmUgZGlzYWJsZWQgYW5kIGFub3RoZXIga2V5IHdhcyBhbHJlYWR5IHJlbmFtZWQgdG8gXCJ7e3RvfX1cIicsXG4gICAgICAgICAgICBvdmVycmlkZTogJ2Nhbm5vdCByZW5hbWUgY2hpbGQgXCJ7e2Zyb219fVwiIGJlY2F1c2Ugb3ZlcnJpZGUgaXMgZGlzYWJsZWQgYW5kIHRhcmdldCBcInt7dG99fVwiIGV4aXN0cycsXG4gICAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICAgIG11bHRpcGxlOiAnY2Fubm90IHJlbmFtZSBjaGlsZHJlbiB7e2Zyb219fSBiZWNhdXNlIG11bHRpcGxlIHJlbmFtZXMgYXJlIGRpc2FibGVkIGFuZCBhbm90aGVyIGtleSB3YXMgYWxyZWFkeSByZW5hbWVkIHRvIFwie3t0b319XCInLFxuICAgICAgICAgICAgICAgIG92ZXJyaWRlOiAnY2Fubm90IHJlbmFtZSBjaGlsZHJlbiB7e2Zyb219fSBiZWNhdXNlIG92ZXJyaWRlIGlzIGRpc2FibGVkIGFuZCB0YXJnZXQgXCJ7e3RvfX1cIiBleGlzdHMnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFwie3t0eXBlfX1cIicsXG4gICAgICAgIHNjaGVtYTogJ211c3QgYmUgYSBKb2kgaW5zdGFuY2UnXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBudW1iZXInLFxuICAgICAgICB1bnNhZmU6ICdtdXN0IGJlIGEgc2FmZSBudW1iZXInLFxuICAgICAgICBtaW46ICdtdXN0IGJlIGxhcmdlciB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fScsXG4gICAgICAgIG1heDogJ211c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fScsXG4gICAgICAgIGxlc3M6ICdtdXN0IGJlIGxlc3MgdGhhbiB7e2xpbWl0fX0nLFxuICAgICAgICBncmVhdGVyOiAnbXVzdCBiZSBncmVhdGVyIHRoYW4ge3tsaW1pdH19JyxcbiAgICAgICAgaW50ZWdlcjogJ211c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICAgIG5lZ2F0aXZlOiAnbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gICAgICAgIHBvc2l0aXZlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gICAgICAgIHByZWNpc2lvbjogJ211c3QgaGF2ZSBubyBtb3JlIHRoYW4ge3tsaW1pdH19IGRlY2ltYWwgcGxhY2VzJyxcbiAgICAgICAgcmVmOiAncmVmZXJlbmNlcyBcInt7cmVmfX1cIiB3aGljaCBpcyBub3QgYSBudW1iZXInLFxuICAgICAgICBtdWx0aXBsZTogJ211c3QgYmUgYSBtdWx0aXBsZSBvZiB7e211bHRpcGxlfX0nLFxuICAgICAgICBwb3J0OiAnbXVzdCBiZSBhIHZhbGlkIHBvcnQnXG4gICAgfSxcbiAgICBzdHJpbmc6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgICBtaW46ICdsZW5ndGggbXVzdCBiZSBhdCBsZWFzdCB7e2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgbWF4OiAnbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7bGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICBsZW5ndGg6ICdsZW5ndGggbXVzdCBiZSB7e2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgYWxwaGFudW06ICdtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGNoYXJhY3RlcnMnLFxuICAgICAgICB0b2tlbjogJ211c3Qgb25seSBjb250YWluIGFscGhhLW51bWVyaWMgYW5kIHVuZGVyc2NvcmUgY2hhcmFjdGVycycsXG4gICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICBiYXNlOiAnd2l0aCB2YWx1ZSBcInt7IXZhbHVlfX1cIiBmYWlscyB0byBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybjoge3twYXR0ZXJufX0nLFxuICAgICAgICAgICAgbmFtZTogJ3dpdGggdmFsdWUgXCJ7eyF2YWx1ZX19XCIgZmFpbHMgdG8gbWF0Y2ggdGhlIHt7bmFtZX19IHBhdHRlcm4nLFxuICAgICAgICAgICAgaW52ZXJ0OiB7XG4gICAgICAgICAgICAgICAgYmFzZTogJ3dpdGggdmFsdWUgXCJ7eyF2YWx1ZX19XCIgbWF0Y2hlcyB0aGUgaW52ZXJ0ZWQgcGF0dGVybjoge3twYXR0ZXJufX0nLFxuICAgICAgICAgICAgICAgIG5hbWU6ICd3aXRoIHZhbHVlIFwie3shdmFsdWV9fVwiIG1hdGNoZXMgdGhlIGludmVydGVkIHt7bmFtZX19IHBhdHRlcm4nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVtYWlsOiAnbXVzdCBiZSBhIHZhbGlkIGVtYWlsJyxcbiAgICAgICAgdXJpOiAnbXVzdCBiZSBhIHZhbGlkIHVyaScsXG4gICAgICAgIHVyaVJlbGF0aXZlT25seTogJ211c3QgYmUgYSB2YWxpZCByZWxhdGl2ZSB1cmknLFxuICAgICAgICB1cmlDdXN0b21TY2hlbWU6ICdtdXN0IGJlIGEgdmFsaWQgdXJpIHdpdGggYSBzY2hlbWUgbWF0Y2hpbmcgdGhlIHt7c2NoZW1lfX0gcGF0dGVybicsXG4gICAgICAgIGlzb0RhdGU6ICdtdXN0IGJlIGEgdmFsaWQgSVNPIDg2MDEgZGF0ZScsXG4gICAgICAgIGd1aWQ6ICdtdXN0IGJlIGEgdmFsaWQgR1VJRCcsXG4gICAgICAgIGhleDogJ211c3Qgb25seSBjb250YWluIGhleGFkZWNpbWFsIGNoYXJhY3RlcnMnLFxuICAgICAgICBoZXhBbGlnbjogJ2hleCBkZWNvZGVkIHJlcHJlc2VudGF0aW9uIG11c3QgYmUgYnl0ZSBhbGlnbmVkJyxcbiAgICAgICAgYmFzZTY0OiAnbXVzdCBiZSBhIHZhbGlkIGJhc2U2NCBzdHJpbmcnLFxuICAgICAgICBkYXRhVXJpOiAnbXVzdCBiZSBhIHZhbGlkIGRhdGFVcmkgc3RyaW5nJyxcbiAgICAgICAgaG9zdG5hbWU6ICdtdXN0IGJlIGEgdmFsaWQgaG9zdG5hbWUnLFxuICAgICAgICBub3JtYWxpemU6ICdtdXN0IGJlIHVuaWNvZGUgbm9ybWFsaXplZCBpbiB0aGUge3tmb3JtfX0gZm9ybScsXG4gICAgICAgIGxvd2VyY2FzZTogJ211c3Qgb25seSBjb250YWluIGxvd2VyY2FzZSBjaGFyYWN0ZXJzJyxcbiAgICAgICAgdXBwZXJjYXNlOiAnbXVzdCBvbmx5IGNvbnRhaW4gdXBwZXJjYXNlIGNoYXJhY3RlcnMnLFxuICAgICAgICB0cmltOiAnbXVzdCBub3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UnLFxuICAgICAgICBjcmVkaXRDYXJkOiAnbXVzdCBiZSBhIGNyZWRpdCBjYXJkJyxcbiAgICAgICAgcmVmOiAncmVmZXJlbmNlcyBcInt7cmVmfX1cIiB3aGljaCBpcyBub3QgYSBudW1iZXInLFxuICAgICAgICBpcDogJ211c3QgYmUgYSB2YWxpZCBpcCBhZGRyZXNzIHdpdGggYSB7e2NpZHJ9fSBDSURSJyxcbiAgICAgICAgaXBWZXJzaW9uOiAnbXVzdCBiZSBhIHZhbGlkIGlwIGFkZHJlc3Mgb2Ygb25lIG9mIHRoZSBmb2xsb3dpbmcgdmVyc2lvbnMge3t2ZXJzaW9ufX0gd2l0aCBhIHt7Y2lkcn19IENJRFInXG4gICAgfSxcbiAgICBzeW1ib2w6IHtcbiAgICAgICAgYmFzZTogJ211c3QgYmUgYSBzeW1ib2wnLFxuICAgICAgICBtYXA6ICdtdXN0IGJlIG9uZSBvZiB7e21hcH19J1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgJ0ludmFsaWQgcmVmZXJlbmNlIGtleTonLCBrZXkpO1xuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSBIb2VrLmNsb25lKG9wdGlvbnMpOyAgICAgICAgIC8vIG9wdGlvbnMgY2FuIGJlIHJldXNlZCBhbmQgbW9kaWZpZWRcblxuICAgIGNvbnN0IHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSwgdmFsaWRhdGlvbk9wdGlvbnMpIHtcblxuICAgICAgICByZXR1cm4gSG9lay5yZWFjaChyZWYuaXNDb250ZXh0ID8gdmFsaWRhdGlvbk9wdGlvbnMuY29udGV4dCA6IHZhbHVlLCByZWYua2V5LCBzZXR0aW5ncyk7XG4gICAgfTtcblxuICAgIHJlZi5pc0NvbnRleHQgPSAoa2V5WzBdID09PSAoKHNldHRpbmdzICYmIHNldHRpbmdzLmNvbnRleHRQcmVmaXgpIHx8ICckJykpO1xuICAgIHJlZi5rZXkgPSAocmVmLmlzQ29udGV4dCA/IGtleS5zbGljZSgxKSA6IGtleSk7XG4gICAgcmVmLnBhdGggPSByZWYua2V5LnNwbGl0KChzZXR0aW5ncyAmJiBzZXR0aW5ncy5zZXBhcmF0b3IpIHx8ICcuJyk7XG4gICAgcmVmLmRlcHRoID0gcmVmLnBhdGgubGVuZ3RoO1xuICAgIHJlZi5yb290ID0gcmVmLnBhdGhbMF07XG4gICAgcmVmLmlzSm9pID0gdHJ1ZTtcblxuICAgIHJlZi50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByZXR1cm4gKHJlZi5pc0NvbnRleHQgPyAnY29udGV4dDonIDogJ3JlZjonKSArIHJlZi5rZXk7XG4gICAgfTtcblxuICAgIHJldHVybiByZWY7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiByZWYuaXNKb2k7XG59O1xuXG5cbmV4cG9ydHMucHVzaCA9IGZ1bmN0aW9uIChhcnJheSwgcmVmKSB7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1JlZihyZWYpICYmXG4gICAgICAgICFyZWYuaXNDb250ZXh0KSB7XG5cbiAgICAgICAgYXJyYXkucHVzaChyZWYucm9vdCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSm9pID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMub3B0aW9ucyA9IEpvaS5vYmplY3Qoe1xuICAgIGFib3J0RWFybHk6IEpvaS5ib29sZWFuKCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBhbGxvd1Vua25vd246IEpvaS5ib29sZWFuKCksXG4gICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICBzdHJpcFVua25vd246IFtKb2kuYm9vbGVhbigpLCBKb2kub2JqZWN0KHsgYXJyYXlzOiBKb2kuYm9vbGVhbigpLCBvYmplY3RzOiBKb2kuYm9vbGVhbigpIH0pLm9yKCdhcnJheXMnLCAnb2JqZWN0cycpXSxcbiAgICBsYW5ndWFnZTogSm9pLm9iamVjdCgpLFxuICAgIHByZXNlbmNlOiBKb2kuc3RyaW5nKCkub25seSgncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJywgJ2lnbm9yZScpLFxuICAgIGNvbnRleHQ6IEpvaS5vYmplY3QoKSxcbiAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgIGVzY2FwZUh0bWw6IEpvaS5ib29sZWFuKClcbn0pLnN0cmljdCgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5leHRlbmRlZENoZWNrRm9yVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodmFsdWVUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGl0ZW0pID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgRGF0ZSAmJiB2YWx1ZS5nZXRUaW1lKCkgPT09IGl0ZW0uZ2V0VGltZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGl0ZW0pID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoaXRlbSkgJiYgdmFsdWUubGVuZ3RoID09PSBpdGVtLmxlbmd0aCAmJiB2YWx1ZS50b1N0cmluZygnYmluYXJ5JykgPT09IGl0ZW0udG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnNlbnNpdGl2ZSAmJiB2YWx1ZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgJiYgbG93ZXJjYXNlVmFsdWUgPT09IGl0ZW0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBJbnRlcm5hbFNldCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihmcm9tKSB7XG5cbiAgICAgICAgdGhpcy5fc2V0ID0gbmV3IFNldChmcm9tKTtcbiAgICAgICAgdGhpcy5faGFzUmVmID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYWRkKHZhbHVlLCByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYodmFsdWUpO1xuICAgICAgICBpZiAoIWlzUmVmICYmIHRoaXMuaGFzKHZhbHVlLCBudWxsLCBudWxsLCBmYWxzZSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVmcyAhPT0gdW5kZWZpbmVkKSB7IC8vIElmIGl0J3MgYSBtZXJnZSwgd2UgZG9uJ3QgaGF2ZSBhbnkgcmVmc1xuICAgICAgICAgICAgUmVmLnB1c2gocmVmcywgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0LmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5faGFzUmVmIHw9IGlzUmVmO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG1lcmdlKGFkZCwgcmVtb3ZlKSB7XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFkZC5fc2V0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByZW1vdmUuX3NldCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZW1vdmUodmFsdWUpIHtcblxuICAgICAgICB0aGlzLl9zZXQuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgaW5zZW5zaXRpdmUpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLmdldCh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIGluc2Vuc2l0aXZlKTtcbiAgICB9XG5cbiAgICBnZXQodmFsdWUsIHN0YXRlLCBvcHRpb25zLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2V0LnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gdGhpcy5fc2V0Lmhhcyh2YWx1ZSk7XG4gICAgICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQ2hlY2sgPSBpbnRlcm5hbHMuZXh0ZW5kZWRDaGVja0ZvclZhbHVlKHZhbHVlLCBpbnNlbnNpdGl2ZSk7XG4gICAgICAgIGlmICghZXh0ZW5kZWRDaGVjaykge1xuICAgICAgICAgICAgaWYgKHN0YXRlICYmIHRoaXMuX2hhc1JlZikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSZWYuaXNSZWYoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBbXS5jb25jYXQoaXRlbShzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IGl0ZW0uaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtW2ZvdW5kXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgZXh0ZW5kZWRDaGVjayk7XG4gICAgfVxuXG4gICAgX2hhcyh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIGNoZWNrKSB7XG5cbiAgICAgICAgY29uc3QgY2hlY2tSZWYgPSAhIShzdGF0ZSAmJiB0aGlzLl9oYXNSZWYpO1xuXG4gICAgICAgIGNvbnN0IGlzUmVhbGx5RXF1YWwgPSBmdW5jdGlvbiAoaXRlbSkge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrKGl0ZW0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5fc2V0KSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tSZWYgJiYgUmVmLmlzUmVmKGl0ZW0pKSB7IC8vIE9ubHkgcmVzb2x2ZSByZWZlcmVuY2VzIGlmIHRoZXJlIGlzIGEgc3RhdGUsIG90aGVyd2lzZSBpdCdzIGEgbWVyZ2VcbiAgICAgICAgICAgICAgICBpdGVtID0gaXRlbShzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gaXRlbS5maW5kSW5kZXgoaXNSZWFsbHlFcXVhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtW2ZvdW5kXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzUmVhbGx5RXF1YWwoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFsdWVzKG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnN0cmlwVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX3NldCkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fc2V0KTtcbiAgICB9XG5cbiAgICBzbGljZSgpIHtcblxuICAgICAgICBjb25zdCBzZXQgPSBuZXcgSW50ZXJuYWxTZXQodGhpcy5fc2V0KTtcbiAgICAgICAgc2V0Ll9oYXNSZWYgPSB0aGlzLl9oYXNSZWY7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuXG4gICAgY29uY2F0KHNvdXJjZSkge1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBJbnRlcm5hbFNldChbLi4udGhpcy5fc2V0LCAuLi5zb3VyY2UuX3NldF0pO1xuICAgICAgICBzZXQuX2hhc1JlZiA9ICEhKHRoaXMuX2hhc1JlZiB8IHNvdXJjZS5faGFzUmVmKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IENhc3QgPSByZXF1aXJlKCcuLi8uLi9jYXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuQWx0ZXJuYXRpdmVzID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdhbHRlcm5hdGl2ZXMnO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcy5yZW1vdmUobnVsbCk7XG4gICAgICAgIHRoaXMuX2lubmVyLm1hdGNoZXMgPSBbXTtcbiAgICB9XG5cbiAgICBfaW5pdCguLi5hcmdzKSB7XG5cbiAgICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoID8gdGhpcy50cnkoLi4uYXJncykgOiB0aGlzO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBjb25zdCBpbCA9IHRoaXMuX2lubmVyLm1hdGNoZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBiYXNlVHlwZSA9IHRoaXMuX2Jhc2VUeXBlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2lubmVyLm1hdGNoZXNbaV07XG4gICAgICAgICAgICBpZiAoIWl0ZW0uc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gaXRlbS5wZWVrIHx8IGl0ZW0uaXM7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBpdGVtLmlzID8gaXRlbS5yZWYoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucykgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsZWQgPSBzY2hlbWEuX3ZhbGlkYXRlKGlucHV0LCBudWxsLCBvcHRpb25zLCBzdGF0ZS5wYXJlbnQpLmVycm9ycztcblxuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5vdGhlcndpc2UuX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS50aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRoZW4uX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IChpbCAtIDEpICYmIGJhc2VUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVHlwZS5fdmFsaWRhdGUodmFsdWUsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5zY2hlbWEuX3ZhbGlkYXRlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5lcnJvcnMpIHsgICAgIC8vIEZvdW5kIGEgdmFsaWQgbWF0Y2hcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IHRoaXMuY3JlYXRlRXJyb3IoJ2FsdGVybmF0aXZlcy5jaGlsZCcsIHsgcmVhc29uOiBlcnJvcnMgfSwgc3RhdGUsIG9wdGlvbnMpIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHRoaXMuY3JlYXRlRXJyb3IoJ2FsdGVybmF0aXZlcy5iYXNlJywgbnVsbCwgc3RhdGUsIG9wdGlvbnMpIH07XG4gICAgfVxuXG4gICAgdHJ5KC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBzY2hlbWFzID0gSG9lay5mbGF0dGVuKHNjaGVtYXMpO1xuICAgICAgICBIb2VrLmFzc2VydChzY2hlbWFzLmxlbmd0aCwgJ0Nhbm5vdCBhZGQgb3RoZXIgYWx0ZXJuYXRpdmVzIHdpdGhvdXQgYXQgbGVhc3Qgb25lIHNjaGVtYScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhc3QgPSBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBzY2hlbWFzW2ldKTtcbiAgICAgICAgICAgIGlmIChjYXN0Ll9yZWZzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iai5fcmVmcy5wdXNoKC4uLmNhc3QuX3JlZnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX2lubmVyLm1hdGNoZXMucHVzaCh7IHNjaGVtYTogY2FzdCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgd2hlbihjb25kaXRpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgc2NoZW1hQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgICAgIEhvZWsuYXNzZXJ0KFJlZi5pc1JlZihjb25kaXRpb24pIHx8IHR5cGVvZiBjb25kaXRpb24gPT09ICdzdHJpbmcnIHx8IChzY2hlbWFDb25kaXRpb24gPSBjb25kaXRpb24gaW5zdGFuY2VvZiBBbnkpLCAnSW52YWxpZCBjb25kaXRpb246JywgY29uZGl0aW9uKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucywgJ01pc3Npbmcgb3B0aW9ucycpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgaWYgKHNjaGVtYUNvbmRpdGlvbikge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2lzJyksICdcImlzXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmhhc093blByb3BlcnR5KCdpcycpLCAnTWlzc2luZyBcImlzXCIgZGlyZWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLnRoZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm90aGVyd2lzZSAhPT0gdW5kZWZpbmVkLCAnb3B0aW9ucyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG9mIFwidGhlblwiIG9yIFwib3RoZXJ3aXNlXCInKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGxldCBpcztcbiAgICAgICAgaWYgKCFzY2hlbWFDb25kaXRpb24pIHtcbiAgICAgICAgICAgIGlzID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgb3B0aW9ucy5pcyk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlzID09PSBudWxsIHx8ICEoUmVmLmlzUmVmKG9wdGlvbnMuaXMpIHx8IG9wdGlvbnMuaXMgaW5zdGFuY2VvZiBBbnkpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJlcXVpcmVkIGlmIHRoaXMgd2Fzbid0IGFscmVhZHkgYSBzY2hlbWEgb3IgYSByZWYsIHdlJ2xsIHN1cHBvc2UgcGVvcGxlIGtub3cgd2hhdCB0aGV5J3JlIGRvaW5nXG4gICAgICAgICAgICAgICAgaXMgPSBpcy5yZXF1aXJlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIHJlZjogc2NoZW1hQ29uZGl0aW9uID8gbnVsbCA6IENhc3QucmVmKGNvbmRpdGlvbiksXG4gICAgICAgICAgICBwZWVrOiBzY2hlbWFDb25kaXRpb24gPyBjb25kaXRpb24gOiBudWxsLFxuICAgICAgICAgICAgaXMsXG4gICAgICAgICAgICB0aGVuOiBvcHRpb25zLnRoZW4gIT09IHVuZGVmaW5lZCA/IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIG9wdGlvbnMudGhlbikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhlcndpc2U6IG9wdGlvbnMub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQgPyBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBvcHRpb25zLm90aGVyd2lzZSkgOiB1bmRlZmluZWRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob2JqLl9iYXNlVHlwZSkge1xuXG4gICAgICAgICAgICBpdGVtLnRoZW4gPSBpdGVtLnRoZW4gJiYgb2JqLl9iYXNlVHlwZS5jb25jYXQoaXRlbS50aGVuKTtcbiAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlID0gaXRlbS5vdGhlcndpc2UgJiYgb2JqLl9iYXNlVHlwZS5jb25jYXQoaXRlbS5vdGhlcndpc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWFDb25kaXRpb24pIHtcbiAgICAgICAgICAgIFJlZi5wdXNoKG9iai5fcmVmcywgaXRlbS5yZWYpO1xuICAgICAgICAgICAgb2JqLl9yZWZzLnB1c2goLi4uaXRlbS5pcy5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS50aGVuICYmIGl0ZW0udGhlbi5fcmVmcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5fcmVmcy5wdXNoKC4uLml0ZW0udGhlbi5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlbS5vdGhlcndpc2UgJiYgaXRlbS5vdGhlcndpc2UuX3JlZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmouX3JlZnMucHVzaCguLi5pdGVtLm90aGVyd2lzZS5fcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX2lubmVyLm1hdGNoZXMucHVzaChpdGVtKTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGxhYmVsKG5hbWUpIHtcblxuICAgICAgICBjb25zdCBvYmogPSBzdXBlci5sYWJlbChuYW1lKTtcbiAgICAgICAgb2JqLl9pbm5lci5tYXRjaGVzID0gb2JqLl9pbm5lci5tYXRjaGVzLm1hcCgobWF0Y2gpID0+IHtcblxuICAgICAgICAgICAgaWYgKG1hdGNoLnNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogbWF0Y2guc2NoZW1hLmxhYmVsKG5hbWUpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hdGNoID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2gpO1xuICAgICAgICAgICAgaWYgKG1hdGNoLnRoZW4pIHtcbiAgICAgICAgICAgICAgICBtYXRjaC50aGVuID0gbWF0Y2gudGhlbi5sYWJlbChuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hdGNoLm90aGVyd2lzZSkge1xuICAgICAgICAgICAgICAgIG1hdGNoLm90aGVyd2lzZSA9IG1hdGNoLm90aGVyd2lzZS5sYWJlbChuYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHN1cGVyLmRlc2NyaWJlKCk7XG4gICAgICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLm1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pbm5lci5tYXRjaGVzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkoKVxuXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVzLnB1c2goaXRlbS5zY2hlbWEuZGVzY3JpYmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4oKVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgd2hlbiA9IGl0ZW0uaXMgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogaXRlbS5yZWYudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgaXM6IGl0ZW0uaXMuZGVzY3JpYmUoKVxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIHBlZWs6IGl0ZW0ucGVlay5kZXNjcmliZSgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgd2hlbi50aGVuID0gaXRlbS50aGVuLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3RoZXJ3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoZW4ub3RoZXJ3aXNlID0gaXRlbS5vdGhlcndpc2UuZGVzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZXMucHVzaCh3aGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRlc2NyaXB0aW9uLmFsdGVybmF0aXZlcyA9IGFsdGVybmF0aXZlcztcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQWx0ZXJuYXRpdmVzKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IENhc3QgPSByZXF1aXJlKCcuLi8uLi9jYXN0Jyk7XG5jb25zdCBTZXR0aW5ncyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uLy4uL3JlZicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBTdGF0ZSA9IHJlcXVpcmUoJy4uL3N0YXRlJyk7XG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vc3ltYm9scycpO1xuXG5jb25zdCBQa2cgPSByZXF1aXJlKCcuLi8uLi8uLi9wYWNrYWdlLmpzb24nKTtcblxubGV0IEFsdGVybmF0aXZlcyA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGF5LWxvYWRlZCB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcGVuZGVuY2llc1xubGV0IFNjaGVtYXMgPSBudWxsO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBTZXQ6IHJlcXVpcmUoJy4uLy4uL3NldCcpLFxuICAgIHN5bWJvbDogU3ltYm9sLmZvcignQGhhcGkvam9pL3NjaGVtYScpXG59O1xuXG5cbmludGVybmFscy5kZWZhdWx0cyA9IHtcbiAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgIGNvbnZlcnQ6IHRydWUsXG4gICAgYWxsb3dVbmtub3duOiBmYWxzZSxcbiAgICBza2lwRnVuY3Rpb25zOiBmYWxzZSxcbiAgICBzdHJpcFVua25vd246IGZhbHNlLFxuICAgIGxhbmd1YWdlOiB7fSxcbiAgICBwcmVzZW5jZTogJ29wdGlvbmFsJyxcbiAgICBub0RlZmF1bHRzOiBmYWxzZSxcbiAgICBlc2NhcGVIdG1sOiBmYWxzZVxuXG4gICAgLy8gY29udGV4dDogbnVsbFxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5BbnkgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLmlzSm9pID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdhbnknO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhbGlkcyA9IG5ldyBpbnRlcm5hbHMuU2V0KCk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRzID0gbmV3IGludGVybmFscy5TZXQoKTtcbiAgICAgICAgdGhpcy5fdGVzdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVmcyA9IFtdO1xuICAgICAgICB0aGlzLl9mbGFncyA9IHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsLCByZXF1aXJlZCwgZm9yYmlkZGVuLCBpZ25vcmVcbiAgICAgICAgICAgICBhbGxvd09ubHk6IGZhbHNlLFxuICAgICAgICAgICAgIGFsbG93VW5rbm93bjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICBmb3JiaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgIGVuY29kaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgaW5zZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgIHRyaW06IGZhbHNlLFxuICAgICAgICAgICAgIG5vcm1hbGl6ZTogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgICAvLyBORkMsIE5GRCwgTkZLQywgTkZLRFxuICAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cHBlciwgbG93ZXJcbiAgICAgICAgICAgICBlbXB0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgIGZ1bmM6IGZhbHNlLFxuICAgICAgICAgICAgIHJhdzogZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5pdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX25vdGVzID0gW107XG4gICAgICAgIHRoaXMuX3RhZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5fZXhhbXBsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbWV0YSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2lubmVyID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFzaCBvZiBhcnJheXMgb2YgaW1tdXRhYmxlIG9iamVjdHNcbiAgICB9XG5cbiAgICBfaW5pdCgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXQgc2NoZW1hVHlwZSgpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cbiAgICBjcmVhdGVFcnJvcih0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZmxhZ3MgPSB0aGlzLl9mbGFncykge1xuXG4gICAgICAgIHJldHVybiBFcnJvcnMuY3JlYXRlKHR5cGUsIGNvbnRleHQsIHN0YXRlLCBvcHRpb25zLCBmbGFncyk7XG4gICAgfVxuXG4gICAgY3JlYXRlT3ZlcnJpZGVFcnJvcih0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgbWVzc2FnZSwgdGVtcGxhdGUpIHtcblxuICAgICAgICByZXR1cm4gRXJyb3JzLmNyZWF0ZSh0eXBlLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MsIG1lc3NhZ2UsIHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICBjaGVja09wdGlvbnMob3B0aW9ucykge1xuXG4gICAgICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4uLy4uL3NjaGVtYXMnKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBTY2hlbWFzLm9wdGlvbnMudmFsaWRhdGUob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuXG4gICAgICAgIG9iai5pc0pvaSA9IHRydWU7XG4gICAgICAgIG9iai5fY3VycmVudEpvaSA9IHRoaXMuX2N1cnJlbnRKb2k7XG4gICAgICAgIG9iai5fdHlwZSA9IHRoaXMuX3R5cGU7XG4gICAgICAgIG9iai5fc2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5ncztcbiAgICAgICAgb2JqLl9iYXNlVHlwZSA9IHRoaXMuX2Jhc2VUeXBlO1xuICAgICAgICBvYmouX3ZhbGlkcyA9IHRoaXMuX3ZhbGlkcy5zbGljZSgpO1xuICAgICAgICBvYmouX2ludmFsaWRzID0gdGhpcy5faW52YWxpZHMuc2xpY2UoKTtcbiAgICAgICAgb2JqLl90ZXN0cyA9IHRoaXMuX3Rlc3RzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fcmVmcyA9IHRoaXMuX3JlZnMuc2xpY2UoKTtcbiAgICAgICAgb2JqLl9mbGFncyA9IEhvZWsuY2xvbmUodGhpcy5fZmxhZ3MpO1xuXG4gICAgICAgIG9iai5fZGVzY3JpcHRpb24gPSB0aGlzLl9kZXNjcmlwdGlvbjtcbiAgICAgICAgb2JqLl91bml0ID0gdGhpcy5fdW5pdDtcbiAgICAgICAgb2JqLl9ub3RlcyA9IHRoaXMuX25vdGVzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fdGFncyA9IHRoaXMuX3RhZ3Muc2xpY2UoKTtcbiAgICAgICAgb2JqLl9leGFtcGxlcyA9IHRoaXMuX2V4YW1wbGVzLnNsaWNlKCk7XG4gICAgICAgIG9iai5fbWV0YSA9IHRoaXMuX21ldGEuc2xpY2UoKTtcblxuICAgICAgICBvYmouX2lubmVyID0ge307XG4gICAgICAgIGNvbnN0IGlubmVycyA9IE9iamVjdC5rZXlzKHRoaXMuX2lubmVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGlubmVyc1tpXTtcbiAgICAgICAgICAgIG9iai5faW5uZXJba2V5XSA9IHRoaXMuX2lubmVyW2tleV0gPyB0aGlzLl9pbm5lcltrZXldLnNsaWNlKCkgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBjb25jYXQoc2NoZW1hKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hIGluc3RhbmNlb2YgaW50ZXJuYWxzLkFueSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0aGlzLl90eXBlID09PSAnYW55JyB8fCBzY2hlbWEuX3R5cGUgPT09ICdhbnknIHx8IHNjaGVtYS5fdHlwZSA9PT0gdGhpcy5fdHlwZSwgJ0Nhbm5vdCBtZXJnZSB0eXBlJywgdGhpcy5fdHlwZSwgJ3dpdGggYW5vdGhlciB0eXBlOicsIHNjaGVtYS5fdHlwZSk7XG5cbiAgICAgICAgbGV0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ2FueScgJiYgc2NoZW1hLl90eXBlICE9PSAnYW55Jykge1xuXG4gICAgICAgICAgICAvLyBSZXNldCB2YWx1ZXMgYXMgaWYgd2Ugd2VyZSBcInRoaXNcIlxuICAgICAgICAgICAgY29uc3QgdG1wT2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBjb25zdCBrZXlzVG9SZXN0b3JlID0gWydfc2V0dGluZ3MnLCAnX3ZhbGlkcycsICdfaW52YWxpZHMnLCAnX3Rlc3RzJywgJ19yZWZzJywgJ19mbGFncycsICdfZGVzY3JpcHRpb24nLCAnX3VuaXQnLFxuICAgICAgICAgICAgICAgICdfbm90ZXMnLCAnX3RhZ3MnLCAnX2V4YW1wbGVzJywgJ19tZXRhJywgJ19pbm5lciddO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNUb1Jlc3RvcmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0bXBPYmpba2V5c1RvUmVzdG9yZVtpXV0gPSBvYmpba2V5c1RvUmVzdG9yZVtpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iaiA9IHRtcE9iajtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5fc2V0dGluZ3MgPSBvYmouX3NldHRpbmdzID8gU2V0dGluZ3MuY29uY2F0KG9iai5fc2V0dGluZ3MsIHNjaGVtYS5fc2V0dGluZ3MpIDogc2NoZW1hLl9zZXR0aW5ncztcbiAgICAgICAgb2JqLl92YWxpZHMubWVyZ2Uoc2NoZW1hLl92YWxpZHMsIHNjaGVtYS5faW52YWxpZHMpO1xuICAgICAgICBvYmouX2ludmFsaWRzLm1lcmdlKHNjaGVtYS5faW52YWxpZHMsIHNjaGVtYS5fdmFsaWRzKTtcbiAgICAgICAgb2JqLl90ZXN0cy5wdXNoKC4uLnNjaGVtYS5fdGVzdHMpO1xuICAgICAgICBvYmouX3JlZnMucHVzaCguLi5zY2hlbWEuX3JlZnMpO1xuICAgICAgICBpZiAob2JqLl9mbGFncy5lbXB0eSAmJiBzY2hlbWEuX2ZsYWdzLmVtcHR5KSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gb2JqLl9mbGFncy5lbXB0eS5jb25jYXQoc2NoZW1hLl9mbGFncy5lbXB0eSk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgSG9lay5tZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLl9mbGFncy5lbXB0eSkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IHNjaGVtYS5fZmxhZ3MuZW1wdHk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgSG9lay5tZXJnZShvYmouX2ZsYWdzLCBmbGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBIb2VrLm1lcmdlKG9iai5fZmxhZ3MsIHNjaGVtYS5fZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9kZXNjcmlwdGlvbiA9IHNjaGVtYS5fZGVzY3JpcHRpb24gfHwgb2JqLl9kZXNjcmlwdGlvbjtcbiAgICAgICAgb2JqLl91bml0ID0gc2NoZW1hLl91bml0IHx8IG9iai5fdW5pdDtcbiAgICAgICAgb2JqLl9ub3Rlcy5wdXNoKC4uLnNjaGVtYS5fbm90ZXMpO1xuICAgICAgICBvYmouX3RhZ3MucHVzaCguLi5zY2hlbWEuX3RhZ3MpO1xuICAgICAgICBvYmouX2V4YW1wbGVzLnB1c2goLi4uc2NoZW1hLl9leGFtcGxlcyk7XG4gICAgICAgIG9iai5fbWV0YS5wdXNoKC4uLnNjaGVtYS5fbWV0YSk7XG5cbiAgICAgICAgY29uc3QgaW5uZXJzID0gT2JqZWN0LmtleXMoc2NoZW1hLl9pbm5lcik7XG4gICAgICAgIGNvbnN0IGlzT2JqZWN0ID0gb2JqLl90eXBlID09PSAnb2JqZWN0JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbm5lcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGlubmVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNjaGVtYS5faW5uZXJba2V5XTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBvYmouX2lubmVyW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QgJiYga2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFyZ2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c1t0YXJnZXRbal0ua2V5XSA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc291cmNlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlS2V5ID0gc291cmNlW2pdLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tzb3VyY2VLZXldID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleXNbc291cmNlS2V5XV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNvdXJjZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogdGFyZ2V0W2tleXNbc291cmNlS2V5XV0uc2NoZW1hLmNvbmNhdChzb3VyY2Vbal0uc2NoZW1hKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goc291cmNlW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouX2lubmVyW2tleV0gPSBvYmouX2lubmVyW2tleV0uY29uY2F0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5faW5uZXJba2V5XSA9IHNvdXJjZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX3Rlc3QobmFtZSwgYXJnLCBmdW5jLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3Rlc3RzLnB1c2goeyBmdW5jLCBuYW1lLCBhcmcsIG9wdGlvbnMgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX3Rlc3RVbmlxdWUobmFtZSwgYXJnLCBmdW5jLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3Rlc3RzID0gb2JqLl90ZXN0cy5maWx0ZXIoKHRlc3QpID0+IHRlc3QubmFtZSAhPT0gbmFtZSk7XG4gICAgICAgIG9iai5fdGVzdHMucHVzaCh7IGZ1bmMsIG5hbWUsIGFyZywgb3B0aW9ucyB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBvcHRpb25zKG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCghb3B0aW9ucy5jb250ZXh0LCAnQ2Fubm90IG92ZXJyaWRlIGNvbnRleHQnKTtcbiAgICAgICAgdGhpcy5jaGVja09wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3NldHRpbmdzID0gU2V0dGluZ3MuY29uY2F0KG9iai5fc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHN0cmljdChpc1N0cmljdCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBjb25zdCBjb252ZXJ0ID0gaXNTdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogIWlzU3RyaWN0O1xuICAgICAgICBvYmouX3NldHRpbmdzID0gU2V0dGluZ3MuY29uY2F0KG9iai5fc2V0dGluZ3MsIHsgY29udmVydCB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByYXcoaXNSYXcpIHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGlzUmF3ID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNSYXc7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnJhdyA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnJhdyA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGVycm9yKGVyciwgb3B0aW9ucyA9IHsgc2VsZjogZmFsc2UgfSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGVyciAmJiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVyciA9PT0gJ2Z1bmN0aW9uJyksICdNdXN0IHByb3ZpZGUgYSB2YWxpZCBFcnJvciBvYmplY3Qgb3IgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgIGNvbnN0IHVua25vd25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucykuZmlsdGVyKChrKSA9PiAhWydzZWxmJ10uaW5jbHVkZXMoaykpO1xuICAgICAgICBIb2VrLmFzc2VydCh1bmtub3duS2V5cy5sZW5ndGggPT09IDAsIGBPcHRpb25zICR7dW5rbm93bktleXN9IGFyZSB1bmtub3duYCk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmVycm9yID0gZXJyO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnNlbGYpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3Muc2VsZkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYWxsb3coLi4udmFsdWVzKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YWx1ZXMgPSBIb2VrLmZsYXR0ZW4odmFsdWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgYWxsb3cvdmFsaWQvaW52YWxpZCB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgb2JqLl9pbnZhbGlkcy5yZW1vdmUodmFsdWUpO1xuICAgICAgICAgICAgb2JqLl92YWxpZHMuYWRkKHZhbHVlLCBvYmouX3JlZnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB2YWxpZCguLi52YWx1ZXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmFsbG93KC4uLnZhbHVlcyk7XG4gICAgICAgIG9iai5fZmxhZ3MuYWxsb3dPbmx5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpbnZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgdmFsdWVzID0gSG9lay5mbGF0dGVuKHZhbHVlcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBjYWxsIGFsbG93L3ZhbGlkL2ludmFsaWQgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIG9iai5fdmFsaWRzLnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgICBvYmouX2ludmFsaWRzLmFkZCh2YWx1ZSwgb2JqLl9yZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgcmVxdWlyZWQoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5wcmVzZW5jZSA9ICdyZXF1aXJlZCc7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgb3B0aW9uYWwoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnByZXNlbmNlID09PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5wcmVzZW5jZSA9ICdvcHRpb25hbCc7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG5cbiAgICBmb3JiaWRkZW4oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnByZXNlbmNlID09PSAnZm9yYmlkZGVuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MucHJlc2VuY2UgPSAnZm9yYmlkZGVuJztcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cblxuICAgIHN0cmlwKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5zdHJpcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3Muc3RyaXAgPSB0cnVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGNoaWxkcmVuLCBmbiwgYXJncyA9IFtdLCByb290KSB7XG5cbiAgICAgICAgY2hpbGRyZW4gPSBbXS5jb25jYXQoY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgY2hpbGRyZW5bMF0gIT09ICcnKSB7XG4gICAgICAgICAgICByb290ID0gcm9vdCA/IChyb290ICsgJy4nKSA6ICcnO1xuXG4gICAgICAgICAgICBjb25zdCBleHRyYUNoaWxkcmVuID0gKGNoaWxkcmVuWzBdID09PSAnJyA/IGNoaWxkcmVuLnNsaWNlKDEpIDogY2hpbGRyZW4pLm1hcCgoY2hpbGQpID0+IHtcblxuICAgICAgICAgICAgICAgIHJldHVybiByb290ICsgY2hpbGQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGtleShzKSAnICsgZXh0cmFDaGlsZHJlbi5qb2luKCcsICcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzW2ZuXSguLi5hcmdzKTtcbiAgICB9XG5cbiAgICBkZWZhdWx0KHZhbHVlLCBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICFSZWYuaXNSZWYodmFsdWUpKSB7XG5cbiAgICAgICAgICAgIGlmICghdmFsdWUuZGVzY3JpcHRpb24gJiZcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgICAgICAgICAgdmFsdWUuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9mbGFncy5mdW5jKSB7XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHZhbHVlLmRlc2NyaXB0aW9uID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5kZXNjcmlwdGlvbi5sZW5ndGggPiAwLCAnZGVzY3JpcHRpb24gbXVzdCBiZSBwcm92aWRlZCB3aGVuIGRlZmF1bHQgdmFsdWUgaXMgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmRlZmF1bHQgPSB2YWx1ZTtcbiAgICAgICAgUmVmLnB1c2gob2JqLl9yZWZzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZW1wdHkoc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmouX2ZsYWdzLmVtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5lbXB0eSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHdoZW4oY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIG9wdGlvbnMnKTtcbiAgICAgICAgSG9lay5hc3NlcnQob3B0aW9ucy50aGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5vdGhlcndpc2UgIT09IHVuZGVmaW5lZCwgJ29wdGlvbnMgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBvZiBcInRoZW5cIiBvciBcIm90aGVyd2lzZVwiJyk7XG5cbiAgICAgICAgY29uc3QgdGhlbiA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ3RoZW4nKSA/IHRoaXMuY29uY2F0KENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIG9wdGlvbnMudGhlbikpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBvdGhlcndpc2UgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdvdGhlcndpc2UnKSA/IHRoaXMuY29uY2F0KENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIG9wdGlvbnMub3RoZXJ3aXNlKSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgQWx0ZXJuYXRpdmVzID0gQWx0ZXJuYXRpdmVzIHx8IHJlcXVpcmUoJy4uL2FsdGVybmF0aXZlcycpO1xuXG4gICAgICAgIGNvbnN0IGFsdGVybmF0aXZlT3B0aW9ucyA9IHsgdGhlbiwgb3RoZXJ3aXNlIH07XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2lzJykpIHtcbiAgICAgICAgICAgIGFsdGVybmF0aXZlT3B0aW9ucy5pcyA9IG9wdGlvbnMuaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSBBbHRlcm5hdGl2ZXMud2hlbihjb25kaXRpb24sIGFsdGVybmF0aXZlT3B0aW9ucyk7XG4gICAgICAgIG9iai5fZmxhZ3MucHJlc2VuY2UgPSAnaWdub3JlJztcbiAgICAgICAgb2JqLl9iYXNlVHlwZSA9IHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBkZXNjcmlwdGlvbihkZXNjKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoZGVzYyAmJiB0eXBlb2YgZGVzYyA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9kZXNjcmlwdGlvbiA9IGRlc2M7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbm90ZXMobm90ZXMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChub3RlcyAmJiAodHlwZW9mIG5vdGVzID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG5vdGVzKSksICdOb3RlcyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZyBvciBhcnJheScpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9ub3RlcyA9IG9iai5fbm90ZXMuY29uY2F0KG5vdGVzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0YWdzKHRhZ3MpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0YWdzICYmICh0eXBlb2YgdGFncyA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheSh0YWdzKSksICdUYWdzIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIGFycmF5Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX3RhZ3MgPSBvYmouX3RhZ3MuY29uY2F0KHRhZ3MpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1ldGEobWV0YSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG1ldGEgIT09IHVuZGVmaW5lZCwgJ01ldGEgY2Fubm90IGJlIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9tZXRhID0gb2JqLl9tZXRhLmNvbmNhdChtZXRhKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBleGFtcGxlKC4uLmV4YW1wbGVzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoZXhhbXBsZXMubGVuZ3RoID4gMCwgJ01pc3NpbmcgZXhhbXBsZXMnKTtcblxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGFtcGxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IFtdLmNvbmNhdChleGFtcGxlc1tpXSk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydChleGFtcGxlLmxlbmd0aCA8PSAyLCBgQmFkIGV4YW1wbGUgZm9ybWF0IGF0IGluZGV4ICR7aX1gKTtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBleGFtcGxlWzBdO1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBleGFtcGxlWzFdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCBgT3B0aW9ucyBmb3IgZXhhbXBsZSBhdCBpbmRleCAke2l9IG11c3QgYmUgYW4gb2JqZWN0YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5rbm93bk9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKG9wdGlvbikgPT4gIVsncGFyZW50JywgJ2NvbnRleHQnXS5pbmNsdWRlcyhvcHRpb24pKTtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh1bmtub3duT3B0aW9ucy5sZW5ndGggPT09IDAsIGBVbmtub3duIGV4YW1wbGUgb3B0aW9ucyAke3Vua25vd25PcHRpb25zfSBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBuZXcgU3RhdGUoJycsIFtdLCBvcHRpb25zLnBhcmVudCB8fCBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBTZXR0aW5ncy5jb25jYXQoaW50ZXJuYWxzLmRlZmF1bHRzLCBvcHRpb25zLmNvbnRleHQgPyB7IGNvbnRleHQ6IG9wdGlvbnMuY29udGV4dCB9IDogbnVsbCkpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoIXJlc3VsdC5lcnJvcnMsIGBCYWQgZXhhbXBsZSBhdCBpbmRleCAke2l9OmAsIHJlc3VsdC5lcnJvcnMgJiYgRXJyb3JzLnByb2Nlc3MocmVzdWx0LmVycm9ycywgdmFsdWUpKTtcblxuICAgICAgICAgICAgY29uc3QgZXggPSB7IHZhbHVlIH07XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXgub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9leGFtcGxlcyA9IHByb2Nlc3NlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB1bml0KG5hbWUpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ1VuaXQgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl91bml0ID0gbmFtZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfcHJlcGFyZUVtcHR5VmFsdWUodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB0aGlzLl9mbGFncy50cmltKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMsIHJlZmVyZW5jZSkge1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBTZXR1cCBzdGF0ZSBhbmQgc2V0dGluZ3NcblxuICAgICAgICBzdGF0ZSA9IHN0YXRlIHx8IG5ldyBTdGF0ZSgnJywgW10sIG51bGwsIHJlZmVyZW5jZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCBpc0RlZmF1bHRPcHRpb25zID0gb3B0aW9ucyA9PT0gaW50ZXJuYWxzLmRlZmF1bHRzO1xuICAgICAgICAgICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMgJiYgdGhpcy5fc2V0dGluZ3NbU3ltYm9scy5zZXR0aW5nc0NhY2hlXSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGlzLl9zZXR0aW5nc1tTeW1ib2xzLnNldHRpbmdzQ2FjaGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IFNldHRpbmdzLmNvbmNhdCh0aGlzLl9sYW5ndWFnZSA/IFNldHRpbmdzLmNvbmNhdCh7IGxhbmd1YWdlOiB0aGlzLl9sYW5ndWFnZSB9LCBvcHRpb25zKSA6IG9wdGlvbnMsIHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0aW5nc1tTeW1ib2xzLnNldHRpbmdzQ2FjaGVdID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBTZXR0aW5ncy5jb25jYXQoeyBsYW5ndWFnZTogdGhpcy5fbGFuZ3VhZ2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXJyb3JzID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvZXJjZSkge1xuICAgICAgICAgICAgY29uc3QgY29lcmNlZCA9IHRoaXMuX2NvZXJjZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGNvZXJjZWQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2VyY2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoY29lcmNlZC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlZCBlcnJvciBhbHdheXMgYWJvcnRzIGVhcmx5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5lbXB0eSAmJiAhdGhpcy5fZmxhZ3MuZW1wdHkuX3ZhbGlkYXRlKHRoaXMuX3ByZXBhcmVFbXB0eVZhbHVlKHZhbHVlKSwgbnVsbCwgaW50ZXJuYWxzLmRlZmF1bHRzKS5lcnJvcnMpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2UgcmVxdWlyZW1lbnRzXG5cbiAgICAgICAgY29uc3QgcHJlc2VuY2UgPSB0aGlzLl9mbGFncy5wcmVzZW5jZSB8fCBvcHRpb25zLnByZXNlbmNlO1xuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdvcHRpb25hbCcpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEZWVwRGVmYXVsdCA9IHRoaXMuX2ZsYWdzLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgJiYgdGhpcy5fZmxhZ3MuZGVmYXVsdCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZXBEZWZhdWx0ICYmIHRoaXMuX3R5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXNlbmNlID09PSAncmVxdWlyZWQnICYmXG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FueS5yZXF1aXJlZCcsIG51bGwsIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYW55LnVua25vd24nLCBudWxsLCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgYWxsb3dlZCBhbmQgZGVuaWVkIHZhbHVlcyB1c2luZyB0aGUgb3JpZ2luYWwgdmFsdWVcblxuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLl92YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnZlcnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW52YWxpZHMuaGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKHZhbHVlID09PSAnJyA/ICdhbnkuZW1wdHknIDogJ2FueS5pbnZhbGlkJywgeyB2YWx1ZSwgaW52YWxpZHM6IHRoaXMuX2ludmFsaWRzLnZhbHVlcyh7IHN0cmlwVW5kZWZpbmVkOiB0cnVlIH0pIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IHZhbHVlIGFuZCB2YWxpZGF0ZSB0eXBlXG5cbiAgICAgICAgaWYgKHRoaXMuX2Jhc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoYmFzZS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2UudmFsdWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChiYXNlLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJhc2UudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWxsb3dlZCBhbmQgZGVuaWVkIHZhbHVlcyB1c2luZyB0aGUgY29udmVydGVkIHZhbHVlXG5cbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRoaXMuX3ZhbGlkcy5nZXQodmFsdWUsIHN0YXRlLCBvcHRpb25zLCB0aGlzLl9mbGFncy5pbnNlbnNpdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2gudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVZhbHVlKHZhbHVlLCBvcmlnaW5hbFZhbHVlLCBlcnJvcnMsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW52YWxpZHMuaGFzKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucywgdGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IodmFsdWUgPT09ICcnID8gJ2FueS5lbXB0eScgOiAnYW55LmludmFsaWQnLCB7IHZhbHVlLCBpbnZhbGlkczogdGhpcy5faW52YWxpZHMudmFsdWVzKHsgc3RyaXBVbmRlZmluZWQ6IHRydWUgfSkgfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWlyZWQgdmFsdWVzIGRpZCBub3QgbWF0Y2hcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuYWxsb3dPbmx5KSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhbnkuYWxsb3dPbmx5JywgeyB2YWx1ZSwgdmFsaWRzOiB0aGlzLl92YWxpZHMudmFsdWVzKHsgc3RyaXBVbmRlZmluZWQ6IHRydWUgfSkgfSwgc3RhdGUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSB0ZXN0c1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdGVzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0aGlzLl90ZXN0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRlc3QuZnVuYy5jYWxsKHRoaXMsIHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3JzLkVycikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJldCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVWYWx1ZSh2YWx1ZSwgb3JpZ2luYWxWYWx1ZSwgZXJyb3JzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX2ZpbmFsaXplVmFsdWUodmFsdWUsIG9yaWdpbmFsVmFsdWUsIGVycm9ycywgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgZmluYWxWYWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuX2ZsYWdzLnJhdyA/IG9yaWdpbmFsVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLm5vRGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChSZWYuaXNSZWYodGhpcy5fZmxhZ3MuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLl9mbGFncy5kZWZhdWx0KHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXMuX2ZsYWdzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICEodGhpcy5fZmxhZ3MuZnVuYyAmJiAhdGhpcy5fZmxhZ3MuZGVmYXVsdC5kZXNjcmlwdGlvbikpIHtcblxuICAgICAgICAgICAgbGV0IGFyZ3M7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5wYXJlbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mbGFncy5kZWZhdWx0Lmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbSG9lay5jbG9uZShzdGF0ZS5wYXJlbnQpLCBvcHRpb25zXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gaW50ZXJuYWxzLl90cnkodGhpcy5fZmxhZ3MuZGVmYXVsdCwgYXJncyk7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gZGVmYXVsdFZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRWYWx1ZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FueS5kZWZhdWx0JywgeyBlcnJvcjogZGVmYXVsdFZhbHVlLmVycm9yIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gSG9lay5jbG9uZSh0aGlzLl9mbGFncy5kZWZhdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAhdGhpcy5fZmxhZ3Muc2VsZkVycm9yIHx8XG4gICAgICAgICAgICAgICAgZXJyb3JzLnNvbWUoKGUpID0+IHN0YXRlLnBhdGgubGVuZ3RoID09PSBlLnBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHRoaXMuX2ZsYWdzLmVycm9yLmNhbGwodGhpcywgZXJyb3JzKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW3RoaXMuY3JlYXRlT3ZlcnJpZGVFcnJvcignb3ZlcnJpZGUnLCB7IHJlYXNvbjogZXJyb3JzIH0sIHN0YXRlLCBvcHRpb25zLCBjaGFuZ2UpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IFtdLmNvbmNhdChjaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGVycikgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgRXJyb3IgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVPdmVycmlkZUVycm9yKGVyci50eXBlIHx8ICdvdmVycmlkZScsIGVyci5jb250ZXh0LCBzdGF0ZSwgb3B0aW9ucywgZXJyLm1lc3NhZ2UsIGVyci50ZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLl9mbGFncy5zdHJpcCA/IHVuZGVmaW5lZCA6IGZpbmFsVmFsdWUsXG4gICAgICAgICAgICBmaW5hbFZhbHVlLFxuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF92YWxpZGF0ZVdpdGhPcHRpb25zKHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gU2V0dGluZ3MuY29uY2F0KGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3ZhbGlkYXRlKHZhbHVlLCBudWxsLCBzZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IEVycm9ycy5wcm9jZXNzKHJlc3VsdC5lcnJvcnMsIHZhbHVlKTtcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9ycyxcbiAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JzKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0LnZhbHVlKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGNoKHJlamVjdCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JzKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVdpdGhPcHRpb25zKHZhbHVlLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZVdpdGhPcHRpb25zKHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLl90eXBlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3Qua2V5cyh0aGlzLl9mbGFncyk7XG4gICAgICAgIGlmIChmbGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChbJ2VtcHR5JywgJ2RlZmF1bHQnLCAnbGF6eScsICdsYWJlbCddLnNvbWUoKGZsYWcpID0+IHRoaXMuX2ZsYWdzLmhhc093blByb3BlcnR5KGZsYWcpKSkge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFnID09PSAnZW1wdHknKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFnc1tmbGFnXSA9IHRoaXMuX2ZsYWdzW2ZsYWddLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmxhZyA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUmVmLmlzUmVmKHRoaXMuX2ZsYWdzW2ZsYWddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzW2ZsYWddID0gdGhpcy5fZmxhZ3NbZmxhZ10udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9mbGFnc1tmbGFnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzW2ZsYWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5fZmxhZ3NbZmxhZ10uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICAgOiB0aGlzLl9mbGFnc1tmbGFnXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5mbGFnc1tmbGFnXSA9IHRoaXMuX2ZsYWdzW2ZsYWddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZsYWcgPT09ICdsYXp5JyB8fCBmbGFnID09PSAnbGFiZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IGl0IGluIHRoZSBkZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24uZmxhZ3NbZmxhZ10gPSB0aGlzLl9mbGFnc1tmbGFnXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmZsYWdzID0gdGhpcy5fZmxhZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLm9wdGlvbnMgPSBIb2VrLmNsb25lKHRoaXMuX3NldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9iYXNlVHlwZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uYmFzZSA9IHRoaXMuX2Jhc2VUeXBlLmRlc2NyaWJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmRlc2NyaXB0aW9uID0gdGhpcy5fZGVzY3JpcHRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbm90ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5ub3RlcyA9IHRoaXMuX25vdGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3RhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi50YWdzID0gdGhpcy5fdGFncztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tZXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24ubWV0YSA9IHRoaXMuX21ldGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZXhhbXBsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5leGFtcGxlcyA9IHRoaXMuX2V4YW1wbGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3VuaXQpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnVuaXQgPSB0aGlzLl91bml0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsaWRzID0gdGhpcy5fdmFsaWRzLnZhbHVlcygpO1xuICAgICAgICBpZiAodmFsaWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24udmFsaWRzID0gdmFsaWRzLm1hcCgodikgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZi5pc1JlZih2KSA/IHYudG9TdHJpbmcoKSA6IHY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGludmFsaWRzID0gdGhpcy5faW52YWxpZHMudmFsdWVzKCk7XG4gICAgICAgIGlmIChpbnZhbGlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmludmFsaWRzID0gaW52YWxpZHMubWFwKCh2KSA9PiB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUmVmLmlzUmVmKHYpID8gdi50b1N0cmluZygpIDogdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzY3JpcHRpb24ucnVsZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3Rlc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSB0aGlzLl90ZXN0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7IG5hbWU6IHZhbGlkYXRvci5uYW1lIH07XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IuYXJnICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFyZyA9IFJlZi5pc1JlZih2YWxpZGF0b3IuYXJnKSA/IHZhbGlkYXRvci5hcmcudG9TdHJpbmcoKSA6IHZhbGlkYXRvci5hcmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2YWxpZGF0b3Iub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXJnID0ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWxpZGF0b3IuYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxpZGF0b3IuYXJnW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFyZ1trZXldID0gUmVmLmlzUmVmKHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmRlc2NyaXB0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uKGl0ZW0uYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnJ1bGVzLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlc2NyaXB0aW9uLnJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVsZXRlIGRlc2NyaXB0aW9uLnJ1bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLl9nZXRMYWJlbCgpO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgbGFiZWwobmFtZSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnTGFiZWwgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5sYWJlbCA9IG5hbWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2dldExhYmVsKGRlZikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9mbGFncy5sYWJlbCB8fCBkZWY7XG4gICAgfVxuXG59O1xuXG5cbmludGVybmFscy5BbnkucHJvdG90eXBlLmlzSW1tdXRhYmxlID0gdHJ1ZTsgICAgIC8vIFByZXZlbnRzIEhvZWsgZnJvbSBkZWVwIGNsb25pbmcgc2NoZW1hIG9iamVjdHNcblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuQW55LnByb3RvdHlwZS5vbmx5ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUuZXF1YWwgPSBpbnRlcm5hbHMuQW55LnByb3RvdHlwZS52YWxpZDtcbmludGVybmFscy5BbnkucHJvdG90eXBlLmRpc2FsbG93ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUubm90ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUuaW52YWxpZDtcbmludGVybmFscy5BbnkucHJvdG90eXBlLmV4aXN0ID0gaW50ZXJuYWxzLkFueS5wcm90b3R5cGUucmVxdWlyZWQ7XG5cblxuaW50ZXJuYWxzLkFueS5wcm90b3R5cGVbaW50ZXJuYWxzLnN5bWJvbF0gPSB7XG4gICAgdmVyc2lvbjogUGtnLnZlcnNpb24sXG4gICAgY29tcGlsZTogQ2FzdC5zY2hlbWEsXG4gICAgcm9vdDogJ19jdXJyZW50Sm9pJ1xufTtcblxuXG5pbnRlcm5hbHMuX3RyeSA9IGZ1bmN0aW9uIChmbiwgYXJncyA9IFtdKSB7XG5cbiAgICBsZXQgZXJyO1xuICAgIGxldCByZXN1bHQ7XG5cbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyID0gZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuLi9zeW1ib2xzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5jb25jYXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcblxuICAgIGNvbnN0IGxhbmd1YWdlID0gc291cmNlLmxhbmd1YWdlO1xuXG4gICAgT2JqZWN0LmFzc2lnbihvYmosIHNvdXJjZSk7XG5cbiAgICBpZiAobGFuZ3VhZ2UgJiYgdGFyZ2V0ICYmIHRhcmdldC5sYW5ndWFnZSkge1xuICAgICAgICBvYmoubGFuZ3VhZ2UgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyh0YXJnZXQubGFuZ3VhZ2UsIGxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICBpZiAob2JqW1N5bWJvbHMuc2V0dGluZ3NDYWNoZV0pIHtcbiAgICAgICAgZGVsZXRlIG9ialtTeW1ib2xzLnNldHRpbmdzQ2FjaGVdO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb3VybmUgPSByZXF1aXJlKCdAaGFwaS9ib3VybmUnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuY29uc3QgQ2FzdCA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uLy4uL3JlZicpO1xuY29uc3QgU3RhdGUgPSByZXF1aXJlKCcuLi9zdGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5mYXN0U3BsaWNlID0gZnVuY3Rpb24gKGFyciwgaSkge1xuXG4gICAgbGV0IHBvcyA9IGk7XG4gICAgd2hpbGUgKHBvcyA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgYXJyW3BvcysrXSA9IGFycltwb3NdO1xuICAgIH1cblxuICAgIC0tYXJyLmxlbmd0aDtcbn07XG5cblxuaW50ZXJuYWxzLkFycmF5ID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdhcnJheSc7XG4gICAgICAgIHRoaXMuX2lubmVyLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMuX2lubmVyLm9yZGVyZWRzID0gW107XG4gICAgICAgIHRoaXMuX2lubmVyLmluY2x1c2lvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5uZXIuZXhjbHVzaW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9pbm5lci5yZXF1aXJlZHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZmxhZ3Muc3BhcnNlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlWzBdID09PSAnWycgfHwgL15cXHMqXFxbLy50ZXN0KHZhbHVlKSkpIHtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IEJvdXJuZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShyZXN1bHQudmFsdWUpO1xuICAgICAgICBjb25zdCB3YXNBcnJheSA9IGlzQXJyYXk7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnZlcnQgJiYgdGhpcy5fZmxhZ3Muc2luZ2xlICYmICFpc0FycmF5KSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSBbcmVzdWx0LnZhbHVlXTtcbiAgICAgICAgICAgIGlzQXJyYXkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkuYmFzZScsIG51bGwsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuaW5jbHVzaW9ucy5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuX2lubmVyLmV4Y2x1c2lvbnMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLl9pbm5lci5yZXF1aXJlZHMubGVuZ3RoIHx8XG4gICAgICAgICAgICB0aGlzLl9pbm5lci5vcmRlcmVkcy5sZW5ndGggfHxcbiAgICAgICAgICAgICF0aGlzLl9mbGFncy5zcGFyc2UpIHtcblxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGFycmF5IHNvIHRoYXQgd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgaWYgKHdhc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gcmVzdWx0LnZhbHVlLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5fY2hlY2tJdGVtcyhyZXN1bHQudmFsdWUsIHdhc0FycmF5LCBzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmIHdhc0FycmF5ICYmIG9wdGlvbnMuY29udmVydCAmJiB0aGlzLl9mbGFncy5zaW5nbGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgYSAybmQgcGFzcyBieSBwdXR0aW5nIHRoZSBhcnJheSBpbnNpZGUgb25lLlxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JzID0gcmVzdWx0LmVycm9ycztcblxuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IFtyZXN1bHQudmFsdWVdO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLl9jaGVja0l0ZW1zKHJlc3VsdC52YWx1ZSwgd2FzQXJyYXksIHN0YXRlLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBwcmV2aW91cyBlcnJvcnMgYW5kIHZhbHVlIHNpbmNlIHRoaXMgZGlkbid0IHZhbGlkYXRlIGVpdGhlci5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHByZXZpb3VzRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSByZXN1bHQudmFsdWVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBfY2hlY2tJdGVtcyhpdGVtcywgd2FzQXJyYXksIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGxldCBlcnJvcmVkO1xuXG4gICAgICAgIGNvbnN0IHJlcXVpcmVkcyA9IHRoaXMuX2lubmVyLnJlcXVpcmVkcy5zbGljZSgpO1xuICAgICAgICBjb25zdCBvcmRlcmVkcyA9IHRoaXMuX2lubmVyLm9yZGVyZWRzLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IGluY2x1c2lvbnMgPSBbLi4udGhpcy5faW5uZXIuaW5jbHVzaW9ucywgLi4ucmVxdWlyZWRzXTtcblxuICAgICAgICBsZXQgaWwgPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgZXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHdhc0FycmF5ID8gaSA6IHN0YXRlLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3YXNBcnJheSA/IFsuLi5zdGF0ZS5wYXRoLCBpXSA6IHN0YXRlLnBhdGg7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKGtleSwgcGF0aCwgc3RhdGUucGFyZW50LCBzdGF0ZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgbGV0IHJlcztcblxuICAgICAgICAgICAgLy8gU3BhcnNlXG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZmxhZ3Muc3BhcnNlICYmIGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnNwYXJzZScsIG51bGwsIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCwgcG9zOiBpIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcmRlcmVkcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4Y2x1c2lvbnNcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9pbm5lci5leGNsdXNpb25zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gdGhpcy5faW5uZXIuZXhjbHVzaW9uc1tqXS5fdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwge30pOyAgICAgICAgICAgICAgICAvLyBOb3QgcGFzc2luZyBvcHRpb25zIHRvIHVzZSBkZWZhdWx0c1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3Iod2FzQXJyYXkgPyAnYXJyYXkuZXhjbHVkZXMnIDogJ2FycmF5LmV4Y2x1ZGVzU2luZ2xlJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvcmRlcmVkcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3JkZXJlZFxuICAgICAgICAgICAgaWYgKHRoaXMuX2lubmVyLm9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWQgPSBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXMgPSBvcmRlcmVkLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JkZXJlZC5fZmxhZ3Muc3RyaXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShpdGVtcywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5fZmxhZ3Muc3BhcnNlICYmIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkuc3BhcnNlJywgbnVsbCwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoLCBwb3M6IGkgfSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5vcmRlcmVkJywgeyBwb3M6IGksIHJlYXNvbjogcmVzLmVycm9ycywgdmFsdWU6IGl0ZW0gfSwgeyBrZXk6IHN0YXRlLmtleSwgcGF0aDogbG9jYWxTdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9pbm5lci5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkub3JkZXJlZExlbmd0aCcsIHsgcG9zOiBpLCBsaW1pdDogdGhpcy5faW5uZXIub3JkZXJlZHMubGVuZ3RoIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlcXVpcmVkc1xuXG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZENoZWNrcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGpsID0gcmVxdWlyZWRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcXVpcmVkQ2hlY2tzW2pdID0gcmVxdWlyZWRzW2pdLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZShyZXF1aXJlZHMsIGopO1xuICAgICAgICAgICAgICAgICAgICAtLWo7XG4gICAgICAgICAgICAgICAgICAgIC0tamw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9mbGFncy5zcGFyc2UgJiYgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnNwYXJzZScsIG51bGwsIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IGxvY2FsU3RhdGUucGF0aCwgcG9zOiBpIH0sIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluY2x1c2lvbnNcblxuICAgICAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gb3B0aW9ucy5zdHJpcFVua25vd24gJiYgISFvcHRpb25zLnN0cmlwVW5rbm93bi5hcnJheXMgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgIGpsID0gaW5jbHVzaW9ucy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGpsOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmNsdXNpb24gPSBpbmNsdXNpb25zW2pdO1xuXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgcmUtcnVubmluZyByZXF1aXJlZHMgdGhhdCBhbHJlYWR5IGRpZG4ndCBtYXRjaCBpbiB0aGUgcHJldmlvdXMgbG9vcFxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2hlY2sgPSByZXF1aXJlZHMuaW5kZXhPZihpbmNsdXNpb24pO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NoZWNrICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXF1aXJlZENoZWNrc1twcmV2aW91c0NoZWNrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGluY2x1c2lvbi5fdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVzaW9uLl9mbGFncy5zdHJpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKGl0ZW1zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9mbGFncy5zcGFyc2UgJiYgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5zcGFyc2UnLCBudWxsLCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGgsIHBvczogaSB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXSA9IHJlcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYWN0dWFsIGVycm9yIGlmIG9ubHkgb25lIGluY2x1c2lvbiBkZWZpbmVkXG4gICAgICAgICAgICAgICAgaWYgKGpsID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKGl0ZW1zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcih3YXNBcnJheSA/ICdhcnJheS5pbmNsdWRlc09uZScgOiAnYXJyYXkuaW5jbHVkZXNPbmVTaW5nbGUnLCB7IHBvczogaSwgcmVhc29uOiByZXMuZXJyb3JzLCB2YWx1ZTogaXRlbSB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5faW5uZXIuaW5jbHVzaW9ucy5sZW5ndGggJiYgIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKGl0ZW1zLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKHdhc0FycmF5ID8gJ2FycmF5LmluY2x1ZGVzJyA6ICdhcnJheS5pbmNsdWRlc1NpbmdsZScsIHsgcG9zOiBpLCB2YWx1ZTogaXRlbSB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBsb2NhbFN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXF1aXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsTWlzc2VkRXJyb3JzKGVycm9ycywgcmVxdWlyZWRzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsT3JkZXJlZEVycm9ycyhlcnJvcnMsIG9yZGVyZWRzLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXJyb3JzLmxlbmd0aCA/IGVycm9ycyA6IG51bGw7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzdXBlci5kZXNjcmliZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbm5lci5vcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLm9yZGVyZWRJdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLm9yZGVyZWRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24ub3JkZXJlZEl0ZW1zLnB1c2godGhpcy5faW5uZXIub3JkZXJlZHNbaV0uZGVzY3JpYmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5pdGVtcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24uaXRlbXMucHVzaCh0aGlzLl9pbm5lci5pdGVtc1tpXS5kZXNjcmliZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbi5ydWxlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcmlwdGlvbi5ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBkZXNjcmlwdGlvbi5ydWxlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5uYW1lID09PSAnaGFzJykge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmFyZyA9IHJ1bGUuYXJnLmRlc2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIGl0ZW1zKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgSG9lay5mbGF0dGVuKHNjaGVtYXMpLmZvckVhY2goKHR5cGUsIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IENhc3Quc2NoZW1hKHRoaXMuX2N1cnJlbnRKb2ksIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FzdEVyci5oYXNPd25Qcm9wZXJ0eSgncGF0aCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc3RFcnIucGF0aCA9IGluZGV4ICsgJy4nICsgY2FzdEVyci5wYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzdEVyci5wYXRoID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzdEVyci5tZXNzYWdlID0gYCR7Y2FzdEVyci5tZXNzYWdlfSgke2Nhc3RFcnIucGF0aH0pYDtcbiAgICAgICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouX2lubmVyLml0ZW1zLnB1c2godHlwZSk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlLl9mbGFncy5wcmVzZW5jZSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgICAgIG9iai5faW5uZXIucmVxdWlyZWRzLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlLl9mbGFncy5wcmVzZW5jZSA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgICAgICAgICBvYmouX2lubmVyLmV4Y2x1c2lvbnMucHVzaCh0eXBlLm9wdGlvbmFsKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqLl9pbm5lci5pbmNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgb3JkZXJlZCguLi5zY2hlbWFzKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIEhvZWsuZmxhdHRlbihzY2hlbWFzKS5mb3JFYWNoKCh0eXBlLCBpbmRleCkgPT4ge1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXN0RXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhc3RFcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RXJyLnBhdGggPSBpbmRleCArICcuJyArIGNhc3RFcnIucGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc3RFcnIucGF0aCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc3RFcnIubWVzc2FnZSA9IGAke2Nhc3RFcnIubWVzc2FnZX0oJHtjYXN0RXJyLnBhdGh9KWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgY2FzdEVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9pbm5lci5vcmRlcmVkcy5wdXNoKHR5cGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1pbihsaW1pdCkge1xuXG4gICAgICAgIGNvbnN0IGlzUmVmID0gUmVmLmlzUmVmKGxpbWl0KTtcblxuICAgICAgICBIb2VrLmFzc2VydCgoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpICYmIGxpbWl0ID49IDApIHx8IGlzUmVmLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgcmVmZXJlbmNlJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3RVbmlxdWUoJ21pbicsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGxldCBjb21wYXJlVG87XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdChzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICghKE51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbXBhcmVUbykgJiYgY29tcGFyZVRvID49IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5yZWYnLCB7IHJlZjogbGltaXQsIHZhbHVlOiBjb21wYXJlVG8gfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IGNvbXBhcmVUbykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5Lm1pbicsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWF4KGxpbWl0KSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYobGltaXQpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCkgfHwgaXNSZWYsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciByZWZlcmVuY2UnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdFVuaXF1ZSgnbWF4JywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgbGV0IGNvbXBhcmVUbztcbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0KHN0YXRlLnJlZmVyZW5jZSB8fCBzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoTnVtYmVyLmlzU2FmZUludGVnZXIoY29tcGFyZVRvKSAmJiBjb21wYXJlVG8gPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnJlZicsIHsgcmVmOiBsaW1pdC5rZXkgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IGNvbXBhcmVUbykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5Lm1heCcsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGVuZ3RoKGxpbWl0KSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYobGltaXQpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCkgfHwgaXNSZWYsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciByZWZlcmVuY2UnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdFVuaXF1ZSgnbGVuZ3RoJywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgbGV0IGNvbXBhcmVUbztcbiAgICAgICAgICAgIGlmIChpc1JlZikge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0KHN0YXRlLnJlZmVyZW5jZSB8fCBzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoTnVtYmVyLmlzU2FmZUludGVnZXIoY29tcGFyZVRvKSAmJiBjb21wYXJlVG8gPj0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnJlZicsIHsgcmVmOiBsaW1pdC5rZXkgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBjb21wYXJlVG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5sZW5ndGgnLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhcyhzY2hlbWEpIHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2NoZW1hID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2FzdEVycikge1xuICAgICAgICAgICAgaWYgKGNhc3RFcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgIGNhc3RFcnIubWVzc2FnZSA9IGAke2Nhc3RFcnIubWVzc2FnZX0oJHtjYXN0RXJyLnBhdGh9KWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGNhc3RFcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnaGFzJywgc2NoZW1hLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWx1ZS5zb21lKChpdGVtLCBpZHgpID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBuZXcgU3RhdGUoaWR4LCBbLi4uc3RhdGUucGF0aCwgaWR4XSwgc3RhdGUua2V5LCBzdGF0ZS5yZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhc2NoZW1hLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBvcHRpb25zKS5lcnJvcnM7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5MYWJlbCA9IHNjaGVtYS5fZ2V0TGFiZWwoKTtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuTGFiZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkuaGFzS25vd24nLCB7IHBhdHRlcm5MYWJlbCB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdhcnJheS5oYXNVbmtub3duJywgbnVsbCwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bmlxdWUoY29tcGFyYXRvciwgY29uZmlncykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGNvbXBhcmF0b3IgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgdHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJywgJ2NvbXBhcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoY29uZmlncyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0eXBlb2YgY29uZmlncyA9PT0gJ29iamVjdCcsICdjb25maWdzIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBpZ25vcmVVbmRlZmluZWQ6IChjb25maWdzICYmIGNvbmZpZ3MuaWdub3JlVW5kZWZpbmVkKSB8fCBmYWxzZVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0dGluZ3MucGF0aCA9IGNvbXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3VuaXF1ZScsIHNldHRpbmdzLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0ge1xuICAgICAgICAgICAgICAgIHN0cmluZzogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICBudW1iZXI6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgIGJvb2xlYW46IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IG5ldyBNYXAoKSxcbiAgICAgICAgICAgICAgICBjdXN0b206IG5ldyBNYXAoKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY29uc3QgY29tcGFyZSA9IHNldHRpbmdzLmNvbXBhcmF0b3IgfHwgSG9lay5kZWVwRXF1YWw7XG4gICAgICAgICAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSBzZXR0aW5ncy5pZ25vcmVVbmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gc2V0dGluZ3MucGF0aCA/IEhvZWsucmVhY2godmFsdWVbaV0sIHNldHRpbmdzLnBhdGgpIDogdmFsdWVbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IHNldHRpbmdzLmNvbXBhcmF0b3IgPyBmb3VuZC5jdXN0b20gOiBmb3VuZFt0eXBlb2YgaXRlbV07XG5cbiAgICAgICAgICAgICAgICAvLyBBbGwgYXZhaWxhYmxlIHR5cGVzIGFyZSBzdXBwb3J0ZWQsIHNvIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHJlYWNoIDEwMCUgY292ZXJhZ2Ugd2l0aG91dCBpZ25vcmluZyB0aGlzIGxpbmUuXG4gICAgICAgICAgICAgICAgLy8gSSBzdGlsbCB3YW50IHRvIGtlZXAgdGhlIHRlc3QgZm9yIGZ1dHVyZSBqcyB2ZXJzaW9ucyB3aXRoIG5ldyB0eXBlcyAoZWcuIFN5bWJvbCkuXG4gICAgICAgICAgICAgICAgaWYgKC8qICRsYWI6Y292ZXJhZ2U6b2ZmJCAqLyByZWNvcmRzIC8qICRsYWI6Y292ZXJhZ2U6b24kICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmRzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gcmVjb3Jkcy5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghKGN1cnJlbnQgPSBlbnRyaWVzLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGN1cnJlbnQudmFsdWVbMF0sIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBuZXcgU3RhdGUoc3RhdGUua2V5LCBbLi4uc3RhdGUucGF0aCwgaV0sIHN0YXRlLnBhcmVudCwgc3RhdGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IGN1cnJlbnQudmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW2N1cnJlbnQudmFsdWVbMV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHNldHRpbmdzLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChpdGVtLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIWlnbm9yZVVuZGVmaW5lZCB8fCBpdGVtICE9PSB1bmRlZmluZWQpICYmIHJlY29yZHNbaXRlbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBuZXcgU3RhdGUoc3RhdGUua2V5LCBbLi4uc3RhdGUucGF0aCwgaV0sIHN0YXRlLnBhcmVudCwgc3RhdGUucmVmZXJlbmNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlUG9zOiByZWNvcmRzW2l0ZW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW3JlY29yZHNbaXRlbV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHNldHRpbmdzLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzW2l0ZW1dID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzcGFyc2UoZW5hYmxlZCkge1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3Muc3BhcnNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3Muc3BhcnNlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgc2luZ2xlKGVuYWJsZWQpIHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnNpbmdsZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnNpbmdsZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9maWxsTWlzc2VkRXJyb3JzKGVycm9ycywgcmVxdWlyZWRzLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGtub3duTWlzc2VzID0gW107XG4gICAgICAgIGxldCB1bmtub3duTWlzc2VzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1aXJlZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gcmVxdWlyZWRzW2ldLl9nZXRMYWJlbCgpO1xuICAgICAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAga25vd25NaXNzZXMucHVzaChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICArK3Vua25vd25NaXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa25vd25NaXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodW5rbm93bk1pc3Nlcykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRCb3RoJywgeyBrbm93bk1pc3NlcywgdW5rbm93bk1pc3NlcyB9LCB7IGtleTogc3RhdGUua2V5LCBwYXRoOiBzdGF0ZS5wYXRoIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRLbm93bnMnLCB7IGtub3duTWlzc2VzIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IHN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignYXJyYXkuaW5jbHVkZXNSZXF1aXJlZFVua25vd25zJywgeyB1bmtub3duTWlzc2VzIH0sIHsga2V5OiBzdGF0ZS5rZXksIHBhdGg6IHN0YXRlLnBhdGggfSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBfZmlsbE9yZGVyZWRFcnJvcnMoZXJyb3JzLCBvcmRlcmVkcywgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCByZXF1aXJlZE9yZGVyZWRzID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2UgPSBIb2VrLnJlYWNoKG9yZGVyZWRzW2ldLCAnX2ZsYWdzLnByZXNlbmNlJyk7XG4gICAgICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZE9yZGVyZWRzLnB1c2gob3JkZXJlZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVpcmVkT3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsTWlzc2VkRXJyb3JzKGVycm9ycywgcmVxdWlyZWRPcmRlcmVkcywgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5BcnJheSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuQmluYXJ5ID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdiaW5hcnknO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29udmVydCkge1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCB0aGlzLl9mbGFncy5lbmNvZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuZXJyb3JzID0gQnVmZmVyLmlzQnVmZmVyKHJlc3VsdC52YWx1ZSkgPyBudWxsIDogdGhpcy5jcmVhdGVFcnJvcignYmluYXJ5LmJhc2UnLCBudWxsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZW5jb2RpbmcoZW5jb2RpbmcpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuZW5jb2RpbmcgPT09IGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIG1pbihsaW1pdCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSAmJiBsaW1pdCA+PSAwLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbWluJywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2JpbmFyeS5taW4nLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1heChsaW1pdCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSAmJiBsaW1pdCA+PSAwLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbWF4JywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2JpbmFyeS5tYXgnLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxlbmd0aChsaW1pdCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSAmJiBsaW1pdCA+PSAwLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbGVuZ3RoJywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdiaW5hcnkubGVuZ3RoJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkJpbmFyeSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgU2V0OiByZXF1aXJlKCcuLi8uLi9zZXQnKVxufTtcblxuXG5pbnRlcm5hbHMuQm9vbGVhbiA9IGNsYXNzIGV4dGVuZHMgQW55IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gJ2Jvb2xlYW4nO1xuICAgICAgICB0aGlzLl9mbGFncy5pbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lubmVyLnRydXRoeVNldCA9IG5ldyBpbnRlcm5hbHMuU2V0KCk7XG4gICAgICAgIHRoaXMuX2lubmVyLmZhbHN5U2V0ID0gbmV3IGludGVybmFscy5TZXQoKTtcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBvcHRpb25zLmNvbnZlcnQpIHtcblxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlID8gdmFsdWUudG9Mb3dlckNhc2UoKSA6IHZhbHVlO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gKG5vcm1hbGl6ZWQgPT09ICd0cnVlJyA/IHRydWVcbiAgICAgICAgICAgICAgICA6IChub3JtYWxpemVkID09PSAnZmFsc2UnID8gZmFsc2UgOiB2YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQudmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gKHRoaXMuX2lubmVyLnRydXRoeVNldC5oYXModmFsdWUsIG51bGwsIG51bGwsIHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlKSA/IHRydWVcbiAgICAgICAgICAgICAgICA6ICh0aGlzLl9pbm5lci5mYWxzeVNldC5oYXModmFsdWUsIG51bGwsIG51bGwsIHRoaXMuX2ZsYWdzLmluc2Vuc2l0aXZlKSA/IGZhbHNlIDogdmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5lcnJvcnMgPSAodHlwZW9mIHJlc3VsdC52YWx1ZSA9PT0gJ2Jvb2xlYW4nKSA/IG51bGwgOiB0aGlzLmNyZWF0ZUVycm9yKCdib29sZWFuLmJhc2UnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB0cnV0aHkoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB2YWx1ZXMgPSBIb2VrLmZsYXR0ZW4odmFsdWVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgdHJ1dGh5IHdpdGggdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICBvYmouX2lubmVyLnRydXRoeVNldC5hZGQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBmYWxzeSguLi52YWx1ZXMpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHZhbHVlcyA9IEhvZWsuZmxhdHRlbih2YWx1ZXMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCBmYWxzeSB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgb2JqLl9pbm5lci5mYWxzeVNldC5hZGQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpbnNlbnNpdGl2ZShlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3QgaW5zZW5zaXRpdmUgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogISFlbmFibGVkO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5pbnNlbnNpdGl2ZSA9PT0gaW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmluc2Vuc2l0aXZlID0gaW5zZW5zaXRpdmU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzdXBlci5kZXNjcmliZSgpO1xuICAgICAgICBkZXNjcmlwdGlvbi50cnV0aHkgPSBbdHJ1ZSwgLi4udGhpcy5faW5uZXIudHJ1dGh5U2V0LnZhbHVlcygpXTtcbiAgICAgICAgZGVzY3JpcHRpb24uZmFsc3kgPSBbZmFsc2UsIC4uLnRoaXMuX2lubmVyLmZhbHN5U2V0LnZhbHVlcygpXTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkJvb2xlYW4oKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuLi8uLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuaW50ZXJuYWxzLmlzb0RhdGUgPSAvXig/OlstK11cXGR7Mn0pPyg/OlxcZHs0fSg/IVxcZHsyfVxcYikpKD86KC0/KSg/Oig/OjBbMS05XXwxWzAtMl0pKD86XFwxKD86WzEyXVxcZHwwWzEtOV18M1swMV0pKT98Vyg/OlswLTRdXFxkfDVbMC0yXSkoPzotP1sxLTddKT98KD86MDBbMS05XXwwWzEtOV1cXGR8WzEyXVxcZHsyfXwzKD86WzAtNV1cXGR8NlsxLTZdKSkpKD8hW1RdJHxbVF1bXFxkXStaJCkoPzpbVFxcc10oPzooPzooPzpbMDFdXFxkfDJbMC0zXSkoPzooOj8pWzAtNV1cXGQpP3wyNFxcOj8wMCkoPzpbLixdXFxkKyg/ITopKT8pKD86XFwyWzAtNV1cXGQoPzpbLixdXFxkKyk/KT8oPzpbWl18KD86WystXSkoPzpbMDFdXFxkfDJbMC0zXSkoPzo6P1swLTVdXFxkKT8pPyk/KT8kLztcbmludGVybmFscy5pbnZhbGlkRGF0ZSA9IG5ldyBEYXRlKCcnKTtcbmludGVybmFscy5pc0lzb0RhdGUgPSAoKCkgPT4ge1xuXG4gICAgY29uc3QgaXNvU3RyaW5nID0gaW50ZXJuYWxzLmlzb0RhdGUudG9TdHJpbmcoKTtcblxuICAgIHJldHVybiAoZGF0ZSkgPT4ge1xuXG4gICAgICAgIHJldHVybiBkYXRlICYmIChkYXRlLnRvU3RyaW5nKCkgPT09IGlzb1N0cmluZyk7XG4gICAgfTtcbn0pKCk7XG5cbmludGVybmFscy5EYXRlID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdkYXRlJztcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICB2YWx1ZTogKG9wdGlvbnMuY29udmVydCAmJiBpbnRlcm5hbHMuRGF0ZS50b0RhdGUodmFsdWUsIHRoaXMuX2ZsYWdzLmZvcm1hdCwgdGhpcy5fZmxhZ3MudGltZXN0YW1wLCB0aGlzLl9mbGFncy5tdWx0aXBsaWVyKSkgfHwgdmFsdWVcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocmVzdWx0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4ocmVzdWx0LnZhbHVlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmNvbnZlcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdkYXRlLnN0cmljdCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmlzSXNvRGF0ZSh0aGlzLl9mbGFncy5mb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdpc29EYXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2ZsYWdzLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBgdGltZXN0YW1wLiR7dGhpcy5fZmxhZ3MudGltZXN0YW1wfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2Jhc2UnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcihgZGF0ZS4ke3R5cGV9YCwgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHN0YXRpYyB0b0RhdGUodmFsdWUsIGZvcm1hdCwgdGltZXN0YW1wLCBtdWx0aXBsaWVyKSB7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgaXNGaW5pdGUodmFsdWUpKSkge1xuXG4gICAgICAgICAgICBjb25zdCBpc0lzb0RhdGUgPSBmb3JtYXQgJiYgaW50ZXJuYWxzLmlzSXNvRGF0ZShmb3JtYXQpO1xuICAgICAgICAgICAgaWYgKCFpc0lzb0RhdGUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgL15bKy1dP1xcZCsoXFwuXFxkKyk/JC8udGVzdCh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBkYXRlO1xuICAgICAgICAgICAgaWYgKGlzSXNvRGF0ZSkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBmb3JtYXQudGVzdCh2YWx1ZSkgPyBuZXcgRGF0ZSh2YWx1ZS50b1N0cmluZygpKSA6IGludGVybmFscy5pbnZhbGlkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSAvXlxccyokLy50ZXN0KHZhbHVlKSA/IGludGVybmFscy5pbnZhbGlkRGF0ZSA6IG5ldyBEYXRlKHZhbHVlICogbXVsdGlwbGllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaXNvKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5mb3JtYXQgPT09IGludGVybmFscy5pc29EYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5mb3JtYXQgPSBpbnRlcm5hbHMuaXNvRGF0ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB0aW1lc3RhbXAodHlwZSA9ICdqYXZhc2NyaXB0Jykge1xuXG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBbJ2phdmFzY3JpcHQnLCAndW5peCddO1xuICAgICAgICBIb2VrLmFzc2VydChhbGxvd2VkLmluY2x1ZGVzKHR5cGUpLCAnXCJ0eXBlXCIgbXVzdCBiZSBvbmUgb2YgXCInICsgYWxsb3dlZC5qb2luKCdcIiwgXCInKSArICdcIicpO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy50aW1lc3RhbXAgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnRpbWVzdGFtcCA9IHR5cGU7XG4gICAgICAgIG9iai5fZmxhZ3MubXVsdGlwbGllciA9IHR5cGUgPT09ICd1bml4JyA/IDEwMDAgOiAxO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9pc0lzb0RhdGUodmFsdWUpIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmlzb0RhdGUudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG59O1xuXG5pbnRlcm5hbHMuY29tcGFyZSA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUpIHtcblxuICAgICAgICBjb25zdCBpc05vdyA9IGRhdGUgPT09ICdub3cnO1xuICAgICAgICBjb25zdCBpc1JlZiA9IFJlZi5pc1JlZihkYXRlKTtcblxuICAgICAgICBpZiAoIWlzTm93ICYmICFpc1JlZikge1xuICAgICAgICAgICAgZGF0ZSA9IGludGVybmFscy5EYXRlLnRvRGF0ZShkYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGRhdGUsICdJbnZhbGlkIGRhdGUgZm9ybWF0Jyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QodHlwZSwgZGF0ZSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZVRvO1xuICAgICAgICAgICAgaWYgKGlzTm93KSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmVmFsdWUgPSBkYXRlKHN0YXRlLnJlZmVyZW5jZSB8fCBzdGF0ZS5wYXJlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUbyA9IGludGVybmFscy5EYXRlLnRvRGF0ZShyZWZWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmVUbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignZGF0ZS5yZWYnLCB7IHJlZjogZGF0ZSwgdmFsdWU6IHJlZlZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBjb21wYXJlVG8uZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbHVlLmdldFRpbWUoKSwgY29tcGFyZVRvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2RhdGUuJyArIHR5cGUsIHsgbGltaXQ6IG5ldyBEYXRlKGNvbXBhcmVUbyksIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLkRhdGUucHJvdG90eXBlLm1pbiA9IGludGVybmFscy5jb21wYXJlKCdtaW4nLCAodmFsdWUsIGRhdGUpID0+IHZhbHVlID49IGRhdGUpO1xuaW50ZXJuYWxzLkRhdGUucHJvdG90eXBlLm1heCA9IGludGVybmFscy5jb21wYXJlKCdtYXgnLCAodmFsdWUsIGRhdGUpID0+IHZhbHVlIDw9IGRhdGUpO1xuaW50ZXJuYWxzLkRhdGUucHJvdG90eXBlLmdyZWF0ZXIgPSBpbnRlcm5hbHMuY29tcGFyZSgnZ3JlYXRlcicsICh2YWx1ZSwgZGF0ZSkgPT4gdmFsdWUgPiBkYXRlKTtcbmludGVybmFscy5EYXRlLnByb3RvdHlwZS5sZXNzID0gaW50ZXJuYWxzLmNvbXBhcmUoJ2xlc3MnLCAodmFsdWUsIGRhdGUpID0+IHZhbHVlIDwgZGF0ZSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkRhdGUoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgT2JqZWN0VHlwZSA9IHJlcXVpcmUoJy4uL29iamVjdCcpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vLi4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLkZ1bmMgPSBjbGFzcyBleHRlbmRzIE9iamVjdFR5cGUuY29uc3RydWN0b3Ige1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZmxhZ3MuZnVuYyA9IHRydWU7XG4gICAgfVxuXG4gICAgYXJpdHkobikge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnYXJpdHknLCBuLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdmdW5jdGlvbi5hcml0eScsIHsgbiB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1pbkFyaXR5KG4pIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID4gMCwgJ24gbXVzdCBiZSBhIHN0cmljdCBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ21pbkFyaXR5JywgbiwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID49IG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdmdW5jdGlvbi5taW5Bcml0eScsIHsgbiB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1heEFyaXR5KG4pIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ21heEFyaXR5JywgbiwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IG4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdmdW5jdGlvbi5tYXhBcml0eScsIHsgbiB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlZigpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgncmVmJywgbnVsbCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoUmVmLmlzUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ2Z1bmN0aW9uLnJlZicsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGFzcygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnY2xhc3MnLCBudWxsLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICgoL15cXHMqY2xhc3NcXHMvKS50ZXN0KHZhbHVlLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignZnVuY3Rpb24uY2xhc3MnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLkZ1bmMoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLkxhenkgPSBjbGFzcyBleHRlbmRzIEFueSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90eXBlID0gJ2xhenknO1xuICAgICAgICB0aGlzLl9mbGFncy5vbmNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBudWxsO1xuICAgIH1cblxuICAgIF9pbml0KGZuLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGZuLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgc2NoZW1hO1xuICAgICAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMuX2NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZSB9O1xuICAgICAgICAgICAgY29uc3QgbGF6eSA9IHRoaXMuX2ZsYWdzLmxhenk7XG5cbiAgICAgICAgICAgIGlmICghbGF6eSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdsYXp5LmJhc2UnLCBudWxsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2NoZW1hID0gbGF6eSgpO1xuXG4gICAgICAgICAgICBpZiAoIShzY2hlbWEgaW5zdGFuY2VvZiBBbnkpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ2xhenkuc2NoZW1hJywgeyBzY2hlbWEgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5vbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBzY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHNldChmbiwgb3B0aW9ucykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJywgJ1lvdSBtdXN0IHByb3ZpZGUgYSBmdW5jdGlvbiBhcyBmaXJzdCBhcmd1bWVudCcpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMpKSwgYE9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3RgKTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bk9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKGtleSkgPT4gIVsnb25jZSddLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodW5rbm93bk9wdGlvbnMubGVuZ3RoID09PSAwLCBgT3B0aW9ucyBjb250YWluIHVua25vd24ga2V5czogJHt1bmtub3duT3B0aW9uc31gKTtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMub25jZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLm9uY2UgPT09ICdib29sZWFuJywgJ09wdGlvbiBcIm9uY2VcIiBtdXN0IGJlIGEgYm9vbGVhbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmxhenkgPSBmbjtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm9uY2UgIT09IG9iai5fZmxhZ3Mub25jZSkge1xuICAgICAgICAgICAgb2JqLl9mbGFncy5vbmNlID0gb3B0aW9ucy5vbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5MYXp5KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi4vLi4vcmVmJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHByZWNpc2lvblJ4OiAvKD86XFwuKFxcZCspKT8oPzpbZUVdKFsrLV0/XFxkKykpPyQvLFxuICAgIG5vcm1hbGl6ZUV4cG9uZW50KHN0cikge1xuXG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXC4/MCtlLywgJ2UnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL2VcXCsvLCAnZScpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcKy8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL14oLT8pMCsoWzEtOV0pLywgJyQxJDInKTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZURlY2ltYWwoc3RyKSB7XG5cbiAgICAgICAgc3RyID0gc3RyXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcKy8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcLjArJC8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL14oLT8pMCsoWzEtOV0pLywgJyQxJDInKTtcblxuICAgICAgICBpZiAoc3RyLmluY2x1ZGVzKCcuJykgJiYgc3RyLmVuZHNXaXRoKCcwJykpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8wKyQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLk51bWJlciA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgdGhpcy5fZmxhZ3MudW5zYWZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ludmFsaWRzLmFkZChJbmZpbml0eSk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRzLmFkZCgtSW5maW5pdHkpO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuY29udmVydCkge1xuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goL15cXHMqWystXT9cXGQrKD86XFwuXFxkKyk/KD86ZShbKy1dP1xcZCspKT9cXHMqJC9pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZmxhZ3MudW5zYWZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLm5vcm1hbGl6ZUV4cG9uZW50KGAke3Jlc3VsdC52YWx1ZSAvIE1hdGgucG93KDEwLCBtYXRjaGVzWzFdKX1lJHttYXRjaGVzWzFdfWApICE9PSBpbnRlcm5hbHMubm9ybWFsaXplRXhwb25lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci51bnNhZmUnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZS50b1N0cmluZygpICE9PSBpbnRlcm5hbHMubm9ybWFsaXplRGVjaW1hbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnVuc2FmZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc051bWJlciA9IHR5cGVvZiByZXN1bHQudmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTihyZXN1bHQudmFsdWUpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmNvbnZlcnQgJiYgJ3ByZWNpc2lvbicgaW4gdGhpcy5fZmxhZ3MgJiYgaXNOdW1iZXIpIHtcblxuICAgICAgICAgICAgLy8gVGhpcyBpcyBjb25jZXB0dWFsbHkgZXF1aXZhbGVudCB0byB1c2luZyB0b0ZpeGVkIGJ1dCBpdCBzaG91bGQgYmUgbXVjaCBmYXN0ZXJcbiAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCB0aGlzLl9mbGFncy5wcmVjaXNpb24pO1xuICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gTWF0aC5yb3VuZChyZXN1bHQudmFsdWUgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZsYWdzLnVuc2FmZSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IHZhbHVlIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycyA9IHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci51bnNhZmUnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIuYmFzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBtdWx0aXBsZShiYXNlKSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYoYmFzZSk7XG5cbiAgICAgICAgaWYgKCFpc1JlZikge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGJhc2UgPT09ICdudW1iZXInICYmIGlzRmluaXRlKGJhc2UpLCAnbXVsdGlwbGUgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoYmFzZSA+IDAsICdtdWx0aXBsZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbXVsdGlwbGUnLCBiYXNlLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpdmlzb3IgPSBpc1JlZiA/IGJhc2Uoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucykgOiBiYXNlO1xuXG4gICAgICAgICAgICBpZiAoaXNSZWYgJiYgKHR5cGVvZiBkaXZpc29yICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUoZGl2aXNvcikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5yZWYnLCB7IHJlZjogYmFzZS5rZXkgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUgJSBkaXZpc29yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLm11bHRpcGxlJywgeyBtdWx0aXBsZTogYmFzZSwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpbnRlZ2VyKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdpbnRlZ2VyJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnRydW5jKHZhbHVlKSAtIHZhbHVlID09PSAwID8gdmFsdWUgOiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIuaW50ZWdlcicsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1bnNhZmUoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy51bnNhZmUgPT09IGVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLnVuc2FmZSA9IGVuYWJsZWQ7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbmVnYXRpdmUoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ25lZ2F0aXZlJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIubmVnYXRpdmUnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcG9zaXRpdmUoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3Bvc2l0aXZlJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIucG9zaXRpdmUnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJlY2lzaW9uKGxpbWl0KSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoTnVtYmVyLmlzU2FmZUludGVnZXIobGltaXQpLCAnbGltaXQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCEoJ3ByZWNpc2lvbicgaW4gdGhpcy5fZmxhZ3MpLCAncHJlY2lzaW9uIGFscmVhZHkgc2V0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5fdGVzdCgncHJlY2lzaW9uJywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaChpbnRlcm5hbHMucHJlY2lzaW9uUngpO1xuICAgICAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBNYXRoLm1heCgocGxhY2VzWzFdID8gcGxhY2VzWzFdLmxlbmd0aCA6IDApIC0gKHBsYWNlc1syXSA/IHBhcnNlSW50KHBsYWNlc1syXSwgMTApIDogMCksIDApO1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxzIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignbnVtYmVyLnByZWNpc2lvbicsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqLl9mbGFncy5wcmVjaXNpb24gPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwb3J0KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdwb3J0JywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5wb3J0JywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59O1xuXG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBhcmUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiAobGltaXQpIHtcblxuICAgICAgICBjb25zdCBpc1JlZiA9IFJlZi5pc1JlZihsaW1pdCk7XG4gICAgICAgIGNvbnN0IGlzTnVtYmVyID0gdHlwZW9mIGxpbWl0ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4obGltaXQpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGlzTnVtYmVyIHx8IGlzUmVmLCAnbGltaXQgbXVzdCBiZSBhIG51bWJlciBvciByZWZlcmVuY2UnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCh0eXBlLCBsaW1pdCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBsZXQgY29tcGFyZVRvO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQoc3RhdGUucmVmZXJlbmNlIHx8IHN0YXRlLnBhcmVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgY29tcGFyZVRvID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oY29tcGFyZVRvKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ251bWJlci5yZWYnLCB7IHJlZjogbGltaXQua2V5IH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbXBhcmUodmFsdWUsIGNvbXBhcmVUbykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdudW1iZXIuJyArIHR5cGUsIHsgbGltaXQ6IGNvbXBhcmVUbywgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuTnVtYmVyLnByb3RvdHlwZS5taW4gPSBpbnRlcm5hbHMuY29tcGFyZSgnbWluJywgKHZhbHVlLCBsaW1pdCkgPT4gdmFsdWUgPj0gbGltaXQpO1xuaW50ZXJuYWxzLk51bWJlci5wcm90b3R5cGUubWF4ID0gaW50ZXJuYWxzLmNvbXBhcmUoJ21heCcsICh2YWx1ZSwgbGltaXQpID0+IHZhbHVlIDw9IGxpbWl0KTtcbmludGVybmFscy5OdW1iZXIucHJvdG90eXBlLmdyZWF0ZXIgPSBpbnRlcm5hbHMuY29tcGFyZSgnZ3JlYXRlcicsICh2YWx1ZSwgbGltaXQpID0+IHZhbHVlID4gbGltaXQpO1xuaW50ZXJuYWxzLk51bWJlci5wcm90b3R5cGUubGVzcyA9IGludGVybmFscy5jb21wYXJlKCdsZXNzJywgKHZhbHVlLCBsaW1pdCkgPT4gdmFsdWUgPCBsaW1pdCk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgaW50ZXJuYWxzLk51bWJlcigpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb3VybmUgPSByZXF1aXJlKCdAaGFwaS9ib3VybmUnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBUb3BvID0gcmVxdWlyZSgnQGhhcGkvdG9wbycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgQ2FzdCA9IHJlcXVpcmUoJy4uLy4uL2Nhc3QnKTtcbmNvbnN0IFN0YXRlID0gcmVxdWlyZSgnLi4vc3RhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuT2JqZWN0ID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdvYmplY3QnO1xuICAgICAgICB0aGlzLl9pbm5lci5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lubmVyLnJlbmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5faW5uZXIuZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIHRoaXMuX2lubmVyLnBhdHRlcm5zID0gW107XG4gICAgfVxuXG4gICAgX2luaXQoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA/IHRoaXMua2V5cyguLi5hcmdzKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgX2Jhc2UodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgbGV0IHRhcmdldCA9IHZhbHVlO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgZmluaXNoID0gKCkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgKHZhbHVlWzBdID09PSAneycgfHwgL15cXHMqXFx7Ly50ZXN0KHZhbHVlKSkpIHtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQm91cm5lLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX2ZsYWdzLmZ1bmMgPyAnZnVuY3Rpb24nIDogJ29iamVjdCc7XG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcih0eXBlICsgJy5iYXNlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBpZiB0aGVyZSBhcmUgbm8gb3RoZXIgcnVsZXMgdG8gdGVzdFxuXG4gICAgICAgIGlmICghdGhpcy5faW5uZXIucmVuYW1lcy5sZW5ndGggJiZcbiAgICAgICAgICAgICF0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhdGhpcy5faW5uZXIuY2hpbGRyZW4gJiYgICAgICAgICAgICAgICAgICAgIC8vIG51bGwgYWxsb3dzIGFueSBrZXlzXG4gICAgICAgICAgICAhdGhpcy5faW5uZXIucGF0dGVybnMubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIHRhcmdldCBpcyBhIGxvY2FsIGNvcHkgKHBhcnNlZCkgb3Igc2hhbGxvdyBjb3B5XG5cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnByb3RvdHlwZSA9IEhvZWsuY2xvbmUodmFsdWUucHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmFsdWVLZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbdmFsdWVLZXlzW2ldXSA9IHZhbHVlW3ZhbHVlS2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbmFtZSBrZXlzXG5cbiAgICAgICAgY29uc3QgcmVuYW1lZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLnJlbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmFtZSA9IHRoaXMuX2lubmVyLnJlbmFtZXNbaV07XG5cbiAgICAgICAgICAgIGlmIChyZW5hbWUuaXNSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkVGFyZ2V0S2V5cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YXJnZXRLZXlzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5hbWUuZnJvbS50ZXN0KHRhcmdldEtleXNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVGFyZ2V0S2V5cy5wdXNoKHRhcmdldEtleXNbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsVW5kZWZpbmVkID0gbWF0Y2hlZFRhcmdldEtleXMuZXZlcnkoKGtleSkgPT4gdGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCAmJiBhbGxVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5tdWx0aXBsZSAmJlxuICAgICAgICAgICAgICAgICAgICByZW5hbWVkW3JlbmFtZS50b10pIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLnJlZ2V4Lm11bHRpcGxlJywgeyBmcm9tOiBtYXRjaGVkVGFyZ2V0S2V5cywgdG86IHJlbmFtZS50byB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcmVuYW1lLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmVuYW1lLm9wdGlvbnMub3ZlcnJpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbmFtZWRbcmVuYW1lLnRvXSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUucmVnZXgub3ZlcnJpZGUnLCB7IGZyb206IG1hdGNoZWRUYXJnZXRLZXlzLCB0bzogcmVuYW1lLnRvIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhbGxVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldFtyZW5hbWUudG9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3JlbmFtZS50b10gPSB0YXJnZXRbbWF0Y2hlZFRhcmdldEtleXNbbWF0Y2hlZFRhcmdldEtleXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbmFtZWRbcmVuYW1lLnRvXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Y2hlZFRhcmdldEtleXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbbWF0Y2hlZFRhcmdldEtleXNbal1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbmFtZS5vcHRpb25zLmlnbm9yZVVuZGVmaW5lZCAmJiB0YXJnZXRbcmVuYW1lLmZyb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyZW5hbWUub3B0aW9ucy5tdWx0aXBsZSAmJlxuICAgICAgICAgICAgICAgICAgICByZW5hbWVkW3JlbmFtZS50b10pIHtcblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm11bHRpcGxlJywgeyBmcm9tOiByZW5hbWUuZnJvbSwgdG86IHJlbmFtZS50byB9LCBzdGF0ZSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcmVuYW1lLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmVuYW1lLm9wdGlvbnMub3ZlcnJpZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbmFtZWRbcmVuYW1lLnRvXSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5yZW5hbWUub3ZlcnJpZGUnLCB7IGZyb206IHJlbmFtZS5mcm9tLCB0bzogcmVuYW1lLnRvIH0sIHN0YXRlLCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbcmVuYW1lLmZyb21dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldFtyZW5hbWUudG9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3JlbmFtZS50b10gPSB0YXJnZXRbcmVuYW1lLmZyb21dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbmFtZWRbcmVuYW1lLnRvXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbcmVuYW1lLmZyb21dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbGlkYXRlIHNjaGVtYVxuXG4gICAgICAgIGlmICghdGhpcy5faW5uZXIuY2hpbGRyZW4gJiYgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXRoaXMuX2lubmVyLmRlcGVuZGVuY2llcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5wcm9jZXNzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRhcmdldCkpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbm5lci5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3Qgc3RyaXBQcm9wcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLl9pbm5lci5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRhcmdldFtrZXldO1xuXG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKGtleSwgWy4uLnN0YXRlLnBhdGgsIGtleV0sIHRhcmdldCwgc3RhdGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGlsZC5zY2hlbWEuX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5jaGlsZCcsIHsga2V5LCBjaGlsZDogY2hpbGQuc2NoZW1hLl9nZXRMYWJlbChrZXkpLCByZWFzb246IHJlc3VsdC5lcnJvcnMgfSwgbG9jYWxTdGF0ZSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnNjaGVtYS5fZmxhZ3Muc3RyaXAgfHwgKHJlc3VsdC52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIHJlc3VsdC52YWx1ZSAhPT0gaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmlwUHJvcHMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSByZXN1bHQuZmluYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaXBQcm9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbc3RyaXBQcm9wc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmtub3duIGtleXNcblxuICAgICAgICBpZiAodW5wcm9jZXNzZWQuc2l6ZSAmJiB0aGlzLl9pbm5lci5wYXR0ZXJucy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKGtleSwgWy4uLnN0YXRlLnBhdGgsIGtleV0sIHRhcmdldCwgc3RhdGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGFyZ2V0W2tleV07XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLl9pbm5lci5wYXR0ZXJuc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5yZWdleCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnJlZ2V4LnRlc3Qoa2V5KSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAhcGF0dGVybi5zY2hlbWEuX3ZhbGlkYXRlKGtleSwgc3RhdGUsIHsgLi4ub3B0aW9ucywgYWJvcnRFYXJseTp0cnVlIH0pLmVycm9ycykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGF0dGVybi5ydWxlLl92YWxpZGF0ZShpdGVtLCBsb2NhbFN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LmNoaWxkJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkOiBwYXR0ZXJuLnJ1bGUuX2dldExhYmVsKGtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0LmVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGxvY2FsU3RhdGUsIG9wdGlvbnMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodW5wcm9jZXNzZWQuc2l6ZSAmJiAodGhpcy5faW5uZXIuY2hpbGRyZW4gfHwgdGhpcy5faW5uZXIucGF0dGVybnMubGVuZ3RoKSkge1xuICAgICAgICAgICAgaWYgKChvcHRpb25zLnN0cmlwVW5rbm93biAmJiB0aGlzLl9mbGFncy5hbGxvd1Vua25vd24gIT09IHRydWUpIHx8XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5za2lwRnVuY3Rpb25zKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpcFVua25vd24gPSBvcHRpb25zLnN0cmlwVW5rbm93blxuICAgICAgICAgICAgICAgICAgICA/IChvcHRpb25zLnN0cmlwVW5rbm93biA9PT0gdHJ1ZSA/IHRydWUgOiAhIW9wdGlvbnMuc3RyaXBVbmtub3duLm9iamVjdHMpXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG5cblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0YXJnZXRba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgodGhpcy5fZmxhZ3MuYWxsb3dVbmtub3duICE9PSB1bmRlZmluZWQgPyAhdGhpcy5fZmxhZ3MuYWxsb3dVbmtub3duIDogIW9wdGlvbnMuYWxsb3dVbmtub3duKSkge1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB1bnByb2Nlc3NlZEtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QuYWxsb3dVbmtub3duJywgeyBjaGlsZDogdW5wcm9jZXNzZWRLZXksIHZhbHVlOiB0YXJnZXRbdW5wcm9jZXNzZWRLZXldIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdW5wcm9jZXNzZWRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBbLi4uc3RhdGUucGF0aCwgdW5wcm9jZXNzZWRLZXldXG4gICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMsIHt9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZGVwZW5kZW5jaWVzXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcCA9IHRoaXMuX2lubmVyLmRlcGVuZGVuY2llc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0tleSA9IGRlcC5rZXkgIT09IG51bGw7XG4gICAgICAgICAgICBjb25zdCBzcGxpdEtleSA9IGhhc0tleSAmJiBkZXAua2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gaGFzS2V5ID8gbmV3IFN0YXRlKHNwbGl0S2V5W3NwbGl0S2V5Lmxlbmd0aCAtIDFdLCBbLi4uc3RhdGUucGF0aCwgLi4uc3BsaXRLZXldKSA6IG5ldyBTdGF0ZShudWxsLCBzdGF0ZS5wYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IGludGVybmFsc1tkZXAudHlwZV0uY2FsbCh0aGlzLCBkZXAua2V5LCBoYXNLZXkgJiYgSG9lay5yZWFjaCh0YXJnZXQsIGRlcC5rZXksIHsgZnVuY3Rpb25zOiB0cnVlIH0pLCBkZXAucGVlcnMsIHRhcmdldCwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3JzLkVycikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgIH1cblxuICAgIGtleXMoc2NoZW1hKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnLCAnT2JqZWN0IHNjaGVtYSBtdXN0IGJlIGEgdmFsaWQgb2JqZWN0Jyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFzY2hlbWEgfHwgIShzY2hlbWEgaW5zdGFuY2VvZiBBbnkpLCAnT2JqZWN0IHNjaGVtYSBjYW5ub3QgYmUgYSBqb2kgc2NoZW1hJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICBvYmouX2lubmVyLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5faW5uZXIuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3BvID0gbmV3IFRvcG8oKTtcbiAgICAgICAgaWYgKG9iai5faW5uZXIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLl9pbm5lci5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gb2JqLl9pbm5lci5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBrZXkgaWYgd2UgYXJlIG5vdCBnb2luZyB0byByZXBsYWNlIGl0IGxhdGVyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZHJlbi5pbmNsdWRlcyhjaGlsZC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcG8uYWRkKGNoaWxkLCB7IGFmdGVyOiBjaGlsZC5fcmVmcywgZ3JvdXA6IGNoaWxkLmtleSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gc2NoZW1hW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3QgPSBDYXN0LnNjaGVtYSh0aGlzLl9jdXJyZW50Sm9pLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgdG9wby5hZGQoeyBrZXksIHNjaGVtYTogY2FzdCB9LCB7IGFmdGVyOiBjYXN0Ll9yZWZzLCBncm91cDoga2V5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGNhc3RFcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FzdEVyci5oYXNPd25Qcm9wZXJ0eSgncGF0aCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc3RFcnIucGF0aCA9IGtleSArICcuJyArIGNhc3RFcnIucGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc3RFcnIucGF0aCA9IGtleTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBjYXN0RXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pbm5lci5jaGlsZHJlbiA9IHRvcG8ubm9kZXM7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBhcHBlbmQoc2NoZW1hKSB7XG4gICAgICAgIC8vIFNraXAgYW55IGNoYW5nZXNcbiAgICAgICAgaWYgKHNjaGVtYSA9PT0gbnVsbCB8fCBzY2hlbWEgPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5rZXlzKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgdW5rbm93bihhbGxvdykge1xuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYWxsb3cgIT09IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFncy5hbGxvd1Vua25vd24gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLl9mbGFncy5hbGxvd1Vua25vd24gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBsZW5ndGgobGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2xlbmd0aCcsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5sZW5ndGgnLCB7IGxpbWl0LCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1pbihsaW1pdCkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKGxpbWl0KSAmJiBsaW1pdCA+PSAwLCAnbGltaXQgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnbWluJywgbGltaXQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QubWluJywgeyBsaW1pdCwgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtYXgobGltaXQpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCwgJ2xpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ21heCcsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0Lm1heCcsIHsgbGltaXQsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcGF0dGVybihwYXR0ZXJuLCBzY2hlbWEpIHtcblxuICAgICAgICBjb25zdCBpc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgIEhvZWsuYXNzZXJ0KGlzUmVnRXhwIHx8IHBhdHRlcm4gaW5zdGFuY2VvZiBBbnksICdwYXR0ZXJuIG11c3QgYmUgYSByZWdleCBvciBzY2hlbWEnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoc2NoZW1hICE9PSB1bmRlZmluZWQsICdJbnZhbGlkIHJ1bGUnKTtcblxuICAgICAgICBpZiAoaXNSZWdFeHApIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KCFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCdnJykgJiYgIXBhdHRlcm4uZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3BhdHRlcm4gc2hvdWxkIG5vdCB1c2UgZ2xvYmFsIG9yIHN0aWNreSBtb2RlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2NoZW1hID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2FzdEVycikge1xuICAgICAgICAgICAgaWYgKGNhc3RFcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgIGNhc3RFcnIubWVzc2FnZSA9IGAke2Nhc3RFcnIubWVzc2FnZX0oJHtjYXN0RXJyLnBhdGh9KWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGNhc3RFcnI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIGlmIChpc1JlZ0V4cCkge1xuICAgICAgICAgICAgb2JqLl9pbm5lci5wYXR0ZXJucy5wdXNoKHsgcmVnZXg6IHBhdHRlcm4sIHJ1bGU6IHNjaGVtYSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5faW5uZXIucGF0dGVybnMucHVzaCh7IHNjaGVtYTogcGF0dGVybiwgcnVsZTogc2NoZW1hIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzY2hlbWEoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ3NjaGVtYScsIG51bGwsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW55KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LnNjaGVtYScsIG51bGwsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgd2l0aChrZXksIHBlZXJzKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiwgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cywgZXhwZWN0ZWQgMi4nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgnd2l0aCcsIGtleSwgcGVlcnMpO1xuICAgIH1cblxuICAgIHdpdGhvdXQoa2V5LCBwZWVycykge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KGFyZ3VtZW50cy5sZW5ndGggPT09IDIsICdJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMsIGV4cGVjdGVkIDIuJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGVuZGVuY3koJ3dpdGhvdXQnLCBrZXksIHBlZXJzKTtcbiAgICB9XG5cbiAgICB4b3IoLi4ucGVlcnMpIHtcblxuICAgICAgICBwZWVycyA9IEhvZWsuZmxhdHRlbihwZWVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBlbmRlbmN5KCd4b3InLCBudWxsLCBwZWVycyk7XG4gICAgfVxuXG4gICAgb3hvciguLi5wZWVycykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBlbmRlbmN5KCdveG9yJywgbnVsbCwgcGVlcnMpO1xuICAgIH1cblxuICAgIG9yKC4uLnBlZXJzKSB7XG5cbiAgICAgICAgcGVlcnMgPSBIb2VrLmZsYXR0ZW4ocGVlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgnb3InLCBudWxsLCBwZWVycyk7XG4gICAgfVxuXG4gICAgYW5kKC4uLnBlZXJzKSB7XG5cbiAgICAgICAgcGVlcnMgPSBIb2VrLmZsYXR0ZW4ocGVlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVwZW5kZW5jeSgnYW5kJywgbnVsbCwgcGVlcnMpO1xuICAgIH1cblxuICAgIG5hbmQoLi4ucGVlcnMpIHtcblxuICAgICAgICBwZWVycyA9IEhvZWsuZmxhdHRlbihwZWVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBlbmRlbmN5KCduYW5kJywgbnVsbCwgcGVlcnMpO1xuICAgIH1cblxuICAgIHJlcXVpcmVkS2V5cyguLi5jaGlsZHJlbikge1xuXG4gICAgICAgIGNoaWxkcmVuID0gSG9lay5mbGF0dGVuKGNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlGdW5jdGlvblRvQ2hpbGRyZW4oY2hpbGRyZW4sICdyZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIG9wdGlvbmFsS2V5cyguLi5jaGlsZHJlbikge1xuXG4gICAgICAgIGNoaWxkcmVuID0gSG9lay5mbGF0dGVuKGNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlGdW5jdGlvblRvQ2hpbGRyZW4oY2hpbGRyZW4sICdvcHRpb25hbCcpO1xuICAgIH1cblxuICAgIGZvcmJpZGRlbktleXMoLi4uY2hpbGRyZW4pIHtcblxuICAgICAgICBjaGlsZHJlbiA9IEhvZWsuZmxhdHRlbihjaGlsZHJlbik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGNoaWxkcmVuLCAnZm9yYmlkZGVuJyk7XG4gICAgfVxuXG4gICAgcmVuYW1lKGZyb20sIHRvLCBvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGZyb20gPT09ICdzdHJpbmcnIHx8IGZyb20gaW5zdGFuY2VvZiBSZWdFeHAsICdSZW5hbWUgbWlzc2luZyB0aGUgZnJvbSBhcmd1bWVudCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgdG8gPT09ICdzdHJpbmcnLCAnUmVuYW1lIG1pc3NpbmcgdGhlIHRvIGFyZ3VtZW50Jyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHRvICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSBrZXkgdG8gc2FtZSBuYW1lOicsIGZyb20pO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIucmVuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodGhpcy5faW5uZXIucmVuYW1lc1tpXS5mcm9tICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSB0aGUgc2FtZSBrZXkgbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBvYmouX2lubmVyLnJlbmFtZXMucHVzaCh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBvcHRpb25zOiBIb2VrLmFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMucmVuYW1lRGVmYXVsdHMsIG9wdGlvbnMgfHwge30pLFxuICAgICAgICAgICAgaXNSZWdFeHA6IGZyb20gaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBhcHBseUZ1bmN0aW9uVG9DaGlsZHJlbihjaGlsZHJlbiwgZm4sIGFyZ3MgPSBbXSwgcm9vdCkge1xuXG4gICAgICAgIGNoaWxkcmVuID0gW10uY29uY2F0KGNoaWxkcmVuKTtcbiAgICAgICAgSG9lay5hc3NlcnQoY2hpbGRyZW4ubGVuZ3RoID4gMCwgJ2V4cGVjdGVkIGF0IGxlYXN0IG9uZSBjaGlsZHJlbicpO1xuXG4gICAgICAgIGNvbnN0IGdyb3VwZWRDaGlsZHJlbiA9IGludGVybmFscy5ncm91cENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgICAgbGV0IG9iajtcblxuICAgICAgICBpZiAoJycgaW4gZ3JvdXBlZENoaWxkcmVuKSB7XG4gICAgICAgICAgICBvYmogPSB0aGlzW2ZuXSguLi5hcmdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBncm91cGVkQ2hpbGRyZW5bJyddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai5faW5uZXIuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJvb3QgPSByb290ID8gKHJvb3QgKyAnLicpIDogJyc7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLl9pbm5lci5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gb2JqLl9pbm5lci5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cCA9IGdyb3VwZWRDaGlsZHJlbltjaGlsZC5rZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai5faW5uZXIuY2hpbGRyZW5baV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGNoaWxkLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWZzOiBjaGlsZC5fcmVmcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogY2hpbGQuc2NoZW1hLmFwcGx5RnVuY3Rpb25Ub0NoaWxkcmVuKGdyb3VwLCBmbiwgYXJncywgcm9vdCArIGNoaWxkLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ3JvdXBlZENoaWxkcmVuW2NoaWxkLmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gT2JqZWN0LmtleXMoZ3JvdXBlZENoaWxkcmVuKTtcbiAgICAgICAgSG9lay5hc3NlcnQocmVtYWluaW5nLmxlbmd0aCA9PT0gMCwgJ3Vua25vd24ga2V5KHMpJywgcmVtYWluaW5nLmpvaW4oJywgJykpO1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgX2RlcGVuZGVuY3kodHlwZSwga2V5LCBwZWVycykge1xuXG4gICAgICAgIHBlZXJzID0gW10uY29uY2F0KHBlZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHBlZXJzW2ldID09PSAnc3RyaW5nJywgdHlwZSwgJ3BlZXJzIG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2lubmVyLmRlcGVuZGVuY2llcy5wdXNoKHsgdHlwZSwga2V5LCBwZWVycyB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBkZXNjcmliZShzaGFsbG93KSB7XG5cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzdXBlci5kZXNjcmliZSgpO1xuXG4gICAgICAgIGlmIChkZXNjcmlwdGlvbi5ydWxlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcmlwdGlvbi5ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBkZXNjcmlwdGlvbi5ydWxlc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBDb3ZlcmFnZSBvZmYgZm9yIGZ1dHVyZS1wcm9vZiBkZXNjcmlwdGlvbnMsIG9ubHkgb2JqZWN0KCkuYXNzZXJ0KCkgaXMgdXNlIHJpZ2h0IG5vd1xuICAgICAgICAgICAgICAgIGlmICgvKiAkbGFiOmNvdmVyYWdlOm9mZiQgKi9ydWxlLmFyZyAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcnVsZS5hcmcgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXJnLnNjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgICBydWxlLmFyZy5yZWYgLyogJGxhYjpjb3ZlcmFnZTpvbiQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHJ1bGUuYXJnLnNjaGVtYS5kZXNjcmliZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBydWxlLmFyZy5yZWYudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbm5lci5jaGlsZHJlbiAmJlxuICAgICAgICAgICAgIXNoYWxsb3cpIHtcblxuICAgICAgICAgICAgZGVzY3JpcHRpb24uY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5faW5uZXIuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2lubmVyLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLmNoaWxkcmVuW2NoaWxkLmtleV0gPSBjaGlsZC5zY2hlbWEuZGVzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbm5lci5kZXBlbmRlbmNpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5kZXBlbmRlbmNpZXMgPSBIb2VrLmNsb25lKHRoaXMuX2lubmVyLmRlcGVuZGVuY2llcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5uZXIucGF0dGVybnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbi5wYXR0ZXJucyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2lubmVyLnBhdHRlcm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2lubmVyLnBhdHRlcm5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLnBhdHRlcm5zLnB1c2goeyByZWdleDogcGF0dGVybi5yZWdleC50b1N0cmluZygpLCBydWxlOiBwYXR0ZXJuLnJ1bGUuZGVzY3JpYmUoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uLnBhdHRlcm5zLnB1c2goeyBzY2hlbWE6IHBhdHRlcm4uc2NoZW1hLmRlc2NyaWJlKCksIHJ1bGU6IHBhdHRlcm4ucnVsZS5kZXNjcmliZSgpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbm5lci5yZW5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnJlbmFtZXMgPSBIb2VrLmNsb25lKHRoaXMuX2lubmVyLnJlbmFtZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIGFzc2VydChyZWYsIHNjaGVtYSwgbWVzc2FnZSkge1xuXG4gICAgICAgIHJlZiA9IENhc3QucmVmKHJlZik7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHJlZi5pc0NvbnRleHQgfHwgcmVmLmRlcHRoID4gMSwgJ0Nhbm5vdCB1c2UgYXNzZXJ0aW9ucyBmb3Igcm9vdCBsZXZlbCByZWZlcmVuY2VzIC0gdXNlIGRpcmVjdCBrZXkgcnVsZXMgaW5zdGVhZCcpO1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCAncGFzcyB0aGUgYXNzZXJ0aW9uIHRlc3QnO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycsICdNZXNzYWdlIG11c3QgYmUgYSBzdHJpbmcnKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2NoZW1hID0gQ2FzdC5zY2hlbWEodGhpcy5fY3VycmVudEpvaSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2FzdEVycikge1xuICAgICAgICAgICAgaWYgKGNhc3RFcnIuaGFzT3duUHJvcGVydHkoJ3BhdGgnKSkge1xuICAgICAgICAgICAgICAgIGNhc3RFcnIubWVzc2FnZSA9IGAke2Nhc3RFcnIubWVzc2FnZX0oJHtjYXN0RXJyLnBhdGh9KWA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IGNhc3RFcnI7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBrZXkgPSByZWYucGF0aFtyZWYucGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlZi5wYXRoLmpvaW4oJy4nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnYXNzZXJ0JywgeyBzY2hlbWEsIHJlZiB9LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fdmFsaWRhdGUocmVmKHZhbHVlKSwgbnVsbCwgb3B0aW9ucywgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gbmV3IFN0YXRlKGtleSwgcmVmLnBhdGgsIHN0YXRlLnBhcmVudCwgc3RhdGUucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QuYXNzZXJ0JywgeyByZWY6IHBhdGgsIG1lc3NhZ2UgfSwgbG9jYWxTdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHR5cGUoY29uc3RydWN0b3IsIG5hbWUgPSBjb25zdHJ1Y3Rvci5uYW1lKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIGNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nLCAndHlwZSBtdXN0IGJlIGEgY29uc3RydWN0b3IgZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc3QgdHlwZURhdGEgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgY3RvcjogY29uc3RydWN0b3JcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgndHlwZScsIHR5cGVEYXRhLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LnR5cGUnLCB7IHR5cGU6IHR5cGVEYXRhLm5hbWUsIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucmVuYW1lRGVmYXVsdHMgPSB7XG4gICAgYWxpYXM6IGZhbHNlLCAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9sZCB2YWx1ZSBpbiBwbGFjZVxuICAgIG11bHRpcGxlOiBmYWxzZSwgICAgICAgICAgICAgICAgLy8gQWxsb3cgcmVuYW1pbmcgbXVsdGlwbGUga2V5cyBpbnRvIHRoZSBzYW1lIHRhcmdldFxuICAgIG92ZXJyaWRlOiBmYWxzZSAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGVzIGFuIGV4aXN0aW5nIGtleVxufTtcblxuXG5pbnRlcm5hbHMuZ3JvdXBDaGlsZHJlbiA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuXG4gICAgY2hpbGRyZW4uc29ydCgpO1xuXG4gICAgY29uc3QgZ3JvdXBlZCA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnLCAnY2hpbGRyZW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICAgIGNvbnN0IGdyb3VwID0gY2hpbGQuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgY29uc3QgY2hpbGRHcm91cCA9IGdyb3VwZWRbZ3JvdXBdID0gKGdyb3VwZWRbZ3JvdXBdIHx8IFtdKTtcbiAgICAgICAgY2hpbGRHcm91cC5wdXNoKGNoaWxkLnN1YnN0cmluZyhncm91cC5sZW5ndGggKyAxKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwZWQ7XG59O1xuXG5cbmludGVybmFscy5rZXlzVG9MYWJlbHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBrZXlzKSB7XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHNjaGVtYS5faW5uZXIuY2hpbGRyZW47XG5cbiAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbmRMYWJlbCA9IGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgICBjb25zdCBtYXRjaGluZ0NoaWxkID0gc2NoZW1hLl9jdXJyZW50Sm9pLnJlYWNoKHNjaGVtYSwga2V5KTtcbiAgICAgICAgcmV0dXJuIG1hdGNoaW5nQ2hpbGQgPyBtYXRjaGluZ0NoaWxkLl9nZXRMYWJlbChrZXkpIDoga2V5O1xuICAgIH07XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICByZXR1cm4ga2V5cy5tYXAoZmluZExhYmVsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZExhYmVsKGtleXMpO1xufTtcblxuXG5pbnRlcm5hbHMud2l0aCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcblxuICAgICAgICBjb25zdCBwZWVyID0gcGVlcnNbaV07XG4gICAgICAgIGNvbnN0IGtleXNFeGlzdCA9IEhvZWsucmVhY2gocGFyZW50LCBwZWVyLCB7IGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGtleXNFeGlzdCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3Qud2l0aCcsIHtcbiAgICAgICAgICAgICAgICBtYWluOiBrZXksXG4gICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBrZXkpLFxuICAgICAgICAgICAgICAgIHBlZXIsXG4gICAgICAgICAgICAgICAgcGVlcldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwZWVyKVxuICAgICAgICAgICAgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMud2l0aG91dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGVlciA9IHBlZXJzW2ldO1xuICAgICAgICBjb25zdCBrZXlzRXhpc3QgPSBIb2VrLnJlYWNoKHBhcmVudCwgcGVlciwgeyBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIGlmIChrZXlzRXhpc3QgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LndpdGhvdXQnLCB7XG4gICAgICAgICAgICAgICAgbWFpbjoga2V5LFxuICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywga2V5KSxcbiAgICAgICAgICAgICAgICBwZWVyLFxuICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcGVlcilcbiAgICAgICAgICAgIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnhvciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGVlciA9IHBlZXJzW2ldO1xuICAgICAgICBjb25zdCBrZXlzRXhpc3QgPSBIb2VrLnJlYWNoKHBhcmVudCwgcGVlciwgeyBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIGlmIChrZXlzRXhpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXNlbnQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0geyBwZWVycywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHBlZXJzKSB9O1xuXG4gICAgaWYgKHByZXNlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QubWlzc2luZycsIGNvbnRleHQsIHN0YXRlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LnByZXNlbnQgPSBwcmVzZW50O1xuICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIHByZXNlbnQpO1xuXG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC54b3InLCBjb250ZXh0LCBzdGF0ZSwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5veG9yID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHBlZXJzLCBwYXJlbnQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwZWVyID0gcGVlcnNbaV07XG4gICAgICAgIGNvbnN0IGtleXNFeGlzdCA9IEhvZWsucmVhY2gocGFyZW50LCBwZWVyLCB7IGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKGtleXNFeGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXByZXNlbnQubGVuZ3RoIHx8XG4gICAgICAgIHByZXNlbnQubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRleHQgPSB7IHBlZXJzLCBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgcGVlcnMpIH07XG4gICAgY29udGV4dC5wcmVzZW50ID0gcHJlc2VudDtcbiAgICBjb250ZXh0LnByZXNlbnRXaXRoTGFiZWxzID0gaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwcmVzZW50KTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3Qub3hvcicsIGNvbnRleHQsIHN0YXRlLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLm9yID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHBlZXJzLCBwYXJlbnQsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdvYmplY3QubWlzc2luZycsIHtcbiAgICAgICAgcGVlcnMsXG4gICAgICAgIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwZWVycylcbiAgICB9LCBzdGF0ZSwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5hbmQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgcGVlcnMsIHBhcmVudCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgY29uc3QgY291bnQgPSBwZWVycy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBlZXIgPSBwZWVyc1tpXTtcbiAgICAgICAgY29uc3Qga2V5c0V4aXN0ID0gSG9lay5yZWFjaChwYXJlbnQsIHBlZXIsIHsgZnVuY3Rpb25zOiB0cnVlIH0pO1xuICAgICAgICBpZiAoa2V5c0V4aXN0ID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgbWlzc2luZy5wdXNoKHBlZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYW9uID0gKG1pc3NpbmcubGVuZ3RoID09PSBjb3VudCB8fCBwcmVzZW50Lmxlbmd0aCA9PT0gY291bnQpO1xuXG4gICAgaWYgKCFhb24pIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignb2JqZWN0LmFuZCcsIHtcbiAgICAgICAgICAgIHByZXNlbnQsXG4gICAgICAgICAgICBwcmVzZW50V2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBwcmVzZW50KSxcbiAgICAgICAgICAgIG1pc3NpbmcsXG4gICAgICAgICAgICBtaXNzaW5nV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyh0aGlzLCBtaXNzaW5nKVxuICAgICAgICB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMubmFuZCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBwZWVycywgcGFyZW50LCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGVlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGVlciA9IHBlZXJzW2ldO1xuICAgICAgICBjb25zdCBrZXlzRXhpc3QgPSBIb2VrLnJlYWNoKHBhcmVudCwgcGVlciwgeyBmdW5jdGlvbnM6IHRydWUgfSk7XG4gICAgICAgIGlmIChrZXlzRXhpc3QgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtYWluID0gcGVlcnNbMF07XG4gICAgY29uc3QgdmFsdWVzID0gcGVlcnMuc2xpY2UoMSk7XG4gICAgY29uc3QgYWxsUHJlc2VudCA9IChwcmVzZW50Lmxlbmd0aCA9PT0gcGVlcnMubGVuZ3RoKTtcbiAgICByZXR1cm4gYWxsUHJlc2VudCA/IHRoaXMuY3JlYXRlRXJyb3IoJ29iamVjdC5uYW5kJywge1xuICAgICAgICBtYWluLFxuICAgICAgICBtYWluV2l0aExhYmVsOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHRoaXMsIG1haW4pLFxuICAgICAgICBwZWVyczogdmFsdWVzLFxuICAgICAgICBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHModGhpcywgdmFsdWVzKVxuICAgIH0sIHN0YXRlLCBvcHRpb25zKSA6IG51bGw7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5PYmplY3QoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCBwYXRoLCBwYXJlbnQsIHJlZmVyZW5jZSkge1xuXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2U7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5cbmNvbnN0IEFkZHJlc3MgPSByZXF1aXJlKCdAaGFwaS9hZGRyZXNzJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuLi9hbnknKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uLy4uL3JlZicpO1xuY29uc3QgSm9pRGF0ZSA9IHJlcXVpcmUoJy4uL2RhdGUnKTtcblxuY29uc3QgVXJpID0gcmVxdWlyZSgnLi91cmknKTtcbmNvbnN0IElwID0gcmVxdWlyZSgnLi9pcCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICB1cmlSZWdleDogVXJpLmNyZWF0ZVVyaVJlZ2V4KCksXG4gICAgaXBSZWdleDogSXAuY3JlYXRlSXBSZWdleChbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXSwgJ29wdGlvbmFsJyksXG4gICAgZ3VpZEJyYWNrZXRzOiB7XG4gICAgICAgICd7JzogJ30nLCAnWyc6ICddJywgJygnOiAnKScsICcnOiAnJ1xuICAgIH0sXG4gICAgZ3VpZFZlcnNpb25zOiB7XG4gICAgICAgIHV1aWR2MTogJzEnLFxuICAgICAgICB1dWlkdjI6ICcyJyxcbiAgICAgICAgdXVpZHYzOiAnMycsXG4gICAgICAgIHV1aWR2NDogJzQnLFxuICAgICAgICB1dWlkdjU6ICc1J1xuICAgIH0sXG4gICAgY2lkclByZXNlbmNlczogWydyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nXSxcbiAgICBub3JtYWxpemF0aW9uRm9ybXM6IFsnTkZDJywgJ05GRCcsICdORktDJywgJ05GS0QnXVxufTtcblxuXG5pbnRlcm5hbHMuU3RyaW5nID0gY2xhc3MgZXh0ZW5kcyBBbnkge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcy5hZGQoJycpO1xuICAgIH1cblxuICAgIF9iYXNlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBvcHRpb25zLmNvbnZlcnQpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9ybWFsaXplKHRoaXMuX2ZsYWdzLm5vcm1hbGl6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5jYXNlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAodGhpcy5fZmxhZ3MuY2FzZSA9PT0gJ3VwcGVyJyA/IHZhbHVlLnRvTG9jYWxlVXBwZXJDYXNlKCkgOiB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnRyaW0pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lubmVyLnJlcGxhY2VtZW50cykge1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbm5lci5yZXBsYWNlbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSB0aGlzLl9pbm5lci5yZXBsYWNlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZXBsYWNlbWVudC5wYXR0ZXJuLCByZXBsYWNlbWVudC5yZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3MudHJ1bmNhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3Rlc3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QgPSB0aGlzLl90ZXN0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3QubmFtZSA9PT0gJ21heCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgdGVzdC5hcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5ieXRlQWxpZ25lZCAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGVycm9yczogKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpID8gbnVsbCA6IHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5iYXNlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnNlbnNpdGl2ZSgpIHtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuaW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2ZsYWdzLmluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBjcmVkaXRDYXJkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdjcmVkaXRDYXJkJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGxldCBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgICAgICBsZXQgbXVsID0gMTtcblxuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXIgPSB2YWx1ZS5jaGFyQXQoaSkgKiBtdWw7XG4gICAgICAgICAgICAgICAgc3VtID0gc3VtICsgKGNoYXIgLSAoY2hhciA+IDkpICogOSk7XG4gICAgICAgICAgICAgICAgbXVsID0gbXVsIF4gMztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSAoc3VtICUgMTAgPT09IDApICYmIChzdW0gPiAwKTtcbiAgICAgICAgICAgIHJldHVybiBjaGVjayA/IHZhbHVlIDogdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmNyZWRpdENhcmQnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVnZXgocGF0dGVybiwgcGF0dGVybk9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwLCAncGF0dGVybiBtdXN0IGJlIGEgUmVnRXhwJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KCFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCdnJykgJiYgIXBhdHRlcm4uZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3BhdHRlcm4gc2hvdWxkIG5vdCB1c2UgZ2xvYmFsIG9yIHN0aWNreSBtb2RlJyk7XG5cbiAgICAgICAgY29uc3QgcGF0dGVybk9iamVjdCA9IHsgcGF0dGVybiB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybk9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuT2JqZWN0Lm5hbWUgPSBwYXR0ZXJuT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGF0dGVybk9wdGlvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuT2JqZWN0LmludmVydCA9ICEhcGF0dGVybk9wdGlvbnMuaW52ZXJ0O1xuXG4gICAgICAgICAgICBpZiAocGF0dGVybk9wdGlvbnMubmFtZSkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm5PYmplY3QubmFtZSA9IHBhdHRlcm5PcHRpb25zLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlcnJvckNvZGUgPSBbJ3N0cmluZy5yZWdleCcsIHBhdHRlcm5PYmplY3QuaW52ZXJ0ID8gJy5pbnZlcnQnIDogJycsIHBhdHRlcm5PYmplY3QubmFtZSA/ICcubmFtZScgOiAnLmJhc2UnXS5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgncmVnZXgnLCBwYXR0ZXJuT2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5NYXRjaCA9IHBhdHRlcm5PYmplY3QucGF0dGVybi50ZXN0KHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHBhdHRlcm5NYXRjaCBeIHBhdHRlcm5PYmplY3QuaW52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcihlcnJvckNvZGUsIHsgbmFtZTogcGF0dGVybk9iamVjdC5uYW1lLCBwYXR0ZXJuOiBwYXR0ZXJuT2JqZWN0LnBhdHRlcm4sIHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWxwaGFudW0oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2FscGhhbnVtJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICgvXlthLXpBLVowLTldKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmFscGhhbnVtJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRva2VuKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCd0b2tlbicsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAoL15cXHcrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcudG9rZW4nLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZW1haWwodmFsaWRhdGlvbk9wdGlvbnMpIHtcblxuICAgICAgICBpZiAodmFsaWRhdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiB2YWxpZGF0aW9uT3B0aW9ucyA9PT0gJ29iamVjdCcsICdlbWFpbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICAgICAgICAgIC8vIE1pZ3JhdGlvbiB2YWxpZGF0aW9uIGZvciB1bnN1cHBvcnRlZCBvcHRpb25zXG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLmNoZWNrRE5TID09PSB1bmRlZmluZWQsICdjaGVja0ROUyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsaWRhdGlvbk9wdGlvbnMuZXJyb3JMZXZlbCA9PT0gdW5kZWZpbmVkLCAnZXJyb3JMZXZlbCBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsaWRhdGlvbk9wdGlvbnMubWluRG9tYWluQXRvbXMgPT09IHVuZGVmaW5lZCwgJ21pbkRvbWFpbkF0b21zIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgbWluRG9tYWluU2VnbWVudHMgaW5zdGVhZCcpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsaWRhdGlvbk9wdGlvbnMudGxkQmxhY2tsaXN0ID09PSB1bmRlZmluZWQsICd0bGRCbGFja2xpc3Qgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0bGRzLmRlbnkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsaWRhdGlvbk9wdGlvbnMudGxkV2hpdGVsaXN0ID09PSB1bmRlZmluZWQsICd0bGRXaGl0ZWxpc3Qgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0bGRzLmFsbG93IGluc3RlYWQnKTtcblxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgb3B0aW9uc1xuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbk9wdGlvbnMudGxkcyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWxpZGF0aW9uT3B0aW9ucy50bGRzID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodmFsaWRhdGlvbk9wdGlvbnMudGxkcy5hbGxvdyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25PcHRpb25zLnRsZHMuYWxsb3cgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25PcHRpb25zLnRsZHMuYWxsb3cgPT09IHRydWUgfHxcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmFsbG93KSB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmFsbG93IGluc3RhbmNlb2YgU2V0LCAndGxkcy5hbGxvdyBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLnRsZHMuZGVueSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFsaWRhdGlvbk9wdGlvbnMudGxkcy5kZW55KSB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmRlbnkgaW5zdGFuY2VvZiBTZXQsICd0bGRzLmRlbnkgbXVzdCBiZSBhbiBhcnJheSBvciBTZXQnKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZVRhYmxlID0gKHRhYmxlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhYmxlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YWJsZSA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZSBpbnN0YW5jZW9mIFNldCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldCh0YWJsZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsaWRhdGlvbk9wdGlvbnMpOyAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25PcHRpb25zLnRsZHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93OiBub3JtYWxpemVUYWJsZSh2YWxpZGF0aW9uT3B0aW9ucy50bGRzLmFsbG93KSxcbiAgICAgICAgICAgICAgICAgICAgZGVueTogbm9ybWFsaXplVGFibGUodmFsaWRhdGlvbk9wdGlvbnMudGxkcy5kZW55KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHZhbGlkYXRpb25PcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWxpZGF0aW9uT3B0aW9ucy5taW5Eb21haW5TZWdtZW50cykgJiYgdmFsaWRhdGlvbk9wdGlvbnMubWluRG9tYWluU2VnbWVudHMgPiAwLCAnbWluRG9tYWluU2VnbWVudHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdlbWFpbCcsIHZhbGlkYXRpb25PcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChBZGRyZXNzLmVtYWlsLmlzVmFsaWQodmFsdWUsIHZhbGlkYXRpb25PcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5lbWFpbCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpcChpcE9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGxldCByZWdleCA9IGludGVybmFscy5pcFJlZ2V4O1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgaXBPcHRpb25zID09PSAnb2JqZWN0JywgJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgICAgICBpZiAoaXBPcHRpb25zLmNpZHIpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBpcE9wdGlvbnMuY2lkciA9PT0gJ3N0cmluZycsICdjaWRyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIGlwT3B0aW9ucy5jaWRyID0gaXBPcHRpb25zLmNpZHIudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgSG9lay5hc3NlcnQoSG9lay5jb250YWluKGludGVybmFscy5jaWRyUHJlc2VuY2VzLCBpcE9wdGlvbnMuY2lkciksICdjaWRyIG11c3QgYmUgb25lIG9mICcgKyBpbnRlcm5hbHMuY2lkclByZXNlbmNlcy5qb2luKCcsICcpKTtcblxuICAgICAgICAgICAgLy8gSWYgd2Ugb25seSByZWNlaXZlZCBhIGBjaWRyYCBzZXR0aW5nLCBjcmVhdGUgYSByZWdleCBmb3IgaXQuIEJ1dCB3ZSBkb24ndCBuZWVkIHRvIGNyZWF0ZSBvbmUgaWYgYGNpZHJgIGlzIFwib3B0aW9uYWxcIiBzaW5jZSB0aGF0IGlzIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICBpZiAoIWlwT3B0aW9ucy52ZXJzaW9uICYmIGlwT3B0aW9ucy5jaWRyICE9PSAnb3B0aW9uYWwnKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSBJcC5jcmVhdGVJcFJlZ2V4KFsnaXB2NCcsICdpcHY2JywgJ2lwdmZ1dHVyZSddLCBpcE9wdGlvbnMuY2lkcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIFNldCBvdXIgZGVmYXVsdCBjaWRyIHN0cmF0ZWd5XG4gICAgICAgICAgICBpcE9wdGlvbnMuY2lkciA9ICdvcHRpb25hbCc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmVyc2lvbnM7XG4gICAgICAgIGlmIChpcE9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlwT3B0aW9ucy52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIGlwT3B0aW9ucy52ZXJzaW9uID0gW2lwT3B0aW9ucy52ZXJzaW9uXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSG9lay5hc3NlcnQoaXBPcHRpb25zLnZlcnNpb24ubGVuZ3RoID49IDEsICd2ZXJzaW9uIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHZlcnNpb24gc3BlY2lmaWVkJyk7XG5cbiAgICAgICAgICAgIHZlcnNpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlwT3B0aW9ucy52ZXJzaW9uLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBpcE9wdGlvbnMudmVyc2lvbltpXTtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycsICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydChJcC52ZXJzaW9uc1t2ZXJzaW9uXSwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhJcC52ZXJzaW9ucykuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBzZXQgb2YgdmVyc2lvbnNcbiAgICAgICAgICAgIHZlcnNpb25zID0gQXJyYXkuZnJvbShuZXcgU2V0KHZlcnNpb25zKSk7XG5cbiAgICAgICAgICAgIHJlZ2V4ID0gSXAuY3JlYXRlSXBSZWdleCh2ZXJzaW9ucywgaXBPcHRpb25zLmNpZHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2lwJywgaXBPcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZlcnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5pcFZlcnNpb24nLCB7IHZhbHVlLCBjaWRyOiBpcE9wdGlvbnMuY2lkciwgdmVyc2lvbjogdmVyc2lvbnMgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmlwJywgeyB2YWx1ZSwgY2lkcjogaXBPcHRpb25zLmNpZHIgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB1cmkodXJpT3B0aW9ucykge1xuXG4gICAgICAgIGxldCBjdXN0b21TY2hlbWUgPSAnJztcbiAgICAgICAgbGV0IGFsbG93UmVsYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlbGF0aXZlT25seSA9IGZhbHNlO1xuICAgICAgICBsZXQgYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzID0gZmFsc2U7XG4gICAgICAgIGxldCByZWdleCA9IGludGVybmFscy51cmlSZWdleDtcblxuICAgICAgICBpZiAodXJpT3B0aW9ucykge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHVyaU9wdGlvbnMgPT09ICdvYmplY3QnLCAnb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuXG4gICAgICAgICAgICBjb25zdCB1bmtub3duT3B0aW9ucyA9IE9iamVjdC5rZXlzKHVyaU9wdGlvbnMpLmZpbHRlcigoa2V5KSA9PiAhWydzY2hlbWUnLCAnYWxsb3dSZWxhdGl2ZScsICdyZWxhdGl2ZU9ubHknLCAnYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzJ10uaW5jbHVkZXMoa2V5KSk7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh1bmtub3duT3B0aW9ucy5sZW5ndGggPT09IDAsIGBvcHRpb25zIGNvbnRhaW4gdW5rbm93biBrZXlzOiAke3Vua25vd25PcHRpb25zfWApO1xuXG4gICAgICAgICAgICBpZiAodXJpT3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCh1cmlPcHRpb25zLnNjaGVtZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCB0eXBlb2YgdXJpT3B0aW9ucy5zY2hlbWUgPT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkodXJpT3B0aW9ucy5zY2hlbWUpLCAnc2NoZW1lIG11c3QgYmUgYSBSZWdFeHAsIFN0cmluZywgb3IgQXJyYXknKTtcblxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh1cmlPcHRpb25zLnNjaGVtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJpT3B0aW9ucy5zY2hlbWUgPSBbdXJpT3B0aW9ucy5zY2hlbWVdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHVyaU9wdGlvbnMuc2NoZW1lLmxlbmd0aCA+PSAxLCAnc2NoZW1lIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHNjaGVtZSBzcGVjaWZpZWQnKTtcblxuICAgICAgICAgICAgICAgIC8vIEZsYXR0ZW4gdGhlIGFycmF5IGludG8gYSBzdHJpbmcgdG8gYmUgdXNlZCB0byBtYXRjaCB0aGUgc2NoZW1lcy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVyaU9wdGlvbnMuc2NoZW1lLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IHVyaU9wdGlvbnMuc2NoZW1lW2ldO1xuICAgICAgICAgICAgICAgICAgICBIb2VrLmFzc2VydChzY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycsICdzY2hlbWUgYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBSZWdFeHAgb3IgU3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIE9SIHNlcGFyYXRvcnMgaWYgYSB2YWx1ZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21TY2hlbWUgPSBjdXN0b21TY2hlbWUgKyAoY3VzdG9tU2NoZW1lID8gJ3wnIDogJycpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHNvbWVvbmUgd2FudHMgdG8gbWF0Y2ggSFRUUCBvciBIVFRQUyBmb3IgZXhhbXBsZSB0aGVuIHdlIG5lZWQgdG8gc3VwcG9ydCBib3RoIFJlZ0V4cCBhbmQgU3RyaW5nIHNvIHdlIGRvbid0IGVzY2FwZSB0aGVpciBwYXR0ZXJuIHVua25vd2luZ2x5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21TY2hlbWUgPSBjdXN0b21TY2hlbWUgKyBzY2hlbWUuc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgSG9lay5hc3NlcnQoL1thLXpBLVpdW2EtekEtWjAtOSstXFwuXSovLnRlc3Qoc2NoZW1lKSwgJ3NjaGVtZSBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHZhbGlkIHNjaGVtZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tU2NoZW1lID0gY3VzdG9tU2NoZW1lICsgSG9lay5lc2NhcGVSZWdleChzY2hlbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodXJpT3B0aW9ucy5hbGxvd1JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dSZWxhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1cmlPcHRpb25zLnJlbGF0aXZlT25seSkge1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlT25seSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1cmlPcHRpb25zLmFsbG93UXVlcnlTcXVhcmVCcmFja2V0cykge1xuICAgICAgICAgICAgICAgIGFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VzdG9tU2NoZW1lIHx8IGFsbG93UmVsYXRpdmUgfHwgcmVsYXRpdmVPbmx5IHx8IGFsbG93UXVlcnlTcXVhcmVCcmFja2V0cykge1xuICAgICAgICAgICAgcmVnZXggPSBVcmkuY3JlYXRlVXJpUmVnZXgoY3VzdG9tU2NoZW1lLCBhbGxvd1JlbGF0aXZlLCByZWxhdGl2ZU9ubHksIGFsbG93UXVlcnlTcXVhcmVCcmFja2V0cyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgndXJpJywgdXJpT3B0aW9ucywgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnVyaVJlbGF0aXZlT25seScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VzdG9tU2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy51cmlDdXN0b21TY2hlbWUnLCB7IHNjaGVtZTogY3VzdG9tU2NoZW1lLCB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcudXJpJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzb0RhdGUoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2lzb0RhdGUnLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKEpvaURhdGUuX2lzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuY29udmVydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGQuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5pc29EYXRlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGd1aWQoZ3VpZE9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgdmVyc2lvbk51bWJlcnMgPSAnJztcblxuICAgICAgICBpZiAoZ3VpZE9wdGlvbnMgJiYgZ3VpZE9wdGlvbnMudmVyc2lvbikge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGd1aWRPcHRpb25zLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgZ3VpZE9wdGlvbnMudmVyc2lvbiA9IFtndWlkT3B0aW9ucy52ZXJzaW9uXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSG9lay5hc3NlcnQoZ3VpZE9wdGlvbnMudmVyc2lvbi5sZW5ndGggPj0gMSwgJ3ZlcnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmFsaWQgdmVyc2lvbiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25zID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGd1aWRPcHRpb25zLnZlcnNpb24ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmVyc2lvbiA9IGd1aWRPcHRpb25zLnZlcnNpb25baV07XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbk51bWJlciA9IGludGVybmFscy5ndWlkVmVyc2lvbnNbdmVyc2lvbl07XG4gICAgICAgICAgICAgICAgSG9lay5hc3NlcnQodmVyc2lvbk51bWJlciwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhpbnRlcm5hbHMuZ3VpZFZlcnNpb25zKS5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICBIb2VrLmFzc2VydCghKHZlcnNpb25zLmhhcyh2ZXJzaW9uTnVtYmVyKSksICd2ZXJzaW9uIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IG5vdCBiZSBhIGR1cGxpY2F0ZS4nKTtcblxuICAgICAgICAgICAgICAgIHZlcnNpb25OdW1iZXJzICs9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgICAgICAgICAgdmVyc2lvbnMuYWRkKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ3VpZFJlZ2V4ID0gbmV3IFJlZ0V4cChgXihbXFxcXFt7XFxcXChdPylbMC05QS1GXXs4fShbOi1dPylbMC05QS1GXXs0fVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzIHx8ICcwLTlBLUYnfV1bMC05QS1GXXszfVxcXFwyP1ske3ZlcnNpb25OdW1iZXJzID8gJzg5QUInIDogJzAtOUEtRid9XVswLTlBLUZdezN9XFxcXDI/WzAtOUEtRl17MTJ9KFtcXFxcXX1cXFxcKV0/KSRgLCAnaScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdndWlkJywgZ3VpZE9wdGlvbnMsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGd1aWRSZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5ndWlkJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1hdGNoaW5nIGJyYWNlc1xuICAgICAgICAgICAgaWYgKGludGVybmFscy5ndWlkQnJhY2tldHNbcmVzdWx0c1sxXV0gIT09IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuZ3VpZCcsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhleChoZXhPcHRpb25zID0ge30pIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgaGV4T3B0aW9ucyA9PT0gJ29iamVjdCcsICdoZXggb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgaGV4T3B0aW9ucy5ieXRlQWxpZ25lZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGhleE9wdGlvbnMuYnl0ZUFsaWduZWQgPT09ICdib29sZWFuJyxcbiAgICAgICAgICAgICdieXRlQWxpZ25lZCBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICBjb25zdCBieXRlQWxpZ25lZCA9IGhleE9wdGlvbnMuYnl0ZUFsaWduZWQgPT09IHRydWU7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL15bYS1mMC05XSskL2k7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5fdGVzdCgnaGV4JywgcmVnZXgsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVBbGlnbmVkICYmIHZhbHVlLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5oZXhBbGlnbicsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5oZXgnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJ5dGVBbGlnbmVkKSB7XG4gICAgICAgICAgICBvYmouX2ZsYWdzLmJ5dGVBbGlnbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgYmFzZTY0KGJhc2U2NE9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIC8vIFZhbGlkYXRpb24uXG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBiYXNlNjRPcHRpb25zID09PSAnb2JqZWN0JywgJ2Jhc2U2NCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBiYXNlNjRPcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGJhc2U2NE9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID09PSAnYm9vbGVhbicsXG4gICAgICAgICAgICAncGFkZGluZ1JlcXVpcmVkIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiBwYWRkaW5nIGlzIHJlcXVpcmVkLlxuICAgICAgICBjb25zdCBwYWRkaW5nUmVxdWlyZWQgPSBiYXNlNjRPcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gZmFsc2UgP1xuICAgICAgICAgICAgYmFzZTY0T3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRcbiAgICAgICAgICAgIDogYmFzZTY0T3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgfHwgdHJ1ZTtcblxuICAgICAgICAvLyBTZXQgdmFsaWRhdGlvbiBiYXNlZCBvbiBwcmVmZXJlbmNlLlxuICAgICAgICBjb25zdCByZWdleCA9IHBhZGRpbmdSZXF1aXJlZCA/XG4gICAgICAgICAgICAvLyBQYWRkaW5nIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgL14oPzpbQS1aYS16MC05K1xcL117Mn1bQS1aYS16MC05K1xcL117Mn0pKig/OltBLVphLXowLTkrXFwvXXsyfT09fFtBLVphLXowLTkrXFwvXXszfT0pPyQvXG4gICAgICAgICAgICAvLyBQYWRkaW5nIGlzIG9wdGlvbmFsLlxuICAgICAgICAgICAgOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9KD09KT98W0EtWmEtejAtOStcXC9dezN9PT8pPyQvO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KCdiYXNlNjQnLCByZWdleCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuYmFzZTY0JywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRhdGFVcmkoZGF0YVVyaU9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gL15kYXRhOltcXHcrLi1dK1xcL1tcXHcrLi1dKzsoKGNoYXJzZXQ9W1xcdy1dK3xiYXNlNjQpLCk/KC4qKSQvO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiBwYWRkaW5nIGlzIHJlcXVpcmVkLlxuICAgICAgICBjb25zdCBwYWRkaW5nUmVxdWlyZWQgPSBkYXRhVXJpT3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09IGZhbHNlID9cbiAgICAgICAgICAgIGRhdGFVcmlPcHRpb25zLnBhZGRpbmdSZXF1aXJlZFxuICAgICAgICAgICAgOiBkYXRhVXJpT3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgfHwgdHJ1ZTtcblxuICAgICAgICBjb25zdCBiYXNlNjRyZWdleCA9IHBhZGRpbmdSZXF1aXJlZCA/XG4gICAgICAgICAgICAvXig/OltBLVphLXowLTkrXFwvXXs0fSkqKD86W0EtWmEtejAtOStcXC9dezJ9PT18W0EtWmEtejAtOStcXC9dezN9PSk/JC9cbiAgICAgICAgICAgIDogL14oPzpbQS1aYS16MC05K1xcL117NH0pKig/OltBLVphLXowLTkrXFwvXXsyfSg9PSk/fFtBLVphLXowLTkrXFwvXXszfT0/KT8kLztcblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdCgnZGF0YVVyaScsIHJlZ2V4LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaChyZWdleCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1syXSAhPT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiYXNlNjRyZWdleC50ZXN0KG1hdGNoZXNbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKCdzdHJpbmcuZGF0YVVyaScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBob3N0bmFtZSgpIHtcblxuICAgICAgICBjb25zdCByZWdleCA9IC9eKChbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTlcXC1dKlthLXpBLVowLTldKVxcLikqKFtBLVphLXowLTldfFtBLVphLXowLTldW0EtWmEtejAtOVxcLV0qW0EtWmEtejAtOV0pJC87XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rlc3QoJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmICgodmFsdWUubGVuZ3RoIDw9IDI1NSAmJiByZWdleC50ZXN0KHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICBOZXQuaXNJUHY2KHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLmhvc3RuYW1lJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZShmb3JtID0gJ05GQycpIHtcblxuICAgICAgICBIb2VrLmFzc2VydChIb2VrLmNvbnRhaW4oaW50ZXJuYWxzLm5vcm1hbGl6YXRpb25Gb3JtcywgZm9ybSksICdub3JtYWxpemF0aW9uIGZvcm0gbXVzdCBiZSBvbmUgb2YgJyArIGludGVybmFscy5ub3JtYWxpemF0aW9uRm9ybXMuam9pbignLCAnKSk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5fdGVzdCgnbm9ybWFsaXplJywgZm9ybSwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IHZhbHVlLm5vcm1hbGl6ZShmb3JtKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLm5vcm1hbGl6ZScsIHsgdmFsdWUsIGZvcm0gfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYmouX2ZsYWdzLm5vcm1hbGl6ZSA9IGZvcm07XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbG93ZXJjYXNlKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Rlc3QoJ2xvd2VyY2FzZScsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0IHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgPT09IHZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy5sb3dlcmNhc2UnLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqLl9mbGFncy5jYXNlID0gJ2xvd2VyJztcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICB1cHBlcmNhc2UoKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5fdGVzdCgndXBwZXJjYXNlJywgdW5kZWZpbmVkLCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnZlcnQgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnVwcGVyY2FzZScsIHsgdmFsdWUgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBvYmouX2ZsYWdzLmNhc2UgPSAndXBwZXInO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRyaW0oZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnb3B0aW9uIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgaWYgKCh0aGlzLl9mbGFncy50cmltICYmIGVuYWJsZWQpIHx8ICghdGhpcy5fZmxhZ3MudHJpbSAmJiAhZW5hYmxlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9iajtcbiAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IHRoaXMuX3Rlc3QoJ3RyaW0nLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbnZlcnQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09IHZhbHVlLnRyaW0oKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnRyaW0nLCB7IHZhbHVlIH0sIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgb2JqLl90ZXN0cyA9IG9iai5fdGVzdHMuZmlsdGVyKCh0ZXN0KSA9PiB0ZXN0Lm5hbWUgIT09ICd0cmltJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX2ZsYWdzLnRyaW0gPSBlbmFibGVkO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJlcGxhY2UocGF0dGVybiwgcmVwbGFjZW1lbnQpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChIb2VrLmVzY2FwZVJlZ2V4KHBhdHRlcm4pLCAnZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgSG9lay5hc3NlcnQocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCwgJ3BhdHRlcm4gbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnLCAncmVwbGFjZW1lbnQgbXVzdCBiZSBhIFN0cmluZycpO1xuXG4gICAgICAgIC8vIFRoaXMgY2FuIG5vdCBiZSBjb25zaWRlcmUgYSB0ZXN0IGxpa2UgdHJpbSwgd2UgY2FuJ3QgXCJyZWplY3RcIlxuICAgICAgICAvLyBhbnl0aGluZyBmcm9tIHRoaXMgcnVsZSwgc28ganVzdCBjbG9uZSB0aGUgY3VycmVudCBvYmplY3RcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICghb2JqLl9pbm5lci5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgIG9iai5faW5uZXIucmVwbGFjZW1lbnRzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBvYmouX2lubmVyLnJlcGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICByZXBsYWNlbWVudFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHRydW5jYXRlKGVuYWJsZWQpIHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWVuYWJsZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLnRydW5jYXRlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fZmxhZ3MudHJ1bmNhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbn07XG5cbmludGVybmFscy5jb21wYXJlID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBhcmUpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiAobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgY29uc3QgaXNSZWYgPSBSZWYuaXNSZWYobGltaXQpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCkgJiYgbGltaXQgPj0gMCkgfHwgaXNSZWYsICdsaW1pdCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciByZWZlcmVuY2UnKTtcbiAgICAgICAgSG9lay5hc3NlcnQoIWVuY29kaW5nIHx8IEJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSwgJ0ludmFsaWQgZW5jb2Rpbmc6JywgZW5jb2RpbmcpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXN0KHR5cGUsIGxpbWl0LCBmdW5jdGlvbiAodmFsdWUsIHN0YXRlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgICAgIGxldCBjb21wYXJlVG87XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb21wYXJlVG8gPSBsaW1pdChzdGF0ZS5yZWZlcmVuY2UgfHwgc3RhdGUucGFyZW50LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoY29tcGFyZVRvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcignc3RyaW5nLnJlZicsIHsgcmVmOiBsaW1pdCwgdmFsdWU6IGNvbXBhcmVUbyB9LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRvID0gbGltaXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb21wYXJlKHZhbHVlLCBjb21wYXJlVG8sIGVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRXJyb3IoJ3N0cmluZy4nICsgdHlwZSwgeyBsaW1pdDogY29tcGFyZVRvLCB2YWx1ZSwgZW5jb2RpbmcgfSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuU3RyaW5nLnByb3RvdHlwZS5taW4gPSBpbnRlcm5hbHMuY29tcGFyZSgnbWluJywgKHZhbHVlLCBsaW1pdCwgZW5jb2RpbmcpID0+IHtcblxuICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kaW5nID8gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUsIGVuY29kaW5nKSA6IHZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuZ3RoID49IGxpbWl0O1xufSk7XG5cblxuaW50ZXJuYWxzLlN0cmluZy5wcm90b3R5cGUubWF4ID0gaW50ZXJuYWxzLmNvbXBhcmUoJ21heCcsICh2YWx1ZSwgbGltaXQsIGVuY29kaW5nKSA9PiB7XG5cbiAgICBjb25zdCBsZW5ndGggPSBlbmNvZGluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZykgOiB2YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA8PSBsaW1pdDtcbn0pO1xuXG5cbmludGVybmFscy5TdHJpbmcucHJvdG90eXBlLmxlbmd0aCA9IGludGVybmFscy5jb21wYXJlKCdsZW5ndGgnLCAodmFsdWUsIGxpbWl0LCBlbmNvZGluZykgPT4ge1xuXG4gICAgY29uc3QgbGVuZ3RoID0gZW5jb2RpbmcgPyBCdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSwgZW5jb2RpbmcpIDogdmFsdWUubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPT09IGxpbWl0O1xufSk7XG5cbi8vIEFsaWFzZXNcblxuaW50ZXJuYWxzLlN0cmluZy5wcm90b3R5cGUudXVpZCA9IGludGVybmFscy5TdHJpbmcucHJvdG90eXBlLmd1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IGludGVybmFscy5TdHJpbmcoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUkZDMzk4NiA9IHJlcXVpcmUoJy4vcmZjMzk4NicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBJcDoge1xuICAgICAgICBjaWRyczoge1xuICAgICAgICAgICAgaXB2NDoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAnXFxcXC8oPzonICsgUkZDMzk4Ni5pcHY0Q2lkciArICcpJyxcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogJyg/OlxcXFwvKD86JyArIFJGQzM5ODYuaXB2NENpZHIgKyAnKSk/JyxcbiAgICAgICAgICAgICAgICBmb3JiaWRkZW46ICcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXB2Njoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAnXFxcXC8nICsgUkZDMzk4Ni5pcHY2Q2lkcixcbiAgICAgICAgICAgICAgICBvcHRpb25hbDogJyg/OlxcXFwvJyArIFJGQzM5ODYuaXB2NkNpZHIgKyAnKT8nLFxuICAgICAgICAgICAgICAgIGZvcmJpZGRlbjogJydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpcHZmdXR1cmU6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogJ1xcXFwvJyArIFJGQzM5ODYuaXB2NkNpZHIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6ICcoPzpcXFxcLycgKyBSRkMzOTg2LmlwdjZDaWRyICsgJyk/JyxcbiAgICAgICAgICAgICAgICBmb3JiaWRkZW46ICcnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZlcnNpb25zOiB7XG4gICAgICAgICAgICBpcHY0OiBSRkMzOTg2LklQdjRhZGRyZXNzLFxuICAgICAgICAgICAgaXB2NjogUkZDMzk4Ni5JUHY2YWRkcmVzcyxcbiAgICAgICAgICAgIGlwdmZ1dHVyZTogUkZDMzk4Ni5JUHZGdXR1cmVcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLklwLmNyZWF0ZUlwUmVnZXggPSBmdW5jdGlvbiAodmVyc2lvbnMsIGNpZHIpIHtcblxuICAgIGxldCByZWdleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uc1tpXTtcbiAgICAgICAgaWYgKCFyZWdleCkge1xuICAgICAgICAgICAgcmVnZXggPSAnXig/OicgKyBpbnRlcm5hbHMuSXAudmVyc2lvbnNbdmVyc2lvbl0gKyBpbnRlcm5hbHMuSXAuY2lkcnNbdmVyc2lvbl1bY2lkcl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWdleCArPSAnfCcgKyBpbnRlcm5hbHMuSXAudmVyc2lvbnNbdmVyc2lvbl0gKyBpbnRlcm5hbHMuSXAuY2lkcnNbdmVyc2lvbl1bY2lkcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCArICcpJCcpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuSXA7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICByZmMzOTg2OiB7fVxufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvKipcbiAgICAgKiBlbGVtZW50cyBzZXBhcmF0ZWQgYnkgZm9yd2FyZCBzbGFzaCAoXCIvXCIpIGFyZSBhbHRlcm5hdGl2ZXMuXG4gICAgICovXG4gICAgY29uc3Qgb3IgPSAnfCc7XG5cbiAgICAvKipcbiAgICAgKiBSdWxlIHRvIHN1cHBvcnQgemVyby1wYWRkZWQgYWRkcmVzc2VzLlxuICAgICAqL1xuICAgIGNvbnN0IHplcm9QYWQgPSAnMD8nO1xuXG4gICAgLyoqXG4gICAgICogRElHSVQgPSAleDMwLTM5IDsgMC05XG4gICAgICovXG4gICAgY29uc3QgZGlnaXQgPSAnMC05JztcbiAgICBjb25zdCBkaWdpdE9ubHkgPSAnWycgKyBkaWdpdCArICddJztcblxuICAgIC8qKlxuICAgICAqIEFMUEhBID0gJXg0MS01QSAvICV4NjEtN0EgICA7IEEtWiAvIGEtelxuICAgICAqL1xuICAgIGNvbnN0IGFscGhhID0gJ2EtekEtWic7XG4gICAgY29uc3QgYWxwaGFPbmx5ID0gJ1snICsgYWxwaGEgKyAnXSc7XG5cbiAgICAvKipcbiAgICAgKiBJUHY0XG4gICAgICogY2lkciAgICAgICA9IERJR0lUICAgICAgICAgICAgICAgIDsgMC05XG4gICAgICogICAgICAgICAgICAvICV4MzEtMzIgRElHSVQgICAgICAgICA7IDEwLTI5XG4gICAgICogICAgICAgICAgICAvIFwiM1wiICV4MzAtMzIgICAgICAgICAgIDsgMzAtMzJcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5pcHY0Q2lkciA9IGRpZ2l0T25seSArIG9yICsgJ1sxLTJdJyArIGRpZ2l0T25seSArIG9yICsgJzMnICsgJ1swLTJdJztcblxuICAgIC8qKlxuICAgICAqIElQdjZcbiAgICAgKiBjaWRyICAgICAgID0gRElHSVQgICAgICAgICAgICAgICAgIDsgMC05XG4gICAgICogICAgICAgICAgICAvICV4MzEtMzkgRElHSVQgICAgICAgICA7IDEwLTk5XG4gICAgICogICAgICAgICAgICAvIFwiMVwiICV4MC0xIERJR0lUICAgICAgIDsgMTAwLTExOVxuICAgICAqICAgICAgICAgICAgLyBcIjEyXCIgJXgwLTggICAgICAgICAgICA7IDEyMC0xMjhcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5pcHY2Q2lkciA9ICcoPzonICsgemVyb1BhZCArIHplcm9QYWQgKyBkaWdpdE9ubHkgKyBvciArIHplcm9QYWQgKyAnWzEtOV0nICsgZGlnaXRPbmx5ICsgb3IgKyAnMScgKyAnWzAxXScgKyBkaWdpdE9ubHkgKyBvciArICcxMlswLThdKSc7XG5cbiAgICAvKipcbiAgICAgKiBIRVhESUcgPSBESUdJVCAvIFwiQVwiIC8gXCJCXCIgLyBcIkNcIiAvIFwiRFwiIC8gXCJFXCIgLyBcIkZcIlxuICAgICAqL1xuICAgIGNvbnN0IGhleERpZ2l0ID0gZGlnaXQgKyAnQS1GYS1mJztcbiAgICBjb25zdCBoZXhEaWdpdE9ubHkgPSAnWycgKyBoZXhEaWdpdCArICddJztcblxuICAgIC8qKlxuICAgICAqIHVucmVzZXJ2ZWQgPSBBTFBIQSAvIERJR0lUIC8gXCItXCIgLyBcIi5cIiAvIFwiX1wiIC8gXCJ+XCJcbiAgICAgKi9cbiAgICBjb25zdCB1bnJlc2VydmVkID0gYWxwaGEgKyBkaWdpdCArICctXFxcXC5ffic7XG5cbiAgICAvKipcbiAgICAgKiBzdWItZGVsaW1zID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxuICAgICAqL1xuICAgIGNvbnN0IHN1YkRlbGltcyA9ICchXFxcXCQmXFwnXFxcXChcXFxcKVxcXFwqXFxcXCssOz0nO1xuXG4gICAgLyoqXG4gICAgICogcGN0LWVuY29kZWQgPSBcIiVcIiBIRVhESUcgSEVYRElHXG4gICAgICovXG4gICAgY29uc3QgcGN0RW5jb2RlZCA9ICclJyArIGhleERpZ2l0O1xuXG4gICAgLyoqXG4gICAgICogcGNoYXIgPSB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgLyBcIkBcIlxuICAgICAqL1xuICAgIGNvbnN0IHBjaGFyID0gdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnOkAnO1xuICAgIGNvbnN0IHBjaGFyT25seSA9ICdbJyArIHBjaGFyICsgJ10nO1xuXG4gICAgLyoqXG4gICAgICogc3F1YXJlQnJhY2tldHMgZXhhbXBsZTogW11cbiAgICAgKi9cbiAgICBjb25zdCBzcXVhcmVCcmFja2V0cyA9ICdcXFxcW1xcXFxdJztcblxuICAgIC8qKlxuICAgICAqIGRlYy1vY3RldCAgID0gRElHSVQgICAgICAgICAgICAgICAgIDsgMC05XG4gICAgICogICAgICAgICAgICAvICV4MzEtMzkgRElHSVQgICAgICAgICA7IDEwLTk5XG4gICAgICogICAgICAgICAgICAvIFwiMVwiIDJESUdJVCAgICAgICAgICAgIDsgMTAwLTE5OVxuICAgICAqICAgICAgICAgICAgLyBcIjJcIiAleDMwLTM0IERJR0lUICAgICA7IDIwMC0yNDlcbiAgICAgKiAgICAgICAgICAgIC8gXCIyNVwiICV4MzAtMzUgICAgICAgICAgOyAyNTAtMjU1XG4gICAgICovXG4gICAgY29uc3QgZGVjT2N0ZWN0ID0gJyg/OicgKyB6ZXJvUGFkICsgemVyb1BhZCArIGRpZ2l0T25seSArIG9yICsgemVyb1BhZCArICdbMS05XScgKyBkaWdpdE9ubHkgKyBvciArICcxJyArIGRpZ2l0T25seSArIGRpZ2l0T25seSArIG9yICsgJzInICsgJ1swLTRdJyArIGRpZ2l0T25seSArIG9yICsgJzI1JyArICdbMC01XSknO1xuXG4gICAgLyoqXG4gICAgICogSVB2NGFkZHJlc3MgPSBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXRcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5JUHY0YWRkcmVzcyA9ICcoPzonICsgZGVjT2N0ZWN0ICsgJ1xcXFwuKXszfScgKyBkZWNPY3RlY3Q7XG5cbiAgICAvKipcbiAgICAgKiBoMTYgPSAxKjRIRVhESUcgOyAxNiBiaXRzIG9mIGFkZHJlc3MgcmVwcmVzZW50ZWQgaW4gaGV4YWRlY2ltYWxcbiAgICAgKiBsczMyID0gKCBoMTYgXCI6XCIgaDE2ICkgLyBJUHY0YWRkcmVzcyA7IGxlYXN0LXNpZ25pZmljYW50IDMyIGJpdHMgb2YgYWRkcmVzc1xuICAgICAqIElQdjZhZGRyZXNzID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgNiggaDE2IFwiOlwiICkgbHMzMlxuICAgICAqICAgICAgICAgICAgIC8gICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICogICAgICAgICAgICAgLyBbICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvIFsgKjEoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAzKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICogICAgICAgICAgICAgLyBbICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuICAgICAqICAgICAgICAgICAgIC8gWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICAgKiAgICAgICAgICAgICAvIFsgKjQoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgbHMzMlxuICAgICAqICAgICAgICAgICAgIC8gWyAqNSggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBoMTZcbiAgICAgKiAgICAgICAgICAgICAvIFsgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgICAqL1xuICAgIGNvbnN0IGgxNiA9IGhleERpZ2l0T25seSArICd7MSw0fSc7XG4gICAgY29uc3QgbHMzMiA9ICcoPzonICsgaDE2ICsgJzonICsgaDE2ICsgJ3wnICsgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NGFkZHJlc3MgKyAnKSc7XG4gICAgY29uc3QgSVB2NlNpeEhleCA9ICcoPzonICsgaDE2ICsgJzopezZ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZpdmVIZXggPSAnOjooPzonICsgaDE2ICsgJzopezV9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZvdXJIZXggPSAnKD86JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXs0fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZUaHJlZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMX0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezN9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NlR3b0hleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMn0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezJ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsM30nICsgaDE2ICsgJyk/OjonICsgaDE2ICsgJzonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNH0nICsgaDE2ICsgJyk/OjonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDIgPSAnKD86KD86JyArIGgxNiArICc6KXswLDV9JyArIGgxNiArICcpPzo6JyArIGgxNjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDMgPSAnKD86KD86JyArIGgxNiArICc6KXswLDZ9JyArIGgxNiArICcpPzo6JztcbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5JUHY2YWRkcmVzcyA9ICcoPzonICsgSVB2NlNpeEhleCArIG9yICsgSVB2NkZpdmVIZXggKyBvciArIElQdjZGb3VySGV4ICsgb3IgKyBJUHY2VGhyZWVIZXggKyBvciArIElQdjZUd29IZXggKyBvciArIElQdjZPbmVIZXggKyBvciArIElQdjZOb25lSGV4ICsgb3IgKyBJUHY2Tm9uZUhleDIgKyBvciArIElQdjZOb25lSGV4MyArICcpJztcblxuICAgIC8qKlxuICAgICAqIElQdkZ1dHVyZSA9IFwidlwiIDEqSEVYRElHIFwiLlwiIDEqKCB1bnJlc2VydmVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIClcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5JUHZGdXR1cmUgPSAndicgKyBoZXhEaWdpdE9ubHkgKyAnK1xcXFwuWycgKyB1bnJlc2VydmVkICsgc3ViRGVsaW1zICsgJzpdKyc7XG5cbiAgICAvKipcbiAgICAgKiBzY2hlbWUgPSBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5zY2hlbWUgPSBhbHBoYU9ubHkgKyAnWycgKyBhbHBoYSArIGRpZ2l0ICsgJystXFxcXC5dKic7XG5cbiAgICAvKipcbiAgICAgKiB1c2VyaW5mbyA9ICooIHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiApXG4gICAgICovXG4gICAgY29uc3QgdXNlcmluZm8gPSAnWycgKyB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICc6XSonO1xuXG4gICAgLyoqXG4gICAgICogSVAtbGl0ZXJhbCA9IFwiW1wiICggSVB2NmFkZHJlc3MgLyBJUHZGdXR1cmUgICkgXCJdXCJcbiAgICAgKi9cbiAgICBjb25zdCBJUExpdGVyYWwgPSAnXFxcXFsoPzonICsgaW50ZXJuYWxzLnJmYzM5ODYuSVB2NmFkZHJlc3MgKyBvciArIGludGVybmFscy5yZmMzOTg2LklQdkZ1dHVyZSArICcpXFxcXF0nO1xuXG4gICAgLyoqXG4gICAgICogcmVnLW5hbWUgPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIClcbiAgICAgKi9cbiAgICBjb25zdCByZWdOYW1lID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnXXswLDI1NX0nO1xuXG4gICAgLyoqXG4gICAgICogaG9zdCA9IElQLWxpdGVyYWwgLyBJUHY0YWRkcmVzcyAvIHJlZy1uYW1lXG4gICAgICovXG4gICAgY29uc3QgaG9zdCA9ICcoPzonICsgSVBMaXRlcmFsICsgb3IgKyBpbnRlcm5hbHMucmZjMzk4Ni5JUHY0YWRkcmVzcyArIG9yICsgcmVnTmFtZSArICcpJztcblxuICAgIC8qKlxuICAgICAqIHBvcnQgPSAqRElHSVRcbiAgICAgKi9cbiAgICBjb25zdCBwb3J0ID0gZGlnaXRPbmx5ICsgJyonO1xuXG4gICAgLyoqXG4gICAgICogYXV0aG9yaXR5ICAgPSBbIHVzZXJpbmZvIFwiQFwiIF0gaG9zdCBbIFwiOlwiIHBvcnQgXVxuICAgICAqL1xuICAgIGNvbnN0IGF1dGhvcml0eSA9ICcoPzonICsgdXNlcmluZm8gKyAnQCk/JyArIGhvc3QgKyAnKD86OicgKyBwb3J0ICsgJyk/JztcblxuICAgIC8qKlxuICAgICAqIHNlZ21lbnQgICAgICAgPSAqcGNoYXJcbiAgICAgKiBzZWdtZW50LW56ICAgID0gMSpwY2hhclxuICAgICAqIHBhdGggICAgICAgICAgPSBwYXRoLWFiZW1wdHkgICAgOyBiZWdpbnMgd2l0aCBcIi9cIiBvciBpcyBlbXB0eVxuICAgICAqICAgICAgICAgICAgICAgLyBwYXRoLWFic29sdXRlICAgOyBiZWdpbnMgd2l0aCBcIi9cIiBidXQgbm90IFwiLy9cIlxuICAgICAqICAgICAgICAgICAgICAgLyBwYXRoLW5vc2NoZW1lICAgOyBiZWdpbnMgd2l0aCBhIG5vbi1jb2xvbiBzZWdtZW50XG4gICAgICogICAgICAgICAgICAgICAvIHBhdGgtcm9vdGxlc3MgICA7IGJlZ2lucyB3aXRoIGEgc2VnbWVudFxuICAgICAqICAgICAgICAgICAgICAgLyBwYXRoLWVtcHR5ICAgICAgOyB6ZXJvIGNoYXJhY3RlcnNcbiAgICAgKiBwYXRoLWFiZW1wdHkgID0gKiggXCIvXCIgc2VnbWVudCApXG4gICAgICogcGF0aC1hYnNvbHV0ZSA9IFwiL1wiIFsgc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50ICkgXVxuICAgICAqIHBhdGgtcm9vdGxlc3MgPSBzZWdtZW50LW56ICooIFwiL1wiIHNlZ21lbnQgKVxuICAgICAqL1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwY2hhck9ubHkgKyAnKic7XG4gICAgY29uc3Qgc2VnbWVudE56ID0gcGNoYXJPbmx5ICsgJysnO1xuICAgIGNvbnN0IHNlZ21lbnROek5jID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnQCcgKyAnXSsnO1xuICAgIGNvbnN0IHBhdGhFbXB0eSA9ICcnO1xuICAgIGNvbnN0IHBhdGhBYkVtcHR5ID0gJyg/OlxcXFwvJyArIHNlZ21lbnQgKyAnKSonO1xuICAgIGNvbnN0IHBhdGhBYnNvbHV0ZSA9ICdcXFxcLyg/OicgKyBzZWdtZW50TnogKyBwYXRoQWJFbXB0eSArICcpPyc7XG4gICAgY29uc3QgcGF0aFJvb3RsZXNzID0gc2VnbWVudE56ICsgcGF0aEFiRW1wdHk7XG4gICAgY29uc3QgcGF0aE5vU2NoZW1lID0gc2VnbWVudE56TmMgKyBwYXRoQWJFbXB0eTtcblxuICAgIC8qKlxuICAgICAqIGhpZXItcGFydCA9IFwiLy9cIiBhdXRob3JpdHkgcGF0aFxuICAgICAqL1xuICAgIGludGVybmFscy5yZmMzOTg2LmhpZXJQYXJ0ID0gJyg/OicgKyAnKD86XFxcXC9cXFxcLycgKyBhdXRob3JpdHkgKyBwYXRoQWJFbXB0eSArICcpJyArIG9yICsgcGF0aEFic29sdXRlICsgb3IgKyBwYXRoUm9vdGxlc3MgKyAnKSc7XG5cbiAgICAvKipcbiAgICAgKiByZWxhdGl2ZS1wYXJ0ID0gXCIvL1wiIGF1dGhvcml0eSBwYXRoLWFiZW1wdHlcbiAgICAgKiAgICAgICAgICAgICAgICAgLyBwYXRoLWFic29sdXRlXG4gICAgICogICAgICAgICAgICAgICAgIC8gcGF0aC1ub3NjaGVtZVxuICAgICAqICAgICAgICAgICAgICAgICAvIHBhdGgtZW1wdHlcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5yZWxhdGl2ZVJlZiA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgICsgJyknICsgb3IgKyBwYXRoQWJzb2x1dGUgKyBvciArIHBhdGhOb1NjaGVtZSArIG9yICsgcGF0aEVtcHR5ICsgJyknO1xuXG4gICAgLyoqXG4gICAgICogcXVlcnkgPSAqKCBwY2hhciAvIFwiL1wiIC8gXCI/XCIgKVxuICAgICAqL1xuICAgIGludGVybmFscy5yZmMzOTg2LnF1ZXJ5ID0gJ1snICsgcGNoYXIgKyAnXFxcXC9cXFxcP10qKD89I3wkKSc7IC8vRmluaXNoIG1hdGNoaW5nIGVpdGhlciBhdCB0aGUgZnJhZ21lbnQgcGFydCBvciBlbmQgb2YgdGhlIGxpbmUuXG5cbiAgICAvKipcbiAgICAgKiBxdWVyeSA9ICooIHBjaGFyIC8gXCJbXCIgLyBcIl1cIiAvIFwiL1wiIC8gXCI/XCIgKVxuICAgICAqL1xuICAgIGludGVybmFscy5yZmMzOTg2LnF1ZXJ5V2l0aFNxdWFyZUJyYWNrZXRzID0gJ1snICsgcGNoYXIgKyBzcXVhcmVCcmFja2V0cyArICdcXFxcL1xcXFw/XSooPz0jfCQpJzsgLy9GaW5pc2ggbWF0Y2hpbmcgZWl0aGVyIGF0IHRoZSBmcmFnbWVudCBwYXJ0IG9yIGVuZCBvZiB0aGUgbGluZS5cblxuICAgIC8qKlxuICAgICAqIGZyYWdtZW50ID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcbiAgICAgKi9cbiAgICBpbnRlcm5hbHMucmZjMzk4Ni5mcmFnbWVudCA9ICdbJyArIHBjaGFyICsgJ1xcXFwvXFxcXD9dKic7XG59O1xuXG5cbmludGVybmFscy5nZW5lcmF0ZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5yZmMzOTg2O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBSRkMzOTg2ID0gcmVxdWlyZSgnLi9yZmMzOTg2Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIFVyaToge1xuICAgICAgICBjcmVhdGVVcmlSZWdleDogZnVuY3Rpb24gKG9wdGlvbmFsU2NoZW1lLCBhbGxvd1JlbGF0aXZlLCByZWxhdGl2ZU9ubHksIGFsbG93UXVlcnlTcXVhcmVCcmFja2V0cykge1xuXG4gICAgICAgICAgICBsZXQgc2NoZW1lID0gUkZDMzk4Ni5zY2hlbWU7XG4gICAgICAgICAgICBsZXQgcHJlZml4O1xuXG4gICAgICAgICAgICBpZiAocmVsYXRpdmVPbmx5KSB7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gJyg/OicgKyBSRkMzOTg2LnJlbGF0aXZlUmVmICsgJyknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBwYXNzZWQgYSBzY2hlbWUsIHVzZSBpdCBpbnN0ZWFkIG9mIHRoZSBnZW5lcmljIG9uZVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbFNjaGVtZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmUgdG8gcHV0IHRoaXMgaW4gYSBub24tY2FwdHVyaW5nIGdyb3VwIHRvIGhhbmRsZSB0aGUgT1Igc3RhdGVtZW50c1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWUgPSAnKD86JyArIG9wdGlvbmFsU2NoZW1lICsgJyknO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhTY2hlbWUgPSAnKD86JyArIHNjaGVtZSArICc6JyArIFJGQzM5ODYuaGllclBhcnQgKyAnKSc7XG5cbiAgICAgICAgICAgICAgICBwcmVmaXggPSBhbGxvd1JlbGF0aXZlID8gJyg/OicgKyB3aXRoU2NoZW1lICsgJ3wnICsgUkZDMzk4Ni5yZWxhdGl2ZVJlZiArICcpJyA6IHdpdGhTY2hlbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVVJJID0gc2NoZW1lIFwiOlwiIGhpZXItcGFydCBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogT1JcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiByZWxhdGl2ZS1yZWYgPSByZWxhdGl2ZS1wYXJ0IFsgXCI/XCIgcXVlcnkgXSBbIFwiI1wiIGZyYWdtZW50IF1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyg/OlxcXFw/JyArIChhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMgPyBSRkMzOTg2LnF1ZXJ5V2l0aFNxdWFyZUJyYWNrZXRzIDogUkZDMzk4Ni5xdWVyeSkgKyAnKT8nICsgJyg/OiMnICsgUkZDMzk4Ni5mcmFnbWVudCArICcpPyQnKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlVyaTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi4vYW55Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLk1hcCA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcblxuICAgIHNsaWNlKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLk1hcCh0aGlzKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICByZXR1cm4gVXRpbC5pbnNwZWN0KHRoaXMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLlN5bWJvbCA9IGNsYXNzIGV4dGVuZHMgQW55IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSAnc3ltYm9sJztcbiAgICAgICAgdGhpcy5faW5uZXIubWFwID0gbmV3IGludGVybmFscy5NYXAoKTtcbiAgICB9XG5cbiAgICBfYmFzZSh2YWx1ZSwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBpZiAob3B0aW9ucy5jb252ZXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLl9pbm5lci5tYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvb2t1cDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZsYWdzLmFsbG93T25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6ICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSA/IG51bGwgOiB0aGlzLmNyZWF0ZUVycm9yKCdzeW1ib2wubWFwJywgeyB2YWx1ZSwgbWFwOiB0aGlzLl9pbm5lci5tYXAgfSwgc3RhdGUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGVycm9yczogKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpID8gbnVsbCA6IHRoaXMuY3JlYXRlRXJyb3IoJ3N5bWJvbC5iYXNlJywgeyB2YWx1ZSB9LCBzdGF0ZSwgb3B0aW9ucylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBtYXAoaXRlcmFibGUpIHtcblxuICAgICAgICBpZiAoaXRlcmFibGUgJiYgIWl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0gJiYgdHlwZW9mIGl0ZXJhYmxlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QuZW50cmllcyhpdGVyYWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBIb2VrLmFzc2VydChpdGVyYWJsZSAmJiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdLCAnSXRlcmFibGUgbXVzdCBiZSBhbiBpdGVyYWJsZSBvciBvYmplY3QnKTtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGNvbnN0IHN5bWJvbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoZW50cnkgJiYgZW50cnlbU3ltYm9sLml0ZXJhdG9yXSwgJ0VudHJ5IG11c3QgYmUgYW4gaXRlcmFibGUnKTtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJ5O1xuXG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBrZXkgIT09ICdzeW1ib2wnLCAnS2V5IG11c3Qgbm90IGJlIGFuIG9iamVjdCwgZnVuY3Rpb24sIG9yIFN5bWJvbCcpO1xuICAgICAgICAgICAgSG9lay5hc3NlcnQodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJywgJ1ZhbHVlIG11c3QgYmUgYSBTeW1ib2wnKTtcbiAgICAgICAgICAgIG9iai5faW5uZXIubWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHN5bWJvbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqLnZhbGlkKC4uLnN5bWJvbHMpO1xuICAgIH1cblxuICAgIGRlc2NyaWJlKCkge1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc3VwZXIuZGVzY3JpYmUoKTtcbiAgICAgICAgZGVzY3JpcHRpb24ubWFwID0gbmV3IE1hcCh0aGlzLl9pbm5lci5tYXApO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuU3ltYm9sKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHNldHRpbmdzQ2FjaGU6IFN5bWJvbCgnc2V0dGluZ3NDYWNoZScpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IEpvaSA9IHJlcXVpcmUoJ0BoYXBpL2pvaScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBKb2kub2JqZWN0KHtcbiAgICBzYW1wbGVJbnRlcnZhbDogSm9pLm51bWJlcigpLm1pbigwKSxcbiAgICBtYXhIZWFwVXNlZEJ5dGVzOiBKb2kubnVtYmVyKCkubWluKDApLFxuICAgIG1heEV2ZW50TG9vcERlbGF5OiBKb2kubnVtYmVyKCkubWluKDApLFxuICAgIG1heFJzc0J5dGVzOiBKb2kubnVtYmVyKCkubWluKDApXG59KVxuICAgIC51bmtub3duKCk7XG5cblxuaW50ZXJuYWxzLmRlZmF1bHRzID0ge1xuICAgIHNhbXBsZUludGVydmFsOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnJlcXVlbmN5IG9mIGxvYWQgc2FtcGxpbmcgaW4gbWlsbGlzZWNvbmRzICh6ZXJvIGlzIG5vIHNhbXBsaW5nKVxuICAgIG1heEhlYXBVc2VkQnl0ZXM6IDAsICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IHJlcXVlc3RzIHdoZW4gVjggaGVhcCBpcyBvdmVyIHNpemUgaW4gYnl0ZXMgKHplcm8gaXMgbm8gbWF4KVxuICAgIG1heFJzc0J5dGVzOiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVqZWN0IHJlcXVlc3RzIHdoZW4gcHJvY2VzcyBSU1MgaXMgb3ZlciBzaXplIGluIGJ5dGVzICh6ZXJvIGlzIG5vIG1heClcbiAgICBtYXhFdmVudExvb3BEZWxheTogMCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBvZiBkZWxheSBhZnRlciB3aGljaCByZXF1ZXN0cyBhcmUgcmVqZWN0ZWQgKHplcm8gaXMgbm8gbWF4KVxufTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuSGVhdnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBKb2kuYXNzZXJ0KG9wdGlvbnMsIGludGVybmFscy5zY2hlbWEsICdJbnZhbGlkIGxvYWQgbW9uaXRvcmluZyBvcHRpb25zJyk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgSG9lay5hc3NlcnQodGhpcy5zZXR0aW5ncy5zYW1wbGVJbnRlcnZhbCB8fCAoIXRoaXMuc2V0dGluZ3MubWF4RXZlbnRMb29wRGVsYXkgJiYgIXRoaXMuc2V0dGluZ3MubWF4SGVhcFVzZWRCeXRlcyAmJiAhdGhpcy5zZXR0aW5ncy5tYXhSc3NCeXRlcyksICdMb2FkIHNhbXBsZSBpbnRlcnZhbCBtdXN0IGJlIHNldCB0byBlbmFibGUgbG9hZCBsaW1pdHMnKTtcblxuICAgIHRoaXMuX2V2ZW50TG9vcFRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkQmVuY2ggPSBuZXcgSG9lay5CZW5jaCgpO1xuICAgIHRoaXMubG9hZCA9IHtcbiAgICAgICAgZXZlbnRMb29wRGVsYXk6IDAsXG4gICAgICAgIGhlYXBVc2VkOiAwLFxuICAgICAgICByc3M6IDBcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMuSGVhdnkucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnNhbXBsZUludGVydmFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsb29wU2FtcGxlID0gKCkgPT4ge1xuXG4gICAgICAgIHRoaXMuX2xvYWRCZW5jaC5yZXNldCgpO1xuICAgICAgICBjb25zdCBtZWFzdXJlID0gKCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBtZW0gPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG5cbiAgICAgICAgICAgIC8vIFJldGFpbiB0aGUgc2FtZSB0aGlzLmxvYWQgb2JqZWN0IHRvIGtlZXAgZXh0ZXJuYWwgcmVmZXJlbmNlcyB2YWxpZFxuXG4gICAgICAgICAgICB0aGlzLmxvYWQuZXZlbnRMb29wRGVsYXkgPSAodGhpcy5fbG9hZEJlbmNoLmVsYXBzZWQoKSAtIHRoaXMuc2V0dGluZ3Muc2FtcGxlSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5sb2FkLmhlYXBVc2VkID0gbWVtLmhlYXBVc2VkO1xuICAgICAgICAgICAgdGhpcy5sb2FkLnJzcyA9IG1lbS5yc3M7XG5cbiAgICAgICAgICAgIGxvb3BTYW1wbGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9ldmVudExvb3BUaW1lciA9IHNldFRpbWVvdXQobWVhc3VyZSwgdGhpcy5zZXR0aW5ncy5zYW1wbGVJbnRlcnZhbCk7XG4gICAgfTtcblxuICAgIGxvb3BTYW1wbGUoKTtcbn07XG5cblxuaW50ZXJuYWxzLkhlYXZ5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2V2ZW50TG9vcFRpbWVyKTtcbiAgICB0aGlzLl9ldmVudExvb3BUaW1lciA9IG51bGw7XG59O1xuXG5cbmludGVybmFscy5IZWF2eS5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIXRoaXMuc2V0dGluZ3Muc2FtcGxlSW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEhvZWsuYXNzZXJ0KHRoaXMuX2V2ZW50TG9vcFRpbWVyLCAnQ2Fubm90IGNoZWNrIGxvYWQgd2hlbiBzYW1wbGVyIGlzIG5vdCBzdGFydGVkJyk7XG5cbiAgICBjb25zdCBlbGFwc2VkID0gdGhpcy5fbG9hZEJlbmNoLmVsYXBzZWQoKTtcbiAgICBjb25zdCBsb2FkID0gdGhpcy5sb2FkO1xuXG4gICAgaWYgKGVsYXBzZWQgPiB0aGlzLnNldHRpbmdzLnNhbXBsZUludGVydmFsKSB7XG4gICAgICAgIGxvYWQuZXZlbnRMb29wRGVsYXkgPSBNYXRoLm1heChsb2FkLmV2ZW50TG9vcERlbGF5LCBlbGFwc2VkIC0gdGhpcy5zZXR0aW5ncy5zYW1wbGVJbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4RXZlbnRMb29wRGVsYXkgJiZcbiAgICAgICAgbG9hZC5ldmVudExvb3BEZWxheSA+IHRoaXMuc2V0dGluZ3MubWF4RXZlbnRMb29wRGVsYXkpIHtcblxuICAgICAgICB0aHJvdyBCb29tLnNlcnZlclVuYXZhaWxhYmxlKCdTZXJ2ZXIgdW5kZXIgaGVhdnkgbG9hZCAoZXZlbnQgbG9vcCknLCBsb2FkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5tYXhIZWFwVXNlZEJ5dGVzICYmXG4gICAgICAgIGxvYWQuaGVhcFVzZWQgPiB0aGlzLnNldHRpbmdzLm1heEhlYXBVc2VkQnl0ZXMpIHtcblxuICAgICAgICB0aHJvdyBCb29tLnNlcnZlclVuYXZhaWxhYmxlKCdTZXJ2ZXIgdW5kZXIgaGVhdnkgbG9hZCAoaGVhcCknLCBsb2FkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5tYXhSc3NCeXRlcyAmJlxuICAgICAgICBsb2FkLnJzcyA+IHRoaXMuc2V0dGluZ3MubWF4UnNzQnl0ZXMpIHtcblxuICAgICAgICB0aHJvdyBCb29tLnNlcnZlclVuYXZhaWxhYmxlKCdTZXJ2ZXIgdW5kZXIgaGVhdnkgbG9hZCAocnNzKScsIGxvYWQpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJy4vY2xvbmUnKTtcbmNvbnN0IE1lcmdlID0gcmVxdWlyZSgnLi9tZXJnZScpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGVmYXVsdHMsIHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBBc3NlcnQoZGVmYXVsdHMgJiYgdHlwZW9mIGRlZmF1bHRzID09PSAnb2JqZWN0JywgJ0ludmFsaWQgZGVmYXVsdHMgdmFsdWU6IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KCFzb3VyY2UgfHwgc291cmNlID09PSB0cnVlIHx8IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzb3VyY2UgdmFsdWU6IG11c3QgYmUgdHJ1ZSwgZmFsc3kgb3IgYW4gb2JqZWN0Jyk7XG4gICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9uczogbXVzdCBiZSBhbiBvYmplY3QnKTtcblxuICAgIGlmICghc291cmNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBubyBzb3VyY2UsIHJldHVybiBudWxsXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyhkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMpO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdHJ1ZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHNvdXJjZSBpcyBzZXQgdG8gdHJ1ZSwgdXNlIGRlZmF1bHRzXG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIGNvbnN0IG51bGxPdmVycmlkZSA9IG9wdGlvbnMubnVsbE92ZXJyaWRlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm51bGxPdmVycmlkZSA6IGZhbHNlO1xuICAgIHJldHVybiBNZXJnZShjb3B5LCBzb3VyY2UsIHsgbnVsbE92ZXJyaWRlLCBtZXJnZUFycmF5czogZmFsc2UgfSk7XG59O1xuXG5cbmludGVybmFscy5hcHBseVRvRGVmYXVsdHNXaXRoU2hhbGxvdyA9IGZ1bmN0aW9uIChkZWZhdWx0cywgc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCBrZXlzID0gb3B0aW9ucy5zaGFsbG93O1xuICAgIEFzc2VydChBcnJheS5pc0FycmF5KGtleXMpLCAnSW52YWxpZCBrZXlzJyk7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5zaGFsbG93ID0gZmFsc2U7XG5cbiAgICBjb25zdCBjb3B5ID0gQ2xvbmUoZGVmYXVsdHMsIHsgc2hhbGxvdzoga2V5cyB9KTtcblxuICAgIGlmIChzb3VyY2UgPT09IHRydWUpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb3VyY2UgaXMgc2V0IHRvIHRydWUsIHVzZSBkZWZhdWx0c1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yYWdlID0gVXRpbHMuc3RvcmUoc291cmNlLCBrZXlzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHNoYWxsb3cgY29weSBpdGVtcyB0byBzdG9yYWdlXG4gICAgTWVyZ2UoY29weSwgc291cmNlLCB7IG1lcmdlQXJyYXlzOiBmYWxzZSwgbnVsbE92ZXJyaWRlOiBmYWxzZSB9KTsgICAvLyBEZWVwIGNvcHkgdGhlIHJlc3RcbiAgICBVdGlscy5yZXN0b3JlKGNvcHksIHNvdXJjZSwgc3RvcmFnZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFsbG93IGNvcHkgdGhlIHN0b3JlZCBpdGVtcyBhbmQgcmVzdG9yZVxuICAgIHJldHVybiBjb3B5O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0RXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJyk7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgLi4uYXJncykge1xuXG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGFyZ3NbMF0gaW5zdGFuY2VvZiBFcnJvcikge1xuXG4gICAgICAgIHRocm93IGFyZ3NbMF07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEFzc2VydEVycm9yKGFyZ3MpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuQmVuY2ggPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLnRzID0gMDtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIHRoaXMudHMgPSBpbnRlcm5hbHMuQmVuY2gubm93KCk7XG4gICAgfVxuXG4gICAgZWxhcHNlZCgpIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLkJlbmNoLm5vdygpIC0gdGhpcy50cztcbiAgICB9XG5cbiAgICBzdGF0aWMgbm93KCkge1xuXG4gICAgICAgIGNvbnN0IHRzID0gcHJvY2Vzcy5ocnRpbWUoKTtcbiAgICAgICAgcmV0dXJuICh0c1swXSAqIDFlMykgKyAodHNbMV0gLyAxZTYpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IElnbm9yZSA9IHJlcXVpcmUoJy4vaWdub3JlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoSWdub3JlKTsgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG5lZWRzUHJvdG9IYWNrOiBuZXcgU2V0KFtUeXBlcy5zZXQsIFR5cGVzLm1hcCwgVHlwZXMud2Vha1NldCwgVHlwZXMud2Vha01hcF0pXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLmNsb25lID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucyA9IHt9LCBfc2VlbiA9IG51bGwpIHtcblxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBvYmogPT09IG51bGwpIHtcblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGxldCBjbG9uZSA9IGludGVybmFscy5jbG9uZTtcbiAgICBsZXQgc2VlbiA9IF9zZWVuO1xuXG4gICAgaWYgKG9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaGFsbG93ICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNsb25lV2l0aFNoYWxsb3cob2JqLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb25lID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBzZWVuIHx8IG5ldyBNYXAoKTtcblxuICAgICAgICBjb25zdCBsb29rdXAgPSBzZWVuLmdldChvYmopO1xuICAgICAgICBpZiAobG9va3VwKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9va3VwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbHQtaW4gb2JqZWN0IHR5cGVzXG5cbiAgICBjb25zdCBiYXNlUHJvdG8gPSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKG9iaik7XG4gICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIgJiYgQnVmZmVyLmZyb20ob2JqKTsgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG9iai5nZXRUaW1lKCkpO1xuICAgIH1cblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLnJlZ2V4KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9iaik7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJpYyBvYmplY3RzXG5cbiAgICBjb25zdCBuZXdPYmogPSBpbnRlcm5hbHMuYmFzZShvYmosIGJhc2VQcm90bywgb3B0aW9ucyk7XG4gICAgaWYgKG5ld09iaiA9PT0gb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgICAgc2Vlbi5zZXQob2JqLCBuZXdPYmopOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBzZWVuLCBzaW5jZSBvYmogY291bGQgcmVjdXJzZVxuICAgIH1cblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLnNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iaikge1xuICAgICAgICAgICAgbmV3T2JqLmFkZChjbG9uZSh2YWx1ZSwgb3B0aW9ucywgc2VlbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMubWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG9iaikge1xuICAgICAgICAgICAgbmV3T2JqLnNldChrZXksIGNsb25lKHZhbHVlLCBvcHRpb25zLCBzZWVuKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0gVXRpbHMua2V5cyhvYmosIG9wdGlvbnMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKGJhc2VQcm90byA9PT0gVHlwZXMuYXJyYXkgJiZcbiAgICAgICAgICAgIGtleSA9PT0gJ2xlbmd0aCcpIHtcblxuICAgICAgICAgICAgbmV3T2JqLmxlbmd0aCA9IG9iai5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCB8fFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iuc2V0KSB7XG5cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBjbG9uZShvYmpba2V5XSwgb3B0aW9ucywgc2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIHsgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBjbG9uZShvYmpba2V5XSwgb3B0aW9ucywgc2VlbikgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2xvbmUob2JqW2tleV0sIG9wdGlvbnMsIHNlZW4pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmo7XG59O1xuXG5cbmludGVybmFscy5jbG9uZVdpdGhTaGFsbG93ID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgY29uc3Qga2V5cyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5zaGFsbG93ID0gZmFsc2U7XG5cbiAgICBjb25zdCBzdG9yYWdlID0gVXRpbHMuc3RvcmUoc291cmNlLCBrZXlzKTsgICAgLy8gTW92ZSBzaGFsbG93IGNvcHkgaXRlbXMgdG8gc3RvcmFnZVxuICAgIGNvbnN0IGNvcHkgPSBpbnRlcm5hbHMuY2xvbmUoc291cmNlLCBvcHRpb25zKTsgICAgICAvLyBEZWVwIGNvcHkgdGhlIHJlc3RcbiAgICBVdGlscy5yZXN0b3JlKGNvcHksIHNvdXJjZSwgc3RvcmFnZSk7ICAgICAgICAgLy8gU2hhbGxvdyBjb3B5IHRoZSBzdG9yZWQgaXRlbXMgYW5kIHJlc3RvcmVcbiAgICByZXR1cm4gY29weTtcbn07XG5cblxuaW50ZXJuYWxzLmJhc2UgPSBmdW5jdGlvbiAob2JqLCBiYXNlUHJvdG8sIG9wdGlvbnMpIHtcblxuICAgIGlmIChiYXNlUHJvdG8gPT09IFR5cGVzLmFycmF5KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wcm90b3R5cGUgPT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICBpZiAoaW50ZXJuYWxzLm5lZWRzUHJvdG9IYWNrLmhhcyhiYXNlUHJvdG8pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJhc2VQcm90by5jb25zdHJ1Y3RvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgaWYgKHByb3RvICYmXG4gICAgICAgIHByb3RvLmlzSW1tdXRhYmxlKSB7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxzLm5lZWRzUHJvdG9IYWNrLmhhcyhiYXNlUHJvdG8pKSB7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IG5ldyBwcm90by5jb25zdHJ1Y3RvcigpO1xuICAgICAgICBpZiAocHJvdG8gIT09IGJhc2VQcm90bykge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld09iaiwgcHJvdG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90byk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnLi9kZWVwRXF1YWwnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnLi9lc2NhcGVSZWdleCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVmLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkgeyAgICAgICAgLy8gb3B0aW9uczogeyBkZWVwLCBvbmNlLCBvbmx5LCBwYXJ0LCBzeW1ib2xzIH1cblxuICAgIC8qXG4gICAgICAgIHN0cmluZyAtPiBzdHJpbmcocylcbiAgICAgICAgYXJyYXkgLT4gaXRlbShzKVxuICAgICAgICBvYmplY3QgLT4ga2V5KHMpXG4gICAgICAgIG9iamVjdCAtPiBvYmplY3QgKGtleTp2YWx1ZSlcbiAgICAqL1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgIH1cblxuICAgIEFzc2VydCghQXJyYXkuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGgsICdWYWx1ZXMgYXJyYXkgY2Fubm90IGJlIGVtcHR5Jyk7XG5cbiAgICAvLyBTdHJpbmdcblxuICAgIGlmICh0eXBlb2YgcmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnN0cmluZyhyZWYsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gQXJyYXlcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5hcnJheShyZWYsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0XG5cbiAgICBBc3NlcnQodHlwZW9mIHJlZiA9PT0gJ29iamVjdCcsICdSZWZlcmVuY2UgbXVzdCBiZSBzdHJpbmcgb3IgYW4gb2JqZWN0Jyk7XG4gICAgcmV0dXJuIGludGVybmFscy5vYmplY3QocmVmLCB2YWx1ZXMsIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuYXJyYXkgPSBmdW5jdGlvbiAocmVmLCB2YWx1ZXMsIG9wdGlvbnMpIHtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgIH1cblxuICAgIGlmICghcmVmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMub25seSAmJlxuICAgICAgICBvcHRpb25zLm9uY2UgJiZcbiAgICAgICAgcmVmLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgY29tcGFyZTtcblxuICAgIC8vIE1hcCB2YWx1ZXNcblxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZGVlcCB8fFxuICAgICAgICAgICAgIXZhbHVlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gbWFwLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICArK2V4aXN0aW5nLmFsbG93ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KHZhbHVlLCB7IGFsbG93ZWQ6IDEsIGhpdHM6IDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb21wYXJlID0gY29tcGFyZSB8fCBpbnRlcm5hbHMuY29tcGFyZShvcHRpb25zKTtcblxuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGV4aXN0aW5nXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKytleGlzdGluZy5hbGxvd2VkO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgIG1hcC5zZXQodmFsdWUsIHsgYWxsb3dlZDogMSwgaGl0czogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExvb2t1cCB2YWx1ZXNcblxuICAgIGxldCBoaXRzID0gMDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVmKSB7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRlZXAgfHxcbiAgICAgICAgICAgICFpdGVtIHx8XG4gICAgICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICAgICAgbWF0Y2ggPSBtYXAuZ2V0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBleGlzdGluZ10gb2YgbWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGtleSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBleGlzdGluZztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICArK21hdGNoLmhpdHM7XG4gICAgICAgICAgICArK2hpdHM7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uY2UgJiZcbiAgICAgICAgICAgICAgICBtYXRjaC5oaXRzID4gbWF0Y2guYWxsb3dlZCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcmVzdWx0c1xuXG4gICAgaWYgKG9wdGlvbnMub25seSAmJlxuICAgICAgICBoaXRzICE9PSByZWYubGVuZ3RoKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChtYXRjaC5oaXRzID09PSBtYXRjaC5hbGxvd2VkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaC5oaXRzIDwgbWF0Y2guYWxsb3dlZCAmJlxuICAgICAgICAgICAgIW9wdGlvbnMucGFydCkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gISFoaXRzO1xufTtcblxuXG5pbnRlcm5hbHMub2JqZWN0ID0gZnVuY3Rpb24gKHJlZiwgdmFsdWVzLCBvcHRpb25zKSB7XG5cbiAgICBBc3NlcnQob3B0aW9ucy5vbmNlID09PSB1bmRlZmluZWQsICdDYW5ub3QgdXNlIG9wdGlvbiBvbmNlIHdpdGggb2JqZWN0Jyk7XG5cbiAgICBjb25zdCBrZXlzID0gVXRpbHMua2V5cyhyZWYsIG9wdGlvbnMpO1xuICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEtleXMgbGlzdFxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmFycmF5KGtleXMsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gS2V5IHZhbHVlIHBhaXJzXG5cbiAgICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZXMpLmZpbHRlcigoc3ltKSA9PiB2YWx1ZXMucHJvcGVydHlJc0VudW1lcmFibGUoc3ltKSk7XG4gICAgY29uc3QgdGFyZ2V0cyA9IFsuLi5PYmplY3Qua2V5cyh2YWx1ZXMpLCAuLi5zeW1ib2xzXTtcblxuICAgIGNvbnN0IGNvbXBhcmUgPSBpbnRlcm5hbHMuY29tcGFyZShvcHRpb25zKTtcbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0KHRhcmdldHMpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoIXNldC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbXBhcmUodmFsdWVzW2tleV0sIHJlZltrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0LmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIGlmIChzZXQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wYXJ0ID8gc2V0LnNpemUgPCB0YXJnZXRzLmxlbmd0aCA6IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuc3RyaW5nID0gZnVuY3Rpb24gKHJlZiwgdmFsdWVzLCBvcHRpb25zKSB7XG5cbiAgICAvLyBFbXB0eSBzdHJpbmdcblxuICAgIGlmIChyZWYgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoID09PSAxICYmIHZhbHVlc1swXSA9PT0gJycgfHwgICAgICAgICAgICAgICAvLyAnJyBjb250YWlucyAnJ1xuICAgICAgICAgICAgIW9wdGlvbnMub25jZSAmJiAhdmFsdWVzLnNvbWUoKHYpID0+IHYgIT09ICcnKTsgICAgICAgICAgICAgLy8gJycgY29udGFpbnMgbXVsdGlwbGUgJycgaWYgIW9uY2VcbiAgICB9XG5cbiAgICAvLyBNYXAgdmFsdWVzXG5cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgcGF0dGVybnMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgIEFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnQ2Fubm90IGNvbXBhcmUgc3RyaW5nIHJlZmVyZW5jZSB0byBub24tc3RyaW5nIHZhbHVlJyk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IG1hcC5nZXQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgKytleGlzdGluZy5hbGxvd2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldCh2YWx1ZSwgeyBhbGxvd2VkOiAxLCBoaXRzOiAwIH0pO1xuICAgICAgICAgICAgICAgIHBhdHRlcm5zLnB1c2goRXNjYXBlUmVnZXgodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2UgfHxcbiAgICAgICAgICAgIG9wdGlvbnMub25seSkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhdHRlcm5zLmxlbmd0aCkgeyAgICAgICAgICAgICAgICAgICAgIC8vIE5vbi1lbXB0eSBzdHJpbmcgY29udGFpbnMgdW5saW1pdGVkIGVtcHR5IHN0cmluZ1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBNYXRjaCBwYXR0ZXJuc1xuXG4gICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGAoJHtwYXR0ZXJucy5qb2luKCd8Jyl9KWAsICdnJyk7XG4gICAgY29uc3QgbGVmdG92ZXJzID0gcmVmLnJlcGxhY2UocmVnZXgsICgkMCwgJDEpID0+IHtcblxuICAgICAgICArK21hcC5nZXQoJDEpLmhpdHM7XG4gICAgICAgIHJldHVybiAnJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBzdHJpbmdcbiAgICB9KTtcblxuICAgIC8vIFZhbGlkYXRlIHJlc3VsdHNcblxuICAgIGlmIChvcHRpb25zLm9ubHkgJiZcbiAgICAgICAgbGVmdG92ZXJzKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBhbnkgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobWF0Y2guaGl0cykge1xuICAgICAgICAgICAgYW55ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaC5oaXRzID09PSBtYXRjaC5hbGxvd2VkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaC5oaXRzIDwgbWF0Y2guYWxsb3dlZCAmJlxuICAgICAgICAgICAgIW9wdGlvbnMucGFydCkge1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXRjaC5oaXRzID4gbWF0Y2guYWxsb3dlZFxuXG4gICAgICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhIWFueTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbXBhcmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgaWYgKCFvcHRpb25zLmRlZXApIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5zaGFsbG93O1xuICAgIH1cblxuICAgIGNvbnN0IGhhc09ubHkgPSBvcHRpb25zLm9ubHkgIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBoYXNQYXJ0ID0gb3B0aW9ucy5wYXJ0ICE9PSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgcHJvdG90eXBlOiBoYXNPbmx5ID8gb3B0aW9ucy5vbmx5IDogaGFzUGFydCA/ICFvcHRpb25zLnBhcnQgOiBmYWxzZSxcbiAgICAgICAgcGFydDogaGFzT25seSA/ICFvcHRpb25zLm9ubHkgOiBoYXNQYXJ0ID8gb3B0aW9ucy5wYXJ0IDogZmFsc2VcbiAgICB9O1xuXG4gICAgcmV0dXJuIChhLCBiKSA9PiBEZWVwRXF1YWwoYSwgYiwgZmxhZ3MpO1xufTtcblxuXG5pbnRlcm5hbHMuc2hhbGxvdyA9IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICByZXR1cm4gYSA9PT0gYjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBtaXNtYXRjaGVkOiBudWxsXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgcmVmLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHByb3RvdHlwZTogdHJ1ZSB9LCBvcHRpb25zKTtcblxuICAgIHJldHVybiAhIWludGVybmFscy5pc0RlZXBFcXVhbChvYmosIHJlZiwgb3B0aW9ucywgW10pO1xufTtcblxuXG5pbnRlcm5hbHMuaXNEZWVwRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYsIG9wdGlvbnMsIHNlZW4pIHtcblxuICAgIGlmIChvYmogPT09IHJlZikgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcGllZCBmcm9tIERlZXAtZXFsLCBjb3B5cmlnaHQoYykgMjAxMyBKYWtlIEx1ZXIsIGpha2VAYWxvZ2ljYWxwYXJhZG94LmNvbSwgTUlUIExpY2Vuc2VkLCBodHRwczovL2dpdGh1Yi5jb20vY2hhaWpzL2RlZXAtZXFsXG4gICAgICAgIHJldHVybiBvYmogIT09IDAgfHwgMSAvIG9iaiA9PT0gMSAvIHJlZjtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iajtcblxuICAgIGlmICh0eXBlICE9PSB0eXBlb2YgcmVmKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob2JqID09PSBudWxsIHx8XG4gICAgICAgIHJlZiA9PT0gbnVsbCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuZGVlcEZ1bmN0aW9uIHx8XG4gICAgICAgICAgICBvYmoudG9TdHJpbmcoKSAhPT0gcmVmLnRvU3RyaW5nKCkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udGludWUgYXMgb2JqZWN0XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBvYmogIT09IG9iaiAmJiByZWYgIT09IHJlZjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmFOXG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFuY2VUeXBlID0gaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUob2JqLCByZWYsICEhb3B0aW9ucy5wcm90b3R5cGUpO1xuICAgIHN3aXRjaCAoaW5zdGFuY2VUeXBlKSB7XG4gICAgICAgIGNhc2UgVHlwZXMuYnVmZmVyOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlciAmJiBCdWZmZXIucHJvdG90eXBlLmVxdWFscy5jYWxsKG9iaiwgcmVmKTsgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICBjYXNlIFR5cGVzLnByb21pc2U6XG4gICAgICAgICAgICByZXR1cm4gb2JqID09PSByZWY7XG4gICAgICAgIGNhc2UgVHlwZXMucmVnZXg6XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCkgPT09IHJlZi50b1N0cmluZygpO1xuICAgICAgICBjYXNlIGludGVybmFscy5taXNtYXRjaGVkOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBzZWVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChzZWVuW2ldLmlzU2FtZShvYmosIHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBjb21wYXJpc29uIGZhaWxlZCwgaXQgd291bGQgaGF2ZSBzdG9wcGVkIGV4ZWN1dGlvblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2Vlbi5wdXNoKG5ldyBpbnRlcm5hbHMuU2VlbkVudHJ5KG9iaiwgcmVmKSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gISFpbnRlcm5hbHMuaXNEZWVwRXF1YWxPYmooaW5zdGFuY2VUeXBlLCBvYmosIHJlZiwgb3B0aW9ucywgc2Vlbik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBzZWVuLnBvcCgpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmdldFNoYXJlZFR5cGUgPSBmdW5jdGlvbiAob2JqLCByZWYsIGNoZWNrUHJvdG90eXBlKSB7XG5cbiAgICBpZiAoY2hlY2tQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR5cGVzLmdldEludGVybmFsUHJvdG8ob2JqKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gVHlwZXMuZ2V0SW50ZXJuYWxQcm90byhvYmopO1xuICAgIGlmICh0eXBlICE9PSBUeXBlcy5nZXRJbnRlcm5hbFByb3RvKHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5taXNtYXRjaGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xufTtcblxuXG5pbnRlcm5hbHMudmFsdWVPZiA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGNvbnN0IG9ialZhbHVlT2YgPSBvYmoudmFsdWVPZjtcbiAgICBpZiAob2JqVmFsdWVPZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG9ialZhbHVlT2YuY2FsbChvYmopO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuaGFzT3duRW51bWVyYWJsZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5KSB7XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KTtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2V0U2ltcGxlRXF1YWwgPSBmdW5jdGlvbiAob2JqLCByZWYpIHtcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2Ygb2JqKSB7XG4gICAgICAgIGlmICghcmVmLmhhcyhlbnRyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuaXNEZWVwRXF1YWxPYmogPSBmdW5jdGlvbiAoaW5zdGFuY2VUeXBlLCBvYmosIHJlZiwgb3B0aW9ucywgc2Vlbikge1xuXG4gICAgY29uc3QgeyBpc0RlZXBFcXVhbCwgdmFsdWVPZiwgaGFzT3duRW51bWVyYWJsZVByb3BlcnR5IH0gPSBpbnRlcm5hbHM7XG4gICAgY29uc3QgeyBrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgfSA9IE9iamVjdDtcblxuICAgIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLmFycmF5KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBhcnQpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IGluZGV4IG1hdGNoIGFueSBvdGhlciBpbmRleFxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9ialZhbHVlIG9mIG9iaikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVmVmFsdWUgb2YgcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbChvYmpWYWx1ZSwgcmVmVmFsdWUsIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvYmoubGVuZ3RoICE9PSByZWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWwob2JqW2ldLCByZWZbaV0sIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGluc3RhbmNlVHlwZSA9PT0gVHlwZXMuc2V0KSB7XG4gICAgICAgIGlmIChvYmouc2l6ZSAhPT0gcmVmLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW50ZXJuYWxzLmlzU2V0U2ltcGxlRXF1YWwob2JqLCByZWYpKSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkZWVwIGVxdWFsaXR5XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZjIgPSBuZXcgU2V0KHJlZik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iakVudHJ5IG9mIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChyZWYyLmRlbGV0ZShvYmpFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWZFbnRyeSBvZiByZWYyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZXBFcXVhbChvYmpFbnRyeSwgcmVmRW50cnksIG9wdGlvbnMsIHNlZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYyLmRlbGV0ZShyZWZFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZVR5cGUgPT09IFR5cGVzLm1hcCkge1xuICAgICAgICBpZiAob2JqLnNpemUgIT09IHJlZi5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICFyZWYuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWwodmFsdWUsIHJlZi5nZXQoa2V5KSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFuY2VUeXBlID09PSBUeXBlcy5lcnJvcikge1xuXG4gICAgICAgIC8vIEFsd2F5cyBjaGVjayBuYW1lIGFuZCBtZXNzYWdlXG5cbiAgICAgICAgaWYgKG9iai5uYW1lICE9PSByZWYubmFtZSB8fFxuICAgICAgICAgICAgb2JqLm1lc3NhZ2UgIT09IHJlZi5tZXNzYWdlKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIC52YWx1ZU9mKClcblxuICAgIGNvbnN0IHZhbHVlT2ZPYmogPSB2YWx1ZU9mKG9iaik7XG4gICAgY29uc3QgdmFsdWVPZlJlZiA9IHZhbHVlT2YocmVmKTtcbiAgICBpZiAoKG9iaiAhPT0gdmFsdWVPZk9iaiB8fCByZWYgIT09IHZhbHVlT2ZSZWYpICYmXG4gICAgICAgICFpc0RlZXBFcXVhbCh2YWx1ZU9mT2JqLCB2YWx1ZU9mUmVmLCBvcHRpb25zLCBzZWVuKSkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBwcm9wZXJ0aWVzXG5cbiAgICBjb25zdCBvYmpLZXlzID0ga2V5cyhvYmopO1xuICAgIGlmICghb3B0aW9ucy5wYXJ0ICYmXG4gICAgICAgIG9iaktleXMubGVuZ3RoICE9PSBrZXlzKHJlZikubGVuZ3RoICYmXG4gICAgICAgICFvcHRpb25zLnNraXApIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHNraXBwZWQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG9iaktleXMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcCAmJlxuICAgICAgICAgICAgb3B0aW9ucy5za2lwLmluY2x1ZGVzKGtleSkpIHtcblxuICAgICAgICAgICAgaWYgKHJlZltrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICArK3NraXBwZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtrZXldLCByZWZba2V5XSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5wYXJ0ICYmXG4gICAgICAgIG9iaktleXMubGVuZ3RoIC0gc2tpcHBlZCAhPT0ga2V5cyhyZWYpLmxlbmd0aCkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBzeW1ib2xzXG5cbiAgICBpZiAob3B0aW9ucy5zeW1ib2xzICE9PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICBjb25zdCBvYmpTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaik7XG4gICAgICAgIGNvbnN0IHJlZlN5bWJvbHMgPSBuZXcgU2V0KGdldE93blByb3BlcnR5U3ltYm9scyhyZWYpKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBvYmpTeW1ib2xzKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2tpcCB8fFxuICAgICAgICAgICAgICAgICFvcHRpb25zLnNraXAuaW5jbHVkZXMoa2V5KSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc093bkVudW1lcmFibGVQcm9wZXJ0eShvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsKG9ialtrZXldLCByZWZba2V5XSwgb3B0aW9ucywgc2VlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNPd25FbnVtZXJhYmxlUHJvcGVydHkocmVmLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlZlN5bWJvbHMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZWZTeW1ib2xzKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duRW51bWVyYWJsZVByb3BlcnR5KHJlZiwga2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuXG5pbnRlcm5hbHMuU2VlbkVudHJ5ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob2JqLCByZWYpIHtcblxuICAgICAgICB0aGlzLm9iaiA9IG9iajtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgfVxuXG4gICAgaXNTYW1lKG9iaiwgcmVmKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub2JqID09PSBvYmogJiYgdGhpcy5yZWYgPT09IHJlZjtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJpbmdpZnkgPSByZXF1aXJlKCcuL3N0cmluZ2lmeScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG5cbiAgICAgICAgY29uc3QgbXNncyA9IGFyZ3NcbiAgICAgICAgICAgIC5maWx0ZXIoKGFyZykgPT4gYXJnICE9PSAnJylcbiAgICAgICAgICAgIC5tYXAoKGFyZykgPT4ge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gYXJnIDogYXJnIGluc3RhbmNlb2YgRXJyb3IgPyBhcmcubWVzc2FnZSA6IFN0cmluZ2lmeShhcmcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgc3VwZXIobXNncy5qb2luKCcgJykgfHwgJ1Vua25vd24gZXJyb3InKTtcblxuICAgICAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKSB7ICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBleHBvcnRzLmFzc2VydCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXG4gICAgLy8gQWxsb3dlZCB2YWx1ZSBjaGFyYWN0ZXJzOiAhIyQlJicoKSorLC0uLzo7PD0+P0BbXV5fYHt8fX4gYW5kIHNwYWNlLCBhLXosIEEtWiwgMC05LCBcXCwgXCJcblxuICAgIEFzc2VydCgvXlsgXFx3XFwhI1xcJCUmJ1xcKFxcKVxcKlxcKyxcXC1cXC5cXC9cXDo7PFxcPT5cXD9AXFxbXFxdXFxeYFxce1xcfFxcfX5cXFwiXFxcXF0qJC8udGVzdChhdHRyaWJ1dGUpLCAnQmFkIGF0dHJpYnV0ZSB2YWx1ZSAoJyArIGF0dHJpYnV0ZSArICcpJyk7XG5cbiAgICByZXR1cm4gYXR0cmlidXRlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFxcIi9nLCAnXFxcXFwiJyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFc2NhcGUgcXVvdGVzIGFuZCBzbGFzaFxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblxuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGxldCBlc2NhcGVkID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChpbnRlcm5hbHMuaXNTYWZlKGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgZXNjYXBlZCArPSBpbnB1dFtpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVzY2FwZWQgKz0gaW50ZXJuYWxzLmVzY2FwZUh0bWxDaGFyKGNoYXJDb2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlc2NhcGVkO1xufTtcblxuXG5pbnRlcm5hbHMuZXNjYXBlSHRtbENoYXIgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcblxuICAgIGNvbnN0IG5hbWVkRXNjYXBlID0gaW50ZXJuYWxzLm5hbWVkSHRtbFtjaGFyQ29kZV07XG4gICAgaWYgKHR5cGVvZiBuYW1lZEVzY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVkRXNjYXBlO1xuICAgIH1cblxuICAgIGlmIChjaGFyQ29kZSA+PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuICcmIycgKyBjaGFyQ29kZSArICc7JztcbiAgICB9XG5cbiAgICBjb25zdCBoZXhWYWx1ZSA9IGNoYXJDb2RlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgIHJldHVybiBgJiN4JHtoZXhWYWx1ZX07YDtcbn07XG5cblxuaW50ZXJuYWxzLmlzU2FmZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuXG4gICAgcmV0dXJuICh0eXBlb2YgaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXNbY2hhckNvZGVdICE9PSAndW5kZWZpbmVkJyk7XG59O1xuXG5cbmludGVybmFscy5uYW1lZEh0bWwgPSB7XG4gICAgJzM4JzogJyZhbXA7JyxcbiAgICAnNjAnOiAnJmx0OycsXG4gICAgJzYyJzogJyZndDsnLFxuICAgICczNCc6ICcmcXVvdDsnLFxuICAgICcxNjAnOiAnJm5ic3A7JyxcbiAgICAnMTYyJzogJyZjZW50OycsXG4gICAgJzE2Myc6ICcmcG91bmQ7JyxcbiAgICAnMTY0JzogJyZjdXJyZW47JyxcbiAgICAnMTY5JzogJyZjb3B5OycsXG4gICAgJzE3NCc6ICcmcmVnOydcbn07XG5cblxuaW50ZXJuYWxzLnNhZmVDaGFyQ29kZXMgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qgc2FmZSA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDMyOyBpIDwgMTIzOyArK2kpIHtcblxuICAgICAgICBpZiAoKGkgPj0gOTcpIHx8ICAgICAgICAgICAgICAgICAgICAvLyBhLXpcbiAgICAgICAgICAgIChpID49IDY1ICYmIGkgPD0gOTApIHx8ICAgICAgICAgLy8gQS1aXG4gICAgICAgICAgICAoaSA+PSA0OCAmJiBpIDw9IDU3KSB8fCAgICAgICAgIC8vIDAtOVxuICAgICAgICAgICAgaSA9PT0gMzIgfHwgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZVxuICAgICAgICAgICAgaSA9PT0gNDYgfHwgICAgICAgICAgICAgICAgICAgICAvLyAuXG4gICAgICAgICAgICBpID09PSA0NCB8fCAgICAgICAgICAgICAgICAgICAgIC8vICxcbiAgICAgICAgICAgIGkgPT09IDQ1IHx8ICAgICAgICAgICAgICAgICAgICAgLy8gLVxuICAgICAgICAgICAgaSA9PT0gNTggfHwgICAgICAgICAgICAgICAgICAgICAvLyA6XG4gICAgICAgICAgICBpID09PSA5NSkgeyAgICAgICAgICAgICAgICAgICAgIC8vIF9cblxuICAgICAgICAgICAgc2FmZVtpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2FmZTtcbn0oKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCBsZXNzVGhhbiA9IDB4M0M7XG4gICAgY29uc3QgZ3JlYXRlclRoYW4gPSAweDNFO1xuICAgIGNvbnN0IGFuZFN5bWJvbCA9IDB4MjY7XG4gICAgY29uc3QgbGluZVNlcGVyYXRvciA9IDB4MjAyODtcblxuICAgIC8vIHJlcGxhY2UgbWV0aG9kXG4gICAgbGV0IGNoYXJDb2RlO1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bPD4mXFx1MjAyOFxcdTIwMjldL2csIChtYXRjaCkgPT4ge1xuXG4gICAgICAgIGNoYXJDb2RlID0gbWF0Y2guY2hhckNvZGVBdCgwKTtcblxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IGxlc3NUaGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MDAzYyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IGdyZWF0ZXJUaGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MDAzZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhckNvZGUgPT09IGFuZFN5bWJvbCkge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcdTAwMjYnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYXJDb2RlID09PSBsaW5lU2VwZXJhdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1xcXFx1MjAyOSc7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIC8vIEVzY2FwZSBeJC4qKy0/PSE6fFxcLygpW117fSxcblxuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvW1xcXlxcJFxcLlxcKlxcK1xcLVxcP1xcPVxcIVxcOlxcfFxcXFxcXC9cXChcXClcXFtcXF1cXHtcXH1cXCxdL2csICdcXFxcJCYnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyYXksIHRhcmdldCkge1xuXG4gICAgY29uc3QgcmVzdWx0ID0gdGFyZ2V0IHx8IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheVtpXSkpIHtcbiAgICAgICAgICAgIGludGVybmFscy5mbGF0dGVuKGFycmF5W2ldLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhcHBseVRvRGVmYXVsdHM6IHJlcXVpcmUoJy4vYXBwbHlUb0RlZmF1bHRzJyksXG4gICAgYXNzZXJ0OiByZXF1aXJlKCcuL2Fzc2VydCcpLFxuICAgIEJlbmNoOiByZXF1aXJlKCcuL2JlbmNoJyksXG4gICAgYmxvY2s6IHJlcXVpcmUoJy4vYmxvY2snKSxcbiAgICBjbG9uZTogcmVxdWlyZSgnLi9jbG9uZScpLFxuICAgIGNvbnRhaW46IHJlcXVpcmUoJy4vY29udGFpbicpLFxuICAgIGRlZXBFcXVhbDogcmVxdWlyZSgnLi9kZWVwRXF1YWwnKSxcbiAgICBFcnJvcjogcmVxdWlyZSgnLi9lcnJvcicpLFxuICAgIGVzY2FwZUhlYWRlckF0dHJpYnV0ZTogcmVxdWlyZSgnLi9lc2NhcGVIZWFkZXJBdHRyaWJ1dGUnKSxcbiAgICBlc2NhcGVIdG1sOiByZXF1aXJlKCcuL2VzY2FwZUh0bWwnKSxcbiAgICBlc2NhcGVKc29uOiByZXF1aXJlKCcuL2VzY2FwZUpzb24nKSxcbiAgICBlc2NhcGVSZWdleDogcmVxdWlyZSgnLi9lc2NhcGVSZWdleCcpLFxuICAgIGZsYXR0ZW46IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIGlnbm9yZTogcmVxdWlyZSgnLi9pZ25vcmUnKSxcbiAgICBpbnRlcnNlY3Q6IHJlcXVpcmUoJy4vaW50ZXJzZWN0JyksXG4gICAgbWVyZ2U6IHJlcXVpcmUoJy4vbWVyZ2UnKSxcbiAgICBvbmNlOiByZXF1aXJlKCcuL29uY2UnKSxcbiAgICByZWFjaDogcmVxdWlyZSgnLi9yZWFjaCcpLFxuICAgIHJlYWNoVGVtcGxhdGU6IHJlcXVpcmUoJy4vcmVhY2hUZW1wbGF0ZScpLFxuICAgIHN0cmluZ2lmeTogcmVxdWlyZSgnLi9zdHJpbmdpZnknKSxcbiAgICB3YWl0OiByZXF1aXJlKCcuL3dhaXQnKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKCFhcnJheTEgfHxcbiAgICAgICAgIWFycmF5Mikge1xuXG4gICAgICAgIHJldHVybiAob3B0aW9ucy5maXJzdCA/IG51bGwgOiBbXSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tbW9uID0gW107XG4gICAgY29uc3QgaGFzaCA9IChBcnJheS5pc0FycmF5KGFycmF5MSkgPyBuZXcgU2V0KGFycmF5MSkgOiBhcnJheTEpO1xuICAgIGNvbnN0IGZvdW5kID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXJyYXkyKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbHMuaGFzKGhhc2gsIHZhbHVlKSAmJlxuICAgICAgICAgICAgIWZvdW5kLmhhcyh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmlyc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbW1vbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGZvdW5kLmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKG9wdGlvbnMuZmlyc3QgPyBudWxsIDogY29tbW9uKTtcbn07XG5cblxuaW50ZXJuYWxzLmhhcyA9IGZ1bmN0aW9uIChyZWYsIGtleSkge1xuXG4gICAgaWYgKHR5cGVvZiByZWYuaGFzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiByZWYuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZltrZXldICE9PSB1bmRlZmluZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCcuL2Nsb25lJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5tZXJnZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JywgJ0ludmFsaWQgdGFyZ2V0IHZhbHVlOiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIEFzc2VydChzb3VyY2UgPT09IG51bGwgfHwgc291cmNlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHNvdXJjZSA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHNvdXJjZSB2YWx1ZTogbXVzdCBiZSBudWxsLCB1bmRlZmluZWQsIG9yIGFuIG9iamVjdCcpO1xuXG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IG51bGxPdmVycmlkZTogdHJ1ZSwgbWVyZ2VBcnJheXM6IHRydWUgfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgIEFzc2VydChBcnJheS5pc0FycmF5KHRhcmdldCksICdDYW5ub3QgbWVyZ2UgYXJyYXkgb250byBhbiBvYmplY3QnKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLm1lcmdlQXJyYXlzKSB7XG4gICAgICAgICAgICB0YXJnZXQubGVuZ3RoID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTXVzdCBub3QgY2hhbmdlIHRhcmdldCBhc3NpZ25tZW50XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goQ2xvbmUoc291cmNlW2ldLCB7IHN5bWJvbHM6IG9wdGlvbnMuc3ltYm9scyB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBVdGlscy5rZXlzKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFtrZXldICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSAhPT0gQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICAgICAgKEJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB8fCAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IENsb25lKHZhbHVlLCB7IHN5bWJvbHM6IG9wdGlvbnMuc3ltYm9scyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludGVybmFscy5tZXJnZSh0YXJnZXRba2V5XSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IHRvIHByZXNlcnZlIGVtcHR5IHN0cmluZ3NcblxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm51bGxPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG5cbiAgICBpZiAobWV0aG9kLl9ob2VrT25jZSkge1xuICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgIH1cblxuICAgIGxldCBvbmNlID0gZmFsc2U7XG4gICAgY29uc3Qgd3JhcHBlZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgaWYgKCFvbmNlKSB7XG4gICAgICAgICAgICBvbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIG1ldGhvZCguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB3cmFwcGVkLl9ob2VrT25jZSA9IHRydWU7XG4gICAgcmV0dXJuIHdyYXBwZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCcuL2Fzc2VydCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgY2hhaW4sIG9wdGlvbnMpIHtcblxuICAgIGlmIChjaGFpbiA9PT0gZmFsc2UgfHxcbiAgICAgICAgY2hhaW4gPT09IG51bGwgfHxcbiAgICAgICAgY2hhaW4gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0geyBzZXBhcmF0b3I6IG9wdGlvbnMgfTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0NoYWluQXJyYXkgPSBBcnJheS5pc0FycmF5KGNoYWluKTtcblxuICAgIEFzc2VydCghaXNDaGFpbkFycmF5IHx8ICFvcHRpb25zLnNlcGFyYXRvciwgJ1NlcGFyYXRvciBvcHRpb24gbm8gdmFsaWQgZm9yIGFycmF5LWJhc2VkIGNoYWluJyk7XG5cbiAgICBjb25zdCBwYXRoID0gaXNDaGFpbkFycmF5ID8gY2hhaW4gOiBjaGFpbi5zcGxpdChvcHRpb25zLnNlcGFyYXRvciB8fCAnLicpO1xuICAgIGxldCByZWYgPSBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBrZXkgPSBwYXRoW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy5pdGVyYWJsZXMgJiYgaW50ZXJuYWxzLml0ZXJhYmxlcyhyZWYpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZikgfHxcbiAgICAgICAgICAgIHR5cGUgPT09ICdzZXQnKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bWJlciA8IDAgPyByZWYubGVuZ3RoICsgbnVtYmVyIDogbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZWYgfHxcbiAgICAgICAgICAgIHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5mdW5jdGlvbnMgPT09IGZhbHNlIHx8ICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgIXR5cGUgJiYgcmVmW2tleV0gPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBBc3NlcnQoIW9wdGlvbnMuc3RyaWN0IHx8IGkgKyAxID09PSBwYXRoLmxlbmd0aCwgJ01pc3Npbmcgc2VnbWVudCcsIGtleSwgJ2luIHJlYWNoIHBhdGggJywgY2hhaW4pO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiByZWYgPT09ICdvYmplY3QnIHx8IG9wdGlvbnMuZnVuY3Rpb25zID09PSB0cnVlIHx8IHR5cGVvZiByZWYgIT09ICdmdW5jdGlvbicsICdJbnZhbGlkIHNlZ21lbnQnLCBrZXksICdpbiByZWFjaCBwYXRoICcsIGNoYWluKTtcbiAgICAgICAgICAgIHJlZiA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZWYgPSByZWZba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2V0Jykge1xuICAgICAgICAgICAgcmVmID0gWy4uLnJlZl1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgIC8vIHR5cGUgPT09ICdtYXAnXG4gICAgICAgICAgICByZWYgPSByZWYuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVmO1xufTtcblxuXG5pbnRlcm5hbHMuaXRlcmFibGVzID0gZnVuY3Rpb24gKHJlZikge1xuXG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gJ3NldCc7XG4gICAgfVxuXG4gICAgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gJ21hcCc7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUmVhY2ggPSByZXF1aXJlKCcuL3JlYWNoJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCB0ZW1wbGF0ZSwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoL3soW159XSspfS9nLCAoJDAsIGNoYWluKSA9PiB7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBSZWFjaChvYmosIGNoYWluLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsID8gJycgOiB2YWx1ZSk7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuICdbQ2Fubm90IGRpc3BsYXkgb2JqZWN0OiAnICsgZXJyLm1lc3NhZ2UgKyAnXSc7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFycmF5OiBBcnJheS5wcm90b3R5cGUsXG4gICAgYnVmZmVyOiBCdWZmZXIgJiYgQnVmZmVyLnByb3RvdHlwZSwgICAgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgZGF0ZTogRGF0ZS5wcm90b3R5cGUsXG4gICAgZXJyb3I6IEVycm9yLnByb3RvdHlwZSxcbiAgICBnZW5lcmljOiBPYmplY3QucHJvdG90eXBlLFxuICAgIG1hcDogTWFwLnByb3RvdHlwZSxcbiAgICBwcm9taXNlOiBQcm9taXNlLnByb3RvdHlwZSxcbiAgICByZWdleDogUmVnRXhwLnByb3RvdHlwZSxcbiAgICBzZXQ6IFNldC5wcm90b3R5cGUsXG4gICAgd2Vha01hcDogV2Vha01hcC5wcm90b3R5cGUsXG4gICAgd2Vha1NldDogV2Vha1NldC5wcm90b3R5cGVcbn07XG5cblxuaW50ZXJuYWxzLnR5cGVNYXAgPSBuZXcgTWFwKFtcbiAgICBbJ1tvYmplY3QgRXJyb3JdJywgZXhwb3J0cy5lcnJvcl0sXG4gICAgWydbb2JqZWN0IE1hcF0nLCBleHBvcnRzLm1hcF0sXG4gICAgWydbb2JqZWN0IFByb21pc2VdJywgZXhwb3J0cy5wcm9taXNlXSxcbiAgICBbJ1tvYmplY3QgU2V0XScsIGV4cG9ydHMuc2V0XSxcbiAgICBbJ1tvYmplY3QgV2Vha01hcF0nLCBleHBvcnRzLndlYWtNYXBdLFxuICAgIFsnW29iamVjdCBXZWFrU2V0XScsIGV4cG9ydHMud2Vha1NldF1cbl0pO1xuXG5cbmV4cG9ydHMuZ2V0SW50ZXJuYWxQcm90byA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuYXJyYXk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBCdWZmZXIpIHsgICAgICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgIHJldHVybiBleHBvcnRzLmJ1ZmZlcjtcbiAgICB9XG5cbiAgICBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5kYXRlO1xuICAgIH1cblxuICAgIGlmIChvYmogaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVnZXg7XG4gICAgfVxuXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmVycm9yO1xuICAgIH1cblxuICAgIGNvbnN0IG9iak5hbWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLnR5cGVNYXAuZ2V0KG9iak5hbWUpIHx8IGV4cG9ydHMuZ2VuZXJpYztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnLi9yZWFjaCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgcmV0dXJuIG9wdGlvbnMuc3ltYm9scyAhPT0gZmFsc2UgPyBSZWZsZWN0Lm93bktleXMob2JqKSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaik7ICAvLyBEZWZhdWx0cyB0byB0cnVlXG59O1xuXG5cbmV4cG9ydHMuc3RvcmUgPSBmdW5jdGlvbiAoc291cmNlLCBrZXlzKSB7XG5cbiAgICBjb25zdCBzdG9yYWdlID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFJlYWNoKHNvdXJjZSwga2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgICAgICBzdG9yYWdlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGludGVybmFscy5yZWFjaFNldChzb3VyY2UsIGtleSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdG9yYWdlO1xufTtcblxuXG5leHBvcnRzLnJlc3RvcmUgPSBmdW5jdGlvbiAoY29weSwgc291cmNlLCBzdG9yYWdlKSB7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdG9yYWdlKSB7XG4gICAgICAgIGludGVybmFscy5yZWFjaFNldChjb3B5LCBrZXksIHZhbHVlKTtcbiAgICAgICAgaW50ZXJuYWxzLnJlYWNoU2V0KHNvdXJjZSwga2V5LCB2YWx1ZSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMucmVhY2hTZXQgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG5cbiAgICBjb25zdCBwYXRoID0gQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDoga2V5LnNwbGl0KCcuJyk7XG4gICAgbGV0IHJlZiA9IG9iajtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHBhdGhbaV07XG4gICAgICAgIGlmIChpICsgMSA9PT0gcGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlZltzZWdtZW50XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmID0gcmVmW3NlZ21lbnRdO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBQYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgSm9pID0gcmVxdWlyZSgnQGhhcGkvam9pJyk7XG5cbmNvbnN0IEZpbGUgPSByZXF1aXJlKCcuL2ZpbGUnKTtcbmNvbnN0IEZzID0gcmVxdWlyZSgnLi9mcycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBKb2kub2JqZWN0KHtcbiAgICBwYXRoOiBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCksIEpvaS5mdW5jKCkpLnJlcXVpcmVkKCksXG4gICAgaW5kZXg6IEpvaS5hbHRlcm5hdGl2ZXMoSm9pLmJvb2xlYW4oKSwgSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKSkuZGVmYXVsdCh0cnVlKSxcbiAgICBsaXN0aW5nOiBKb2kuYm9vbGVhbigpLFxuICAgIHNob3dIaWRkZW46IEpvaS5ib29sZWFuKCksXG4gICAgcmVkaXJlY3RUb1NsYXNoOiBKb2kuYm9vbGVhbigpLFxuICAgIGxvb2t1cENvbXByZXNzZWQ6IEpvaS5ib29sZWFuKCksXG4gICAgbG9va3VwTWFwOiBKb2kub2JqZWN0KCkubWluKDEpLnBhdHRlcm4oLy4rLywgSm9pLnN0cmluZygpKSxcbiAgICBldGFnTWV0aG9kOiBKb2kuc3RyaW5nKCkudmFsaWQoJ2hhc2gnLCAnc2ltcGxlJykuYWxsb3coZmFsc2UpLFxuICAgIGRlZmF1bHRFeHRlbnNpb246IEpvaS5zdHJpbmcoKS5hbHBoYW51bSgpXG59KTtcblxuXG5pbnRlcm5hbHMucmVzb2x2ZVBhdGhPcHRpb24gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG5cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHRocm93IEJvb20uaW50ZXJuYWwoJ0ludmFsaWQgcGF0aCBmdW5jdGlvbicpO1xufTtcblxuXG5leHBvcnRzLmhhbmRsZXIgPSBmdW5jdGlvbiAocm91dGUsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHNldHRpbmdzID0gSm9pLmF0dGVtcHQob3B0aW9ucywgaW50ZXJuYWxzLnNjaGVtYSwgJ0ludmFsaWQgZGlyZWN0b3J5IGhhbmRsZXIgb3B0aW9ucyAoJyArIHJvdXRlLnBhdGggKyAnKScpO1xuICAgIEhvZWsuYXNzZXJ0KHJvdXRlLnBhdGhbcm91dGUucGF0aC5sZW5ndGggLSAxXSA9PT0gJ30nLCAnVGhlIHJvdXRlIHBhdGggZm9yIGEgZGlyZWN0b3J5IGhhbmRsZXIgbXVzdCBlbmQgd2l0aCBhIHBhcmFtZXRlcjonLCByb3V0ZS5wYXRoKTtcblxuICAgIGNvbnN0IHBhcmFtTmFtZSA9IC9cXHcrLy5leGVjKHJvdXRlLnBhdGguc2xpY2Uocm91dGUucGF0aC5sYXN0SW5kZXhPZigneycpKSlbMF07XG4gICAgY29uc3QgYmFzZVBhdGggPSByb3V0ZS5zZXR0aW5ncy5maWxlcy5yZWxhdGl2ZVRvO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IChBcnJheS5pc0FycmF5KHNldHRpbmdzLnBhdGgpID8gc2V0dGluZ3MucGF0aCA6IG51bGwpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBvciBmdW5jdGlvblxuICAgIGNvbnN0IGluZGV4TmFtZXMgPSAoc2V0dGluZ3MuaW5kZXggPT09IHRydWUpID8gWydpbmRleC5odG1sJ10gOiAoc2V0dGluZ3MuaW5kZXggfHwgW10pO1xuXG4gICAgLy8gRGVjbGFyZSBoYW5kbGVyXG5cbiAgICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKHJlcXVlc3QsIHJlcGx5KSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGF0aHMgPSBub3JtYWxpemVkIHx8IGludGVybmFscy5yZXNvbHZlUGF0aE9wdGlvbihzZXR0aW5ncy5wYXRoLmNhbGwobnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAgIC8vIEFwcGVuZCBwYXJhbWV0ZXJcblxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSByZXF1ZXN0LnBhcmFtc1twYXJhbU5hbWVdO1xuICAgICAgICBpZiAoc2VsZWN0aW9uICYmXG4gICAgICAgICAgICAhc2V0dGluZ3Muc2hvd0hpZGRlbiAmJlxuICAgICAgICAgICAgaW50ZXJuYWxzLmlzRmlsZUhpZGRlbihzZWxlY3Rpb24pKSB7XG5cbiAgICAgICAgICAgIHRocm93IEJvb20ubm90Rm91bmQobnVsbCwge30pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChyZXF1ZXN0LnNlcnZlci5zZXR0aW5ncy5yb3V0ZXIuc3RyaXBUcmFpbGluZ1NsYXNoIHx8ICFyZXF1ZXN0LnBhdGguZW5kc1dpdGgoJy8nKSkpIHtcblxuICAgICAgICAgICAgcmVxdWVzdC5wYXRoICs9ICcvJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHJlc3BvbnNlXG5cbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSByZXF1ZXN0LnBhdGg7XG4gICAgICAgIGNvbnN0IGhhc1RyYWlsaW5nU2xhc2ggPSByZXNvdXJjZS5lbmRzV2l0aCgnLycpO1xuICAgICAgICBjb25zdCBmaWxlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNvbmZpbmU6IG51bGwsXG4gICAgICAgICAgICBsb29rdXBDb21wcmVzc2VkOiBzZXR0aW5ncy5sb29rdXBDb21wcmVzc2VkLFxuICAgICAgICAgICAgbG9va3VwTWFwOiBzZXR0aW5ncy5sb29rdXBNYXAsXG4gICAgICAgICAgICBldGFnTWV0aG9kOiBzZXR0aW5ncy5ldGFnTWV0aG9kXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IGFzeW5jIChiYXNlRGlyKSA9PiB7XG5cbiAgICAgICAgICAgIGZpbGVPcHRpb25zLmNvbmZpbmUgPSBiYXNlRGlyO1xuXG4gICAgICAgICAgICBsZXQgcGF0aCA9IHNlbGVjdGlvbiB8fCAnJztcbiAgICAgICAgICAgIGxldCBlcnJvcjtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgRmlsZS5sb2FkKHBhdGgsIHJlcXVlc3QsIGZpbGVPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBCb3VuY2UuaWdub3JlKGVyciwgJ2Jvb20nKTtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFuZGxlIE5vdCBmb3VuZFxuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmlzTm90Rm91bmQoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5kZWZhdWx0RXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChoYXNUcmFpbGluZ1NsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgRmlsZS5sb2FkKHBhdGggKyAnLicgKyBzZXR0aW5ncy5kZWZhdWx0RXh0ZW5zaW9uLCByZXF1ZXN0LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBEaXJlY3RvcnlcblxuICAgICAgICAgICAgaWYgKGludGVybmFscy5pc0RpcmVjdG9yeShlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucmVkaXJlY3RUb1NsYXNoICE9PSBmYWxzZSAmJiAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAhcmVxdWVzdC5zZXJ2ZXIuc2V0dGluZ3Mucm91dGVyLnN0cmlwVHJhaWxpbmdTbGFzaCAmJlxuICAgICAgICAgICAgICAgICAgICAhaGFzVHJhaWxpbmdTbGFzaCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBseS5yZWRpcmVjdChyZXNvdXJjZSArICcvJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleE5hbWUgb2YgaW5kZXhOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleEZpbGUgPSBQYXRoLmpvaW4ocGF0aCwgaW5kZXhOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBGaWxlLmxvYWQoaW5kZXhGaWxlLCByZXF1ZXN0LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgQm91bmNlLmlnbm9yZShlcnIsICdib29tJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmlzTm90Rm91bmQoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEJvb20uaW50ZXJuYWwoaW5kZXhOYW1lICsgJyBpcyBhIGRpcmVjdG9yeScsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBmb3VuZCAtIHRyeSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb25lIG9mIHRoZSBpbmRleCBmaWxlcyB3ZXJlIGZvdW5kXG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubGlzdGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlTGlzdGluZyhQYXRoLmpvaW4oYmFzZVBhdGgsIGJhc2VEaXIsIHBhdGgpLCByZXNvdXJjZSwgc2VsZWN0aW9uLCBoYXNUcmFpbGluZ1NsYXNoLCBzZXR0aW5ncywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBlYWNoKHBhdGhzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBCb3VuY2UuaWdub3JlKGVyciwgJ2Jvb20nKTtcblxuICAgICAgICAgICAgICAgIC8vIFByb3BhZ2F0ZSBhbnkgbm9uLTQwNCBlcnJvcnNcblxuICAgICAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLmlzTm90Rm91bmQoZXJyKSB8fFxuICAgICAgICAgICAgICAgICAgICBpID09PSBwYXRocy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBCb29tLm5vdEZvdW5kKG51bGwsIHt9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGhhbmRsZXI7XG59O1xuXG5cbmludGVybmFscy5nZW5lcmF0ZUxpc3RpbmcgPSBhc3luYyBmdW5jdGlvbiAocGF0aCwgcmVzb3VyY2UsIHNlbGVjdGlvbiwgaGFzVHJhaWxpbmdTbGFzaCwgc2V0dGluZ3MsIHJlcXVlc3QpIHtcblxuICAgIGxldCBmaWxlcztcbiAgICB0cnkge1xuICAgICAgICBmaWxlcyA9IGF3YWl0IEZzLnJlYWRkaXIocGF0aCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCAnc3lzdGVtJyk7XG4gICAgICAgIHRocm93IEJvb20uaW50ZXJuYWwoJ0Vycm9yIGFjY2Vzc2luZyBkaXJlY3RvcnknLCBlcnIpO1xuICAgIH1cblxuICAgIHJlc291cmNlID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlc291cmNlKTtcbiAgICBjb25zdCBkaXNwbGF5ID0gSG9lay5lc2NhcGVIdG1sKHJlc291cmNlKTtcbiAgICBsZXQgaHRtbCA9ICc8aHRtbD48aGVhZD48dGl0bGU+JyArIGRpc3BsYXkgKyAnPC90aXRsZT48L2hlYWQ+PGJvZHk+PGgxPkRpcmVjdG9yeTogJyArIGRpc3BsYXkgKyAnPC9oMT48dWw+JztcblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gcmVzb3VyY2Uuc3Vic3RyaW5nKDAsIHJlc291cmNlLmxhc3RJbmRleE9mKCcvJywgcmVzb3VyY2UubGVuZ3RoIC0gKGhhc1RyYWlsaW5nU2xhc2ggPyAyIDogMSkpKSArICcvJztcbiAgICAgICAgaHRtbCA9IGh0bWwgKyAnPGxpPjxhIGhyZWY9XCInICsgaW50ZXJuYWxzLnBhdGhFbmNvZGUocGFyZW50KSArICdcIj5QYXJlbnQgRGlyZWN0b3J5PC9hPjwvbGk+JztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zaG93SGlkZGVuIHx8XG4gICAgICAgICAgICAhaW50ZXJuYWxzLmlzRmlsZUhpZGRlbihmaWxlc1tpXSkpIHtcblxuICAgICAgICAgICAgaHRtbCA9IGh0bWwgKyAnPGxpPjxhIGhyZWY9XCInICsgaW50ZXJuYWxzLnBhdGhFbmNvZGUocmVzb3VyY2UgKyAoIWhhc1RyYWlsaW5nU2xhc2ggPyAnLycgOiAnJykgKyBmaWxlc1tpXSkgKyAnXCI+JyArIEhvZWsuZXNjYXBlSHRtbChmaWxlc1tpXSkgKyAnPC9hPjwvbGk+JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGh0bWwgPSBodG1sICsgJzwvdWw+PC9ib2R5PjwvaHRtbD4nO1xuXG4gICAgcmV0dXJuIHJlcXVlc3QuZ2VuZXJhdGVSZXNwb25zZShodG1sKTtcbn07XG5cblxuaW50ZXJuYWxzLmlzRmlsZUhpZGRlbiA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICByZXR1cm4gLyhefFtcXFxcXFwvXSlcXC4oW14uXFxcXFxcL118XFwuW15cXFxcXFwvXSkvLnRlc3QocGF0aCk7ICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBhICcuJyBvciBjb250YWlucyAnLy4nIG9yICdcXC4nLCB3aGljaCBpcyBub3QgZm9sbG93ZWQgYnkgYSAnLycgb3IgJ1xcJyBvciAnLidcbn07XG5cblxuaW50ZXJuYWxzLnBhdGhFbmNvZGUgPSBmdW5jdGlvbiAocGF0aCkge1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwYXRoKS5yZXBsYWNlKC8lMkYvZywgJy8nKS5yZXBsYWNlKC8lNUMvZywgJ1xcXFwnKTtcbn07XG5cblxuaW50ZXJuYWxzLmlzTm90Rm91bmQgPSBmdW5jdGlvbiAoYm9vbSkge1xuXG4gICAgcmV0dXJuIGJvb20ub3V0cHV0LnN0YXR1c0NvZGUgPT09IDQwNDtcbn07XG5cblxuaW50ZXJuYWxzLmlzRGlyZWN0b3J5ID0gZnVuY3Rpb24gKGJvb20pIHtcblxuICAgIHJldHVybiBib29tLm91dHB1dC5zdGF0dXNDb2RlID09PSA0MDMgJiYgYm9vbS5kYXRhLmNvZGUgPT09ICdFSVNESVInO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQ3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IExydUNhY2hlID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHBlbmRpbmdzOiBPYmplY3QuY3JlYXRlKG51bGwpXG59O1xuXG5cbmludGVybmFscy5zdHJlYW1FbmQgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIHN0cmVhbS5vbignZW5kJywgcmVzb2x2ZSk7XG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpO1xuICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuY29tcHV0ZUhhc2hlZCA9IGFzeW5jIGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdCkge1xuXG4gICAgY29uc3QgZXRhZ3MgPSByZXNwb25zZS5yZXF1ZXN0LnNlcnZlci5wbHVnaW5zLmluZXJ0Ll9ldGFncztcbiAgICBpZiAoIWV0YWdzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFVzZSBzdGF0IGluZm8gZm9yIGFuIExSVSBjYWNoZSBrZXkuXG5cbiAgICBjb25zdCBwYXRoID0gcmVzcG9uc2Uuc291cmNlLnBhdGg7XG4gICAgY29uc3QgY2FjaGVrZXkgPSBbcGF0aCwgc3RhdC5pbm8sIHN0YXQuc2l6ZSwgc3RhdC5tdGltZS5nZXRUaW1lKCldLmpvaW4oJy0nKTtcblxuICAgIC8vIFRoZSBldGFnIGhhc2hlcyB0aGUgZmlsZSBjb250ZW50cyBpbiBvcmRlciB0byBiZSBjb25zaXN0ZW50IGFjcm9zcyBkaXN0cmlidXRlZCBkZXBsb3ltZW50c1xuXG4gICAgY29uc3QgY2FjaGVkRXRhZyA9IGV0YWdzLmdldChjYWNoZWtleSk7XG4gICAgaWYgKGNhY2hlZEV0YWcpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEV0YWc7XG4gICAgfVxuXG4gICAgbGV0IHByb21pc2UgPSBpbnRlcm5hbHMucGVuZGluZ3NbY2FjaGVrZXldO1xuICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICAgIH1cblxuICAgIC8vIFN0YXJ0IGhhc2hpbmdcblxuICAgIGNvbnN0IGNvbXB1dGUgPSBhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBpbnRlcm5hbHMuaGFzaEZpbGUocmVzcG9uc2UpO1xuICAgICAgICAgICAgZXRhZ3Muc2V0KGNhY2hla2V5LCBoYXNoKTtcblxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJuYWxzLnBlbmRpbmdzW2NhY2hla2V5XTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpbnRlcm5hbHMucGVuZGluZ3NbY2FjaGVrZXldID0gcHJvbWlzZSA9IGNvbXB1dGUoKTtcblxuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xufTtcblxuXG5pbnRlcm5hbHMuaGFzaEZpbGUgPSBhc3luYyBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIGNvbnN0IGhhc2ggPSBDcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpO1xuICAgIGhhc2guc2V0RW5jb2RpbmcoJ2hleCcpO1xuXG4gICAgY29uc3QgZmlsZVN0cmVhbSA9IHJlc3BvbnNlLnNvdXJjZS5maWxlLmNyZWF0ZVJlYWRTdHJlYW0oeyBhdXRvQ2xvc2U6IGZhbHNlIH0pO1xuICAgIGZpbGVTdHJlYW0ucGlwZShoYXNoKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGludGVybmFscy5zdHJlYW1FbmQoZmlsZVN0cmVhbSk7XG4gICAgICAgIHJldHVybiBoYXNoLnJlYWQoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBCb3VuY2UucmV0aHJvdyhlcnIsICdzeXN0ZW0nKTtcbiAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVyciwgeyBtZXNzYWdlOiAnRmFpbGVkIHRvIGhhc2ggZmlsZScsIGRhdGE6IHsgcGF0aDogcmVzcG9uc2Uuc291cmNlLnBhdGggfSB9KTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5jb21wdXRlU2ltcGxlID0gZnVuY3Rpb24gKHJlc3BvbnNlLCBzdGF0KSB7XG5cbiAgICBjb25zdCBzaXplID0gc3RhdC5zaXplLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBtdGltZSA9IHN0YXQubXRpbWUuZ2V0VGltZSgpLnRvU3RyaW5nKDE2KTtcblxuICAgIHJldHVybiBzaXplICsgJy0nICsgbXRpbWU7XG59O1xuXG5cbmV4cG9ydHMuYXBwbHkgPSBhc3luYyBmdW5jdGlvbiAocmVzcG9uc2UsIHN0YXQpIHtcblxuICAgIGNvbnN0IGV0YWdNZXRob2QgPSByZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3MuZXRhZ01ldGhvZDtcbiAgICBpZiAoZXRhZ01ldGhvZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBldGFnO1xuICAgIGlmIChldGFnTWV0aG9kID09PSAnc2ltcGxlJykge1xuICAgICAgICBldGFnID0gaW50ZXJuYWxzLmNvbXB1dGVTaW1wbGUocmVzcG9uc2UsIHN0YXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXRhZyA9IGF3YWl0IGludGVybmFscy5jb21wdXRlSGFzaGVkKHJlc3BvbnNlLCBzdGF0KTtcbiAgICB9XG5cbiAgICBpZiAoZXRhZyAhPT0gbnVsbCkge1xuICAgICAgICByZXNwb25zZS5ldGFnKGV0YWcsIHsgdmFyeTogdHJ1ZSB9KTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuQ2FjaGUgPSBMcnVDYWNoZTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgQW1tbyA9IHJlcXVpcmUoJ0BoYXBpL2FtbW8nKTtcbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuY29uc3QgRXRhZyA9IHJlcXVpcmUoJy4vZXRhZycpO1xuY29uc3QgRnMgPSByZXF1aXJlKCcuL2ZzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLmRlZmF1bHRNYXAgPSB7XG4gICAgZ3ppcDogJy5neidcbn07XG5cblxuaW50ZXJuYWxzLnNjaGVtYSA9IEpvaS5hbHRlcm5hdGl2ZXMoW1xuICAgIEpvaS5zdHJpbmcoKSxcbiAgICBKb2kuZnVuYygpLFxuICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICBwYXRoOiBKb2kuYWx0ZXJuYXRpdmVzKEpvaS5zdHJpbmcoKSwgSm9pLmZ1bmMoKSkucmVxdWlyZWQoKSxcbiAgICAgICAgY29uZmluZTogSm9pLmFsdGVybmF0aXZlcyhKb2kuc3RyaW5nKCksIEpvaS5ib29sZWFuKCkpLmRlZmF1bHQodHJ1ZSksXG4gICAgICAgIGZpbGVuYW1lOiBKb2kuc3RyaW5nKCksXG4gICAgICAgIG1vZGU6IEpvaS5zdHJpbmcoKS52YWxpZCgnYXR0YWNobWVudCcsICdpbmxpbmUnKS5hbGxvdyhmYWxzZSksXG4gICAgICAgIGxvb2t1cENvbXByZXNzZWQ6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGxvb2t1cE1hcDogSm9pLm9iamVjdCgpLm1pbigxKS5wYXR0ZXJuKC8uKy8sIEpvaS5zdHJpbmcoKSksXG4gICAgICAgIGV0YWdNZXRob2Q6IEpvaS5zdHJpbmcoKS52YWxpZCgnaGFzaCcsICdzaW1wbGUnKS5hbGxvdyhmYWxzZSksXG4gICAgICAgIHN0YXJ0OiBKb2kubnVtYmVyKCkuaW50ZWdlcigpLm1pbigwKS5kZWZhdWx0KDApLFxuICAgICAgICBlbmQ6IEpvaS5udW1iZXIoKS5pbnRlZ2VyKCkubWluKEpvaS5yZWYoJ3N0YXJ0JykpXG4gICAgfSlcbiAgICAgICAgLndpdGgoJ2ZpbGVuYW1lJywgJ21vZGUnKVxuXSk7XG5cblxuZXhwb3J0cy5oYW5kbGVyID0gZnVuY3Rpb24gKHJvdXRlLCBvcHRpb25zKSB7XG5cbiAgICBsZXQgc2V0dGluZ3MgPSBKb2kuYXR0ZW1wdChvcHRpb25zLCBpbnRlcm5hbHMuc2NoZW1hLCAnSW52YWxpZCBmaWxlIGhhbmRsZXIgb3B0aW9ucyAoJyArIHJvdXRlLnBhdGggKyAnKScpO1xuICAgIHNldHRpbmdzID0gKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyA/IHsgcGF0aDogb3B0aW9ucywgY29uZmluZTogJy4nIH0gOiBzZXR0aW5ncyk7XG4gICAgc2V0dGluZ3MuY29uZmluZSA9IHNldHRpbmdzLmNvbmZpbmUgPT09IHRydWUgPyAnLicgOiBzZXR0aW5ncy5jb25maW5lO1xuICAgIEhvZWsuYXNzZXJ0KHR5cGVvZiBzZXR0aW5ncy5wYXRoICE9PSAnc3RyaW5nJyB8fCBzZXR0aW5ncy5wYXRoW3NldHRpbmdzLnBhdGgubGVuZ3RoIC0gMV0gIT09ICcvJywgJ0ZpbGUgcGF0aCBjYW5ub3QgZW5kIHdpdGggYSBcXCcvXFwnOicsIHJvdXRlLnBhdGgpO1xuXG4gICAgY29uc3QgaGFuZGxlciA9IChyZXF1ZXN0KSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGF0aCA9ICh0eXBlb2Ygc2V0dGluZ3MucGF0aCA9PT0gJ2Z1bmN0aW9uJyA/IHNldHRpbmdzLnBhdGgocmVxdWVzdCkgOiBzZXR0aW5ncy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmVzcG9uc2UocGF0aCwgc2V0dGluZ3MsIHJlcXVlc3QpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaGFuZGxlcjtcbn07XG5cblxuZXhwb3J0cy5sb2FkID0gZnVuY3Rpb24gKHBhdGgsIHJlcXVlc3QsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gZXhwb3J0cy5yZXNwb25zZShwYXRoLCBvcHRpb25zLCByZXF1ZXN0LCB0cnVlKTtcbiAgICByZXR1cm4gaW50ZXJuYWxzLnByZXBhcmUocmVzcG9uc2UpO1xufTtcblxuXG5leHBvcnRzLnJlc3BvbnNlID0gZnVuY3Rpb24gKHBhdGgsIG9wdGlvbnMsIHJlcXVlc3QsIF9wcmVsb2FkZWQpIHtcblxuICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLm1vZGUgfHwgWydhdHRhY2htZW50JywgJ2lubGluZSddLmluZGV4T2Yob3B0aW9ucy5tb2RlKSAhPT0gLTEsICdvcHRpb25zLm1vZGUgbXVzdCBiZSBlaXRoZXIgZmFsc2UsIGF0dGFjaG1lbnQsIG9yIGlubGluZScpO1xuXG4gICAgaWYgKG9wdGlvbnMuY29uZmluZSkge1xuICAgICAgICBjb25zdCBjb25maW5lRGlyID0gUGF0aC5yZXNvbHZlKHJlcXVlc3Qucm91dGUuc2V0dGluZ3MuZmlsZXMucmVsYXRpdmVUbywgb3B0aW9ucy5jb25maW5lKTtcbiAgICAgICAgcGF0aCA9IFBhdGguaXNBYnNvbHV0ZShwYXRoKSA/IFBhdGgubm9ybWFsaXplKHBhdGgpIDogUGF0aC5qb2luKGNvbmZpbmVEaXIsIHBhdGgpO1xuXG4gICAgICAgIC8vIFZlcmlmeSB0aGF0IHJlc29sdmVkIHBhdGggaXMgd2l0aGluIGNvbmZpbmVEaXJcbiAgICAgICAgaWYgKHBhdGgubGFzdEluZGV4T2YoY29uZmluZURpciwgMCkgIT09IDApIHtcbiAgICAgICAgICAgIHBhdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwYXRoID0gUGF0aC5pc0Fic29sdXRlKHBhdGgpID8gUGF0aC5ub3JtYWxpemUocGF0aCkgOiBQYXRoLmpvaW4ocmVxdWVzdC5yb3V0ZS5zZXR0aW5ncy5maWxlcy5yZWxhdGl2ZVRvLCBwYXRoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHNldHRpbmdzOiBvcHRpb25zLFxuICAgICAgICBzdGF0OiBudWxsLFxuICAgICAgICBmaWxlOiBudWxsXG4gICAgfTtcblxuICAgIGNvbnN0IHByZXBhcmUgPSBfcHJlbG9hZGVkID8gbnVsbCA6IGludGVybmFscy5wcmVwYXJlO1xuXG4gICAgcmV0dXJuIHJlcXVlc3QuZ2VuZXJhdGVSZXNwb25zZShzb3VyY2UsIHsgdmFyaWV0eTogJ2ZpbGUnLCBtYXJzaGFsOiBpbnRlcm5hbHMubWFyc2hhbCwgcHJlcGFyZSwgY2xvc2U6IGludGVybmFscy5jbG9zZSB9KTtcbn07XG5cblxuaW50ZXJuYWxzLnByZXBhcmUgPSBhc3luYyBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIGNvbnN0IHBhdGggPSByZXNwb25zZS5zb3VyY2UucGF0aDtcblxuICAgIGlmIChwYXRoID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IEJvb20uZm9yYmlkZGVuKG51bGwsIHsgY29kZTogJ0VBQ0NFUycgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZSA9IHJlc3BvbnNlLnNvdXJjZS5maWxlID0gbmV3IEZzLkZpbGUocGF0aCk7XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdGF0ID0gYXdhaXQgZmlsZS5vcGVuU3RhdCgncicpO1xuXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLnN0YXJ0IHx8IDA7XG4gICAgICAgIGlmIChyZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3MuZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmJ5dGVzKHJlc3BvbnNlLnNvdXJjZS5zZXR0aW5ncy5lbmQgLSBzdGFydCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UuYnl0ZXMoc3RhdC5zaXplIC0gc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICAgICAgcmVzcG9uc2UudHlwZShyZXNwb25zZS5yZXF1ZXN0LnNlcnZlci5taW1lLnBhdGgocGF0aCkudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNwb25zZS5oZWFkZXIoJ2xhc3QtbW9kaWZpZWQnLCBzdGF0Lm10aW1lLnRvVVRDU3RyaW5nKCkpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3MubW9kZSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSByZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3MuZmlsZW5hbWUgfHwgUGF0aC5iYXNlbmFtZShwYXRoKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcignY29udGVudC1kaXNwb3NpdGlvbicsIHJlc3BvbnNlLnNvdXJjZS5zZXR0aW5ncy5tb2RlICsgJzsgZmlsZW5hbWU9JyArIGVuY29kZVVSSUNvbXBvbmVudChmaWxlTmFtZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgRXRhZy5hcHBseShyZXNwb25zZSwgc3RhdCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGludGVybmFscy5jbG9zZShyZXNwb25zZSk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5tYXJzaGFsID0gYXN5bmMgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBpZiAocmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLmxvb2t1cENvbXByZXNzZWQgJiZcbiAgICAgICAgIXJlc3BvbnNlLnNvdXJjZS5zZXR0aW5ncy5zdGFydCAmJlxuICAgICAgICByZXNwb25zZS5zb3VyY2Uuc2V0dGluZ3MuZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcmVzcG9uc2UucmVxdWVzdC5zZXJ2ZXIuc2V0dGluZ3MuY29tcHJlc3Npb24gIT09IGZhbHNlKSB7XG5cbiAgICAgICAgY29uc3QgbG9va3VwTWFwID0gcmVzcG9uc2Uuc291cmNlLnNldHRpbmdzLmxvb2t1cE1hcCB8fCBpbnRlcm5hbHMuZGVmYXVsdE1hcDtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSByZXNwb25zZS5yZXF1ZXN0LmluZm8uYWNjZXB0RW5jb2Rpbmc7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IGxvb2t1cE1hcC5oYXNPd25Qcm9wZXJ0eShlbmNvZGluZykgPyBsb29rdXBNYXBbZW5jb2RpbmddIDogbnVsbDtcbiAgICAgICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgY29uc3QgcHJlY29tcHJlc3NlZCA9IG5ldyBGcy5GaWxlKGAke3Jlc3BvbnNlLnNvdXJjZS5wYXRofSR7ZXh0ZW5zaW9ufWApO1xuICAgICAgICAgICAgbGV0IHN0YXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YXQgPSBhd2FpdCBwcmVjb21wcmVzc2VkLm9wZW5TdGF0KCdyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJlY29tcHJlc3NlZC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIEJvdW5jZS5pZ25vcmUoZXJyLCAnYm9vbScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNvdXJjZS5maWxlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc291cmNlLmZpbGUgPSBwcmVjb21wcmVzc2VkO1xuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYnl0ZXMoc3RhdC5zaXplKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXIoJ2NvbnRlbnQtZW5jb2RpbmcnLCBlbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UudmFyeSgnYWNjZXB0LWVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmNyZWF0ZVN0cmVhbShyZXNwb25zZSk7XG59O1xuXG5cbmludGVybmFscy5hZGRDb250ZW50UmFuZ2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSByZXNwb25zZS5yZXF1ZXN0O1xuICAgIGNvbnN0IGxlbmd0aCA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgbGV0IHJhbmdlID0gbnVsbDtcblxuICAgIGlmIChyZXF1ZXN0LnJvdXRlLnNldHRpbmdzLnJlc3BvbnNlLnJhbmdlcykge1xuICAgICAgICBpZiAocmVxdWVzdC5oZWFkZXJzLnJhbmdlICYmIGxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBJZi1SYW5nZVxuXG4gICAgICAgICAgICBpZiAoIXJlcXVlc3QuaGVhZGVyc1snaWYtcmFuZ2UnXSB8fFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVyc1snaWYtcmFuZ2UnXSA9PT0gcmVzcG9uc2UuaGVhZGVycy5ldGFnKSB7ICAgICAgICAgICAgLy8gSWdub3JpbmcgbGFzdC1tb2RpZmllZCBkYXRlICh3ZWFrKVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCByZXNwb25zZSBpcyBub3QgZW5jb2RlZCBvbmNlIHRyYW5zbWl0dGVkXG5cbiAgICAgICAgICAgICAgICBjb25zdCBtaW1lID0gcmVxdWVzdC5zZXJ2ZXIubWltZS50eXBlKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IChyZXF1ZXN0LnNlcnZlci5zZXR0aW5ncy5jb21wcmVzc2lvbiAmJiBtaW1lLmNvbXByZXNzaWJsZSAmJiAhcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddID8gcmVxdWVzdC5pbmZvLmFjY2VwdEVuY29kaW5nIDogbnVsbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdpZGVudGl0eScgfHwgIWVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgaGVhZGVyXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2VzID0gQW1tby5oZWFkZXIocmVxdWVzdC5oZWFkZXJzLnJhbmdlLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBCb29tLnJhbmdlTm90U2F0aXNmaWFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm91dHB1dC5oZWFkZXJzWydjb250ZW50LXJhbmdlJ10gPSAnYnl0ZXMgKi8nICsgbGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIHRyYW5zZm9ybVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAxKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHJlcXVlc3RzIGZvciBtdWx0aXBsZSByYW5nZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gcmFuZ2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuY29kZSgyMDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYnl0ZXMocmFuZ2UudG8gLSByYW5nZS5mcm9tICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXIoJ2NvbnRlbnQtcmFuZ2UnLCAnYnl0ZXMgJyArIHJhbmdlLmZyb20gKyAnLScgKyByYW5nZS50byArICcvJyArIGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXNwb25zZS5oZWFkZXIoJ2FjY2VwdC1yYW5nZXMnLCAnYnl0ZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuXG5cbmludGVybmFscy5jcmVhdGVTdHJlYW0gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIGNvbnN0IHNvdXJjZSA9IHJlc3BvbnNlLnNvdXJjZTtcblxuICAgIEhvZWsuYXNzZXJ0KHNvdXJjZS5maWxlICE9PSBudWxsKTtcblxuICAgIGNvbnN0IHJhbmdlID0gaW50ZXJuYWxzLmFkZENvbnRlbnRSYW5nZShyZXNwb25zZSk7XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBzdGFydDogc291cmNlLnNldHRpbmdzLnN0YXJ0IHx8IDAsXG4gICAgICAgIGVuZDogc291cmNlLnNldHRpbmdzLmVuZFxuICAgIH07XG5cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQgPSByYW5nZS50byArIG9wdGlvbnMuc3RhcnQ7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQgPSByYW5nZS5mcm9tICsgb3B0aW9ucy5zdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlLmZpbGUuY3JlYXRlUmVhZFN0cmVhbShvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLmNsb3NlID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cbiAgICBpZiAocmVzcG9uc2Uuc291cmNlLmZpbGUgIT09IG51bGwpIHtcbiAgICAgICAgcmVzcG9uc2Uuc291cmNlLmZpbGUuY2xvc2UoKTtcbiAgICAgICAgcmVzcG9uc2Uuc291cmNlLmZpbGUgPSBudWxsO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcHJvbWlzZWQ6IFsnb3BlbicsICdjbG9zZScsICdmc3RhdCcsICdyZWFkZGlyJ10sXG4gICAgICAgIHJhdzogWydjcmVhdGVSZWFkU3RyZWFtJ11cbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuRmlsZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuZmQgPSBudWxsO1xufTtcblxuXG5leHBvcnRzLkZpbGUucHJvdG90eXBlLm9wZW4gPSBhc3luYyBmdW5jdGlvbiAobW9kZSkge1xuXG4gICAgSG9lay5hc3NlcnQodGhpcy5mZCA9PT0gbnVsbCk7XG5cbiAgICB0cnkge1xuICAgICAgICB0aGlzLmZkID0gYXdhaXQgZXhwb3J0cy5vcGVuKHRoaXMucGF0aCwgbW9kZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgcGF0aDogdGhpcy5wYXRoIH07XG5cbiAgICAgICAgaWYgKHRoaXMucGF0aC5pbmRleE9mKCdcXHUwMDAwJykgIT09IC0xIHx8IGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5ub3RGb3VuZChudWxsLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VBQ0NFUycgfHwgZXJyLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgICAgIGRhdGEuY29kZSA9IGVyci5jb2RlO1xuICAgICAgICAgICAgdGhyb3cgQm9vbS5mb3JiaWRkZW4obnVsbCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBCb29tLmJvb21pZnkoZXJyLCB7IG1lc3NhZ2U6ICdGYWlsZWQgdG8gb3BlbiBmaWxlJywgZGF0YSB9KTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5mZCAhPT0gbnVsbCkge1xuICAgICAgICBCb3VuY2UuYmFja2dyb3VuZChleHBvcnRzLmNsb3NlKHRoaXMuZmQpKTtcbiAgICAgICAgdGhpcy5mZCA9IG51bGw7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLkZpbGUucHJvdG90eXBlLnN0YXQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLmZkICE9PSBudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBleHBvcnRzLmZzdGF0KHRoaXMuZmQpO1xuXG4gICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uZm9yYmlkZGVuKG51bGwsIHsgY29kZTogJ0VJU0RJUicsIHBhdGg6IHRoaXMucGF0aCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGF0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuY2xvc2UodGhpcy5mZCk7XG5cbiAgICAgICAgQm91bmNlLnJldGhyb3coZXJyLCBbJ2Jvb20nLCAnc3lzdGVtJ10pO1xuICAgICAgICB0aHJvdyBCb29tLmJvb21pZnkoZXJyLCB7IG1lc3NhZ2U6ICdGYWlsZWQgdG8gc3RhdCBmaWxlJywgZGF0YTogeyBwYXRoOiB0aGlzLnBhdGggfSB9KTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuRmlsZS5wcm90b3R5cGUub3BlblN0YXQgPSBhc3luYyBmdW5jdGlvbiAobW9kZSkge1xuXG4gICAgYXdhaXQgdGhpcy5vcGVuKG1vZGUpO1xuICAgIHJldHVybiB0aGlzLnN0YXQoKTtcbn07XG5cblxuZXhwb3J0cy5GaWxlLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIEhvZWsuYXNzZXJ0KHRoaXMuZmQgIT09IG51bGwpO1xuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBmZDogdGhpcy5mZCwgc3RhcnQ6IDAgfSwgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBzdHJlYW0gPSBleHBvcnRzLmNyZWF0ZVJlYWRTdHJlYW0odGhpcy5wYXRoLCBvcHRpb25zKTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9DbG9zZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5mZCA9IG51bGw7ICAgICAgICAgICAvLyBUaGUgc3RyZWFtIG5vdyBvd25zIHRoZSBmZFxuICAgIH1cblxuICAgIHJldHVybiBzdHJlYW07XG59O1xuXG5cbi8vIEV4cG9ydCBGcyBtZXRob2RzXG5cbmZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJuYWxzLm1ldGhvZHMucmF3Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgbWV0aG9kID0gaW50ZXJuYWxzLm1ldGhvZHMucmF3W2ldO1xuICAgIGV4cG9ydHNbbWV0aG9kXSA9IEZzW21ldGhvZF0uYmluZChGcyk7XG59XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgaW50ZXJuYWxzLm1ldGhvZHMucHJvbWlzZWQubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBtZXRob2QgPSBpbnRlcm5hbHMubWV0aG9kcy5wcm9taXNlZFtpXTtcbiAgICBleHBvcnRzW21ldGhvZF0gPSBVdGlsLnByb21pc2lmeShGc1ttZXRob2RdKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IEpvaSA9IHJlcXVpcmUoJ0BoYXBpL2pvaScpO1xuXG5jb25zdCBEaXJlY3RvcnkgPSByZXF1aXJlKCcuL2RpcmVjdG9yeScpO1xuY29uc3QgRXRhZyA9IHJlcXVpcmUoJy4vZXRhZycpO1xuY29uc3QgRmlsZSA9IHJlcXVpcmUoJy4vZmlsZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzY2hlbWE6IEpvaS5vYmplY3Qoe1xuICAgICAgICBldGFnc0NhY2hlTWF4U2l6ZTogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMCkuZGVmYXVsdCgxMDAwKVxuICAgIH0pLnJlcXVpcmVkKClcbn07XG5cblxuaW50ZXJuYWxzLmZpbGVNZXRob2QgPSBmdW5jdGlvbiAocGF0aCwgcmVzcG9uc2VPcHRpb25zKSB7XG5cbiAgICAvLyBTZXQgY29ycmVjdCBjb25maW5lIHZhbHVlXG5cbiAgICByZXNwb25zZU9wdGlvbnMgPSByZXNwb25zZU9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlT3B0aW9ucy5jb25maW5lID09PSAndW5kZWZpbmVkJyB8fCByZXNwb25zZU9wdGlvbnMuY29uZmluZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXNwb25zZU9wdGlvbnMuY29uZmluZSA9ICcuJztcbiAgICB9XG5cbiAgICBIb2VrLmFzc2VydChyZXNwb25zZU9wdGlvbnMuZW5kID09PSB1bmRlZmluZWQgfHwgK3Jlc3BvbnNlT3B0aW9ucy5zdGFydCA8PSArcmVzcG9uc2VPcHRpb25zLmVuZCwgJ29wdGlvbnMuc3RhcnQgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gb3B0aW9ucy5lbmQnKTtcblxuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlKEZpbGUucmVzcG9uc2UocGF0aCwgcmVzcG9uc2VPcHRpb25zLCB0aGlzLnJlcXVlc3QpKTtcbn07XG5cblxuZXhwb3J0cy5wbHVnaW4gPSB7XG4gICAgbmFtZTogJ2luZXJ0JyxcbiAgICBwa2c6IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLFxuICAgIG9uY2U6IHRydWUsXG4gICAgcmVxdWlyZW1lbnRzOiB7XG4gICAgICAgIGhhcGk6ICc+PTE3LjcuMCdcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXIoc2VydmVyLCBvcHRpb25zKSB7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoT2JqZWN0LmtleXMob3B0aW9ucykubGVuZ3RoID09PSAwLCAnSW5lcnQgZG9lcyBub3Qgc3VwcG9ydCByZWdpc3RyYXRpb24gb3B0aW9ucycpO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IEpvaS5hdHRlbXB0KEhvZWsucmVhY2goc2VydmVyLnNldHRpbmdzLnBsdWdpbnMsICdpbmVydCcpIHx8IHt9LCBpbnRlcm5hbHMuc2NoZW1hLCAnSW52YWxpZCBcImluZXJ0XCIgc2VydmVyIG9wdGlvbnMnKTtcblxuICAgICAgICBzZXJ2ZXIuZXhwb3NlKCdfZXRhZ3MnLCBzZXR0aW5ncy5ldGFnc0NhY2hlTWF4U2l6ZSA+IDAgPyBuZXcgRXRhZy5DYWNoZShzZXR0aW5ncy5ldGFnc0NhY2hlTWF4U2l6ZSkgOiBudWxsKTtcblxuICAgICAgICBzZXJ2ZXIuZGVjb3JhdGUoJ2hhbmRsZXInLCAnZmlsZScsIEZpbGUuaGFuZGxlcik7XG4gICAgICAgIHNlcnZlci5kZWNvcmF0ZSgnaGFuZGxlcicsICdkaXJlY3RvcnknLCBEaXJlY3RvcnkuaGFuZGxlcik7XG4gICAgICAgIHNlcnZlci5kZWNvcmF0ZSgndG9vbGtpdCcsICdmaWxlJywgaW50ZXJuYWxzLmZpbGVNZXRob2QpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBCNjQgPSByZXF1aXJlKCdAaGFwaS9iNjQnKTtcbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBCb3VybmUgPSByZXF1aXJlKCdAaGFwaS9ib3VybmUnKTtcbmNvbnN0IENyeXB0aWxlcyA9IHJlcXVpcmUoJ0BoYXBpL2NyeXB0aWxlcycpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmRlZmF1bHRzID0ge1xuICAgIGVuY3J5cHRpb246IHtcbiAgICAgICAgc2FsdEJpdHM6IDI1NixcbiAgICAgICAgYWxnb3JpdGhtOiAnYWVzLTI1Ni1jYmMnLFxuICAgICAgICBpdGVyYXRpb25zOiAxLFxuICAgICAgICBtaW5QYXNzd29yZGxlbmd0aDogMzJcbiAgICB9LFxuXG4gICAgaW50ZWdyaXR5OiB7XG4gICAgICAgIHNhbHRCaXRzOiAyNTYsXG4gICAgICAgIGFsZ29yaXRobTogJ3NoYTI1NicsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEsXG4gICAgICAgIG1pblBhc3N3b3JkbGVuZ3RoOiAzMlxuICAgIH0sXG5cbiAgICB0dGw6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzLCAwIG1lYW5zIGZvcmV2ZXJcbiAgICB0aW1lc3RhbXBTa2V3U2VjOiA2MCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kcyBvZiBwZXJtaXR0ZWQgY2xvY2sgc2tldyBmb3IgaW5jb21pbmcgZXhwaXJhdGlvbnNcbiAgICBsb2NhbHRpbWVPZmZzZXRNc2VjOiAwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9jYWwgY2xvY2sgdGltZSBvZmZzZXQgZXhwcmVzcyBpbiBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgKHBvc2l0aXZlIG9yIG5lZ2F0aXZlKVxufTtcblxuXG4vLyBBbGdvcml0aG0gY29uZmlndXJhdGlvblxuXG5leHBvcnRzLmFsZ29yaXRobXMgPSB7XG4gICAgJ2Flcy0xMjgtY3RyJzogeyBrZXlCaXRzOiAxMjgsIGl2Qml0czogMTI4IH0sXG4gICAgJ2Flcy0yNTYtY2JjJzogeyBrZXlCaXRzOiAyNTYsIGl2Qml0czogMTI4IH0sXG4gICAgJ3NoYTI1Nic6IHsga2V5Qml0czogMjU2IH1cbn07XG5cblxuLy8gTUFDIG5vcm1hbGl6YXRpb24gZm9ybWF0IHZlcnNpb25cblxuZXhwb3J0cy5tYWNGb3JtYXRWZXJzaW9uID0gJzInOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGNvbXBhcmlzb24gb2YgbWFjIHZhbHVlcyBnZW5lcmF0ZWQgd2l0aCBkaWZmZXJlbnQgbm9ybWFsaXplZCBzdHJpbmcgZm9ybWF0c1xuXG5leHBvcnRzLm1hY1ByZWZpeCA9ICdGZTI2LicgKyBleHBvcnRzLm1hY0Zvcm1hdFZlcnNpb247XG5cblxuLy8gR2VuZXJhdGUgYSB1bmlxdWUgZW5jcnlwdGlvbiBrZXlcblxuLypcbiAgICBjb25zdCBvcHRpb25zID0gIHtcbiAgICAgICAgc2FsdEJpdHM6IDI1NiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlZCBpZiBzYWx0IGlzIHNldFxuICAgICAgICBzYWx0OiAnNGQ4bnI5cTM4NG5yOXEzODRucjkzcThucnVxOTM0OHJ1bicsXG4gICAgICAgIGFsZ29yaXRobTogJ2Flcy0xMjgtY3RyJyxcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMDAsXG4gICAgICAgIGl2OiAnc2Rmc2Rmc2Rmc2Rmc2NkcmdlcmNnZXNyY2dzZXJjZycsICAgICAgICAgIC8vIE9wdGlvbmFsXG4gICAgICAgIG1pblBhc3N3b3JkbGVuZ3RoOiAzMlxuICAgIH07XG4qL1xuXG5leHBvcnRzLmdlbmVyYXRlS2V5ID0gYXN5bmMgZnVuY3Rpb24gKHBhc3N3b3JkLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgICAgIHRocm93IG5ldyBCb29tKCdFbXB0eSBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucyB8fFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcblxuICAgICAgICB0aHJvdyBuZXcgQm9vbSgnQmFkIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBleHBvcnRzLmFsZ29yaXRobXNbb3B0aW9ucy5hbGdvcml0aG1dO1xuICAgIGlmICghYWxnb3JpdGhtKSB7XG4gICAgICAgIHRocm93IG5ldyBCb29tKCdVbmtub3duIGFsZ29yaXRobTogJyArIG9wdGlvbnMuYWxnb3JpdGhtKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGFzc3dvcmQpKSB7XG4gICAgICAgIGlmIChwYXNzd29yZC5sZW5ndGggPCBhbGdvcml0aG0ua2V5Qml0cyAvIDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb29tKCdLZXkgYnVmZmVyIChwYXNzd29yZCkgdG9vIHNtYWxsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQua2V5ID0gcGFzc3dvcmQ7XG4gICAgICAgIHJlc3VsdC5zYWx0ID0gJyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocGFzc3dvcmQubGVuZ3RoIDwgb3B0aW9ucy5taW5QYXNzd29yZGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvb20oJ1Bhc3N3b3JkIHN0cmluZyB0b28gc2hvcnQgKG1pbiAnICsgb3B0aW9ucy5taW5QYXNzd29yZGxlbmd0aCArICcgY2hhcmFjdGVycyByZXF1aXJlZCknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzYWx0ID0gb3B0aW9ucy5zYWx0O1xuICAgICAgICBpZiAoIXNhbHQpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5zYWx0Qml0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb29tKCdNaXNzaW5nIHNhbHQgYW5kIHNhbHRCaXRzIG9wdGlvbnMnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmFuZG9tU2FsdCA9IENyeXB0aWxlcy5yYW5kb21CaXRzKG9wdGlvbnMuc2FsdEJpdHMpO1xuICAgICAgICAgICAgc2FsdCA9IHJhbmRvbVNhbHQudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IGF3YWl0IGludGVybmFscy5wYmtkZjIocGFzc3dvcmQsIHNhbHQsIG9wdGlvbnMuaXRlcmF0aW9ucywgYWxnb3JpdGhtLmtleUJpdHMgLyA4LCAnc2hhMScpO1xuXG4gICAgICAgIHJlc3VsdC5rZXkgPSBkZXJpdmVkS2V5O1xuICAgICAgICByZXN1bHQuc2FsdCA9IHNhbHQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaXYpIHtcbiAgICAgICAgcmVzdWx0Lml2ID0gb3B0aW9ucy5pdjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxnb3JpdGhtLml2Qml0cykge1xuICAgICAgICByZXN1bHQuaXYgPSBDcnlwdGlsZXMucmFuZG9tQml0cyhhbGdvcml0aG0uaXZCaXRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vLyBFbmNyeXB0IGRhdGFcbi8vIG9wdGlvbnM6IHNlZSBleHBvcnRzLmdlbmVyYXRlS2V5KClcblxuZXhwb3J0cy5lbmNyeXB0ID0gYXN5bmMgZnVuY3Rpb24gKHBhc3N3b3JkLCBvcHRpb25zLCBkYXRhKSB7XG5cbiAgICBjb25zdCBrZXkgPSBhd2FpdCBleHBvcnRzLmdlbmVyYXRlS2V5KHBhc3N3b3JkLCBvcHRpb25zKTtcbiAgICBjb25zdCBjaXBoZXIgPSBDcnlwdG8uY3JlYXRlQ2lwaGVyaXYob3B0aW9ucy5hbGdvcml0aG0sIGtleS5rZXksIGtleS5pdik7XG4gICAgY29uc3QgZW5jcnlwdGVkID0gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhLCAndXRmOCcpLCBjaXBoZXIuZmluYWwoKV0pO1xuXG4gICAgcmV0dXJuIHsgZW5jcnlwdGVkLCBrZXkgfTtcbn07XG5cblxuLy8gRGVjcnlwdCBkYXRhXG4vLyBvcHRpb25zOiBzZWUgZXhwb3J0cy5nZW5lcmF0ZUtleSgpXG5cbmV4cG9ydHMuZGVjcnlwdCA9IGFzeW5jIGZ1bmN0aW9uIChwYXNzd29yZCwgb3B0aW9ucywgZGF0YSkge1xuXG4gICAgY29uc3Qga2V5ID0gYXdhaXQgZXhwb3J0cy5nZW5lcmF0ZUtleShwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGVjaXBoZXIgPSBDcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihvcHRpb25zLmFsZ29yaXRobSwga2V5LmtleSwga2V5Lml2KTtcbiAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEsIG51bGwsICd1dGY4Jyk7XG4gICAgZGVjID0gZGVjICsgZGVjaXBoZXIuZmluYWwoJ3V0ZjgnKTtcblxuICAgIHJldHVybiBkZWM7XG59O1xuXG5cbi8vIEhNQUMgdXNpbmcgYSBwYXNzd29yZFxuLy8gb3B0aW9uczogc2VlIGV4cG9ydHMuZ2VuZXJhdGVLZXkoKVxuXG5leHBvcnRzLmhtYWNXaXRoUGFzc3dvcmQgPSBhc3luYyBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdGlvbnMsIGRhdGEpIHtcblxuICAgIGNvbnN0IGtleSA9IGF3YWl0IGV4cG9ydHMuZ2VuZXJhdGVLZXkocGFzc3dvcmQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGhtYWMgPSBDcnlwdG8uY3JlYXRlSG1hYyhvcHRpb25zLmFsZ29yaXRobSwga2V5LmtleSkudXBkYXRlKGRhdGEpO1xuICAgIGNvbnN0IGRpZ2VzdCA9IGhtYWMuZGlnZXN0KCdiYXNlNjQnKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXD0vZywgJycpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlnZXN0LFxuICAgICAgICBzYWx0OiBrZXkuc2FsdFxuICAgIH07XG59O1xuXG5cbi8vIE5vcm1hbGl6ZXMgYSBwYXNzd29yZCBwYXJhbWV0ZXIgaW50byBhIHsgaWQsIGVuY3J5cHRpb24sIGludGVncml0eSB9IG9iamVjdFxuLy8gcGFzc3dvcmQ6IHN0cmluZywgYnVmZmVyIG9yIG9iamVjdCB3aXRoIHsgaWQsIHNlY3JldCB9IG9yIHsgaWQsIGVuY3J5cHRpb24sIGludGVncml0eSB9XG5cbmludGVybmFscy5ub3JtYWxpemVQYXNzd29yZCA9IGZ1bmN0aW9uIChwYXNzd29yZCkge1xuXG4gICAgaWYgKHBhc3N3b3JkICYmXG4gICAgICAgIHR5cGVvZiBwYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihwYXNzd29yZCkpIHtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHBhc3N3b3JkLmlkLFxuICAgICAgICAgICAgZW5jcnlwdGlvbjogcGFzc3dvcmQuc2VjcmV0IHx8IHBhc3N3b3JkLmVuY3J5cHRpb24sXG4gICAgICAgICAgICBpbnRlZ3JpdHk6IHBhc3N3b3JkLnNlY3JldCB8fCBwYXNzd29yZC5pbnRlZ3JpdHlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0aW9uOiBwYXNzd29yZCxcbiAgICAgICAgaW50ZWdyaXR5OiBwYXNzd29yZFxuICAgIH07XG59O1xuXG5cbi8vIEVuY3J5cHQgYW5kIEhNQUMgYW4gb2JqZWN0XG4vLyBwYXNzd29yZDogc3RyaW5nLCBidWZmZXIgb3Igb2JqZWN0IHdpdGggeyBpZCwgc2VjcmV0IH0gb3IgeyBpZCwgZW5jcnlwdGlvbiwgaW50ZWdyaXR5IH1cbi8vIG9wdGlvbnM6IHNlZSBleHBvcnRzLmRlZmF1bHRzXG5cbmV4cG9ydHMuc2VhbCA9IGFzeW5jIGZ1bmN0aW9uIChvYmplY3QsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG5cbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgIC8vIFNoYWxsb3cgY2xvbmVkIHRvIHByZXZlbnQgY2hhbmdlcyBkdXJpbmcgYXN5bmMgb3BlcmF0aW9uc1xuXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKSArIChvcHRpb25zLmxvY2FsdGltZU9mZnNldE1zZWMgfHwgMCk7ICAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIG5vdyBiZWZvcmUgYW55IG90aGVyIHByb2Nlc3NpbmdcblxuICAgIC8vIFNlcmlhbGl6ZSBvYmplY3RcblxuICAgIGNvbnN0IG9iamVjdFN0cmluZyA9IGludGVybmFscy5zdHJpbmdpZnkob2JqZWN0KTtcblxuICAgIC8vIE9idGFpbiBwYXNzd29yZFxuXG4gICAgbGV0IHBhc3N3b3JkSWQgPSAnJztcbiAgICBwYXNzd29yZCA9IGludGVybmFscy5ub3JtYWxpemVQYXNzd29yZChwYXNzd29yZCk7XG4gICAgaWYgKHBhc3N3b3JkLmlkKSB7XG4gICAgICAgIGlmICghL15cXHcrJC8udGVzdChwYXNzd29yZC5pZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb29tKCdJbnZhbGlkIHBhc3N3b3JkIGlkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXNzd29yZElkID0gcGFzc3dvcmQuaWQ7XG4gICAgfVxuXG4gICAgLy8gRW5jcnlwdCBvYmplY3Qgc3RyaW5nXG5cbiAgICBjb25zdCB7IGVuY3J5cHRlZCwga2V5IH0gPSBhd2FpdCBleHBvcnRzLmVuY3J5cHQocGFzc3dvcmQuZW5jcnlwdGlvbiwgb3B0aW9ucy5lbmNyeXB0aW9uLCBvYmplY3RTdHJpbmcpO1xuXG4gICAgLy8gQmFzZTY0dXJsIHRoZSBlbmNyeXB0ZWQgdmFsdWVcblxuICAgIGNvbnN0IGVuY3J5cHRlZEI2NCA9IEI2NC5iYXNlNjR1cmxFbmNvZGUoZW5jcnlwdGVkKTtcbiAgICBjb25zdCBpdiA9IEI2NC5iYXNlNjR1cmxFbmNvZGUoa2V5Lml2KTtcbiAgICBjb25zdCBleHBpcmF0aW9uID0gKG9wdGlvbnMudHRsID8gbm93ICsgb3B0aW9ucy50dGwgOiAnJyk7XG4gICAgY29uc3QgbWFjQmFzZVN0cmluZyA9IGV4cG9ydHMubWFjUHJlZml4ICsgJyonICsgcGFzc3dvcmRJZCArICcqJyArIGtleS5zYWx0ICsgJyonICsgaXYgKyAnKicgKyBlbmNyeXB0ZWRCNjQgKyAnKicgKyBleHBpcmF0aW9uO1xuXG4gICAgLy8gTWFjIHRoZSBjb21iaW5lZCB2YWx1ZXNcblxuICAgIGNvbnN0IG1hYyA9IGF3YWl0IGV4cG9ydHMuaG1hY1dpdGhQYXNzd29yZChwYXNzd29yZC5pbnRlZ3JpdHksIG9wdGlvbnMuaW50ZWdyaXR5LCBtYWNCYXNlU3RyaW5nKTtcblxuICAgIC8vIFB1dCBpdCBhbGwgdG9nZXRoZXJcblxuICAgIC8vIHByZWZpeCpbcGFzc3dvcmQtaWRdKmVuY3J5cHRpb24tc2FsdCplbmNyeXB0aW9uLWl2KmVuY3J5cHRlZCpbZXhwaXJhdGlvbl0qaG1hYy1zYWx0KmhtYWNcbiAgICAvLyBBbGxvd2VkIFVSSSBxdWVyeSBuYW1lL3ZhbHVlIGNoYXJhY3RlcnM6ICotLiBcXGQgXFx3XG5cbiAgICBjb25zdCBzZWFsZWQgPSBtYWNCYXNlU3RyaW5nICsgJyonICsgbWFjLnNhbHQgKyAnKicgKyBtYWMuZGlnZXN0O1xuICAgIHJldHVybiBzZWFsZWQ7XG59O1xuXG5cbi8vIERlY3J5cHQgYW5kIHZhbGlkYXRlIHNlYWxlZCBzdHJpbmdcbi8vIHBhc3N3b3JkOiBzdHJpbmcsIGJ1ZmZlciBvciBvYmplY3Qgd2l0aCB7IGlkOiBzZWNyZXQgfSBvciB7IGlkOiB7IGVuY3J5cHRpb24sIGludGVncml0eSB9IH1cbi8vIG9wdGlvbnM6IHNlZSBleHBvcnRzLmRlZmF1bHRzXG5cbmV4cG9ydHMudW5zZWFsID0gYXN5bmMgZnVuY3Rpb24gKHNlYWxlZCwgcGFzc3dvcmQsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFsbG93IGNsb25lZCB0byBwcmV2ZW50IGNoYW5nZXMgZHVyaW5nIGFzeW5jIG9wZXJhdGlvbnNcblxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCkgKyAob3B0aW9ucy5sb2NhbHRpbWVPZmZzZXRNc2VjIHx8IDApOyAgICAgICAgICAgICAgICAvLyBNZWFzdXJlIG5vdyBiZWZvcmUgYW55IG90aGVyIHByb2Nlc3NpbmdcblxuICAgIC8vIEJyZWFrIHN0cmluZyBpbnRvIGNvbXBvbmVudHNcblxuICAgIGNvbnN0IHBhcnRzID0gc2VhbGVkLnNwbGl0KCcqJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gOCkge1xuICAgICAgICB0aHJvdyBuZXcgQm9vbSgnSW5jb3JyZWN0IG51bWJlciBvZiBzZWFsZWQgY29tcG9uZW50cycpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hY1ByZWZpeCA9IHBhcnRzWzBdO1xuICAgIGNvbnN0IHBhc3N3b3JkSWQgPSBwYXJ0c1sxXTtcbiAgICBjb25zdCBlbmNyeXB0aW9uU2FsdCA9IHBhcnRzWzJdO1xuICAgIGNvbnN0IGVuY3J5cHRpb25JdiA9IHBhcnRzWzNdO1xuICAgIGNvbnN0IGVuY3J5cHRlZEI2NCA9IHBhcnRzWzRdO1xuICAgIGNvbnN0IGV4cGlyYXRpb24gPSBwYXJ0c1s1XTtcbiAgICBjb25zdCBobWFjU2FsdCA9IHBhcnRzWzZdO1xuICAgIGNvbnN0IGhtYWMgPSBwYXJ0c1s3XTtcbiAgICBjb25zdCBtYWNCYXNlU3RyaW5nID0gbWFjUHJlZml4ICsgJyonICsgcGFzc3dvcmRJZCArICcqJyArIGVuY3J5cHRpb25TYWx0ICsgJyonICsgZW5jcnlwdGlvbkl2ICsgJyonICsgZW5jcnlwdGVkQjY0ICsgJyonICsgZXhwaXJhdGlvbjtcblxuICAgIC8vIENoZWNrIHByZWZpeFxuXG4gICAgaWYgKG1hY1ByZWZpeCAhPT0gZXhwb3J0cy5tYWNQcmVmaXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvb20oJ1dyb25nIG1hYyBwcmVmaXgnKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBleHBpcmF0aW9uXG5cbiAgICBpZiAoZXhwaXJhdGlvbikge1xuICAgICAgICBpZiAoIWV4cGlyYXRpb24ubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnSW52YWxpZCBleHBpcmF0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHAgPSBwYXJzZUludChleHBpcmF0aW9uLCAxMCk7XG4gICAgICAgIGlmIChleHAgPD0gKG5vdyAtIChvcHRpb25zLnRpbWVzdGFtcFNrZXdTZWMgKiAxMDAwKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb29tKCdFeHBpcmVkIHNlYWwnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9idGFpbiBwYXNzd29yZFxuXG4gICAgaWYgKCFwYXNzd29yZCkge1xuICAgICAgICB0aHJvdyBuZXcgQm9vbSgnRW1wdHkgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhQnVmZmVyLmlzQnVmZmVyKHBhc3N3b3JkKSkge1xuXG4gICAgICAgIHBhc3N3b3JkID0gcGFzc3dvcmRbcGFzc3dvcmRJZCB8fCAnZGVmYXVsdCddO1xuICAgICAgICBpZiAoIXBhc3N3b3JkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9vbSgnQ2Fubm90IGZpbmQgcGFzc3dvcmQ6ICcgKyBwYXNzd29yZElkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhc3N3b3JkID0gaW50ZXJuYWxzLm5vcm1hbGl6ZVBhc3N3b3JkKHBhc3N3b3JkKTtcblxuICAgIC8vIENoZWNrIGhtYWNcblxuICAgIGNvbnN0IG1hY09wdGlvbnMgPSBIb2VrLmNsb25lKG9wdGlvbnMuaW50ZWdyaXR5KTtcbiAgICBtYWNPcHRpb25zLnNhbHQgPSBobWFjU2FsdDtcbiAgICBjb25zdCBtYWMgPSBhd2FpdCBleHBvcnRzLmhtYWNXaXRoUGFzc3dvcmQocGFzc3dvcmQuaW50ZWdyaXR5LCBtYWNPcHRpb25zLCBtYWNCYXNlU3RyaW5nKTtcblxuICAgIGlmICghQ3J5cHRpbGVzLmZpeGVkVGltZUNvbXBhcmlzb24obWFjLmRpZ2VzdCwgaG1hYykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvb20oJ0JhZCBobWFjIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgLy8gRGVjcnlwdFxuXG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGVuY3J5cHRlZCA9IEI2NC5iYXNlNjR1cmxEZWNvZGUoZW5jcnlwdGVkQjY0LCAnYnVmZmVyJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5ib29taWZ5KGVycik7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjcnlwdE9wdGlvbnMgPSBIb2VrLmNsb25lKG9wdGlvbnMuZW5jcnlwdGlvbik7XG4gICAgZGVjcnlwdE9wdGlvbnMuc2FsdCA9IGVuY3J5cHRpb25TYWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZGVjcnlwdE9wdGlvbnMuaXYgPSBCNjQuYmFzZTY0dXJsRGVjb2RlKGVuY3J5cHRpb25JdiwgJ2J1ZmZlcicpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IEJvb20uYm9vbWlmeShlcnIpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY3J5cHRlZCA9IGF3YWl0IGV4cG9ydHMuZGVjcnlwdChwYXNzd29yZC5lbmNyeXB0aW9uLCBkZWNyeXB0T3B0aW9ucywgZW5jcnlwdGVkKTtcblxuICAgIC8vIFBhcnNlIEpTT05cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBCb3VybmUucGFyc2UoZGVjcnlwdGVkKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgQm9vbSgnRmFpbGVkIHBhcnNpbmcgc2VhbGVkIG9iamVjdCBKU09OOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmplY3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBCb29tKCdGYWlsZWQgdG8gc3RyaW5naWZ5IG9iamVjdDogJyArIGVyci5tZXNzYWdlKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5wYmtkZjIgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICBjb25zdCBuZXh0ID0gKGVyciwgcmVzdWx0KSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KEJvb20uYm9vbWlmeShlcnIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFyZ3MucHVzaChuZXh0KTtcbiAgICAgICAgQ3J5cHRvLnBia2RmMiguLi5hcmdzKTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBNZXJnZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL21lcmdlJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcbmNvbnN0IE1vZGlmeSA9IHJlcXVpcmUoJy4vbW9kaWZ5Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVHJhY2UgPSByZXF1aXJlKCcuL3RyYWNlJyk7XG5jb25zdCBWYWxpZGF0b3IgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcicpO1xuY29uc3QgVmFsdWVzID0gcmVxdWlyZSgnLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuQmFzZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcblxuICAgICAgICAvLyBOYW1pbmc6IHB1YmxpYywgX3ByaXZhdGUsICRfZXh0ZW5zaW9uLCAkX211dGF0ZXthY3Rpb259XG5cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgICAgICB0aGlzLiRfcm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSB7fTtcbiAgICAgICAgdGhpcy5faWRzID0gbmV3IE1vZGlmeS5JZHMoKTtcbiAgICAgICAgdGhpcy5fcHJlZmVyZW5jZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWZzID0gbmV3IFJlZi5NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl92YWxpZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9pbnZhbGlkcyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fc2luZ2xlUnVsZXMgPSBuZXcgTWFwKCk7ICAgICAgICAgICAgICAvLyBUaGUgcnVsZSBvcHRpb25zIHBhc3NlZCBmb3Igbm9uLW11bHRpIHJ1bGVzXG5cbiAgICAgICAgdGhpcy4kX3Rlcm1zID0ge307ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYXNoIG9mIGFycmF5cyBvZiBpbW11dGFibGUgb2JqZWN0cyAoZXh0ZW5kZWQgYnkgb3RoZXIgdHlwZXMpXG5cbiAgICAgICAgdGhpcy4kX3RlbXAgPSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIHN0YXRlIChub3QgY2xvbmVkKVxuICAgICAgICAgICAgcnVsZXNldDogbnVsbCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG51bGw6IHVzZSBsYXN0LCBmYWxzZTogZXJyb3IsIG51bWJlcjogc3RhcnQgcG9zaXRpb25cbiAgICAgICAgICAgIHdoZW5zOiB7fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSdW50aW1lIGNhY2hlIG9mIGdlbmVyYXRlZCB3aGVuc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmRlc2NyaWJlID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuZGVzY3JpYmUodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZXNcblxuICAgIGFsbG93KC4uLnZhbHVlcykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZXModmFsdWVzLCAnX3ZhbGlkcycpO1xuICAgIH1cblxuICAgIGFsdGVyKHRhcmdldHMpIHtcblxuICAgICAgICBBc3NlcnQodGFyZ2V0cyAmJiB0eXBlb2YgdGFyZ2V0cyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0cyksICdJbnZhbGlkIHRhcmdldHMgYXJndW1lbnQnKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgYWx0ZXJhdGlvbnMgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgb2JqLiRfdGVybXMuYWx0ZXJhdGlvbnMgPSBvYmouJF90ZXJtcy5hbHRlcmF0aW9ucyB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgaW4gdGFyZ2V0cykge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZXIgPSB0YXJnZXRzW3RhcmdldF07XG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGFkanVzdGVyID09PSAnZnVuY3Rpb24nLCAnQWx0ZXJhdGlvbiBhZGp1c3RlciBmb3InLCB0YXJnZXQsICdtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLmFsdGVyYXRpb25zLnB1c2goeyB0YXJnZXQsIGFkanVzdGVyIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgY2FzdCh0bykge1xuXG4gICAgICAgIEFzc2VydCh0byA9PT0gZmFsc2UgfHwgdHlwZW9mIHRvID09PSAnc3RyaW5nJywgJ0ludmFsaWQgdG8gdmFsdWUnKTtcbiAgICAgICAgQXNzZXJ0KHRvID09PSBmYWxzZSB8fCB0aGlzLl9kZWZpbml0aW9uLmNhc3RbdG9dLCAnVHlwZScsIHRoaXMudHlwZSwgJ2RvZXMgbm90IHN1cHBvcnQgY2FzdGluZyB0bycsIHRvKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Nhc3QnLCB0byA9PT0gZmFsc2UgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgfVxuXG4gICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGRlc2NyaXB0aW9uKGRlc2MpIHtcblxuICAgICAgICBBc3NlcnQoZGVzYyAmJiB0eXBlb2YgZGVzYyA9PT0gJ3N0cmluZycsICdEZXNjcmlwdGlvbiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZGVzY3JpcHRpb24nLCBkZXNjKTtcbiAgICB9XG5cbiAgICBlbXB0eShzY2hlbWEpIHtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBvYmouJF9jb21waWxlKHNjaGVtYSwgeyBvdmVycmlkZTogZmFsc2UgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqLiRfc2V0RmxhZygnZW1wdHknLCBzY2hlbWEsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGVycm9yKGVycikge1xuXG4gICAgICAgIEFzc2VydChlcnIsICdNaXNzaW5nIGVycm9yJyk7XG4gICAgICAgIEFzc2VydChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nLCAnTXVzdCBwcm92aWRlIGEgdmFsaWQgRXJyb3Igb2JqZWN0IG9yIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG5cbiAgICBleGFtcGxlKGV4YW1wbGUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydChleGFtcGxlICE9PSB1bmRlZmluZWQsICdNaXNzaW5nIGV4YW1wbGUnKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydvdmVycmlkZSddKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ2V4YW1wbGVzJywgZXhhbXBsZSwgeyBzaW5nbGU6IHRydWUsIG92ZXJyaWRlOiBvcHRpb25zLm92ZXJyaWRlIH0pO1xuICAgIH1cblxuICAgIGV4dGVybmFsKG1ldGhvZCwgZGVzY3JpcHRpb24pIHtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIEFzc2VydCghZGVzY3JpcHRpb24sICdDYW5ub3QgY29tYmluZSBvcHRpb25zIHdpdGggZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gbWV0aG9kLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kLm1ldGhvZDtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nLCAnTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBBc3NlcnQoZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCB8fCBkZXNjcmlwdGlvbiAmJiB0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdzdHJpbmcnLCAnRGVzY3JpcHRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5faW5uZXIoJ2V4dGVybmFscycsIHsgbWV0aG9kLCBkZXNjcmlwdGlvbiB9LCB7IHNpbmdsZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICBmYWlsb3Zlcih2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0KCdmYWlsb3ZlcicsIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3JiaWRkZW4oKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2UoJ2ZvcmJpZGRlbicpO1xuICAgIH1cblxuICAgIGlkKGlkKSB7XG5cbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpZCcsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIGlkID09PSAnc3RyaW5nJywgJ2lkIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICAgIEFzc2VydCgvXlteXFwuXSskLy50ZXN0KGlkKSwgJ2lkIGNhbm5vdCBjb250YWluIHBlcmlvZCBjaGFyYWN0ZXInKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ2lkJywgaWQpO1xuICAgIH1cblxuICAgIGludmFsaWQoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcyh2YWx1ZXMsICdfaW52YWxpZHMnKTtcbiAgICB9XG5cbiAgICBsYWJlbChuYW1lKSB7XG5cbiAgICAgICAgQXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnTGFiZWwgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnbGFiZWwnLCBuYW1lKTtcbiAgICB9XG5cbiAgICBtZXRhKG1ldGEpIHtcblxuICAgICAgICBBc3NlcnQobWV0YSAhPT0gdW5kZWZpbmVkLCAnTWV0YSBjYW5ub3QgYmUgdW5kZWZpbmVkJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lubmVyKCdtZXRhcycsIG1ldGEsIHsgc2luZ2xlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIG5vdGUoLi4ubm90ZXMpIHtcblxuICAgICAgICBBc3NlcnQobm90ZXMubGVuZ3RoLCAnTWlzc2luZyBub3RlcycpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vdGUgb2Ygbm90ZXMpIHtcbiAgICAgICAgICAgIEFzc2VydChub3RlICYmIHR5cGVvZiBub3RlID09PSAnc3RyaW5nJywgJ05vdGVzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcignbm90ZXMnLCBub3Rlcyk7XG4gICAgfVxuXG4gICAgb25seShtb2RlID0gdHJ1ZSkge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbW9kZSA9PT0gJ2Jvb2xlYW4nLCAnSW52YWxpZCBtb2RlOicsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnb25seScsIG1vZGUpO1xuICAgIH1cblxuICAgIG9wdGlvbmFsKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdvcHRpb25hbCcpO1xuICAgIH1cblxuICAgIHByZWZzKHByZWZzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHByZWZzLCAnTWlzc2luZyBwcmVmZXJlbmNlcycpO1xuICAgICAgICBBc3NlcnQocHJlZnMuY29udGV4dCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGNvbnRleHQnKTtcbiAgICAgICAgQXNzZXJ0KHByZWZzLmV4dGVybmFscyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IG92ZXJyaWRlIGV4dGVybmFscycpO1xuICAgICAgICBBc3NlcnQocHJlZnMud2FybmluZ3MgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSB3YXJuaW5ncycpO1xuICAgICAgICBBc3NlcnQocHJlZnMuZGVidWcgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSBkZWJ1ZycpO1xuXG4gICAgICAgIENvbW1vbi5jaGVja1ByZWZlcmVuY2VzKHByZWZzKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai5fcHJlZmVyZW5jZXMgPSBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgcHJlZnMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHByZXNlbmNlKG1vZGUpIHtcblxuICAgICAgICBBc3NlcnQoWydvcHRpb25hbCcsICdyZXF1aXJlZCcsICdmb3JiaWRkZW4nXS5pbmNsdWRlcyhtb2RlKSwgJ1Vua25vd24gcHJlc2VuY2UgbW9kZScsIG1vZGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncHJlc2VuY2UnLCBtb2RlKTtcbiAgICB9XG5cbiAgICByYXcoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIGVuYWJsZWQgPyAncmF3JyA6IHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmVzdWx0KG1vZGUpIHtcblxuICAgICAgICBBc3NlcnQoWydyYXcnLCAnc3RyaXAnXS5pbmNsdWRlcyhtb2RlKSwgJ1Vua25vd24gcmVzdWx0IG1vZGUnLCBtb2RlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3Jlc3VsdCcsIG1vZGUpO1xuICAgIH1cblxuICAgIHJlcXVpcmVkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByZXNlbmNlKCdyZXF1aXJlZCcpO1xuICAgIH1cblxuICAgIHN0cmljdChlbmFibGVkKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGNvbnN0IGNvbnZlcnQgPSBlbmFibGVkID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFlbmFibGVkO1xuICAgICAgICBvYmouX3ByZWZlcmVuY2VzID0gQ29tbW9uLnByZWZlcmVuY2VzKG9iai5fcHJlZmVyZW5jZXMsIHsgY29udmVydCB9KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBzdHJpcChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVzdWx0JywgZW5hYmxlZCA/ICdzdHJpcCcgOiB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHRhZyguLi50YWdzKSB7XG5cbiAgICAgICAgQXNzZXJ0KHRhZ3MubGVuZ3RoLCAnTWlzc2luZyB0YWdzJyk7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIEFzc2VydCh0YWcgJiYgdHlwZW9mIHRhZyA9PT0gJ3N0cmluZycsICdUYWdzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbm5lcigndGFncycsIHRhZ3MpO1xuICAgIH1cblxuICAgIHVuaXQobmFtZSkge1xuXG4gICAgICAgIEFzc2VydChuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJywgJ1VuaXQgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5pdCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhbGlkKC4uLnZhbHVlcykge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuYWxsb3coLi4udmFsdWVzKTtcbiAgICAgICAgb2JqLiRfc2V0RmxhZygnb25seScsICEhb2JqLl92YWxpZHMsIHsgY2xvbmU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHdoZW4oY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmICghb2JqLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3aGVuID0gQ29tcGlsZS53aGVuKG9iaiwgY29uZGl0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFbJ2FueScsICdsaW5rJ10uaW5jbHVkZXMob2JqLnR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gd2hlbi5pcyA/IFt3aGVuXSA6IHdoZW4uc3dpdGNoO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIWl0ZW0udGhlbiB8fCBpdGVtLnRoZW4udHlwZSA9PT0gJ2FueScgfHwgaXRlbS50aGVuLnR5cGUgPT09IG9iai50eXBlLCAnQ2Fubm90IGNvbWJpbmUnLCBvYmoudHlwZSwgJ3dpdGgnLCBpdGVtLnRoZW4gJiYgaXRlbS50aGVuLnR5cGUpO1xuICAgICAgICAgICAgICAgIEFzc2VydCghaXRlbS5vdGhlcndpc2UgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gJ2FueScgfHwgaXRlbS5vdGhlcndpc2UudHlwZSA9PT0gb2JqLnR5cGUsICdDYW5ub3QgY29tYmluZScsIG9iai50eXBlLCAnd2l0aCcsIGl0ZW0ub3RoZXJ3aXNlICYmIGl0ZW0ub3RoZXJ3aXNlLnR5cGUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZXJtcy53aGVucy5wdXNoKHdoZW4pO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIC8vIEhlbHBlcnNcblxuICAgIGNhY2hlKGNhY2hlKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgY2FjaGluZyBpbnNpZGUgYSBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghdGhpcy5fY2FjaGUsICdDYW5ub3Qgb3ZlcnJpZGUgc2NoZW1hIGNhY2hlJyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBvYmouX2NhY2hlID0gY2FjaGUgfHwgQ2FjaGUucHJvdmlkZXIucHJvdmlzaW9uKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Fzc2lnbihvYmopO1xuICAgIH1cblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBBc3NlcnQoQ29tbW9uLmlzU2NoZW1hKHNvdXJjZSksICdJbnZhbGlkIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgQXNzZXJ0KHRoaXMudHlwZSA9PT0gJ2FueScgfHwgc291cmNlLnR5cGUgPT09ICdhbnknIHx8IHNvdXJjZS50eXBlID09PSB0aGlzLnR5cGUsICdDYW5ub3QgbWVyZ2UgdHlwZScsIHRoaXMudHlwZSwgJ3dpdGggYW5vdGhlciB0eXBlOicsIHNvdXJjZS50eXBlKTtcbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBvbnRvIGEgc2NoZW1hIHdpdGggb3BlbiBydWxlc2V0Jyk7XG4gICAgICAgIEFzc2VydCghc291cmNlLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBjb25jYXRlbmF0ZSBhIHNjaGVtYSB3aXRoIG9wZW4gcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2FueScgJiZcbiAgICAgICAgICAgIHNvdXJjZS50eXBlICE9PSAnYW55Jykge1xuXG4gICAgICAgICAgICAvLyBDaGFuZ2Ugb2JqIHRvIG1hdGNoIHNvdXJjZSB0eXBlXG5cbiAgICAgICAgICAgIGNvbnN0IHRtcE9iaiA9IHNvdXJjZS5jbG9uZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJykge1xuICAgICAgICAgICAgICAgICAgICB0bXBPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqID0gdG1wT2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqLl9pZHMuY29uY2F0KHNvdXJjZS5faWRzKTtcbiAgICAgICAgb2JqLl9yZWZzLnJlZ2lzdGVyKHNvdXJjZSwgUmVmLnRvU2libGluZyk7XG5cbiAgICAgICAgb2JqLl9wcmVmZXJlbmNlcyA9IG9iai5fcHJlZmVyZW5jZXMgPyBDb21tb24ucHJlZmVyZW5jZXMob2JqLl9wcmVmZXJlbmNlcywgc291cmNlLl9wcmVmZXJlbmNlcykgOiBzb3VyY2UuX3ByZWZlcmVuY2VzO1xuICAgICAgICBvYmouX3ZhbGlkcyA9IFZhbHVlcy5tZXJnZShvYmouX3ZhbGlkcywgc291cmNlLl92YWxpZHMsIHNvdXJjZS5faW52YWxpZHMpO1xuICAgICAgICBvYmouX2ludmFsaWRzID0gVmFsdWVzLm1lcmdlKG9iai5faW52YWxpZHMsIHNvdXJjZS5faW52YWxpZHMsIHNvdXJjZS5fdmFsaWRzKTtcblxuICAgICAgICAvLyBSZW1vdmUgdW5pcXVlIHJ1bGVzIHByZXNlbnQgaW4gc291cmNlXG5cbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHNvdXJjZS5fc2luZ2xlUnVsZXMua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAob2JqLl9zaW5nbGVSdWxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvYmouX3J1bGVzID0gb2JqLl9ydWxlcy5maWx0ZXIoKHRhcmdldCkgPT4gdGFyZ2V0LmtlZXAgfHwgdGFyZ2V0Lm5hbWUgIT09IG5hbWUpO1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZXNcblxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2Ygc291cmNlLl9ydWxlcykge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX2RlZmluaXRpb24ucnVsZXNbdGVzdC5tZXRob2RdLm11bHRpKSB7XG4gICAgICAgICAgICAgICAgb2JqLl9zaW5nbGVSdWxlcy5zZXQodGVzdC5uYW1lLCB0ZXN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlcy5wdXNoKHRlc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmxhZ3NcblxuICAgICAgICBpZiAob2JqLl9mbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgc291cmNlLl9mbGFncy5lbXB0eSkge1xuXG4gICAgICAgICAgICBvYmouX2ZsYWdzLmVtcHR5ID0gb2JqLl9mbGFncy5lbXB0eS5jb25jYXQoc291cmNlLl9mbGFncy5lbXB0eSk7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICAgICAgZGVsZXRlIGZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgTWVyZ2Uob2JqLl9mbGFncywgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5fZmxhZ3MuZW1wdHkpIHtcbiAgICAgICAgICAgIG9iai5fZmxhZ3MuZW1wdHkgPSBzb3VyY2UuX2ZsYWdzLmVtcHR5O1xuICAgICAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzb3VyY2UuX2ZsYWdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBmbGFncy5lbXB0eTtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE1lcmdlKG9iai5fZmxhZ3MsIHNvdXJjZS5fZmxhZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVybXNcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UuJF90ZXJtcykge1xuICAgICAgICAgICAgY29uc3QgdGVybXMgPSBzb3VyY2UuJF90ZXJtc1trZXldO1xuICAgICAgICAgICAgaWYgKCF0ZXJtcykge1xuICAgICAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gdGVybXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghb2JqLiRfdGVybXNba2V5XSkge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zW2tleV0gPSB0ZXJtcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvYmouJF90ZXJtc1trZXldID0gb2JqLiRfdGVybXNba2V5XS5jb25jYXQodGVybXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2luZ1xuXG4gICAgICAgIGlmICh0aGlzLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRfcm9vdC5fdHJhY2VyLl9jb21iaW5lKG9iaiwgW3RoaXMsIHNvdXJjZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVidWlsZFxuXG4gICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgfVxuXG4gICAgZXh0ZW5kKG9wdGlvbnMpIHtcblxuICAgICAgICBBc3NlcnQoIW9wdGlvbnMuYmFzZSwgJ0Nhbm5vdCBleHRlbmQgdHlwZSB3aXRoIGFub3RoZXIgYmFzZScpO1xuXG4gICAgICAgIHJldHVybiBFeHRlbmQudHlwZSh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBleHRyYWN0KHBhdGgpIHtcblxuICAgICAgICBwYXRoID0gQXJyYXkuaXNBcnJheShwYXRoKSA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZHMucmVhY2gocGF0aCk7XG4gICAgfVxuXG4gICAgZm9yayhwYXRocywgYWRqdXN0ZXIpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IGZvcmsgaW5zaWRlIGEgcnVsZXNldCcpO1xuXG4gICAgICAgIGxldCBvYmogPSB0aGlzOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgICAgIGZvciAobGV0IHBhdGggb2YgW10uY29uY2F0KHBhdGhzKSkge1xuICAgICAgICAgICAgcGF0aCA9IEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgICAgb2JqID0gb2JqLl9pZHMuZm9yayhwYXRoLCBhZGp1c3Rlciwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIHJ1bGUob3B0aW9ucykge1xuXG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZmluaXRpb247XG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIE9iamVjdC5rZXlzKGRlZi5tb2RpZmllcnMpKTtcblxuICAgICAgICBBc3NlcnQodGhpcy4kX3RlbXAucnVsZXNldCAhPT0gZmFsc2UsICdDYW5ub3QgYXBwbHkgcnVsZXMgdG8gZW1wdHkgcnVsZXNldCBvciB0aGUgbGFzdCBydWxlIGFkZGVkIGRvZXMgbm90IHN1cHBvcnQgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy4kX3RlbXAucnVsZXNldCA9PT0gbnVsbCA/IHRoaXMuX3J1bGVzLmxlbmd0aCAtIDEgOiB0aGlzLiRfdGVtcC5ydWxlc2V0O1xuICAgICAgICBBc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMuX3J1bGVzLmxlbmd0aCwgJ0Nhbm5vdCBhcHBseSBydWxlcyB0byBlbXB0eSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG9iai5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gb2JqLl9ydWxlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBDbG9uZShvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgZGVmLm1vZGlmaWVyc1tuYW1lXShydWxlLCBvcHRpb25zW25hbWVdKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQocnVsZS5uYW1lID09PSBvcmlnaW5hbC5uYW1lLCAnQ2Fubm90IGNoYW5nZSBydWxlIG5hbWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqLl9ydWxlc1tpXSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmIChvYmouX3NpbmdsZVJ1bGVzLmdldChydWxlLm5hbWUpID09PSBvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIG9iai5fc2luZ2xlUnVsZXMuc2V0KHJ1bGUubmFtZSwgcnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICB9XG5cbiAgICBnZXQgcnVsZXNldCgpIHtcblxuICAgICAgICBBc3NlcnQoIXRoaXMuX2luUnVsZXNldCgpLCAnQ2Fubm90IHN0YXJ0IGEgbmV3IHJ1bGVzZXQgd2l0aG91dCBjbG9zaW5nIHRoZSBwcmV2aW91cyBvbmUnKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IG9iai5fcnVsZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIGdldCAkKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJ1bGVzZXQ7XG4gICAgfVxuXG4gICAgdGFpbG9yKHRhcmdldHMpIHtcblxuICAgICAgICB0YXJnZXRzID0gW10uY29uY2F0KHRhcmdldHMpO1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksICdDYW5ub3QgdGFpbG9yIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG5cbiAgICAgICAgaWYgKHRoaXMuJF90ZXJtcy5hbHRlcmF0aW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHRhcmdldCwgYWRqdXN0ZXIgfSBvZiB0aGlzLiRfdGVybXMuYWx0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0cy5pbmNsdWRlcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGFkanVzdGVyKG9iaik7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEob2JqKSwgJ0FsdGVyYXRpb24gYWRqdXN0ZXIgZm9yJywgdGFyZ2V0LCAnZmFpbGVkIHRvIHJldHVybiBhIHNjaGVtYSBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmouJF9tb2RpZnkoeyBlYWNoOiAoaXRlbSkgPT4gaXRlbS50YWlsb3IodGFyZ2V0cyksIHJlZjogZmFsc2UgfSk7XG4gICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgIH1cblxuICAgIHRyYWNlcigpIHtcblxuICAgICAgICByZXR1cm4gVHJhY2UubG9jYXRpb24gPyBUcmFjZS5sb2NhdGlvbih0aGlzKSA6IHRoaXM7ICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIH1cblxuICAgIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci5lbnRyeSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVBc3luYyh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHJldHVybiBWYWxpZGF0b3IuZW50cnlBc3luYyh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5zaW9uc1xuXG4gICAgJF9hZGRSdWxlKG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBOb3JtYWxpemUgcnVsZVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIEFzc2VydChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JywgJ0ludmFsaWQgb3B0aW9ucycpO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5uYW1lICYmIHR5cGVvZiBvcHRpb25zLm5hbWUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBydWxlIG5hbWUnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBBc3NlcnQoa2V5WzBdICE9PSAnXycsICdDYW5ub3Qgc2V0IHByaXZhdGUgcnVsZSBwcm9wZXJ0aWVzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBydWxlID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgICAgICBydWxlLl9yZXNvbHZlID0gW107XG4gICAgICAgIHJ1bGUubWV0aG9kID0gcnVsZS5tZXRob2QgfHwgcnVsZS5uYW1lO1xuXG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9kZWZpbml0aW9uLnJ1bGVzW3J1bGUubWV0aG9kXTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJ1bGUuYXJncztcblxuICAgICAgICBBc3NlcnQoZGVmaW5pdGlvbiwgJ1Vua25vd24gcnVsZScsIHJ1bGUubWV0aG9kKTtcblxuICAgICAgICAvLyBBcmdzXG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICBBc3NlcnQoT2JqZWN0LmtleXMoYXJncykubGVuZ3RoID09PSAxIHx8IE9iamVjdC5rZXlzKGFyZ3MpLmxlbmd0aCA9PT0gdGhpcy5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm5hbWVdLmFyZ3MubGVuZ3RoLCAnSW52YWxpZCBydWxlIGRlZmluaXRpb24gZm9yJywgdGhpcy50eXBlLCBydWxlLm5hbWUpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhcmdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGFyZ3Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uYXJnc0J5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IGRlZmluaXRpb24uYXJnc0J5TmFtZS5nZXQoa2V5KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIucmVmICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBDb21tb24uaXNSZXNvbHZhYmxlKGFyZykpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5fcmVzb2x2ZS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3RlcihhcmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHJlc29sdmVyLm5vcm1hbGl6ZShhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3Nba2V5XSA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyLmFzc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gQ29tbW9uLnZhbGlkYXRlQXJnKGFyZywga2V5LCByZXNvbHZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFlcnJvciwgZXJyb3IsICdvciByZWZlcmVuY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFyZ3Nba2V5XSA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuaXF1ZSBydWxlc1xuXG4gICAgICAgIGlmICghZGVmaW5pdGlvbi5tdWx0aSkge1xuICAgICAgICAgICAgb2JqLl9ydWxlUmVtb3ZlKHJ1bGUubmFtZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai4kX3RlbXAucnVsZXNldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9iai4kX3RlbXAucnVsZXNldCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5wcmlvcml0eSkge1xuICAgICAgICAgICAgb2JqLl9ydWxlcy51bnNoaWZ0KHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLl9ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAkX2NvbXBpbGUoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIENvbXBpbGUuc2NoZW1hKHRoaXMuJF9yb290LCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgICRfY3JlYXRlRXJyb3IoY29kZSwgdmFsdWUsIGxvY2FsLCBzdGF0ZSwgcHJlZnMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGNvbnN0IGZsYWdzID0gb3B0aW9ucy5mbGFncyAhPT0gZmFsc2UgPyB0aGlzLl9mbGFncyA6IHt9O1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXMgPyBNZXNzYWdlcy5tZXJnZSh0aGlzLl9kZWZpbml0aW9uLm1lc3NhZ2VzLCBvcHRpb25zLm1lc3NhZ2VzKSA6IHRoaXMuX2RlZmluaXRpb24ubWVzc2FnZXM7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JzLlJlcG9ydChjb2RlLCB2YWx1ZSwgbG9jYWwsIGZsYWdzLCBtZXNzYWdlcywgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICAkX2dldEZsYWcobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9mbGFnc1tuYW1lXTtcbiAgICB9XG5cbiAgICAkX2dldFJ1bGUobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9zaW5nbGVSdWxlcy5nZXQobmFtZSk7XG4gICAgfVxuXG4gICAgJF9tYXBMYWJlbHMocGF0aCkge1xuXG4gICAgICAgIHBhdGggPSBBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aCA6IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5sYWJlbHMocGF0aCk7XG4gICAgfVxuXG4gICAgJF9tYXRjaCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBvdmVycmlkZXMpIHtcblxuICAgICAgICBwcmVmcyA9IE9iamVjdC5hc3NpZ24oe30sIHByZWZzKTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcbiAgICAgICAgcHJlZnMuYWJvcnRFYXJseSA9IHRydWU7XG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgPSBmYWxzZTtcblxuICAgICAgICBzdGF0ZS5zbmFwc2hvdCgpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSAhVmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlLCB0aGlzLCBzdGF0ZSwgcHJlZnMsIG92ZXJyaWRlcykuZXJyb3JzO1xuICAgICAgICBzdGF0ZS5yZXN0b3JlKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAkX21vZGlmeShvcHRpb25zKSB7XG5cbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydlYWNoJywgJ29uY2UnLCAncmVmJywgJ3NjaGVtYSddKTtcbiAgICAgICAgcmV0dXJuIE1vZGlmeS5zY2hlbWEodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICB9XG5cbiAgICAkX211dGF0ZVJlYnVpbGQoKSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBhZGQgdGhpcyBydWxlIGluc2lkZSBhIHJ1bGVzZXQnKTtcblxuICAgICAgICB0aGlzLl9yZWZzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2lkcy5yZXNldCgpO1xuXG4gICAgICAgIGNvbnN0IGVhY2ggPSAoaXRlbSwgeyBzb3VyY2UsIG5hbWUsIHBhdGgsIGtleSB9KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGZhbWlseSA9IHRoaXMuX2RlZmluaXRpb25bc291cmNlXVtuYW1lXSAmJiB0aGlzLl9kZWZpbml0aW9uW3NvdXJjZV1bbmFtZV0ucmVnaXN0ZXI7XG4gICAgICAgICAgICBpZiAoZmFtaWx5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJF9tdXRhdGVSZWdpc3RlcihpdGVtLCB7IGZhbWlseSwga2V5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuJF9tb2RpZnkoeyBlYWNoIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLl9kZWZpbml0aW9uLnJlYnVpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb24ucmVidWlsZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgJF9tdXRhdGVSZWdpc3RlcihzY2hlbWEsIHsgZmFtaWx5LCBrZXkgfSA9IHt9KSB7XG5cbiAgICAgICAgdGhpcy5fcmVmcy5yZWdpc3RlcihzY2hlbWEsIGZhbWlseSk7XG4gICAgICAgIHRoaXMuX2lkcy5yZWdpc3RlcihzY2hlbWEsIHsga2V5IH0pO1xuICAgIH1cblxuICAgICRfcHJvcGVydHkobmFtZSkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uLnByb3BlcnRpZXNbbmFtZV07XG4gICAgfVxuXG4gICAgJF9yZWFjaChwYXRoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkcy5yZWFjaChwYXRoKTtcbiAgICB9XG5cbiAgICAkX3Jvb3RSZWZlcmVuY2VzKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZzLnJvb3RzKCk7XG4gICAgfVxuXG4gICAgJF9zZXRGbGFnKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICBBc3NlcnQobmFtZVswXSA9PT0gJ18nIHx8ICF0aGlzLl9pblJ1bGVzZXQoKSwgJ0Nhbm5vdCBzZXQgZmxhZyBpbnNpZGUgYSBydWxlc2V0Jyk7XG5cbiAgICAgICAgY29uc3QgZmxhZyA9IHRoaXMuX2RlZmluaXRpb24uZmxhZ3NbbmFtZV0gfHwge307XG4gICAgICAgIGlmIChEZWVwRXF1YWwodmFsdWUsIGZsYWcuZGVmYXVsdCkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKERlZXBFcXVhbCh2YWx1ZSwgdGhpcy5fZmxhZ3NbbmFtZV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqLl9mbGFnc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIG9iai5fZmxhZ3NbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZVswXSAhPT0gJ18nKSB7XG4gICAgICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZSwgdGhpcywgc3RhdGUsIHByZWZzKTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbHNcblxuICAgIF9hc3NpZ24odGFyZ2V0KSB7XG5cbiAgICAgICAgdGFyZ2V0LnR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgdGFyZ2V0LiRfcm9vdCA9IHRoaXMuJF9yb290O1xuXG4gICAgICAgIHRhcmdldC4kX3RlbXAgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLiRfdGVtcCk7XG4gICAgICAgIHRhcmdldC4kX3RlbXAud2hlbnMgPSB7fTtcblxuICAgICAgICB0YXJnZXQuX2lkcyA9IHRoaXMuX2lkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX3ByZWZlcmVuY2VzID0gdGhpcy5fcHJlZmVyZW5jZXM7XG4gICAgICAgIHRhcmdldC5fdmFsaWRzID0gdGhpcy5fdmFsaWRzICYmIHRoaXMuX3ZhbGlkcy5jbG9uZSgpO1xuICAgICAgICB0YXJnZXQuX2ludmFsaWRzID0gdGhpcy5faW52YWxpZHMgJiYgdGhpcy5faW52YWxpZHMuY2xvbmUoKTtcbiAgICAgICAgdGFyZ2V0Ll9ydWxlcyA9IHRoaXMuX3J1bGVzLnNsaWNlKCk7XG4gICAgICAgIHRhcmdldC5fc2luZ2xlUnVsZXMgPSBDbG9uZSh0aGlzLl9zaW5nbGVSdWxlcywgeyBzaGFsbG93OiB0cnVlIH0pO1xuICAgICAgICB0YXJnZXQuX3JlZnMgPSB0aGlzLl9yZWZzLmNsb25lKCk7XG4gICAgICAgIHRhcmdldC5fZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9mbGFncyk7XG4gICAgICAgIHRhcmdldC5fY2FjaGUgPSBudWxsO1xuXG4gICAgICAgIHRhcmdldC4kX3Rlcm1zID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJF90ZXJtcykge1xuICAgICAgICAgICAgdGFyZ2V0LiRfdGVybXNba2V5XSA9IHRoaXMuJF90ZXJtc1trZXldID8gdGhpcy4kX3Rlcm1zW2tleV0uc2xpY2UoKSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQuJF9zdXBlciA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG92ZXJyaWRlIGluIHRoaXMuJF9zdXBlcikge1xuICAgICAgICAgICAgdGFyZ2V0LiRfc3VwZXJbb3ZlcnJpZGVdID0gdGhpcy5fc3VwZXJbb3ZlcnJpZGVdLmJpbmQodGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgX2RlZmF1bHQoZmxhZywgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsICdsaXRlcmFsJyk7XG5cbiAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdNaXNzaW5nJywgZmxhZywgJ3ZhbHVlJyk7XG4gICAgICAgIEFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgIW9wdGlvbnMubGl0ZXJhbCwgJ09ubHkgZnVuY3Rpb24gdmFsdWUgc3VwcG9ydHMgbGl0ZXJhbCBvcHRpb24nKTtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBvcHRpb25zLmxpdGVyYWwpIHtcblxuICAgICAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdOiB0cnVlLFxuICAgICAgICAgICAgICAgIGxpdGVyYWw6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy4kX3NldEZsYWcoZmxhZywgdmFsdWUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIF9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLiRfdGVybXMud2hlbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sbGVjdCBtYXRjaGluZyB3aGVuc1xuXG4gICAgICAgIGNvbnN0IHdoZW5zID0gW107XG4gICAgICAgIGNvbnN0IGlkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuJF90ZXJtcy53aGVucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgd2hlbiA9IHRoaXMuJF90ZXJtcy53aGVuc1tpXTtcblxuICAgICAgICAgICAgaWYgKHdoZW4uY29uY2F0KSB7XG4gICAgICAgICAgICAgICAgd2hlbnMucHVzaCh3aGVuLmNvbmNhdCk7XG4gICAgICAgICAgICAgICAgaWRzLnB1c2goYCR7aX0uY29uY2F0YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gd2hlbi5yZWYgPyB3aGVuLnJlZi5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpIDogdmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0ZXN0cyA9IHdoZW4uaXMgPyBbd2hlbl0gOiB3aGVuLnN3aXRjaDtcbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGlkcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGVzdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlzLCB0aGVuLCBvdGhlcndpc2UgfSA9IHRlc3RzW2pdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUlkID0gYCR7aX0ke3doZW4uc3dpdGNoID8gJy4nICsgaiA6ICcnfWA7XG4gICAgICAgICAgICAgICAgaWYgKGlzLiRfbWF0Y2goaW5wdXQsIHN0YXRlLm5lc3QoaXMsIGAke2Jhc2VJZH0uaXNgKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUoWy4uLnN0YXRlLnBhdGgsIGAke2Jhc2VJZH0udGhlbmBdLCBzdGF0ZS5hbmNlc3RvcnMsIHN0YXRlLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWE6IGdlbmVyYXRlZCwgaWQgfSA9IHRoZW4uX2dlbmVyYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVucy5wdXNoKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChgJHtiYXNlSWR9LnRoZW4ke2lkID8gYCgke2lkfSlgIDogJyd9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvdGhlcndpc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBgJHtiYXNlSWR9Lm90aGVyd2lzZWBdLCBzdGF0ZS5hbmNlc3RvcnMsIHN0YXRlLnNjaGVtYXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjaGVtYTogZ2VuZXJhdGVkLCBpZCB9ID0gb3RoZXJ3aXNlLl9nZW5lcmF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB3aGVucy5wdXNoKGdlbmVyYXRlZCk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5wdXNoKGAke2Jhc2VJZH0ub3RoZXJ3aXNlJHtpZCA/IGAoJHtpZH0pYCA6ICcnfWApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3aGVuLmJyZWFrICYmXG4gICAgICAgICAgICAgICAgaWRzLmxlbmd0aCA+IGJlZm9yZSkgeyAgICAgICAgICAvLyBTb21ldGhpbmcgbWF0Y2hlZFxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBjYWNoZVxuXG4gICAgICAgIGNvbnN0IGlkID0gaWRzLmpvaW4oJywgJyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3J1bGUnLCAnd2hlbicsIGlkKTtcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzY2hlbWE6IHRoaXMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGUubWFpbnN0YXkudHJhY2VyLmFjdGl2ZSAmJlxuICAgICAgICAgICAgdGhpcy4kX3RlbXAud2hlbnNbaWRdKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHNjaGVtYTogdGhpcy4kX3RlbXAud2hlbnNbaWRdLCBpZCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgZHluYW1pYyBzY2hlbWFcblxuICAgICAgICBsZXQgb2JqID0gdGhpczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtdGhpc1xuICAgICAgICBpZiAodGhpcy5fZGVmaW5pdGlvbi5nZW5lcmF0ZSkge1xuICAgICAgICAgICAgb2JqID0gdGhpcy5fZGVmaW5pdGlvbi5nZW5lcmF0ZSh0aGlzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IHdoZW5zXG5cbiAgICAgICAgZm9yIChjb25zdCB3aGVuIG9mIHdoZW5zKSB7XG4gICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KHdoZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2luZ1xuXG4gICAgICAgIGlmICh0aGlzLiRfcm9vdC5fdHJhY2VyKSB7XG4gICAgICAgICAgICB0aGlzLiRfcm9vdC5fdHJhY2VyLl9jb21iaW5lKG9iaiwgW3RoaXMsIC4uLndoZW5zXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWNoZSByZXN1bHRcblxuICAgICAgICB0aGlzLiRfdGVtcC53aGVuc1tpZF0gPSBvYmo7XG4gICAgICAgIHJldHVybiB7IHNjaGVtYTogb2JqLCBpZCB9O1xuICAgIH1cblxuICAgIF9pbm5lcih0eXBlLCB2YWx1ZXMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEFzc2VydCghdGhpcy5faW5SdWxlc2V0KCksIGBDYW5ub3Qgc2V0ICR7dHlwZX0gaW5zaWRlIGEgcnVsZXNldGApO1xuXG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgaWYgKCFvYmouJF90ZXJtc1t0eXBlXSB8fFxuICAgICAgICAgICAgb3B0aW9ucy5vdmVycmlkZSkge1xuXG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2luZ2xlKSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXS5wdXNoKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1t0eXBlXS5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouJF90ZW1wLnJ1bGVzZXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfaW5SdWxlc2V0KCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLiRfdGVtcC5ydWxlc2V0ICE9PSBudWxsICYmIHRoaXMuJF90ZW1wLnJ1bGVzZXQgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIF9ydWxlUmVtb3ZlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fc2luZ2xlUnVsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iaiA9IG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlID8gdGhpcy5jbG9uZSgpIDogdGhpcztcblxuICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLmRlbGV0ZShuYW1lKTtcblxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5fcnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBvYmouX3J1bGVzW2ldO1xuICAgICAgICAgICAgaWYgKHRlc3QubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgICAgICAgICAgICF0ZXN0LmtlZXApIHtcblxuICAgICAgICAgICAgICAgIGlmIChvYmouX2luUnVsZXNldCgpICYmXG4gICAgICAgICAgICAgICAgICAgIGkgPCBvYmouJF90ZW1wLnJ1bGVzZXQpIHtcblxuICAgICAgICAgICAgICAgICAgICAtLW9iai4kX3RlbXAucnVsZXNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaCh0ZXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5fcnVsZXMgPSBmaWx0ZXJlZDtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBfdmFsdWVzKHZhbHVlcywga2V5KSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCBrZXkuc2xpY2UoMSwgLTEpKTtcblxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgY29uc3Qgb3ZlcnJpZGUgPSB2YWx1ZXNbMF0gPT09IENvbW1vbi5zeW1ib2xzLm92ZXJyaWRlO1xuICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb2JqW2tleV0gJiZcbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgb2JqW2tleV0gPSBuZXcgVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWVzLmxlbmd0aCA/IG5ldyBWYWx1ZXMoKSA6IG51bGw7XG4gICAgICAgICAgICBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9ialtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgICAgICBvYmpba2V5XS5vdmVycmlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgYWxsb3cvdmFsaWQvaW52YWxpZCB3aXRoIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSBDb21tb24uc3ltYm9scy5vdmVycmlkZSwgJ092ZXJyaWRlIG11c3QgYmUgdGhlIGZpcnN0IHZhbHVlJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG90aGVyID0ga2V5ID09PSAnX2ludmFsaWRzJyA/ICdfdmFsaWRzJyA6ICdfaW52YWxpZHMnO1xuICAgICAgICAgICAgaWYgKG9ialtvdGhlcl0pIHtcbiAgICAgICAgICAgICAgICBvYmpbb3RoZXJdLnJlbW92ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvYmpbb3RoZXJdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoa2V5ID09PSAnX3ZhbGlkcycgfHwgIW9iai5fZmxhZ3Mub25seSwgJ1NldHRpbmcgaW52YWxpZCB2YWx1ZScsIHZhbHVlLCAnbGVhdmVzIHNjaGVtYSByZWplY3RpbmcgYWxsIHZhbHVlcyBkdWUgdG8gcHJldmlvdXMgdmFsaWQgcnVsZScpO1xuICAgICAgICAgICAgICAgICAgICBvYmpbb3RoZXJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9ialtrZXldLmFkZCh2YWx1ZSwgb2JqLl9yZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuaXNJbW11dGFibGUgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIEhvZWsgZnJvbSBkZWVwIGNsb25pbmcgc2NoZW1hIG9iamVjdHNcblxuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGVbQ29tbW9uLnN5bWJvbHMuYW55XSA9IHtcbiAgICB2ZXJzaW9uOiBDb21tb24udmVyc2lvbixcbiAgICBjb21waWxlOiBDb21waWxlLmNvbXBpbGUsXG4gICAgcm9vdDogJyRfcm9vdCdcbn07XG5cblxuLy8gQWxpYXNlc1xuXG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZGVueSA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5pbnZhbGlkO1xuaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmRpc2FsbG93ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZXF1YWwgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUudmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUuZXhpc3QgPSBpbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUucmVxdWlyZWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUubm90ID0gaW50ZXJuYWxzLkJhc2UucHJvdG90eXBlLmludmFsaWQ7XG5pbnRlcm5hbHMuQmFzZS5wcm90b3R5cGUub3B0aW9ucyA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmcztcbmludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmZXJlbmNlcyA9IGludGVybmFscy5CYXNlLnByb3RvdHlwZS5wcmVmcztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQmFzZSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgbWF4OiAxMDAwLFxuICAgIHN1cHBvcnRlZDogbmV3IFNldChbJ3VuZGVmaW5lZCcsICdib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXSlcbn07XG5cblxuZXhwb3J0cy5wcm92aWRlciA9IHtcblxuICAgIHByb3Zpc2lvbihvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQ2FjaGUob3B0aW9ucyk7XG4gICAgfVxufTtcblxuXG4vLyBMZWFzdCBSZWNlbnRseSBVc2VkIChMUlUpIENhY2hlXG5cbmludGVybmFscy5DYWNoZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnbWF4J10pO1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5tYXggPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLm1heCAmJiBvcHRpb25zLm1heCA+IDAgJiYgaXNGaW5pdGUob3B0aW9ucy5tYXgpLCAnSW52YWxpZCBtYXggY2FjaGUgc2l6ZScpO1xuXG4gICAgICAgIHRoaXMuX21heCA9IG9wdGlvbnMubWF4IHx8IGludGVybmFscy5tYXg7XG5cbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwIG9mIG5vZGVzIGJ5IGtleVxuICAgICAgICB0aGlzLl9saXN0ID0gbmV3IGludGVybmFscy5MaXN0KCk7ICAgICAgICAgICAgICAvLyBMaXN0IG9mIG5vZGVzIChtb3N0IHJlY2VudGx5IHVzZWQgaW4gaGVhZClcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuc2l6ZTtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuXG4gICAgICAgIGlmIChrZXkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFpbnRlcm5hbHMuc3VwcG9ydGVkLmhhcyh0eXBlb2Yga2V5KSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3QuZmlyc3Qobm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gdGhpcy5fbGlzdC51bnNoaWZ0KHsga2V5LCB2YWx1ZSB9KTtcbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIG5vZGUpO1xuICAgICAgICB0aGlzLl9jb21wYWN0KCk7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0LmZpcnN0KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIENsb25lKG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NvbXBhY3QoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hcC5zaXplID4gdGhpcy5fbWF4KSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbGlzdC5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX21hcC5kZWxldGUobm9kZS5rZXkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuTGlzdCA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdW5zaGlmdChub2RlKSB7XG5cbiAgICAgICAgbm9kZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgbm9kZS5wcmV2ID0gdGhpcy5oZWFkO1xuXG4gICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZC5uZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBmaXJzdChub2RlKSB7XG5cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUpO1xuICAgICAgICB0aGlzLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuXG4gICAgcG9wKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmUodGhpcy50YWlsKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlKG5vZGUpIHtcblxuICAgICAgICBjb25zdCB7IG5leHQsIHByZXYgfSA9IG5vZGU7XG5cbiAgICAgICAgbmV4dC5wcmV2ID0gcHJldjtcblxuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnByZXYgPSBudWxsO1xuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQXNzZXJ0RXJyb3IgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9lcnJvcicpO1xuXG5jb25zdCBQa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcblxubGV0IE1lc3NhZ2VzO1xubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGlzb0RhdGU6IC9eKD86Wy0rXVxcZHsyfSk/KD86XFxkezR9KD8hXFxkezJ9XFxiKSkoPzooLT8pKD86KD86MFsxLTldfDFbMC0yXSkoPzpcXDEoPzpbMTJdXFxkfDBbMS05XXwzWzAxXSkpP3xXKD86WzAtNF1cXGR8NVswLTJdKSg/Oi0/WzEtN10pP3woPzowMFsxLTldfDBbMS05XVxcZHxbMTJdXFxkezJ9fDMoPzpbMC01XVxcZHw2WzEtNl0pKSkoPyFbVF0kfFtUXVtcXGRdK1okKSg/OltUXFxzXSg/Oig/Oig/OlswMV1cXGR8MlswLTNdKSg/Oig6PylbMC01XVxcZCk/fDI0XFw6PzAwKSg/OlsuLF1cXGQrKD8hOikpPykoPzpcXDJbMC01XVxcZCg/OlsuLF1cXGQrKT8pPyg/OltaXXwoPzpbKy1dKSg/OlswMV1cXGR8MlswLTNdKSg/Ojo/WzAtNV1cXGQpPyk/KT8pPyQvXG59O1xuXG5cbmV4cG9ydHMudmVyc2lvbiA9IFBrZy52ZXJzaW9uO1xuXG5cbmV4cG9ydHMuZGVmYXVsdHMgPSB7XG4gICAgYWJvcnRFYXJseTogdHJ1ZSxcbiAgICBhbGxvd1Vua25vd246IGZhbHNlLFxuICAgIGNhY2hlOiB0cnVlLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgY29udmVydDogdHJ1ZSxcbiAgICBkYXRlRm9ybWF0OiAnaXNvJyxcbiAgICBlcnJvcnM6IHtcbiAgICAgICAgZXNjYXBlSHRtbDogZmFsc2UsXG4gICAgICAgIGxhYmVsOiAncGF0aCcsXG4gICAgICAgIGxhbmd1YWdlOiBudWxsLFxuICAgICAgICByZW5kZXI6IHRydWUsXG4gICAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgICAgd3JhcEFycmF5czogdHJ1ZVxuICAgIH0sXG4gICAgZXh0ZXJuYWxzOiB0cnVlLFxuICAgIG1lc3NhZ2VzOiB7fSxcbiAgICBub25FbnVtZXJhYmxlczogZmFsc2UsXG4gICAgbm9EZWZhdWx0czogZmFsc2UsXG4gICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsXG4gICAgc2tpcEZ1bmN0aW9uczogZmFsc2UsXG4gICAgc3RyaXBVbmtub3duOiBmYWxzZSxcbiAgICB3YXJuaW5nczogZmFsc2Vcbn07XG5cblxuZXhwb3J0cy5zeW1ib2xzID0ge1xuICAgIGFueTogU3ltYm9sLmZvcignQGhhcGkvam9pL3NjaGVtYScpLCAgICAgICAgICAgIC8vIFVzZWQgdG8gaW50ZXJuYWxseSBpZGVudGlmeSBhbnktYmFzZWQgdHlwZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBhcnJheVNpbmdsZTogU3ltYm9sKCdhcnJheVNpbmdsZScpLFxuICAgIGRlZXBEZWZhdWx0OiBTeW1ib2woJ2RlZXBEZWZhdWx0JyksXG4gICAgbGl0ZXJhbDogU3ltYm9sKCdsaXRlcmFsJyksXG4gICAgb3ZlcnJpZGU6IFN5bWJvbCgnb3ZlcnJpZGUnKSxcbiAgICBwcmVmczogU3ltYm9sKCdwcmVmcycpLFxuICAgIHJlZjogU3ltYm9sKCdyZWYnKSxcbiAgICB2YWx1ZXM6IFN5bWJvbCgndmFsdWVzJyksXG4gICAgdGVtcGxhdGU6IFN5bWJvbCgndGVtcGxhdGUnKVxufTtcblxuXG5leHBvcnRzLmFzc2VydE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywga2V5cywgbmFtZSA9ICdPcHRpb25zJykge1xuXG4gICAgQXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMpLCAnT3B0aW9ucyBtdXN0IGJlIG9mIHR5cGUgb2JqZWN0Jyk7XG4gICAgY29uc3QgdW5rbm93bktleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKGspID0+ICFrZXlzLmluY2x1ZGVzKGspKTtcbiAgICBBc3NlcnQodW5rbm93bktleXMubGVuZ3RoID09PSAwLCBgJHtuYW1lfSBjb250YWluIHVua25vd24ga2V5czogJHt1bmtub3duS2V5c31gKTtcbn07XG5cblxuZXhwb3J0cy5jaGVja1ByZWZlcmVuY2VzID0gZnVuY3Rpb24gKHByZWZzKSB7XG5cbiAgICBTY2hlbWFzID0gU2NoZW1hcyB8fCByZXF1aXJlKCcuL3NjaGVtYXMnKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFNjaGVtYXMucHJlZmVyZW5jZXMudmFsaWRhdGUocHJlZnMpO1xuXG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0RXJyb3IoW3Jlc3VsdC5lcnJvci5kZXRhaWxzWzBdLm1lc3NhZ2VdKTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiLCBvcGVyYXRvcikge1xuXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlICc9JzogcmV0dXJuIGEgPT09IGI7XG4gICAgICAgIGNhc2UgJz4nOiByZXR1cm4gYSA+IGI7XG4gICAgICAgIGNhc2UgJzwnOiByZXR1cm4gYSA8IGI7XG4gICAgICAgIGNhc2UgJz49JzogcmV0dXJuIGEgPj0gYjtcbiAgICAgICAgY2FzZSAnPD0nOiByZXR1cm4gYSA8PSBiO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcblxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59O1xuXG5cbmV4cG9ydHMuaXNJc29EYXRlID0gZnVuY3Rpb24gKGRhdGUpIHtcblxuICAgIHJldHVybiBpbnRlcm5hbHMuaXNvRGF0ZS50ZXN0KGRhdGUpO1xufTtcblxuXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpO1xufTtcblxuXG5leHBvcnRzLmlzUmVzb2x2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcblxuICAgIGlmICghb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqW2V4cG9ydHMuc3ltYm9scy5yZWZdIHx8IG9ialtleHBvcnRzLnN5bWJvbHMudGVtcGxhdGVdO1xufTtcblxuXG5leHBvcnRzLmlzU2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWEgJiYgc2NoZW1hW2V4cG9ydHMuc3ltYm9scy5hbnldO1xuICAgIGlmICghYW55KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBBc3NlcnQob3B0aW9ucy5sZWdhY3kgfHwgYW55LnZlcnNpb24gPT09IGV4cG9ydHMudmVyc2lvbiwgJ0Nhbm5vdCBtaXggZGlmZmVyZW50IHZlcnNpb25zIG9mIGpvaSBzY2hlbWFzJyk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmV4cG9ydHMuaXNWYWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICByZXR1cm4gb2JqW2V4cG9ydHMuc3ltYm9scy52YWx1ZXNdO1xufTtcblxuXG5leHBvcnRzLmxpbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG59O1xuXG5cbmV4cG9ydHMucHJlZmVyZW5jZXMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIE1lc3NhZ2VzID0gTWVzc2FnZXMgfHwgcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICAgIHNvdXJjZSA9IHNvdXJjZSB8fCB7fTtcblxuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgc291cmNlKTtcbiAgICBpZiAoc291cmNlLmVycm9ycyAmJlxuICAgICAgICB0YXJnZXQuZXJyb3JzKSB7XG5cbiAgICAgICAgbWVyZ2VkLmVycm9ycyA9IE9iamVjdC5hc3NpZ24oe30sIHRhcmdldC5lcnJvcnMsIHNvdXJjZS5lcnJvcnMpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UubWVzc2FnZXMpIHtcbiAgICAgICAgbWVyZ2VkLm1lc3NhZ2VzID0gTWVzc2FnZXMuY29tcGlsZShzb3VyY2UubWVzc2FnZXMsIHRhcmdldC5tZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG1lcmdlZFtleHBvcnRzLnN5bWJvbHMucHJlZnNdO1xuICAgIHJldHVybiBtZXJnZWQ7XG59O1xuXG5cbmV4cG9ydHMudHJ5V2l0aFBhdGggPSBmdW5jdGlvbiAoZm4sIGtleSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyLnBhdGggPSBrZXkgKyAnLicgKyBlcnIucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVyci5wYXRoID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwZW5kKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIucGF0aH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMudmFsaWRhdGVBcmcgPSBmdW5jdGlvbiAodmFsdWUsIGxhYmVsLCB7IGFzc2VydCwgbWVzc2FnZSB9KSB7XG5cbiAgICBpZiAoZXhwb3J0cy5pc1NjaGVtYShhc3NlcnQpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzc2VydC52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghcmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFhc3NlcnQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBsYWJlbCA/IGAke2xhYmVsfSAke21lc3NhZ2V9YCA6IG1lc3NhZ2U7XG4gICAgfVxufTtcblxuXG5leHBvcnRzLnZlcmlmeUZsYXQgPSBmdW5jdGlvbiAoYXJncywgbWV0aG9kKSB7XG5cbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XG4gICAgICAgIEFzc2VydCghQXJyYXkuaXNBcnJheShhcmcpLCAnTWV0aG9kIG5vIGxvbmdlciBhY2NlcHRzIGFycmF5IGFyZ3VtZW50czonLCBtZXRob2QpO1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnNjaGVtYSA9IGZ1bmN0aW9uIChKb2ksIGNvbmZpZywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FwcGVuZFBhdGgnLCAnb3ZlcnJpZGUnXSk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNjaGVtYShKb2ksIGNvbmZpZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwZW5kUGF0aCAmJlxuICAgICAgICAgICAgZXJyLnBhdGggIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAoJHtlcnIucGF0aH0pYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWEgPSBmdW5jdGlvbiAoSm9pLCBjb25maWcsIG9wdGlvbnMpIHtcblxuICAgIEFzc2VydChjb25maWcgIT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgdW5kZWZpbmVkIHNjaGVtYScpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgICAgICBBc3NlcnQoY29uZmlnLmxlbmd0aCwgJ0ludmFsaWQgZW1wdHkgYXJyYXkgc2NoZW1hJyk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZ1swXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gKGJhc2UsIC4uLnZhbHVlcykgPT4ge1xuXG4gICAgICAgIGlmIChvcHRpb25zLm92ZXJyaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoSm9pLm92ZXJyaWRlLCAuLi52YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2UudmFsaWQoLi4udmFsdWVzKTtcbiAgICB9O1xuXG4gICAgaWYgKGludGVybmFscy5zaW1wbGUoY29uZmlnKSkge1xuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBKb2kuY3VzdG9tKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnLCAnSW52YWxpZCBzY2hlbWEgY29udGVudDonLCB0eXBlb2YgY29uZmlnKTtcblxuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkKEpvaSwgY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25maWcpKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmICghaW50ZXJuYWxzLnNpbXBsZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKb2kuYWx0ZXJuYXRpdmVzKCkudHJ5KC4uLmNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQoSm9pLCAuLi5jb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuIEpvaS5zdHJpbmcoKS5yZWdleChjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB2YWxpZChKb2kuZGF0ZSgpLCBjb25maWcpO1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29uZmlnKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIHJldHVybiBKb2kub2JqZWN0KCkua2V5cyhjb25maWcpO1xufTtcblxuXG5leHBvcnRzLnJlZiA9IGZ1bmN0aW9uIChpZCwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIFJlZi5pc1JlZihpZCkgPyBpZCA6IFJlZi5jcmVhdGUoaWQsIG9wdGlvbnMpO1xufTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBvcHRpb25zID0ge30pIHtcblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnbGVnYWN5J10pO1xuXG4gICAgLy8gQ29tcGlsZWQgYnkgYW55IHN1cHBvcnRlZCB2ZXJzaW9uXG5cbiAgICBjb25zdCBhbnkgPSBzY2hlbWEgJiYgc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5sZWdhY3kgfHwgYW55LnZlcnNpb24gPT09IENvbW1vbi52ZXJzaW9uLCAnQ2Fubm90IG1peCBkaWZmZXJlbnQgdmVyc2lvbnMgb2Ygam9pIHNjaGVtYXMnKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICAvLyBVbmNvbXBpbGVkIHJvb3RcblxuICAgIGlmICh0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhb3B0aW9ucy5sZWdhY3kpIHtcblxuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7ICAgICAgICAgIC8vIFdpbGwgZXJyb3IgaWYgc2NoZW1hIGNvbnRhaW5zIG90aGVyIHZlcnNpb25zXG4gICAgfVxuXG4gICAgLy8gU2NhbiBzY2hlbWEgZm9yIGNvbXBpbGVkIHBhcnRzXG5cbiAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYSk7XG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zY2hlbWEocm9vdCwgc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBpbGVyLmNvbXBpbGUoY29tcGlsZXIucm9vdCwgc2NoZW1hKTtcbn07XG5cblxuaW50ZXJuYWxzLndhbGsgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBpZiAodHlwZW9mIHNjaGVtYSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYW55ID0gc2NoZW1hW0NvbW1vbi5zeW1ib2xzLmFueV07XG4gICAgaWYgKGFueSkge1xuICAgICAgICByZXR1cm4geyByb290OiBzY2hlbWFbYW55LnJvb3RdLCBjb21waWxlOiBhbnkuY29tcGlsZSB9O1xuICAgIH1cblxuICAgIEFzc2VydChPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2NoZW1hKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KSwgJ1NjaGVtYSBjYW4gb25seSBjb250YWluIHBsYWluIG9iamVjdHMnKTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb21waWxlciA9IGludGVybmFscy53YWxrKHNjaGVtYVtrZXldKTtcbiAgICAgICAgaWYgKGNvbXBpbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLnNpbXBsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IFsnYm9vbGVhbicsICdzdHJpbmcnLCAnbnVtYmVyJ10uaW5jbHVkZXModHlwZW9mIHZhbHVlKTtcbn07XG5cblxuZXhwb3J0cy53aGVuID0gZnVuY3Rpb24gKHNjaGVtYSwgY29uZGl0aW9uLCBvcHRpb25zKSB7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIEFzc2VydChjb25kaXRpb24gJiYgdHlwZW9mIGNvbmRpdGlvbiA9PT0gJ29iamVjdCcsICdNaXNzaW5nIG9wdGlvbnMnKTtcblxuICAgICAgICBvcHRpb25zID0gY29uZGl0aW9uO1xuICAgICAgICBjb25kaXRpb24gPSBSZWYuY3JlYXRlKCcuJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgc3dpdGNoOiBvcHRpb25zIH07XG4gICAgfVxuXG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydpcycsICdub3QnLCAndGhlbicsICdvdGhlcndpc2UnLCAnc3dpdGNoJywgJ2JyZWFrJ10pO1xuXG4gICAgLy8gU2NoZW1hIGNvbmRpdGlvblxuXG4gICAgaWYgKENvbW1vbi5pc1NjaGVtYShjb25kaXRpb24pKSB7XG4gICAgICAgIEFzc2VydChvcHRpb25zLmlzID09PSB1bmRlZmluZWQsICdcImlzXCIgY2FuIG5vdCBiZSB1c2VkIHdpdGggYSBzY2hlbWEgY29uZGl0aW9uJyk7XG4gICAgICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnXCJub3RcIiBjYW4gbm90IGJlIHVzZWQgd2l0aCBhIHNjaGVtYSBjb25kaXRpb24nKTtcbiAgICAgICAgQXNzZXJ0KG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQsICdcInN3aXRjaFwiIGNhbiBub3QgYmUgdXNlZCB3aXRoIGEgc2NoZW1hIGNvbmRpdGlvbicpO1xuXG4gICAgICAgIHJldHVybiBpbnRlcm5hbHMuY29uZGl0aW9uKHNjaGVtYSwgeyBpczogY29uZGl0aW9uLCB0aGVuOiBvcHRpb25zLnRoZW4sIG90aGVyd2lzZTogb3B0aW9ucy5vdGhlcndpc2UsIGJyZWFrOiBvcHRpb25zLmJyZWFrIH0pO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSBjb25kaXRpb25cblxuICAgIEFzc2VydChSZWYuaXNSZWYoY29uZGl0aW9uKSB8fCB0eXBlb2YgY29uZGl0aW9uID09PSAnc3RyaW5nJywgJ0ludmFsaWQgY29uZGl0aW9uOicsIGNvbmRpdGlvbik7XG4gICAgQXNzZXJ0KG9wdGlvbnMubm90ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJpc1wiIHdpdGggXCJub3RcIicpO1xuXG4gICAgaWYgKG9wdGlvbnMuc3dpdGNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGV0IHJ1bGUgPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy5ub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVsZSA9IHsgaXM6IG9wdGlvbnMubm90LCB0aGVuOiBvcHRpb25zLm90aGVyd2lzZSwgb3RoZXJ3aXNlOiBvcHRpb25zLnRoZW4sIGJyZWFrOiBvcHRpb25zLmJyZWFrIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXMgPSBydWxlLmlzICE9PSB1bmRlZmluZWQgPyBzY2hlbWEuJF9jb21waWxlKHJ1bGUuaXMpIDogc2NoZW1hLiRfcm9vdC5pbnZhbGlkKG51bGwsIGZhbHNlLCAwLCAnJykucmVxdWlyZWQoKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUudGhlbiAhPT0gdW5kZWZpbmVkIHx8IHJ1bGUub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQsICdvcHRpb25zIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2YgXCJ0aGVuXCIsIFwib3RoZXJ3aXNlXCIsIG9yIFwic3dpdGNoXCInKTtcbiAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCB8fCBydWxlLnRoZW4gPT09IHVuZGVmaW5lZCB8fCBydWxlLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IHNwZWNpZnkgdGhlbiwgb3RoZXJ3aXNlLCBhbmQgYnJlYWsgYWxsIHRvZ2V0aGVyJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIVJlZi5pc1JlZihvcHRpb25zLmlzKSAmJlxuICAgICAgICAgICAgIUNvbW1vbi5pc1NjaGVtYShvcHRpb25zLmlzKSkge1xuXG4gICAgICAgICAgICBpcyA9IGlzLnJlcXVpcmVkKCk7ICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSByZXF1aXJlZCBpZiB0aGlzIHdhc24ndCBhbHJlYWR5IGEgc2NoZW1hIG9yIGEgcmVmXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmNvbmRpdGlvbihzY2hlbWEsIHsgcmVmOiBleHBvcnRzLnJlZihjb25kaXRpb24pLCBpcywgdGhlbjogcnVsZS50aGVuLCBvdGhlcndpc2U6IHJ1bGUub3RoZXJ3aXNlLCBicmVhazogcnVsZS5icmVhayB9KTtcbiAgICB9XG5cbiAgICAvLyBTd2l0Y2ggc3RhdGVtZW50XG5cbiAgICBBc3NlcnQoQXJyYXkuaXNBcnJheShvcHRpb25zLnN3aXRjaCksICdcInN3aXRjaFwiIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICBBc3NlcnQob3B0aW9ucy5pcyA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwiaXNcIicpO1xuICAgIEFzc2VydChvcHRpb25zLm5vdCA9PT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNvbWJpbmUgXCJzd2l0Y2hcIiB3aXRoIFwibm90XCInKTtcbiAgICBBc3NlcnQob3B0aW9ucy50aGVuID09PSB1bmRlZmluZWQsICdDYW5ub3QgY29tYmluZSBcInN3aXRjaFwiIHdpdGggXCJ0aGVuXCInKTtcblxuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHJlZjogZXhwb3J0cy5yZWYoY29uZGl0aW9uKSxcbiAgICAgICAgc3dpdGNoOiBbXSxcbiAgICAgICAgYnJlYWs6IG9wdGlvbnMuYnJlYWtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25zLnN3aXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0ZXN0ID0gb3B0aW9ucy5zd2l0Y2hbaV07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBpID09PSBvcHRpb25zLnN3aXRjaC5sZW5ndGggLSAxO1xuXG4gICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKHRlc3QsIGxhc3QgPyBbJ2lzJywgJ3RoZW4nLCAnb3RoZXJ3aXNlJ10gOiBbJ2lzJywgJ3RoZW4nXSk7XG5cbiAgICAgICAgQXNzZXJ0KHRlc3QuaXMgIT09IHVuZGVmaW5lZCwgJ1N3aXRjaCBzdGF0ZW1lbnQgbWlzc2luZyBcImlzXCInKTtcbiAgICAgICAgQXNzZXJ0KHRlc3QudGhlbiAhPT0gdW5kZWZpbmVkLCAnU3dpdGNoIHN0YXRlbWVudCBtaXNzaW5nIFwidGhlblwiJyk7XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgIGlzOiBzY2hlbWEuJF9jb21waWxlKHRlc3QuaXMpLFxuICAgICAgICAgICAgdGhlbjogc2NoZW1hLiRfY29tcGlsZSh0ZXN0LnRoZW4pXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFSZWYuaXNSZWYodGVzdC5pcykgJiZcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEodGVzdC5pcykpIHtcblxuICAgICAgICAgICAgaXRlbS5pcyA9IGl0ZW0uaXMucmVxdWlyZWQoKTsgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgcmVxdWlyZWQgaWYgdGhpcyB3YXNuJ3QgYWxyZWFkeSBhIHNjaGVtYSBvciBhIHJlZlxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIEFzc2VydChvcHRpb25zLm90aGVyd2lzZSA9PT0gdW5kZWZpbmVkIHx8IHRlc3Qub3RoZXJ3aXNlID09PSB1bmRlZmluZWQsICdDYW5ub3Qgc3BlY2lmeSBcIm90aGVyd2lzZVwiIGluc2lkZSBhbmQgb3V0c2lkZSBhIFwic3dpdGNoXCInKTtcbiAgICAgICAgICAgIGNvbnN0IG90aGVyd2lzZSA9IG9wdGlvbnMub3RoZXJ3aXNlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm90aGVyd2lzZSA6IHRlc3Qub3RoZXJ3aXNlO1xuICAgICAgICAgICAgaWYgKG90aGVyd2lzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJ1bGUuYnJlYWsgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBzcGVjaWZ5IGJvdGggb3RoZXJ3aXNlIGFuZCBicmVhaycpO1xuICAgICAgICAgICAgICAgIGl0ZW0ub3RoZXJ3aXNlID0gc2NoZW1hLiRfY29tcGlsZShvdGhlcndpc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVsZS5zd2l0Y2gucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cblxuaW50ZXJuYWxzLmNvbmRpdGlvbiA9IGZ1bmN0aW9uIChzY2hlbWEsIGNvbmRpdGlvbikge1xuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgWyd0aGVuJywgJ290aGVyd2lzZSddKSB7XG4gICAgICAgIGlmIChjb25kaXRpb25ba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZGl0aW9uW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25kaXRpb25ba2V5XSA9IHNjaGVtYS4kX2NvbXBpbGUoY29uZGl0aW9uW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmRpdGlvbjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBhbm5vdGF0aW9uczogU3ltYm9sKCdhbm5vdGF0aW9ucycpXG59O1xuXG5cbmV4cG9ydHMuUmVwb3J0ID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IoY29kZSwgdmFsdWUsIGxvY2FsLCBmbGFncywgbWVzc2FnZXMsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICB0aGlzLnBhdGggPSBzdGF0ZS5wYXRoO1xuICAgICAgICB0aGlzLnByZWZzID0gcHJlZnM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbCB8fCB7fTtcbiAgICAgICAgdGhpcy5sb2NhbC5sYWJlbCA9IGV4cG9ydHMubGFiZWwodGhpcy5mbGFncywgdGhpcy5zdGF0ZSwgdGhpcy5wcmVmcywgdGhpcy5tZXNzYWdlcyk7XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIXRoaXMubG9jYWwuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcblxuICAgICAgICAgICAgdGhpcy5sb2NhbC52YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWwua2V5ID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldFRlbXBsYXRlKHRlbXBsYXRlKSB7XG5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuXG4gICAgICAgIGlmICghdGhpcy5mbGFncy5sYWJlbCAmJlxuICAgICAgICAgICAgdGhpcy5wYXRoLmxlbmd0aCA9PT0gMCkge1xuXG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSB0aGlzLl90ZW1wbGF0ZSh0aGlzLnRlbXBsYXRlLCAncm9vdCcpO1xuICAgICAgICAgICAgaWYgKGxvY2FsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWwubGFiZWwgPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuY29kZTtcblxuICAgICAgICBpZiAoIXRoaXMucHJlZnMuZXJyb3JzLnJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5fdGVtcGxhdGUodGhpcy50ZW1wbGF0ZSkgfHxcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlKHRoaXMucHJlZnMubWVzc2FnZXMpIHx8XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSh0aGlzLm1lc3NhZ2VzKTtcblxuICAgICAgICBpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGBFcnJvciBjb2RlIFwiJHtjb2RlfVwiIGlzIG5vdCBkZWZpbmVkLCB5b3VyIGN1c3RvbSB0eXBlIGlzIG1pc3NpbmcgdGhlIGNvcnJlY3QgbWVzc2FnZXMgZGVmaW5pdGlvbmA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5kZXIgYW5kIGNhY2hlIHJlc3VsdFxuXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRlbXBsYXRlLnJlbmRlcih0aGlzLnZhbHVlLCB0aGlzLnN0YXRlLCB0aGlzLnByZWZzLCB0aGlzLmxvY2FsLCB7IGVycm9yczogdGhpcy5wcmVmcy5lcnJvcnMsIG1lc3NhZ2VzOiBbdGhpcy5wcmVmcy5tZXNzYWdlcywgdGhpcy5tZXNzYWdlc10gfSk7XG4gICAgICAgIGlmICghdGhpcy5wcmVmcy5lcnJvcnMubGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMubWVzc2FnZS5yZXBsYWNlKC9eXCJcIiAvLCAnJykudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG5cbiAgICBfdGVtcGxhdGUobWVzc2FnZXMsIGNvZGUpIHtcblxuICAgICAgICByZXR1cm4gZXhwb3J0cy50ZW1wbGF0ZSh0aGlzLnZhbHVlLCBtZXNzYWdlcywgY29kZSB8fCB0aGlzLmNvZGUsIHRoaXMuc3RhdGUsIHRoaXMucHJlZnMpO1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5wYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcblxuICAgIGxldCBsYWJlbCA9ICcnO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ29iamVjdCcpIHsgICAgICAgICAgLy8gRXhjbHVkZSBhcnJheSBzaW5nbGUgcGF0aCBzZWdtZW50XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgIGxhYmVsICs9ICcuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFiZWwgKz0gc2VnbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsICs9IGBbJHtzZWdtZW50fV1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhYmVsO1xufTtcblxuXG5leHBvcnRzLnRlbXBsYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlcywgY29kZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlcykpIHtcbiAgICAgICAgcmV0dXJuIGNvZGUgIT09ICdyb290JyA/IG1lc3NhZ2VzIDogbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgbGFuZyA9IHByZWZzLmVycm9ycy5sYW5ndWFnZTtcbiAgICBpZiAoQ29tbW9uLmlzUmVzb2x2YWJsZShsYW5nKSkge1xuICAgICAgICBsYW5nID0gbGFuZy5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIGlmIChsYW5nICYmXG4gICAgICAgIG1lc3NhZ2VzW2xhbmddICYmXG4gICAgICAgIG1lc3NhZ2VzW2xhbmddW2NvZGVdICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICByZXR1cm4gbWVzc2FnZXNbbGFuZ11bY29kZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lc3NhZ2VzW2NvZGVdO1xufTtcblxuXG5leHBvcnRzLmxhYmVsID0gZnVuY3Rpb24gKGZsYWdzLCBzdGF0ZSwgcHJlZnMsIG1lc3NhZ2VzKSB7XG5cbiAgICBpZiAoZmxhZ3MubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzLmxhYmVsO1xuICAgIH1cblxuICAgIGlmICghcHJlZnMuZXJyb3JzLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBsZXQgcGF0aCA9IHN0YXRlLnBhdGg7XG4gICAgaWYgKHByZWZzLmVycm9ycy5sYWJlbCA9PT0gJ2tleScgJiZcbiAgICAgICAgc3RhdGUucGF0aC5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgcGF0aCA9IHN0YXRlLnBhdGguc2xpY2UoLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLnBhdGgocGF0aCkgfHxcbiAgICAgICAgZXhwb3J0cy50ZW1wbGF0ZShudWxsLCBwcmVmcy5tZXNzYWdlcywgJ3Jvb3QnLCBzdGF0ZSwgcHJlZnMpIHx8XG4gICAgICAgIG1lc3NhZ2VzICYmIGV4cG9ydHMudGVtcGxhdGUobnVsbCwgbWVzc2FnZXMsICdyb290Jywgc3RhdGUsIHByZWZzKSB8fFxuICAgICAgICAndmFsdWUnO1xufTtcblxuXG5leHBvcnRzLnByb2Nlc3MgPSBmdW5jdGlvbiAoZXJyb3JzLCBvcmlnaW5hbCwgcHJlZnMpIHtcblxuICAgIGlmICghZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHsgb3ZlcnJpZGUsIG1lc3NhZ2UsIGRldGFpbHMgfSA9IGV4cG9ydHMuZGV0YWlscyhlcnJvcnMpO1xuICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGU7XG4gICAgfVxuXG4gICAgaWYgKHByZWZzLmVycm9ycy5zdGFjaykge1xuICAgICAgICByZXR1cm4gbmV3IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2UsIGRldGFpbHMsIG9yaWdpbmFsKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvciA9IG5ldyBleHBvcnRzLlZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCBkZXRhaWxzLCBvcmlnaW5hbCk7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHZhbGlkYXRpb25FcnJvcjtcbn07XG5cblxuZXhwb3J0cy5kZXRhaWxzID0gZnVuY3Rpb24gKGVycm9ycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBsZXQgbWVzc2FnZXMgPSBbXTtcbiAgICBjb25zdCBkZXRhaWxzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXJyb3JzKSB7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGVcblxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdmVycmlkZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvdmVycmlkZTogaXRlbSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblxuICAgICAgICAgICAgZGV0YWlscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdvdmVycmlkZScsXG4gICAgICAgICAgICAgICAgY29udGV4dDogeyBlcnJvcjogaXRlbSB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXBvcnRcblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXG4gICAgICAgIGRldGFpbHMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLmZpbHRlcigodikgPT4gdHlwZW9mIHYgIT09ICdvYmplY3QnKSxcbiAgICAgICAgICAgIHR5cGU6IGl0ZW0uY29kZSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGl0ZW0ubG9jYWxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbWVzc2FnZXMgPSBbLi4ubmV3IFNldChtZXNzYWdlcyldO1xuICAgIH1cblxuICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2VzLmpvaW4oJy4gJyksIGRldGFpbHMgfTtcbn07XG5cblxuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGRldGFpbHMsIG9yaWdpbmFsKSB7XG5cbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxuXG4gICAgYW5ub3RhdGUoc3RyaXBDb2xvckNvZGVzKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9vcmlnaW5hbCB8fFxuICAgICAgICAgICAgdHlwZW9mIHRoaXMuX29yaWdpbmFsICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRhaWxzWzBdLm1lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWRGZ0VzY2FwZSA9IHN0cmlwQ29sb3JDb2RlcyA/ICcnIDogJ1xcdTAwMWJbMzFtJztcbiAgICAgICAgY29uc3QgcmVkQmdFc2NhcGUgPSBzdHJpcENvbG9yQ29kZXMgPyAnJyA6ICdcXHUwMDFiWzQxbSc7XG4gICAgICAgIGNvbnN0IGVuZENvbG9yID0gc3RyaXBDb2xvckNvZGVzID8gJycgOiAnXFx1MDAxYlswbSc7XG5cbiAgICAgICAgY29uc3Qgb2JqID0gQ2xvbmUodGhpcy5fb3JpZ2luYWwpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmRldGFpbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgICAgICAgIC8vIFJldmVyc2Ugb3JkZXIgdG8gcHJvY2VzcyBkZWVwZXN0IGNoaWxkIGZpcnN0XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5kZXRhaWxzW2ldO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGVycm9yLnBhdGg7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IG9iajtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyA7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZyA9IHBhdGhbal07XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNsb25lKCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gam9pIHNjaGVtYXMgYXJlIG5vdCBjbG9uZWQgYnkgaG9laywgd2UgaGF2ZSB0byB0YWtlIHRoaXMgZXh0cmEgc3RlcFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChqICsgMSA8IHBhdGgubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBub2RlW3NlZ10gIT09ICdzdHJpbmcnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVbc2VnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZkFubm90YXRpb25zID0gbm9kZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdIHx8IHsgZXJyb3JzOiB7fSwgbWlzc2luZzoge30gfTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdID0gcmVmQW5ub3RhdGlvbnM7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzZWcgfHwgZXJyb3IuY29udGV4dC5rZXk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVbc2VnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZBbm5vdGF0aW9ucy5lcnJvcnNbY2FjaGVLZXldID0gcmVmQW5ub3RhdGlvbnMuZXJyb3JzW2NhY2hlS2V5XSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZkFubm90YXRpb25zLmVycm9yc1tjYWNoZUtleV0ucHVzaChwb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmQW5ub3RhdGlvbnMubWlzc2luZ1tjYWNoZUtleV0gPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXBsYWNlcnMgPSB7XG4gICAgICAgICAgICBrZXk6IC9fXFwka2V5XFwkXyhbLCBcXGRdKylfXFwkZW5kXFwkX1wiL2csXG4gICAgICAgICAgICBtaXNzaW5nOiAvXCJfXFwkbWlzc1xcJF8oW158XSspXFx8KFxcZCspX1xcJGVuZFxcJF9cIjogXCJfX21pc3NpbmdfX1wiL2csXG4gICAgICAgICAgICBhcnJheUluZGV4OiAvXFxzKlwiX1xcJGlkeFxcJF8oWywgXFxkXSspX1xcJGVuZFxcJF9cIiw/XFxuKC4qKS9nLFxuICAgICAgICAgICAgc3BlY2lhbHM6IC9cIlxcWyhOYU58U3ltYm9sLip8LT9JbmZpbml0eXxmdW5jdGlvbi4qfFxcKC4qKV1cIi9nXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBpbnRlcm5hbHMuc2FmZVN0cmluZ2lmeShvYmosIDIpXG4gICAgICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMua2V5LCAoJDAsICQxKSA9PiBgXCIgJHtyZWRGZ0VzY2FwZX1bJHskMX1dJHtlbmRDb2xvcn1gKVxuICAgICAgICAgICAgLnJlcGxhY2UocmVwbGFjZXJzLm1pc3NpbmcsICgkMCwgJDEsICQyKSA9PiBgJHtyZWRCZ0VzY2FwZX1cIiR7JDF9XCIke2VuZENvbG9yfSR7cmVkRmdFc2NhcGV9IFskeyQyfV06IC0tIG1pc3NpbmcgLS0ke2VuZENvbG9yfWApXG4gICAgICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuYXJyYXlJbmRleCwgKCQwLCAkMSwgJDIpID0+IGBcXG4keyQyfSAke3JlZEZnRXNjYXBlfVskeyQxfV0ke2VuZENvbG9yfWApXG4gICAgICAgICAgICAucmVwbGFjZShyZXBsYWNlcnMuc3BlY2lhbHMsICgkMCwgJDEpID0+ICQxKTtcblxuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG4ke3JlZEZnRXNjYXBlfWA7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRldGFpbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuWyR7cG9zfV0gJHt0aGlzLmRldGFpbHNbaV0ubWVzc2FnZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgKyBlbmRDb2xvcjtcblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG59O1xuXG5cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS5pc0pvaSA9IHRydWU7XG5cblxuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcblxuXG4vLyBJbnNwaXJlZCBieSBqc29uLXN0cmluZ2lmeS1zYWZlXG5cbmludGVybmFscy5zYWZlU3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgc3BhY2VzKSB7XG5cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBpbnRlcm5hbHMuc2VyaWFsaXplcigpLCBzcGFjZXMpO1xufTtcblxuXG5pbnRlcm5hbHMuc2VyaWFsaXplciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuXG4gICAgY29uc3QgY3ljbGVSZXBsYWNlciA9IChrZXksIHZhbHVlKSA9PiB7XG5cbiAgICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfl0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfi4nICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbignLicpICsgJ10nO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICBpZiAofnRoaXNQb3MpIHtcbiAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSB0aGlzUG9zICsgMTtcbiAgICAgICAgICAgICAgICBrZXlzLmxlbmd0aCA9IHRoaXNQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGtleXNbdGhpc1Bvc10gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjeWNsZVJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgYW5ub3RhdGlvbnMgPSB2YWx1ZVtpbnRlcm5hbHMuYW5ub3RhdGlvbnNdO1xuICAgICAgICAgICAgaWYgKGFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFubm90YXRlZCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9ucy5lcnJvcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZWQucHVzaChgXyRpZHgkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2ldLnNvcnQoKS5qb2luKCcsICcpfV8kZW5kJF9gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVkLnB1c2godmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhbm5vdGF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVycm9yS2V5IGluIGFubm90YXRpb25zLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYCR7ZXJyb3JLZXl9XyRrZXkkXyR7YW5ub3RhdGlvbnMuZXJyb3JzW2Vycm9yS2V5XS5zb3J0KCkuam9pbignLCAnKX1fJGVuZCRfYF0gPSB2YWx1ZVtlcnJvcktleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtlcnJvcktleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1pc3NpbmdLZXkgaW4gYW5ub3RhdGlvbnMubWlzc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbYF8kbWlzcyRfJHttaXNzaW5nS2V5fXwke2Fubm90YXRpb25zLm1pc3NpbmdbbWlzc2luZ0tleV19XyRlbmQkX2BdID0gJ19fbWlzc2luZ19fJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAtSW5maW5pdHkgfHxcbiAgICAgICAgICAgIE51bWJlci5pc05hTih2YWx1ZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgICAgICByZXR1cm4gJ1snICsgdmFsdWUudG9TdHJpbmcoKSArICddJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoZnJvbSwgb3B0aW9ucykge1xuXG4gICAgY29uc3QgYmFzZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihmcm9tKTtcbiAgICBjb25zdCBwcm90b3R5cGUgPSBDbG9uZShiYXNlKTtcbiAgICBjb25zdCBzY2hlbWEgPSBmcm9tLl9hc3NpZ24oT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpKTtcbiAgICBjb25zdCBkZWYgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGFsbG93IGNsb25lZFxuICAgIGRlbGV0ZSBkZWYuYmFzZTtcblxuICAgIHByb3RvdHlwZS5fZGVmaW5pdGlvbiA9IGRlZjtcblxuICAgIGNvbnN0IHBhcmVudCA9IGJhc2UuX2RlZmluaXRpb24gfHwge307XG4gICAgZGVmLm1lc3NhZ2VzID0gTWVzc2FnZXMubWVyZ2UocGFyZW50Lm1lc3NhZ2VzLCBkZWYubWVzc2FnZXMpO1xuICAgIGRlZi5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnByb3BlcnRpZXMsIGRlZi5wcm9wZXJ0aWVzKTtcblxuICAgIC8vIFR5cGVcblxuICAgIHNjaGVtYS50eXBlID0gZGVmLnR5cGU7XG5cbiAgICAvLyBGbGFnc1xuXG4gICAgZGVmLmZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LmZsYWdzLCBkZWYuZmxhZ3MpO1xuXG4gICAgLy8gVGVybXNcblxuICAgIGNvbnN0IHRlcm1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LnRlcm1zKTtcbiAgICBpZiAoZGVmLnRlcm1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZWYudGVybXMpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSBvd24gdGVybXNcbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBkZWYudGVybXNbbmFtZV07XG4gICAgICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXNbbmFtZV0gPT09IHVuZGVmaW5lZCwgJ0ludmFsaWQgdGVybSBvdmVycmlkZSBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBzY2hlbWEuJF90ZXJtc1tuYW1lXSA9IHRlcm0uaW5pdDtcbiAgICAgICAgICAgIHRlcm1zW25hbWVdID0gdGVybTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlZi50ZXJtcyA9IHRlcm1zO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgYXJndW1lbnRzXG5cbiAgICBpZiAoIWRlZi5hcmdzKSB7XG4gICAgICAgIGRlZi5hcmdzID0gcGFyZW50LmFyZ3M7XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZVxuXG4gICAgZGVmLnByZXBhcmUgPSBpbnRlcm5hbHMucHJlcGFyZShkZWYucHJlcGFyZSwgcGFyZW50LnByZXBhcmUpO1xuXG4gICAgLy8gQ29lcmNlXG5cbiAgICBpZiAoZGVmLmNvZXJjZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlZi5jb2VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlZi5jb2VyY2UgPSB7IG1ldGhvZDogZGVmLmNvZXJjZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZi5jb2VyY2UuZnJvbSAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoZGVmLmNvZXJjZS5mcm9tKSkge1xuXG4gICAgICAgICAgICBkZWYuY29lcmNlID0geyBtZXRob2Q6IGRlZi5jb2VyY2UubWV0aG9kLCBmcm9tOiBbXS5jb25jYXQoZGVmLmNvZXJjZS5mcm9tKSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLmNvZXJjZSA9IGludGVybmFscy5jb2VyY2UoZGVmLmNvZXJjZSwgcGFyZW50LmNvZXJjZSk7XG5cbiAgICAvLyBWYWxpZGF0ZVxuXG4gICAgZGVmLnZhbGlkYXRlID0gaW50ZXJuYWxzLnZhbGlkYXRlKGRlZi52YWxpZGF0ZSwgcGFyZW50LnZhbGlkYXRlKTtcblxuICAgIC8vIFJ1bGVzXG5cbiAgICBjb25zdCBydWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5ydWxlcyk7XG4gICAgaWYgKGRlZi5ydWxlcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmLnJ1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gZGVmLnJ1bGVzW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBydWxlID09PSAnb2JqZWN0JywgJ0ludmFsaWQgcnVsZSBkZWZpbml0aW9uIGZvcicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgbGV0IG1ldGhvZCA9IHJ1bGUubWV0aG9kO1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFwcm90b3R5cGVbbmFtZV0sICdSdWxlIGNvbmZsaWN0IGluJywgZGVmLnR5cGUsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KCFydWxlc1tuYW1lXSwgJ1J1bGUgY29uZmxpY3QgaW4nLCBkZWYudHlwZSwgbmFtZSk7XG4gICAgICAgICAgICBydWxlc1tuYW1lXSA9IHJ1bGU7XG5cbiAgICAgICAgICAgIGlmIChydWxlLmFsaWFzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXNlcyA9IFtdLmNvbmNhdChydWxlLmFsaWFzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIGFsaWFzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2FsaWFzXSA9IHJ1bGUubWV0aG9kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgIHJ1bGUuYXJnc0J5TmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBydWxlLmFyZ3MgPSBydWxlLmFyZ3MubWFwKChhcmcpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IHsgbmFtZTogYXJnIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBBc3NlcnQoIXJ1bGUuYXJnc0J5TmFtZS5oYXMoYXJnLm5hbWUpLCAnRHVwbGljYXRlZCBhcmd1bWVudCBuYW1lJywgYXJnLm5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoYXJnLmFzc2VydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZy5hc3NlcnQgPSBhcmcuYXNzZXJ0LnN0cmljdCgpLmxhYmVsKGFyZy5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXJnc0J5TmFtZS5zZXQoYXJnLm5hbWUsIGFyZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYucnVsZXMgPSBydWxlcztcblxuICAgIC8vIE1vZGlmaWVyc1xuXG4gICAgY29uc3QgbW9kaWZpZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50Lm1vZGlmaWVycyk7XG4gICAgaWYgKGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRlZi5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIEFzc2VydCghcHJvdG90eXBlW25hbWVdLCAnUnVsZSBjb25mbGljdCBpbicsIGRlZi50eXBlLCBuYW1lKTtcblxuICAgICAgICAgICAgY29uc3QgbW9kaWZpZXIgPSBkZWYubW9kaWZpZXJzW25hbWVdO1xuICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBtb2RpZmllciA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgbW9kaWZpZXIgZGVmaW5pdGlvbiBmb3InLCBkZWYudHlwZSwgbmFtZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGZ1bmN0aW9uIChhcmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bGUoeyBbbmFtZV06IGFyZyB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZDtcbiAgICAgICAgICAgIG1vZGlmaWVyc1tuYW1lXSA9IG1vZGlmaWVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVmLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIC8vIE92ZXJyaWRlc1xuXG4gICAgaWYgKGRlZi5vdmVycmlkZXMpIHtcbiAgICAgICAgcHJvdG90eXBlLl9zdXBlciA9IGJhc2U7XG4gICAgICAgIHNjaGVtYS4kX3N1cGVyID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgb3ZlcnJpZGUgaW4gZGVmLm92ZXJyaWRlcykge1xuICAgICAgICAgICAgQXNzZXJ0KGJhc2Vbb3ZlcnJpZGVdLCAnQ2Fubm90IG92ZXJyaWRlIG1pc3NpbmcnLCBvdmVycmlkZSk7XG4gICAgICAgICAgICBzY2hlbWEuJF9zdXBlcltvdmVycmlkZV0gPSBiYXNlW292ZXJyaWRlXS5iaW5kKHNjaGVtYSk7XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKHByb3RvdHlwZSwgZGVmLm92ZXJyaWRlcyk7XG4gICAgfVxuXG4gICAgLy8gQ2FzdHNcblxuICAgIGRlZi5jYXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50LmNhc3QsIGRlZi5jYXN0KTtcblxuICAgIC8vIE1hbmlmZXN0XG5cbiAgICBjb25zdCBtYW5pZmVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudC5tYW5pZmVzdCwgZGVmLm1hbmlmZXN0KTtcbiAgICBtYW5pZmVzdC5idWlsZCA9IGludGVybmFscy5idWlsZChkZWYubWFuaWZlc3QgJiYgZGVmLm1hbmlmZXN0LmJ1aWxkLCBwYXJlbnQubWFuaWZlc3QgJiYgcGFyZW50Lm1hbmlmZXN0LmJ1aWxkKTtcbiAgICBkZWYubWFuaWZlc3QgPSBtYW5pZmVzdDtcblxuICAgIC8vIFJlYnVpbGRcblxuICAgIGRlZi5yZWJ1aWxkID0gaW50ZXJuYWxzLnJlYnVpbGQoZGVmLnJlYnVpbGQsIHBhcmVudC5yZWJ1aWxkKTtcblxuICAgIHJldHVybiBzY2hlbWE7XG59O1xuXG5cbi8vIEhlbHBlcnNcblxuaW50ZXJuYWxzLmJ1aWxkID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gcGFyZW50KGNoaWxkKG9iaiwgZGVzYyksIGRlc2MpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5jb2VyY2UgPSBmdW5jdGlvbiAoY2hpbGQsIHBhcmVudCkge1xuXG4gICAgaWYgKCFjaGlsZCB8fFxuICAgICAgICAhcGFyZW50KSB7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tOiBjaGlsZC5mcm9tICYmIHBhcmVudC5mcm9tID8gWy4uLm5ldyBTZXQoWy4uLmNoaWxkLmZyb20sIC4uLnBhcmVudC5mcm9tXSldIDogbnVsbCxcbiAgICAgICAgbWV0aG9kKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgIGxldCBjb2VyY2VkO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC5mcm9tLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSkpIHtcblxuICAgICAgICAgICAgICAgIGNvZXJjZWQgPSBwYXJlbnQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAoY29lcmNlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29lcmNlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZXJjZWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29lcmNlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2hpbGQuZnJvbSB8fFxuICAgICAgICAgICAgICAgIGNoaWxkLmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb3duID0gY2hpbGQubWV0aG9kKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgICAgICBpZiAob3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvd247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cbmludGVybmFscy5wcmVwYXJlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gY2hpbGQodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocHJlcGFyZWQpIHtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZC5lcnJvcnMgfHxcbiAgICAgICAgICAgICAgICBwcmVwYXJlZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlcGFyZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gcHJlcGFyZWQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50KHZhbHVlLCBoZWxwZXJzKSB8fCBwcmVwYXJlZDtcbiAgICB9O1xufTtcblxuXG5pbnRlcm5hbHMucmVidWlsZCA9IGZ1bmN0aW9uIChjaGlsZCwgcGFyZW50KSB7XG5cbiAgICBpZiAoIWNoaWxkIHx8XG4gICAgICAgICFwYXJlbnQpIHtcblxuICAgICAgICByZXR1cm4gY2hpbGQgfHwgcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICAgICAgcGFyZW50KHNjaGVtYSk7XG4gICAgICAgIGNoaWxkKHNjaGVtYSk7XG4gICAgfTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKGNoaWxkLCBwYXJlbnQpIHtcblxuICAgIGlmICghY2hpbGQgfHxcbiAgICAgICAgIXBhcmVudCkge1xuXG4gICAgICAgIHJldHVybiBjaGlsZCB8fCBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcmVudCh2YWx1ZSwgaGVscGVycyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3JzICYmXG4gICAgICAgICAgICAgICAgKCFBcnJheS5pc0FycmF5KHJlc3VsdC5lcnJvcnMpIHx8IHJlc3VsdC5lcnJvcnMubGVuZ3RoKSkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hpbGQodmFsdWUsIGhlbHBlcnMpIHx8IHJlc3VsdDtcbiAgICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5cbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFeHRlbmQgPSByZXF1aXJlKCcuL2V4dGVuZCcpO1xuY29uc3QgTWFuaWZlc3QgPSByZXF1aXJlKCcuL21hbmlmZXN0Jyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5jb25zdCBUcmFjZSA9IHJlcXVpcmUoJy4vdHJhY2UnKTtcblxubGV0IFNjaGVtYXM7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHR5cGVzOiB7XG4gICAgICAgIGFsdGVybmF0aXZlczogcmVxdWlyZSgnLi90eXBlcy9hbHRlcm5hdGl2ZXMnKSxcbiAgICAgICAgYW55OiByZXF1aXJlKCcuL3R5cGVzL2FueScpLFxuICAgICAgICBhcnJheTogcmVxdWlyZSgnLi90eXBlcy9hcnJheScpLFxuICAgICAgICBib29sZWFuOiByZXF1aXJlKCcuL3R5cGVzL2Jvb2xlYW4nKSxcbiAgICAgICAgZGF0ZTogcmVxdWlyZSgnLi90eXBlcy9kYXRlJyksXG4gICAgICAgIGZ1bmN0aW9uOiByZXF1aXJlKCcuL3R5cGVzL2Z1bmN0aW9uJyksXG4gICAgICAgIGxpbms6IHJlcXVpcmUoJy4vdHlwZXMvbGluaycpLFxuICAgICAgICBudW1iZXI6IHJlcXVpcmUoJy4vdHlwZXMvbnVtYmVyJyksXG4gICAgICAgIG9iamVjdDogcmVxdWlyZSgnLi90eXBlcy9vYmplY3QnKSxcbiAgICAgICAgc3RyaW5nOiByZXF1aXJlKCcuL3R5cGVzL3N0cmluZycpLFxuICAgICAgICBzeW1ib2w6IHJlcXVpcmUoJy4vdHlwZXMvc3ltYm9sJylcbiAgICB9XG59O1xuXG5cbmlmIChCdWZmZXIpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGludGVybmFscy50eXBlcy5iaW5hcnkgPSByZXF1aXJlKCcuL3R5cGVzL2JpbmFyeScpO1xufVxuXG5cbmludGVybmFscy5yb290ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc3Qgcm9vdCA9IHtcbiAgICAgICAgX3R5cGVzOiBuZXcgU2V0KE9iamVjdC5rZXlzKGludGVybmFscy50eXBlcykpXG4gICAgfTtcblxuICAgIC8vIFR5cGVzXG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygcm9vdC5fdHlwZXMpIHtcbiAgICAgICAgcm9vdFt0eXBlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCghYXJncy5sZW5ndGggfHwgWydhbHRlcm5hdGl2ZXMnLCAnbGluaycsICdvYmplY3QnXS5pbmNsdWRlcyh0eXBlKSwgJ1RoZScsIHR5cGUsICd0eXBlIGRvZXMgbm90IGFsbG93IGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBpbnRlcm5hbHMudHlwZXNbdHlwZV0sIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIFNob3J0Y3V0c1xuXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgWydhbGxvdycsICdjdXN0b20nLCAnZGlzYWxsb3cnLCAnZXF1YWwnLCAnZXhpc3QnLCAnZm9yYmlkZGVuJywgJ2ludmFsaWQnLCAnbm90JywgJ29ubHknLCAnb3B0aW9uYWwnLCAnb3B0aW9ucycsICdwcmVmcycsICdwcmVmZXJlbmNlcycsICdyZXF1aXJlZCcsICdzdHJpcCcsICd2YWxpZCcsICd3aGVuJ10pIHtcbiAgICAgICAgcm9vdFttZXRob2RdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW55KClbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNZXRob2RzXG5cbiAgICBPYmplY3QuYXNzaWduKHJvb3QsIGludGVybmFscy5tZXRob2RzKTtcblxuICAgIC8vIEFsaWFzZXNcblxuICAgIHJvb3QuYWx0ID0gcm9vdC5hbHRlcm5hdGl2ZXM7XG4gICAgcm9vdC5ib29sID0gcm9vdC5ib29sZWFuO1xuICAgIHJvb3QuZnVuYyA9IHJvb3QuZnVuY3Rpb247XG4gICAgcm9vdC54ID0gcm9vdC5leHByZXNzaW9uO1xuXG4gICAgLy8gVHJhY2VcblxuICAgIGlmIChUcmFjZS5zZXR1cCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICBUcmFjZS5zZXR1cChyb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbn07XG5cblxuaW50ZXJuYWxzLm1ldGhvZHMgPSB7XG5cbiAgICBWYWxpZGF0aW9uRXJyb3I6IEVycm9ycy5WYWxpZGF0aW9uRXJyb3IsXG4gICAgdmVyc2lvbjogQ29tbW9uLnZlcnNpb24sXG4gICAgY2FjaGU6IENhY2hlLnByb3ZpZGVyLFxuXG4gICAgYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICBpbnRlcm5hbHMuYXNzZXJ0KHZhbHVlLCBzY2hlbWEsIHRydWUsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBhdHRlbXB0KHZhbHVlLCBzY2hlbWEsIC4uLmFyZ3MgLyogW21lc3NhZ2VdLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmFzc2VydCh2YWx1ZSwgc2NoZW1hLCBmYWxzZSwgYXJncyk7XG4gICAgfSxcblxuICAgIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICBBc3NlcnQodHlwZW9mIE1hbmlmZXN0LmJ1aWxkID09PSAnZnVuY3Rpb24nLCAnTWFuaWZlc3QgZnVuY3Rpb25hbGl0eSBkaXNhYmxlZCcpO1xuICAgICAgICByZXR1cm4gTWFuaWZlc3QuYnVpbGQodGhpcywgZGVzYyk7XG4gICAgfSxcblxuICAgIGNoZWNrUHJlZmVyZW5jZXMocHJlZnMpIHtcblxuICAgICAgICBDb21tb24uY2hlY2tQcmVmZXJlbmNlcyhwcmVmcyk7XG4gICAgfSxcblxuICAgIGNvbXBpbGUoc2NoZW1hLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIENvbXBpbGUuY29tcGlsZSh0aGlzLCBzY2hlbWEsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0cyhtb2RpZmllcikge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2YgbW9kaWZpZXIgPT09ICdmdW5jdGlvbicsICdtb2RpZmllciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICAgICAgICBjb25zdCBqb2kgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGpvaS5fdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IG1vZGlmaWVyKGpvaVt0eXBlXSgpKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc2NoZW1hKSwgJ21vZGlmaWVyIG11c3QgcmV0dXJuIGEgdmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuXG4gICAgICAgICAgICBqb2lbdHlwZV0gPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZSh0aGlzLCBzY2hlbWEsIGFyZ3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqb2k7XG4gICAgfSxcblxuICAgIGV4cHJlc3Npb24oLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoLi4uYXJncyk7XG4gICAgfSxcblxuICAgIGV4dGVuZCguLi5leHRlbnNpb25zKSB7XG5cbiAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoZXh0ZW5zaW9ucywgJ2V4dGVuZCcpO1xuXG4gICAgICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgICAgIEFzc2VydChleHRlbnNpb25zLmxlbmd0aCwgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYXQgbGVhc3Qgb25lIGV4dGVuc2lvbicpO1xuICAgICAgICB0aGlzLmFzc2VydChleHRlbnNpb25zLCBTY2hlbWFzLmV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGNvbnN0IGpvaSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMpO1xuICAgICAgICBqb2kuX3R5cGVzID0gbmV3IFNldChqb2kuX3R5cGVzKTtcblxuICAgICAgICBmb3IgKGxldCBleHRlbnNpb24gb2YgZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBleHRlbnNpb24oam9pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hc3NlcnQoZXh0ZW5zaW9uLCBTY2hlbWFzLmV4dGVuc2lvbik7XG5cbiAgICAgICAgICAgIEFzc2VydChqb2lbZXh0ZW5zaW9uLnR5cGVdID09PSB1bmRlZmluZWQgfHwgam9pLl90eXBlcy5oYXMoZXh0ZW5zaW9uLnR5cGUpLCAnQ2Fubm90IG92ZXJyaWRlIG5hbWUnLCBleHRlbnNpb24udHlwZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBleHRlbnNpb24uYmFzZSB8fCB0aGlzLmFueSgpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gRXh0ZW5kLnR5cGUoYmFzZSwgZXh0ZW5zaW9uKTtcblxuICAgICAgICAgICAgam9pLl90eXBlcy5hZGQoZXh0ZW5zaW9uLnR5cGUpO1xuICAgICAgICAgICAgam9pW2V4dGVuc2lvbi50eXBlXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmdlbmVyYXRlKHRoaXMsIHNjaGVtYSwgYXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpvaTtcbiAgICB9LFxuXG4gICAgaXNFeHByZXNzaW9uOiBUZW1wbGF0ZS5pc1RlbXBsYXRlLFxuICAgIGlzUmVmOiBSZWYuaXNSZWYsXG4gICAgaXNTY2hlbWE6IENvbW1vbi5pc1NjaGVtYSxcblxuICAgIGluKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gUmVmLmluKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICBvdmVycmlkZTogQ29tbW9uLnN5bWJvbHMub3ZlcnJpZGUsXG5cbiAgICByZWYoLi4uYXJncykge1xuXG4gICAgICAgIHJldHVybiBSZWYuY3JlYXRlKC4uLmFyZ3MpO1xuICAgIH0sXG5cbiAgICB0eXBlcygpIHtcblxuICAgICAgICBjb25zdCB0eXBlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy5fdHlwZXMpIHtcbiAgICAgICAgICAgIHR5cGVzW3R5cGVdID0gdGhpc1t0eXBlXSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbn07XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuYXNzZXJ0ID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIGFubm90YXRlLCBhcmdzIC8qIFttZXNzYWdlXSwgW29wdGlvbnNdICovKSB7XG5cbiAgICBjb25zdCBtZXNzYWdlID0gYXJnc1swXSBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3NbMF0gOiBudWxsO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXNzYWdlID8gYXJnc1sxXSA6IGFyZ3NbMF07XG4gICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLnZhbGlkYXRlKHZhbHVlLCBDb21tb24ucHJlZmVyZW5jZXMoeyBlcnJvcnM6IHsgc3RhY2s6IHRydWUgfSB9LCBvcHRpb25zIHx8IHt9KSk7XG5cbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICB9XG5cbiAgICBhbm5vdGF0ZSA9IGFubm90YXRlICYmIHR5cGVvZiBlcnJvci5hbm5vdGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICBjb25zdCBkaXNwbGF5ID0gYW5ub3RhdGUgPyBlcnJvci5hbm5vdGF0ZSgpIDogZXJyb3IubWVzc2FnZTtcblxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9ycy5WYWxpZGF0aW9uRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgIGVycm9yID0gQ2xvbmUoZXJyb3IpO1xuICAgIH1cblxuICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlID8gYCR7bWVzc2FnZX0gJHtkaXNwbGF5fWAgOiBkaXNwbGF5O1xuICAgIHRocm93IGVycm9yO1xufTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAocm9vdCwgc2NoZW1hLCBhcmdzKSB7XG5cbiAgICBBc3NlcnQocm9vdCwgJ011c3QgYmUgaW52b2tlZCBvbiBhIEpvaSBpbnN0YW5jZS4nKTtcblxuICAgIHNjaGVtYS4kX3Jvb3QgPSByb290O1xuXG4gICAgaWYgKCFzY2hlbWEuX2RlZmluaXRpb24uYXJncyB8fFxuICAgICAgICAhYXJncy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWEuX2RlZmluaXRpb24uYXJncyhzY2hlbWEsIC4uLmFyZ3MpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5yb290KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgTWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbmxldCBTY2hlbWFzO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuZGVzY3JpYmUgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG5cbiAgICAvLyBUeXBlXG5cbiAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICB0eXBlOiBzY2hlbWEudHlwZSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICBydWxlczogW11cbiAgICB9O1xuXG4gICAgLy8gRmxhZ3NcblxuICAgIGZvciAoY29uc3QgZmxhZyBpbiBzY2hlbWEuX2ZsYWdzKSB7XG4gICAgICAgIGlmIChmbGFnWzBdICE9PSAnXycpIHtcbiAgICAgICAgICAgIGRlc2MuZmxhZ3NbZmxhZ10gPSBpbnRlcm5hbHMuZGVzY3JpYmUoc2NoZW1hLl9mbGFnc1tmbGFnXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKGRlc2MuZmxhZ3MpLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgZGVzYy5mbGFncztcbiAgICB9XG5cbiAgICAvLyBQcmVmZXJlbmNlc1xuXG4gICAgaWYgKHNjaGVtYS5fcHJlZmVyZW5jZXMpIHtcbiAgICAgICAgZGVzYy5wcmVmZXJlbmNlcyA9IENsb25lKHNjaGVtYS5fcHJlZmVyZW5jZXMsIHsgc2hhbGxvdzogWydtZXNzYWdlcyddIH0pO1xuICAgICAgICBkZWxldGUgZGVzYy5wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc107XG4gICAgICAgIGlmIChkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBkZXNjLnByZWZlcmVuY2VzLm1lc3NhZ2VzID0gTWVzc2FnZXMuZGVjb21waWxlKGRlc2MucHJlZmVyZW5jZXMubWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgLyBJbnZhbGlkXG5cbiAgICBpZiAoc2NoZW1hLl92YWxpZHMpIHtcbiAgICAgICAgZGVzYy5hbGxvdyA9IHNjaGVtYS5fdmFsaWRzLmRlc2NyaWJlKCk7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVtYS5faW52YWxpZHMpIHtcbiAgICAgICAgZGVzYy5pbnZhbGlkID0gc2NoZW1hLl9pbnZhbGlkcy5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIC8vIFJ1bGVzXG5cbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2Ygc2NoZW1hLl9ydWxlcykge1xuICAgICAgICBjb25zdCBydWxlRGVmID0gZGVmLnJ1bGVzW3J1bGUubmFtZV07XG4gICAgICAgIGlmIChydWxlRGVmLm1hbmlmZXN0ID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXRlbSA9IHsgbmFtZTogcnVsZS5uYW1lIH07XG5cbiAgICAgICAgZm9yIChjb25zdCBjdXN0b20gaW4gZGVmLm1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKHJ1bGVbY3VzdG9tXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbVtjdXN0b21dID0gaW50ZXJuYWxzLmRlc2NyaWJlKHJ1bGVbY3VzdG9tXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICBpdGVtLmFyZ3MgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZyA9IHJ1bGUuYXJnc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdvcHRpb25zJyAmJlxuICAgICAgICAgICAgICAgICAgICAhT2JqZWN0LmtleXMoYXJnKS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtLmFyZ3Nba2V5XSA9IGludGVybmFscy5kZXNjcmliZShhcmcsIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXMoaXRlbS5hcmdzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXRlbS5hcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVzYy5ydWxlcy5wdXNoKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmICghZGVzYy5ydWxlcy5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGRlc2MucnVsZXM7XG4gICAgfVxuXG4gICAgLy8gVGVybXMgKG11c3QgYmUgbGFzdCB0byB2ZXJpZnkgbm8gbmFtZSBjb25mbGljdHMpXG5cbiAgICBmb3IgKGNvbnN0IHRlcm0gaW4gc2NoZW1hLiRfdGVybXMpIHtcbiAgICAgICAgaWYgKHRlcm1bMF0gPT09ICdfJykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQoIWRlc2NbdGVybV0sICdDYW5ub3QgZGVzY3JpYmUgc2NoZW1hIGR1ZSB0byBpbnRlcm5hbCBuYW1lIGNvbmZsaWN0IHdpdGgnLCB0ZXJtKTtcblxuICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS4kX3Rlcm1zW3Rlcm1dO1xuICAgICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgaWYgKGl0ZW1zLnNpemUpIHtcbiAgICAgICAgICAgICAgICBkZXNjW3Rlcm1dID0gWy4uLml0ZW1zLmVudHJpZXMoKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1ZhbHVlcyhpdGVtcykpIHtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSBpdGVtcy5kZXNjcmliZSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQoZGVmLnRlcm1zW3Rlcm1dLCAnVGVybScsIHRlcm0sICdtaXNzaW5nIGNvbmZpZ3VyYXRpb24nKTtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBkZWYudGVybXNbdGVybV0ubWFuaWZlc3Q7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IHR5cGVvZiBtYW5pZmVzdCA9PT0gJ29iamVjdCc7XG4gICAgICAgIGlmICghaXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICAhbWFwcGVkKSB7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChpbnRlcm5hbHMuZGVzY3JpYmUoaXRlbSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFwcGVkXG5cbiAgICAgICAgaWYgKG1hcHBlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gbWFuaWZlc3QubWFwcGVkO1xuICAgICAgICAgICAgZGVzY1t0ZXJtXSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICBkZXNjW3Rlcm1dW2l0ZW1bdG9dXSA9IGl0ZW1bZnJvbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlXG5cbiAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgQXNzZXJ0KG5vcm1hbGl6ZWQubGVuZ3RoID09PSAxLCAnVGVybScsIHRlcm0sICdjb250YWlucyBtb3JlIHRoYW4gb25lIGl0ZW0nKTtcbiAgICAgICAgICAgIGRlc2NbdGVybV0gPSBub3JtYWxpemVkWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGRlc2NbdGVybV0gPSBub3JtYWxpemVkO1xuICAgIH1cblxuICAgIGludGVybmFscy52YWxpZGF0ZShzY2hlbWEuJF9yb290LCBkZXNjKTtcbiAgICByZXR1cm4gZGVzYztcbn07XG5cblxuaW50ZXJuYWxzLmRlc2NyaWJlID0gZnVuY3Rpb24gKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubWFwKGludGVybmFscy5kZXNjcmliZSk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gPT09IENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiB7IHNwZWNpYWw6ICdkZWVwJyB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgcmV0dXJuIENsb25lKGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKGl0ZW0pKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcbiAgICAgICAgcmV0dXJuIHsgYnVmZmVyOiBpdGVtLnRvU3RyaW5nKCdiaW5hcnknKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVnZXgnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgcmVnZXg6IGl0ZW0udG9TdHJpbmcoKSB9O1xuICAgIH1cblxuICAgIGlmIChpdGVtW0NvbW1vbi5zeW1ib2xzLmxpdGVyYWxdKSB7XG4gICAgICAgIHJldHVybiB7IGZ1bmN0aW9uOiBpdGVtLmxpdGVyYWwgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGl0ZW0uZGVzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzaWduID09PSAncmVmJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGVzY3JpYmUoKS5yZWY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbS5kZXNjcmliZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpdGVtKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXRlbVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpbnRlcm5hbHMuZGVzY3JpYmUodmFsdWUsIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59O1xuXG5cbmV4cG9ydHMuYnVpbGQgPSBmdW5jdGlvbiAoam9pLCBkZXNjKSB7XG5cbiAgICBjb25zdCBidWlsZGVyID0gbmV3IGludGVybmFscy5CdWlsZGVyKGpvaSk7XG4gICAgcmV0dXJuIGJ1aWxkZXIucGFyc2UoZGVzYyk7XG59O1xuXG5cbmludGVybmFscy5CdWlsZGVyID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Ioam9pKSB7XG5cbiAgICAgICAgdGhpcy5qb2kgPSBqb2k7XG4gICAgfVxuXG4gICAgcGFyc2UoZGVzYykge1xuXG4gICAgICAgIGludGVybmFscy52YWxpZGF0ZSh0aGlzLmpvaSwgZGVzYyk7XG5cbiAgICAgICAgLy8gVHlwZVxuXG4gICAgICAgIGxldCBzY2hlbWEgPSB0aGlzLmpvaVtkZXNjLnR5cGVdKCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fZGVmaW5pdGlvbjtcblxuICAgICAgICAvLyBGbGFnc1xuXG4gICAgICAgIGlmIChkZXNjLmZsYWdzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZsYWcgaW4gZGVzYy5mbGFncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRlciA9IGRlZi5mbGFnc1tmbGFnXSAmJiBkZWYuZmxhZ3NbZmxhZ10uc2V0dGVyIHx8IGZsYWc7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBzY2hlbWFbc2V0dGVyXSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgZmxhZycsIGZsYWcsICdmb3IgdHlwZScsIGRlc2MudHlwZSk7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hW3NldHRlcl0odGhpcy5idWlsZChkZXNjLmZsYWdzW2ZsYWddKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmVmZXJlbmNlc1xuXG4gICAgICAgIGlmIChkZXNjLnByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEucHJlZmVyZW5jZXModGhpcy5idWlsZChkZXNjLnByZWZlcmVuY2VzKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGxvdyAvIEludmFsaWRcblxuICAgICAgICBpZiAoZGVzYy5hbGxvdykge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLmFsbG93KC4uLnRoaXMuYnVpbGQoZGVzYy5hbGxvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MuaW52YWxpZCkge1xuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hLmludmFsaWQoLi4udGhpcy5idWlsZChkZXNjLmludmFsaWQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJ1bGVzXG5cbiAgICAgICAgaWYgKGRlc2MucnVsZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBkZXNjLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBzY2hlbWFbcnVsZS5uYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJ0ludmFsaWQgcnVsZScsIHJ1bGUubmFtZSwgJ2ZvciB0eXBlJywgZGVzYy50eXBlKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1aWx0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGUuYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbHRba2V5XSA9IHRoaXMuYnVpbGQocnVsZS5hcmdzW2tleV0sIHsgYXNzaWduOiBrZXkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYnVpbHQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmLnJ1bGVzW3J1bGUubmFtZV0uYXJncztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXlzLmxlbmd0aCA8PSBkZWZpbml0aW9uLmxlbmd0aCwgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3InLCBkZXNjLnR5cGUsIHJ1bGUubmFtZSwgJyhleHBlY3RlZCB1cCB0bycsIGRlZmluaXRpb24ubGVuZ3RoLCAnLCBmb3VuZCcsIGtleXMubGVuZ3RoLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IG5hbWUgfSBvZiBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWx0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChrZXlzLmxlbmd0aCA9PT0gMSwgJ0ludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3InLCBkZXNjLnR5cGUsIHJ1bGUubmFtZSwgJyhleHBlY3RlZCB1cCB0byAxLCBmb3VuZCcsIGtleXMubGVuZ3RoLCAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGJ1aWx0W2tleXNbMF1dKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWFbcnVsZS5uYW1lXSguLi5hcmdzKTtcblxuICAgICAgICAgICAgICAgIC8vIFJ1bGVzZXRcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGN1c3RvbSBpbiBkZWYubW9kaWZpZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlW2N1c3RvbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tjdXN0b21dID0gdGhpcy5idWlsZChydWxlW2N1c3RvbV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWEgPSBzY2hlbWEucnVsZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXJtc1xuXG4gICAgICAgIGNvbnN0IHRlcm1zID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlc2MpIHtcbiAgICAgICAgICAgIGlmIChbJ2FsbG93JywgJ2ZsYWdzJywgJ2ludmFsaWQnLCAnd2hlbnMnLCAncHJlZmVyZW5jZXMnLCAncnVsZXMnLCAndHlwZSddLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQXNzZXJ0KGRlZi50ZXJtc1trZXldLCAnVGVybScsIGtleSwgJ21pc3NpbmcgY29uZmlndXJhdGlvbicpO1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBkZWYudGVybXNba2V5XS5tYW5pZmVzdDtcblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2NoZW1hJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSBkZXNjW2tleV0ubWFwKChpdGVtKSA9PiB0aGlzLnBhcnNlKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAndmFsdWVzJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSBkZXNjW2tleV0ubWFwKChpdGVtKSA9PiB0aGlzLmJ1aWxkKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1hbmlmZXN0ID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHRlcm1zW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFuaWZlc3QgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGVybXNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkZXNjW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZXNjW2tleV1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRlcm1zW2tleV1bbmFtZV0gPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVybXNba2V5XSA9IHRoaXMuYnVpbGQoZGVzY1trZXldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXNjLndoZW5zKSB7XG4gICAgICAgICAgICB0ZXJtcy53aGVucyA9IGRlc2Mud2hlbnMubWFwKCh3aGVuKSA9PiB0aGlzLmJ1aWxkKHdoZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVtYSA9IGRlZi5tYW5pZmVzdC5idWlsZChzY2hlbWEsIHRlcm1zKTtcbiAgICAgICAgc2NoZW1hLiRfdGVtcC5ydWxlc2V0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuXG4gICAgYnVpbGQoZGVzYywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKGRlc2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVzYykpIHtcbiAgICAgICAgICAgIHJldHVybiBkZXNjLm1hcCgoaXRlbSkgPT4gdGhpcy5idWlsZChpdGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFzc2lnbiA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWdleCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMucmVnZXgoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hc3NpZ24gPT09ICdyZWYnKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmLmJ1aWxkKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXNjICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVzYykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoZGVzYy5idWZmZXIpIHtcbiAgICAgICAgICAgICAgICBBc3NlcnQoQnVmZmVyLCAnQnVmZmVycyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIgJiYgQnVmZmVyLmZyb20oZGVzYy5idWZmZXIsICdiaW5hcnknKTsgICAgICAgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5mdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IFtDb21tb24uc3ltYm9scy5saXRlcmFsXTogdHJ1ZSwgbGl0ZXJhbDogZGVzYy5mdW5jdGlvbiB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGVzYy5vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tb24uc3ltYm9scy5vdmVycmlkZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZi5idWlsZChkZXNjLnJlZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5yZWdleChkZXNjLnJlZ2V4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2Muc3BlY2lhbCkge1xuICAgICAgICAgICAgICAgIEFzc2VydChbJ2RlZXAnXS5pbmNsdWRlcyhkZXNjLnNwZWNpYWwpLCAnVW5rbm93biBzcGVjaWFsIHZhbHVlJywgZGVzYy5zcGVjaWFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENsb25lKGRlc2MudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc2MudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoZGVzYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVzYy50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlLmJ1aWxkKGRlc2MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkW2tleV0gPSB0aGlzLmJ1aWxkKGRlc2Nba2V5XSwgeyBhc3NpZ246IGtleSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnJlZ2V4ID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgY29uc3QgZW5kID0gc3RyaW5nLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgY29uc3QgZXhwID0gc3RyaW5nLnNsaWNlKDEsIGVuZCk7XG4gICAgY29uc3QgZmxhZ3MgPSBzdHJpbmcuc2xpY2UoZW5kICsgMSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoZXhwLCBmbGFncyk7XG59O1xuXG5cbmludGVybmFscy52YWxpZGF0ZSA9IGZ1bmN0aW9uIChqb2ksIGRlc2MpIHtcblxuICAgIFNjaGVtYXMgPSBTY2hlbWFzIHx8IHJlcXVpcmUoJy4vc2NoZW1hcycpO1xuXG4gICAgam9pLmFzc2VydChkZXNjLCBTY2hlbWFzLmRlc2NyaXB0aW9uKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgQ2xvbmUgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9jbG9uZScpO1xuXG5jb25zdCBUZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAobWVzc2FnZXMsIHRhcmdldCkge1xuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHN0cmluZyAoJ3BsYWluIGVycm9yIG1lc3NhZ2UnLCAndGVtcGxhdGUge2Vycm9yfSBtZXNzYWdlJylcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIEFzc2VydCghdGFyZ2V0LCAnQ2Fubm90IHNldCBzaW5nbGUgbWVzc2FnZSBzdHJpbmcnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShtZXNzYWdlcyk7XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHZhbHVlIHRlbXBsYXRlXG5cbiAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlcykpIHtcbiAgICAgICAgQXNzZXJ0KCF0YXJnZXQsICdDYW5ub3Qgc2V0IHNpbmdsZSBtZXNzYWdlIHRlbXBsYXRlJyk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIEFzc2VydCh0eXBlb2YgbWVzc2FnZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2VzKSwgJ0ludmFsaWQgbWVzc2FnZSBvcHRpb25zJyk7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgPyBDbG9uZSh0YXJnZXQpIDoge307XG5cbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKG1lc3NhZ2UpKSB7XG5cbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRhcmdldFtjb2RlXSA9IG5ldyBUZW1wbGF0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnkgbGFuZ3VhZ2UgeyBlbmdsaXNoOiB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9IH1cblxuICAgICAgICBBc3NlcnQodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG1lc3NhZ2UpLCAnSW52YWxpZCBtZXNzYWdlIGZvcicsIGNvZGUpO1xuXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gY29kZTtcbiAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXSA9IHRhcmdldFtsYW5ndWFnZV0gfHwge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcgfHxcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5pc1RlbXBsYXRlKGxvY2FsaXplZCkpIHtcblxuICAgICAgICAgICAgICAgIHRhcmdldFtsYW5ndWFnZV1bY29kZV0gPSBsb2NhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgbG9jYWxpemVkID09PSAnc3RyaW5nJywgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlLCAnaW4nLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbmV3IFRlbXBsYXRlKGxvY2FsaXplZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5leHBvcnRzLmRlY29tcGlsZSA9IGZ1bmN0aW9uIChtZXNzYWdlcykge1xuXG4gICAgLy8gQnkgZXJyb3IgY29kZSB7ICdudW1iZXIubWluJzogPHN0cmluZyB8IHRlbXBsYXRlPiB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGxldCBjb2RlIGluIG1lc3NhZ2VzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGFyZ2V0W2NvZGVdID0gbWVzc2FnZS5kZXNjcmliZSh7IGNvbXBhY3Q6IHRydWUgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBjb2RlO1xuICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdID0ge307XG5cbiAgICAgICAgZm9yIChjb2RlIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsaXplZCA9IG1lc3NhZ2VbY29kZV07XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkLmRlc2NyaWJlKHsgY29tcGFjdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoYmFzZSwgZXh0ZW5kZWQpIHtcblxuICAgIGlmICghYmFzZSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5jb21waWxlKGV4dGVuZGVkKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSBzdHJpbmdcblxuICAgIGlmICh0eXBlb2YgZXh0ZW5kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUoZXh0ZW5kZWQpO1xuICAgIH1cblxuICAgIC8vIFNpbmdsZSB2YWx1ZSB0ZW1wbGF0ZVxuXG4gICAgaWYgKFRlbXBsYXRlLmlzVGVtcGxhdGUoZXh0ZW5kZWQpKSB7XG4gICAgICAgIHJldHVybiBleHRlbmRlZDtcbiAgICB9XG5cbiAgICAvLyBCeSBlcnJvciBjb2RlIHsgJ251bWJlci5taW4nOiA8c3RyaW5nIHwgdGVtcGxhdGU+IH1cblxuICAgIGNvbnN0IHRhcmdldCA9IENsb25lKGJhc2UpO1xuXG4gICAgZm9yIChsZXQgY29kZSBpbiBleHRlbmRlZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXh0ZW5kZWRbY29kZV07XG5cbiAgICAgICAgaWYgKGNvZGUgPT09ICdyb290JyB8fFxuICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShtZXNzYWdlKSkge1xuXG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0YXJnZXRbY29kZV0gPSBuZXcgVGVtcGxhdGUobWVzc2FnZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ5IGxhbmd1YWdlIHsgZW5nbGlzaDogeyAnbnVtYmVyLm1pbic6IDxzdHJpbmcgfCB0ZW1wbGF0ZT4gfSB9XG5cbiAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShtZXNzYWdlKSwgJ0ludmFsaWQgbWVzc2FnZSBmb3InLCBjb2RlKTtcblxuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGNvZGU7XG4gICAgICAgIHRhcmdldFtsYW5ndWFnZV0gPSB0YXJnZXRbbGFuZ3VhZ2VdIHx8IHt9O1xuXG4gICAgICAgIGZvciAoY29kZSBpbiBtZXNzYWdlKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGl6ZWQgPSBtZXNzYWdlW2NvZGVdO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gJ3Jvb3QnIHx8XG4gICAgICAgICAgICAgICAgVGVtcGxhdGUuaXNUZW1wbGF0ZShsb2NhbGl6ZWQpKSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXRbbGFuZ3VhZ2VdW2NvZGVdID0gbG9jYWxpemVkO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBc3NlcnQodHlwZW9mIGxvY2FsaXplZCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIG1lc3NhZ2UgZm9yJywgY29kZSwgJ2luJywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdGFyZ2V0W2xhbmd1YWdlXVtjb2RlXSA9IG5ldyBUZW1wbGF0ZShsb2NhbGl6ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgUmVmID0gcmVxdWlyZSgnLi9yZWYnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5cbmV4cG9ydHMuSWRzID0gaW50ZXJuYWxzLklkcyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX2J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2J5S2V5ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IGNsb25lID0gbmV3IGludGVybmFscy5JZHMoKTtcbiAgICAgICAgY2xvbmUuX2J5SWQgPSBuZXcgTWFwKHRoaXMuX2J5SWQpO1xuICAgICAgICBjbG9uZS5fYnlLZXkgPSBuZXcgTWFwKHRoaXMuX2J5S2V5KTtcbiAgICAgICAgY2xvbmUuX3NjaGVtYUNoYWluID0gdGhpcy5fc2NoZW1hQ2hhaW47XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgaWYgKHNvdXJjZS5fc2NoZW1hQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVtYUNoYWluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW2lkLCB2YWx1ZV0gb2Ygc291cmNlLl9ieUlkLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoaWQpLCAnU2NoZW1hIGlkIGNvbmZsaWN0cyB3aXRoIGV4aXN0aW5nIGtleTonLCBpZCk7XG4gICAgICAgICAgICB0aGlzLl9ieUlkLnNldChpZCwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc291cmNlLl9ieUtleS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlJZC5oYXMoa2V5KSwgJ1NjaGVtYSBrZXkgY29uZmxpY3RzIHdpdGggZXhpc3RpbmcgaWQ6Jywga2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2J5S2V5LnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcmsocGF0aCwgYWRqdXN0ZXIsIHJvb3QpIHtcblxuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuX2NvbGxlY3QocGF0aCk7XG4gICAgICAgIGNoYWluLnB1c2goeyBzY2hlbWE6IHJvb3QgfSk7XG4gICAgICAgIGNvbnN0IHRhaWwgPSBjaGFpbi5zaGlmdCgpO1xuICAgICAgICBsZXQgYWRqdXN0ZWQgPSB7IGlkOiB0YWlsLmlkLCBzY2hlbWE6IGFkanVzdGVyKHRhaWwuc2NoZW1hKSB9O1xuXG4gICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoYWRqdXN0ZWQuc2NoZW1hKSwgJ2FkanVzdGVyIGZ1bmN0aW9uIGZhaWxlZCB0byByZXR1cm4gYSBqb2kgc2NoZW1hIHR5cGUnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY2hhaW4pIHtcbiAgICAgICAgICAgIGFkanVzdGVkID0geyBpZDogbm9kZS5pZCwgc2NoZW1hOiBpbnRlcm5hbHMuZm9yayhub2RlLnNjaGVtYSwgYWRqdXN0ZWQuaWQsIGFkanVzdGVkLnNjaGVtYSkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhZGp1c3RlZC5zY2hlbWE7XG4gICAgfVxuXG4gICAgbGFiZWxzKHBhdGgsIGJlaGluZCA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBiZWhpbmQgPSBbLi4uYmVoaW5kLCBub2RlLnNjaGVtYS5fZmxhZ3MubGFiZWwgfHwgY3VycmVudF07XG4gICAgICAgIGlmICghZm9yd2FyZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBiZWhpbmQuam9pbignLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMubGFiZWxzKGZvcndhcmQsIGJlaGluZCk7XG4gICAgfVxuXG4gICAgcmVhY2gocGF0aCwgYmVoaW5kID0gW10pIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGF0aFswXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dldChjdXJyZW50KTtcbiAgICAgICAgQXNzZXJ0KG5vZGUsICdTY2hlbWEgZG9lcyBub3QgY29udGFpbiBwYXRoJywgWy4uLmJlaGluZCwgLi4ucGF0aF0uam9pbignLicpKTtcblxuICAgICAgICBjb25zdCBmb3J3YXJkID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgaWYgKCFmb3J3YXJkLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuc2NoZW1hLl9pZHMucmVhY2goZm9yd2FyZCwgWy4uLmJlaGluZCwgY3VycmVudF0pO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyKHNjaGVtYSwgeyBrZXkgfSA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCFzY2hlbWEgfHxcbiAgICAgICAgICAgICFDb21tb24uaXNTY2hlbWEoc2NoZW1hKSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NoZW1hLiRfcHJvcGVydHkoJ3NjaGVtYUNoYWluJykgfHxcbiAgICAgICAgICAgIHNjaGVtYS5faWRzLl9zY2hlbWFDaGFpbikge1xuXG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpZCA9IHNjaGVtYS5fZmxhZ3MuaWQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLl9ieUlkLmdldChpZCk7XG4gICAgICAgICAgICBBc3NlcnQoIWV4aXN0aW5nIHx8IGV4aXN0aW5nLnNjaGVtYSA9PT0gc2NoZW1hLCAnQ2Fubm90IGFkZCBkaWZmZXJlbnQgc2NoZW1hcyB3aXRoIHRoZSBzYW1lIGlkOicsIGlkKTtcbiAgICAgICAgICAgIEFzc2VydCghdGhpcy5fYnlLZXkuaGFzKGlkKSwgJ1NjaGVtYSBpZCBjb25mbGljdHMgd2l0aCBleGlzdGluZyBrZXk6JywgaWQpO1xuXG4gICAgICAgICAgICB0aGlzLl9ieUlkLnNldChpZCwgeyBzY2hlbWEsIGlkIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUtleS5oYXMoa2V5KSwgJ1NjaGVtYSBhbHJlYWR5IGNvbnRhaW5zIGtleTonLCBrZXkpO1xuICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9ieUlkLmhhcyhrZXkpLCAnU2NoZW1hIGtleSBjb25mbGljdHMgd2l0aCBleGlzdGluZyBpZDonLCBrZXkpO1xuXG4gICAgICAgICAgICB0aGlzLl9ieUtleS5zZXQoa2V5LCB7IHNjaGVtYSwgaWQ6IGtleSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIHRoaXMuX2J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2J5S2V5ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9zY2hlbWFDaGFpbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9jb2xsZWN0KHBhdGgsIGJlaGluZCA9IFtdLCBub2RlcyA9IFtdKSB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHBhdGhbMF07XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9nZXQoY3VycmVudCk7XG4gICAgICAgIEFzc2VydChub2RlLCAnU2NoZW1hIGRvZXMgbm90IGNvbnRhaW4gcGF0aCcsIFsuLi5iZWhpbmQsIC4uLnBhdGhdLmpvaW4oJy4nKSk7XG5cbiAgICAgICAgbm9kZXMgPSBbbm9kZSwgLi4ubm9kZXNdO1xuXG4gICAgICAgIGNvbnN0IGZvcndhcmQgPSBwYXRoLnNsaWNlKDEpO1xuICAgICAgICBpZiAoIWZvcndhcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZS5zY2hlbWEuX2lkcy5fY29sbGVjdChmb3J3YXJkLCBbLi4uYmVoaW5kLCBjdXJyZW50XSwgbm9kZXMpO1xuICAgIH1cblxuICAgIF9nZXQoaWQpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYnlJZC5nZXQoaWQpIHx8IHRoaXMuX2J5S2V5LmdldChpZCk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZm9yayA9IGZ1bmN0aW9uIChzY2hlbWEsIGlkLCByZXBsYWNlbWVudCkge1xuXG4gICAgY29uc3QgZWFjaCA9IChpdGVtLCB7IGtleSB9KSA9PiB7XG5cbiAgICAgICAgaWYgKGlkID09PSAoaXRlbS5fZmxhZ3MuaWQgfHwga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9iaiA9IGV4cG9ydHMuc2NoZW1hKHNjaGVtYSwgeyBlYWNoLCByZWY6IGZhbHNlIH0pO1xuICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG59O1xuXG5cbmV4cG9ydHMuc2NoZW1hID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0aW9ucykge1xuXG4gICAgbGV0IG9iajtcblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEuX2ZsYWdzKSB7XG4gICAgICAgIGlmIChuYW1lWzBdID09PSAnXycpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4oc2NoZW1hLl9mbGFnc1tuYW1lXSwgeyBzb3VyY2U6ICdmbGFncycsIG5hbWUgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqID0gb2JqIHx8IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgICAgICAgb2JqLl9mbGFnc1tuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hLl9ydWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLl9ydWxlc1tpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLnNjYW4ocnVsZS5hcmdzLCB7IHNvdXJjZTogJ3J1bGVzJywgbmFtZTogcnVsZS5uYW1lIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBzY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgcnVsZSk7XG4gICAgICAgICAgICBjbG9uZS5hcmdzID0gcmVzdWx0O1xuICAgICAgICAgICAgb2JqLl9ydWxlc1tpXSA9IGNsb25lO1xuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1VuaXF1ZSA9IG9iai5fc2luZ2xlUnVsZXMuZ2V0KHJ1bGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdVbmlxdWUgPT09IHJ1bGUpIHtcbiAgICAgICAgICAgICAgICBvYmouX3NpbmdsZVJ1bGVzLnNldChydWxlLm5hbWUsIGNsb25lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzY2hlbWEuJF90ZXJtcykge1xuICAgICAgICBpZiAobmFtZVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKHNjaGVtYS4kX3Rlcm1zW25hbWVdLCB7IHNvdXJjZTogJ3Rlcm1zJywgbmFtZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmogPSBvYmogfHwgc2NoZW1hLmNsb25lKCk7XG4gICAgICAgICAgICBvYmouJF90ZXJtc1tuYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG59O1xuXG5cbmludGVybmFscy5zY2FuID0gZnVuY3Rpb24gKGl0ZW0sIHNvdXJjZSwgb3B0aW9ucywgX3BhdGgsIF9rZXkpIHtcblxuICAgIGNvbnN0IHBhdGggPSBfcGF0aCB8fCBbXTtcblxuICAgIGlmIChpdGVtID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0Jykge1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2xvbmU7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW0ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHNvdXJjZS5zb3VyY2UgPT09ICd0ZXJtcycgJiYgc291cmNlLm5hbWUgPT09ICdrZXlzJyAmJiBpdGVtW2ldLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKGl0ZW1baV0sIHNvdXJjZSwgb3B0aW9ucywgW2ksIC4uLnBhdGhdLCBrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBjbG9uZSB8fCBpdGVtLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY2xvbmVbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc2NoZW1hICE9PSBmYWxzZSAmJiBDb21tb24uaXNTY2hlbWEoaXRlbSkgfHxcbiAgICAgICAgb3B0aW9ucy5yZWYgIT09IGZhbHNlICYmIFJlZi5pc1JlZihpdGVtKSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbnMuZWFjaChpdGVtLCB7IC4uLnNvdXJjZSwgcGF0aCwga2V5OiBfa2V5IH0pO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJ18nKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5zY2FuKGl0ZW1ba2V5XSwgc291cmNlLCBvcHRpb25zLCBba2V5LCAuLi5wYXRoXSwgX2tleSk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xvbmUgPSBjbG9uZSB8fCBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgICAgIGNsb25lW2tleV0gPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxubGV0IFRlbXBsYXRlO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeW1ib2w6IFN5bWJvbCgncmVmJyksICAgICAgLy8gVXNlZCB0byBpbnRlcm5hbGx5IGlkZW50aWZ5IHJlZmVyZW5jZXMgKHNoYXJlZCB3aXRoIG90aGVyIGpvaSB2ZXJzaW9ucylcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBhZGp1c3Q6IG51bGwsXG4gICAgICAgIGluOiBmYWxzZSxcbiAgICAgICAgaXRlcmFibGVzOiBudWxsLFxuICAgICAgICBtYXA6IG51bGwsXG4gICAgICAgIHNlcGFyYXRvcjogJy4nLFxuICAgICAgICB0eXBlOiAndmFsdWUnXG4gICAgfVxufTtcblxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgQXNzZXJ0KHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnLCAnSW52YWxpZCByZWZlcmVuY2Uga2V5OicsIGtleSk7XG4gICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhZGp1c3QnLCAnYW5jZXN0b3InLCAnaW4nLCAnaXRlcmFibGVzJywgJ21hcCcsICdwcmVmaXgnLCAnc2VwYXJhdG9yJ10pO1xuICAgIEFzc2VydCghb3B0aW9ucy5wcmVmaXggfHwgdHlwZW9mIG9wdGlvbnMucHJlZml4ID09PSAnb2JqZWN0JywgJ29wdGlvbnMucHJlZml4IG11c3QgYmUgb2YgdHlwZSBvYmplY3QnKTtcblxuICAgIGNvbnN0IHJlZiA9IE9iamVjdC5hc3NpZ24oe30sIGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgZGVsZXRlIHJlZi5wcmVmaXg7XG5cbiAgICBjb25zdCBzZXBhcmF0b3IgPSByZWYuc2VwYXJhdG9yO1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbnRlcm5hbHMuY29udGV4dChrZXksIHNlcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIHJlZi50eXBlID0gY29udGV4dC50eXBlO1xuICAgIGtleSA9IGNvbnRleHQua2V5O1xuXG4gICAgaWYgKHJlZi50eXBlID09PSAndmFsdWUnKSB7XG4gICAgICAgIGlmIChjb250ZXh0LnJvb3QpIHtcbiAgICAgICAgICAgIEFzc2VydCghc2VwYXJhdG9yIHx8IGtleVswXSAhPT0gc2VwYXJhdG9yLCAnQ2Fubm90IHNwZWNpZnkgcmVsYXRpdmUgcGF0aCB3aXRoIHJvb3QgcHJlZml4Jyk7XG4gICAgICAgICAgICByZWYuYW5jZXN0b3IgPSAncm9vdCc7XG4gICAgICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VwYXJhdG9yICYmXG4gICAgICAgICAgICBzZXBhcmF0b3IgPT09IGtleSkge1xuXG4gICAgICAgICAgICBrZXkgPSBudWxsO1xuICAgICAgICAgICAgcmVmLmFuY2VzdG9yID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWYuYW5jZXN0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIEFzc2VydCghc2VwYXJhdG9yIHx8ICFrZXkgfHwga2V5WzBdICE9PSBzZXBhcmF0b3IsICdDYW5ub3QgY29tYmluZSBwcmVmaXggd2l0aCBhbmNlc3RvciBvcHRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IFthbmNlc3Rvciwgc2xpY2VdID0gaW50ZXJuYWxzLmFuY2VzdG9yKGtleSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5LnNsaWNlKHNsaWNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZWYuYW5jZXN0b3IgPSBhbmNlc3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZi5wYXRoID0gc2VwYXJhdG9yID8gKGtleSA9PT0gbnVsbCA/IFtdIDoga2V5LnNwbGl0KHNlcGFyYXRvcikpIDogW2tleV07XG5cbiAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYocmVmKTtcbn07XG5cblxuZXhwb3J0cy5pbiA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuY3JlYXRlKGtleSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBpbjogdHJ1ZSB9KSk7XG59O1xuXG5cbmV4cG9ydHMuaXNSZWYgPSBmdW5jdGlvbiAocmVmKSB7XG5cbiAgICByZXR1cm4gcmVmID8gISFyZWZbQ29tbW9uLnN5bWJvbHMucmVmXSA6IGZhbHNlO1xufTtcblxuXG5pbnRlcm5hbHMuUmVmID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcsICdJbnZhbGlkIHJlZmVyZW5jZSBjb25zdHJ1Y3Rpb24nKTtcbiAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgW1xuICAgICAgICAgICAgJ2FkanVzdCcsICdhbmNlc3RvcicsICdpbicsICdpdGVyYWJsZXMnLCAnbWFwJywgJ3BhdGgnLCAnc2VwYXJhdG9yJywgJ3R5cGUnLCAgICAvLyBDb3BpZWRcbiAgICAgICAgICAgICdkZXB0aCcsICdrZXknLCAncm9vdCcsICdkaXNwbGF5JyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGRlblxuICAgICAgICBdKTtcblxuICAgICAgICBBc3NlcnQoW2ZhbHNlLCB1bmRlZmluZWRdLmluY2x1ZGVzKG9wdGlvbnMuc2VwYXJhdG9yKSB8fCB0eXBlb2Ygb3B0aW9ucy5zZXBhcmF0b3IgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuc2VwYXJhdG9yLmxlbmd0aCA9PT0gMSwgJ0ludmFsaWQgc2VwYXJhdG9yJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5hZGp1c3QgfHwgdHlwZW9mIG9wdGlvbnMuYWRqdXN0ID09PSAnZnVuY3Rpb24nLCAnb3B0aW9ucy5hZGp1c3QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5tYXAgfHwgQXJyYXkuaXNBcnJheShvcHRpb25zLm1hcCksICdvcHRpb25zLm1hcCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy5tYXAgfHwgIW9wdGlvbnMuYWRqdXN0LCAnQ2Fubm90IHNldCBib3RoIG1hcCBhbmQgYWRqdXN0IG9wdGlvbnMnKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgQXNzZXJ0KHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyB8fCB0aGlzLmFuY2VzdG9yID09PSB1bmRlZmluZWQsICdOb24tdmFsdWUgcmVmZXJlbmNlcyBjYW5ub3QgcmVmZXJlbmNlIGFuY2VzdG9ycycpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubWFwKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKHRoaXMubWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVwdGggPSB0aGlzLnBhdGgubGVuZ3RoO1xuICAgICAgICB0aGlzLmtleSA9IHRoaXMucGF0aC5sZW5ndGggPyB0aGlzLnBhdGguam9pbih0aGlzLnNlcGFyYXRvcikgOiBudWxsO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnBhdGhbMF07XG5cbiAgICAgICAgdGhpcy51cGRhdGVEaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgQXNzZXJ0KCF0aGlzLmluIHx8IG9wdGlvbnMuaW4sICdJbnZhbGlkIGluKCkgcmVmZXJlbmNlIHVzYWdlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHByZWZzLmNvbnRleHQsIHN0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKGxvY2FsLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hbmNlc3RvciA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShzdGF0ZS5hbmNlc3RvcnNbc3RhdGUuYW5jZXN0b3JzLmxlbmd0aCAtIDFdLCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQodGhpcy5hbmNlc3RvciA8PSBzdGF0ZS5hbmNlc3RvcnMubGVuZ3RoLCAnSW52YWxpZCByZWZlcmVuY2UgZXhjZWVkcyB0aGUgc2NoZW1hIHJvb3Q6JywgdGhpcy5kaXNwbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoc3RhdGUuYW5jZXN0b3JzW3RoaXMuYW5jZXN0b3IgLSAxXSwgc3RhdGUsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIF9yZXNvbHZlKHRhcmdldCwgc3RhdGUsIG9wdGlvbnMpIHtcblxuICAgICAgICBsZXQgcmVzb2x2ZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3ZhbHVlJyAmJlxuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkuc2hhZG93ICYmXG4gICAgICAgICAgICBvcHRpb25zLnNoYWRvdyAhPT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgcmVzb2x2ZWQgPSBzdGF0ZS5tYWluc3RheS5zaGFkb3cuZ2V0KHRoaXMuYWJzb2x1dGUoc3RhdGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNvbHZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNvbHZlZCA9IFJlYWNoKHRhcmdldCwgdGhpcy5wYXRoLCB7IGl0ZXJhYmxlczogdGhpcy5pdGVyYWJsZXMsIGZ1bmN0aW9uczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFkanVzdCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQgPSB0aGlzLmFkanVzdChyZXNvbHZlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IHRoaXMubWFwLmdldChyZXNvbHZlZCk7XG4gICAgICAgICAgICBpZiAobWFwcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IG1hcHBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZS5tYWluc3RheSkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnJlc29sdmUoc3RhdGUsIHRoaXMsIHJlc29sdmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5O1xuICAgIH1cblxuICAgIGFic29sdXRlKHN0YXRlKSB7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5zdGF0ZS5wYXRoLnNsaWNlKDAsIC10aGlzLmFuY2VzdG9yKSwgLi4udGhpcy5wYXRoXTtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5SZWYodGhpcyk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUoKSB7XG5cbiAgICAgICAgY29uc3QgcmVmID0geyBwYXRoOiB0aGlzLnBhdGggfTtcblxuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICByZWYudHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICByZWYuc2VwYXJhdG9yID0gdGhpcy5zZXBhcmF0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgICAgICB0aGlzLmFuY2VzdG9yICE9PSAxKSB7XG5cbiAgICAgICAgICAgIHJlZi5hbmNlc3RvciA9IHRoaXMuYW5jZXN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIHJlZi5tYXAgPSBbLi4udGhpcy5tYXBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgWydhZGp1c3QnLCAnaXRlcmFibGVzJ10pIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWZba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVmLmluID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlZiB9O1xuICAgIH1cblxuICAgIHVwZGF0ZURpc3BsYXkoKSB7XG5cbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXkgIT09IG51bGwgPyB0aGlzLmtleSA6ICcnO1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy50eXBlfToke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnNlcGFyYXRvcikge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gYHJlZjoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmFuY2VzdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBgcmVmOiR7dGhpcy5zZXBhcmF0b3J9JHtrZXl9YDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFuY2VzdG9yID09PSAncm9vdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6cm9vdDoke2tleX1gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYW5jZXN0b3IgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtrZXkgfHwgJy4uJ31gO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVhZCA9IG5ldyBBcnJheSh0aGlzLmFuY2VzdG9yICsgMSkuZmlsbCh0aGlzLnNlcGFyYXRvcikuam9pbignJyk7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IGByZWY6JHtsZWFkfSR7a2V5IHx8ICcnfWA7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVmLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy5yZWZdID0gdHJ1ZTtcblxuXG5leHBvcnRzLmJ1aWxkID0gZnVuY3Rpb24gKGRlc2MpIHtcblxuICAgIGRlc2MgPSBPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbHMuZGVmYXVsdHMsIGRlc2MpO1xuICAgIGlmIChkZXNjLnR5cGUgPT09ICd2YWx1ZScgJiZcbiAgICAgICAgZGVzYy5hbmNlc3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgZGVzYy5hbmNlc3RvciA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuUmVmKGRlc2MpO1xufTtcblxuXG5pbnRlcm5hbHMuY29udGV4dCA9IGZ1bmN0aW9uIChrZXksIHNlcGFyYXRvciwgcHJlZml4ID0ge30pIHtcblxuICAgIGtleSA9IGtleS50cmltKCk7XG5cbiAgICBjb25zdCBnbG9iYWxwID0gcHJlZml4Lmdsb2JhbCA9PT0gdW5kZWZpbmVkID8gJyQnIDogcHJlZml4Lmdsb2JhbDtcbiAgICBpZiAoZ2xvYmFscCAhPT0gc2VwYXJhdG9yICYmXG4gICAgICAgIGtleS5zdGFydHNXaXRoKGdsb2JhbHApKSB7XG5cbiAgICAgICAgcmV0dXJuIHsga2V5OiBrZXkuc2xpY2UoZ2xvYmFscC5sZW5ndGgpLCB0eXBlOiAnZ2xvYmFsJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IGxvY2FsID0gcHJlZml4LmxvY2FsID09PSB1bmRlZmluZWQgPyAnIycgOiBwcmVmaXgubG9jYWw7XG4gICAgaWYgKGxvY2FsICE9PSBzZXBhcmF0b3IgJiZcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgobG9jYWwpKSB7XG5cbiAgICAgICAgcmV0dXJuIHsga2V5OiBrZXkuc2xpY2UobG9jYWwubGVuZ3RoKSwgdHlwZTogJ2xvY2FsJyB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3QgPSBwcmVmaXgucm9vdCA9PT0gdW5kZWZpbmVkID8gJy8nIDogcHJlZml4LnJvb3Q7XG4gICAgaWYgKHJvb3QgIT09IHNlcGFyYXRvciAmJlxuICAgICAgICBrZXkuc3RhcnRzV2l0aChyb290KSkge1xuXG4gICAgICAgIHJldHVybiB7IGtleToga2V5LnNsaWNlKHJvb3QubGVuZ3RoKSwgdHlwZTogJ3ZhbHVlJywgcm9vdDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGtleSwgdHlwZTogJ3ZhbHVlJyB9O1xufTtcblxuXG5pbnRlcm5hbHMuYW5jZXN0b3IgPSBmdW5jdGlvbiAoa2V5LCBzZXBhcmF0b3IpIHtcblxuICAgIGlmICghc2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBbMSwgMF07ICAgICAgICAgICAgICAvLyAnYV9iJyAtPiAxIChwYXJlbnQpXG4gICAgfVxuXG4gICAgaWYgKGtleVswXSAhPT0gc2VwYXJhdG9yKSB7ICAgICAvLyAnYS5iJyAtPiAxIChwYXJlbnQpXG4gICAgICAgIHJldHVybiBbMSwgMF07XG4gICAgfVxuXG4gICAgaWYgKGtleVsxXSAhPT0gc2VwYXJhdG9yKSB7ICAgICAvLyAnLmEuYicgLT4gMCAoc2VsZilcbiAgICAgICAgcmV0dXJuIFswLCAxXTtcbiAgICB9XG5cbiAgICBsZXQgaSA9IDI7XG4gICAgd2hpbGUgKGtleVtpXSA9PT0gc2VwYXJhdG9yKSB7XG4gICAgICAgICsraTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2kgLSAxLCBpXTsgICAgICAgICAgICAgIC8vICcuLi5hLmIuJyAtPiAyIChncmFuZHBhcmVudClcbn07XG5cblxuZXhwb3J0cy50b1NpYmxpbmcgPSAwO1xuXG5leHBvcnRzLnRvUGFyZW50ID0gMTtcblxuXG5leHBvcnRzLk1hbmFnZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLnJlZnMgPSBbXTsgICAgICAgICAgICAgICAgICAgICAvLyAwOiBbc2VsZiByZWZzXSwgMTogW3BhcmVudCByZWZzXSwgMjogW2dyYW5kcGFyZW50IHJlZnNdLCAuLi5cbiAgICB9XG5cbiAgICByZWdpc3Rlcihzb3VyY2UsIHRhcmdldCkge1xuXG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgPT09IHVuZGVmaW5lZCA/IGV4cG9ydHMudG9QYXJlbnQgOiB0YXJnZXQ7XG5cbiAgICAgICAgLy8gQXJyYXlcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHJlZiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NoZW1hXG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYShzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc291cmNlLl9yZWZzLnJlZnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5hbmNlc3RvciAtIHRhcmdldCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcy5wdXNoKHsgYW5jZXN0b3I6IGl0ZW0uYW5jZXN0b3IgLSB0YXJnZXQsIHJvb3Q6IGl0ZW0ucm9vdCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChleHBvcnRzLmlzUmVmKHNvdXJjZSkgJiZcbiAgICAgICAgICAgIHNvdXJjZS50eXBlID09PSAndmFsdWUnICYmXG4gICAgICAgICAgICBzb3VyY2UuYW5jZXN0b3IgLSB0YXJnZXQgPj0gMCkge1xuXG4gICAgICAgICAgICB0aGlzLnJlZnMucHVzaCh7IGFuY2VzdG9yOiBzb3VyY2UuYW5jZXN0b3IgLSB0YXJnZXQsIHJvb3Q6IHNvdXJjZS5yb290IH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVtcGxhdGVcblxuICAgICAgICBUZW1wbGF0ZSA9IFRlbXBsYXRlIHx8IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxuICAgICAgICBpZiAoVGVtcGxhdGUuaXNUZW1wbGF0ZShzb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHNvdXJjZS5yZWZzKCksIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgZXhwb3J0cy5NYW5hZ2VyKCk7XG4gICAgICAgIGNvcHkucmVmcyA9IENsb25lKHRoaXMucmVmcyk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuXG4gICAgICAgIHRoaXMucmVmcyA9IFtdO1xuICAgIH1cblxuICAgIHJvb3RzKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnMuZmlsdGVyKChyZWYpID0+ICFyZWYuYW5jZXN0b3IpLm1hcCgocmVmKSA9PiByZWYucm9vdCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgSm9pID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbi8vIFByZWZlcmVuY2VzXG5cbmV4cG9ydHMucHJlZmVyZW5jZXMgPSBKb2kub2JqZWN0KHtcbiAgICBhbGxvd1Vua25vd246IEpvaS5ib29sZWFuKCksXG4gICAgYWJvcnRFYXJseTogSm9pLmJvb2xlYW4oKSxcbiAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICBjb250ZXh0OiBKb2kub2JqZWN0KCksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBkYXRlRm9ybWF0OiBKb2kudmFsaWQoJ2RhdGUnLCAnaXNvJywgJ3N0cmluZycsICd0aW1lJywgJ3V0YycpLFxuICAgIGRlYnVnOiBKb2kuYm9vbGVhbigpLFxuICAgIGVycm9yczoge1xuICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBsYWJlbDogSm9pLnZhbGlkKCdwYXRoJywgJ2tleScsIGZhbHNlKSxcbiAgICAgICAgbGFuZ3VhZ2U6IFtcbiAgICAgICAgICAgIEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIEpvaS5vYmplY3QoKS5yZWYoKVxuICAgICAgICBdLFxuICAgICAgICByZW5kZXI6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHN0YWNrOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICB3cmFwQXJyYXlzOiBKb2kuYm9vbGVhbigpXG4gICAgfSxcbiAgICBleHRlcm5hbHM6IEpvaS5ib29sZWFuKCksXG4gICAgbWVzc2FnZXM6IEpvaS5vYmplY3QoKSxcbiAgICBub0RlZmF1bHRzOiBKb2kuYm9vbGVhbigpLFxuICAgIG5vbkVudW1lcmFibGVzOiBKb2kuYm9vbGVhbigpLFxuICAgIHByZXNlbmNlOiBKb2kudmFsaWQoJ3JlcXVpcmVkJywgJ29wdGlvbmFsJywgJ2ZvcmJpZGRlbicpLFxuICAgIHNraXBGdW5jdGlvbnM6IEpvaS5ib29sZWFuKCksXG4gICAgc3RyaXBVbmtub3duOiBKb2kub2JqZWN0KHtcbiAgICAgICAgYXJyYXlzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBvYmplY3RzOiBKb2kuYm9vbGVhbigpXG4gICAgfSlcbiAgICAgICAgLm9yKCdhcnJheXMnLCAnb2JqZWN0cycpXG4gICAgICAgIC5hbGxvdyh0cnVlLCBmYWxzZSksXG4gICAgd2FybmluZ3M6IEpvaS5ib29sZWFuKClcbn0pXG4gICAgLnN0cmljdCgpO1xuXG5cbi8vIEV4dGVuc2lvbnNcblxuaW50ZXJuYWxzLm5hbWVSeCA9IC9eW2EtekEtWjAtOV0rJC87XG5cblxuaW50ZXJuYWxzLnJ1bGUgPSBKb2kub2JqZWN0KHtcbiAgICBhbGlhczogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCkpLnNpbmdsZSgpLFxuICAgIGFyZ3M6IEpvaS5hcnJheSgpLml0ZW1zKFxuICAgICAgICBKb2kuc3RyaW5nKCksXG4gICAgICAgIEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCkucmVxdWlyZWQoKSxcbiAgICAgICAgICAgIHJlZjogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIGFzc2VydDogSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgICAgICAgICAgICAgSm9pLmZ1bmN0aW9uKCksXG4gICAgICAgICAgICAgICAgSm9pLm9iamVjdCgpLnNjaGVtYSgpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIC5jb25kaXRpb25hbCgncmVmJywgeyBpczogdHJ1ZSwgdGhlbjogSm9pLnJlcXVpcmVkKCkgfSksXG4gICAgICAgICAgICBub3JtYWxpemU6IEpvaS5mdW5jdGlvbigpLFxuICAgICAgICAgICAgbWVzc2FnZTogSm9pLnN0cmluZygpLndoZW4oJ2Fzc2VydCcsIHsgaXM6IEpvaS5mdW5jdGlvbigpLCB0aGVuOiBKb2kucmVxdWlyZWQoKSB9KVxuICAgICAgICB9KVxuICAgICksXG4gICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICBtYW5pZmVzdDogSm9pLmJvb2xlYW4oKSxcbiAgICBtZXRob2Q6IEpvaS5mdW5jdGlvbigpLmFsbG93KGZhbHNlKSxcbiAgICBtdWx0aTogSm9pLmJvb2xlYW4oKSxcbiAgICB2YWxpZGF0ZTogSm9pLmZ1bmN0aW9uKClcbn0pO1xuXG5cbmV4cG9ydHMuZXh0ZW5zaW9uID0gSm9pLm9iamVjdCh7XG4gICAgdHlwZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG5cbiAgICBhcmdzOiBKb2kuZnVuY3Rpb24oKSxcbiAgICBiYXNlOiBKb2kub2JqZWN0KCkuc2NoZW1hKCksXG4gICAgY29lcmNlOiBbXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLm1heEFyaXR5KDMpLFxuICAgICAgICBKb2kub2JqZWN0KHsgbWV0aG9kOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKS5yZXF1aXJlZCgpLCBmcm9tOiBKb2kuYXJyYXkoKS5pdGVtcyhKb2kuc3RyaW5nKCkpLnNpbmdsZSgpIH0pXG4gICAgXSxcbiAgICBmbGFnczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgSm9pLm9iamVjdCh7XG4gICAgICAgIHNldHRlcjogSm9pLnN0cmluZygpLFxuICAgICAgICBkZWZhdWx0OiBKb2kuYW55KClcbiAgICB9KSksXG4gICAgbWFuaWZlc3Q6IHtcbiAgICAgICAgYnVpbGQ6IEpvaS5mdW5jdGlvbigpLmFyaXR5KDIpXG4gICAgfSxcbiAgICBtZXNzYWdlczogW0pvaS5vYmplY3QoKSwgSm9pLnN0cmluZygpXSxcbiAgICBtb2RpZmllcnM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpLm1pbkFyaXR5KDEpLm1heEFyaXR5KDIpKSxcbiAgICBvdmVycmlkZXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKGludGVybmFscy5uYW1lUngsIEpvaS5mdW5jdGlvbigpKSxcbiAgICBwcmVwYXJlOiBKb2kuZnVuY3Rpb24oKS5tYXhBcml0eSgzKSxcbiAgICByZWJ1aWxkOiBKb2kuZnVuY3Rpb24oKS5hcml0eSgxKSxcbiAgICBydWxlczogSm9pLm9iamVjdCgpLnBhdHRlcm4oaW50ZXJuYWxzLm5hbWVSeCwgaW50ZXJuYWxzLnJ1bGUpLFxuICAgIHRlcm1zOiBKb2kub2JqZWN0KCkucGF0dGVybihpbnRlcm5hbHMubmFtZVJ4LCBKb2kub2JqZWN0KHtcbiAgICAgICAgaW5pdDogSm9pLmFycmF5KCkuYWxsb3cobnVsbCkucmVxdWlyZWQoKSxcbiAgICAgICAgbWFuaWZlc3Q6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgICAgIEpvaS52YWxpZCgnc2NoZW1hJywgJ3NpbmdsZScpLFxuICAgICAgICAgICAgSm9pLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFwcGVkOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICAgICAgICAgIHRvOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5yZXF1aXJlZCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgIH0pKSxcbiAgICB2YWxpZGF0ZTogSm9pLmZ1bmN0aW9uKCkubWF4QXJpdHkoMylcbn0pXG4gICAgLnN0cmljdCgpO1xuXG5cbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5vYmplY3QoKSwgSm9pLmZ1bmN0aW9uKCkuYXJpdHkoMSkpLnN0cmljdCgpO1xuXG5cbi8vIE1hbmlmZXN0XG5cbmludGVybmFscy5kZXNjID0ge1xuXG4gICAgYnVmZmVyOiBKb2kub2JqZWN0KHtcbiAgICAgICAgYnVmZmVyOiBKb2kuc3RyaW5nKClcbiAgICB9KSxcblxuICAgIGZ1bmM6IEpvaS5vYmplY3Qoe1xuICAgICAgICBmdW5jdGlvbjogSm9pLmZ1bmN0aW9uKCkucmVxdWlyZWQoKSxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbGl0ZXJhbDogdHJ1ZVxuICAgICAgICB9XG4gICAgfSksXG5cbiAgICBvdmVycmlkZTogSm9pLm9iamVjdCh7XG4gICAgICAgIG92ZXJyaWRlOiB0cnVlXG4gICAgfSksXG5cbiAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWY6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogSm9pLnZhbGlkKCd2YWx1ZScsICdnbG9iYWwnLCAnbG9jYWwnKSxcbiAgICAgICAgICAgIHBhdGg6IEpvaS5hcnJheSgpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICBzZXBhcmF0b3I6IEpvaS5zdHJpbmcoKS5sZW5ndGgoMSkuYWxsb3coZmFsc2UpLFxuICAgICAgICAgICAgYW5jZXN0b3I6IEpvaS5udW1iZXIoKS5taW4oMCkuaW50ZWdlcigpLmFsbG93KCdyb290JyksXG4gICAgICAgICAgICBtYXA6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5hcnJheSgpLmxlbmd0aCgyKSkubWluKDEpLFxuICAgICAgICAgICAgYWRqdXN0OiBKb2kuZnVuY3Rpb24oKSxcbiAgICAgICAgICAgIGl0ZXJhYmxlczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIGluOiBKb2kuYm9vbGVhbigpXG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVxdWlyZWQoKVxuICAgIH0pLFxuXG4gICAgcmVnZXg6IEpvaS5vYmplY3Qoe1xuICAgICAgICByZWdleDogSm9pLnN0cmluZygpLm1pbigzKVxuICAgIH0pLFxuXG4gICAgc3BlY2lhbDogSm9pLm9iamVjdCh7XG4gICAgICAgIHNwZWNpYWw6IEpvaS52YWxpZCgnZGVlcCcpLnJlcXVpcmVkKClcbiAgICB9KSxcblxuICAgIHRlbXBsYXRlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdGVtcGxhdGU6IEpvaS5zdHJpbmcoKS5yZXF1aXJlZCgpLFxuICAgICAgICBvcHRpb25zOiBKb2kub2JqZWN0KClcbiAgICB9KSxcblxuICAgIHZhbHVlOiBKb2kub2JqZWN0KHtcbiAgICAgICAgdmFsdWU6IEpvaS5hbHRlcm5hdGl2ZXMoW0pvaS5vYmplY3QoKSwgSm9pLmFycmF5KCldKS5yZXF1aXJlZCgpXG4gICAgfSlcbn07XG5cblxuaW50ZXJuYWxzLmRlc2MuZW50aXR5ID0gSm9pLmFsdGVybmF0aXZlcyhbXG4gICAgSm9pLmFycmF5KCkuaXRlbXMoSm9pLmxpbmsoJy4uLicpKSxcbiAgICBKb2kuYm9vbGVhbigpLFxuICAgIEpvaS5mdW5jdGlvbigpLFxuICAgIEpvaS5udW1iZXIoKSxcbiAgICBKb2kuc3RyaW5nKCksXG4gICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgIGludGVybmFscy5kZXNjLmZ1bmMsXG4gICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgIGludGVybmFscy5kZXNjLnJlZ2V4LFxuICAgIGludGVybmFscy5kZXNjLnNwZWNpYWwsXG4gICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgaW50ZXJuYWxzLmRlc2MudmFsdWUsXG4gICAgSm9pLmxpbmsoJy8nKVxuXSk7XG5cblxuaW50ZXJuYWxzLmRlc2MudmFsdWVzID0gSm9pLmFycmF5KClcbiAgICAuaXRlbXMoXG4gICAgICAgIG51bGwsXG4gICAgICAgIEpvaS5ib29sZWFuKCksXG4gICAgICAgIEpvaS5mdW5jdGlvbigpLFxuICAgICAgICBKb2kubnVtYmVyKCkuYWxsb3coSW5maW5pdHksIC1JbmZpbml0eSksXG4gICAgICAgIEpvaS5zdHJpbmcoKS5hbGxvdygnJyksXG4gICAgICAgIEpvaS5zeW1ib2woKSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MuYnVmZmVyLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5mdW5jLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5vdmVycmlkZSxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MucmVmLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy5yZWdleCxcbiAgICAgICAgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGUsXG4gICAgICAgIGludGVybmFscy5kZXNjLnZhbHVlXG4gICAgKTtcblxuXG5pbnRlcm5hbHMuZGVzYy5tZXNzYWdlcyA9IEpvaS5vYmplY3QoKVxuICAgIC5wYXR0ZXJuKC8uKy8sIFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBpbnRlcm5hbHMuZGVzYy50ZW1wbGF0ZSxcbiAgICAgICAgSm9pLm9iamVjdCgpLnBhdHRlcm4oLy4rLywgW0pvaS5zdHJpbmcoKSwgaW50ZXJuYWxzLmRlc2MudGVtcGxhdGVdKVxuICAgIF0pO1xuXG5cbmV4cG9ydHMuZGVzY3JpcHRpb24gPSBKb2kub2JqZWN0KHtcbiAgICB0eXBlOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICBmbGFnczogSm9pLm9iamVjdCh7XG4gICAgICAgIGNhc3Q6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgZGVmYXVsdDogSm9pLmFueSgpLFxuICAgICAgICBkZXNjcmlwdGlvbjogSm9pLnN0cmluZygpLFxuICAgICAgICBlbXB0eTogSm9pLmxpbmsoJy8nKSxcbiAgICAgICAgZmFpbG92ZXI6IGludGVybmFscy5kZXNjLmVudGl0eSxcbiAgICAgICAgaWQ6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgbGFiZWw6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgb25seTogdHJ1ZSxcbiAgICAgICAgcHJlc2VuY2U6IFsnb3B0aW9uYWwnLCAncmVxdWlyZWQnLCAnZm9yYmlkZGVuJ10sXG4gICAgICAgIHJlc3VsdDogWydyYXcnLCAnc3RyaXAnXSxcbiAgICAgICAgc3RyaXA6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIHVuaXQ6IEpvaS5zdHJpbmcoKVxuICAgIH0pXG4gICAgICAgIC51bmtub3duKCksXG4gICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgYWxsb3dVbmtub3duOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBhYm9ydEVhcmx5OiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjYWNoZTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgY29udmVydDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgZGF0ZUZvcm1hdDogWydkYXRlJywgJ2lzbycsICdzdHJpbmcnLCAndGltZScsICd1dGMnXSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgICBlc2NhcGVIdG1sOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICAgICAgbGFiZWw6IFsncGF0aCcsICdrZXknXSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBbXG4gICAgICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgICAgIGludGVybmFscy5kZXNjLnJlZlxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHdyYXBBcnJheXM6IEpvaS5ib29sZWFuKClcbiAgICAgICAgfSxcbiAgICAgICAgZXh0ZXJuYWxzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBtZXNzYWdlczogaW50ZXJuYWxzLmRlc2MubWVzc2FnZXMsXG4gICAgICAgIG5vRGVmYXVsdHM6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIG5vbkVudW1lcmFibGVzOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBwcmVzZW5jZTogWydyZXF1aXJlZCcsICdvcHRpb25hbCcsICdmb3JiaWRkZW4nXSxcbiAgICAgICAgc2tpcEZ1bmN0aW9uczogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgc3RyaXBVbmtub3duOiBKb2kub2JqZWN0KHtcbiAgICAgICAgICAgIGFycmF5czogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIG9iamVjdHM6IEpvaS5ib29sZWFuKClcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vcignYXJyYXlzJywgJ29iamVjdHMnKVxuICAgICAgICAgICAgLmFsbG93KHRydWUsIGZhbHNlKSxcbiAgICAgICAgd2FybmluZ3M6IEpvaS5ib29sZWFuKClcbiAgICB9LFxuICAgIGFsbG93OiBpbnRlcm5hbHMuZGVzYy52YWx1ZXMsXG4gICAgaW52YWxpZDogaW50ZXJuYWxzLmRlc2MudmFsdWVzLFxuICAgIHJ1bGVzOiBKb2kuYXJyYXkoKS5taW4oMSkuaXRlbXMoe1xuICAgICAgICBuYW1lOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgYXJnczogSm9pLm9iamVjdCgpLm1pbigxKSxcbiAgICAgICAga2VlcDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgbWVzc2FnZTogW1xuICAgICAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgaW50ZXJuYWxzLmRlc2MubWVzc2FnZXNcbiAgICAgICAgXSxcbiAgICAgICAgd2FybjogSm9pLmJvb2xlYW4oKVxuICAgIH0pLFxuXG4gICAgLy8gVGVybXNcblxuICAgIGtleXM6IEpvaS5vYmplY3QoKS5wYXR0ZXJuKC8uKi8sIEpvaS5saW5rKCcvJykpLFxuICAgIGxpbms6IGludGVybmFscy5kZXNjLnJlZlxufSlcbiAgICAucGF0dGVybigvXlthLXpdXFx3KiQvLCBKb2kuYW55KCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBSZWFjaCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL3JlYWNoJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIHZhbHVlOiBTeW1ib2woJ3ZhbHVlJylcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuU3RhdGUgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBhbmNlc3RvcnMsIHN0YXRlKSB7XG5cbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5hbmNlc3RvcnMgPSBhbmNlc3RvcnM7ICAgICAgICAgICAgICAgICAvLyBbcGFyZW50LCAuLi4sIHJvb3RdXG5cbiAgICAgICAgdGhpcy5tYWluc3RheSA9IHN0YXRlLm1haW5zdGF5O1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSBzdGF0ZS5zY2hlbWFzOyAgICAgICAgICAgICAgIC8vIFtjdXJyZW50LCAuLi4sIHJvb3RdXG4gICAgICAgIHRoaXMuZGVidWcgPSBudWxsO1xuICAgIH1cblxuICAgIGxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycyA9IG51bGwsIHNjaGVtYSA9IG51bGwpIHtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyBpbnRlcm5hbHMuU3RhdGUocGF0aCwgYW5jZXN0b3JzLCB0aGlzKTtcblxuICAgICAgICBpZiAoc2NoZW1hICYmXG4gICAgICAgICAgICBzdGF0ZS5zY2hlbWFzKSB7XG5cbiAgICAgICAgICAgIHN0YXRlLnNjaGVtYXMgPSBbaW50ZXJuYWxzLnNjaGVtYXMoc2NoZW1hKSwgLi4uc3RhdGUuc2NoZW1hc107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgbmVzdChzY2hlbWEsIGRlYnVnKSB7XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgaW50ZXJuYWxzLlN0YXRlKHRoaXMucGF0aCwgdGhpcy5hbmNlc3RvcnMsIHRoaXMpO1xuICAgICAgICBzdGF0ZS5zY2hlbWFzID0gc3RhdGUuc2NoZW1hcyAmJiBbaW50ZXJuYWxzLnNjaGVtYXMoc2NoZW1hKSwgLi4uc3RhdGUuc2NoZW1hc107XG4gICAgICAgIHN0YXRlLmRlYnVnID0gZGVidWc7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICBzaGFkb3codmFsdWUsIHJlYXNvbikge1xuXG4gICAgICAgIHRoaXMubWFpbnN0YXkuc2hhZG93ID0gdGhpcy5tYWluc3RheS5zaGFkb3cgfHwgbmV3IGludGVybmFscy5TaGFkb3coKTtcbiAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cuc2V0KHRoaXMucGF0aCwgdmFsdWUsIHJlYXNvbik7XG4gICAgfVxuXG4gICAgc25hcHNob3QoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMubWFpbnN0YXkuc2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IENsb25lKHRoaXMubWFpbnN0YXkuc2hhZG93Lm5vZGUodGhpcy5wYXRoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuXG4gICAgICAgIGlmICh0aGlzLm1haW5zdGF5LnNoYWRvdykge1xuICAgICAgICAgICAgdGhpcy5tYWluc3RheS5zaGFkb3cub3ZlcnJpZGUodGhpcy5wYXRoLCB0aGlzLl9zbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnNjaGVtYXMgPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICBpZiAoQ29tbW9uLmlzU2NoZW1hKHNjaGVtYSkpIHtcbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYTtcbn07XG5cblxuaW50ZXJuYWxzLlNoYWRvdyA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc2V0KHBhdGgsIHZhbHVlLCByZWFzb24pIHtcblxuICAgICAgICBpZiAoIXBhdGgubGVuZ3RoKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc3RvcmUgcm9vdCB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlYXNvbiA9PT0gJ3N0cmlwJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHsgICAgICAgIC8vIENhbm5vdCBzdG9yZSBzdHJpcHBlZCBhcnJheSB2YWx1ZXMgKGR1ZSB0byBzaGlmdClcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdGhpcy5fdmFsdWVzIHx8IG5ldyBNYXAoKTtcblxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX3ZhbHVlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gcGF0aFtpXTtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5nZXQoc2VnbWVudCk7XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIG5vZGUuc2V0KHNlZ21lbnQsIG5leHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVbaW50ZXJuYWxzLnZhbHVlXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldChwYXRoKSB7XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZShwYXRoKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlW2ludGVybmFscy52YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlKHBhdGgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWNoKHRoaXMuX3ZhbHVlcywgcGF0aCwgeyBpdGVyYWJsZXM6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUocGF0aCwgbm9kZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnRzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGNvbnN0IG93biA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gUmVhY2godGhpcy5fdmFsdWVzLCBwYXJlbnRzLCB7IGl0ZXJhYmxlczogdHJ1ZSB9KTtcblxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgcGFyZW50LnNldChvd24sIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LmRlbGV0ZShvd24pO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBDbG9uZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Nsb25lJyk7XG5jb25zdCBFc2NhcGVIdG1sID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlSHRtbCcpO1xuY29uc3QgRm9ybXVsYSA9IHJlcXVpcmUoJ0BoYXBpL2Zvcm11bGEnKTtcblxuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBSZWYgPSByZXF1aXJlKCcuL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBzeW1ib2w6IFN5bWJvbCgndGVtcGxhdGUnKSxcblxuICAgIG9wZW5zOiBuZXcgQXJyYXkoMTAwMCkuam9pbignXFx1MDAwMCcpLFxuICAgIGNsb3NlczogbmV3IEFycmF5KDEwMDApLmpvaW4oJ1xcdTAwMDEnKSxcblxuICAgIGRhdGVGb3JtYXQ6IHtcbiAgICAgICAgZGF0ZTogRGF0ZS5wcm90b3R5cGUudG9EYXRlU3RyaW5nLFxuICAgICAgICBpc286IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nLFxuICAgICAgICBzdHJpbmc6IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLFxuICAgICAgICB0aW1lOiBEYXRlLnByb3RvdHlwZS50b1RpbWVTdHJpbmcsXG4gICAgICAgIHV0YzogRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmdcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGludGVybmFscy5UZW1wbGF0ZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgICAgIEFzc2VydCh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJywgJ1RlbXBsYXRlIHNvdXJjZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIEFzc2VydCghc291cmNlLmluY2x1ZGVzKCdcXHUwMDAwJykgJiYgIXNvdXJjZS5pbmNsdWRlcygnXFx1MDAwMScpLCAnVGVtcGxhdGUgc291cmNlIGNhbm5vdCBjb250YWluIHJlc2VydmVkIGNvbnRyb2wgY2hhcmFjdGVycycpO1xuXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVkID0gc291cmNlO1xuXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBDbG9uZShvcHRpb25zKTtcblxuICAgICAgICB0aGlzLl9wYXJzZSgpO1xuICAgIH1cblxuICAgIF9wYXJzZSgpIHtcblxuICAgICAgICAvLyAndGV4dCB7cmF3fSB7e3JlZn19IFxcXFx7e2lnbm9yZX19IHt7aWdub3JlXFxcXH19IHt7aWdub3JlIHt7aWdub3JlfSdcblxuICAgICAgICBpZiAoIXRoaXMuc291cmNlLmluY2x1ZGVzKCd7JykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuY29kZSBlc2NhcGVkIFxcXFx7e3t7e1xuXG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBpbnRlcm5hbHMuZW5jb2RlKHRoaXMuc291cmNlKTtcblxuICAgICAgICAvLyBTcGxpdCBvbiBmaXJzdCB7IGluIGVhY2ggc2V0XG5cbiAgICAgICAgY29uc3QgcGFydHMgPSBpbnRlcm5hbHMuc3BsaXQoZW5jb2RlZCk7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJ0c1xuXG4gICAgICAgIGxldCByZWZzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgICAgICBjb25zdCBoZWFkID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGhlYWQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGhlYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBwYXJ0WzBdICE9PSAneyc7XG4gICAgICAgICAgICBjb25zdCBlbmRlciA9IHJhdyA/ICd9JyA6ICd9fSc7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwYXJ0LmluZGV4T2YoZW5kZXIpO1xuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEgfHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIG5vbi1tYXRjaGluZyBjbG9zaW5nXG4gICAgICAgICAgICAgICAgcGFydFsxXSA9PT0gJ3snKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbW9yZSB0aGFuIHR3byB7XG5cbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChgeyR7aW50ZXJuYWxzLmRlY29kZShwYXJ0KX1gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGUgPSBwYXJ0LnNsaWNlKHJhdyA/IDAgOiAxLCBlbmQpO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IHRoaXMuX3JlZihpbnRlcm5hbHMuZGVjb2RlKHZhcmlhYmxlKSwgcmF3KTtcbiAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGR5bmFtaWMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkeW5hbWljICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCByZXN0ID0gcGFydC5zbGljZShlbmQgKyBlbmRlci5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWQucHVzaChpbnRlcm5hbHMuZGVjb2RlKHJlc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVmcykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHByb2Nlc3NlZC5qb2luKCcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gcHJvY2Vzc2VkO1xuICAgIH1cblxuICAgIHN0YXRpYyBkYXRlKGRhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlRm9ybWF0W3ByZWZzLmRhdGVGb3JtYXRdLmNhbGwoZGF0ZSk7XG4gICAgfVxuXG4gICAgZGVzY3JpYmUob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zZXR0aW5ncyAmJlxuICAgICAgICAgICAgb3B0aW9ucy5jb21wYWN0KSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlc2MgPSB7IHRlbXBsYXRlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGRlc2Mub3B0aW9ucyA9IHRoaXMuX3NldHRpbmdzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgfVxuXG4gICAgc3RhdGljIGJ1aWxkKGRlc2MpIHtcblxuICAgICAgICByZXR1cm4gbmV3IGludGVybmFscy5UZW1wbGF0ZShkZXNjLnRlbXBsYXRlLCBkZXNjLm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlzRHluYW1pYygpIHtcblxuICAgICAgICByZXR1cm4gISF0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSA/ICEhdGVtcGxhdGVbQ29tbW9uLnN5bWJvbHMudGVtcGxhdGVdIDogZmFsc2U7XG4gICAgfVxuXG4gICAgcmVmcygpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWZzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlZnMucHVzaCguLi5wYXJ0LnJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZnM7XG4gICAgfVxuXG4gICAgcmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCkge1xuXG4gICAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXJ0KHRoaXMuX3RlbXBsYXRlWzBdLCAvKiBjb250ZXh0IC0+IFsqLyB2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwge30gLypdICovKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCk7XG4gICAgfVxuXG4gICAgX3BhcnQocGFydCwgLi4uYXJncykge1xuXG4gICAgICAgIGlmIChwYXJ0LnJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnQucmVmLnJlc29sdmUoLi4uYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydC5mb3JtdWxhLmV2YWx1YXRlKGFyZ3MpO1xuICAgIH1cblxuICAgIHJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBsb2NhbCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzRHluYW1pYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlZCA9IHRoaXMuX3BhcnQocGFydCwgLyogY29udGV4dCAtPiBbKi8gdmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMgLypdICovKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmcgPSBpbnRlcm5hbHMuc3RyaW5naWZ5KHJlbmRlcmVkLCBwcmVmcywgb3B0aW9ucy5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJ0LnJhdyB8fCAob3B0aW9ucy5lcnJvcnMgJiYgb3B0aW9ucy5lcnJvcnMuZXNjYXBlSHRtbCkgPT09IGZhbHNlID8gc3RyaW5nIDogRXNjYXBlSHRtbChzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgIH1cblxuICAgIF9yZWYoY29udGVudCwgcmF3KSB7XG5cbiAgICAgICAgY29uc3QgcmVmcyA9IFtdO1xuICAgICAgICBjb25zdCByZWZlcmVuY2UgPSAodmFyaWFibGUpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgcmVmID0gUmVmLmNyZWF0ZSh2YXJpYWJsZSwgdGhpcy5fc2V0dGluZ3MpO1xuICAgICAgICAgICAgcmVmcy5wdXNoKHJlZik7XG4gICAgICAgICAgICByZXR1cm4gKGNvbnRleHQpID0+IHJlZi5yZXNvbHZlKC4uLmNvbnRleHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZm9ybXVsYSA9IG5ldyBGb3JtdWxhKGNvbnRlbnQsIHsgcmVmZXJlbmNlLCBmdW5jdGlvbnM6IGludGVybmFscy5mdW5jdGlvbnMsIGNvbnN0YW50czogaW50ZXJuYWxzLmNvbnN0YW50cyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBJbnZhbGlkIHRlbXBsYXRlIHZhcmlhYmxlIFwiJHtjb250ZW50fVwiIGZhaWxzIGR1ZSB0bzogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm11bGEuc2luZ2xlKSB7XG4gICAgICAgICAgICBpZiAoZm9ybXVsYS5zaW5nbGUudHlwZSA9PT0gJ3JlZmVyZW5jZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWY6IHJlZnNbMF0sIHJhdywgcmVmcyB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnN0cmluZ2lmeShmb3JtdWxhLnNpbmdsZS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBmb3JtdWxhLCByYXcsIHJlZnMgfTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuVGVtcGxhdGUucHJvdG90eXBlW0NvbW1vbi5zeW1ib2xzLnRlbXBsYXRlXSA9IHRydWU7XG5pbnRlcm5hbHMuVGVtcGxhdGUucHJvdG90eXBlLmlzSW1tdXRhYmxlID0gdHJ1ZTsgICAgICAgICAgICAgICAgLy8gUHJldmVudHMgSG9layBmcm9tIGRlZXAgY2xvbmluZyBzY2hlbWEgb2JqZWN0c1xuXG5cbmludGVybmFscy5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICAgIC5yZXBsYWNlKC9cXFxcKFxceyspL2csICgkMCwgJDEpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5vcGVucy5zbGljZSgwLCAkMS5sZW5ndGgpO1xuICAgICAgICB9KVxuICAgICAgICAucmVwbGFjZSgvXFxcXChcXH0rKS9nLCAoJDAsICQxKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuY2xvc2VzLnNsaWNlKDAsICQxLmxlbmd0aCk7XG4gICAgICAgIH0pO1xufTtcblxuXG5pbnRlcm5hbHMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICAucmVwbGFjZSgvXFx1MDAwMC9nLCAneycpXG4gICAgICAgIC5yZXBsYWNlKC9cXHUwMDAxL2csICd9Jyk7XG59O1xuXG5cbmludGVybmFscy5zcGxpdCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblxuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzdHJpbmdbaV07XG5cbiAgICAgICAgaWYgKGNoYXIgPT09ICd7Jykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSAnJztcbiAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IHN0cmluZy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdbaSArIDFdID09PSAneycpIHtcblxuICAgICAgICAgICAgICAgIG5leHQgKz0gJ3snO1xuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudCArPSBjaGFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChjdXJyZW50KTtcbiAgICByZXR1cm4gcGFydHM7XG59O1xuXG5cbmludGVybmFscy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUsIHByZWZzLCBvcHRpb25zKSB7XG5cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlID09PSAnc3ltYm9sJykge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5UZW1wbGF0ZS5kYXRlKHZhbHVlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgc3ltXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goYCR7a2V5LnRvU3RyaW5nKCl9IC0+ICR7c3ltLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHBhaXJzO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IHBhcnRpYWwgPSAnJztcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgcGFydGlhbCA9IHBhcnRpYWwgKyAocGFydGlhbC5sZW5ndGggPyAnLCAnIDogJycpICsgaW50ZXJuYWxzLnN0cmluZ2lmeShpdGVtLCBwcmVmcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnMud3JhcEFycmF5cyA/ICdbJyArIHBhcnRpYWwgKyAnXScgOiBwYXJ0aWFsO1xufTtcblxuXG5pbnRlcm5hbHMuY29uc3RhbnRzID0ge1xuXG4gICAgdHJ1ZTogdHJ1ZSxcbiAgICBmYWxzZTogZmFsc2UsXG4gICAgbnVsbDogbnVsbCxcblxuICAgIHNlY29uZDogMTAwMCxcbiAgICBtaW51dGU6IDYwICogMTAwMCxcbiAgICBob3VyOiA2MCAqIDYwICogMTAwMCxcbiAgICBkYXk6IDI0ICogNjAgKiA2MCAqIDEwMDBcbn07XG5cblxuaW50ZXJuYWxzLmZ1bmN0aW9ucyA9IHtcblxuICAgIGlmKGNvbmRpdGlvbiwgdGhlbiwgb3RoZXJ3aXNlKSB7XG5cbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IHRoZW4gOiBvdGhlcndpc2U7XG4gICAgfSxcblxuICAgIG1zZyhjb2RlKSB7XG5cbiAgICAgICAgY29uc3QgW3ZhbHVlLCBzdGF0ZSwgcHJlZnMsIGxvY2FsLCBvcHRpb25zXSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcztcbiAgICAgICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBFcnJvcnMudGVtcGxhdGUodmFsdWUsIG1lc3NhZ2VzWzBdLCBjb2RlLCBzdGF0ZSwgcHJlZnMpIHx8IEVycm9ycy50ZW1wbGF0ZSh2YWx1ZSwgbWVzc2FnZXNbMV0sIGNvZGUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZW5kZXIodmFsdWUsIHN0YXRlLCBwcmVmcywgbG9jYWwsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBudW1iZXIodmFsdWUpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5jb25zdCBQaW5wb2ludCA9IHJlcXVpcmUoJ0BoYXBpL3BpbnBvaW50Jyk7XG5cbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGNvZGVzOiB7XG4gICAgICAgIGVycm9yOiAxLFxuICAgICAgICBwYXNzOiAyLFxuICAgICAgICBmdWxsOiAzXG4gICAgfSxcbiAgICBsYWJlbHM6IHtcbiAgICAgICAgMDogJ25ldmVyIHVzZWQnLFxuICAgICAgICAxOiAnYWx3YXlzIGVycm9yJyxcbiAgICAgICAgMjogJ2Fsd2F5cyBwYXNzJ1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy5zZXR1cCA9IGZ1bmN0aW9uIChyb290KSB7XG5cbiAgICBjb25zdCB0cmFjZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICByb290Ll90cmFjZXIgPSByb290Ll90cmFjZXIgfHwgbmV3IGludGVybmFscy5UcmFjZXIoKTtcbiAgICAgICAgcmV0dXJuIHJvb3QuX3RyYWNlcjtcbiAgICB9O1xuXG4gICAgcm9vdC50cmFjZSA9IHRyYWNlO1xuICAgIHJvb3RbU3ltYm9sLmZvcignQGhhcGkvbGFiL2NvdmVyYWdlL2luaXRpYWxpemUnKV0gPSB0cmFjZTtcblxuICAgIHJvb3QudW50cmFjZSA9ICgpID0+IHtcblxuICAgICAgICByb290Ll90cmFjZXIgPSBudWxsO1xuICAgIH07XG59O1xuXG5cbmV4cG9ydHMubG9jYXRpb24gPSBmdW5jdGlvbiAoc2NoZW1hKSB7XG5cbiAgICByZXR1cm4gc2NoZW1hLiRfc2V0RmxhZygnX3RyYWNlckxvY2F0aW9uJywgUGlucG9pbnQubG9jYXRpb24oMikpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzZS50cmFjZXIoKSwgY2FsbGVyXG59O1xuXG5cbmludGVybmFscy5UcmFjZXIgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICB0aGlzLm5hbWUgPSAnSm9pJztcbiAgICAgICAgdGhpcy5fc2NoZW1hcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBfcmVnaXN0ZXIoc2NoZW1hKSB7XG5cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLl9zY2hlbWFzLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZy5zdG9yZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0b3JlID0gbmV3IGludGVybmFscy5TdG9yZShzY2hlbWEpO1xuICAgICAgICBjb25zdCB7IGZpbGVuYW1lLCBsaW5lIH0gPSBzY2hlbWEuX2ZsYWdzLl90cmFjZXJMb2NhdGlvbiB8fCBQaW5wb2ludC5sb2NhdGlvbig1KTsgICAvLyBpbnRlcm5hbHMudHJhY2VyKCksIGludGVybmFscy5lbnRyeSgpLCBleHBvcnRzLmVudHJ5KCksIHZhbGlkYXRlKCksIGNhbGxlclxuICAgICAgICB0aGlzLl9zY2hlbWFzLnNldChzY2hlbWEsIHsgZmlsZW5hbWUsIGxpbmUsIHN0b3JlIH0pO1xuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfVxuXG4gICAgX2NvbWJpbmUobWVyZ2VkLCBzb3VyY2VzKSB7XG5cbiAgICAgICAgZm9yIChjb25zdCB7IHN0b3JlIH0gb2YgdGhpcy5fc2NoZW1hcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc3RvcmUuX2NvbWJpbmUobWVyZ2VkLCBzb3VyY2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlcG9ydChmaWxlKSB7XG5cbiAgICAgICAgY29uc3QgY292ZXJhZ2UgPSBbXTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggcmVnaXN0ZXJlZCBzY2hlbWFcblxuICAgICAgICBmb3IgKGNvbnN0IHsgZmlsZW5hbWUsIGxpbmUsIHN0b3JlIH0gb2YgdGhpcy5fc2NoZW1hcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKGZpbGUgJiZcbiAgICAgICAgICAgICAgICBmaWxlICE9PSBmaWxlbmFtZSkge1xuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByb2Nlc3Mgc3ViIHNjaGVtYXMgb2YgdGhlIHJlZ2lzdGVyZWQgcm9vdFxuXG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nID0gW107XG4gICAgICAgICAgICBjb25zdCBza2lwcGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgW3NjaGVtYSwgbG9nXSBvZiBzdG9yZS5fc291cmNlcy5lbnRyaWVzKCkpIHtcblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHN1YiBzY2hlbWEgcGFyZW50IHNraXBwZWRcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuc3ViKGxvZy5wYXRocywgc2tpcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc3ViIHNjaGVtYSByZWFjaGVkXG5cbiAgICAgICAgICAgICAgICBpZiAoIWxvZy5lbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAnbmV2ZXIgcmVhY2hlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoczogWy4uLmxvZy5wYXRoc11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZC5wdXNoKC4uLmxvZy5wYXRocyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHZhbHVlc1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIFsndmFsaWQnLCAnaW52YWxpZCddKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldCA9IHNjaGVtYVtgXyR7dHlwZX1zYF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoc2V0Ll92YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZzID0gbmV3IFNldChzZXQuX3JlZnMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgdmFsdWUsIHJlZiB9IG9mIGxvZ1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5zaXplIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZzLnNpemUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFsuLi52YWx1ZXMsIC4uLlsuLi5yZWZzXS5tYXAoKHJlZikgPT4gcmVmLmRpc3BsYXkpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBgJHt0eXBlfXNgXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHJ1bGVzIHN0YXR1c1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcnVsZXMgPSBzY2hlbWEuX3J1bGVzLm1hcCgocnVsZSkgPT4gcnVsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgWydkZWZhdWx0JywgJ2ZhaWxvdmVyJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3NbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBydWxlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBpbnRlcm5hbHMubGFiZWxzW2xvZy5ydWxlW25hbWVdIHx8IDBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBvcnQgPSB7IHJ1bGU6IG5hbWUsIHN0YXR1cyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5wYXRocy5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0LnBhdGhzID0gWy4uLmxvZy5wYXRoc107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChyZXBvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb3ZlcmFnZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmUsXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcsXG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5OiAnZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgU2NoZW1hIG1pc3NpbmcgdGVzdHMgZm9yICR7bWlzc2luZy5tYXAoaW50ZXJuYWxzLm1lc3NhZ2UpLmpvaW4oJywgJyl9YFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdmVyYWdlLmxlbmd0aCA/IGNvdmVyYWdlIDogbnVsbDtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5TdG9yZSA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc291cmNlcyA9IG5ldyBNYXAoKTsgICAgICAgICAgLy8gc2NoZW1hIC0+IHsgcGF0aHMsIGVudHJ5LCBydWxlLCB2YWxpZCwgaW52YWxpZCB9XG4gICAgICAgIHRoaXMuX2NvbWJvcyA9IG5ldyBNYXAoKTsgICAgICAgICAgIC8vIG1lcmdlZCAtPiBbc291cmNlc11cbiAgICAgICAgdGhpcy5fc2NhbihzY2hlbWEpO1xuICAgIH1cblxuICAgIGRlYnVnKHN0YXRlLCBzb3VyY2UsIG5hbWUsIHJlc3VsdCkge1xuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnICYmIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2goeyB0eXBlOiBzb3VyY2UsIG5hbWUsIHJlc3VsdCwgcGF0aDogc3RhdGUucGF0aCB9KTtcbiAgICB9XG5cbiAgICBlbnRyeShzY2hlbWEsIHN0YXRlKSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmRlYnVnKHN0YXRlLCB7IHR5cGU6ICdlbnRyeScgfSk7XG5cbiAgICAgICAgdGhpcy5fcmVjb3JkKHNjaGVtYSwgKGxvZykgPT4ge1xuXG4gICAgICAgICAgICBsb2cuZW50cnkgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmaWx0ZXIoc2NoZW1hLCBzdGF0ZSwgc291cmNlLCB2YWx1ZSkge1xuXG4gICAgICAgIGludGVybmFscy5kZWJ1ZyhzdGF0ZSwgeyB0eXBlOiBzb3VyY2UsIC4uLnZhbHVlIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlY29yZChzY2hlbWEsIChsb2cpID0+IHtcblxuICAgICAgICAgICAgbG9nW3NvdXJjZV0uYWRkKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbG9nKHNjaGVtYSwgc3RhdGUsIHNvdXJjZSwgbmFtZSwgcmVzdWx0KSB7XG5cbiAgICAgICAgaW50ZXJuYWxzLmRlYnVnKHN0YXRlLCB7IHR5cGU6IHNvdXJjZSwgbmFtZSwgcmVzdWx0OiByZXN1bHQgPT09ICdmdWxsJyA/ICdwYXNzJyA6IHJlc3VsdCB9KTtcblxuICAgICAgICB0aGlzLl9yZWNvcmQoc2NoZW1hLCAobG9nKSA9PiB7XG5cbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdW25hbWVdID0gbG9nW3NvdXJjZV1bbmFtZV0gfHwgMDtcbiAgICAgICAgICAgIGxvZ1tzb3VyY2VdW25hbWVdIHw9IGludGVybmFscy5jb2Rlc1tyZXN1bHRdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNvbHZlKHN0YXRlLCByZWYsIHRvKSB7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9nID0geyB0eXBlOiAncmVzb2x2ZScsIHJlZjogcmVmLmRpc3BsYXksIHRvLCBwYXRoOiBzdGF0ZS5wYXRoIH07XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LmRlYnVnLnB1c2gobG9nKTtcbiAgICB9XG5cbiAgICB2YWx1ZShzdGF0ZSwgYnksIGZyb20sIHRvLCBuYW1lKSB7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5tYWluc3RheS5kZWJ1ZyB8fFxuICAgICAgICAgICAgRGVlcEVxdWFsKGZyb20sIHRvKSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2cgPSB7IHR5cGU6ICd2YWx1ZScsIGJ5LCBmcm9tLCB0bywgcGF0aDogc3RhdGUucGF0aCB9O1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgbG9nLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUubWFpbnN0YXkuZGVidWcucHVzaChsb2cpO1xuICAgIH1cblxuICAgIF9yZWNvcmQoc2NoZW1hLCBlYWNoKSB7XG5cbiAgICAgICAgY29uc3QgbG9nID0gdGhpcy5fc291cmNlcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgZWFjaChsb2cpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc291cmNlcyA9IHRoaXMuX2NvbWJvcy5nZXQoc2NoZW1hKTtcbiAgICAgICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkKHNvdXJjZSwgZWFjaCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2NhbihzY2hlbWEsIF9wYXRoKSB7XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IF9wYXRoIHx8IFtdO1xuXG4gICAgICAgIGxldCBsb2cgPSB0aGlzLl9zb3VyY2VzLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAoIWxvZykge1xuICAgICAgICAgICAgbG9nID0ge1xuICAgICAgICAgICAgICAgIHBhdGhzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgZW50cnk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJ1bGU6IHt9LFxuICAgICAgICAgICAgICAgIHZhbGlkOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgaW52YWxpZDogbmV3IFNldCgpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VzLnNldChzY2hlbWEsIGxvZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZy5wYXRocy5hZGQocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlYWNoID0gKHN1Yiwgc291cmNlKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHN1YklkID0gaW50ZXJuYWxzLmlkKHN1Yiwgc291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX3NjYW4oc3ViLCBwYXRoLmNvbmNhdChzdWJJZCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNjaGVtYS4kX21vZGlmeSh7IGVhY2gsIHJlZjogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgX2NvbWJpbmUobWVyZ2VkLCBzb3VyY2VzKSB7XG5cbiAgICAgICAgdGhpcy5fY29tYm9zLnNldChtZXJnZWQsIHNvdXJjZXMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLm1lc3NhZ2UgPSBmdW5jdGlvbiAoaXRlbSkge1xuXG4gICAgY29uc3QgcGF0aCA9IGl0ZW0ucGF0aHMgPyBFcnJvcnMucGF0aChpdGVtLnBhdGhzWzBdKSArIChpdGVtLnJ1bGUgPyAnOicgOiAnJykgOiAnJztcbiAgICByZXR1cm4gYCR7cGF0aH0ke2l0ZW0ucnVsZSB8fCAnJ30gKCR7aXRlbS5zdGF0dXN9KWA7XG59O1xuXG5cbmludGVybmFscy5pZCA9IGZ1bmN0aW9uIChzY2hlbWEsIHsgc291cmNlLCBuYW1lLCBwYXRoLCBrZXkgfSkge1xuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MuaWQpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5fZmxhZ3MuaWQ7XG4gICAgfVxuXG4gICAgaWYgKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIG5hbWUgPSBgQCR7bmFtZX1gO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gJ3Rlcm1zJykge1xuICAgICAgICByZXR1cm4gW25hbWUsIHBhdGhbTWF0aC5taW4ocGF0aC5sZW5ndGggLSAxLCAxKV1dO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xufTtcblxuXG5pbnRlcm5hbHMuc3ViID0gZnVuY3Rpb24gKHBhdGhzLCBza2lwcGVkKSB7XG5cbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBza2lwIG9mIHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlmIChEZWVwRXF1YWwocGF0aC5zbGljZSgwLCBza2lwLmxlbmd0aCksIHNraXApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbmludGVybmFscy5kZWJ1ZyA9IGZ1bmN0aW9uIChzdGF0ZSwgZXZlbnQpIHtcblxuICAgIGlmIChzdGF0ZS5tYWluc3RheS5kZWJ1Zykge1xuICAgICAgICBldmVudC5wYXRoID0gc3RhdGUuZGVidWcgPyBbLi4uc3RhdGUucGF0aCwgc3RhdGUuZGVidWddIDogc3RhdGUucGF0aDtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkuZGVidWcucHVzaChldmVudCk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYWx0ZXJuYXRpdmVzJyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgbWF0Y2g6IHsgZGVmYXVsdDogJ2FueScgfSAgICAgICAgICAgICAgICAgLy8gJ2FueScsICdvbmUnLCAnYWxsJ1xuICAgIH0sXG5cbiAgICB0ZXJtczoge1xuXG4gICAgICAgIG1hdGNoZXM6IHsgaW5pdDogW10sIHJlZ2lzdGVyOiBSZWYudG9TaWJsaW5nIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIC4uLnNjaGVtYXMpIHtcblxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50cnkoLi4uc2NoZW1hc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2NoZW1hLnRyeSguLi5zY2hlbWFzKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICBjb25zdCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9ID0gaGVscGVycztcblxuICAgICAgICAvLyBNYXRjaCBhbGwgb3Igb25lXG5cbiAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3MubWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBoaXRzID0gMDtcbiAgICAgICAgICAgIGxldCBtYXRjaGVkO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLiRfdGVybXMubWF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubmVzdChpdGVtLnNjaGVtYSwgYG1hdGNoLiR7aX1gKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0YXRlLnNuYXBzaG90KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLnNjaGVtYS4kX3ZhbGlkYXRlKHZhbHVlLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICsraGl0cztcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZCA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoaXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLmFueScpIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLm1hdGNoID09PSAnb25lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaXRzID09PSAxID8geyB2YWx1ZTogbWF0Y2hlZCB9IDogeyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMub25lJykgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhpdHMgPT09IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoID8geyB2YWx1ZSB9IDogeyBlcnJvcnM6IGVycm9yKCdhbHRlcm5hdGl2ZXMuYWxsJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1hdGNoIGFueVxuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLm1hdGNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzY2hlbWEuJF90ZXJtcy5tYXRjaGVzW2ldO1xuXG4gICAgICAgICAgICAvLyBUcnlcblxuICAgICAgICAgICAgaWYgKGl0ZW0uc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLm5lc3QoaXRlbS5zY2hlbWEsIGBtYXRjaC4ke2l9YCk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5zbmFwc2hvdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5zY2hlbWEuJF92YWxpZGF0ZSh2YWx1ZSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUucmVzdG9yZSgpO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgc2NoZW1hOiBpdGVtLnNjaGVtYSwgcmVwb3J0czogcmVzdWx0LmVycm9ycyB9KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29uZGl0aW9uYWxcblxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBpdGVtLnJlZiA/IGl0ZW0ucmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcykgOiB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RzID0gaXRlbS5pcyA/IFtpdGVtXSA6IGl0ZW0uc3dpdGNoO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRlc3RzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdCA9IHRlc3RzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXMsIHRoZW4sIG90aGVyd2lzZSB9ID0gdGVzdDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gYG1hdGNoLiR7aX0ke2l0ZW0uc3dpdGNoID8gJy4nICsgaiA6ICcnfWA7XG4gICAgICAgICAgICAgICAgaWYgKCFpcy4kX21hdGNoKGlucHV0LCBzdGF0ZS5uZXN0KGlzLCBgJHtpZH0uaXNgKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdGhlcndpc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlcndpc2UuJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUubmVzdChvdGhlcndpc2UsIGAke2lkfS5vdGhlcndpc2VgKSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZW4uJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUubmVzdCh0aGVuLCBgJHtpZH0udGhlbmApLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5lcnJvcnMoZXJyb3JzLCBoZWxwZXJzKTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBjb25kaXRpb25hbDoge1xuICAgICAgICAgICAgbWV0aG9kKGNvbmRpdGlvbiwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9mbGFncy5fZW5kZWRTd2l0Y2gsICdVbnJlYWNoYWJsZSBjb25kaXRpb24nKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXRoaXMuX2ZsYWdzLm1hdGNoLCAnQ2Fubm90IGNvbWJpbmUgbWF0Y2ggbW9kZScsIHRoaXMuX2ZsYWdzLm1hdGNoLCAnd2l0aCBjb25kaXRpb25hbCBydWxlJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMuYnJlYWsgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCB1c2UgYnJlYWsgb3B0aW9uIHdpdGggYWx0ZXJuYXRpdmVzIGNvbmRpdGlvbmFsJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IENvbXBpbGUud2hlbihvYmosIGNvbmRpdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IG1hdGNoLmlzID8gW21hdGNoXSA6IG1hdGNoLnN3aXRjaDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZGl0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50aGVuICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm90aGVyd2lzZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouJF9zZXRGbGFnKCdfZW5kZWRTd2l0Y2gnLCB0cnVlLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubWF0Y2hlcy5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1hdGNoOiB7XG4gICAgICAgICAgICBtZXRob2QobW9kZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KFsnYW55JywgJ29uZScsICdhbGwnXS5pbmNsdWRlcyhtb2RlKSwgJ0ludmFsaWQgYWx0ZXJuYXRpdmVzIG1hdGNoIG1vZGUnLCBtb2RlKTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RlICE9PSAnYW55Jykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHRoaXMuJF90ZXJtcy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQobWF0Y2guc2NoZW1hLCAnQ2Fubm90IGNvbWJpbmUgbWF0Y2ggbW9kZScsIG1vZGUsICd3aXRoIGNvbmRpdGlvbmFsIHJ1bGVzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ21hdGNoJywgbW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJ5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4uc2NoZW1hcykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHNjaGVtYXMubGVuZ3RoLCAnTWlzc2luZyBhbHRlcm5hdGl2ZSBzY2hlbWFzJyk7XG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoc2NoZW1hcywgJ3RyeScpO1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLl9mbGFncy5fZW5kZWRTd2l0Y2gsICdVbnJlYWNoYWJsZSBjb25kaXRpb24nKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBzY2hlbWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hdGNoZXMucHVzaCh7IHNjaGVtYTogb2JqLiRfY29tcGlsZShzY2hlbWEpIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgbGFiZWwobmFtZSkge1xuXG4gICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfc3VwZXIubGFiZWwobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBlYWNoID0gKGl0ZW0sIHNvdXJjZSkgPT4gKHNvdXJjZS5wYXRoWzBdICE9PSAnaXMnID8gaXRlbS5sYWJlbChuYW1lKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqLiRfbW9kaWZ5KHsgZWFjaCwgcmVmOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWJ1aWxkKHNjaGVtYSkge1xuXG4gICAgICAgIC8vIEZsYWcgd2hlbiBhbiBhbHRlcm5hdGl2ZSB0eXBlIGlzIGFuIGFycmF5XG5cbiAgICAgICAgY29uc3QgZWFjaCA9IChpdGVtKSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChDb21tb24uaXNTY2hlbWEoaXRlbSkgJiZcbiAgICAgICAgICAgICAgICBpdGVtLnR5cGUgPT09ICdhcnJheScpIHtcblxuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NoZW1hLiRfbW9kaWZ5KHsgZWFjaCB9KTtcbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgZGVzYy5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSB9ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai50cnkoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChyZWYsIHsgaXMsIHRoZW4sIG5vdCwgb3RoZXJ3aXNlLCBzd2l0Y2g6IG1hdGNoLnN3aXRjaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5jb25kaXRpb25hbChpcywgeyB0aGVuLCBvdGhlcndpc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5hbGwnOiAnXCJ7eyNsYWJlbH19XCIgZG9lcyBub3QgbWF0Y2ggYWxsIG9mIHRoZSByZXF1aXJlZCB0eXBlcycsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMuYW55JzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMubWF0Y2gnOiAnXCJ7eyNsYWJlbH19XCIgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBhbGxvd2VkIHR5cGVzJyxcbiAgICAgICAgJ2FsdGVybmF0aXZlcy5vbmUnOiAnXCJ7eyNsYWJlbH19XCIgbWF0Y2hlcyBtb3JlIHRoYW4gb25lIGFsbG93ZWQgdHlwZScsXG4gICAgICAgICdhbHRlcm5hdGl2ZXMudHlwZXMnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBvbmUgb2Yge3sjdHlwZXN9fSdcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5lcnJvcnMgPSBmdW5jdGlvbiAoZmFpbHVyZXMsIHsgZXJyb3IsIHN0YXRlIH0pIHtcblxuICAgIC8vIE5vdGhpbmcgbWF0Y2hlZCBkdWUgdG8gdHlwZSBjcml0ZXJpYSBydWxlc1xuXG4gICAgaWYgKCFmYWlsdXJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLmFueScpIH07XG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIGVycm9yXG5cbiAgICBpZiAoZmFpbHVyZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogZmFpbHVyZXNbMF0ucmVwb3J0cyB9O1xuICAgIH1cblxuICAgIC8vIEFuYWx5emUgcmVhc29uc1xuXG4gICAgY29uc3QgdmFsaWRzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGNvbXBsZXggPSBbXTtcblxuICAgIGZvciAoY29uc3QgeyByZXBvcnRzLCBzY2hlbWEgfSBvZiBmYWlsdXJlcykge1xuXG4gICAgICAgIC8vIE11bHRpcGxlIGVycm9ycyAoIWFib3J0RWFybHkpXG5cbiAgICAgICAgaWYgKHJlcG9ydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy51bm1hdGNoZWQoZmFpbHVyZXMsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1c3RvbSBlcnJvclxuXG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IHJlcG9ydHNbMF07XG4gICAgICAgIGlmIChyZXBvcnQgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy51bm1hdGNoZWQoZmFpbHVyZXMsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEludGVybmFsIG9iamVjdCBvciBhcnJheSBlcnJvclxuXG4gICAgICAgIGlmIChyZXBvcnQuc3RhdGUucGF0aC5sZW5ndGggIT09IHN0YXRlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21wbGV4LnB1c2goeyB0eXBlOiBzY2hlbWEudHlwZSwgcmVwb3J0IH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZHNcblxuICAgICAgICBpZiAocmVwb3J0LmNvZGUgPT09ICdhbnkub25seScpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsaWQgb2YgcmVwb3J0LmxvY2FsLnZhbGlkcykge1xuICAgICAgICAgICAgICAgIHZhbGlkcy5hZGQodmFsaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhc2UgdHlwZVxuXG4gICAgICAgIGNvbnN0IFt0eXBlLCBjb2RlXSA9IHJlcG9ydC5jb2RlLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChjb2RlICE9PSAnYmFzZScpIHtcbiAgICAgICAgICAgIGNvbXBsZXgucHVzaCh7IHR5cGU6IHNjaGVtYS50eXBlLCByZXBvcnQgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbGlkcy5hZGQodHlwZSk7XG4gICAgfVxuXG4gICAgLy8gQWxsIGVycm9ycyBhcmUgYmFzZSB0eXBlcyBvciB2YWxpZHNcblxuICAgIGlmICghY29tcGxleC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLnR5cGVzJywgeyB0eXBlczogWy4uLnZhbGlkc10gfSkgfTtcbiAgICB9XG5cbiAgICAvLyBTaW5nbGUgY29tcGxleCBlcnJvclxuXG4gICAgaWYgKGNvbXBsZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7IGVycm9yczogY29tcGxleFswXS5yZXBvcnQgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnVubWF0Y2hlZChmYWlsdXJlcywgZXJyb3IpO1xufTtcblxuXG5pbnRlcm5hbHMudW5tYXRjaGVkID0gZnVuY3Rpb24gKGZhaWx1cmVzLCBlcnJvcikge1xuXG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKC4uLmZhaWx1cmUucmVwb3J0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcignYWx0ZXJuYXRpdmVzLm1hdGNoJywgRXJyb3JzLmRldGFpbHMoZXJyb3JzLCB7IG92ZXJyaWRlOiBmYWxzZSB9KSkgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBNZXNzYWdlcyA9IHJlcXVpcmUoJy4uL21lc3NhZ2VzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlLmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYW55JyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgb25seTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgYWx0ZXJhdGlvbnM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICBleGFtcGxlczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIGV4dGVybmFsczogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIG1ldGFzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIG5vdGVzOiB7IGluaXQ6IFtdIH0sXG4gICAgICAgIHNoYXJlZDogeyBpbml0OiBudWxsIH0sXG4gICAgICAgIHRhZ3M6IHsgaW5pdDogW10gfSxcbiAgICAgICAgd2hlbnM6IHsgaW5pdDogbnVsbCB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY3VzdG9tOiB7XG4gICAgICAgICAgICBtZXRob2QobWV0aG9kLCBkZXNjcmlwdGlvbikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicsICdNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRpb24gJiYgdHlwZW9mIGRlc2NyaXB0aW9uID09PSAnc3RyaW5nJywgJ0Rlc2NyaXB0aW9uIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnY3VzdG9tJywgYXJnczogeyBtZXRob2QsIGRlc2NyaXB0aW9uIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbWV0aG9kIH0pIHtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdhbnkuY3VzdG9tJywgeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ21ldGhvZCcsICdkZXNjcmlwdGlvbiddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBtZXNzYWdlczoge1xuICAgICAgICAgICAgbWV0aG9kKG1lc3NhZ2VzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVmcyh7IG1lc3NhZ2VzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNoYXJlZDoge1xuICAgICAgICAgICAgbWV0aG9kKHNjaGVtYSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KENvbW1vbi5pc1NjaGVtYShzY2hlbWEpICYmIHNjaGVtYS5fZmxhZ3MuaWQsICdTY2hlbWEgbXVzdCBiZSBhIHNjaGVtYSB3aXRoIGFuIGlkJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuc2hhcmVkID0gb2JqLiRfdGVybXMuc2hhcmVkIHx8IFtdO1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnNoYXJlZC5wdXNoKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdhcm5pbmc6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb2RlLCBsb2NhbCkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGNvZGUgJiYgdHlwZW9mIGNvZGUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCB3YXJuaW5nIGNvZGUnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICd3YXJuaW5nJywgYXJnczogeyBjb2RlLCBsb2NhbCB9LCB3YXJuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGNvZGUsIGxvY2FsIH0pIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGNvZGUsIGxvY2FsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvZGUnLCAnbG9jYWwnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbW9kaWZpZXJzOiB7XG5cbiAgICAgICAga2VlcChydWxlLCBlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBydWxlLmtlZXAgPSBlbmFibGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1lc3NhZ2UocnVsZSwgbWVzc2FnZSkge1xuXG4gICAgICAgICAgICBydWxlLm1lc3NhZ2UgPSBNZXNzYWdlcy5jb21waWxlKG1lc3NhZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdhcm4ocnVsZSwgZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgcnVsZS53YXJuID0gZW5hYmxlZDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gZGVzY1trZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKFsnZXhhbXBsZXMnLCAnZXh0ZXJuYWxzJywgJ21ldGFzJywgJ25vdGVzJywgJ3RhZ3MnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmpba2V5LnNsaWNlKDAsIC0xKV0odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2FsdGVyYXRpb25zJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbHRlciA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0LCBhZGp1c3RlciB9IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJbdGFyZ2V0XSA9IGFkanVzdGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLmFsdGVyKGFsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3doZW5zJykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWYsIGlzLCBub3QsIHRoZW4sIG90aGVyd2lzZSwgY29uY2F0IH0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25jYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmouY29uY2F0KGNvbmNhdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoud2hlbihyZWYsIHsgaXMsIG5vdCwgdGhlbiwgb3RoZXJ3aXNlLCBzd2l0Y2g6IHZhbHVlLnN3aXRjaCwgYnJlYWs6IHZhbHVlLmJyZWFrIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLndoZW4oaXMsIHsgdGhlbiwgb3RoZXJ3aXNlLCBicmVhazogdmFsdWUuYnJlYWsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnc2hhcmVkJykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnNoYXJlZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2FueS5jdXN0b20nOiAnXCJ7eyNsYWJlbH19XCIgZmFpbGVkIGN1c3RvbSB2YWxpZGF0aW9uIGJlY2F1c2Uge3sjZXJyb3IubWVzc2FnZX19JyxcbiAgICAgICAgJ2FueS5kZWZhdWx0JzogJ1wie3sjbGFiZWx9fVwiIHRocmV3IGFuIGVycm9yIHdoZW4gcnVubmluZyBkZWZhdWx0IG1ldGhvZCcsXG4gICAgICAgICdhbnkuZmFpbG92ZXInOiAnXCJ7eyNsYWJlbH19XCIgdGhyZXcgYW4gZXJyb3Igd2hlbiBydW5uaW5nIGZhaWxvdmVyIG1ldGhvZCcsXG4gICAgICAgICdhbnkuaW52YWxpZCc6ICdcInt7I2xhYmVsfX1cIiBjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlJyxcbiAgICAgICAgJ2FueS5vbmx5JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUge2lmKCN2YWxpZHMubGVuZ3RoID09IDEsIFwiXCIsIFwib25lIG9mIFwiKX17eyN2YWxpZHN9fScsXG4gICAgICAgICdhbnkucmVmJzogJ1wie3sjbGFiZWx9fVwiIHt7I2FyZ319IHJlZmVyZW5jZXMgXCJ7eyNyZWZ9fVwiIHdoaWNoIHt7I3JlYXNvbn19JyxcbiAgICAgICAgJ2FueS5yZXF1aXJlZCc6ICdcInt7I2xhYmVsfX1cIiBpcyByZXF1aXJlZCcsXG4gICAgICAgICdhbnkudW5rbm93bic6ICdcInt7I2xhYmVsfX1cIiBpcyBub3QgYWxsb3dlZCdcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEZWVwRXF1YWwgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9kZWVwRXF1YWwnKTtcbmNvbnN0IFJlYWNoID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvcmVhY2gnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuY29uc3QgQ29tcGlsZSA9IHJlcXVpcmUoJy4uL2NvbXBpbGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2FycmF5JyxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgc2luZ2xlOiB7IGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgICAgIHNwYXJzZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgaXRlbXM6IHsgaW5pdDogW10sIG1hbmlmZXN0OiAnc2NoZW1hJyB9LFxuICAgICAgICBvcmRlcmVkOiB7IGluaXQ6IFtdLCBtYW5pZmVzdDogJ3NjaGVtYScgfSxcblxuICAgICAgICBfZXhjbHVzaW9uczogeyBpbml0OiBbXSB9LFxuICAgICAgICBfaW5jbHVzaW9uczogeyBpbml0OiBbXSB9LFxuICAgICAgICBfcmVxdWlyZWRzOiB7IGluaXQ6IFtdIH1cbiAgICB9LFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdvYmplY3QnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ID0gc2NoZW1hLiRfZ2V0UnVsZSgnc29ydCcpO1xuICAgICAgICAgICAgaWYgKCFzb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnNvcnQoc2NoZW1hLCB2YWx1ZSwgc29ydC5hcmdzLm9wdGlvbnMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3Muc2luZ2xlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlID0gW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBzaW5nbGVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogc2luZ2xlIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yczogZXJyb3IoJ2FycmF5LmJhc2UnKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY2hlbWEuJF9nZXRSdWxlKCdpdGVtcycpICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZS5zbGljZSgpIH07ICAgICAgICAvLyBDbG9uZSB0aGUgYXJyYXkgc28gdGhhdCB3ZSBkb24ndCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgaGFzOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBzY2hlbWEgPSB0aGlzLiRfY29tcGlsZShzY2hlbWEsIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdoYXMnLCBhcmdzOiB7IHNjaGVtYSB9IH0pO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzdGF0ZSwgcHJlZnMsIGVycm9yIH0sIHsgc2NoZW1hOiBoYXMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgYW5jZXN0b3JzLCBoYXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzLiRfbWF0Y2godmFsdWVbaV0sIGxvY2FsU3RhdGUsIHByZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybkxhYmVsID0gaGFzLl9mbGFncy5sYWJlbDtcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybkxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkuaGFzS25vd24nLCB7IHBhdHRlcm5MYWJlbCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5Lmhhc1Vua25vd24nLCBudWxsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4uc2NoZW1hcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQoc2NoZW1hcywgJ2l0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRoaXMuJF9jb21waWxlKHNjaGVtYXNbaV0pLCBpLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuaXRlbXMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXF1aXJlZHMgPSBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZHMgPSBzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5jbHVzaW9ucyA9IFsuLi5zY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucywgLi4ucmVxdWlyZWRzXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHdhc0FycmF5ID0gIXZhbHVlW0NvbW1vbi5zeW1ib2xzLmFycmF5U2luZ2xlXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbQ29tbW9uLnN5bWJvbHMuYXJyYXlTaW5nbGVdO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGlsID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWw7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdmFsdWVbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB3YXNBcnJheSA/IGkgOiBuZXcgTnVtYmVyKGkpOyAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gWy4uLnN0YXRlLnBhdGgsIGtleV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3BhcnNlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yKCdhcnJheS5zcGFyc2UnLCB7IGtleSwgcGF0aCwgcG9zOiBpLCB2YWx1ZTogdW5kZWZpbmVkIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4Y2x1c2lvbnNcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBleGNsdXNpb24gb2Ygc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhjbHVzaW9uLiRfbWF0Y2goaXRlbSwgc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBleGNsdXNpb24pLCBwcmVmcywgeyBwcmVzZW5jZTogJ2lnbm9yZScgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LmV4Y2x1ZGVzJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT3JkZXJlZFxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5vcmRlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yZGVyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyZWQgPSBvcmRlcmVkcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IG9yZGVyZWQuJF92YWxpZGF0ZShpdGVtLCBzdGF0ZS5sb2NhbGl6ZShwYXRoLCBhbmNlc3RvcnMsIG9yZGVyZWQpLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkuc3BhcnNlJywgeyBrZXksIHBhdGgsIHBvczogaSwgdmFsdWU6IHVuZGVmaW5lZCB9LCBzdGF0ZS5sb2NhbGl6ZShwYXRoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuJF90ZXJtcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnJvcignYXJyYXkub3JkZXJlZExlbmd0aCcsIHsgcG9zOiBpLCBsaW1pdDogc2NoZW1hLiRfdGVybXMub3JkZXJlZC5sZW5ndGggfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgLy8gTm8gcmVhc29uIHRvIGNvbnRpbnVlIHNpbmNlIHRoZXJlIGFyZSBubyBvdGhlciBydWxlcyB0byB2YWxpZGF0ZSBvdGhlciB0aGFuIGFycmF5Lm9yZGVyZWRMZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcXVpcmVkc1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkQ2hlY2tzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBqbCA9IHJlcXVpcmVkcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgamw7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgcmVxdWlyZWRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gcmVxdWlyZWRzW2pdLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRDaGVja3Nbal0gPSByZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gcmVzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHJlcXVpcmVkcywgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1qO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tamw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3Muc3BhcnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdXNpb25zXG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gcHJlZnMuc3RyaXBVbmtub3duICYmICEhcHJlZnMuc3RyaXBVbmtub3duLmFycmF5cyB8fCBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBqbCA9IGluY2x1c2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluY2x1c2lvbiBvZiBpbmNsdXNpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHJlLXJ1bm5pbmcgcmVxdWlyZWRzIHRoYXQgYWxyZWFkeSBkaWRuJ3QgbWF0Y2ggaW4gdGhlIHByZXZpb3VzIGxvb3BcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzQ2hlY2sgPSByZXF1aXJlZHMuaW5kZXhPZihpbmNsdXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2hlY2sgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVxdWlyZWRDaGVja3NbcHJldmlvdXNDaGVja107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0YXRlID0gc3RhdGUubG9jYWxpemUocGF0aCwgYW5jZXN0b3JzLCBpbmNsdXNpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RhdGUuc25hcHNob3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGluY2x1c2lvbi4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlcy5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1c2lvbi5fZmxhZ3MucmVzdWx0ID09PSAnc3RyaXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmFzdFNwbGljZSh2YWx1ZSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWlsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzY2hlbWEuX2ZsYWdzLnNwYXJzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LnNwYXJzZScsIHsga2V5LCBwYXRoLCBwb3M6IGksIHZhbHVlOiB1bmRlZmluZWQgfSwgc3RhdGUubG9jYWxpemUocGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbaV0gPSByZXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTdGF0ZS5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYWN0dWFsIGVycm9yIGlmIG9ubHkgb25lIGluY2x1c2lvbiBkZWZpbmVkXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqbCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpcFVua25vd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLmZhc3RTcGxpY2UodmFsdWUsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0taWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCguLi5yZXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWlzVmFsaWQpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmlwVW5rbm93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFscy5mYXN0U3BsaWNlKHZhbHVlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1pbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IoJ2FycmF5LmluY2x1ZGVzJywgeyBwb3M6IGksIHZhbHVlOiBpdGVtIH0sIHN0YXRlLmxvY2FsaXplKHBhdGgpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbHMuZmlsbE1pc3NlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgcmVxdWlyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3JkZXJlZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5maWxsT3JkZXJlZEVycm9ycyhzY2hlbWEsIGVycm9ycywgb3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID8gZXJyb3JzIDogdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgIG1hbmlmZXN0OiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIGxlbmd0aDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJz0nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLmxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2FycmF5LicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb3JkZXJlZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnNjaGVtYXMpIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHNjaGVtYXMsICdvcmRlcmVkJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSgnaXRlbXMnKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1hcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gQ29tbW9uLnRyeVdpdGhQYXRoKCgpID0+IHRoaXMuJF9jb21waWxlKHNjaGVtYXNbaV0pLCBpLCB7IGFwcGVuZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIG9iaik7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm9yZGVyZWQucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLiRfbXV0YXRlUmVidWlsZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpbmdsZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIXZhbHVlIHx8ICF0aGlzLl9mbGFncy5fYXJyYXlJdGVtcywgJ0Nhbm5vdCBzcGVjaWZ5IHNpbmdsZSBydWxlIHdoZW4gYXJyYXkgaGFzIGFycmF5IGl0ZW1zJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3NpbmdsZScsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2J5JywgJ29yZGVyJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyOiBvcHRpb25zLm9yZGVyIHx8ICdhc2NlbmRpbmcnXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmJ5ID0gQ29tcGlsZS5yZWYob3B0aW9ucy5ieSwgeyBhbmNlc3RvcjogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFzZXR0aW5ncy5ieS5hbmNlc3RvciwgJ0Nhbm5vdCBzb3J0IGJ5IGFuY2VzdG9yJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NvcnQnLCBhcmdzOiB7IG9wdGlvbnM6IHNldHRpbmdzIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IsIHN0YXRlLCBwcmVmcywgc2NoZW1hIH0sIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBzb3J0ZWQsIGVycm9ycyB9ID0gaW50ZXJuYWxzLnNvcnQoc2NoZW1hLCB2YWx1ZSwgb3B0aW9ucywgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gIT09IHNvcnRlZFtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKCdhcnJheS5zb3J0JywgeyBvcmRlcjogb3B0aW9ucy5vcmRlciwgYnk6IG9wdGlvbnMuYnkgPyBvcHRpb25zLmJ5LmtleSA6ICd2YWx1ZScgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNwYXJzZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhZW5hYmxlZDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mbGFncy5zcGFyc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHZhbHVlID8gdGhpcy5jbG9uZSgpIDogdGhpcy4kX2FkZFJ1bGUoJ2l0ZW1zJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX3NldEZsYWcoJ3NwYXJzZScsIHZhbHVlLCB7IGNsb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmlxdWU6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb21wYXJhdG9yLCBvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCghY29tcGFyYXRvciB8fCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycsICdjb21wYXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnaWdub3JlVW5kZWZpbmVkJywgJ3NlcGFyYXRvciddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSB7IG5hbWU6ICd1bmlxdWUnLCBhcmdzOiB7IG9wdGlvbnMsIGNvbXBhcmF0b3IgfSB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gQ29tbW9uLmRlZmF1bHQob3B0aW9ucy5zZXBhcmF0b3IsICcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnBhdGggPSBzZXBhcmF0b3IgPyBjb21wYXJhdG9yLnNwbGl0KHNlcGFyYXRvcikgOiBbY29tcGFyYXRvcl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHJ1bGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCB7IHN0YXRlLCBlcnJvciwgc2NoZW1hIH0sIHsgY29tcGFyYXRvcjogcmF3LCBvcHRpb25zIH0sIHsgY29tcGFyYXRvciwgcGF0aCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmb3VuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBudW1iZXI6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiBuZXcgTWFwKCksXG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbTogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSBjb21wYXJhdG9yIHx8IERlZXBFcXVhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHBhdGggPyBSZWFjaCh2YWx1ZVtpXSwgcGF0aCkgOiB2YWx1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IGNvbXBhcmF0b3IgPyBmb3VuZC5jdXN0b20gOiBmb3VuZFt0eXBlb2YgaXRlbV07XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChyZWNvcmRzLCAnRmFpbGVkIHRvIGZpbmQgdW5pcXVlIG1hcCBjb250YWluZXIgZm9yIHR5cGUnLCB0eXBlb2YgaXRlbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZHMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSByZWNvcmRzLmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEoY3VycmVudCA9IGVudHJpZXMubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoY3VycmVudC52YWx1ZVswXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cGVQb3M6IGN1cnJlbnQudmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXBlVmFsdWU6IHZhbHVlW2N1cnJlbnQudmFsdWVbMV1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucGF0aCA9IHJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignYXJyYXkudW5pcXVlJywgY29udGV4dCwgbG9jYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzLnNldChpdGVtLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoIWlnbm9yZVVuZGVmaW5lZCB8fCBpdGVtICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3Jkc1tpdGVtXSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVBvczogcmVjb3Jkc1tpdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVwZVZhbHVlOiB2YWx1ZVtyZWNvcmRzW2l0ZW1dXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBhdGggPSByYXc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCBpXSwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ2FycmF5LnVuaXF1ZScsIGNvbnRleHQsIGxvY2FsU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRzW2l0ZW1dID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2NvbXBhcmF0b3InLCAnb3B0aW9ucyddLFxuICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIHNldDoge1xuICAgICAgICAgICAgZnJvbTogQXJyYXkuaXNBcnJheSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBzY2hlbWEuJF90ZXJtcy5faW5jbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fZXhjbHVzaW9ucyA9IFtdO1xuICAgICAgICBzY2hlbWEuJF90ZXJtcy5fcmVxdWlyZWRzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHNjaGVtYS4kX3Rlcm1zLml0ZW1zKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUodHlwZSwgc2NoZW1hKTtcblxuICAgICAgICAgICAgaWYgKHR5cGUuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX3JlcXVpcmVkcy5wdXNoKHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5fZmxhZ3MucHJlc2VuY2UgPT09ICdmb3JiaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRfdGVybXMuX2V4Y2x1c2lvbnMucHVzaCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLl9pbmNsdXNpb25zLnB1c2godHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygc2NoZW1hLiRfdGVybXMub3JkZXJlZCkge1xuICAgICAgICAgICAgaW50ZXJuYWxzLnZhbGlkYXRlU2luZ2xlKHR5cGUsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2MuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouaXRlbXMoLi4uZGVzYy5pdGVtcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLm9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoub3JkZXJlZCguLi5kZXNjLm9yZGVyZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdhcnJheS5iYXNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYW4gYXJyYXknLFxuICAgICAgICAnYXJyYXkuZXhjbHVkZXMnOiAnXCJ7eyNsYWJlbH19XCIgY29udGFpbnMgYW4gZXhjbHVkZWQgdmFsdWUnLFxuICAgICAgICAnYXJyYXkuaGFzS25vd24nOiAnXCJ7eyNsYWJlbH19XCIgZG9lcyBub3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcmVxdWlyZWQgbWF0Y2ggZm9yIHR5cGUgXCJ7I3BhdHRlcm5MYWJlbH1cIicsXG4gICAgICAgICdhcnJheS5oYXNVbmtub3duJzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHJlcXVpcmVkIG1hdGNoJyxcbiAgICAgICAgJ2FycmF5LmluY2x1ZGVzJzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IG1hdGNoIGFueSBvZiB0aGUgYWxsb3dlZCB0eXBlcycsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkQm90aCc6ICdcInt7I2xhYmVsfX1cIiBkb2VzIG5vdCBjb250YWluIHt7I2tub3duTWlzc2VzfX0gYW5kIHt7I3Vua25vd25NaXNzZXN9fSBvdGhlciByZXF1aXJlZCB2YWx1ZShzKScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkS25vd25zJzogJ1wie3sjbGFiZWx9fVwiIGRvZXMgbm90IGNvbnRhaW4ge3sja25vd25NaXNzZXN9fScsXG4gICAgICAgICdhcnJheS5pbmNsdWRlc1JlcXVpcmVkVW5rbm93bnMnOiAnXCJ7eyNsYWJlbH19XCIgZG9lcyBub3QgY29udGFpbiB7eyN1bmtub3duTWlzc2VzfX0gcmVxdWlyZWQgdmFsdWUocyknLFxuICAgICAgICAnYXJyYXkubGVuZ3RoJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgY29udGFpbiB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm1heCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGNvbnRhaW4gbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gaXRlbXMnLFxuICAgICAgICAnYXJyYXkubWluJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgY29udGFpbiBhdCBsZWFzdCB7eyNsaW1pdH19IGl0ZW1zJyxcbiAgICAgICAgJ2FycmF5Lm9yZGVyZWRMZW5ndGgnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBjb250YWluIGF0IG1vc3Qge3sjbGltaXR9fSBpdGVtcycsXG4gICAgICAgICdhcnJheS5zb3J0JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgc29ydGVkIGluIHsjb3JkZXJ9IG9yZGVyIGJ5IHt7I2J5fX0nLFxuICAgICAgICAnYXJyYXkuc29ydC5taXNtYXRjaGluZyc6ICdcInt7I2xhYmVsfX1cIiBjYW5ub3QgYmUgc29ydGVkIGR1ZSB0byBtaXNtYXRjaGluZyB0eXBlcycsXG4gICAgICAgICdhcnJheS5zb3J0LnVuc3VwcG9ydGVkJzogJ1wie3sjbGFiZWx9fVwiIGNhbm5vdCBiZSBzb3J0ZWQgZHVlIHRvIHVuc3VwcG9ydGVkIHR5cGUgeyN0eXBlfScsXG4gICAgICAgICdhcnJheS5zcGFyc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBub3QgYmUgYSBzcGFyc2UgYXJyYXkgaXRlbScsXG4gICAgICAgICdhcnJheS51bmlxdWUnOiAnXCJ7eyNsYWJlbH19XCIgY29udGFpbnMgYSBkdXBsaWNhdGUgdmFsdWUnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMuZmlsbE1pc3NlZEVycm9ycyA9IGZ1bmN0aW9uIChzY2hlbWEsIGVycm9ycywgcmVxdWlyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBjb25zdCBrbm93bk1pc3NlcyA9IFtdO1xuICAgIGxldCB1bmtub3duTWlzc2VzID0gMDtcbiAgICBmb3IgKGNvbnN0IHJlcXVpcmVkIG9mIHJlcXVpcmVkcykge1xuICAgICAgICBjb25zdCBsYWJlbCA9IHJlcXVpcmVkLl9mbGFncy5sYWJlbDtcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICBrbm93bk1pc3Nlcy5wdXNoKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICsrdW5rbm93bk1pc3NlcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrbm93bk1pc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHVua25vd25NaXNzZXMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhcnJheS5pbmNsdWRlc1JlcXVpcmVkQm90aCcsIHZhbHVlLCB7IGtub3duTWlzc2VzLCB1bmtub3duTWlzc2VzIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRLbm93bnMnLCB2YWx1ZSwgeyBrbm93bk1pc3NlcyB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnB1c2goc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LmluY2x1ZGVzUmVxdWlyZWRVbmtub3ducycsIHZhbHVlLCB7IHVua25vd25NaXNzZXMgfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuZmlsbE9yZGVyZWRFcnJvcnMgPSBmdW5jdGlvbiAoc2NoZW1hLCBlcnJvcnMsIG9yZGVyZWRzLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBjb25zdCByZXF1aXJlZE9yZGVyZWRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG9yZGVyZWQgb2Ygb3JkZXJlZHMpIHtcbiAgICAgICAgaWYgKG9yZGVyZWQuX2ZsYWdzLnByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXF1aXJlZE9yZGVyZWRzLnB1c2gob3JkZXJlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWlyZWRPcmRlcmVkcy5sZW5ndGgpIHtcbiAgICAgICAgaW50ZXJuYWxzLmZpbGxNaXNzZWRFcnJvcnMoc2NoZW1hLCBlcnJvcnMsIHJlcXVpcmVkT3JkZXJlZHMsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmZhc3RTcGxpY2UgPSBmdW5jdGlvbiAoYXJyLCBpKSB7XG5cbiAgICBsZXQgcG9zID0gaTtcbiAgICB3aGlsZSAocG9zIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBhcnJbcG9zKytdID0gYXJyW3Bvc107XG4gICAgfVxuXG4gICAgLS1hcnIubGVuZ3RoO1xufTtcblxuXG5pbnRlcm5hbHMudmFsaWRhdGVTaW5nbGUgPSBmdW5jdGlvbiAodHlwZSwgb2JqKSB7XG5cbiAgICBpZiAodHlwZS50eXBlID09PSAnYXJyYXknIHx8XG4gICAgICAgIHR5cGUuX2ZsYWdzLl9hcnJheUl0ZW1zKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFvYmouX2ZsYWdzLnNpbmdsZSwgJ0Nhbm5vdCBzcGVjaWZ5IGFycmF5IGl0ZW0gd2l0aCBzaW5nbGUgcnVsZSBlbmFibGVkJyk7XG4gICAgICAgIG9iai4kX3NldEZsYWcoJ19hcnJheUl0ZW1zJywgdHJ1ZSwgeyBjbG9uZTogZmFsc2UgfSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuc29ydCA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzZXR0aW5ncywgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBjb25zdCBvcmRlciA9IHNldHRpbmdzLm9yZGVyID09PSAnYXNjZW5kaW5nJyA/IDEgOiAtMTtcbiAgICBjb25zdCBhRmlyc3QgPSAtMSAqIG9yZGVyO1xuICAgIGNvbnN0IGJGaXJzdCA9IG9yZGVyO1xuXG4gICAgY29uc3Qgc29ydCA9IChhLCBiKSA9PiB7XG5cbiAgICAgICAgbGV0IGNvbXBhcmUgPSBpbnRlcm5hbHMuY29tcGFyZShhLCBiLCBhRmlyc3QsIGJGaXJzdCk7XG4gICAgICAgIGlmIChjb21wYXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5ieSkge1xuICAgICAgICAgICAgYSA9IHNldHRpbmdzLmJ5LnJlc29sdmUoYSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGIgPSBzZXR0aW5ncy5ieS5yZXNvbHZlKGIsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wYXJlID0gaW50ZXJuYWxzLmNvbXBhcmUoYSwgYiwgYUZpcnN0LCBiRmlyc3QpO1xuICAgICAgICBpZiAoY29tcGFyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGE7XG4gICAgICAgIGlmICh0eXBlICE9PSB0eXBlb2YgYikge1xuICAgICAgICAgICAgdGhyb3cgc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LnNvcnQubWlzbWF0Y2hpbmcnLCB2YWx1ZSwgbnVsbCwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgdGhyb3cgc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FycmF5LnNvcnQudW5zdXBwb3J0ZWQnLCB2YWx1ZSwgeyB0eXBlIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiAoYSAtIGIpICogb3JkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYSA8IGIgPyBhRmlyc3QgOiBiRmlyc3Q7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZS5zbGljZSgpLnNvcnQoc29ydCkgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IGVyciB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYiwgYUZpcnN0LCBiRmlyc3QpIHtcblxuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIDE7ICAgICAgICAgICAvLyBBbHdheXMgbGFzdCByZWdhcmRsZXNzIG9mIHNvcnQgb3JkZXJcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAtMTsgICAgICAgICAgIC8vIEFsd2F5cyBsYXN0IHJlZ2FyZGxlc3Mgb2Ygc29ydCBvcmRlclxuICAgIH1cblxuICAgIGlmIChhID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiRmlyc3Q7XG4gICAgfVxuXG4gICAgaWYgKGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFGaXJzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdiaW5hcnknLFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206ICdzdHJpbmcnLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogQnVmZmVyLmZyb20odmFsdWUsIHNjaGVtYS5fZmxhZ3MuZW5jb2RpbmcpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlRXJyKSB7IH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignYmluYXJ5LmJhc2UnKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG4gICAgICAgIGVuY29kaW5nOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygnZW5jb2RpbmcnLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZW5ndGgnLCBtZXRob2Q6ICdsZW5ndGgnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPScgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoQ29tbW9uLmNvbXBhcmUodmFsdWUubGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignYmluYXJ5LicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnYmluYXJ5LmJhc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIGJ1ZmZlciBvciBhIHN0cmluZycsXG4gICAgICAgICdiaW5hcnkubGVuZ3RoJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUge3sjbGltaXR9fSBieXRlcycsXG4gICAgICAgICdiaW5hcnkubWF4JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHt7I2xpbWl0fX0gYnl0ZXMnLFxuICAgICAgICAnYmluYXJ5Lm1pbic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gYnl0ZXMnXG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBWYWx1ZXMgPSByZXF1aXJlKCcuLi92YWx1ZXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNCb29sID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnYm9vbGVhbicsXG5cbiAgICBmbGFnczoge1xuXG4gICAgICAgIHNlbnNpdGl2ZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgZmFsc3k6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfSxcblxuICAgICAgICB0cnV0aHk6IHtcbiAgICAgICAgICAgIGluaXQ6IG51bGwsXG4gICAgICAgICAgICBtYW5pZmVzdDogJ3ZhbHVlcydcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2UodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUgPyB2YWx1ZSA6IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vcm1hbGl6ZWQgPT09ICd0cnVlJyA/IHRydWUgOiAobm9ybWFsaXplZCA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHNjaGVtYS4kX3Rlcm1zLnRydXRoeSAmJiBzY2hlbWEuJF90ZXJtcy50cnV0aHkuaGFzKHZhbHVlLCBudWxsLCBudWxsLCAhc2NoZW1hLl9mbGFncy5zZW5zaXRpdmUpIHx8XG4gICAgICAgICAgICAgICAgKHNjaGVtYS4kX3Rlcm1zLmZhbHN5ICYmIHNjaGVtYS4kX3Rlcm1zLmZhbHN5Lmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgIXNjaGVtYS5fZmxhZ3Muc2Vuc2l0aXZlKSA/IGZhbHNlIDogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSkge1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ2Jvb2xlYW4uYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgdHJ1dGh5OiB7XG4gICAgICAgICAgICBtZXRob2QoLi4udmFsdWVzKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdCh2YWx1ZXMsICd0cnV0aHknKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy50cnV0aHkgPSBvYmouJF90ZXJtcy50cnV0aHkgfHwgbmV3IFZhbHVlcygpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsICdDYW5ub3QgY2FsbCB0cnV0aHkgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMudHJ1dGh5LmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmYWxzeToge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnZhbHVlcykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQodmFsdWVzLCAnZmFsc3knKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5mYWxzeSA9IG9iai4kX3Rlcm1zLmZhbHN5IHx8IG5ldyBWYWx1ZXMoKTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkLCAnQ2Fubm90IGNhbGwgZmFsc3kgd2l0aCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMuZmFsc3kuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNlbnNpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX3NldEZsYWcoJ3NlbnNpdGl2ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNhc3Q6IHtcbiAgICAgICAgbnVtYmVyOiB7XG4gICAgICAgICAgICBmcm9tOiBpbnRlcm5hbHMuaXNCb29sLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0Jvb2wsXG4gICAgICAgICAgICB0byh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy50cnV0aHkpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoudHJ1dGh5KC4uLmRlc2MudHJ1dGh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MuZmFsc3kpIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmouZmFsc3koLi4uZGVzYy5mYWxzeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Jvb2xlYW4uYmFzZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgYm9vbGVhbidcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IFRlbXBsYXRlID0gcmVxdWlyZSgnLi4vdGVtcGxhdGUnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuaXNEYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEFueS5leHRlbmQoe1xuXG4gICAgdHlwZTogJ2RhdGUnLFxuXG4gICAgY29lcmNlOiB7XG4gICAgICAgIGZyb206IFsnbnVtYmVyJywgJ3N0cmluZyddLFxuICAgICAgICBtZXRob2QodmFsdWUsIHsgc2NoZW1hIH0pIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGludGVybmFscy5wYXJzZSh2YWx1ZSwgc2NoZW1hLl9mbGFncy5mb3JtYXQpIHx8IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgcHJlZnMgfSkge1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICAgICAgICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHNjaGVtYS5fZmxhZ3MuZm9ybWF0O1xuXG4gICAgICAgIGlmICghcHJlZnMuY29udmVydCB8fFxuICAgICAgICAgICAgIWZvcm1hdCB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignZGF0ZS5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdkYXRlLmZvcm1hdCcsIHsgZm9ybWF0IH0pIH07XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29tcGFyZToge1xuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGRhdGUgfSwgeyBuYW1lLCBvcGVyYXRvciwgYXJncyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0byA9IGRhdGUgPT09ICdub3cnID8gRGF0ZS5ub3coKSA6IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZSh2YWx1ZS5nZXRUaW1lKCksIHRvLCBvcGVyYXRvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdkYXRlLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmRhdGUsIHZhbHVlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemU6IChkYXRlKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRlID09PSAnbm93JyA/IGRhdGUgOiBpbnRlcm5hbHMucGFyc2UoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKGRhdGUpID0+IGRhdGUgIT09IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGhhdmUgYSB2YWxpZCBkYXRlIGZvcm1hdCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICBtZXRob2QoZm9ybWF0KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWydpc28nLCAnamF2YXNjcmlwdCcsICd1bml4J10uaW5jbHVkZXMoZm9ybWF0KSwgJ1Vua25vd24gZGF0ZSBmb3JtYXQnLCBmb3JtYXQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdmb3JtYXQnLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGdyZWF0ZXI6IHtcbiAgICAgICAgICAgIG1ldGhvZChkYXRlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3JlYXRlcicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGRhdGUgfSwgb3BlcmF0b3I6ICc+JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc286IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCgnaXNvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVzczoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZXNzJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgZGF0ZSB9LCBvcGVyYXRvcjogJzwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXgnLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGRhdGUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtaW4nLCBtZXRob2Q6ICdjb21wYXJlJywgYXJnczogeyBkYXRlIH0sIG9wZXJhdG9yOiAnPj0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRpbWVzdGFtcDoge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnamF2YXNjcmlwdCcpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2phdmFzY3JpcHQnLCAndW5peCddLmluY2x1ZGVzKHR5cGUpLCAnXCJ0eXBlXCIgbXVzdCBiZSBvbmUgb2YgXCJqYXZhc2NyaXB0LCB1bml4XCInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZnJvbTogaW50ZXJuYWxzLmlzRGF0ZSxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206IGludGVybmFscy5pc0RhdGUsXG4gICAgICAgICAgICB0byh2YWx1ZSwgeyBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGUuZGF0ZSh2YWx1ZSwgcHJlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdkYXRlLmJhc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIGRhdGUnLFxuICAgICAgICAnZGF0ZS5mb3JtYXQnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBpbiB7bXNnKFwiZGF0ZS5mb3JtYXQuXCIgKyAjZm9ybWF0KSB8fCAjZm9ybWF0fSBmb3JtYXQnLFxuICAgICAgICAnZGF0ZS5ncmVhdGVyJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwie3sjbGltaXR9fVwiJyxcbiAgICAgICAgJ2RhdGUubGVzcyc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGxlc3MgdGhhbiBcInt7I2xpbWl0fX1cIicsXG4gICAgICAgICdkYXRlLm1heCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBcInt7I2xpbWl0fX1cIicsXG4gICAgICAgICdkYXRlLm1pbic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGxhcmdlciB0aGFuIG9yIGVxdWFsIHRvIFwie3sjbGltaXR9fVwiJyxcblxuICAgICAgICAvLyBNZXNzYWdlcyB1c2VkIGluIGRhdGUuZm9ybWF0XG5cbiAgICAgICAgJ2RhdGUuZm9ybWF0Lmlzbyc6ICdJU08gODYwMSBkYXRlJyxcbiAgICAgICAgJ2RhdGUuZm9ybWF0LmphdmFzY3JpcHQnOiAndGltZXN0YW1wIG9yIG51bWJlciBvZiBtaWxsaXNlY29uZHMnLFxuICAgICAgICAnZGF0ZS5mb3JtYXQudW5peCc6ICd0aW1lc3RhbXAgb3IgbnVtYmVyIG9mIHNlY29uZHMnXG4gICAgfVxufSk7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMucGFyc2UgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICgvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJU09cblxuICAgIGlmIChmb3JtYXQgPT09ICdpc28nKSB7XG4gICAgICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5kYXRlKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBudW1iZXIgc3RyaW5nXG5cbiAgICBjb25zdCBvcmlnaW5hbCA9IHZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIC9eWystXT9cXGQrKFxcLlxcZCspPyQvLnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUaW1lc3RhbXBcblxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2phdmFzY3JpcHQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRhdGUoMSAqIHZhbHVlKTsgICAgICAgIC8vIENhc3RpbmcgdG8gbnVtYmVyXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9ybWF0ID09PSAndW5peCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSgxMDAwICogdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGxhaW5cblxuICAgIHJldHVybiBpbnRlcm5hbHMuZGF0ZSh2YWx1ZSk7XG59O1xuXG5cbmludGVybmFscy5kYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IEtleXMuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGVvZjogJ2Z1bmN0aW9uJ1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuICAgICAgICBhcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID49IDAsICduIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnYXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdmdW5jdGlvbi5hcml0eScsIHsgbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjbGFzcycpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoKC9eXFxzKmNsYXNzXFxzLykudGVzdCh2YWx1ZS50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLmNsYXNzJywgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW5Bcml0eToge1xuICAgICAgICAgICAgbWV0aG9kKG4pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSAmJiBuID4gMCwgJ24gbXVzdCBiZSBhIHN0cmljdCBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluQXJpdHknLCBhcmdzOiB7IG4gfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBuIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPj0gbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ2Z1bmN0aW9uLm1pbkFyaXR5JywgeyBuIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heEFyaXR5OiB7XG4gICAgICAgICAgICBtZXRob2Qobikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KE51bWJlci5pc1NhZmVJbnRlZ2VyKG4pICYmIG4gPj0gMCwgJ24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdtYXhBcml0eScsIGFyZ3M6IHsgbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG4gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignZnVuY3Rpb24ubWF4QXJpdHknLCB7IG4gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWVzc2FnZXM6IHtcbiAgICAgICAgJ2Z1bmN0aW9uLmFyaXR5JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgaGF2ZSBhbiBhcml0eSBvZiB7eyNufX0nLFxuICAgICAgICAnZnVuY3Rpb24uY2xhc3MnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIGNsYXNzJyxcbiAgICAgICAgJ2Z1bmN0aW9uLm1heEFyaXR5JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgaGF2ZSBhbiBhcml0eSBsZXNzZXIgb3IgZXF1YWwgdG8ge3sjbn19JyxcbiAgICAgICAgJ2Z1bmN0aW9uLm1pbkFyaXR5JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgaGF2ZSBhbiBhcml0eSBncmVhdGVyIG9yIGVxdWFsIHRvIHt7I259fSdcbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXBwbHlUb0RlZmF1bHRzID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXBwbHlUb0RlZmF1bHRzJyk7XG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IFRvcG8gPSByZXF1aXJlKCdAaGFwaS90b3BvJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmNvbnN0IENvbXBpbGUgPSByZXF1aXJlKCcuLi9jb21waWxlJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IFJlZiA9IHJlcXVpcmUoJy4uL3JlZicpO1xuY29uc3QgVGVtcGxhdGUgPSByZXF1aXJlKCcuLi90ZW1wbGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICByZW5hbWVEZWZhdWx0czoge1xuICAgICAgICBhbGlhczogZmFsc2UsICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgb2xkIHZhbHVlIGluIHBsYWNlXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZSwgICAgICAgICAgICAgICAgLy8gQWxsb3cgcmVuYW1pbmcgbXVsdGlwbGUga2V5cyBpbnRvIHRoZSBzYW1lIHRhcmdldFxuICAgICAgICBvdmVycmlkZTogZmFsc2UgICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlcyBhbiBleGlzdGluZyBrZXlcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnX2tleXMnLFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlb2Y6ICdvYmplY3QnXG4gICAgfSxcblxuICAgIGZsYWdzOiB7XG5cbiAgICAgICAgdW5rbm93bjogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgZGVwZW5kZW5jaWVzOiB7IGluaXQ6IG51bGwgfSxcbiAgICAgICAga2V5czogeyBpbml0OiBudWxsLCBtYW5pZmVzdDogeyBtYXBwZWQ6IHsgZnJvbTogJ3NjaGVtYScsIHRvOiAna2V5JyB9IH0gfSxcbiAgICAgICAgcGF0dGVybnM6IHsgaW5pdDogbnVsbCB9LFxuICAgICAgICByZW5hbWVzOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBhcmdzKHNjaGVtYSwga2V5cykge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEua2V5cyhrZXlzKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGUodmFsdWUsIHsgc2NoZW1hLCBlcnJvciwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBpZiAoIXZhbHVlIHx8XG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09IHNjaGVtYS4kX3Byb3BlcnR5KCd0eXBlb2YnKSB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ29iamVjdC5iYXNlJywgeyB0eXBlOiBzY2hlbWEuJF9wcm9wZXJ0eSgndHlwZW9mJykgfSkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNraXAgaWYgdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzIHRvIHRlc3RcblxuICAgICAgICBpZiAoIXNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5kZXBlbmRlbmNpZXMgJiZcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICAgICAgICAgICAgICAgICAgICAgICAvLyBudWxsIGFsbG93cyBhbnkga2V5c1xuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zICYmXG4gICAgICAgICAgICAhc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoYWxsb3cgY2xvbmUgdmFsdWVcblxuICAgICAgICB2YWx1ZSA9IGludGVybmFscy5jbG9uZSh2YWx1ZSwgcHJlZnMpO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICAgICAgICAvLyBSZW5hbWUga2V5c1xuXG4gICAgICAgIGlmIChzY2hlbWEuJF90ZXJtcy5yZW5hbWVzICYmXG4gICAgICAgICAgICAhaW50ZXJuYWxzLnJlbmFtZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGVycm9ycykpIHtcblxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9ycyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW55dGhpbmcgYWxsb3dlZFxuXG4gICAgICAgIGlmICghc2NoZW1hLiRfdGVybXMua2V5cyAmJiAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVsbCBhbGxvd3MgYW55IGtleXNcbiAgICAgICAgICAgICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucyAmJlxuICAgICAgICAgICAgIXNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmVkIGtleXNcblxuICAgICAgICBjb25zdCB1bnByb2Nlc3NlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICAgICAgICB1bnByb2Nlc3NlZC5kZWxldGUoa2V5KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSBzdGF0ZS5sb2NhbGl6ZShbLi4uc3RhdGUucGF0aCwga2V5XSwgYW5jZXN0b3JzLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hpbGQuc2NoZW1hLiRfdmFsaWRhdGUoaXRlbSwgbG9jYWxTdGF0ZSwgcHJlZnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IHJlc3VsdC5lcnJvcnMgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5zY2hlbWEuX2ZsYWdzLnJlc3VsdCA9PT0gJ3N0cmlwJyB8fFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpdGVtICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbmtub3duIGtleXNcblxuICAgICAgICBpZiAodW5wcm9jZXNzZWQuc2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgZWFybHkgPSBpbnRlcm5hbHMudW5rbm93bihzY2hlbWEsIHZhbHVlLCB1bnByb2Nlc3NlZCwgZXJyb3JzLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgaWYgKGVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhcmx5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgZGVwZW5kZW5jaWVzXG5cbiAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkZXAgb2Ygc2NoZW1hLiRfdGVybXMuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcC5rZXkgJiZcbiAgICAgICAgICAgICAgICAgICAgZGVwLmtleS5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZmFpbGVkID0gaW50ZXJuYWxzLmRlcGVuZGVuY2llc1tkZXAucmVsXShzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKGZhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBvcnQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcihmYWlsZWQuY29kZSwgdmFsdWUsIGZhaWxlZC5jb250ZXh0LCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVwb3J0IH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnMgfTtcbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcblxuICAgICAgICBhbmQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ2FuZCcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICdhbmQnLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXBwZW5kOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFzc2VydDoge1xuICAgICAgICAgICAgbWV0aG9kKHN1YmplY3QsIHNjaGVtYSwgbWVzc2FnZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFUZW1wbGF0ZS5pc1RlbXBsYXRlKHN1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3QgPSBDb21waWxlLnJlZihzdWJqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQobWVzc2FnZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJywgJ01lc3NhZ2UgbXVzdCBiZSBhIHN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy4kX2NvbXBpbGUoc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdhc3NlcnQnLCBhcmdzOiB7IHN1YmplY3QsIHNjaGVtYSwgbWVzc2FnZSB9IH0pO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHN1YmplY3QpO1xuICAgICAgICAgICAgICAgIG9iai4kX211dGF0ZVJlZ2lzdGVyKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciwgcHJlZnMsIHN0YXRlIH0sIHsgc3ViamVjdCwgc2NoZW1hLCBtZXNzYWdlIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFib3V0ID0gc3ViamVjdC5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBSZWYuaXNSZWYoc3ViamVjdCkgPyBzdWJqZWN0LmFic29sdXRlKHN0YXRlKSA6IFtdO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuJF9tYXRjaChhYm91dCwgc3RhdGUubG9jYWxpemUocGF0aCwgW3ZhbHVlLCAuLi5zdGF0ZS5hbmNlc3RvcnNdLCBzY2hlbWEpLCBwcmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcignb2JqZWN0LmFzc2VydCcsIHsgc3ViamVjdCwgbWVzc2FnZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ3N1YmplY3QnLCAnc2NoZW1hJywgJ21lc3NhZ2UnXSxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zdGFuY2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChjb25zdHJ1Y3RvciwgbmFtZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBjb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJywgJ2NvbnN0cnVjdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgfHwgY29uc3RydWN0b3IubmFtZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdpbnN0YW5jZScsIGFyZ3M6IHsgY29uc3RydWN0b3IsIG5hbWUgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBjb25zdHJ1Y3RvciwgbmFtZSB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ29iamVjdC5pbnN0YW5jZScsIHsgdHlwZTogbmFtZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydjb25zdHJ1Y3RvcicsICduYW1lJ11cbiAgICAgICAgfSxcblxuICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICBtZXRob2Qoc2NoZW1hKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoc2NoZW1hID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHNjaGVtYSA9PT0gJ29iamVjdCcsICdPYmplY3Qgc2NoZW1hIG11c3QgYmUgYSB2YWxpZCBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQoIUNvbW1vbi5pc1NjaGVtYShzY2hlbWEpLCAnT2JqZWN0IHNjaGVtYSBjYW5ub3QgYmUgYSBqb2kgc2NoZW1hJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgYWxsXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLmtleXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGgpIHsgICAgICAgICAgICAgLy8gQWxsb3cgbm9uZVxuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5rZXlzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5rZXlzID0gb2JqLiRfdGVybXMua2V5cyA/IG9iai4kX3Rlcm1zLmtleXMuZmlsdGVyKChjaGlsZCkgPT4gIXNjaGVtYS5oYXNPd25Qcm9wZXJ0eShjaGlsZC5rZXkpKSA6IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbi50cnlXaXRoUGF0aCgoKSA9PiBvYmouJF90ZXJtcy5rZXlzLnB1c2goeyBrZXksIHNjaGVtYTogdGhpcy4kX2NvbXBpbGUoc2NoZW1hW2tleV0pIH0pLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai4kX211dGF0ZVJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc9JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBsaW1pdCB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChDb21tb24uY29tcGFyZShPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignb2JqZWN0LicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuXG4gICAgICAgIG1heDoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWF4JywgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCB9LCBvcGVyYXRvcjogJzw9JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21pbicsIG1ldGhvZDogJ2xlbmd0aCcsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmFuZDoge1xuICAgICAgICAgICAgbWV0aG9kKC4uLnBlZXJzIC8qLCBbb3B0aW9uc10gKi8pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi52ZXJpZnlGbGF0KHBlZXJzLCAnbmFuZCcpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICduYW5kJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9yOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLnZlcmlmeUZsYXQocGVlcnMsICdvcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICdvcicsIG51bGwsIHBlZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBveG9yOiB7XG4gICAgICAgICAgICBtZXRob2QoLi4ucGVlcnMgLyosIFtvcHRpb25zXSAqLykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICdveG9yJywgbnVsbCwgcGVlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBhdHRlcm46IHtcbiAgICAgICAgICAgIG1ldGhvZChwYXR0ZXJuLCBzY2hlbWEsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWdFeHAgPSBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgICAgICAgICAgICAgIGlmICghaXNSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMuJF9jb21waWxlKHBhdHRlcm4sIHsgYXBwZW5kUGF0aDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoc2NoZW1hICE9PSB1bmRlZmluZWQsICdJbnZhbGlkIHJ1bGUnKTtcbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2ZhbGx0aHJvdWdoJywgJ21hdGNoZXMnXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNSZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KCFwYXR0ZXJuLmZsYWdzLmluY2x1ZGVzKCdnJykgJiYgIXBhdHRlcm4uZmxhZ3MuaW5jbHVkZXMoJ3knKSwgJ3BhdHRlcm4gc2hvdWxkIG5vdCB1c2UgZ2xvYmFsIG9yIHN0aWNreSBtb2RlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdGhpcy4kX2NvbXBpbGUoc2NoZW1hLCB7IGFwcGVuZFBhdGg6IHRydWUgfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucGF0dGVybnMgPSBvYmouJF90ZXJtcy5wYXR0ZXJucyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWcgPSB7IFtpc1JlZ0V4cCA/ICdyZWdleCcgOiAnc2NoZW1hJ106IHBhdHRlcm4sIHJ1bGU6IHNjaGVtYSB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLm1hdGNoZXMgPSB0aGlzLiRfY29tcGlsZShvcHRpb25zLm1hdGNoZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLm1hdGNoZXMudHlwZSAhPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLm1hdGNoZXMgPSBjb25maWcubWF0Y2hlcy4kX3Jvb3QuYXJyYXkoKS5pdGVtcyhjb25maWcubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcihjb25maWcubWF0Y2hlcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmFsbHRocm91Z2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmZhbGx0aHJvdWdoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYmouJF90ZXJtcy5wYXR0ZXJucy5wdXNoKGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgb2JqLiRfbXV0YXRlUmVnaXN0ZXIoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdyZWYnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKFJlZi5pc1JlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3QucmVmVHlwZScsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVuYW1lOiB7XG4gICAgICAgICAgICBtZXRob2QoZnJvbSwgdG8sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyB8fCBmcm9tIGluc3RhbmNlb2YgUmVnRXhwLCAnUmVuYW1lIG1pc3NpbmcgdGhlIGZyb20gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fCB0byBpbnN0YW5jZW9mIFRlbXBsYXRlLCAnSW52YWxpZCByZW5hbWUgdG8gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodG8gIT09IGZyb20sICdDYW5ub3QgcmVuYW1lIGtleSB0byBzYW1lIG5hbWU6JywgZnJvbSk7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2FsaWFzJywgJ2lnbm9yZVVuZGVmaW5lZCcsICdvdmVycmlkZScsICdtdWx0aXBsZSddKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLnJlbmFtZXMgPSBvYmouJF90ZXJtcy5yZW5hbWVzIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIG9iai4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHJlbmFtZS5mcm9tICE9PSBmcm9tLCAnQ2Fubm90IHJlbmFtZSB0aGUgc2FtZSBrZXkgbXVsdGlwbGUgdGltZXMnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodG8gaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJF9tdXRhdGVSZWdpc3Rlcih0byk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVuYW1lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFwcGx5VG9EZWZhdWx0cyhpbnRlcm5hbHMucmVuYW1lRGVmYXVsdHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgbWV0aG9kKHR5cGUgPSAnYW55Jykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3NjaGVtYScsIGFyZ3M6IHsgdHlwZSB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHR5cGUgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5pc1NjaGVtYSh2YWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT09ICdhbnknIHx8IHZhbHVlLnR5cGUgPT09IHR5cGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdvYmplY3Quc2NoZW1hJywgeyB0eXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVua25vd246IHtcbiAgICAgICAgICAgIG1ldGhvZChhbGxvdykge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd1bmtub3duJywgYWxsb3cgIT09IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRoOiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGgnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aXRob3V0OiB7XG4gICAgICAgICAgICBtZXRob2Qoa2V5LCBwZWVycywgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmRlcGVuZGVuY3kodGhpcywgJ3dpdGhvdXQnLCBrZXksIHBlZXJzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB4b3I6IHtcbiAgICAgICAgICAgIG1ldGhvZCguLi5wZWVycyAvKiwgW29wdGlvbnNdICovKSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24udmVyaWZ5RmxhdChwZWVycywgJ3hvcicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5kZXBlbmRlbmN5KHRoaXMsICd4b3InLCBudWxsLCBwZWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb3ZlcnJpZGVzOiB7XG5cbiAgICAgICAgZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucykge1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gQ29tbW9uLnN5bWJvbHMuZGVlcERlZmF1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc3VwZXIuZGVmYXVsdCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVidWlsZChzY2hlbWEpIHtcblxuICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMua2V5cykge1xuICAgICAgICAgICAgY29uc3QgdG9wbyA9IG5ldyBUb3BvKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHNjaGVtYS4kX3Rlcm1zLmtleXMpIHtcbiAgICAgICAgICAgICAgICBDb21tb24udHJ5V2l0aFBhdGgoKCkgPT4gdG9wby5hZGQoY2hpbGQsIHsgYWZ0ZXI6IGNoaWxkLnNjaGVtYS4kX3Jvb3RSZWZlcmVuY2VzKCksIGdyb3VwOiBjaGlsZC5rZXkgfSksIGNoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNjaGVtYS4kX3Rlcm1zLmtleXMgPSBuZXcgaW50ZXJuYWxzLktleXMoLi4udG9wby5ub2Rlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgaWYgKGRlc2Mua2V5cykge1xuICAgICAgICAgICAgICAgIG9iaiA9IG9iai5rZXlzKGRlc2Mua2V5cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLmRlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyByZWwsIGtleSA9IG51bGwsIHBlZXJzLCBvcHRpb25zIH0gb2YgZGVzYy5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gaW50ZXJuYWxzLmRlcGVuZGVuY3kob2JqLCByZWwsIGtleSwgcGVlcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRlc2MucGF0dGVybnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcmVnZXgsIHNjaGVtYSwgcnVsZSwgZmFsbHRocm91Z2gsIG1hdGNoZXMgfSBvZiBkZXNjLnBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9iai5wYXR0ZXJuKHJlZ2V4IHx8IHNjaGVtYSwgcnVsZSwgeyBmYWxsdGhyb3VnaCwgbWF0Y2hlcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZXNjLnJlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgZnJvbSwgdG8sIG9wdGlvbnMgfSBvZiBkZXNjLnJlbmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqLnJlbmFtZShmcm9tLCB0bywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdvYmplY3QuYW5kJzogJ1wie3sjbGFiZWx9fVwiIGNvbnRhaW5zIHt7I3ByZXNlbnRXaXRoTGFiZWxzfX0gd2l0aG91dCBpdHMgcmVxdWlyZWQgcGVlcnMge3sjbWlzc2luZ1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QuYXNzZXJ0JzogJ1wie3sjbGFiZWx9fVwiIGlzIGludmFsaWQgYmVjYXVzZSB7aWYoI3N1YmplY3Qua2V5LCBgXCJgICsgI3N1YmplY3Qua2V5ICsgYFwiIGZhaWxlZCB0byBgICsgKCNtZXNzYWdlIHx8IFwicGFzcyB0aGUgYXNzZXJ0aW9uIHRlc3RcIiksICNtZXNzYWdlIHx8IFwidGhlIGFzc2VydGlvbiBmYWlsZWRcIil9JyxcbiAgICAgICAgJ29iamVjdC5iYXNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgb2YgdHlwZSB7eyN0eXBlfX0nLFxuICAgICAgICAnb2JqZWN0Lmluc3RhbmNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgXCJ7eyN0eXBlfX1cIicsXG4gICAgICAgICdvYmplY3QubGVuZ3RoJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgaGF2ZSB7eyNsaW1pdH19IGtleXtpZigjbGltaXQgPT0gMSwgXCJcIiwgXCJzXCIpfScsXG4gICAgICAgICdvYmplY3QubWF4JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgaGF2ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8ge3sjbGltaXR9fSBrZXl7aWYoI2xpbWl0ID09IDEsIFwiXCIsIFwic1wiKX0nLFxuICAgICAgICAnb2JqZWN0Lm1pbic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGhhdmUgYXQgbGVhc3Qge3sjbGltaXR9fSBrZXl7aWYoI2xpbWl0ID09IDEsIFwiXCIsIFwic1wiKX0nLFxuICAgICAgICAnb2JqZWN0Lm1pc3NpbmcnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSBvZiB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QubmFuZCc6ICdcInt7I21haW5XaXRoTGFiZWx9fVwiIG11c3Qgbm90IGV4aXN0IHNpbXVsdGFuZW91c2x5IHdpdGgge3sjcGVlcnNXaXRoTGFiZWxzfX0nLFxuICAgICAgICAnb2JqZWN0Lm94b3InOiAnXCJ7eyNsYWJlbH19XCIgY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIG9wdGlvbmFsIGV4Y2x1c2l2ZSBwZWVycyB7eyNwZWVyc1dpdGhMYWJlbHN9fScsXG4gICAgICAgICdvYmplY3QucGF0dGVybi5tYXRjaCc6ICdcInt7I2xhYmVsfX1cIiBrZXlzIGZhaWxlZCB0byBtYXRjaCBwYXR0ZXJuIHJlcXVpcmVtZW50cycsXG4gICAgICAgICdvYmplY3QucmVmVHlwZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgSm9pIHJlZmVyZW5jZScsXG4gICAgICAgICdvYmplY3QucmVuYW1lLm11bHRpcGxlJzogJ1wie3sjbGFiZWx9fVwiIGNhbm5vdCByZW5hbWUgXCJ7eyNmcm9tfX1cIiBiZWNhdXNlIG11bHRpcGxlIHJlbmFtZXMgYXJlIGRpc2FibGVkIGFuZCBhbm90aGVyIGtleSB3YXMgYWxyZWFkeSByZW5hbWVkIHRvIFwie3sjdG99fVwiJyxcbiAgICAgICAgJ29iamVjdC5yZW5hbWUub3ZlcnJpZGUnOiAnXCJ7eyNsYWJlbH19XCIgY2Fubm90IHJlbmFtZSBcInt7I2Zyb219fVwiIGJlY2F1c2Ugb3ZlcnJpZGUgaXMgZGlzYWJsZWQgYW5kIHRhcmdldCBcInt7I3RvfX1cIiBleGlzdHMnLFxuICAgICAgICAnb2JqZWN0LnNjaGVtYSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgSm9pIHNjaGVtYSBvZiB7eyN0eXBlfX0gdHlwZScsXG4gICAgICAgICdvYmplY3QudW5rbm93bic6ICdcInt7I2xhYmVsfX1cIiBpcyBub3QgYWxsb3dlZCcsXG4gICAgICAgICdvYmplY3Qud2l0aCc6ICdcInt7I21haW5XaXRoTGFiZWx9fVwiIG1pc3NpbmcgcmVxdWlyZWQgcGVlciBcInt7I3BlZXJXaXRoTGFiZWx9fVwiJyxcbiAgICAgICAgJ29iamVjdC53aXRob3V0JzogJ1wie3sjbWFpbldpdGhMYWJlbH19XCIgY29uZmxpY3Qgd2l0aCBmb3JiaWRkZW4gcGVlciBcInt7I3BlZXJXaXRoTGFiZWx9fVwiJyxcbiAgICAgICAgJ29iamVjdC54b3InOiAnXCJ7eyNsYWJlbH19XCIgY29udGFpbnMgYSBjb25mbGljdCBiZXR3ZWVuIGV4Y2x1c2l2ZSBwZWVycyB7eyNwZWVyc1dpdGhMYWJlbHN9fSdcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5jbG9uZSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJlZnMpIHtcblxuICAgIC8vIE9iamVjdFxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHByZWZzLm5vbkVudW1lcmFibGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xvbmUodmFsdWUsIHsgc2hhbGxvdzogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihjbG9uZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25cblxuICAgIGNvbnN0IGNsb25lID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIGNsb25lLnByb3RvdHlwZSA9IENsb25lKHZhbHVlLnByb3RvdHlwZSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCAnbmFtZScsIHsgdmFsdWU6IHZhbHVlLm5hbWUsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xvbmUsICdsZW5ndGgnLCB7IHZhbHVlOiB2YWx1ZS5sZW5ndGgsIHdyaXRhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuYXNzaWduKGNsb25lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIGNsb25lO1xufTtcblxuXG5pbnRlcm5hbHMuZGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChzY2hlbWEsIHJlbCwga2V5LCBwZWVycywgb3B0aW9ucykge1xuXG4gICAgQXNzZXJ0KGtleSA9PT0gbnVsbCB8fCB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJywgcmVsLCAna2V5IG11c3QgYmUgYSBzdHJpbmdzJyk7XG5cbiAgICAvLyBFeHRyYWN0IG9wdGlvbnMgZnJvbSBwZWVycyBhcnJheVxuXG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwZWVycy5sZW5ndGggPiAxICYmIHR5cGVvZiBwZWVyc1twZWVycy5sZW5ndGggLSAxXSA9PT0gJ29iamVjdCcgPyBwZWVycy5wb3AoKSA6IHt9O1xuICAgIH1cblxuICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnc2VwYXJhdG9yJ10pO1xuXG4gICAgcGVlcnMgPSBbXS5jb25jYXQocGVlcnMpO1xuXG4gICAgLy8gQ2FzdCBwZWVyIHBhdGhzXG5cbiAgICBjb25zdCBzZXBhcmF0b3IgPSBDb21tb24uZGVmYXVsdChvcHRpb25zLnNlcGFyYXRvciwgJy4nKTtcbiAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGVlciBvZiBwZWVycykge1xuICAgICAgICBBc3NlcnQodHlwZW9mIHBlZXIgPT09ICdzdHJpbmcnLCByZWwsICdwZWVycyBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgcmVmZXJlbmNlJyk7XG4gICAgICAgIHBhdGhzLnB1c2goQ29tcGlsZS5yZWYocGVlciwgeyBzZXBhcmF0b3IsIGFuY2VzdG9yOiAwIH0pKTtcbiAgICB9XG5cbiAgICAvLyBDYXN0IGtleVxuXG4gICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICBrZXkgPSBDb21waWxlLnJlZihrZXksIHsgc2VwYXJhdG9yLCBhbmNlc3RvcjogMCB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcnVsZVxuXG4gICAgY29uc3Qgb2JqID0gc2NoZW1hLmNsb25lKCk7XG4gICAgb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzID0gb2JqLiRfdGVybXMuZGVwZW5kZW5jaWVzIHx8IFtdO1xuICAgIG9iai4kX3Rlcm1zLmRlcGVuZGVuY2llcy5wdXNoKG5ldyBpbnRlcm5hbHMuRGVwZW5kZW5jeShyZWwsIGtleSwgcGF0aHMsIHBlZXJzKSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cblxuaW50ZXJuYWxzLmRlcGVuZGVuY2llcyA9IHtcblxuICAgIGFuZChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGRlcC5wZWVycy5sZW5ndGg7XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCAhPT0gY291bnQgJiZcbiAgICAgICAgICAgIHByZXNlbnQubGVuZ3RoICE9PSBjb3VudCkge1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvZGU6ICdvYmplY3QuYW5kJyxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnRXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCksXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcsXG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmdXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgbWlzc2luZylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5hbmQoc2NoZW1hLCBkZXAsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgICAgICBjb25zdCBwcmVzZW50ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcmVzZW50LnB1c2gocGVlci5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbnQubGVuZ3RoICE9PSBkZXAucGVlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYWluID0gZGVwLnBhdGhzWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZXAucGF0aHMuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlOiAnb2JqZWN0Lm5hbmQnLFxuICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1haW4sXG4gICAgICAgICAgICAgICAgbWFpbldpdGhMYWJlbDogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIG1haW4pLFxuICAgICAgICAgICAgICAgIHBlZXJzOiB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgdmFsdWVzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogJ29iamVjdC5taXNzaW5nJyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICBwZWVyczogZGVwLnBhdGhzLFxuICAgICAgICAgICAgICAgIHBlZXJzV2l0aExhYmVsczogaW50ZXJuYWxzLmtleXNUb0xhYmVscyhzY2hlbWEsIGRlcC5wYXRocylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgb3hvcihzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGNvbnN0IHByZXNlbnQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwZWVyIG9mIGRlcC5wZWVycykge1xuICAgICAgICAgICAgaWYgKHBlZXIucmVzb2x2ZSh2YWx1ZSwgc3RhdGUsIHByZWZzLCBudWxsLCB7IHNoYWRvdzogZmFsc2UgfSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByZXNlbnQucHVzaChwZWVyLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXNlbnQubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBwZWVyczogZGVwLnBhdGhzLCBwZWVyc1dpdGhMYWJlbHM6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAucGF0aHMpIH07XG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3Qub3hvcicsIGNvbnRleHQgfTtcbiAgICB9LFxuXG4gICAgd2l0aChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGgnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd2l0aG91dChzY2hlbWEsIGRlcCwgdmFsdWUsIHN0YXRlLCBwcmVmcykge1xuXG4gICAgICAgIGZvciAoY29uc3QgcGVlciBvZiBkZXAucGVlcnMpIHtcbiAgICAgICAgICAgIGlmIChwZWVyLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBzaGFkb3c6IGZhbHNlIH0pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAnb2JqZWN0LndpdGhvdXQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluOiBkZXAua2V5LmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5XaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBkZXAua2V5LmtleSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwZWVyOiBwZWVyLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZXJXaXRoTGFiZWw6IGludGVybmFscy5rZXlzVG9MYWJlbHMoc2NoZW1hLCBwZWVyLmtleSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgeG9yKHNjaGVtYSwgZGVwLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgY29uc3QgcHJlc2VudCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBlZXIgb2YgZGVwLnBlZXJzKSB7XG4gICAgICAgICAgICBpZiAocGVlci5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIG51bGwsIHsgc2hhZG93OiBmYWxzZSB9KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJlc2VudC5wdXNoKHBlZXIua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVzZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcGVlcnM6IGRlcC5wYXRocywgcGVlcnNXaXRoTGFiZWxzOiBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgZGVwLnBhdGhzKSB9O1xuICAgICAgICBpZiAocHJlc2VudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QubWlzc2luZycsIGNvbnRleHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQucHJlc2VudCA9IHByZXNlbnQ7XG4gICAgICAgIGNvbnRleHQucHJlc2VudFdpdGhMYWJlbHMgPSBpbnRlcm5hbHMua2V5c1RvTGFiZWxzKHNjaGVtYSwgcHJlc2VudCk7XG4gICAgICAgIHJldHVybiB7IGNvZGU6ICdvYmplY3QueG9yJywgY29udGV4dCB9O1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLmtleXNUb0xhYmVscyA9IGZ1bmN0aW9uIChzY2hlbWEsIGtleXMpIHtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIHJldHVybiBrZXlzLm1hcCgoa2V5KSA9PiBzY2hlbWEuJF9tYXBMYWJlbHMoa2V5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjaGVtYS4kX21hcExhYmVscyhrZXlzKTtcbn07XG5cblxuaW50ZXJuYWxzLnJlbmFtZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGVycm9ycykge1xuXG4gICAgY29uc3QgcmVuYW1lZCA9IHt9O1xuICAgIGZvciAoY29uc3QgcmVuYW1lIG9mIHNjaGVtYS4kX3Rlcm1zLnJlbmFtZXMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdHlwZW9mIHJlbmFtZS5mcm9tICE9PSAnc3RyaW5nJztcblxuICAgICAgICBpZiAoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHJlbmFtZS5mcm9tKSAmJlxuICAgICAgICAgICAgICAgICh2YWx1ZVtyZW5hbWUuZnJvbV0gIT09IHVuZGVmaW5lZCB8fCAhcmVuYW1lLm9wdGlvbnMuaWdub3JlVW5kZWZpbmVkKSkge1xuXG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKHJlbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZyb20gaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbZnJvbV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICByZW5hbWUub3B0aW9ucy5pZ25vcmVVbmRlZmluZWQpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gcmVuYW1lLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVuYW1lLmZyb20uZXhlYyhmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7IGZyb20sIHRvOiByZW5hbWUudG8sIG1hdGNoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gbWF0Y2guZnJvbTtcbiAgICAgICAgICAgIGxldCB0byA9IG1hdGNoLnRvO1xuICAgICAgICAgICAgaWYgKHRvIGluc3RhbmNlb2YgVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB0byA9IHRvLnJlbmRlcih2YWx1ZSwgc3RhdGUsIHByZWZzLCBtYXRjaC5tYXRjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXJlbmFtZS5vcHRpb25zLm11bHRpcGxlICYmXG4gICAgICAgICAgICAgICAgcmVuYW1lZFt0b10pIHtcblxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QucmVuYW1lLm11bHRpcGxlJywgdmFsdWUsIHsgZnJvbSwgdG8sIHBhdHRlcm4gfSwgc3RhdGUsIHByZWZzKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgdG8pICYmXG4gICAgICAgICAgICAgICAgIXJlbmFtZS5vcHRpb25zLm92ZXJyaWRlICYmXG4gICAgICAgICAgICAgICAgIXJlbmFtZWRbdG9dKSB7XG5cbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChzY2hlbWEuJF9jcmVhdGVFcnJvcignb2JqZWN0LnJlbmFtZS5vdmVycmlkZScsIHZhbHVlLCB7IGZyb20sIHRvLCBwYXR0ZXJuIH0sIHN0YXRlLCBwcmVmcykpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZVtmcm9tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW3RvXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlW3RvXSA9IHZhbHVlW2Zyb21dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5hbWVkW3RvXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghcmVuYW1lLm9wdGlvbnMuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbZnJvbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuaW50ZXJuYWxzLnVua25vd24gPSBmdW5jdGlvbiAoc2NoZW1hLCB2YWx1ZSwgdW5wcm9jZXNzZWQsIGVycm9ycywgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoc2NoZW1hLiRfdGVybXMucGF0dGVybnMpIHtcbiAgICAgICAgbGV0IGhhc01hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zLm1hcCgocGF0dGVybikgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGF0dGVybi5tYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBbdmFsdWUsIC4uLnN0YXRlLmFuY2VzdG9yc107XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5wcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IFsuLi5zdGF0ZS5wYXRoLCBrZXldO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcGF0dGVybi5yZWdleC50ZXN0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5kZWJ1ZyhzdGF0ZSwgJ3J1bGUnLCBgcGF0dGVybi4ke2l9YCwgbWF0Y2ggPyAncGFzcycgOiAnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0dGVybi5zY2hlbWEuJF9tYXRjaChrZXksIHN0YXRlLm5lc3QocGF0dGVybi5zY2hlbWEsIGBwYXR0ZXJuLiR7aX1gKSwgcHJlZnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHBhdGgsIGFuY2VzdG9ycywgeyBzY2hlbWE6IHBhdHRlcm4ucnVsZSwga2V5IH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhdHRlcm4ucnVsZS4kX3ZhbGlkYXRlKGl0ZW0sIGxvY2FsU3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogcmVzdWx0LmVycm9ycyB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4ubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW2ldLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghcGF0dGVybi5mYWxsdGhyb3VnaCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBwYXR0ZXJuIG1hdGNoZXMgcnVsZXNcblxuICAgICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RwbSA9IHNjaGVtYS4kX3Rlcm1zLnBhdHRlcm5zW2ldLm1hdGNoZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKHN0YXRlLnBhdGgsIGFuY2VzdG9ycywgc3RwbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RwbS4kX3ZhbGlkYXRlKG1hdGNoLCBsb2NhbFN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IEVycm9ycy5kZXRhaWxzKHJlc3VsdC5lcnJvcnMsIHsgb3ZlcnJpZGU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ29iamVjdC5wYXR0ZXJuLm1hdGNoJywgdmFsdWUsIGRldGFpbHMsIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1bnByb2Nlc3NlZC5zaXplIHx8XG4gICAgICAgICFzY2hlbWEuJF90ZXJtcy5rZXlzICYmICFzY2hlbWEuJF90ZXJtcy5wYXR0ZXJucykgeyAgICAgLy8gSWYgbm8ga2V5cyBvciBwYXR0ZXJucyBzcGVjaWZpZWQsIHVua25vd24ga2V5cyBhbGxvd2VkXG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5zdHJpcFVua25vd24gJiYgIXNjaGVtYS5fZmxhZ3MudW5rbm93biB8fFxuICAgICAgICBwcmVmcy5za2lwRnVuY3Rpb25zKSB7XG5cbiAgICAgICAgY29uc3Qgc3RyaXBVbmtub3duID0gcHJlZnMuc3RyaXBVbmtub3duID8gKHByZWZzLnN0cmlwVW5rbm93biA9PT0gdHJ1ZSA/IHRydWUgOiAhIXByZWZzLnN0cmlwVW5rbm93bi5vYmplY3RzKSA6IGZhbHNlO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBpZiAoc3RyaXBVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgdW5wcm9jZXNzZWQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHVucHJvY2Vzc2VkLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9yYmlkVW5rbm93biA9ICFDb21tb24uZGVmYXVsdChzY2hlbWEuX2ZsYWdzLnVua25vd24sIHByZWZzLmFsbG93VW5rbm93bik7XG4gICAgaWYgKGZvcmJpZFVua25vd24pIHtcbiAgICAgICAgZm9yIChjb25zdCB1bnByb2Nlc3NlZEtleSBvZiB1bnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IHN0YXRlLmxvY2FsaXplKFsuLi5zdGF0ZS5wYXRoLCB1bnByb2Nlc3NlZEtleV0sIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdvYmplY3QudW5rbm93bicsIHZhbHVlW3VucHJvY2Vzc2VkS2V5XSwgeyBjaGlsZDogdW5wcm9jZXNzZWRLZXkgfSwgbG9jYWxTdGF0ZSwgcHJlZnMsIHsgZmxhZ3M6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKHByZWZzLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiByZXBvcnQgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkRlcGVuZGVuY3kgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWwsIGtleSwgcGVlcnMsIHBhdGhzKSB7XG5cbiAgICAgICAgdGhpcy5yZWwgPSByZWw7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnBlZXJzID0gcGVlcnM7XG4gICAgICAgIHRoaXMucGF0aHMgPSBwYXRocztcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBkZXNjID0ge1xuICAgICAgICAgICAgcmVsOiB0aGlzLnJlbCxcbiAgICAgICAgICAgIHBlZXJzOiB0aGlzLnBhdGhzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMua2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkZXNjLmtleSA9IHRoaXMua2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBlZXJzWzBdLnNlcGFyYXRvciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBkZXNjLm9wdGlvbnMgPSB7IHNlcGFyYXRvcjogdGhpcy5wZWVyc1swXS5zZXBhcmF0b3IgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLktleXMgPSBjbGFzcyBleHRlbmRzIEFycmF5IHtcblxuICAgIGNvbmNhdChzb3VyY2UpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNsaWNlKCk7XG5cbiAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGtleXMuc2V0KHJlc3VsdFtpXS5rZXksIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaXRlbS5rZXk7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBrZXlzLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSB7IGtleSwgc2NoZW1hOiByZXN1bHRbcG9zXS5zY2hlbWEuY29uY2F0KGl0ZW0uc2NoZW1hKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuXG5jb25zdCBBbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG5jb25zdCBDb21waWxlID0gcmVxdWlyZSgnLi4vY29tcGlsZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdsaW5rJyxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgc2NoZW1hQ2hhaW46IHRydWVcbiAgICB9LFxuXG4gICAgdGVybXM6IHtcblxuICAgICAgICBsaW5rOiB7IGluaXQ6IG51bGwsIG1hbmlmZXN0OiAnc2luZ2xlJywgcmVnaXN0ZXI6IGZhbHNlIH1cbiAgICB9LFxuXG4gICAgYXJncyhzY2hlbWEsIHJlZikge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEucmVmKHJlZik7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0pIHtcblxuICAgICAgICBBc3NlcnQoc2NoZW1hLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcblxuICAgICAgICBjb25zdCBsaW5rZWQgPSBpbnRlcm5hbHMuZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgY29uc3QgcmVmID0gc2NoZW1hLiRfdGVybXMubGlua1swXS5yZWY7XG4gICAgICAgIHJldHVybiBsaW5rZWQuJF92YWxpZGF0ZSh2YWx1ZSwgc3RhdGUubmVzdChsaW5rZWQsIGBsaW5rOiR7cmVmLmRpc3BsYXl9OiR7bGlua2VkLnR5cGV9YCksIHByZWZzKTtcbiAgICB9LFxuXG4gICAgZ2VuZXJhdGUoc2NoZW1hLCB2YWx1ZSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5nZW5lcmF0ZShzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH0sXG5cbiAgICBydWxlczoge1xuXG4gICAgICAgIHJlZjoge1xuICAgICAgICAgICAgbWV0aG9kKHJlZikge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KCF0aGlzLiRfdGVybXMubGluaywgJ0Nhbm5vdCByZWluaXRpYWxpemUgc2NoZW1hJyk7XG5cbiAgICAgICAgICAgICAgICByZWYgPSBDb21waWxlLnJlZihyZWYpO1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAndmFsdWUnIHx8IHJlZi50eXBlID09PSAnbG9jYWwnLCAnSW52YWxpZCByZWZlcmVuY2UgdHlwZTonLCByZWYudHlwZSk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHJlZi50eXBlID09PSAnbG9jYWwnIHx8IHJlZi5hbmNlc3RvciA9PT0gJ3Jvb3QnIHx8IHJlZi5hbmNlc3RvciA+IDAsICdMaW5rIGNhbm5vdCByZWZlcmVuY2UgaXRzZWxmJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMubGluayA9IFt7IHJlZiB9XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlbGF0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygncmVsYXRpdmUnLCBlbmFibGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvdmVycmlkZXM6IHtcblxuICAgICAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgICAgIEFzc2VydCh0aGlzLiRfdGVybXMubGluaywgJ1VuaW5pdGlhbGl6ZWQgbGluayBzY2hlbWEnKTtcbiAgICAgICAgICAgIEFzc2VydChDb21tb24uaXNTY2hlbWEoc291cmNlKSwgJ0ludmFsaWQgc2NoZW1hIG9iamVjdCcpO1xuICAgICAgICAgICAgQXNzZXJ0KHNvdXJjZS50eXBlICE9PSAnbGluaycsICdDYW5ub3QgbWVyZ2UgdHlwZSBsaW5rIHdpdGggYW5vdGhlciBsaW5rJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtcy53aGVucykge1xuICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9iai4kX3Rlcm1zLndoZW5zLnB1c2goeyBjb25jYXQ6IHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYmouJF9tdXRhdGVSZWJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbWFuaWZlc3Q6IHtcblxuICAgICAgICBidWlsZChvYmosIGRlc2MpIHtcblxuICAgICAgICAgICAgQXNzZXJ0KGRlc2MubGluaywgJ0ludmFsaWQgbGluayBkZXNjcmlwdGlvbiBtaXNzaW5nIGxpbmsnKTtcbiAgICAgICAgICAgIHJldHVybiBvYmoucmVmKGRlc2MubGluayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChzY2hlbWEsIHZhbHVlLCBzdGF0ZSwgcHJlZnMpIHtcblxuICAgIGxldCBsaW5rZWQgPSBzdGF0ZS5tYWluc3RheS5saW5rcy5nZXQoc2NoZW1hKTtcbiAgICBpZiAobGlua2VkKSB7XG4gICAgICAgIHJldHVybiBsaW5rZWQuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCByZWYgPSBzY2hlbWEuJF90ZXJtcy5saW5rWzBdLnJlZjtcbiAgICBjb25zdCB7IHBlcnNwZWN0aXZlLCBwYXRoIH0gPSBpbnRlcm5hbHMucGVyc3BlY3RpdmUocmVmLCBzdGF0ZSk7XG4gICAgaW50ZXJuYWxzLmFzc2VydChwZXJzcGVjdGl2ZSwgJ3doaWNoIGlzIG91dHNpZGUgb2Ygc2NoZW1hIGJvdW5kYXJpZXMnLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGxpbmtlZCA9IHBhdGgubGVuZ3RoID8gcGVyc3BlY3RpdmUuJF9yZWFjaChwYXRoKSA6IHBlcnNwZWN0aXZlO1xuICAgIH1cbiAgICBjYXRjaCAoaWdub3JlRXJyKSB7XG4gICAgICAgIGludGVybmFscy5hc3NlcnQoZmFsc2UsICd0byBub24tZXhpc3Rpbmcgc2NoZW1hJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWxzLmFzc2VydChsaW5rZWQudHlwZSAhPT0gJ2xpbmsnLCAnd2hpY2ggaXMgYW5vdGhlciBsaW5rJywgcmVmLCBzY2hlbWEsIHN0YXRlLCBwcmVmcyk7XG5cbiAgICBpZiAoIXNjaGVtYS5fZmxhZ3MucmVsYXRpdmUpIHtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkubGlua3Muc2V0KHNjaGVtYSwgbGlua2VkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlua2VkLl9nZW5lcmF0ZSh2YWx1ZSwgc3RhdGUsIHByZWZzKS5zY2hlbWE7XG59O1xuXG5cbmludGVybmFscy5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChyZWYsIHN0YXRlKSB7XG5cbiAgICBpZiAocmVmLnR5cGUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgZm9yIChjb25zdCB7IHNjaGVtYSwga2V5IH0gb2Ygc3RhdGUuc2NoZW1hcykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyb20gcGFyZW50IHRvIHJvb3RcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NoZW1hLl9mbGFncy5pZCB8fCBrZXk7XG4gICAgICAgICAgICBpZiAoaWQgPT09IHJlZi5wYXRoWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGVyc3BlY3RpdmU6IHNjaGVtYSwgcGF0aDogcmVmLnBhdGguc2xpY2UoMSkgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2hhcmVkIG9mIHNjaGVtYS4kX3Rlcm1zLnNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcmVkLl9mbGFncy5pZCA9PT0gcmVmLnBhdGhbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBlcnNwZWN0aXZlOiBzaGFyZWQsIHBhdGg6IHJlZi5wYXRoLnNsaWNlKDEpIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogbnVsbCwgcGF0aDogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChyZWYuYW5jZXN0b3IgPT09ICdyb290Jykge1xuICAgICAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tzdGF0ZS5zY2hlbWFzLmxlbmd0aCAtIDFdLnNjaGVtYSwgcGF0aDogcmVmLnBhdGggfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBwZXJzcGVjdGl2ZTogc3RhdGUuc2NoZW1hc1tyZWYuYW5jZXN0b3JdICYmIHN0YXRlLnNjaGVtYXNbcmVmLmFuY2VzdG9yXS5zY2hlbWEsIHBhdGg6IHJlZi5wYXRoIH07XG59O1xuXG5cbmludGVybmFscy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBtZXNzYWdlLCByZWYsIHNjaGVtYSwgc3RhdGUsIHByZWZzKSB7XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7ICAgICAgICAgICAgICAgIC8vIE1hbnVhbCBjaGVjayB0byBhdm9pZCBnZW5lcmF0aW5nIGVycm9yIG1lc3NhZ2Ugb24gc3VjY2Vzc1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQXNzZXJ0KGZhbHNlLCBgXCIke0Vycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpfVwiIGNvbnRhaW5zIGxpbmsgcmVmZXJlbmNlIFwiJHtyZWYuZGlzcGxheX1cIiAke21lc3NhZ2V9YCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcblxuY29uc3QgQW55ID0gcmVxdWlyZSgnLi9hbnknKTtcbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICBudW1iZXJSeDogL15cXHMqWystXT8oPzooPzpcXGQrKD86XFwuXFxkKik/KXwoPzpcXC5cXGQrKSkoPzplKFsrLV0/XFxkKykpP1xccyokL2ksXG4gICAgcHJlY2lzaW9uUng6IC8oPzpcXC4oXFxkKykpPyg/OltlRV0oWystXT9cXGQrKSk/JC9cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdudW1iZXInLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICB1bnNhZmU6IHsgZGVmYXVsdDogZmFsc2UgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yIH0pIHtcblxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKGludGVybmFscy5udW1iZXJSeCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogcGFyc2VGbG9hdCh2YWx1ZSkgfTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IDA7ICAgICAgICAgICAvLyAtMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3MudW5zYWZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9lL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdGVkID0gaW50ZXJuYWxzLm5vcm1hbGl6ZUV4cG9uZW50KGAke3Jlc3VsdC52YWx1ZSAvIE1hdGgucG93KDEwLCBtYXRjaGVzWzFdKX1lJHttYXRjaGVzWzFdfWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RydWN0ZWQgIT09IGludGVybmFscy5ub3JtYWxpemVFeHBvbmVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nID0gcmVzdWx0LnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2goL2UvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5nICE9PSBpbnRlcm5hbHMubm9ybWFsaXplRGVjaW1hbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMgPSBlcnJvcignbnVtYmVyLnVuc2FmZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBzY2hlbWEsIGVycm9yLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgICAgdmFsdWUgPT09IC1JbmZpbml0eSkge1xuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignbnVtYmVyLmluZmluaXR5JykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghQ29tbW9uLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ251bWJlci5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdmFsdWUgfTtcblxuICAgICAgICBpZiAocmVzdWx0LnZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQudmFsdWUgPSAwOyAgICAgICAgICAgLy8gLTBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcmVmcy5jb252ZXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gc2NoZW1hLiRfZ2V0UnVsZSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IE1hdGgucG93KDEwLCBydWxlLmFyZ3MubGltaXQpOyAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBjb25jZXB0dWFsbHkgZXF1aXZhbGVudCB0byB1c2luZyB0b0ZpeGVkIGJ1dCBpdCBzaG91bGQgYmUgbXVjaCBmYXN0ZXJcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBNYXRoLnJvdW5kKHJlc3VsdC52YWx1ZSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNjaGVtYS5fZmxhZ3MudW5zYWZlICYmXG4gICAgICAgICAgICAodmFsdWUgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCB2YWx1ZSA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSkge1xuXG4gICAgICAgICAgICByZXN1bHQuZXJyb3JzID0gZXJyb3IoJ251bWJlci51bnNhZmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgY29tcGFyZToge1xuICAgICAgICAgICAgbWV0aG9kOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0IH0sIHsgbmFtZSwgb3BlcmF0b3IsIGFyZ3MgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKHZhbHVlLCBsaW1pdCwgb3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLicgKyBuYW1lLCB7IGxpbWl0OiBhcmdzLmxpbWl0LCB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnbGltaXQnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogQ29tbW9uLmlzTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnbXVzdCBiZSBhIG51bWJlcidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG5cbiAgICAgICAgZ3JlYXRlcjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3JlYXRlcicsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW50ZWdlcjoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdpbnRlZ2VyJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnRydW5jKHZhbHVlKSAtIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignbnVtYmVyLmludGVnZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBsZXNzOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdsZXNzJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc8JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ21heCcsIG1ldGhvZDogJ2NvbXBhcmUnLCBhcmdzOiB7IGxpbWl0IH0sIG9wZXJhdG9yOiAnPD0nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1pbjoge1xuICAgICAgICAgICAgbWV0aG9kKGxpbWl0KSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbWluJywgbWV0aG9kOiAnY29tcGFyZScsIGFyZ3M6IHsgbGltaXQgfSwgb3BlcmF0b3I6ICc+PScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbGU6IHtcbiAgICAgICAgICAgIG1ldGhvZChiYXNlKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbXVsdGlwbGUnLCBhcmdzOiB7IGJhc2UgfSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgeyBiYXNlIH0sIG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAlIGJhc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIubXVsdGlwbGUnLCB7IG11bHRpcGxlOiBvcHRpb25zLmFyZ3MuYmFzZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2Jhc2UnLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydDogKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIG5lZ2F0aXZlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduKCduZWdhdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHBvcnQ6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgncG9ydCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPD0gNjU1MzUpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ251bWJlci5wb3J0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpdmU6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ24oJ3Bvc2l0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJlY2lzaW9uOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChOdW1iZXIuaXNTYWZlSW50ZWdlcihsaW1pdCksICdsaW1pdCBtdXN0IGJlIGFuIGludGVnZXInKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdwcmVjaXNpb24nLCBhcmdzOiB7IGxpbWl0IH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgbGltaXQgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2VzID0gdmFsdWUudG9TdHJpbmcoKS5tYXRjaChpbnRlcm5hbHMucHJlY2lzaW9uUngpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY2ltYWxzID0gTWF0aC5tYXgoKHBsYWNlc1sxXSA/IHBsYWNlc1sxXS5sZW5ndGggOiAwKSAtIChwbGFjZXNbMl0gPyBwYXJzZUludChwbGFjZXNbMl0sIDEwKSA6IDApLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbHMgPD0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdudW1iZXIucHJlY2lzaW9uJywgeyBsaW1pdCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIG1ldGhvZChzaWduKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQoWyduZWdhdGl2ZScsICdwb3NpdGl2ZSddLmluY2x1ZGVzKHNpZ24pLCAnSW52YWxpZCBzaWduJywgc2lnbik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnc2lnbicsIGFyZ3M6IHsgc2lnbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHNpZ24gfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpZ24gPT09ICduZWdhdGl2ZScgJiYgdmFsdWUgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIHNpZ24gPT09ICdwb3NpdGl2ZScgJiYgdmFsdWUgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKGBudW1iZXIuJHtzaWdufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc2FmZToge1xuICAgICAgICAgICAgbWV0aG9kKGVuYWJsZWQgPSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJywgJ2VuYWJsZWQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfc2V0RmxhZygndW5zYWZlJywgZW5hYmxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FzdDoge1xuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGZyb206ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgICAgIHRvKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnbnVtYmVyLmJhc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICAgICdudW1iZXIuZ3JlYXRlcic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5pbmZpbml0eSc6ICdcInt7I2xhYmVsfX1cIiBjYW5ub3QgYmUgaW5maW5pdHknLFxuICAgICAgICAnbnVtYmVyLmludGVnZXInOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhbiBpbnRlZ2VyJyxcbiAgICAgICAgJ251bWJlci5sZXNzJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgbGVzcyB0aGFuIHt7I2xpbWl0fX0nLFxuICAgICAgICAnbnVtYmVyLm1heCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5taW4nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBsYXJnZXIgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19JyxcbiAgICAgICAgJ251bWJlci5tdWx0aXBsZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgbXVsdGlwbGUgb2Yge3sjbXVsdGlwbGV9fScsXG4gICAgICAgICdudW1iZXIubmVnYXRpdmUnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gICAgICAgICdudW1iZXIucG9ydCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgdmFsaWQgcG9ydCcsXG4gICAgICAgICdudW1iZXIucG9zaXRpdmUnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gICAgICAgICdudW1iZXIucHJlY2lzaW9uJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgaGF2ZSBubyBtb3JlIHRoYW4ge3sjbGltaXR9fSBkZWNpbWFsIHBsYWNlcycsXG4gICAgICAgICdudW1iZXIudW5zYWZlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBzYWZlIG51bWJlcidcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5ub3JtYWxpemVFeHBvbmVudCA9IGZ1bmN0aW9uIChzdHIpIHtcblxuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnJlcGxhY2UoL0UvLCAnZScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC4oXFxkKlsxLTldKT8wK2UvLCAnLiQxZScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC5lLywgJ2UnKVxuICAgICAgICAucmVwbGFjZSgvZVxcKy8sICdlJylcbiAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL14oLT8pMCsoWzEtOV0pLywgJyQxJDInKTtcbn07XG5cblxuaW50ZXJuYWxzLm5vcm1hbGl6ZURlY2ltYWwgPSBmdW5jdGlvbiAoc3RyKSB7XG5cbiAgICBzdHIgPSBzdHJcbiAgICAgICAgLnJlcGxhY2UoL15cXCsvLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcLjArJC8sICcnKVxuICAgICAgICAucmVwbGFjZSgvXigtPylcXC4oW15cXC5dKikkLywgJyQxMC4kMicpXG4gICAgICAgIC5yZXBsYWNlKC9eKC0/KTArKFsxLTldKS8sICckMSQyJyk7XG5cbiAgICBpZiAoc3RyLmluY2x1ZGVzKCcuJykgJiZcbiAgICAgICAgc3RyLmVuZHNXaXRoKCcwJykpIHtcblxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvMCskLywgJycpO1xuICAgIH1cblxuICAgIGlmIChzdHIgPT09ICctMCcpIHtcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgS2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gS2V5cy5leHRlbmQoe1xuXG4gICAgdHlwZTogJ29iamVjdCcsXG5cbiAgICBjYXN0OiB7XG4gICAgICAgIG1hcDoge1xuICAgICAgICAgICAgZnJvbTogKHZhbHVlKSA9PiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnLFxuICAgICAgICAgICAgdG8odmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5jb25zdCBEb21haW4gPSByZXF1aXJlKCdAaGFwaS9hZGRyZXNzL2xpYi9kb21haW4nKTtcbmNvbnN0IEVtYWlsID0gcmVxdWlyZSgnQGhhcGkvYWRkcmVzcy9saWIvZW1haWwnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXgnKTtcbmNvbnN0IFRsZHMgPSByZXF1aXJlKCdAaGFwaS9hZGRyZXNzL2xpYi90bGRzJyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4uL2FueScpO1xuY29uc3QgQ29tbW9uID0gcmVxdWlyZSgnLi4vLi4vY29tbW9uJyk7XG5cbmNvbnN0IElwID0gcmVxdWlyZSgnLi9pcCcpO1xuY29uc3QgVXJpID0gcmVxdWlyZSgnLi91cmknKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgdGxkczogVGxkcyBpbnN0YW5jZW9mIFNldCA/IHsgdGxkczogeyBhbGxvdzogVGxkcywgZGVueTogbnVsbCB9IH0gOiBmYWxzZSwgICAgICAgICAgICAgIC8vICRsYWI6Y292ZXJhZ2U6aWdub3JlJFxuICAgIGJhc2U2NFJlZ2V4OiB7XG4gICAgICAgIC8vIHBhZGRpbmdSZXF1aXJlZFxuICAgICAgICB0cnVlOiB7XG4gICAgICAgICAgICAvLyB1cmxTYWZlXG4gICAgICAgICAgICB0cnVlOiAvXig/OltcXHdcXC1dezJ9W1xcd1xcLV17Mn0pKig/OltcXHdcXC1dezJ9PT18W1xcd1xcLV17M309KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9PT18W0EtWmEtejAtOStcXC9dezN9PSk/JC9cbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2U6IHtcbiAgICAgICAgICAgIHRydWU6IC9eKD86W1xcd1xcLV17Mn1bXFx3XFwtXXsyfSkqKD86W1xcd1xcLV17Mn0oPT0pP3xbXFx3XFwtXXszfT0/KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9KD09KT98W0EtWmEtejAtOStcXC9dezN9PT8pPyQvXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRhdGFVcmlSZWdleDoge1xuICAgICAgICBmb3JtYXQ6IC9eZGF0YTpbXFx3Ky4tXStcXC9bXFx3Ky4tXSs7KChjaGFyc2V0PVtcXHctXSt8YmFzZTY0KSwpPyguKikkLyxcbiAgICAgICAgYmFzZTY0OiB7XG4gICAgICAgICAgICAvLyBwYWRkaW5nUmVxdWlyZWRcbiAgICAgICAgICAgIHRydWU6IC9eKD86W0EtWmEtejAtOStcXC9dezR9KSooPzpbQS1aYS16MC05K1xcL117Mn09PXxbQS1aYS16MC05K1xcL117M309KT8kLyxcbiAgICAgICAgICAgIGZhbHNlOiAvXig/OltBLVphLXowLTkrXFwvXXs0fSkqKD86W0EtWmEtejAtOStcXC9dezJ9KD09KT98W0EtWmEtejAtOStcXC9dezN9PT8pPyQvXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhleFJlZ2V4OiAvXlthLWYwLTldKyQvaSxcbiAgICBob3N0UmVnZXg6IC9eKChbYS16QS1aMC05XXxbYS16QS1aMC05XVthLXpBLVowLTlcXC1dKlthLXpBLVowLTldKVxcLikqKFtBLVphLXowLTldfFtBLVphLXowLTldW0EtWmEtejAtOVxcLV0qW0EtWmEtejAtOV0pJC8sXG4gICAgaXBSZWdleDogSXAuY3JlYXRlSXBSZWdleChbJ2lwdjQnLCAnaXB2NicsICdpcHZmdXR1cmUnXSwgJ29wdGlvbmFsJyksXG4gICAgaXNvRHVyYXRpb25SZWdleDogL15QKD8hJCkoXFxkK1kpPyhcXGQrTSk/KFxcZCtXKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/JC8sXG5cbiAgICBndWlkQnJhY2tldHM6IHtcbiAgICAgICAgJ3snOiAnfScsICdbJzogJ10nLCAnKCc6ICcpJywgJyc6ICcnXG4gICAgfSxcbiAgICBndWlkVmVyc2lvbnM6IHtcbiAgICAgICAgdXVpZHYxOiAnMScsXG4gICAgICAgIHV1aWR2MjogJzInLFxuICAgICAgICB1dWlkdjM6ICczJyxcbiAgICAgICAgdXVpZHY0OiAnNCcsXG4gICAgICAgIHV1aWR2NTogJzUnXG4gICAgfSxcblxuICAgIGNpZHJQcmVzZW5jZXM6IFsncmVxdWlyZWQnLCAnb3B0aW9uYWwnLCAnZm9yYmlkZGVuJ10sXG4gICAgbm9ybWFsaXphdGlvbkZvcm1zOiBbJ05GQycsICdORkQnLCAnTkZLQycsICdORktEJ11cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBBbnkuZXh0ZW5kKHtcblxuICAgIHR5cGU6ICdzdHJpbmcnLFxuXG4gICAgZmxhZ3M6IHtcblxuICAgICAgICBpbnNlbnNpdGl2ZTogeyBkZWZhdWx0OiBmYWxzZSB9LFxuICAgICAgICB0cnVuY2F0ZTogeyBkZWZhdWx0OiBmYWxzZSB9XG4gICAgfSxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgcmVwbGFjZW1lbnRzOiB7IGluaXQ6IG51bGwgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgZnJvbTogJ3N0cmluZycsXG4gICAgICAgIG1ldGhvZCh2YWx1ZSwgeyBzY2hlbWEsIHN0YXRlLCBwcmVmcyB9KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZSA9IHNjaGVtYS4kX2dldFJ1bGUoJ25vcm1hbGl6ZScpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubm9ybWFsaXplKG5vcm1hbGl6ZS5hcmdzLmZvcm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYXNpbmcgPSBzY2hlbWEuJF9nZXRSdWxlKCdjYXNlJyk7XG4gICAgICAgICAgICBpZiAoY2FzaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjYXNpbmcuYXJncy5kaXJlY3Rpb24gPT09ICd1cHBlcicgPyB2YWx1ZS50b0xvY2FsZVVwcGVyQ2FzZSgpIDogdmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdHJpbSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3RyaW0nKTtcbiAgICAgICAgICAgIGlmICh0cmltICYmXG4gICAgICAgICAgICAgICAgdHJpbS5hcmdzLmVuYWJsZWQpIHtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfdGVybXMucmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXBsYWNlbWVudCBvZiBzY2hlbWEuJF90ZXJtcy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlcGxhY2VtZW50LnBhdHRlcm4sIHJlcGxhY2VtZW50LnJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhleCA9IHNjaGVtYS4kX2dldFJ1bGUoJ2hleCcpO1xuICAgICAgICAgICAgaWYgKGhleCAmJlxuICAgICAgICAgICAgICAgIGhleC5hcmdzLm9wdGlvbnMuYnl0ZUFsaWduZWQgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGAwJHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLiRfZ2V0UnVsZSgnaXNvRGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNvID0gaW50ZXJuYWxzLmlzb0RhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc28pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpc287XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2NoZW1hLl9mbGFncy50cnVuY2F0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBzY2hlbWEuJF9nZXRSdWxlKCdtYXgnKTtcbiAgICAgICAgICAgICAgICBpZiAocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGltaXQgPSBydWxlLmFyZ3MubGltaXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKGxpbWl0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQgPSBsaW1pdC5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFDb21tb24ubGltaXQobGltaXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZWYnLCBsaW1pdCwgeyByZWY6IHJ1bGUuYXJncy5saW1pdCwgYXJnOiAnbGltaXQnLCByZWFzb246ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicgfSwgc3RhdGUsIHByZWZzKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlKHZhbHVlLCB7IGVycm9yIH0pIHtcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGVycm9yczogZXJyb3IoJ3N0cmluZy5iYXNlJykgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzdHJpbmcuZW1wdHknKSB9O1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJ1bGVzOiB7XG5cbiAgICAgICAgYWxwaGFudW06IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnYWxwaGFudW0nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKC9eW2EtekEtWjAtOV0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuYWxwaGFudW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBiYXNlNjQ6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsncGFkZGluZ1JlcXVpcmVkJywgJ3VybFNhZmUnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyB1cmxTYWZlOiBmYWxzZSwgcGFkZGluZ1JlcXVpcmVkOiB0cnVlLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnBhZGRpbmdSZXF1aXJlZCA9PT0gJ2Jvb2xlYW4nLCAncGFkZGluZ1JlcXVpcmVkIG11c3QgYmUgYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy51cmxTYWZlID09PSAnYm9vbGVhbicsICd1cmxTYWZlIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Jhc2U2NCcsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBpbnRlcm5hbHMuYmFzZTY0UmVnZXhbb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRdW29wdGlvbnMudXJsU2FmZV07XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmJhc2U2NCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChkaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydChbJ2xvd2VyJywgJ3VwcGVyJ10uaW5jbHVkZXMoZGlyZWN0aW9uKSwgJ0ludmFsaWQgY2FzZTonLCBkaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2Nhc2UnLCBhcmdzOiB7IGRpcmVjdGlvbiB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGRpcmVjdGlvbiB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnbG93ZXInICYmIHZhbHVlID09PSB2YWx1ZS50b0xvY2FsZUxvd2VyQ2FzZSgpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3VwcGVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUudG9Mb2NhbGVVcHBlckNhc2UoKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihgc3RyaW5nLiR7ZGlyZWN0aW9ufWNhc2VgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb252ZXJ0OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlZGl0Q2FyZDoge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdjcmVkaXRDYXJkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGxldCBpID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtdWwgPSAxO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gdmFsdWUuY2hhckF0KGkpICogbXVsO1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAoY2hhciAtIChjaGFyID4gOSkgKiA5KTtcbiAgICAgICAgICAgICAgICAgICAgbXVsID0gbXVsIF4gMztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VtID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBzdW0gJSAxMCA9PT0gMCkge1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmNyZWRpdENhcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkYXRhVXJpOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ3BhZGRpbmdSZXF1aXJlZCddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IHBhZGRpbmdSZXF1aXJlZDogdHJ1ZSwgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Ygb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWQgPT09ICdib29sZWFuJywgJ3BhZGRpbmdSZXF1aXJlZCBtdXN0IGJlIGJvb2xlYW4nKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdkYXRhVXJpJywgYXJnczogeyBvcHRpb25zIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goaW50ZXJuYWxzLmRhdGFVcmlSZWdleC5mb3JtYXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVzWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlc1syXSAhPT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NHJlZ2V4ID0gaW50ZXJuYWxzLmRhdGFVcmlSZWdleC5iYXNlNjRbb3B0aW9ucy5wYWRkaW5nUmVxdWlyZWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZTY0cmVnZXgudGVzdChtYXRjaGVzWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5kYXRhVXJpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucykge1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWydhbGxvd1VuaWNvZGUnLCAnbWluRG9tYWluU2VnbWVudHMnLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdkb21haW4nLCBhcmdzOiB7IG9wdGlvbnMgfSwgYWRkcmVzcyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgeyBhZGRyZXNzIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChEb21haW4uaXNWYWxpZCh2YWx1ZSwgYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZG9tYWluJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZW1haWw6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dVbmljb2RlJywgJ2lnbm9yZUxlbmd0aCcsICdtaW5Eb21haW5TZWdtZW50cycsICdtdWx0aXBsZScsICdzZXBhcmF0b3InLCAndGxkcyddKTtcbiAgICAgICAgICAgICAgICBBc3NlcnQob3B0aW9ucy5tdWx0aXBsZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLm11bHRpcGxlID09PSAnYm9vbGVhbicsICdtdWx0aXBsZSBvcHRpb24gbXVzdCBiZSBhbiBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXHMqWyR7b3B0aW9ucy5zZXBhcmF0b3IgPyBFc2NhcGVSZWdleChvcHRpb25zLnNlcGFyYXRvcikgOiAnLCd9XVxcXFxzKmApO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2VtYWlsJywgYXJnczogeyBvcHRpb25zIH0sIHJlZ2V4LCBhZGRyZXNzIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCwgYWRkcmVzcyB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBlbWFpbHMgPSBvcHRpb25zLm11bHRpcGxlID8gdmFsdWUuc3BsaXQocmVnZXgpIDogW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW1haWwgb2YgZW1haWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghRW1haWwuaXNWYWxpZChlbWFpbCwgYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRzLnB1c2goZW1haWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnZhbGlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZW1haWwnLCB7IHZhbHVlLCBpbnZhbGlkcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBndWlkOiB7XG4gICAgICAgICAgICBhbGlhczogJ3V1aWQnLFxuICAgICAgICAgICAgbWV0aG9kKG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgICAgICAgICAgQ29tbW9uLmFzc2VydE9wdGlvbnMob3B0aW9ucywgWyd2ZXJzaW9uJ10pO1xuXG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb25OdW1iZXJzID0gJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25zID0gW10uY29uY2F0KG9wdGlvbnMudmVyc2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHZlcnNpb25zLmxlbmd0aCA+PSAxLCAndmVyc2lvbiBtdXN0IGhhdmUgYXQgbGVhc3QgMSB2YWxpZCB2ZXJzaW9uIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJywgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25OdW1iZXIgPSBpbnRlcm5hbHMuZ3VpZFZlcnNpb25zW3ZlcnNpb24udG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQodmVyc2lvbk51bWJlciwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhpbnRlcm5hbHMuZ3VpZFZlcnNpb25zKS5qb2luKCcsICcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydCghc2V0Lmhhcyh2ZXJzaW9uTnVtYmVyKSwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3Qgbm90IGJlIGEgZHVwbGljYXRlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb25OdW1iZXJzICs9IHZlcnNpb25OdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKHZlcnNpb25OdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeKFtcXFxcW3tcXFxcKF0/KVswLTlBLUZdezh9KFs6LV0/KVswLTlBLUZdezR9XFxcXDI/WyR7dmVyc2lvbk51bWJlcnMgfHwgJzAtOUEtRid9XVswLTlBLUZdezN9XFxcXDI/WyR7dmVyc2lvbk51bWJlcnMgPyAnODlBQicgOiAnMC05QS1GJ31dWzAtOUEtRl17M31cXFxcMj9bMC05QS1GXXsxMn0oW1xcXFxdfVxcXFwpXT8pJGAsICdpJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnZ3VpZCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgeyByZWdleCB9KSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gcmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5ndWlkJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hpbmcgYnJhY2VzXG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmd1aWRCcmFja2V0c1tyZXN1bHRzWzFdXSAhPT0gcmVzdWx0c1tyZXN1bHRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZ3VpZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoZXg6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYnl0ZUFsaWduZWQnXSk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zID0geyBieXRlQWxpZ25lZDogZmFsc2UsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIG9wdGlvbnMuYnl0ZUFsaWduZWQgPT09ICdib29sZWFuJywgJ2J5dGVBbGlnbmVkIG11c3QgYmUgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ2hleCcsIGFyZ3M6IHsgb3B0aW9ucyB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpbnRlcm5hbHMuaGV4UmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5oZXgnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlQWxpZ25lZCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5oZXhBbGlnbicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBob3N0bmFtZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKCdob3N0bmFtZScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDw9IDI1NSAmJiBpbnRlcm5hbHMuaG9zdFJlZ2V4LnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5pcFJlZ2V4LnRlc3QodmFsdWUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuaG9zdG5hbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbnNlbnNpdGl2ZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCdpbnNlbnNpdGl2ZScsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlwOiB7XG4gICAgICAgICAgICBtZXRob2Qob3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2NpZHInLCAndmVyc2lvbiddKTtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTsgICAgICAgLy8gU2hhbGxvdyBjbG9uZWRcblxuICAgICAgICAgICAgICAgIGxldCByZWdleCA9IGludGVybmFscy5pcFJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNpZHIpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLmNpZHIgPT09ICdzdHJpbmcnLCAnY2lkciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2lkciA9IG9wdGlvbnMuY2lkci50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydChpbnRlcm5hbHMuY2lkclByZXNlbmNlcy5pbmNsdWRlcyhvcHRpb25zLmNpZHIpLCAnY2lkciBtdXN0IGJlIG9uZSBvZiAnICsgaW50ZXJuYWxzLmNpZHJQcmVzZW5jZXMuam9pbignLCAnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnZlcnNpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2lkciAhPT0gJ29wdGlvbmFsJykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdleCA9IElwLmNyZWF0ZUlwUmVnZXgoWydpcHY0JywgJ2lwdjYnLCAnaXB2ZnV0dXJlJ10sIG9wdGlvbnMuY2lkcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2lkciA9ICdvcHRpb25hbCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHZlcnNpb25zO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudmVyc2lvbiA9IFtvcHRpb25zLnZlcnNpb25dO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KG9wdGlvbnMudmVyc2lvbi5sZW5ndGggPj0gMSwgJ3ZlcnNpb24gbXVzdCBoYXZlIGF0IGxlYXN0IDEgdmVyc2lvbiBzcGVjaWZpZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMudmVyc2lvbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBvcHRpb25zLnZlcnNpb25baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBBc3NlcnQodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnLCAndmVyc2lvbiBhdCBwb3NpdGlvbiAnICsgaSArICcgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFzc2VydChJcC52ZXJzaW9uc1t2ZXJzaW9uXSwgJ3ZlcnNpb24gYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgb25lIG9mICcgKyBPYmplY3Qua2V5cyhJcC52ZXJzaW9ucykuam9pbignLCAnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9ucy5wdXNoKHZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbnMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmVyc2lvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBJcC5jcmVhdGVJcFJlZ2V4KHZlcnNpb25zLCBvcHRpb25zLmNpZHIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSh7IG5hbWU6ICdpcCcsIGFyZ3M6IHsgb3B0aW9ucyB9LCB2ZXJzaW9ucywgcmVnZXggfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMsIHsgb3B0aW9ucyB9LCB7IHZlcnNpb25zLCByZWdleCB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlwVmVyc2lvbicsIHsgdmFsdWUsIGNpZHI6IG9wdGlvbnMuY2lkciwgdmVyc2lvbjogdmVyc2lvbnMgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy5pcCcsIHsgdmFsdWUsIGNpZHI6IG9wdGlvbnMuY2lkciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpc29EYXRlOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ2lzb0RhdGUnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmlzb0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ3N0cmluZy5pc29EYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNvRHVyYXRpb246IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRfYWRkUnVsZSgnaXNvRHVyYXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWxpZGF0ZSh2YWx1ZSwgaGVscGVycykge1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVybmFscy5pc29EdXJhdGlvblJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcignc3RyaW5nLmlzb0R1cmF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbGVuZ3RoOiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbGVuZ3RoJywgbGltaXQsICc9JywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGxpbWl0LCBlbmNvZGluZyB9LCB7IG5hbWUsIG9wZXJhdG9yLCBhcmdzIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kaW5nID8gQnVmZmVyICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlLCBlbmNvZGluZykgOiB2YWx1ZS5sZW5ndGg7ICAgICAgLy8gJGxhYjpjb3ZlcmFnZTppZ25vcmUkXG4gICAgICAgICAgICAgICAgaWYgKENvbW1vbi5jb21wYXJlKGxlbmd0aCwgbGltaXQsIG9wZXJhdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy4nICsgbmFtZSwgeyBsaW1pdDogYXJncy5saW1pdCwgdmFsdWUsIGVuY29kaW5nIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdsaW1pdCcsXG4gICAgICAgICAgICAgICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0OiBDb21tb24ubGltaXQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdlbmNvZGluZydcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcblxuICAgICAgICBsb3dlcmNhc2U6IHtcbiAgICAgICAgICAgIG1ldGhvZCgpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhc2UoJ2xvd2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbWF4OiB7XG4gICAgICAgICAgICBtZXRob2QobGltaXQsIGVuY29kaW5nKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmxlbmd0aCh0aGlzLCAnbWF4JywgbGltaXQsICc8PScsIGVuY29kaW5nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcmdzOiBbJ2xpbWl0JywgJ2VuY29kaW5nJ11cbiAgICAgICAgfSxcblxuICAgICAgICBtaW46IHtcbiAgICAgICAgICAgIG1ldGhvZChsaW1pdCwgZW5jb2RpbmcpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMubGVuZ3RoKHRoaXMsICdtaW4nLCBsaW1pdCwgJz49JywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFyZ3M6IFsnbGltaXQnLCAnZW5jb2RpbmcnXVxuICAgICAgICB9LFxuXG4gICAgICAgIG5vcm1hbGl6ZToge1xuICAgICAgICAgICAgbWV0aG9kKGZvcm0gPSAnTkZDJykge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGludGVybmFscy5ub3JtYWxpemF0aW9uRm9ybXMuaW5jbHVkZXMoZm9ybSksICdub3JtYWxpemF0aW9uIGZvcm0gbXVzdCBiZSBvbmUgb2YgJyArIGludGVybmFscy5ub3JtYWxpemF0aW9uRm9ybXMuam9pbignLCAnKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAnbm9ybWFsaXplJywgYXJnczogeyBmb3JtIH0gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIHsgZXJyb3IgfSwgeyBmb3JtIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdmFsdWUubm9ybWFsaXplKGZvcm0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IoJ3N0cmluZy5ub3JtYWxpemUnLCB7IHZhbHVlLCBmb3JtIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnZlcnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBwYXR0ZXJuOiB7XG4gICAgICAgICAgICBhbGlhczogJ3JlZ2V4JyxcbiAgICAgICAgICAgIG1ldGhvZChyZWdleCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQocmVnZXggaW5zdGFuY2VvZiBSZWdFeHAsICdyZWdleCBtdXN0IGJlIGEgUmVnRXhwJyk7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KCFyZWdleC5mbGFncy5pbmNsdWRlcygnZycpICYmICFyZWdleC5mbGFncy5pbmNsdWRlcygneScpLCAncmVnZXggc2hvdWxkIG5vdCB1c2UgZ2xvYmFsIG9yIHN0aWNreSBtb2RlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IG5hbWU6IG9wdGlvbnMgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBDb21tb24uYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBbJ2ludmVydCcsICduYW1lJ10pO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gWydzdHJpbmcucGF0dGVybicsIG9wdGlvbnMuaW52ZXJ0ID8gJy5pbnZlcnQnIDogJycsIG9wdGlvbnMubmFtZSA/ICcubmFtZScgOiAnLmJhc2UnXS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAncGF0dGVybicsIGFyZ3M6IHsgcmVnZXgsIG9wdGlvbnMgfSwgZXJyb3JDb2RlIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IHJlZ2V4LCBvcHRpb25zIH0sIHsgZXJyb3JDb2RlIH0pIHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5NYXRjaCA9IHJlZ2V4LnRlc3QodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5NYXRjaCBeIG9wdGlvbnMuaW52ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVycy5lcnJvcihlcnJvckNvZGUsIHsgbmFtZTogb3B0aW9ucy5uYW1lLCByZWdleCwgdmFsdWUgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXJnczogWydyZWdleCcsICdvcHRpb25zJ10sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlcGxhY2U6IHtcbiAgICAgICAgICAgIG1ldGhvZChwYXR0ZXJuLCByZXBsYWNlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChFc2NhcGVSZWdleChwYXR0ZXJuKSwgJ2cnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBBc3NlcnQocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCwgJ3BhdHRlcm4gbXVzdCBiZSBhIFJlZ0V4cCcpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgcmVwbGFjZW1lbnQgPT09ICdzdHJpbmcnLCAncmVwbGFjZW1lbnQgbXVzdCBiZSBhIFN0cmluZycpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFvYmouJF90ZXJtcy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLiRfdGVybXMucmVwbGFjZW1lbnRzLnB1c2goeyBwYXR0ZXJuLCByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRva2VuOiB7XG4gICAgICAgICAgICBtZXRob2QoKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoJ3Rva2VuJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpIHtcblxuICAgICAgICAgICAgICAgIGlmICgvXlxcdyskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy50b2tlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHRyaW06IHtcbiAgICAgICAgICAgIG1ldGhvZChlbmFibGVkID0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KHR5cGVvZiBlbmFibGVkID09PSAnYm9vbGVhbicsICdlbmFibGVkIG11c3QgYmUgYSBib29sZWFuJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kX2FkZFJ1bGUoeyBuYW1lOiAndHJpbScsIGFyZ3M6IHsgZW5hYmxlZCB9IH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IGVuYWJsZWQgfSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB2YWx1ZS50cmltKCkpIHtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy50cmltJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udmVydDogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIHRydW5jYXRlOiB7XG4gICAgICAgICAgICBtZXRob2QoZW5hYmxlZCA9IHRydWUpIHtcblxuICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgZW5hYmxlZCA9PT0gJ2Jvb2xlYW4nLCAnZW5hYmxlZCBtdXN0IGJlIGEgYm9vbGVhbicpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9zZXRGbGFnKCd0cnVuY2F0ZScsIGVuYWJsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVwcGVyY2FzZToge1xuICAgICAgICAgICAgbWV0aG9kKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FzZSgndXBwZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cmk6IHtcbiAgICAgICAgICAgIG1ldGhvZChvcHRpb25zID0ge30pIHtcblxuICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMsIFsnYWxsb3dSZWxhdGl2ZScsICdhbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMnLCAnZG9tYWluJywgJ3JlbGF0aXZlT25seScsICdzY2hlbWUnXSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB1bmtub3duT3B0aW9ucyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcigoa2V5KSA9PiAhWydzY2hlbWUnLCAnYWxsb3dSZWxhdGl2ZScsICdyZWxhdGl2ZU9ubHknLCAnYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzJywgJ2RvbWFpbiddLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICAgICAgICAgIEFzc2VydCh1bmtub3duT3B0aW9ucy5sZW5ndGggPT09IDAsIGBvcHRpb25zIGNvbnRhaW4gdW5rbm93biBrZXlzOiAke3Vua25vd25PcHRpb25zfWApO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIENvbW1vbi5hc3NlcnRPcHRpb25zKG9wdGlvbnMuZG9tYWluLCBbJ2FsbG93VW5pY29kZScsICdtaW5Eb21haW5TZWdtZW50cycsICd0bGRzJ10pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gVXJpLmNyZWF0ZVJlZ2V4KG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbiA9IG9wdGlvbnMuZG9tYWluID8gaW50ZXJuYWxzLmFkZHJlc3NPcHRpb25zKG9wdGlvbnMuZG9tYWluKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJF9hZGRSdWxlKHsgbmFtZTogJ3VyaScsIGFyZ3M6IHsgb3B0aW9ucyB9LCByZWdleCwgZG9tYWluIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZhbGlkYXRlKHZhbHVlLCBoZWxwZXJzLCB7IG9wdGlvbnMgfSwgeyByZWdleCwgZG9tYWluIH0pIHtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2h0dHA6LycsICdodHRwczovJ10uaW5jbHVkZXModmFsdWUpKSB7ICAgICAgICAgICAgLy8gc2NoZW1lOi8gaXMgdGVjaG5pY2FsbHkgdmFsaWQgYnV0IG1ha2VzIG5vIHNlbnNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIURvbWFpbi5pc1ZhbGlkKG1hdGNoWzFdLCBkb21haW4pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcuZG9tYWluJywgeyB2YWx1ZTogbWF0Y2hbMV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVsYXRpdmVPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpUmVsYXRpdmVPbmx5Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLmVycm9yKCdzdHJpbmcudXJpQ3VzdG9tU2NoZW1lJywgeyBzY2hlbWU6IHJlZ2V4LnNjaGVtZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuZXJyb3IoJ3N0cmluZy51cmknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5yZXBsYWNlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgcmVwbGFjZW1lbnQgfSBvZiBkZXNjLnJlcGxhY2VtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmoucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG1lc3NhZ2VzOiB7XG4gICAgICAgICdzdHJpbmcuYWxwaGFudW0nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBvbmx5IGNvbnRhaW4gYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5iYXNlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSBzdHJpbmcnLFxuICAgICAgICAnc3RyaW5nLmJhc2U2NCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgdmFsaWQgYmFzZTY0IHN0cmluZycsXG4gICAgICAgICdzdHJpbmcuY3JlZGl0Q2FyZCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgY3JlZGl0IGNhcmQnLFxuICAgICAgICAnc3RyaW5nLmRhdGFVcmknOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIGRhdGFVcmkgc3RyaW5nJyxcbiAgICAgICAgJ3N0cmluZy5kb21haW4nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBjb250YWluIGEgdmFsaWQgZG9tYWluIG5hbWUnLFxuICAgICAgICAnc3RyaW5nLmVtYWlsJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCBlbWFpbCcsXG4gICAgICAgICdzdHJpbmcuZW1wdHknOiAnXCJ7eyNsYWJlbH19XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgZW1wdHknLFxuICAgICAgICAnc3RyaW5nLmd1aWQnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIEdVSUQnLFxuICAgICAgICAnc3RyaW5nLmhleCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IG9ubHkgY29udGFpbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzJyxcbiAgICAgICAgJ3N0cmluZy5oZXhBbGlnbic6ICdcInt7I2xhYmVsfX1cIiBoZXggZGVjb2RlZCByZXByZXNlbnRhdGlvbiBtdXN0IGJlIGJ5dGUgYWxpZ25lZCcsXG4gICAgICAgICdzdHJpbmcuaG9zdG5hbWUnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIGhvc3RuYW1lJyxcbiAgICAgICAgJ3N0cmluZy5pcCc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyB3aXRoIGEge3sjY2lkcn19IENJRFInLFxuICAgICAgICAnc3RyaW5nLmlwVmVyc2lvbic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IGJlIGEgdmFsaWQgaXAgYWRkcmVzcyBvZiBvbmUgb2YgdGhlIGZvbGxvd2luZyB2ZXJzaW9ucyB7eyN2ZXJzaW9ufX0gd2l0aCBhIHt7I2NpZHJ9fSBDSURSJyxcbiAgICAgICAgJ3N0cmluZy5pc29EYXRlJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgaW4gaXNvIGZvcm1hdCcsXG4gICAgICAgICdzdHJpbmcuaXNvRHVyYXRpb24nOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIElTTyA4NjAxIGR1cmF0aW9uJyxcbiAgICAgICAgJ3N0cmluZy5sZW5ndGgnOiAnXCJ7eyNsYWJlbH19XCIgbGVuZ3RoIG11c3QgYmUge3sjbGltaXR9fSBjaGFyYWN0ZXJzIGxvbmcnLFxuICAgICAgICAnc3RyaW5nLmxvd2VyY2FzZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IG9ubHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycycsXG4gICAgICAgICdzdHJpbmcubWF4JzogJ1wie3sjbGFiZWx9fVwiIGxlbmd0aCBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7eyNsaW1pdH19IGNoYXJhY3RlcnMgbG9uZycsXG4gICAgICAgICdzdHJpbmcubWluJzogJ1wie3sjbGFiZWx9fVwiIGxlbmd0aCBtdXN0IGJlIGF0IGxlYXN0IHt7I2xpbWl0fX0gY2hhcmFjdGVycyBsb25nJyxcbiAgICAgICAgJ3N0cmluZy5ub3JtYWxpemUnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSB1bmljb2RlIG5vcm1hbGl6ZWQgaW4gdGhlIHt7I2Zvcm19fSBmb3JtJyxcbiAgICAgICAgJ3N0cmluZy50b2tlbic6ICdcInt7I2xhYmVsfX1cIiBtdXN0IG9ubHkgY29udGFpbiBhbHBoYS1udW1lcmljIGFuZCB1bmRlcnNjb3JlIGNoYXJhY3RlcnMnLFxuICAgICAgICAnc3RyaW5nLnBhdHRlcm4uYmFzZSc6ICdcInt7I2xhYmVsfX1cIiB3aXRoIHZhbHVlIFwie1suXX1cIiBmYWlscyB0byBtYXRjaCB0aGUgcmVxdWlyZWQgcGF0dGVybjoge3sjcmVnZXh9fScsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5uYW1lJzogJ1wie3sjbGFiZWx9fVwiIHdpdGggdmFsdWUgXCJ7Wy5dfVwiIGZhaWxzIHRvIG1hdGNoIHRoZSB7eyNuYW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcucGF0dGVybi5pbnZlcnQuYmFzZSc6ICdcInt7I2xhYmVsfX1cIiB3aXRoIHZhbHVlIFwie1suXX1cIiBtYXRjaGVzIHRoZSBpbnZlcnRlZCBwYXR0ZXJuOiB7eyNyZWdleH19JyxcbiAgICAgICAgJ3N0cmluZy5wYXR0ZXJuLmludmVydC5uYW1lJzogJ1wie3sjbGFiZWx9fVwiIHdpdGggdmFsdWUgXCJ7Wy5dfVwiIG1hdGNoZXMgdGhlIGludmVydGVkIHt7I25hbWV9fSBwYXR0ZXJuJyxcbiAgICAgICAgJ3N0cmluZy50cmltJzogJ1wie3sjbGFiZWx9fVwiIG11c3Qgbm90IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlJyxcbiAgICAgICAgJ3N0cmluZy51cmknOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHZhbGlkIHVyaScsXG4gICAgICAgICdzdHJpbmcudXJpQ3VzdG9tU2NoZW1lJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCB1cmkgd2l0aCBhIHNjaGVtZSBtYXRjaGluZyB0aGUge3sjc2NoZW1lfX0gcGF0dGVybicsXG4gICAgICAgICdzdHJpbmcudXJpUmVsYXRpdmVPbmx5JzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgYSB2YWxpZCByZWxhdGl2ZSB1cmknLFxuICAgICAgICAnc3RyaW5nLnVwcGVyY2FzZSc6ICdcInt7I2xhYmVsfX1cIiBtdXN0IG9ubHkgY29udGFpbiB1cHBlcmNhc2UgY2hhcmFjdGVycydcbiAgICB9XG59KTtcblxuXG4vLyBIZWxwZXJzXG5cbmludGVybmFscy5hZGRyZXNzT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLy8gbWluRG9tYWluU2VnbWVudHNcblxuICAgIEFzc2VydChvcHRpb25zLm1pbkRvbWFpblNlZ21lbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIob3B0aW9ucy5taW5Eb21haW5TZWdtZW50cykgJiYgb3B0aW9ucy5taW5Eb21haW5TZWdtZW50cyA+IDAsICdtaW5Eb21haW5TZWdtZW50cyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuXG4gICAgLy8gdGxkc1xuXG4gICAgaWYgKG9wdGlvbnMudGxkcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudGxkcyA9PT0gdHJ1ZSB8fFxuICAgICAgICBvcHRpb25zLnRsZHMgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIEFzc2VydChpbnRlcm5hbHMudGxkcywgJ0J1aWx0LWluIFRMRCBsaXN0IGRpc2FibGVkJyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBpbnRlcm5hbHMudGxkcyk7XG4gICAgfVxuXG4gICAgQXNzZXJ0KHR5cGVvZiBvcHRpb25zLnRsZHMgPT09ICdvYmplY3QnLCAndGxkcyBtdXN0IGJlIHRydWUsIGZhbHNlLCBvciBhbiBvYmplY3QnKTtcblxuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLnRsZHMuZGVueTtcbiAgICBpZiAoZGVueSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkZW55KSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogeyBkZW55OiBuZXcgU2V0KGRlbnkpIH0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICBBc3NlcnQob3B0aW9ucy50bGRzLmRlbnkgaW5zdGFuY2VvZiBTZXQsICd0bGRzLmRlbnkgbXVzdCBiZSBhbiBhcnJheSwgU2V0LCBvciBib29sZWFuJyk7XG4gICAgICAgIEFzc2VydCghb3B0aW9ucy50bGRzLmFsbG93LCAnQ2Fubm90IHNwZWNpZnkgYm90aCB0bGRzLmFsbG93IGFuZCB0bGRzLmRlbnkgbGlzdHMnKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLnRsZHMuYWxsb3c7XG4gICAgaWYgKCFhbGxvdykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoYWxsb3cgPT09IHRydWUpIHtcbiAgICAgICAgQXNzZXJ0KGludGVybmFscy50bGRzLCAnQnVpbHQtaW4gVExEIGxpc3QgZGlzYWJsZWQnKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIGludGVybmFscy50bGRzKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvdykpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxkczogeyBhbGxvdzogbmV3IFNldChhbGxvdykgfSB9KTtcbiAgICB9XG5cbiAgICBBc3NlcnQob3B0aW9ucy50bGRzLmFsbG93IGluc3RhbmNlb2YgU2V0LCAndGxkcy5hbGxvdyBtdXN0IGJlIGFuIGFycmF5LCBTZXQsIG9yIGJvb2xlYW4nKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cblxuaW50ZXJuYWxzLmlzb0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblxuICAgIGlmICghQ29tbW9uLmlzSXNvRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG59O1xuXG5cbmludGVybmFscy5sZW5ndGggPSBmdW5jdGlvbiAoc2NoZW1hLCBuYW1lLCBsaW1pdCwgb3BlcmF0b3IsIGVuY29kaW5nKSB7XG5cbiAgICBBc3NlcnQoIWVuY29kaW5nIHx8IEJ1ZmZlciAmJiBCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZyksICdJbnZhbGlkIGVuY29kaW5nOicsIGVuY29kaW5nKTsgICAgICAvLyAkbGFiOmNvdmVyYWdlOmlnbm9yZSRcblxuICAgIHJldHVybiBzY2hlbWEuJF9hZGRSdWxlKHsgbmFtZSwgbWV0aG9kOiAnbGVuZ3RoJywgYXJnczogeyBsaW1pdCwgZW5jb2RpbmcgfSwgb3BlcmF0b3IgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBVcmkgPSByZXF1aXJlKCcuL3VyaScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMuY2lkcnMgPSB7XG4gICAgaXB2NDoge1xuICAgICAgICByZXF1aXJlZDogJ1xcXFwvKD86JyArIFVyaS5pcHY0Q2lkciArICcpJyxcbiAgICAgICAgb3B0aW9uYWw6ICcoPzpcXFxcLyg/OicgKyBVcmkuaXB2NENpZHIgKyAnKSk/JyxcbiAgICAgICAgZm9yYmlkZGVuOiAnJ1xuICAgIH0sXG4gICAgaXB2Njoge1xuICAgICAgICByZXF1aXJlZDogJ1xcXFwvJyArIFVyaS5pcHY2Q2lkcixcbiAgICAgICAgb3B0aW9uYWw6ICcoPzpcXFxcLycgKyBVcmkuaXB2NkNpZHIgKyAnKT8nLFxuICAgICAgICBmb3JiaWRkZW46ICcnXG4gICAgfSxcbiAgICBpcHZmdXR1cmU6IHtcbiAgICAgICAgcmVxdWlyZWQ6ICdcXFxcLycgKyBVcmkuaXB2NkNpZHIsXG4gICAgICAgIG9wdGlvbmFsOiAnKD86XFxcXC8nICsgVXJpLmlwdjZDaWRyICsgJyk/JyxcbiAgICAgICAgZm9yYmlkZGVuOiAnJ1xuICAgIH1cbn07XG5cblxuZXhwb3J0cy52ZXJzaW9ucyA9IHtcbiAgICBpcHY0OiBVcmkuaXB2NGFkZHJlc3MsXG4gICAgaXB2NjogVXJpLmlwdjZhZGRyZXNzLFxuICAgIGlwdmZ1dHVyZTogVXJpLmlwdkZ1dHVyZVxufTtcblxuXG5leHBvcnRzLmNyZWF0ZUlwUmVnZXggPSBmdW5jdGlvbiAodmVyc2lvbnMsIGNpZHIpIHtcblxuICAgIGNvbnN0IHBhcnRzID0gdmVyc2lvbnMubWFwKCh2ZXJzaW9uKSA9PiBleHBvcnRzLnZlcnNpb25zW3ZlcnNpb25dICsgZXhwb3J0cy5jaWRyc1t2ZXJzaW9uXVtjaWRyXSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14oPzonICsgcGFydHMuam9pbignfCcpICsgJykkJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IEVzY2FwZVJlZ2V4ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZXNjYXBlUmVnZXgnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuZ2VuZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zdCByZmMzOTg2ID0ge307XG5cbiAgICBjb25zdCBoZXhEaWdpdCA9ICdcXFxcZEEtRmEtZic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIRVhESUcgPSBESUdJVCAvIFwiQVwiIC8gXCJCXCIgLyBcIkNcIiAvIFwiRFwiIC8gXCJFXCIgLyBcIkZcIlxuICAgIGNvbnN0IGhleERpZ2l0T25seSA9ICdbJyArIGhleERpZ2l0ICsgJ10nO1xuXG4gICAgY29uc3QgdW5yZXNlcnZlZCA9ICdcXFxcdy1cXFxcLn4nOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnJlc2VydmVkID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gICAgY29uc3Qgc3ViRGVsaW1zID0gJyFcXFxcJCZcXCdcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PSc7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3ViLWRlbGltcyA9IFwiIVwiIC8gXCIkXCIgLyBcIiZcIiAvIFwiJ1wiIC8gXCIoXCIgLyBcIilcIiAvIFwiKlwiIC8gXCIrXCIgLyBcIixcIiAvIFwiO1wiIC8gXCI9XCJcbiAgICBjb25zdCBwY3RFbmNvZGVkID0gJyUnICsgaGV4RGlnaXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGN0LWVuY29kZWQgPSBcIiVcIiBIRVhESUcgSEVYRElHXG4gICAgY29uc3QgcGNoYXIgPSB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICc6QCc7ICAgICAgICAgICAgICAgICAgIC8vIHBjaGFyID0gdW5yZXNlcnZlZCAvIHBjdC1lbmNvZGVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIC8gXCJAXCJcbiAgICBjb25zdCBwY2hhck9ubHkgPSAnWycgKyBwY2hhciArICddJztcbiAgICBjb25zdCBkZWNPY3RlY3QgPSAnKD86MHswLDJ9XFxcXGR8MD9bMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pJzsgICAgIC8vIGRlYy1vY3RldCA9IERJR0lUIC8gJXgzMS0zOSBESUdJVCAvIFwiMVwiIDJESUdJVCAvIFwiMlwiICV4MzAtMzQgRElHSVQgLyBcIjI1XCIgJXgzMC0zNSAgOyAwLTkgLyAxMC05OSAvIDEwMC0xOTkgLyAyMDAtMjQ5IC8gMjUwLTI1NVxuXG4gICAgcmZjMzk4Ni5pcHY0YWRkcmVzcyA9ICcoPzonICsgZGVjT2N0ZWN0ICsgJ1xcXFwuKXszfScgKyBkZWNPY3RlY3Q7ICAgICAgICAgICAgLy8gSVB2NGFkZHJlc3MgPSBkZWMtb2N0ZXQgXCIuXCIgZGVjLW9jdGV0IFwiLlwiIGRlYy1vY3RldCBcIi5cIiBkZWMtb2N0ZXRcblxuICAgIC8qXG4gICAgICAgIGgxNiA9IDEqNEhFWERJRyA7IDE2IGJpdHMgb2YgYWRkcmVzcyByZXByZXNlbnRlZCBpbiBoZXhhZGVjaW1hbFxuICAgICAgICBsczMyID0gKCBoMTYgXCI6XCIgaDE2ICkgLyBJUHY0YWRkcmVzcyA7IGxlYXN0LXNpZ25pZmljYW50IDMyIGJpdHMgb2YgYWRkcmVzc1xuICAgICAgICBJUHY2YWRkcmVzcyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgICAgICAgICAgICAgXCI6OlwiIDUoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICAgICAgICAgICAgICAgaDE2IF0gXCI6OlwiIDQoIGgxNiBcIjpcIiApIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjIoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAyKCBoMTYgXCI6XCIgKSBsczMyXG4gICAgICAgICAgICAgICAgICAgIC8gWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICo0KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGxzMzJcbiAgICAgICAgICAgICAgICAgICAgLyBbICo1KCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgICAgICAgICAgICAgIGgxNlxuICAgICAgICAgICAgICAgICAgICAvIFsgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuICAgICovXG5cbiAgICBjb25zdCBoMTYgPSBoZXhEaWdpdE9ubHkgKyAnezEsNH0nO1xuICAgIGNvbnN0IGxzMzIgPSAnKD86JyArIGgxNiArICc6JyArIGgxNiArICd8JyArIHJmYzM5ODYuaXB2NGFkZHJlc3MgKyAnKSc7XG4gICAgY29uc3QgSVB2NlNpeEhleCA9ICcoPzonICsgaDE2ICsgJzopezZ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZpdmVIZXggPSAnOjooPzonICsgaDE2ICsgJzopezV9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NkZvdXJIZXggPSAnKD86JyArIGgxNiArICcpPzo6KD86JyArIGgxNiArICc6KXs0fScgKyBsczMyO1xuICAgIGNvbnN0IElQdjZUaHJlZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMX0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezN9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2NlR3b0hleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsMn0nICsgaDE2ICsgJyk/OjooPzonICsgaDE2ICsgJzopezJ9JyArIGxzMzI7XG4gICAgY29uc3QgSVB2Nk9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsM30nICsgaDE2ICsgJyk/OjonICsgaDE2ICsgJzonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleCA9ICcoPzooPzonICsgaDE2ICsgJzopezAsNH0nICsgaDE2ICsgJyk/OjonICsgbHMzMjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDIgPSAnKD86KD86JyArIGgxNiArICc6KXswLDV9JyArIGgxNiArICcpPzo6JyArIGgxNjtcbiAgICBjb25zdCBJUHY2Tm9uZUhleDMgPSAnKD86KD86JyArIGgxNiArICc6KXswLDZ9JyArIGgxNiArICcpPzo6JztcblxuICAgIHJmYzM5ODYuaXB2NENpZHIgPSAnXFxcXGR8WzEtMl1cXFxcZHwzWzAtMl0nOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSVB2NCBjaWRyID0gRElHSVQgLyAleDMxLTMyIERJR0lUIC8gXCIzXCIgJXgzMC0zMiAgOyAwLTkgLyAxMC0yOSAvIDMwLTMyXG4gICAgcmZjMzk4Ni5pcHY2Q2lkciA9ICcoPzowezAsMn1cXFxcZHwwP1sxLTldXFxcXGR8MVswMV1cXFxcZHwxMlswLThdKSc7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElQdjYgY2lkciA9IERJR0lUIC8gJXgzMS0zOSBESUdJVCAvIFwiMVwiICV4MC0xIERJR0lUIC8gXCIxMlwiICV4MC04OyAgIDAtOSAvIDEwLTk5IC8gMTAwLTExOSAvIDEyMC0xMjhcbiAgICByZmMzOTg2LmlwdjZhZGRyZXNzID0gJyg/OicgKyBJUHY2U2l4SGV4ICsgJ3wnICsgSVB2NkZpdmVIZXggKyAnfCcgKyBJUHY2Rm91ckhleCArICd8JyArIElQdjZUaHJlZUhleCArICd8JyArIElQdjZUd29IZXggKyAnfCcgKyBJUHY2T25lSGV4ICsgJ3wnICsgSVB2Nk5vbmVIZXggKyAnfCcgKyBJUHY2Tm9uZUhleDIgKyAnfCcgKyBJUHY2Tm9uZUhleDMgKyAnKSc7XG4gICAgcmZjMzk4Ni5pcHZGdXR1cmUgPSAndicgKyBoZXhEaWdpdE9ubHkgKyAnK1xcXFwuWycgKyB1bnJlc2VydmVkICsgc3ViRGVsaW1zICsgJzpdKyc7ICAgICAgLy8gSVB2RnV0dXJlID0gXCJ2XCIgMSpIRVhESUcgXCIuXCIgMSooIHVucmVzZXJ2ZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuXG4gICAgcmZjMzk4Ni5zY2hlbWUgPSAnW2EtekEtWl1bYS16QS1aXFxcXGQrLVxcXFwuXSonOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzY2hlbWUgPSBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcbiAgICByZmMzOTg2LnNjaGVtZVJlZ2V4ID0gbmV3IFJlZ0V4cChyZmMzOTg2LnNjaGVtZSk7XG5cbiAgICBjb25zdCB1c2VyaW5mbyA9ICdbJyArIHVucmVzZXJ2ZWQgKyBwY3RFbmNvZGVkICsgc3ViRGVsaW1zICsgJzpdKic7ICAgICAgICAgICAgICAgICAgICAgLy8gdXNlcmluZm8gPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuICAgIGNvbnN0IElQTGl0ZXJhbCA9ICdcXFxcWyg/OicgKyByZmMzOTg2LmlwdjZhZGRyZXNzICsgJ3wnICsgcmZjMzk4Ni5pcHZGdXR1cmUgKyAnKVxcXFxdJzsgICAgLy8gSVAtbGl0ZXJhbCA9IFwiW1wiICggSVB2NmFkZHJlc3MgLyBJUHZGdXR1cmUgICkgXCJdXCJcbiAgICBjb25zdCByZWdOYW1lID0gJ1snICsgdW5yZXNlcnZlZCArIHBjdEVuY29kZWQgKyBzdWJEZWxpbXMgKyAnXXsxLDI1NX0nOyAgICAgICAgICAgICAgICAgLy8gcmVnLW5hbWUgPSAqKCB1bnJlc2VydmVkIC8gcGN0LWVuY29kZWQgLyBzdWItZGVsaW1zIClcbiAgICBjb25zdCBob3N0ID0gJyg/OicgKyBJUExpdGVyYWwgKyAnfCcgKyByZmMzOTg2LmlwdjRhZGRyZXNzICsgJ3wnICsgcmVnTmFtZSArICcpJzsgICAgICAgLy8gaG9zdCA9IElQLWxpdGVyYWwgLyBJUHY0YWRkcmVzcyAvIHJlZy1uYW1lXG4gICAgY29uc3QgcG9ydCA9ICdcXFxcZConOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG9ydCA9ICpESUdJVFxuICAgIGNvbnN0IGF1dGhvcml0eSA9ICcoPzonICsgdXNlcmluZm8gKyAnQCk/JyArIGhvc3QgKyAnKD86OicgKyBwb3J0ICsgJyk/JzsgICAgICAgICAgICAgICAvLyBhdXRob3JpdHkgICA9IFsgdXNlcmluZm8gXCJAXCIgXSBob3N0IFsgXCI6XCIgcG9ydCBdXG4gICAgY29uc3QgYXV0aG9yaXR5Q2FwdHVyZSA9ICcoPzonICsgdXNlcmluZm8gKyAnQCk/KCcgKyBob3N0ICsgJykoPzo6JyArIHBvcnQgKyAnKT8nO1xuXG4gICAgLypcbiAgICAgICAgc2VnbWVudCAgICAgICA9ICpwY2hhclxuICAgICAgICBzZWdtZW50LW56ICAgID0gMSpwY2hhclxuICAgICAgICBwYXRoICAgICAgICAgID0gcGF0aC1hYmVtcHR5ICAgIDsgYmVnaW5zIHdpdGggXCIvXCIgJ3wnIGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1hYnNvbHV0ZSAgIDsgYmVnaW5zIHdpdGggXCIvXCIgYnV0IG5vdCBcIi8vXCJcbiAgICAgICAgICAgICAgICAgICAgLyBwYXRoLW5vc2NoZW1lICAgOyBiZWdpbnMgd2l0aCBhIG5vbi1jb2xvbiBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1yb290bGVzcyAgIDsgYmVnaW5zIHdpdGggYSBzZWdtZW50XG4gICAgICAgICAgICAgICAgICAgIC8gcGF0aC1lbXB0eSAgICAgIDsgemVybyBjaGFyYWN0ZXJzXG4gICAgICAgIHBhdGgtYWJlbXB0eSAgPSAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAgICAgcGF0aC1hYnNvbHV0ZSA9IFwiL1wiIFsgc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50ICkgXVxuICAgICAgICBwYXRoLXJvb3RsZXNzID0gc2VnbWVudC1ueiAqKCBcIi9cIiBzZWdtZW50IClcbiAgICAqL1xuXG4gICAgY29uc3Qgc2VnbWVudCA9IHBjaGFyT25seSArICcqJztcbiAgICBjb25zdCBzZWdtZW50TnogPSBwY2hhck9ubHkgKyAnKyc7XG4gICAgY29uc3Qgc2VnbWVudE56TmMgPSAnWycgKyB1bnJlc2VydmVkICsgcGN0RW5jb2RlZCArIHN1YkRlbGltcyArICdAJyArICddKyc7XG4gICAgY29uc3QgcGF0aEVtcHR5ID0gJyc7XG4gICAgY29uc3QgcGF0aEFiRW1wdHkgPSAnKD86XFxcXC8nICsgc2VnbWVudCArICcpKic7XG4gICAgY29uc3QgcGF0aEFic29sdXRlID0gJ1xcXFwvKD86JyArIHNlZ21lbnROeiArIHBhdGhBYkVtcHR5ICsgJyk/JztcbiAgICBjb25zdCBwYXRoUm9vdGxlc3MgPSBzZWdtZW50TnogKyBwYXRoQWJFbXB0eTtcbiAgICBjb25zdCBwYXRoTm9TY2hlbWUgPSBzZWdtZW50TnpOYyArIHBhdGhBYkVtcHR5O1xuICAgIGNvbnN0IHBhdGhBYk5vQXV0aG9yaXR5ID0gJyg/OlxcXFwvXFxcXC9cXFxcLycgKyBzZWdtZW50ICsgcGF0aEFiRW1wdHkgKyAnKSc7ICAgICAvLyBVc2VkIGJ5IGZpbGU6Ly8vXG5cbiAgICAvLyBoaWVyLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGhcblxuICAgIHJmYzM5ODYuaGllclBhcnQgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eSArIHBhdGhBYkVtcHR5ICsgJyknICsgJ3wnICsgcGF0aEFic29sdXRlICsgJ3wnICsgcGF0aFJvb3RsZXNzICsgJ3wnICsgcGF0aEFiTm9BdXRob3JpdHkgKyAnKSc7XG4gICAgcmZjMzk4Ni5oaWVyUGFydENhcHR1cmUgPSAnKD86JyArICcoPzpcXFxcL1xcXFwvJyArIGF1dGhvcml0eUNhcHR1cmUgKyBwYXRoQWJFbXB0eSArICcpJyArICd8JyArIHBhdGhBYnNvbHV0ZSArICd8JyArIHBhdGhSb290bGVzcyArICcpJztcblxuICAgIC8vIHJlbGF0aXZlLXBhcnQgPSBcIi8vXCIgYXV0aG9yaXR5IHBhdGgtYWJlbXB0eSAvIHBhdGgtYWJzb2x1dGUgLyBwYXRoLW5vc2NoZW1lIC8gcGF0aC1lbXB0eVxuXG4gICAgcmZjMzk4Ni5yZWxhdGl2ZVJlZiA9ICcoPzonICsgJyg/OlxcXFwvXFxcXC8nICsgYXV0aG9yaXR5ICsgcGF0aEFiRW1wdHkgKyAnKScgKyAnfCcgKyBwYXRoQWJzb2x1dGUgKyAnfCcgKyBwYXRoTm9TY2hlbWUgKyAnfCcgKyBwYXRoRW1wdHkgKyAnKSc7XG5cbiAgICAvLyBxdWVyeSA9ICooIHBjaGFyIC8gXCIvXCIgLyBcIj9cIiApXG4gICAgLy8gcXVlcnkgPSAqKCBwY2hhciAvIFwiW1wiIC8gXCJdXCIgLyBcIi9cIiAvIFwiP1wiIClcblxuICAgIHJmYzM5ODYucXVlcnkgPSAnWycgKyBwY2hhciArICdcXFxcL1xcXFw/XSooPz0jfCQpJzsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9GaW5pc2ggbWF0Y2hpbmcgZWl0aGVyIGF0IHRoZSBmcmFnbWVudCBwYXJ0ICd8JyBlbmQgb2YgdGhlIGxpbmUuXG4gICAgcmZjMzk4Ni5xdWVyeVdpdGhTcXVhcmVCcmFja2V0cyA9ICdbJyArIHBjaGFyICsgJ1xcXFxbXFxcXF1cXFxcL1xcXFw/XSooPz0jfCQpJztcblxuICAgIC8vIGZyYWdtZW50ID0gKiggcGNoYXIgLyBcIi9cIiAvIFwiP1wiIClcblxuICAgIHJmYzM5ODYuZnJhZ21lbnQgPSAnWycgKyBwY2hhciArICdcXFxcL1xcXFw/XSonO1xuXG4gICAgcmV0dXJuIHJmYzM5ODY7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGludGVybmFscy5yZmMzOTg2ID0gaW50ZXJuYWxzLmdlbmVyYXRlKCk7XG5cblxuaW50ZXJuYWxzLmNyZWF0ZVJlZ2V4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHJmYyA9IGludGVybmFscy5yZmMzOTg2O1xuXG4gICAgLy8gQ29uc3RydWN0IGV4cHJlc3Npb25cblxuICAgIGNvbnN0IHF1ZXJ5ID0gb3B0aW9ucy5hbGxvd1F1ZXJ5U3F1YXJlQnJhY2tldHMgPyByZmMucXVlcnlXaXRoU3F1YXJlQnJhY2tldHMgOiByZmMucXVlcnk7XG4gICAgY29uc3Qgc3VmZml4ID0gJyg/OlxcXFw/JyArIHF1ZXJ5ICsgJyk/JyArICcoPzojJyArIHJmYy5mcmFnbWVudCArICcpPyQnO1xuXG4gICAgLy8gcmVsYXRpdmUtcmVmID0gcmVsYXRpdmUtcGFydCBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdXG5cbiAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZU9ubHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcmZjLnJlbGF0aXZlUmVmICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gc2NoZW1lc1xuXG4gICAgbGV0IGN1c3RvbVNjaGVtZSA9ICcnO1xuICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgICBBc3NlcnQob3B0aW9ucy5zY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIG9wdGlvbnMuc2NoZW1lID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2NoZW1lKSwgJ3NjaGVtZSBtdXN0IGJlIGEgUmVnRXhwLCBTdHJpbmcsIG9yIEFycmF5Jyk7XG5cbiAgICAgICAgY29uc3Qgc2NoZW1lcyA9IFtdLmNvbmNhdChvcHRpb25zLnNjaGVtZSk7XG4gICAgICAgIEFzc2VydChzY2hlbWVzLmxlbmd0aCA+PSAxLCAnc2NoZW1lIG11c3QgaGF2ZSBhdCBsZWFzdCAxIHNjaGVtZSBzcGVjaWZpZWQnKTtcblxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBhcnJheSBpbnRvIGEgc3RyaW5nIHRvIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNjaGVtZXNcblxuICAgICAgICBjb25zdCBzZWxlY3Rpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gc2NoZW1lc1tpXTtcbiAgICAgICAgICAgIEFzc2VydChzY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdHlwZW9mIHNjaGVtZSA9PT0gJ3N0cmluZycsICdzY2hlbWUgYXQgcG9zaXRpb24gJyArIGkgKyAnIG11c3QgYmUgYSBSZWdFeHAgb3IgU3RyaW5nJyk7XG5cbiAgICAgICAgICAgIGlmIChzY2hlbWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLnB1c2goc2NoZW1lLnNvdXJjZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEFzc2VydChyZmMuc2NoZW1lUmVnZXgudGVzdChzY2hlbWUpLCAnc2NoZW1lIGF0IHBvc2l0aW9uICcgKyBpICsgJyBtdXN0IGJlIGEgdmFsaWQgc2NoZW1lJyk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9ucy5wdXNoKEVzY2FwZVJlZ2V4KHNjaGVtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VzdG9tU2NoZW1lID0gc2VsZWN0aW9ucy5qb2luKCd8Jyk7XG4gICAgfVxuXG4gICAgLy8gVVJJID0gc2NoZW1lIFwiOlwiIGhpZXItcGFydCBbIFwiP1wiIHF1ZXJ5IF0gWyBcIiNcIiBmcmFnbWVudCBdXG5cbiAgICBjb25zdCBzY2hlbWUgPSBjdXN0b21TY2hlbWUgPyAnKD86JyArIGN1c3RvbVNjaGVtZSArICcpJyA6IHJmYy5zY2hlbWU7XG4gICAgY29uc3QgYWJzb2x1dGUgPSAnKD86JyArIHNjaGVtZSArICc6JyArIChvcHRpb25zLmRvbWFpbiA/IHJmYy5oaWVyUGFydENhcHR1cmUgOiByZmMuaGllclBhcnQpICsgJyknO1xuICAgIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMuYWxsb3dSZWxhdGl2ZSA/ICcoPzonICsgYWJzb2x1dGUgKyAnfCcgKyByZmMucmVsYXRpdmVSZWYgKyAnKScgOiBhYnNvbHV0ZTtcbiAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgc3VmZml4KTtcbiAgICByZWdleC5zY2hlbWUgPSBjdXN0b21TY2hlbWU7XG4gICAgcmV0dXJuIHJlZ2V4O1xufTtcblxuXG5pbnRlcm5hbHMudXJpUmVnZXggPSBpbnRlcm5hbHMuY3JlYXRlUmVnZXgoe30pO1xuXG5cbmV4cG9ydHMuY3JlYXRlUmVnZXggPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG5cbiAgICBpZiAob3B0aW9ucy5zY2hlbWUgfHxcbiAgICAgICAgb3B0aW9ucy5hbGxvd1JlbGF0aXZlIHx8XG4gICAgICAgIG9wdGlvbnMucmVsYXRpdmVPbmx5IHx8XG4gICAgICAgIG9wdGlvbnMuYWxsb3dRdWVyeVNxdWFyZUJyYWNrZXRzIHx8XG4gICAgICAgIG9wdGlvbnMuZG9tYWluKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5jcmVhdGVSZWdleChvcHRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLnVyaVJlZ2V4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQXNzZXJ0ID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvYXNzZXJ0Jyk7XG5cbmNvbnN0IEFueSA9IHJlcXVpcmUoJy4vYW55Jyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLk1hcCA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcblxuICAgIHNsaWNlKCkge1xuXG4gICAgICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLk1hcCh0aGlzKTtcbiAgICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQW55LmV4dGVuZCh7XG5cbiAgICB0eXBlOiAnc3ltYm9sJyxcblxuICAgIHRlcm1zOiB7XG5cbiAgICAgICAgbWFwOiB7IGluaXQ6IG5ldyBpbnRlcm5hbHMuTWFwKCkgfVxuICAgIH0sXG5cbiAgICBjb2VyY2U6IHtcbiAgICAgICAgbWV0aG9kKHZhbHVlLCB7IHNjaGVtYSwgZXJyb3IgfSkge1xuXG4gICAgICAgICAgICBjb25zdCBsb29rdXAgPSBzY2hlbWEuJF90ZXJtcy5tYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsb29rdXApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvb2t1cDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzY2hlbWEuX2ZsYWdzLm9ubHkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZXJyb3JzOiBlcnJvcignc3ltYm9sLm1hcCcsIHsgbWFwOiBzY2hlbWEuJF90ZXJtcy5tYXAgfSkgfTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgeyBlcnJvciB9KSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBlcnJvcnM6IGVycm9yKCdzeW1ib2wuYmFzZScpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcnVsZXM6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICBtZXRob2QoaXRlcmFibGUpIHtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVyYWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgaXRlcmFibGUgPT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QuZW50cmllcyhpdGVyYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgQXNzZXJ0KGl0ZXJhYmxlICYmIGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0sICdJdGVyYWJsZSBtdXN0IGJlIGFuIGl0ZXJhYmxlIG9yIG9iamVjdCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9scyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgQXNzZXJ0KGVudHJ5ICYmIGVudHJ5W1N5bWJvbC5pdGVyYXRvcl0sICdFbnRyeSBtdXN0IGJlIGFuIGl0ZXJhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGVudHJ5O1xuXG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2Yga2V5ICE9PSAnb2JqZWN0JyAmJiB0eXBlb2Yga2V5ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBrZXkgIT09ICdzeW1ib2wnLCAnS2V5IG11c3Qgbm90IGJlIG9mIHR5cGUgb2JqZWN0LCBmdW5jdGlvbiwgb3IgU3ltYm9sJyk7XG4gICAgICAgICAgICAgICAgICAgIEFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnLCAnVmFsdWUgbXVzdCBiZSBhIFN5bWJvbCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG9iai4kX3Rlcm1zLm1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai52YWxpZCguLi5zeW1ib2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtYW5pZmVzdDoge1xuXG4gICAgICAgIGJ1aWxkKG9iaiwgZGVzYykge1xuXG4gICAgICAgICAgICBpZiAoZGVzYy5tYXApIHtcbiAgICAgICAgICAgICAgICBvYmogPSBvYmoubWFwKGRlc2MubWFwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtZXNzYWdlczoge1xuICAgICAgICAnc3ltYm9sLmJhc2UnOiAnXCJ7eyNsYWJlbH19XCIgbXVzdCBiZSBhIHN5bWJvbCcsXG4gICAgICAgICdzeW1ib2wubWFwJzogJ1wie3sjbGFiZWx9fVwiIG11c3QgYmUgb25lIG9mIHt7I21hcH19J1xuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcbmNvbnN0IENsb25lID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvY2xvbmUnKTtcbmNvbnN0IElnbm9yZSA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2lnbm9yZScpO1xuY29uc3QgUmVhY2ggPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9yZWFjaCcpO1xuXG5jb25zdCBDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFN0YXRlID0gcmVxdWlyZSgnLi9zdGF0ZScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHtcbiAgICByZXN1bHQ6IFN5bWJvbCgncmVzdWx0Jylcbn07XG5cblxuZXhwb3J0cy5lbnRyeSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBwcmVmcykge1xuXG4gICAgbGV0IHNldHRpbmdzID0gQ29tbW9uLmRlZmF1bHRzO1xuICAgIGlmIChwcmVmcykge1xuICAgICAgICBBc3NlcnQocHJlZnMud2FybmluZ3MgPT09IHVuZGVmaW5lZCwgJ0Nhbm5vdCBvdmVycmlkZSB3YXJuaW5ncyBwcmVmZXJlbmNlIGluIHN5bmNocm9ub3VzIHZhbGlkYXRpb24nKTtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBBc3NlcnQoIXJlc3VsdC5tYWluc3RheS5leHRlcm5hbHMubGVuZ3RoLCAnU2NoZW1hIHdpdGggZXh0ZXJuYWwgcnVsZXMgbXVzdCB1c2UgdmFsaWRhdGVBc3luYygpJyk7XG4gICAgY29uc3Qgb3V0Y29tZSA9IHsgdmFsdWU6IHJlc3VsdC52YWx1ZSB9O1xuXG4gICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICBvdXRjb21lLmVycm9yID0gcmVzdWx0LmVycm9yO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQubWFpbnN0YXkud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgIG91dGNvbWUud2FybmluZyA9IEVycm9ycy5kZXRhaWxzKHJlc3VsdC5tYWluc3RheS53YXJuaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5tYWluc3RheS5kZWJ1Zykge1xuICAgICAgICBvdXRjb21lLmRlYnVnID0gcmVzdWx0Lm1haW5zdGF5LmRlYnVnO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRjb21lO1xufTtcblxuXG5leHBvcnRzLmVudHJ5QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAodmFsdWUsIHNjaGVtYSwgcHJlZnMpIHtcblxuICAgIGxldCBzZXR0aW5ncyA9IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAocHJlZnMpIHtcbiAgICAgICAgc2V0dGluZ3MgPSBDb21tb24ucHJlZmVyZW5jZXMoQ29tbW9uLmRlZmF1bHRzLCBwcmVmcyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gaW50ZXJuYWxzLmVudHJ5KHZhbHVlLCBzY2hlbWEsIHNldHRpbmdzKTtcbiAgICBjb25zdCBtYWluc3RheSA9IHJlc3VsdC5tYWluc3RheTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICAgICAgcmVzdWx0LmVycm9yLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG1haW5zdGF5LmV4dGVybmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHJvb3QgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgeyBtZXRob2QsIHBhdGgsIGxhYmVsIH0gb2YgbWFpbnN0YXkuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHJvb3Q7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgbGV0IHBhcmVudDtcblxuICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IFJlYWNoKHJvb3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50W2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgbWV0aG9kKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPT09IG5vZGUpIHtcblxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFtrZXldID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gYCAoJHtsYWJlbH0pYDsgICAgICAgLy8gQ2hhbmdlIG1lc3NhZ2UgdG8gaW5jbHVkZSBwYXRoXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnZhbHVlID0gcm9vdDtcbiAgICB9XG5cbiAgICBpZiAoIXNldHRpbmdzLndhcm5pbmdzICYmXG4gICAgICAgICFzZXR0aW5ncy5kZWJ1Zykge1xuXG4gICAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0Y29tZSA9IHsgdmFsdWU6IHJlc3VsdC52YWx1ZSB9O1xuICAgIGlmIChtYWluc3RheS53YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgb3V0Y29tZS53YXJuaW5nID0gRXJyb3JzLmRldGFpbHMobWFpbnN0YXkud2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChtYWluc3RheS5kZWJ1Zykge1xuICAgICAgICBvdXRjb21lLmRlYnVnID0gbWFpbnN0YXkuZGVidWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGNvbWU7XG59O1xuXG5cbmludGVybmFscy5lbnRyeSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hLCBwcmVmcykge1xuXG4gICAgLy8gUHJlcGFyZSBzdGF0ZVxuXG4gICAgY29uc3QgeyB0cmFjZXIsIGNsZWFudXAgfSA9IGludGVybmFscy50cmFjZXIoc2NoZW1hLCBwcmVmcyk7XG4gICAgY29uc3QgZGVidWcgPSBwcmVmcy5kZWJ1ZyA/IFtdIDogbnVsbDtcbiAgICBjb25zdCBsaW5rcyA9IHNjaGVtYS5faWRzLl9zY2hlbWFDaGFpbiA/IG5ldyBNYXAoKSA6IG51bGw7XG4gICAgY29uc3QgbWFpbnN0YXkgPSB7IGV4dGVybmFsczogW10sIHdhcm5pbmdzOiBbXSwgdHJhY2VyLCBkZWJ1ZywgbGlua3MgfTtcbiAgICBjb25zdCBzY2hlbWFzID0gc2NoZW1hLl9pZHMuX3NjaGVtYUNoYWluID8gW3sgc2NoZW1hIH1dIDogbnVsbDtcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBTdGF0ZShbXSwgW10sIHsgbWFpbnN0YXksIHNjaGVtYXMgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB2YWx1ZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZXhwb3J0cy52YWxpZGF0ZSh2YWx1ZSwgc2NoZW1hLCBzdGF0ZSwgcHJlZnMpO1xuXG4gICAgLy8gUHJvY2VzcyB2YWx1ZSBhbmQgZXJyb3JzXG5cbiAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICBzY2hlbWEuJF9yb290LnVudHJhY2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IEVycm9ycy5wcm9jZXNzKHJlc3VsdC5lcnJvcnMsIHZhbHVlLCBwcmVmcyk7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdC52YWx1ZSwgZXJyb3IsIG1haW5zdGF5IH07XG59O1xuXG5cbmludGVybmFscy50cmFjZXIgPSBmdW5jdGlvbiAoc2NoZW1hLCBwcmVmcykge1xuXG4gICAgaWYgKHNjaGVtYS4kX3Jvb3QuX3RyYWNlcikge1xuICAgICAgICByZXR1cm4geyB0cmFjZXI6IHNjaGVtYS4kX3Jvb3QuX3RyYWNlci5fcmVnaXN0ZXIoc2NoZW1hKSB9O1xuICAgIH1cblxuICAgIGlmIChwcmVmcy5kZWJ1Zykge1xuICAgICAgICBBc3NlcnQoc2NoZW1hLiRfcm9vdC50cmFjZSwgJ0RlYnVnIG1vZGUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICByZXR1cm4geyB0cmFjZXI6IHNjaGVtYS4kX3Jvb3QudHJhY2UoKS5fcmVnaXN0ZXIoc2NoZW1hKSwgY2xlYW51cDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHRyYWNlcjogaW50ZXJuYWxzLmlnbm9yZSB9O1xufTtcblxuXG5leHBvcnRzLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlbWEsIHN0YXRlLCBwcmVmcywgb3ZlcnJpZGVzID0ge30pIHtcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy53aGVucykge1xuICAgICAgICBzY2hlbWEgPSBzY2hlbWEuX2dlbmVyYXRlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpLnNjaGVtYTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBzdGF0ZSBhbmQgc2V0dGluZ3NcblxuICAgIGlmIChzY2hlbWEuX3ByZWZlcmVuY2VzKSB7XG4gICAgICAgIHByZWZzID0gaW50ZXJuYWxzLnByZWZzKHNjaGVtYSwgcHJlZnMpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fY2FjaGUuZ2V0KHZhbHVlKTtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmRlYnVnKHN0YXRlLCAndmFsaWRhdGUnLCAnY2FjaGVkJywgISFyZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGVscGVyc1xuXG4gICAgY29uc3QgY3JlYXRlRXJyb3IgPSAoY29kZSwgbG9jYWwsIGxvY2FsU3RhdGUpID0+IHNjaGVtYS4kX2NyZWF0ZUVycm9yKGNvZGUsIHZhbHVlLCBsb2NhbCwgbG9jYWxTdGF0ZSB8fCBzdGF0ZSwgcHJlZnMpO1xuICAgIGNvbnN0IGhlbHBlcnMgPSB7XG4gICAgICAgIG9yaWdpbmFsOiB2YWx1ZSxcbiAgICAgICAgcHJlZnMsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGVycm9yOiBjcmVhdGVFcnJvcixcbiAgICAgICAgd2FybjogKGNvZGUsIGxvY2FsLCBsb2NhbFN0YXRlKSA9PiBzdGF0ZS5tYWluc3RheS53YXJuaW5ncy5wdXNoKGNyZWF0ZUVycm9yKGNvZGUsIGxvY2FsLCBsb2NhbFN0YXRlKSksXG4gICAgICAgIG1lc3NhZ2U6IChtZXNzYWdlcywgbG9jYWwpID0+IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdjdXN0b20nLCB2YWx1ZSwgbG9jYWwsIHN0YXRlLCBwcmVmcywgeyBtZXNzYWdlcyB9KVxuICAgIH07XG5cbiAgICAvLyBQcmVwYXJlXG5cbiAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZW50cnkoc2NoZW1hLCBzdGF0ZSk7XG5cbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX2RlZmluaXRpb247XG4gICAgaWYgKGRlZi5wcmVwYXJlICYmXG4gICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcHJlZnMuY29udmVydCkge1xuXG4gICAgICAgIGNvbnN0IHByZXBhcmVkID0gZGVmLnByZXBhcmUodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAocHJlcGFyZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3ByZXBhcmUnLCB2YWx1ZSwgcHJlcGFyZWQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkLmVycm9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUocHJlcGFyZWQudmFsdWUsIFtdLmNvbmNhdChwcmVwYXJlZC5lcnJvcnMpLCBoZWxwZXJzKTsgICAgICAgICAvLyBQcmVwYXJlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBwcmVwYXJlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFR5cGUgY29lcmNpb25cblxuICAgIGlmIChkZWYuY29lcmNlICYmXG4gICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgcHJlZnMuY29udmVydCAmJlxuICAgICAgICAoIWRlZi5jb2VyY2UuZnJvbSB8fCBkZWYuY29lcmNlLmZyb20uaW5jbHVkZXModHlwZW9mIHZhbHVlKSkpIHtcblxuICAgICAgICBjb25zdCBjb2VyY2VkID0gZGVmLmNvZXJjZS5tZXRob2QodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoY29lcmNlZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnY29lcmNlZCcsIHZhbHVlLCBjb2VyY2VkLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2VyY2VkLmVycm9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUoY29lcmNlZC52YWx1ZSwgW10uY29uY2F0KGNvZXJjZWQuZXJyb3JzKSwgaGVscGVycyk7ICAgICAgICAgICAvLyBDb2VyY2UgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IGNvZXJjZWQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbXB0eSB2YWx1ZVxuXG4gICAgY29uc3QgZW1wdHkgPSBzY2hlbWEuX2ZsYWdzLmVtcHR5O1xuICAgIGlmIChlbXB0eSAmJlxuICAgICAgICBlbXB0eS4kX21hdGNoKGludGVybmFscy50cmltKHZhbHVlLCBzY2hlbWEpLCBzdGF0ZS5uZXN0KGVtcHR5KSwgQ29tbW9uLmRlZmF1bHRzKSkge1xuXG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2VtcHR5JywgdmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFByZXNlbmNlIHJlcXVpcmVtZW50cyAocmVxdWlyZWQsIG9wdGlvbmFsLCBmb3JiaWRkZW4pXG5cbiAgICBjb25zdCBwcmVzZW5jZSA9IG92ZXJyaWRlcy5wcmVzZW5jZSB8fCBzY2hlbWEuX2ZsYWdzLnByZXNlbmNlIHx8IChzY2hlbWEuX2ZsYWdzLl9lbmRlZFN3aXRjaCA/ICdpZ25vcmUnIDogcHJlZnMucHJlc2VuY2UpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwcmVzZW5jZSA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXNlbmNlID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBbc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5yZXF1aXJlZCcsIHZhbHVlLCBudWxsLCBzdGF0ZSwgcHJlZnMpXSwgaGVscGVycyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJlc2VuY2UgPT09ICdvcHRpb25hbCcpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuX2ZsYWdzLmRlZmF1bHQgIT09IENvbW1vbi5zeW1ib2xzLmRlZXBEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgbnVsbCwgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwge30pO1xuICAgICAgICAgICAgdmFsdWUgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwcmVzZW5jZSA9PT0gJ2ZvcmJpZGRlbicpIHtcbiAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3NjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkudW5rbm93bicsIHZhbHVlLCBudWxsLCBzdGF0ZSwgcHJlZnMpXSwgaGVscGVycyk7XG4gICAgfVxuXG4gICAgLy8gQWxsb3dlZCB2YWx1ZXNcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgaWYgKHNjaGVtYS5fdmFsaWRzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc2NoZW1hLl92YWxpZHMuZ2V0KHZhbHVlLCBzdGF0ZSwgcHJlZnMsIHNjaGVtYS5fZmxhZ3MuaW5zZW5zaXRpdmUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGlmIChwcmVmcy5jb252ZXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAndmFsaWRzJywgdmFsdWUsIG1hdGNoLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1hdGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIuZmlsdGVyKHNjaGVtYSwgc3RhdGUsICd2YWxpZCcsIG1hdGNoKTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIG51bGwsIGhlbHBlcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjaGVtYS5fZmxhZ3Mub25seSkge1xuICAgICAgICAgICAgY29uc3QgcmVwb3J0ID0gc2NoZW1hLiRfY3JlYXRlRXJyb3IoJ2FueS5vbmx5JywgdmFsdWUsIHsgdmFsaWRzOiBzY2hlbWEuX3ZhbGlkcy52YWx1ZXMoeyBkaXNwbGF5OiB0cnVlIH0pIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICBpZiAocHJlZnMuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIFtyZXBvcnRdLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVwb3J0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlbmllZCB2YWx1ZXNcblxuICAgIGlmIChzY2hlbWEuX2ludmFsaWRzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc2NoZW1hLl9pbnZhbGlkcy5nZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgc2NoZW1hLl9mbGFncy5pbnNlbnNpdGl2ZSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmZpbHRlcihzY2hlbWEsIHN0YXRlLCAnaW52YWxpZCcsIG1hdGNoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcG9ydCA9IHNjaGVtYS4kX2NyZWF0ZUVycm9yKCdhbnkuaW52YWxpZCcsIHZhbHVlLCB7IGludmFsaWRzOiBzY2hlbWEuX2ludmFsaWRzLnZhbHVlcyh7IGRpc3BsYXk6IHRydWUgfSkgfSwgc3RhdGUsIHByZWZzKTtcbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgW3JlcG9ydF0sIGhlbHBlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXBvcnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmFzZSB0eXBlXG5cbiAgICBpZiAoZGVmLnZhbGlkYXRlKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBkZWYudmFsaWRhdGUodmFsdWUsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoYmFzZSkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnYmFzZScsIHZhbHVlLCBiYXNlLnZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZS52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGJhc2UuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGJhc2UuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChiYXNlLmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbHMuZmluYWxpemUodmFsdWUsIGVycm9ycywgaGVscGVycyk7ICAgICAgICAgIC8vIEJhc2UgZXJyb3IgYWx3YXlzIGFib3J0cyBlYXJseVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiYXNlLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4uYmFzZS5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpOyAgICAgICAgICAvLyBCYXNlIGVycm9yIGFsd2F5cyBhYm9ydHMgZWFybHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0ZXN0c1xuXG4gICAgaWYgKCFzY2hlbWEuX3J1bGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbHMucnVsZXModmFsdWUsIGVycm9ycywgaGVscGVycyk7XG59O1xuXG5cbmludGVybmFscy5ydWxlcyA9IGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3JzLCBoZWxwZXJzKSB7XG5cbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgZm9yIChjb25zdCBydWxlIG9mIHNjaGVtYS5fcnVsZXMpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHNjaGVtYS5fZGVmaW5pdGlvbi5ydWxlc1tydWxlLm1ldGhvZF07XG5cbiAgICAgICAgLy8gU2tpcCBydWxlcyB0aGF0IGFyZSBhbHNvIGFwcGxpZWQgaW4gY29lcmNlIHN0ZXBcblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5jb252ZXJ0ICYmXG4gICAgICAgICAgICBwcmVmcy5jb252ZXJ0KSB7XG5cbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci5sb2coc2NoZW1hLCBzdGF0ZSwgJ3J1bGUnLCBydWxlLm5hbWUsICdmdWxsJyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc29sdmUgcmVmZXJlbmNlc1xuXG4gICAgICAgIGxldCByZXQ7XG4gICAgICAgIGxldCBhcmdzID0gcnVsZS5hcmdzO1xuICAgICAgICBpZiAocnVsZS5fcmVzb2x2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFyZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBhcmdzKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hhbGxvdyBjb3B5XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBydWxlLl9yZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBkZWZpbml0aW9uLmFyZ3NCeU5hbWUuZ2V0KGtleSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IGFyZ3Nba2V5XS5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSByZXNvbHZlci5ub3JtYWxpemUgPyByZXNvbHZlci5ub3JtYWxpemUocmVzb2x2ZWQpIDogcmVzb2x2ZWQ7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkID0gQ29tbW9uLnZhbGlkYXRlQXJnKG5vcm1hbGl6ZWQsIG51bGwsIHJlc29sdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBzY2hlbWEuJF9jcmVhdGVFcnJvcignYW55LnJlZicsIHJlc29sdmVkLCB7IGFyZzoga2V5LCByZWY6IGFyZ3Nba2V5XSwgcmVhc29uOiBpbnZhbGlkIH0sIHN0YXRlLCBwcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFyZ3Nba2V5XSA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IHJ1bGVcblxuICAgICAgICByZXQgPSByZXQgfHwgZGVmaW5pdGlvbi52YWxpZGF0ZSh2YWx1ZSwgaGVscGVycywgYXJncywgcnVsZSk7ICAgICAgICAgICAvLyBVc2UgcmV0IGlmIGFscmVhZHkgc2V0IHRvIHJlZmVyZW5jZSBlcnJvclxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGludGVybmFscy5ydWxlKHJldCwgcnVsZSk7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgcnVsZS5uYW1lLCAnZXJyb3InKTtcblxuICAgICAgICAgICAgaWYgKHJ1bGUud2Fybikge1xuICAgICAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5Lndhcm5pbmdzLnB1c2goLi4ucmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmVmcy5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5maW5hbGl6ZSh2YWx1ZSwgcmVzdWx0LmVycm9ycywgaGVscGVycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLnJlc3VsdC5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLmxvZyhzY2hlbWEsIHN0YXRlLCAncnVsZScsIHJ1bGUubmFtZSwgJ3Bhc3MnKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ3J1bGUnLCB2YWx1ZSwgcmVzdWx0LnZhbHVlLCBydWxlLm5hbWUpO1xuICAgICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJuYWxzLmZpbmFsaXplKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpO1xufTtcblxuXG5pbnRlcm5hbHMucnVsZSA9IGZ1bmN0aW9uIChyZXQsIHJ1bGUpIHtcblxuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0KSB7XG4gICAgICAgIGludGVybmFscy5lcnJvcihyZXQsIHJ1bGUpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IFtyZXRdLCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHJldCkgJiZcbiAgICAgICAgKHJldFswXSBpbnN0YW5jZW9mIEVycm9ycy5SZXBvcnQgfHwgcmV0WzBdIGluc3RhbmNlb2YgRXJyb3IpKSB7XG5cbiAgICAgICAgcmV0LmZvckVhY2goKHJlcG9ydCkgPT4gaW50ZXJuYWxzLmVycm9yKHJlcG9ydCwgcnVsZSkpO1xuICAgICAgICByZXR1cm4geyBlcnJvcnM6IHJldCwgdmFsdWU6IG51bGwgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcnM6IG51bGwsIHZhbHVlOiByZXQgfTtcbn07XG5cblxuaW50ZXJuYWxzLmVycm9yID0gZnVuY3Rpb24gKHJlcG9ydCwgcnVsZSkge1xuXG4gICAgaWYgKHJ1bGUubWVzc2FnZSkge1xuICAgICAgICByZXBvcnQuX3NldFRlbXBsYXRlKHJ1bGUubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcG9ydDtcbn07XG5cblxuaW50ZXJuYWxzLmZpbmFsaXplID0gZnVuY3Rpb24gKHZhbHVlLCBlcnJvcnMsIGhlbHBlcnMpIHtcblxuICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICBjb25zdCB7IHNjaGVtYSwgc3RhdGUsIHByZWZzIH0gPSBoZWxwZXJzO1xuXG4gICAgLy8gRmFpbG92ZXIgdmFsdWVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZhaWxvdmVyID0gaW50ZXJuYWxzLmRlZmF1bHQoJ2ZhaWxvdmVyJywgdW5kZWZpbmVkLCBlcnJvcnMsIGhlbHBlcnMpO1xuICAgICAgICBpZiAoZmFpbG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCAnZmFpbG92ZXInLCB2YWx1ZSwgZmFpbG92ZXIpO1xuICAgICAgICAgICAgdmFsdWUgPSBmYWlsb3ZlcjtcbiAgICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXJyb3Igb3ZlcnJpZGVcblxuICAgIGlmIChlcnJvcnMubGVuZ3RoICYmXG4gICAgICAgIHNjaGVtYS5fZmxhZ3MuZXJyb3IpIHtcblxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5fZmxhZ3MuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IHNjaGVtYS5fZmxhZ3MuZXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gW2Vycm9yc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgQXNzZXJ0KGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcnMuUmVwb3J0LCAnZXJyb3IoKSBtdXN0IHJldHVybiBhbiBFcnJvciBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycyA9IFtzY2hlbWEuX2ZsYWdzLmVycm9yXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmF1bHRcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRlZCA9IGludGVybmFscy5kZWZhdWx0KCdkZWZhdWx0JywgdmFsdWUsIGVycm9ycywgaGVscGVycyk7XG4gICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2RlZmF1bHQnLCB2YWx1ZSwgZGVmYXVsdGVkKTtcbiAgICAgICAgdmFsdWUgPSBkZWZhdWx0ZWQ7XG4gICAgfVxuXG4gICAgLy8gQ2FzdFxuXG4gICAgaWYgKHNjaGVtYS5fZmxhZ3MuY2FzdCAmJlxuICAgICAgICB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgY29uc3QgY2FzdGVyID0gc2NoZW1hLl9kZWZpbml0aW9uLmNhc3Rbc2NoZW1hLl9mbGFncy5jYXN0XTtcbiAgICAgICAgaWYgKGNhc3Rlci5mcm9tKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgY2FzdGVkID0gY2FzdGVyLnRvKHZhbHVlLCBoZWxwZXJzKTtcbiAgICAgICAgICAgIHN0YXRlLm1haW5zdGF5LnRyYWNlci52YWx1ZShzdGF0ZSwgJ2Nhc3QnLCB2YWx1ZSwgY2FzdGVkLCBzY2hlbWEuX2ZsYWdzLmNhc3QpO1xuICAgICAgICAgICAgdmFsdWUgPSBjYXN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRlcm5hbHNcblxuICAgIGlmIChzY2hlbWEuJF90ZXJtcy5leHRlcm5hbHMgJiZcbiAgICAgICAgcHJlZnMuZXh0ZXJuYWxzICYmXG4gICAgICAgIHByZWZzLl9leHRlcm5hbHMgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlZCBmb3IgbWF0Y2hpbmdcblxuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0aG9kIH0gb2Ygc2NoZW1hLiRfdGVybXMuZXh0ZXJuYWxzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tYWluc3RheS5leHRlcm5hbHMucHVzaCh7IG1ldGhvZCwgcGF0aDogc3RhdGUucGF0aCwgbGFiZWw6IEVycm9ycy5sYWJlbChzY2hlbWEuX2ZsYWdzLCBzdGF0ZSwgcHJlZnMpIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVzdWx0XG5cbiAgICBjb25zdCByZXN1bHQgPSB7IHZhbHVlLCBlcnJvcnM6IGVycm9ycy5sZW5ndGggPyBlcnJvcnMgOiBudWxsIH07XG5cbiAgICBpZiAoc2NoZW1hLl9mbGFncy5yZXN1bHQpIHtcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gc2NoZW1hLl9mbGFncy5yZXN1bHQgPT09ICdzdHJpcCcgPyB1bmRlZmluZWQgOiAvKiByYXcgKi8gaGVscGVycy5vcmlnaW5hbDtcbiAgICAgICAgc3RhdGUubWFpbnN0YXkudHJhY2VyLnZhbHVlKHN0YXRlLCBzY2hlbWEuX2ZsYWdzLnJlc3VsdCwgdmFsdWUsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHN0YXRlLnNoYWRvdyh2YWx1ZSwgc2NoZW1hLl9mbGFncy5yZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIENhY2hlXG5cbiAgICBpZiAoc2NoZW1hLl9jYWNoZSAmJlxuICAgICAgICBwcmVmcy5jYWNoZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgIXNjaGVtYS5fcmVmcy5sZW5ndGgpIHtcblxuICAgICAgICBzY2hlbWEuX2NhY2hlLnNldChoZWxwZXJzLm9yaWdpbmFsLCByZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbmludGVybmFscy5wcmVmcyA9IGZ1bmN0aW9uIChzY2hlbWEsIHByZWZzKSB7XG5cbiAgICBjb25zdCBpc0RlZmF1bHRPcHRpb25zID0gcHJlZnMgPT09IENvbW1vbi5kZWZhdWx0cztcbiAgICBpZiAoaXNEZWZhdWx0T3B0aW9ucyAmJlxuICAgICAgICBzY2hlbWEuX3ByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXSkge1xuXG4gICAgICAgIHJldHVybiBzY2hlbWEuX3ByZWZlcmVuY2VzW0NvbW1vbi5zeW1ib2xzLnByZWZzXTtcbiAgICB9XG5cbiAgICBwcmVmcyA9IENvbW1vbi5wcmVmZXJlbmNlcyhwcmVmcywgc2NoZW1hLl9wcmVmZXJlbmNlcyk7XG4gICAgaWYgKGlzRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgc2NoZW1hLl9wcmVmZXJlbmNlc1tDb21tb24uc3ltYm9scy5wcmVmc10gPSBwcmVmcztcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZnM7XG59O1xuXG5cbmludGVybmFscy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZsYWcsIHZhbHVlLCBlcnJvcnMsIHsgc2NoZW1hLCBzdGF0ZSwgcHJlZnMgfSkge1xuXG4gICAgY29uc3Qgc291cmNlID0gc2NoZW1hLl9mbGFnc1tmbGFnXTtcbiAgICBpZiAocHJlZnMubm9EZWZhdWx0cyB8fFxuICAgICAgICBzb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tYWluc3RheS50cmFjZXIubG9nKHNjaGVtYSwgc3RhdGUsICdydWxlJywgZmxhZywgJ2Z1bGwnKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHNvdXJjZS5sZW5ndGggPiAwID8gW0Nsb25lKHN0YXRlLmFuY2VzdG9yc1swXSksIHByZWZzXSA6IFtdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHNjaGVtYS4kX2NyZWF0ZUVycm9yKGBhbnkuJHtmbGFnfWAsIG51bGwsIHsgZXJyb3I6IGVyciB9LCBzdGF0ZSwgcHJlZnMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VbQ29tbW9uLnN5bWJvbHMubGl0ZXJhbF0pIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5saXRlcmFsO1xuICAgIH1cblxuICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5yZXNvbHZlKHZhbHVlLCBzdGF0ZSwgcHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiBDbG9uZShzb3VyY2UpO1xufTtcblxuXG5pbnRlcm5hbHMudHJpbSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZW1hKSB7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgdHJpbSA9IHNjaGVtYS4kX2dldFJ1bGUoJ3RyaW0nKTtcbiAgICBpZiAoIXRyaW0gfHxcbiAgICAgICAgIXRyaW0uYXJncy5lbmFibGVkKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG59O1xuXG5cbmludGVybmFscy5pZ25vcmUgPSB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkZWJ1ZzogSWdub3JlLFxuICAgIGVudHJ5OiBJZ25vcmUsXG4gICAgZmlsdGVyOiBJZ25vcmUsXG4gICAgbG9nOiBJZ25vcmUsXG4gICAgcmVzb2x2ZTogSWdub3JlLFxuICAgIHZhbHVlOiBJZ25vcmVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFzc2VydCA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsvbGliL2Fzc2VydCcpO1xuY29uc3QgRGVlcEVxdWFsID0gcmVxdWlyZSgnQGhhcGkvaG9lay9saWIvZGVlcEVxdWFsJyk7XG5cbmNvbnN0IENvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuVmFsdWVzID0gY2xhc3Mge1xuXG4gICAgY29uc3RydWN0b3IodmFsdWVzLCByZWZzKSB7XG5cbiAgICAgICAgdGhpcy5fdmFsdWVzID0gbmV3IFNldCh2YWx1ZXMpO1xuICAgICAgICB0aGlzLl9yZWZzID0gbmV3IFNldChyZWZzKTtcbiAgICAgICAgdGhpcy5fbG93ZXJjYXNlID0gaW50ZXJuYWxzLmxvd2VyY2FzZXModmFsdWVzKTtcblxuICAgICAgICB0aGlzLl9vdmVycmlkZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBsZW5ndGgoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5zaXplICsgdGhpcy5fcmVmcy5zaXplO1xuICAgIH1cblxuICAgIGFkZCh2YWx1ZSwgcmVmcykge1xuXG4gICAgICAgIC8vIFJlZmVyZW5jZVxuXG4gICAgICAgIGlmIChDb21tb24uaXNSZXNvbHZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWZzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZzLmFkZCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmcykgeyAgICAgICAgICAgICAgICAgICAgIC8vIFNraXBwZWQgaW4gYSBtZXJnZVxuICAgICAgICAgICAgICAgICAgICByZWZzLnJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFZhbHVlXG5cbiAgICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSwgbnVsbCwgbnVsbCwgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZXMuYWRkKHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb3dlcmNhc2Uuc2V0KHZhbHVlLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgcmVtb3ZlKSB7XG5cbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBpbnRlcm5hbHMuVmFsdWVzKCk7XG5cbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZS5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLmNsb25lKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4uc291cmNlLl92YWx1ZXMsIC4uLnNvdXJjZS5fcmVmc10pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFsuLi5yZW1vdmUuX3ZhbHVlcywgLi4ucmVtb3ZlLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Lmxlbmd0aCA/IHRhcmdldCA6IG51bGw7XG4gICAgfVxuXG4gICAgcmVtb3ZlKHZhbHVlKSB7XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlXG5cbiAgICAgICAgaWYgKENvbW1vbi5pc1Jlc29sdmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZWZzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWx1ZVxuXG4gICAgICAgIHRoaXMuX3ZhbHVlcy5kZWxldGUodmFsdWUpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9sb3dlcmNhc2UuZGVsZXRlKHZhbHVlLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzKHZhbHVlLCBzdGF0ZSwgcHJlZnMsIGluc2Vuc2l0aXZlKSB7XG5cbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXQodmFsdWUsIHN0YXRlLCBwcmVmcywgaW5zZW5zaXRpdmUpO1xuICAgIH1cblxuICAgIGdldCh2YWx1ZSwgc3RhdGUsIHByZWZzLCBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbXBsZSBtYXRjaFxuXG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2UgaW5zZW5zaXRpdmUgc3RyaW5nIG1hdGNoXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIHZhbHVlICYmXG4gICAgICAgICAgICBpbnNlbnNpdGl2ZSkge1xuXG4gICAgICAgICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX2xvd2VyY2FzZS5nZXQodmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogZm91bmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVmcy5zaXplICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdHNcblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChEZWVwRXF1YWwoaXRlbSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmZXJlbmNlc1xuXG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgdGhpcy5fcmVmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVmLnJlc29sdmUodmFsdWUsIHN0YXRlLCBwcmVmcywgbnVsbCwgeyBpbjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9ICFyZWYuaW4gfHwgdHlwZW9mIHJlc29sdmVkICE9PSAnb2JqZWN0J1xuICAgICAgICAgICAgICAgICAgICA/IFtyZXNvbHZlZF1cbiAgICAgICAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KHJlc29sdmVkKSA/IHJlc29sdmVkIDogT2JqZWN0LmtleXMocmVzb2x2ZWQpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnNlbnNpdGl2ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCByZWYgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChEZWVwRXF1YWwoaXRlbSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0sIHJlZiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG92ZXJyaWRlKCkge1xuXG4gICAgICAgIHRoaXMuX292ZXJyaWRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YWx1ZXMob3B0aW9ucykge1xuXG4gICAgICAgIGlmIChvcHRpb25zICYmXG4gICAgICAgICAgICBvcHRpb25zLmRpc3BsYXkpIHtcblxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBbLi4udGhpcy5fdmFsdWVzLCAuLi50aGlzLl9yZWZzXSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oWy4uLnRoaXMuX3ZhbHVlcywgLi4udGhpcy5fcmVmc10pO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBpbnRlcm5hbHMuVmFsdWVzKHRoaXMuX3ZhbHVlcywgdGhpcy5fcmVmcyk7XG4gICAgICAgIHNldC5fb3ZlcnJpZGUgPSB0aGlzLl9vdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG5cbiAgICBjb25jYXQoc291cmNlKSB7XG5cbiAgICAgICAgQXNzZXJ0KCFzb3VyY2UuX292ZXJyaWRlLCAnQ2Fubm90IGNvbmNhdCBvdmVycmlkZSBzZXQgb2YgdmFsdWVzJyk7XG5cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IGludGVybmFscy5WYWx1ZXMoWy4uLnRoaXMuX3ZhbHVlcywgLi4uc291cmNlLl92YWx1ZXNdLCBbLi4udGhpcy5fcmVmcywgLi4uc291cmNlLl9yZWZzXSk7XG4gICAgICAgIHNldC5fb3ZlcnJpZGUgPSB0aGlzLl9vdmVycmlkZTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG5cbiAgICBkZXNjcmliZSgpIHtcblxuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2goeyBvdmVycmlkZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fdmFsdWVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnB1c2godmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IHsgdmFsdWUgfSA6IHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fcmVmcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKHZhbHVlLmRlc2NyaWJlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuVmFsdWVzLnByb3RvdHlwZVtDb21tb24uc3ltYm9scy52YWx1ZXNdID0gdHJ1ZTtcblxuXG4vLyBBbGlhc2VzXG5cbmludGVybmFscy5WYWx1ZXMucHJvdG90eXBlLnNsaWNlID0gaW50ZXJuYWxzLlZhbHVlcy5wcm90b3R5cGUuY2xvbmU7XG5cblxuLy8gSGVscGVyc1xuXG5pbnRlcm5hbHMubG93ZXJjYXNlcyA9IGZ1bmN0aW9uIChmcm9tKSB7XG5cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG5cbiAgICBpZiAoZnJvbSkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGZyb20pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldCh2YWx1ZS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IE1pbWVEYiA9IHJlcXVpcmUoJ21pbWUtZGIvZGIuanNvbicpOyAgICAgICAgICAvLyBMb2FkIEpTT04gZmlsZSB0byBwcmV2ZW50IGxvYWRpbmcgb3IgZXhlY3V0aW5nIGNvZGVcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuY29tcHJlc3NpYmxlUnggPSAvXnRleHRcXC98XFwranNvbiR8XFwrdGV4dCR8XFwreG1sJC87XG5cblxuaW50ZXJuYWxzLmNvbXBpbGUgPSBmdW5jdGlvbiAob3ZlcnJpZGUpIHtcblxuICAgIGNvbnN0IGRiID0gSG9lay5jbG9uZShNaW1lRGIpO1xuICAgIEhvZWsubWVyZ2UoZGIsIG92ZXJyaWRlLCB7IG51bGxPdmVycmlkZTogdHJ1ZSwgbWVyZ2VBcnJheXM6IGZhbHNlIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBieVR5cGU6IGRiLFxuICAgICAgICBieUV4dGVuc2lvbjoge31cbiAgICB9O1xuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlc3VsdC5ieVR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB0eXBlID0ga2V5c1tpXTtcbiAgICAgICAgY29uc3QgbWltZSA9IHJlc3VsdC5ieVR5cGVbdHlwZV07XG4gICAgICAgIG1pbWUudHlwZSA9IG1pbWUudHlwZSB8fCB0eXBlO1xuICAgICAgICBtaW1lLnNvdXJjZSA9IG1pbWUuc291cmNlIHx8ICdtaW1lLWRiJztcbiAgICAgICAgbWltZS5leHRlbnNpb25zID0gbWltZS5leHRlbnNpb25zIHx8IFtdO1xuICAgICAgICBtaW1lLmNvbXByZXNzaWJsZSA9IChtaW1lLmNvbXByZXNzaWJsZSAhPT0gdW5kZWZpbmVkID8gbWltZS5jb21wcmVzc2libGUgOiBpbnRlcm5hbHMuY29tcHJlc3NpYmxlUngudGVzdCh0eXBlKSk7XG5cbiAgICAgICAgSG9lay5hc3NlcnQoIW1pbWUucHJlZGljYXRlIHx8IHR5cGVvZiBtaW1lLnByZWRpY2F0ZSA9PT0gJ2Z1bmN0aW9uJywgJ3ByZWRpY2F0ZSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtaW1lLmV4dGVuc2lvbnMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IG1pbWUuZXh0ZW5zaW9uc1tqXTtcbiAgICAgICAgICAgIHJlc3VsdC5ieUV4dGVuc2lvbltleHRdID0gbWltZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgTWltb3Mge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9ucy5vdmVycmlkZSA/IGludGVybmFscy5jb21waWxlKG9wdGlvbnMub3ZlcnJpZGUpIDogaW50ZXJuYWxzLmJhc2U7XG4gICAgICAgIHRoaXMuX2J5VHlwZSA9IHJlc3VsdC5ieVR5cGU7XG4gICAgICAgIHRoaXMuX2J5RXh0ZW5zaW9uID0gcmVzdWx0LmJ5RXh0ZW5zaW9uO1xuICAgIH1cblxuICAgIHBhdGgocGF0aCkge1xuXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IFBhdGguZXh0bmFtZShwYXRoKS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtaW1lID0gdGhpcy5fYnlFeHRlbnNpb25bZXh0ZW5zaW9uXSB8fCB7fTtcblxuICAgICAgICBpZiAobWltZS5wcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW1lLnByZWRpY2F0ZShIb2VrLmNsb25lKG1pbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtaW1lO1xuICAgIH1cblxuICAgIHR5cGUodHlwZSkge1xuXG4gICAgICAgIHR5cGUgPSB0eXBlLnNwbGl0KCc7JywgMSlbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxldCBtaW1lID0gdGhpcy5fYnlUeXBlW3R5cGVdO1xuICAgICAgICBpZiAoIW1pbWUpIHtcbiAgICAgICAgICAgIG1pbWUgPSB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICdtaW1vcycsXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uczogW10sXG4gICAgICAgICAgICAgICAgY29tcHJlc3NpYmxlOiBpbnRlcm5hbHMuY29tcHJlc3NpYmxlUngudGVzdCh0eXBlKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fYnlUeXBlW3R5cGVdID0gbWltZTtcbiAgICAgICAgICAgIHJldHVybiBtaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbWUucHJlZGljYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWltZS5wcmVkaWNhdGUoSG9lay5jbG9uZShtaW1lKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWltZTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5iYXNlID0gaW50ZXJuYWxzLmNvbXBpbGUoKTsgICAgICAgLy8gUHJldmVudHMgYW4gZXhwZW5zaXZlIGNvcHkgb24gZWFjaCBjb25zdHJ1Y3RvciB3aGVuIG5vIGN1c3RvbWl6YXRpb24gaXMgbmVlZGVkXG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgVmlzZSA9IHJlcXVpcmUoJ0BoYXBpL3Zpc2UnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbiAobmVlZGxlKSB7XG5cbiAgICBIb2VrLmFzc2VydChuZWVkbGUgJiYgbmVlZGxlLmxlbmd0aCwgJ01pc3NpbmcgbmVlZGxlJyk7XG4gICAgSG9lay5hc3NlcnQoQnVmZmVyLmlzQnVmZmVyKG5lZWRsZSksICdOZWVkbGUgbXVzdCBiZSBhIGJ1ZmZlcicpO1xuXG4gICAgY29uc3QgcHJvZmlsZSA9IHtcbiAgICAgICAgdmFsdWU6IG5lZWRsZSxcbiAgICAgICAgbGFzdFBvczogbmVlZGxlLmxlbmd0aCAtIDEsXG4gICAgICAgIGxhc3Q6IG5lZWRsZVtuZWVkbGUubGVuZ3RoIC0gMV0sXG4gICAgICAgIGxlbmd0aDogbmVlZGxlLmxlbmd0aCxcbiAgICAgICAgYmFkQ2hhclNoaWZ0OiBCdWZmZXIuYWxsb2MoMjU2KSAgICAgICAgICAgICAgICAgIC8vIExvb2t1cCB0YWJsZSBvZiBob3cgbWFueSBjaGFyYWN0ZXJzIGNhbiBiZSBza2lwcGVkIGZvciBlYWNoIG1hdGNoXG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgICAgICAgcHJvZmlsZS5iYWRDaGFyU2hpZnRbaV0gPSBwcm9maWxlLmxlbmd0aDsgICAgICAgLy8gRGVmYXVsdHMgdG8gdGhlIGZ1bGwgbGVuZ3RoIG9mIHRoZSBuZWVkbGVcbiAgICB9XG5cbiAgICBjb25zdCBsYXN0ID0gcHJvZmlsZS5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdDsgKytpKSB7ICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIG5lZWRsZSAoc2tpcCBsYXN0IHNpbmNlIGl0cyBwb3NpdGlvbiBpcyBhbHJlYWR5IHRoZSBkZWZhdWx0KVxuICAgICAgICBwcm9maWxlLmJhZENoYXJTaGlmdFtwcm9maWxlLnZhbHVlW2ldXSA9IGxhc3QgLSBpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9maWxlO1xufTtcblxuXG5leHBvcnRzLmhvcnNwb29sID0gZnVuY3Rpb24gKGhheXN0YWNrLCBuZWVkbGUsIHN0YXJ0KSB7XG5cbiAgICBIb2VrLmFzc2VydChoYXlzdGFjaywgJ01pc3NpbmcgaGF5c3RhY2snKTtcblxuICAgIG5lZWRsZSA9IChuZWVkbGUuYmFkQ2hhclNoaWZ0ID8gbmVlZGxlIDogZXhwb3J0cy5jb21waWxlKG5lZWRsZSkpO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8PSBoYXlzdGFjay5sZW5ndGggLSBuZWVkbGUubGVuZ3RoOykgeyAgICAgICAvLyBIYXMgZW5vdWdoIHJvb20gdG8gZml0IHRoZSBlbnRpcmUgbmVlZGxlXG4gICAgICAgIGNvbnN0IGxhc3RDaGFyID0gaGF5c3RhY2sucmVhZFVJbnQ4KGkgKyBuZWVkbGUubGFzdFBvcyk7XG4gICAgICAgIGlmIChsYXN0Q2hhciA9PT0gbmVlZGxlLmxhc3QgJiZcbiAgICAgICAgICAgIGludGVybmFscy5zdGFydHNXaXRoKGhheXN0YWNrLCBuZWVkbGUsIGkpKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSBuZWVkbGUuYmFkQ2hhclNoaWZ0W2xhc3RDaGFyXTsgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG5leHQgcG9zc2libGUgcG9zaXRpb24gYmFzZWQgb24gbGFzdCBjaGFyYWN0ZXIgbG9jYXRpb24gaW4gbmVlZGxlXG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcblxuXG5pbnRlcm5hbHMuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChoYXlzdGFjaywgbmVlZGxlLCBwb3MpIHtcblxuICAgIGlmIChoYXlzdGFjay5zdGFydHNXaXRoKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjay5zdGFydHNXaXRoKG5lZWRsZS52YWx1ZSwgcG9zLCBuZWVkbGUubGFzdFBvcyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZWVkbGUubGFzdFBvczsgKytpKSB7XG4gICAgICAgIGlmIChuZWVkbGUudmFsdWVbaV0gIT09IGhheXN0YWNrLnJlYWRVSW50OChwb3MgKyBpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5cbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24gKGhheXN0YWNrLCBuZWVkbGUsIHN0YXJ0KSB7XG5cbiAgICBuZWVkbGUgPSBleHBvcnRzLmNvbXBpbGUobmVlZGxlKTtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpICE9PSAtMSAmJiBpIDwgaGF5c3RhY2subGVuZ3RoOykge1xuXG4gICAgICAgIGkgPSBleHBvcnRzLmhvcnNwb29sKGhheXN0YWNrLCBuZWVkbGUsIGkpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChpKTtcbiAgICAgICAgICAgIGkgKz0gbmVlZGxlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xufTtcblxuXG5pbnRlcm5hbHMuX2luZGV4T2YgPSBmdW5jdGlvbiAoaGF5c3RhY2ssIG5lZWRsZSkge1xuXG4gICAgSG9lay5hc3NlcnQoaGF5c3RhY2ssICdNaXNzaW5nIGhheXN0YWNrJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBoYXlzdGFjay5sZW5ndGggLSBuZWVkbGUubGVuZ3RoOyArK2kpIHsgICAgICAgLy8gSGFzIGVub3VnaCByb29tIHRvIGZpdCB0aGUgZW50aXJlIG5lZWRsZVxuICAgICAgICBpZiAoaGF5c3RhY2suc3RhcnRzV2l0aChuZWVkbGUudmFsdWUsIGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG5cblxuZXhwb3J0cy5TdHJlYW0gPSBpbnRlcm5hbHMuU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW0uV3JpdGFibGUge1xuXG4gICAgY29uc3RydWN0b3IobmVlZGxlKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLm5lZWRsZShuZWVkbGUpO1xuICAgICAgICB0aGlzLl9oYXlzdGFjayA9IG5ldyBWaXNlKCk7XG4gICAgICAgIHRoaXMuX2luZGV4T2YgPSB0aGlzLl9uZWVkbGUubGVuZ3RoID4gMiA/IGV4cG9ydHMuaG9yc3Bvb2wgOiBpbnRlcm5hbHMuX2luZGV4T2Y7XG5cbiAgICAgICAgdGhpcy5vbignZmluaXNoJywgKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBGbHVzaCBvdXQgdGhlIHJlbWFpbmRlclxuXG4gICAgICAgICAgICBjb25zdCBjaHVua3MgPSB0aGlzLl9oYXlzdGFjay5jaHVua3MoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdoYXlzdGFjaycsIGNodW5rc1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmVtaXQoJ2Nsb3NlJykpOyAgICAgLy8gR2l2ZSBwZW5kaW5nIGV2ZW50cyBhIGNoYW5jZSB0byBmaXJlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5lZWRsZShuZWVkbGUpIHtcblxuICAgICAgICB0aGlzLl9uZWVkbGUgPSBleHBvcnRzLmNvbXBpbGUobmVlZGxlKTtcbiAgICB9XG5cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBuZXh0KSB7XG5cbiAgICAgICAgdGhpcy5faGF5c3RhY2sucHVzaChjaHVuayk7XG5cbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5faW5kZXhPZih0aGlzLl9oYXlzdGFjaywgdGhpcy5fbmVlZGxlKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSAtMSAmJlxuICAgICAgICAgICAgY2h1bmsubGVuZ3RoID49IHRoaXMuX25lZWRsZS5sZW5ndGgpIHtcblxuICAgICAgICAgICAgdGhpcy5fZmx1c2godGhpcy5faGF5c3RhY2subGVuZ3RoIC0gY2h1bmsubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChtYXRjaCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoKG1hdGNoKTtcbiAgICAgICAgICAgIHRoaXMuX2hheXN0YWNrLnNoaWZ0KHRoaXMuX25lZWRsZS5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCduZWVkbGUnKTtcblxuICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLl9pbmRleE9mKHRoaXMuX2hheXN0YWNrLCB0aGlzLl9uZWVkbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hheXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgbm90Q2hlY2tlZCA9IHRoaXMuX2hheXN0YWNrLmxlbmd0aCAtIHRoaXMuX25lZWRsZS5sZW5ndGggKyAxOyAgICAgICAvLyBOb3QgZW5vdWdoIHNwYWNlIGZvciBIb3JzcG9vbFxuICAgICAgICAgICAgbGV0IGkgPSBub3RDaGVja2VkO1xuICAgICAgICAgICAgZm9yICg7IGkgPCB0aGlzLl9oYXlzdGFjay5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYXlzdGFjay5zdGFydHNXaXRoKHRoaXMuX25lZWRsZS52YWx1ZSwgaSwgdGhpcy5faGF5c3RhY2subGVuZ3RoIC0gaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9mbHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuXG4gICAgX2ZsdXNoKHBvcykge1xuXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IHRoaXMuX2hheXN0YWNrLnNoaWZ0KHBvcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2hheXN0YWNrJywgY2h1bmtzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoKCkge1xuXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IHRoaXMuX2hheXN0YWNrLnNoaWZ0KHRoaXMuX2hheXN0YWNrLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2hheXN0YWNrJywgY2h1bmtzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5jb25zdCBCNjQgPSByZXF1aXJlKCdAaGFwaS9iNjQnKTtcbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5jb25zdCBDb250ZW50ID0gcmVxdWlyZSgnQGhhcGkvY29udGVudCcpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IE5pZ2VsID0gcmVxdWlyZSgnQGhhcGkvbmlnZWwnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG4vKlxuICAgIFJGQyAyMDQ2IChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMDQ2KVxuXG4gICAgbXVsdGlwYXJ0LWJvZHkgPSBbcHJlYW1ibGUgQ1JMRl1cbiAgICAgICAgICAgICAgICAgICAgZGFzaC1ib3VuZGFyeSAqKCBTUEFDRSAvIEhUQUIgKSBDUkxGIGJvZHktcGFydFxuICAgICAgICAgICAgICAgICAgICAqKCBDUkxGIGRhc2gtYm91bmRhcnkgKiggU1BBQ0UgLyBIVEFCICkgQ1JMRiBib2R5LXBhcnQgKVxuICAgICAgICAgICAgICAgICAgICBDUkxGIGRhc2gtYm91bmRhcnkgXCItLVwiICooIFNQQUNFIC8gSFRBQiApXG4gICAgICAgICAgICAgICAgICAgIFtDUkxGIGVwaWxvZ3VlXVxuXG4gICAgYm91bmRhcnkgICAgICAgPSAwKjY5PGJjaGFycz4gYmNoYXJzbm9zcGFjZVxuICAgIGJjaGFycyAgICAgICAgID0gYmNoYXJzbm9zcGFjZSAvIFwiIFwiXG4gICAgYmNoYXJzbm9zcGFjZSAgPSBESUdJVCAvIEFMUEhBIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiIC8gXCIrXCIgLyBcIl9cIiAvIFwiLFwiIC8gXCItXCIgLyBcIi5cIiAvIFwiL1wiIC8gXCI6XCIgLyBcIj1cIiAvIFwiP1wiXG4gICAgZGFzaC1ib3VuZGFyeSAgPSBcIi0tXCIgYm91bmRhcnlcblxuICAgIHByZWFtYmxlICAgICAgID0gZGlzY2FyZC10ZXh0XG4gICAgZXBpbG9ndWUgICAgICAgPSBkaXNjYXJkLXRleHRcbiAgICBkaXNjYXJkLXRleHQgICA9ICooKnRleHQgQ1JMRikgKnRleHRcblxuICAgIGJvZHktcGFydCAgICAgID0gTUlNRS1wYXJ0LWhlYWRlcnMgW0NSTEYgKk9DVEVUXVxuICAgIE9DVEVUICAgICAgICAgID0gPGFueSAwLTI1NSBvY3RldCB2YWx1ZT5cblxuICAgIFNQQUNFICAgICAgICAgID0gMzJcbiAgICBIVEFCICAgICAgICAgICA9IDlcbiAgICBDUkxGICAgICAgICAgICA9IDEzIDEwXG4qL1xuXG5cbmludGVybmFscy5zdGF0ZSA9IHtcbiAgICBwcmVhbWJsZTogMCwgICAgICAgICAgICAgICAgLy8gVW50aWwgdGhlIGZpcnN0IGJvdW5kYXJ5IGlzIHJlY2VpdmVkXG4gICAgYm91bmRhcnk6IDEsICAgICAgICAgICAgICAgIC8vIEFmdGVyIGEgYm91bmRhcnksIHdhaXRpbmcgZm9yIGZpcnN0IGxpbmUgd2l0aCBvcHRpb25hbCBsaW5lYXItd2hpdGVzcGFjZVxuICAgIGhlYWRlcjogMiwgICAgICAgICAgICAgICAgICAvLyBSZWNlaXZpbmcgcGFydCBoZWFkZXJzXG4gICAgcGF5bG9hZDogMywgICAgICAgICAgICAgICAgIC8vIFJlY2VpdmluZyBwYXJ0IHBheWxvYWRcbiAgICBlcGlsb2d1ZTogNFxufTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdHMgPSB7XG4gICAgbWF4Qnl0ZXM6IEluZmluaXR5XG59O1xuXG5cbmV4cG9ydHMuRGlzcGVuc2VyID0gaW50ZXJuYWxzLkRpc3BlbnNlciA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtLldyaXRhYmxlIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblxuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5fYm91bmRhcnkgPSBzZXR0aW5ncy5ib3VuZGFyeTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBpbnRlcm5hbHMuc3RhdGUucHJlYW1ibGU7XG4gICAgICAgIHRoaXMuX2hlbGQgPSAnJztcblxuICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLl9oZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMuX25hbWUgPSAnJztcbiAgICAgICAgdGhpcy5fcGVuZGluZ0hlYWRlciA9ICcnO1xuICAgICAgICB0aGlzLl9lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2J5dGVzID0gMDtcbiAgICAgICAgdGhpcy5fbWF4Qnl0ZXMgPSBzZXR0aW5ncy5tYXhCeXRlcztcblxuICAgICAgICB0aGlzLl9wYXJ0cyA9IG5ldyBOaWdlbC5TdHJlYW0oQnVmZmVyLmZyb20oJy0tJyArIHNldHRpbmdzLmJvdW5kYXJ5KSk7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gbmV3IE5pZ2VsLlN0cmVhbShCdWZmZXIuZnJvbSgnXFxyXFxuJykpO1xuXG4gICAgICAgIHRoaXMuX3BhcnRzLm9uKCduZWVkbGUnLCAoKSA9PiB0aGlzLl9vblBhcnRFbmQoKSk7XG4gICAgICAgIHRoaXMuX3BhcnRzLm9uKCdoYXlzdGFjaycsIChjaHVuaykgPT4gdGhpcy5fb25QYXJ0KGNodW5rKSk7XG4gICAgICAgIHRoaXMuX2xpbmVzLm9uKCduZWVkbGUnLCAoKSA9PiB0aGlzLl9vbkxpbmVFbmQoKSk7XG4gICAgICAgIHRoaXMuX2xpbmVzLm9uKCdoYXlzdGFjaycsIChjaHVuaykgPT4gdGhpcy5fb25MaW5lKGNodW5rKSk7XG4gICAgICAgIHRoaXMub25jZSgnZmluaXNoJywgKCkgPT4gdGhpcy5fcGFydHMuZW5kKCkpO1xuICAgICAgICB0aGlzLl9wYXJ0cy5vbmNlKCdjbG9zZScsICgpID0+IHRoaXMuX2xpbmVzLmVuZCgpKTtcblxuICAgICAgICBsZXQgcGlwZXIgPSBudWxsO1xuICAgICAgICBsZXQgZmluaXNoID0gKGVycikgPT4ge1xuXG4gICAgICAgICAgICBpZiAocGlwZXIpIHtcbiAgICAgICAgICAgICAgICBwaXBlci5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uUmVxRGF0YSk7XG4gICAgICAgICAgICAgICAgcGlwZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZmluaXNoKTtcbiAgICAgICAgICAgICAgICBwaXBlci5yZW1vdmVMaXN0ZW5lcignYWJvcnRlZCcsIG9uUmVxQWJvcnRlZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnQoZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmaW5pc2ggPSBIb2VrLm9uY2UoZmluaXNoKTtcblxuICAgICAgICB0aGlzLl9saW5lcy5vbmNlKCdjbG9zZScsICgpID0+IHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBpbnRlcm5hbHMuc3RhdGUuZXBpbG9ndWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGVsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdlcGlsb2d1ZScsIHRoaXMuX2hlbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oZWxkID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IGludGVybmFscy5zdGF0ZS5ib3VuZGFyeSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGVsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydChCb29tLmJhZFJlcXVlc3QoJ01pc3NpbmcgZW5kIGJvdW5kYXJ5JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9oZWxkICE9PSAnLS0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fib3J0KEJvb20uYmFkUmVxdWVzdCgnT25seSB3aGl0ZSBzcGFjZSBhbGxvd2VkIGFmdGVyIGJvdW5kYXJ5IGF0IGVuZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydChCb29tLmJhZFJlcXVlc3QoJ0luY29tcGxldGUgbXVsdGlwYXJ0IHBheWxvYWQnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShmaW5pc2gpOyAgICAgICAgICAgICAgICAgIC8vIEdpdmUgcGVuZGluZyBldmVudHMgYSBjaGFuY2UgdG8gZmlyZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBvblJlcUFib3J0ZWQgPSAoKSA9PiB7XG5cbiAgICAgICAgICAgIGZpbmlzaChCb29tLmJhZFJlcXVlc3QoJ0NsaWVudCByZXF1ZXN0IGFib3J0ZWQnKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb25SZXFEYXRhID0gKGRhdGEpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5fYnl0ZXMgKz0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9ieXRlcyA+IHRoaXMuX21heEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoKEJvb20uZW50aXR5VG9vTGFyZ2UoJ01heGltdW0gc2l6ZSBleGNlZWRlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9uY2UoJ3BpcGUnLCAocmVxKSA9PiB7XG5cbiAgICAgICAgICAgIHBpcGVyID0gcmVxO1xuICAgICAgICAgICAgcmVxLm9uKCdkYXRhJywgb25SZXFEYXRhKTtcbiAgICAgICAgICAgIHJlcS5vbmNlKCdlcnJvcicsIGZpbmlzaCk7XG4gICAgICAgICAgICByZXEub25jZSgnYWJvcnRlZCcsIG9uUmVxQWJvcnRlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkRpc3BlbnNlci5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgZW5jb2RpbmcsIG5leHQpIHtcblxuICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhcnRzLndyaXRlKGJ1ZmZlcik7XG4gICAgcmV0dXJuIG5leHQoKTtcbn07XG5cblxuaW50ZXJuYWxzLkRpc3BlbnNlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuXG4gICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoLi4uYXJncyk7XG59O1xuXG5cbmludGVybmFscy5EaXNwZW5zZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uIChlcnIpIHtcblxuICAgIHRoaXMuX2VtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB0aGlzLl9lcnJvciA9IGVycjtcbn07XG5cblxuaW50ZXJuYWxzLkRpc3BlbnNlci5wcm90b3R5cGUuX29uUGFydEVuZCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuX2xpbmVzLmZsdXNoKCk7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IGludGVybmFscy5zdGF0ZS5wcmVhbWJsZSkge1xuICAgICAgICBpZiAodGhpcy5faGVsZCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMuX2hlbGQubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlbGRbbGFzdF0gIT09ICdcXG4nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5faGVsZFtsYXN0IC0gMV0gIT09ICdcXHInKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnQoQm9vbS5iYWRSZXF1ZXN0KCdQcmVhbWJsZSBtaXNzaW5nIENSTEYgdGVybWluYXRvcicpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZW1pdCgncHJlYW1ibGUnLCB0aGlzLl9oZWxkLnNsaWNlKDAsIC0yKSk7XG4gICAgICAgICAgICB0aGlzLl9oZWxkID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXJ0cy5uZWVkbGUoQnVmZmVyLmZyb20oJ1xcclxcbi0tJyArIHRoaXMuX2JvdW5kYXJ5KSk7ICAgICAgICAgICAgICAgICAgICAgIC8vIENSTEYgbm8gbG9uZ2VyIG9wdGlvbmFsXG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBpbnRlcm5hbHMuc3RhdGUuYm91bmRhcnk7XG5cbiAgICBpZiAodGhpcy5fc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5lbmQoKTtcbiAgICAgICAgdGhpcy5fc3RyZWFtID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fbmFtZSkge1xuICAgICAgICB0aGlzLl9lbWl0KCdmaWVsZCcsIHRoaXMuX25hbWUsIHRoaXMuX2hlbGQpO1xuICAgICAgICB0aGlzLl9uYW1lID0gJyc7XG4gICAgICAgIHRoaXMuX2hlbGQgPSAnJztcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5EaXNwZW5zZXIucHJvdG90eXBlLl9vblBhcnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcblxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gaW50ZXJuYWxzLnN0YXRlLnByZWFtYmxlKSB7XG4gICAgICAgIHRoaXMuX2hlbGQgPSB0aGlzLl9oZWxkICsgY2h1bmsudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IGludGVybmFscy5zdGF0ZS5wYXlsb2FkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cmVhbS53cml0ZShjaHVuayk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmVhbSBwYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oZWxkID0gdGhpcy5faGVsZCArIGNodW5rLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2xpbmVzLndyaXRlKGNodW5rKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYm91bmRhcnlcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5EaXNwZW5zZXIucHJvdG90eXBlLl9vbkxpbmVFbmQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBCb3VuZGFyeSB3aGl0ZXNwYWNlXG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IGludGVybmFscy5zdGF0ZS5ib3VuZGFyeSkge1xuICAgICAgICBpZiAodGhpcy5faGVsZCkge1xuICAgICAgICAgICAgdGhpcy5faGVsZCA9IHRoaXMuX2hlbGQucmVwbGFjZSgvW1xcdCBdL2csICcnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyaW0oKSByZW1vdmVzIG5ldyBsaW5lc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hlbGQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGVsZCA9PT0gJy0tJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IGludGVybmFscy5zdGF0ZS5lcGlsb2d1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVsZCA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnQoQm9vbS5iYWRSZXF1ZXN0KCdPbmx5IHdoaXRlIHNwYWNlIGFsbG93ZWQgYWZ0ZXIgYm91bmRhcnknKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IGludGVybmFscy5zdGF0ZS5oZWFkZXI7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFBhcnQgaGVhZGVyc1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBpbnRlcm5hbHMuc3RhdGUuaGVhZGVyKSB7XG5cbiAgICAgICAgLy8gSGVhZGVyXG5cbiAgICAgICAgaWYgKHRoaXMuX2hlbGQpIHtcblxuICAgICAgICAgICAgLy8gSGVhZGVyIGNvbnRpbnVhdGlvblxuXG4gICAgICAgICAgICBpZiAodGhpcy5faGVsZFswXSA9PT0gJyAnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5faGVsZFswXSA9PT0gJ1xcdCcpIHtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcGVuZGluZ0hlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnQoQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGhlYWRlciBjb250aW51YXRpb24gd2l0aG91dCB2YWxpZCBkZWNsYXJhdGlvbiBvbiBwcmV2aW91cyBsaW5lJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdIZWFkZXIgPSB0aGlzLl9wZW5kaW5nSGVhZGVyICsgJyAnICsgdGhpcy5faGVsZC5zbGljZSgxKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIERyb3AgdGFiXG4gICAgICAgICAgICAgICAgdGhpcy5faGVsZCA9ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgb2YgbmV3IGhlYWRlclxuXG4gICAgICAgICAgICB0aGlzLl9mbHVzaEhlYWRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0hlYWRlciA9IHRoaXMuX2hlbGQ7XG4gICAgICAgICAgICB0aGlzLl9oZWxkID0gJyc7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCBvZiBoZWFkZXJzXG5cbiAgICAgICAgdGhpcy5fZmx1c2hIZWFkZXIoKTtcblxuICAgICAgICB0aGlzLl9zdGF0ZSA9IGludGVybmFscy5zdGF0ZS5wYXlsb2FkO1xuXG4gICAgICAgIGxldCBkaXNwb3NpdGlvbjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcG9zaXRpb24gPSBDb250ZW50LmRpc3Bvc2l0aW9uKHRoaXMuX2hlYWRlcnNbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Fib3J0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlzcG9zaXRpb24uZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbS5QYXNzVGhyb3VnaCgpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJFbmNvZGluZyA9IHRoaXMuX2hlYWRlcnNbJ2NvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmcnXTtcblxuICAgICAgICAgICAgaWYgKHRyYW5zZmVyRW5jb2RpbmcgJiZcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckVuY29kaW5nLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNlNjQnKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW0gPSBuZXcgQjY0LkRlY29kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJlYW0ucGlwZShzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHJlYW0ubmFtZSA9IGRpc3Bvc2l0aW9uLm5hbWU7XG4gICAgICAgICAgICBzdHJlYW0uZmlsZW5hbWUgPSBkaXNwb3NpdGlvbi5maWxlbmFtZTtcbiAgICAgICAgICAgIHN0cmVhbS5oZWFkZXJzID0gdGhpcy5faGVhZGVycztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3BhcnQnLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IGRpc3Bvc2l0aW9uLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9saW5lcy5mbHVzaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRXBpbG9ndWVcblxuICAgIHRoaXMuX2hlbGQgPSB0aGlzLl9oZWxkICsgJ1xcclxcbic7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1dCB0aGUgbmV3IGxpbmUgYmFja1xufTtcblxuXG5pbnRlcm5hbHMuRGlzcGVuc2VyLnByb3RvdHlwZS5fb25MaW5lID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICBpZiAodGhpcy5fc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS53cml0ZShjaHVuayk7ICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmVhbSBwYXlsb2FkXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9oZWxkID0gdGhpcy5faGVsZCArIGNodW5rLnRvU3RyaW5nKCk7ICAgICAgICAgICAgICAgICAvLyBSZWFkaW5nIGhlYWRlciBvciBmaWVsZFxuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLkRpc3BlbnNlci5wcm90b3R5cGUuX2ZsdXNoSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nSGVhZGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZXAgPSB0aGlzLl9wZW5kaW5nSGVhZGVyLmluZGV4T2YoJzonKTtcblxuICAgIGlmIChzZXAgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYm9ydChCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgaGVhZGVyIG1pc3NpbmcgY29sb24gc2VwYXJhdG9yJykpO1xuICAgIH1cblxuICAgIGlmICghc2VwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYm9ydChCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgaGVhZGVyIG1pc3NpbmcgZmllbGQgbmFtZScpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJzW3RoaXMuX3BlbmRpbmdIZWFkZXIuc2xpY2UoMCwgc2VwKS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMuX3BlbmRpbmdIZWFkZXIuc2xpY2Uoc2VwICsgMSkudHJpbSgpO1xuICAgIHRoaXMuX3BlbmRpbmdIZWFkZXIgPSAnJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMubG9jYXRpb24gPSBmdW5jdGlvbiAoZGVwdGggPSAwKSB7XG5cbiAgICBjb25zdCBvcmlnID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSAoaWdub3JlLCBzdGFjaykgPT4gc3RhY2s7XG5cbiAgICBjb25zdCBjYXB0dXJlID0ge307XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoY2FwdHVyZSwgdGhpcyk7XG4gICAgY29uc3QgbGluZSA9IGNhcHR1cmUuc3RhY2tbZGVwdGggKyAxXTtcblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gb3JpZztcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVuYW1lOiBsaW5lLmdldEZpbGVOYW1lKCksXG4gICAgICAgIGxpbmU6IGxpbmUuZ2V0TGluZU51bWJlcigpXG4gICAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgc2NoZW1hOiB7XG4gICAgICAgIGJhc2U6IEpvaS5vYmplY3Qoe1xuICAgICAgICAgICAgbmFtZTogSm9pLnN0cmluZygpLnJlcXVpcmVkKCksXG4gICAgICAgICAgICBjbG9uZTogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgICAgIHRhZ3M6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBzcHJlYWQ6IEpvaS5ib29sZWFuKCksXG4gICAgICAgICAgICBjaGFubmVsczogSm9pLmFycmF5KCkuaXRlbXMoSm9pLnN0cmluZygpKS5zaW5nbGUoKS51bmlxdWUoKS5taW4oMSlcbiAgICAgICAgfSlcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5zY2hlbWEuZXZlbnQgPSBpbnRlcm5hbHMuc2NoZW1hLmJhc2Uua2V5cyh7XG4gICAgc2hhcmVkOiBKb2kuYm9vbGVhbigpXG59KTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hLmxpc3RlbmVyID0gaW50ZXJuYWxzLnNjaGVtYS5ldmVudC5rZXlzKHtcbiAgICBsaXN0ZW5lcjogSm9pLmZ1bmMoKS5yZXF1aXJlZCgpLFxuICAgIGNvbnRleHQ6IEpvaS5vYmplY3QoKSxcbiAgICBjb3VudDogSm9pLm51bWJlcigpLmludGVnZXIoKS5taW4oMSksXG4gICAgZmlsdGVyOiB7XG4gICAgICAgIHRhZ3M6IEpvaS5hcnJheSgpLml0ZW1zKEpvaS5zdHJpbmcoKSkuc2luZ2xlKCkudW5pcXVlKCkubWluKDEpLnJlcXVpcmVkKCksXG4gICAgICAgIGFsbDogSm9pLmJvb2xlYW4oKVxuICAgIH1cbn0pO1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5Qb2RpdW0gPSBmdW5jdGlvbiAoZXZlbnRzLCBvcHRpb25zKSB7XG5cbiAgICAvLyBVc2UgZGVzY3JpcHRpdmUgbmFtZXMgdG8gYXZvaWQgY29uZmxpY3Qgd2hlbiBpbmhlcml0ZWRcblxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ub3RpZmljYXRpb25zUXVldWUgPSBbXTtcbiAgICB0aGlzLl9ldmVudHNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc291cmNlUG9kaXVtcyA9IFtdO1xuXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoZXZlbnRzLCBvcHRpb25zKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0uZGVjb3JhdGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblxuICAgIGludGVybmFscy5Qb2RpdW0uY2FsbCh0YXJnZXQsIG51bGwpO1xuXG4gICAgT2JqZWN0LmtleXMoc291cmNlLl9ldmVudExpc3RlbmVycykuZm9yRWFjaCgobmFtZSkgPT4ge1xuXG4gICAgICAgIHRhcmdldC5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0gPSB7XG4gICAgICAgICAgICBoYW5kbGVyczogbnVsbCxcbiAgICAgICAgICAgIGZsYWdzOiBzb3VyY2UuX2V2ZW50TGlzdGVuZXJzW25hbWVdLmZsYWdzXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0udmFsaWRhdGUgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XG5cbiAgICBjb25zdCBub3JtYWxpemVkID0gW107XG4gICAgW10uY29uY2F0KGV2ZW50cykuZm9yRWFjaCgoZXZlbnQpID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXZlbnQgPSB7IG5hbWU6IGV2ZW50IH07XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVkLnB1c2goSm9pLmF0dGVtcHQoZXZlbnQsIGludGVybmFscy5zY2hlbWEuZXZlbnQsICdJbnZhbGlkIGV2ZW50IG9wdGlvbnMnKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn07XG5cblxuaW50ZXJuYWxzLlBvZGl1bS5wcm90b3R5cGUucmVnaXN0ZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudHMsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgZXZlbnRzID0gSG9lay5mbGF0dGVuKFtdLmNvbmNhdChldmVudHMpKTtcbiAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcblxuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBpbnRlcm5hbHMuUG9kaXVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclBvZGl1bShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXZlbnQgPSB7IG5hbWU6IGV2ZW50IH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSAhPT0gZmFsc2UpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgZXZlbnQgPSBKb2kuYXR0ZW1wdChldmVudCwgaW50ZXJuYWxzLnNjaGVtYS5ldmVudCwgJ0ludmFsaWQgZXZlbnQgb3B0aW9ucycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmFtZSA9IGV2ZW50Lm5hbWU7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgSG9lay5hc3NlcnQoZXZlbnQuc2hhcmVkLCBgRXZlbnQgJHtuYW1lfSBleGlzdHNgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdID0geyBoYW5kbGVyczogbnVsbCwgZmxhZ3M6IGV2ZW50IH07XG4gICAgICAgIHRoaXMuX3NvdXJjZVBvZGl1bXMuZm9yRWFjaCgocG9kaXVtKSA9PiB7XG5cbiAgICAgICAgICAgIGlmICghcG9kaXVtLl9ldmVudExpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHBvZGl1bS5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0gPSB7IGhhbmRsZXJzOiBudWxsLCBmbGFnczogZXZlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0ucHJvdG90eXBlLnJlZ2lzdGVyUG9kaXVtID0gZnVuY3Rpb24gKHBvZGl1bXMpIHtcblxuICAgIFtdLmNvbmNhdChwb2RpdW1zKS5mb3JFYWNoKChwb2RpdW0pID0+IHtcblxuICAgICAgICBpZiAocG9kaXVtLl9zb3VyY2VQb2RpdW1zLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwb2RpdW0uX3NvdXJjZVBvZGl1bXMucHVzaCh0aGlzKTtcbiAgICAgICAgT2JqZWN0LmtleXMocG9kaXVtLl9ldmVudExpc3RlbmVycykuZm9yRWFjaCgobmFtZSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0gPSB7IGhhbmRsZXJzOiBudWxsLCBmbGFnczogcG9kaXVtLl9ldmVudExpc3RlbmVyc1tuYW1lXS5mbGFncyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cblxuaW50ZXJuYWxzLlBvZGl1bS5wcm90b3R5cGUuZW1pdCA9IGFzeW5jIGZ1bmN0aW9uIChjcml0ZXJpYSwgZGF0YSwgX2dlbmVyYXRlZCkge1xuXG4gICAgY3JpdGVyaWEgPSBpbnRlcm5hbHMuY3JpdGVyaWEoY3JpdGVyaWEpO1xuXG4gICAgY29uc3QgbmFtZSA9IGNyaXRlcmlhLm5hbWU7XG4gICAgSG9lay5hc3NlcnQobmFtZSwgJ0NyaXRlcmlhIG1pc3NpbmcgZXZlbnQgbmFtZScpO1xuXG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXTtcbiAgICBIb2VrLmFzc2VydChldmVudCwgYFVua25vd24gZXZlbnQgJHtuYW1lfWApO1xuICAgIEhvZWsuYXNzZXJ0KCFjcml0ZXJpYS5jaGFubmVsIHx8IHR5cGVvZiBjcml0ZXJpYS5jaGFubmVsID09PSAnc3RyaW5nJywgJ0ludmFsaWQgY2hhbm5lbCBuYW1lJyk7XG4gICAgSG9lay5hc3NlcnQoIWNyaXRlcmlhLmNoYW5uZWwgfHwgIWV2ZW50LmZsYWdzLmNoYW5uZWxzIHx8IGV2ZW50LmZsYWdzLmNoYW5uZWxzLmluZGV4T2YoY3JpdGVyaWEuY2hhbm5lbCkgIT09IC0xLCBgVW5rbm93biAke2NyaXRlcmlhLmNoYW5uZWx9IGNoYW5uZWxgKTtcbiAgICBIb2VrLmFzc2VydCghZXZlbnQuZmxhZ3Muc3ByZWFkIHx8IEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicsICdEYXRhIG11c3QgYmUgYW4gYXJyYXkgZm9yIHNwcmVhZCBldmVudCcpO1xuXG4gICAgaWYgKCFldmVudC5oYW5kbGVycyAmJlxuICAgICAgICAhdGhpcy5fc291cmNlUG9kaXVtcy5sZW5ndGgpIHtcblxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjcml0ZXJpYS50YWdzID09PSAnc3RyaW5nJykge1xuICAgICAgICBjcml0ZXJpYS50YWdzID0gW2NyaXRlcmlhLnRhZ3NdO1xuICAgIH1cblxuICAgIGlmIChjcml0ZXJpYS50YWdzICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoY3JpdGVyaWEudGFncykpIHtcblxuICAgICAgICAvLyBNYXAgYXJyYXkgdG8gb2JqZWN0XG5cbiAgICAgICAgY29uc3QgdGFncyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBjcml0ZXJpYS50YWdzKSB7XG4gICAgICAgICAgICB0YWdzW3RhZ10gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3JpdGVyaWEudGFncyA9IHRhZ3M7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LmhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmcgPSBbXTtcblxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGV2ZW50LmhhbmRsZXJzLnNsaWNlKCk7ICAgICAgICAgICAgICAgIC8vIENsb25lIGluIGNhc2UgaGFuZGxlcnMgYXJlIGNoYW5nZWQgYnkgbGlzdGVuZXJzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIuY2hhbm5lbHMgJiZcbiAgICAgICAgICAgICAgICAoIWNyaXRlcmlhLmNoYW5uZWwgfHwgaGFuZGxlci5jaGFubmVscy5pbmRleE9mKGNyaXRlcmlhLmNoYW5uZWwpID09PSAtMSkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFuZGxlci5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNyaXRlcmlhLnRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBIb2VrLmludGVyc2VjdChjcml0ZXJpYS50YWdzLCBoYW5kbGVyLmZpbHRlci50YWdzLCB7IGZpcnN0OiAhaGFuZGxlci5maWx0ZXIuYWxsIH0pO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2ggfHxcbiAgICAgICAgICAgICAgICAgICAgKGhhbmRsZXIuZmlsdGVyLmFsbCAmJiBtYXRjaC5sZW5ndGggIT09IGhhbmRsZXIuZmlsdGVyLnRhZ3MubGVuZ3RoKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhhbmRsZXIuY291bnQpIHtcbiAgICAgICAgICAgICAgICAtLWhhbmRsZXIuY291bnQ7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIuY291bnQgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGludGVybmFscy5yZW1vdmVIYW5kbGVyKHRoaXMsIGNyaXRlcmlhLm5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFfZ2VuZXJhdGVkICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKCk7XG4gICAgICAgICAgICAgICAgX2dlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IChpbnRlcm5hbHMuZmxhZygnY2xvbmUnLCBoYW5kbGVyLCBldmVudCkgPyBIb2VrLmNsb25lKGRhdGEpIDogZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gKGludGVybmFscy5mbGFnKCdzcHJlYWQnLCBoYW5kbGVyLCBldmVudCkgJiYgQXJyYXkuaXNBcnJheSh1cGRhdGUpID8gdXBkYXRlIDogW3VwZGF0ZV0pO1xuXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmZsYWcoJ3RhZ3MnLCBoYW5kbGVyLCBldmVudCkgJiZcbiAgICAgICAgICAgICAgICBjcml0ZXJpYS50YWdzKSB7XG5cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goY3JpdGVyaWEudGFncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGhhbmRsZXIuY29udGV4dCA/IGhhbmRsZXIubGlzdGVuZXIuYXBwbHkoaGFuZGxlci5jb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIubGlzdGVuZXIoLi4uYXJncykpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcucHVzaChQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvY2Vzc2luZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc291cmNlUG9kaXVtcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcG9kaXVtcyA9IHRoaXMuX3NvdXJjZVBvZGl1bXMuc2xpY2UoKTsgICAgICAgICAvLyBDbG9uZSBpbiBjYXNlIG1vZGlmaWVkIHdoaWxlIHByb2Nlc3NpbmdcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocG9kaXVtcy5tYXAoKHBvZGl1bSkgPT4gcG9kaXVtLmVtaXQoY3JpdGVyaWEsIGRhdGEsIF9nZW5lcmF0ZWQpKSk7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUG9kaXVtLnByb3RvdHlwZS5vbiA9IGludGVybmFscy5Qb2RpdW0ucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBsaXN0ZW5lciwgY29udGV4dCkge1xuXG4gICAgY3JpdGVyaWEgPSBpbnRlcm5hbHMuY3JpdGVyaWEoY3JpdGVyaWEpO1xuICAgIGNyaXRlcmlhLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgY3JpdGVyaWEuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICBpZiAoY3JpdGVyaWEuZmlsdGVyICYmXG4gICAgICAgICh0eXBlb2YgY3JpdGVyaWEuZmlsdGVyID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KGNyaXRlcmlhLmZpbHRlcikpKSB7XG5cbiAgICAgICAgY3JpdGVyaWEuZmlsdGVyID0geyB0YWdzOiBjcml0ZXJpYS5maWx0ZXIgfTtcbiAgICB9XG5cbiAgICBjcml0ZXJpYSA9IEpvaS5hdHRlbXB0KGNyaXRlcmlhLCBpbnRlcm5hbHMuc2NoZW1hLmxpc3RlbmVyLCAnSW52YWxpZCBldmVudCBsaXN0ZW5lciBvcHRpb25zJyk7XG5cbiAgICBjb25zdCBuYW1lID0gY3JpdGVyaWEubmFtZTtcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdO1xuICAgIEhvZWsuYXNzZXJ0KGV2ZW50LCBgVW5rbm93biBldmVudCAke25hbWV9YCk7XG4gICAgSG9lay5hc3NlcnQoIWNyaXRlcmlhLmNoYW5uZWxzIHx8ICFldmVudC5mbGFncy5jaGFubmVscyB8fCBIb2VrLmludGVyc2VjdChldmVudC5mbGFncy5jaGFubmVscywgY3JpdGVyaWEuY2hhbm5lbHMpLmxlbmd0aCA9PT0gY3JpdGVyaWEuY2hhbm5lbHMubGVuZ3RoLCBgVW5rbm93biBldmVudCBjaGFubmVscyAke2NyaXRlcmlhLmNoYW5uZWxzICYmIGNyaXRlcmlhLmNoYW5uZWxzLmpvaW4oJywgJyl9YCk7XG5cbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLmhhbmRsZXJzIHx8IFtdO1xuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLmhhbmRsZXJzLnB1c2goY3JpdGVyaWEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0ucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGxpc3RlbmVyLCBjb250ZXh0KSB7XG5cbiAgICBjcml0ZXJpYSA9IE9iamVjdC5hc3NpZ24oaW50ZXJuYWxzLmNyaXRlcmlhKGNyaXRlcmlhKSwgeyBjb3VudDogMSB9KTtcblxuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihjcml0ZXJpYSwgbGlzdGVuZXIsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gdGhpcy5vbihjcml0ZXJpYSwgKC4uLmFyZ3MpID0+IHJlc29sdmUoYXJncyksIGNvbnRleHQpKTtcbn07XG5cblxuaW50ZXJuYWxzLlBvZGl1bS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcblxuICAgIEhvZWsuYXNzZXJ0KHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLCBgVW5rbm93biBldmVudCAke25hbWV9YCk7XG4gICAgSG9lay5hc3NlcnQodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nLCAnTGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLmhhbmRsZXJzO1xuICAgIGlmICghaGFuZGxlcnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsdGVyZWQgPSBoYW5kbGVycy5maWx0ZXIoKGhhbmRsZXIpID0+IGhhbmRsZXIubGlzdGVuZXIgIT09IGxpc3RlbmVyKTtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycyA9IChmaWx0ZXJlZC5sZW5ndGggPyBmaWx0ZXJlZCA6IG51bGwpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG5pbnRlcm5hbHMuUG9kaXVtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuXG4gICAgSG9lay5hc3NlcnQodGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0sIGBVbmtub3duIGV2ZW50ICR7bmFtZX1gKTtcbiAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbmludGVybmFscy5Qb2RpdW0ucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICBIb2VrLmFzc2VydCh0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXSwgYFVua25vd24gZXZlbnQgJHtuYW1lfWApO1xuICAgIHJldHVybiAhIXRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLmhhbmRsZXJzO1xufTtcblxuXG5pbnRlcm5hbHMucmVtb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIChlbWl0dGVyLCBuYW1lLCBoYW5kbGVyKSB7XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IGVtaXR0ZXIuX2V2ZW50TGlzdGVuZXJzW25hbWVdLmhhbmRsZXJzO1xuICAgIGNvbnN0IGZpbHRlcmVkID0gaGFuZGxlcnMuZmlsdGVyKChpdGVtKSA9PiBpdGVtICE9PSBoYW5kbGVyKTtcbiAgICBlbWl0dGVyLl9ldmVudExpc3RlbmVyc1tuYW1lXS5oYW5kbGVycyA9IChmaWx0ZXJlZC5sZW5ndGggPyBmaWx0ZXJlZCA6IG51bGwpO1xufTtcblxuXG5pbnRlcm5hbHMuY3JpdGVyaWEgPSBmdW5jdGlvbiAoY3JpdGVyaWEpIHtcblxuICAgIHJldHVybiAodHlwZW9mIGNyaXRlcmlhID09PSAnc3RyaW5nJyA/IHsgbmFtZTogY3JpdGVyaWEgfSA6IEhvZWsuY2xvbmUoY3JpdGVyaWEpKTtcbn07XG5cblxuaW50ZXJuYWxzLmZsYWcgPSBmdW5jdGlvbiAobmFtZSwgaGFuZGxlciwgZXZlbnQpIHtcblxuICAgIHJldHVybiAoaGFuZGxlcltuYW1lXSAhPT0gdW5kZWZpbmVkID8gaGFuZGxlcltuYW1lXSA6IGV2ZW50LmZsYWdzW25hbWVdKSB8fCBmYWxzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuY29uc3QgUmVxdWVzdCA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpO1xuY29uc3QgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi9zeW1ib2xzJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuaW50ZXJuYWxzLm9wdGlvbnMgPSBKb2kub2JqZWN0KCkua2V5cyh7XG4gICAgdXJsOiBKb2kuYWx0ZXJuYXRpdmVzKFtcbiAgICAgICAgSm9pLnN0cmluZygpLFxuICAgICAgICBKb2kub2JqZWN0KCkua2V5cyh7XG4gICAgICAgICAgICBwcm90b2NvbDogSm9pLnN0cmluZygpLFxuICAgICAgICAgICAgaG9zdG5hbWU6IEpvaS5zdHJpbmcoKSxcbiAgICAgICAgICAgIHBvcnQ6IEpvaS5hbnkoKSxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBKb2kuc3RyaW5nKCkucmVxdWlyZWQoKSxcbiAgICAgICAgICAgIHF1ZXJ5OiBKb2kuYW55KClcbiAgICAgICAgfSlcbiAgICBdKVxuICAgICAgICAucmVxdWlyZWQoKSxcbiAgICBoZWFkZXJzOiBKb2kub2JqZWN0KCksXG4gICAgcGF5bG9hZDogSm9pLmFueSgpLFxuICAgIHNpbXVsYXRlOiB7XG4gICAgICAgIGVuZDogSm9pLmJvb2xlYW4oKSxcbiAgICAgICAgc3BsaXQ6IEpvaS5ib29sZWFuKCksXG4gICAgICAgIGVycm9yOiBKb2kuYm9vbGVhbigpLFxuICAgICAgICBjbG9zZTogSm9pLmJvb2xlYW4oKVxuICAgIH0sXG4gICAgYXV0aG9yaXR5OiBKb2kuc3RyaW5nKCksXG4gICAgcmVtb3RlQWRkcmVzczogSm9pLnN0cmluZygpLFxuICAgIG1ldGhvZDogSm9pLnN0cmluZygpLFxuICAgIHZhbGlkYXRlOiBKb2kuYm9vbGVhbigpXG59KTtcblxuXG5leHBvcnRzLmluamVjdCA9IGZ1bmN0aW9uIChkaXNwYXRjaEZ1bmMsIG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnID8geyB1cmw6IG9wdGlvbnMgfSA6IG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMudmFsaWRhdGUgIT09IGZhbHNlKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgZGlzcGF0Y2hGdW5jID09PSAnZnVuY3Rpb24nLCAnSW52YWxpZCBkaXNwYXRjaCBmdW5jdGlvbicpO1xuICAgICAgICAgICAgSm9pLmFzc2VydChvcHRpb25zLCBpbnRlcm5hbHMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblxuICAgICAgICBjb25zdCByZXEgPSBuZXcgUmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFJlc3BvbnNlKHJlcSwgcmVzb2x2ZSk7XG5cbiAgICAgICAgcmVxLnByZXBhcmUoKCkgPT4gZGlzcGF0Y2hGdW5jKHJlcSwgcmVzKSk7XG4gICAgfSk7XG59O1xuXG5cbmV4cG9ydHMuaXNJbmplY3Rpb24gPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgICByZXR1cm4gISFvYmpbU3ltYm9scy5pbmplY3Rpb25dO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCBVcmwgPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4vc3ltYm9scycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5SZXF1ZXN0ID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW0uUmVhZGFibGUge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLy8gb3B0aW9uczogbWV0aG9kLCB1cmwsIHBheWxvYWQsIGhlYWRlcnMsIHJlbW90ZUFkZHJlc3NcblxuICAgICAgICBsZXQgdXJsID0gb3B0aW9ucy51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdXJsID0gVXJsLmZvcm1hdCh1cmwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXJpID0gVXJsLnBhcnNlKHVybCk7XG4gICAgICAgIHRoaXMudXJsID0gdXJpLnBhdGg7XG5cbiAgICAgICAgdGhpcy5odHRwVmVyc2lvbiA9ICcxLjEnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IChvcHRpb25zLm1ldGhvZCA/IG9wdGlvbnMubWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAnR0VUJyk7XG5cbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgICAgICBmaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcblxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyc1tmaWVsZF07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaGVhZGVyc1sndXNlci1hZ2VudCddID0gdGhpcy5oZWFkZXJzWyd1c2VyLWFnZW50J10gfHwgJ3Nob3QnO1xuXG4gICAgICAgIGNvbnN0IGhvc3RIZWFkZXJGcm9tVXJpID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodXJpLnBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJpLmhvc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1cmkucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJpLmhvc3RuYW1lICsgKHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnOjQ0MycgOiAnOjgwJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaGVhZGVycy5ob3N0ID0gdGhpcy5oZWFkZXJzLmhvc3QgfHwgaG9zdEhlYWRlckZyb21VcmkoKSB8fCBvcHRpb25zLmF1dGhvcml0eSB8fCAnbG9jYWxob3N0OjgwJztcblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBvcHRpb25zLnJlbW90ZUFkZHJlc3MgfHwgJzEyNy4wLjAuMSdcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgcGF5bG9hZCA9IG9wdGlvbnMucGF5bG9hZCB8fCBudWxsO1xuICAgICAgICBpZiAocGF5bG9hZCAmJlxuICAgICAgICAgICAgdHlwZW9mIHBheWxvYWQgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAhKHBheWxvYWQgaW5zdGFuY2VvZiBTdHJlYW0pICYmXG4gICAgICAgICAgICAhQnVmZmVyLmlzQnVmZmVyKHBheWxvYWQpKSB7XG5cbiAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSB0aGlzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgY29udGVudC1sZW5ndGggZm9yIHRoZSBjb3JyZXNwb25kaW5nIHBheWxvYWQgaWYgbm9uZSBzZXRcblxuICAgICAgICBpZiAocGF5bG9hZCAmJlxuICAgICAgICAgICAgIShwYXlsb2FkIGluc3RhbmNlb2YgU3RyZWFtKSAmJlxuICAgICAgICAgICAgIXRoaXMuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eSgnY29udGVudC1sZW5ndGgnKSkge1xuXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSAoQnVmZmVyLmlzQnVmZmVyKHBheWxvYWQpID8gcGF5bG9hZC5sZW5ndGggOiBCdWZmZXIuYnl0ZUxlbmd0aChwYXlsb2FkKSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBfc2hvdCBuYW1lc3BhY2UgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggTm9kZVxuXG4gICAgICAgIHRoaXMuX3Nob3QgPSB7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgaXNEb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHNpbXVsYXRlOiBvcHRpb25zLnNpbXVsYXRlIHx8IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJlcGFyZShuZXh0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3QucGF5bG9hZCBpbnN0YW5jZW9mIFN0cmVhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgICB0aGlzLl9zaG90LnBheWxvYWQub24oJ2RhdGEnLCAoY2h1bmspID0+IGNodW5rcy5wdXNoKEJ1ZmZlci5mcm9tKGNodW5rKSkpO1xuXG4gICAgICAgIHRoaXMuX3Nob3QucGF5bG9hZC5vbignZW5kJywgKCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmNvbmNhdChjaHVua3MpO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gdGhpcy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddIHx8IHBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fc2hvdC5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9yZWFkKHNpemUpIHtcblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdC5pc0RvbmUpIHtcbiAgICAgICAgICAgICAgICAvKiAkbGFiOmNvdmVyYWdlOm9mZiQgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvdC5zaW11bGF0ZS5lbmQgIT09IGZhbHNlKSB7ICAgICAgICAvLyAnZW5kJyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogJGxhYjpjb3ZlcmFnZTpvbiQgKi9cblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2hvdC5pc0RvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdC5wYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3Quc2ltdWxhdGUuc3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuX3Nob3QucGF5bG9hZC5zbGljZSgwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLl9zaG90LnBheWxvYWQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuX3Nob3QucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2hvdC5zaW11bGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ1NpbXVsYXRlZCcpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3Quc2ltdWxhdGUuY2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zaG90LnNpbXVsYXRlLmVuZCAhPT0gZmFsc2UpIHsgICAgICAgIC8vICdlbmQnIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG5cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5SZXF1ZXN0LnByb3RvdHlwZVtTeW1ib2xzLmluamVjdGlvbl0gPSB0cnVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIdHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFN5bWJvbHMgPSByZXF1aXJlKCcuL3N5bWJvbHMnKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuUmVzcG9uc2UgPSBjbGFzcyBleHRlbmRzIEh0dHAuU2VydmVyUmVzcG9uc2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVxLCBvbkVuZCkge1xuXG4gICAgICAgIHN1cGVyKHsgbWV0aG9kOiByZXEubWV0aG9kLCBodHRwVmVyc2lvbk1ham9yOiAxLCBodHRwVmVyc2lvbk1pbm9yOiAxIH0pO1xuICAgICAgICB0aGlzLl9zaG90ID0geyBoZWFkZXJzOiBudWxsLCB0cmFpbGVyczoge30sIHBheWxvYWRDaHVua3M6IFtdIH07XG4gICAgICAgIHRoaXMuYXNzaWduU29ja2V0KGludGVybmFscy5udWxsU29ja2V0KCkpO1xuXG4gICAgICAgIHRoaXMub25jZSgnZmluaXNoJywgKCkgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCByZXMgPSBpbnRlcm5hbHMucGF5bG9hZCh0aGlzKTtcbiAgICAgICAgICAgIHJlcy5yYXcucmVxID0gcmVxO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBvbkVuZChyZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgd3JpdGVIZWFkKC4uLmFyZ3MpIHtcblxuICAgICAgICAvLyBGaW5kIHRoZSBoZWFkZXJzIG9iamVjdCBpZiBvbmUgd2FzIHByb3ZpZGVkLiBJZiBhIGhlYWRlcnMgb2JqZWN0IGlzIHByZXNlbnQsIGNhbGwgc2V0SGVhZGVyKClcbiAgICAgICAgLy8gb24gdGhlIGZpcnN0IHZhbGlkIGhlYWRlciwgYW5kIHRoZW4gYnJlYWsgb3V0IG9mIHRoZSBsb29wIGFuZCBjYWxsIHdyaXRlSGVhZCgpLiBCeSBjYWxsaW5nXG4gICAgICAgIC8vIHNldEhlYWRlcigpLCBOb2RlIHdpbGwgbWF0ZXJpYWxpemUgYSBoZWFkZXJzIG9iamVjdC5cblxuICAgICAgICBjb25zdCBoZWFkZXJzID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgaGVhZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyTmFtZXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBoZWFkZXJOYW1lc1tpXTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZUVycikge30gLy8gTGV0IHRoZSByZWFsIHdyaXRlSGVhZCgpIGhhbmRsZSBlcnJvcnMuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci53cml0ZUhlYWQoLi4uYXJncyk7XG5cbiAgICAgICAgdGhpcy5fc2hvdC5oZWFkZXJzID0gdGhpcy5nZXRIZWFkZXJzKCk7XG5cbiAgICAgICAgLy8gQWRkIHJhdyBoZWFkZXJzXG5cbiAgICAgICAgWydEYXRlJywgJ0Nvbm5lY3Rpb24nLCAnVHJhbnNmZXItRW5jb2RpbmcnXS5mb3JFYWNoKChuYW1lKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXHJcXFxcbicgKyBuYW1lICsgJzogKFteXFxcXHJdKilcXFxcclxcXFxuJyk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHRoaXMuX2hlYWRlci5tYXRjaChyZWdleCk7XG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG90LmhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGZpZWxkWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHdyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXG4gICAgICAgIHN1cGVyLndyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX3Nob3QucGF5bG9hZENodW5rcy5wdXNoKEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKSk7XG4gICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXcml0ZSBhbHdheXMgcmV0dXJucyBmYWxzZSB3aGVuIGRpc2Nvbm5lY3RlZFxuICAgIH1cblxuICAgIGVuZChkYXRhLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5lbmQoY2FsbGJhY2spO1xuICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG5cbiAgICB9XG5cbiAgICBhZGRUcmFpbGVycyh0cmFpbGVycykge1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYWlsZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaG90LnRyYWlsZXJzW2tleS50b0xvd2VyQ2FzZSgpLnRyaW0oKV0gPSB0cmFpbGVyc1trZXldLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuUmVzcG9uc2UucHJvdG90eXBlW1N5bWJvbHMuaW5qZWN0aW9uXSA9IHRydWU7XG5cblxuaW50ZXJuYWxzLnBheWxvYWQgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblxuICAgIC8vIFByZXBhcmUgcmVzcG9uc2Ugb2JqZWN0XG5cbiAgICBjb25zdCByZXMgPSB7XG4gICAgICAgIHJhdzoge1xuICAgICAgICAgICAgcmVzOiByZXNwb25zZVxuICAgICAgICB9LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5fc2hvdC5oZWFkZXJzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICBzdGF0dXNNZXNzYWdlOiByZXNwb25zZS5zdGF0dXNNZXNzYWdlLFxuICAgICAgICB0cmFpbGVyczoge31cbiAgICB9O1xuXG4gICAgLy8gUHJlcGFyZSBwYXlsb2FkIGFuZCB0cmFpbGVyc1xuXG4gICAgY29uc3QgcmF3QnVmZmVyID0gQnVmZmVyLmNvbmNhdChyZXNwb25zZS5fc2hvdC5wYXlsb2FkQ2h1bmtzKTtcbiAgICByZXMucmF3UGF5bG9hZCA9IHJhd0J1ZmZlcjtcbiAgICByZXMucGF5bG9hZCA9IHJhd0J1ZmZlci50b1N0cmluZygpO1xuICAgIHJlcy50cmFpbGVycyA9IHJlc3BvbnNlLl9zaG90LnRyYWlsZXJzO1xuXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblxuLy8gVGhyb3dzIGF3YXkgYWxsIHdyaXR0ZW4gZGF0YSB0byBwcmV2ZW50IHJlc3BvbnNlIGZyb20gYnVmZmVyaW5nIHBheWxvYWRcblxuaW50ZXJuYWxzLm51bGxTb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFN0cmVhbS5Xcml0YWJsZSh7XG4gICAgICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cy5pbmplY3Rpb24gPSBTeW1ib2woJ2luamVjdGlvbicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBCb3VuY2UgPSByZXF1aXJlKCdAaGFwaS9ib3VuY2UnKTtcbmNvbnN0IEhvZWsgPSByZXF1aXJlKCdAaGFwaS9ob2VrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIG1heExlbmd0aDogMjU2LFxuICAgIHdpbGRjYXJkczogWyd4JywgJ1gnLCAnKiddLFxuICAgIGFueTogU3ltYm9sKCdhbnknKVxufTtcblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOm1ham9yICAgICAgICAgMjptaW5vciAgICAgICAgIDM6cGF0Y2ggICAgICAgICAgNDpwcmVyZWxlYXNlICA1OmJ1aWxkXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEEgICAgICAgICBhQiAgICBDICAgICAgICAgY0QgICAgRSAgICAgICAgIGVGICAgICBHICAgICBnZiBIICAgIEkgIGloIGQgYlxuaW50ZXJuYWxzLnZlcnNpb25SeCA9IC9eXFxzKlt2Vl0/KFxcZCt8W3hYKl0pKD86XFwuKFxcZCt8W3hYKl0pKD86XFwuKFxcZCt8W3hYKl0pKD86XFwtPyhbXitdKykpPyg/OlxcKyguKykpPyk/KT9cXHMqJC87XG5cbmludGVybmFscy5zdHJpY3QgPSB7XG4gICAgdG9rZW5SeDogL15bLVxcZEEtWmEtel0rKD86XFwuWy1cXGRBLVphLXpdKykqJC8sXG4gICAgbnVtYmVyUng6IC9eKCg/OjApfCg/OlsxLTldXFxkKikpJC9cbn07XG5cblxuZXhwb3J0cy52ZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb24sIG9wdGlvbnMpIHtcblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlZlcnNpb24odmVyc2lvbiwgb3B0aW9ucyk7XG59O1xuXG5cbmV4cG9ydHMucmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcblxuICAgIHJldHVybiBuZXcgaW50ZXJuYWxzLlJhbmdlKHJhbmdlKTtcbn07XG5cblxuZXhwb3J0cy5tYXRjaCA9IGZ1bmN0aW9uICh2ZXJzaW9uLCByYW5nZSkge1xuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMucmFuZ2UocmFuZ2UpLm1hdGNoKHZlcnNpb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuXG5pbnRlcm5hbHMuVmVyc2lvbiA9IGNsYXNzIHtcblxuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24sIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KHZlcnNpb24sICdNaXNzaW5nIHZlcnNpb24gYXJndW1lbnQnKTtcblxuICAgICAgICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIGludGVybmFscy5WZXJzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcHkodmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZSh2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9ybWF0KCk7XG4gICAgfVxuXG4gICAgX2NvcHkodmVyc2lvbikge1xuXG4gICAgICAgIHRoaXMubWFqb3IgPSB2ZXJzaW9uLm1ham9yID09PSB1bmRlZmluZWQgPyBpbnRlcm5hbHMuYW55IDogdmVyc2lvbi5tYWpvcjtcbiAgICAgICAgdGhpcy5taW5vciA9IHZlcnNpb24ubWlub3IgPT09IHVuZGVmaW5lZCA/IGludGVybmFscy5hbnkgOiB2ZXJzaW9uLm1pbm9yO1xuICAgICAgICB0aGlzLnBhdGNoID0gdmVyc2lvbi5wYXRjaCA9PT0gdW5kZWZpbmVkID8gaW50ZXJuYWxzLmFueSA6IHZlcnNpb24ucGF0Y2g7XG4gICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IHZlcnNpb24ucHJlcmVsZWFzZSB8fCBbXTtcbiAgICAgICAgdGhpcy5idWlsZCA9IHZlcnNpb24uYnVpbGQgfHwgW107XG4gICAgfVxuXG4gICAgX3BhcnNlKHZlcnNpb24sIG9wdGlvbnMpIHtcblxuICAgICAgICBIb2VrLmFzc2VydCh0eXBlb2YgdmVyc2lvbiA9PT0gJ3N0cmluZycsICdWZXJzaW9uIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgSG9lay5hc3NlcnQodmVyc2lvbi5sZW5ndGggPD0gaW50ZXJuYWxzLm1heExlbmd0aCwgJ1ZlcnNpb24gc3RyaW5nIHRvbyBsb25nJyk7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKGludGVybmFscy52ZXJzaW9uUngpO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbiBzdHJpbmcgZm9ybWF0OiAke3ZlcnNpb259YCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1ham9yID0gaW50ZXJuYWxzLlZlcnNpb24uX251bWJlcihtYXRjaFsxXSwgJ21ham9yJywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubWlub3IgPSBpbnRlcm5hbHMuVmVyc2lvbi5fbnVtYmVyKG1hdGNoWzJdIHx8ICd4JywgJ21pbm9yJywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGF0Y2ggPSBpbnRlcm5hbHMuVmVyc2lvbi5fbnVtYmVyKG1hdGNoWzNdIHx8ICd4JywgJ3BhdGNoJywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gaW50ZXJuYWxzLlZlcnNpb24uX3N1YihtYXRjaFs0XSwgJ3ByZXJlbGVhc2UnLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5idWlsZCA9IGludGVybmFscy5WZXJzaW9uLl9zdWIobWF0Y2hbNV0sICdidWlsZCcsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfbnVtYmVyKHN0cmluZywgc291cmNlLCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKGludGVybmFscy53aWxkY2FyZHMuaW5jbHVkZXMoc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFscy5hbnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHN0cmluZy5tYXRjaChpbnRlcm5hbHMuc3RyaWN0Lm51bWJlclJ4KSwgJ1ZhbHVlIG11c3QgYmUgMCBvciBhIG51bWJlciB3aXRob3V0IGEgbGVhZGluZyB6ZXJvOicsIHNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KHN0cmluZywgMTApO1xuICAgICAgICBIb2VrLmFzc2VydCh2YWx1ZSA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgJ1ZhbHVlIG11c3QgYmUgcG9zaXRpdmUgYW5kIGxlc3MgdGhhbiBtYXggc2FmZSBpbnRlZ2VyOicsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX3N1YihzdHJpbmcsIHNvdXJjZSwgb3B0aW9ucykge1xuXG4gICAgICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgIEhvZWsuYXNzZXJ0KHN0cmluZy5tYXRjaChpbnRlcm5hbHMuc3RyaWN0LnRva2VuUngpLCAnVmFsdWUgY2FuIG9ubHkgY29udGFpbiBkb3Qtc2VwYXJhdGVkIGh5cGhlbnMsIGRpZ2l0cywgYS16IG9yIEEtWjonLCBzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3VicyA9IFtdO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGlmICghcGFydCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbXB0eSAke3NvdXJjZX0gc2VnbWVudGApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJzLnB1c2gocGFydC5tYXRjaCgvXlxcZCskLykgPyBpbnRlcm5hbHMuVmVyc2lvbi5fbnVtYmVyKHBhcnQsIHNvdXJjZSwgeyBzdHJpY3Q6IG9wdGlvbnMuc3RyaWN0IH0pIDogcGFydCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VicztcbiAgICB9XG5cbiAgICBmb3JtYXQoKSB7XG5cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gYCR7aW50ZXJuYWxzLmRvdCh0aGlzLm1ham9yKX0uJHtpbnRlcm5hbHMuZG90KHRoaXMubWlub3IpfS4ke2ludGVybmFscy5kb3QodGhpcy5wYXRjaCl9JHtpbnRlcm5hbHMudG9rZW4odGhpcy5wcmVyZWxlYXNlLCAnLScpfSR7aW50ZXJuYWxzLnRva2VuKHRoaXMuYnVpbGQsICcrJyl9YDtcbiAgICAgICAgdGhpcy5kb3RzID0gW3RoaXMubWFqb3IsIHRoaXMubWlub3IsIHRoaXMucGF0Y2hdO1xuICAgICAgICB0aGlzLndpbGRjYXJkID0gdGhpcy5tYWpvciA9PT0gaW50ZXJuYWxzLmFueSAmJiB0aGlzLm1pbm9yID09PSBpbnRlcm5hbHMuYW55ICYmIHRoaXMucGF0Y2ggPT09IGludGVybmFscy5hbnkgJiYgIXRoaXMucHJlcmVsZWFzZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgICB9XG5cbiAgICBjb21wYXJlKHRvLCBvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy5WZXJzaW9uLmNvbXBhcmUodGhpcywgdG8sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjb21wYXJlKGEsIGIsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAgIGxldCBhRmlyc3QgPSAtMTtcbiAgICAgICAgbGV0IGJGaXJzdCA9IDE7XG5cbiAgICAgICAgYSA9IGV4cG9ydHMudmVyc2lvbihhLCBvcHRpb25zKTtcbiAgICAgICAgYiA9IGV4cG9ydHMudmVyc2lvbihiLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBNYXJrIGluY29tcGF0aWJsZSBwcmVyZWxlYXNlc1xuXG4gICAgICAgIGlmIChvcHRpb25zLnJhbmdlICYmXG4gICAgICAgICAgICBhLnByZXJlbGVhc2UubGVuZ3RoICYmXG4gICAgICAgICAgICAoYS5tYWpvciAhPT0gYi5tYWpvciB8fCBhLm1pbm9yICE9PSBiLm1pbm9yIHx8IGEucGF0Y2ggIT09IGIucGF0Y2ggfHwgIWIucHJlcmVsZWFzZS5sZW5ndGgpKSB7XG5cbiAgICAgICAgICAgIGFGaXJzdCA9IC0yO1xuICAgICAgICAgICAgYkZpcnN0ID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgdmVyc2lvbnNcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYXYgPSBhLmRvdHNbaV07XG4gICAgICAgICAgICBjb25zdCBidiA9IGIuZG90c1tpXTtcblxuICAgICAgICAgICAgaWYgKGF2ID09PSBidiB8fFxuICAgICAgICAgICAgICAgIGF2ID09PSBpbnRlcm5hbHMuYW55IHx8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaWxkY2FyZCBpcyBlcXVhbCB0byBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgYnYgPT09IGludGVybmFscy5hbnkpIHtcblxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYXYgLSBidiA8IDAgPyBhRmlyc3QgOiBiRmlyc3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIHByZXJlbGVhc2VcblxuICAgICAgICBpZiAoIWEucHJlcmVsZWFzZS5sZW5ndGggJiZcbiAgICAgICAgICAgICFiLnByZXJlbGVhc2UubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhYS5wcmVyZWxlYXNlLmxlbmd0aCAhPT0gISFiLnByZXJlbGVhc2UubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGEucHJlcmVsZWFzZS5sZW5ndGggPyBhRmlyc3QgOiBiRmlyc3QpOyAgICAgICAgIC8vIHByZXJlbGVhc2UgPCBub25lXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGFpID0gYS5wcmVyZWxlYXNlW2ldO1xuICAgICAgICAgICAgY29uc3QgYmkgPSBiLnByZXJlbGVhc2VbaV07XG5cbiAgICAgICAgICAgIGlmIChhaSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgYmkgPT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhaSA9PT0gYmkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYUZpcnN0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiRmlyc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFuID0gTnVtYmVyLmlzRmluaXRlKGFpKTtcbiAgICAgICAgICAgIGNvbnN0IGJuID0gTnVtYmVyLmlzRmluaXRlKGJpKTtcblxuICAgICAgICAgICAgaWYgKGFuICE9PSBibikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbiA/IGFGaXJzdCA6IGJGaXJzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChhIDwgYiA/IGFGaXJzdCA6IGJGaXJzdCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5kb3QgPSAodikgPT4ge1xuXG4gICAgcmV0dXJuICh2ID09PSBpbnRlcm5hbHMuYW55ID8gJ3gnIDogdik7XG59O1xuXG5cbmludGVybmFscy50b2tlbiA9ICh2LCBwcmVmaXgpID0+IHtcblxuICAgIGlmICghdi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBgJHtwcmVmaXh9JHt2LmpvaW4oJy4nKX1gO1xufTtcblxuXG5pbnRlcm5hbHMuUmFuZ2UgPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgb3B0aW9ucykge1xuXG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7ICAgIC8vIFNoYWxsb3cgY2xvbmVkXG4gICAgICAgIHRoaXMuX2FueXRoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29yID0gW107ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFthbmQsIGFuZCwgLi4uLCBhY3RpdmVdXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGF0dGVybihyYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hbm90aGVyKCk7XG4gICAgfVxuXG4gICAgX2Fub3RoZXIoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9hY3RpdmUgfHxcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZS5ydWxlcy5sZW5ndGgpIHtcblxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0geyBydWxlczogW10gfTtcbiAgICAgICAgICAgIHRoaXMuX29yLnB1c2godGhpcy5fYWN0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9ydWxlKG9wZXJhdG9yLCB2ZXJzaW9uKSB7XG5cbiAgICAgICAgdmVyc2lvbiA9IGV4cG9ydHMudmVyc2lvbih2ZXJzaW9uLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgICAgY29uc3QgY29tcGFyZSA9IGludGVybmFscy5vcGVyYXRvcihvcGVyYXRvcik7XG4gICAgICAgIHRoaXMuX2FjdGl2ZS5ydWxlcy5wdXNoKHsgY29tcGFyZSwgdmVyc2lvbiwgb3BlcmF0b3IgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IG9yKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9hbm90aGVyKCk7XG4gICAgfVxuXG4gICAgZXF1YWwodmVyc2lvbikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlKCc9JywgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgYWJvdmUodmVyc2lvbikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlKCc+JywgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgYmVsb3codmVyc2lvbikge1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlKCc8JywgdmVyc2lvbik7XG4gICAgfVxuXG4gICAgYmV0d2Vlbihmcm9tLCB0bykge1xuXG4gICAgICAgIHRoaXMuX3J1bGUoJz49JywgZnJvbSk7XG4gICAgICAgIHRoaXMuX3J1bGUoJzw9JywgdG8pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBtaW5vcih2ZXJzaW9uKSB7ICAgICAgICAvLyB+MS4yLjNcblxuICAgICAgICAvLyBtaW5vcigyLjUuNykgICAgIC0+ICAgICAgMi41LjcgPD0gWCA8IDIuNi4wXG4gICAgICAgIC8vIG1pbm9yKDIuNS54KSAgICAgLT4gICAgICAyLjUuMCA8PSBYIDwgMi42LjBcbiAgICAgICAgLy8gbWlub3IoMi54LngpICAgICAtPiAgICAgIDIuMC4wIDw9IFggPCAzLjAuMFxuXG4gICAgICAgIHZlcnNpb24gPSBleHBvcnRzLnZlcnNpb24odmVyc2lvbiwgdGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uLm1ham9yID09PSBpbnRlcm5hbHMuYW55KSB7XG4gICAgICAgICAgICB0aGlzLl9ydWxlKCc9JywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3J1bGUoJz49JywgdmVyc2lvbik7XG5cbiAgICAgICAgaWYgKHZlcnNpb24ubWlub3IgPT09IGludGVybmFscy5hbnkpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bGUoJzwnLCB7IG1ham9yOiB2ZXJzaW9uLm1ham9yICsgMSwgbWlub3I6IDAsIHBhdGNoOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcnVsZSgnPCcsIHsgbWFqb3I6IHZlcnNpb24ubWFqb3IsIG1pbm9yOiB2ZXJzaW9uLm1pbm9yICsgMSwgcGF0Y2g6IDAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb21wYXRpYmxlKHZlcnNpb24pIHsgICAgICAgLy8gXjEuMi4zXG5cbiAgICAgICAgLy8gY29tcGF0aWJsZSgyLjUuNykgICAgIC0+ICAgICAgMi41LjcgPD0gWCA8IDMuMC4wXG4gICAgICAgIC8vIGNvbXBhdGlibGUoMi54LngpICAgICAtPiAgICAgIDIuMC4wIDw9IFggPCAzLjAuMFxuICAgICAgICAvLyBjb21wYXRpYmxlKDAuMS54KSAgICAgLT4gICAgICAwLjEuMCA8PSBYIDwgMC4yLjBcblxuICAgICAgICB2ZXJzaW9uID0gZXhwb3J0cy52ZXJzaW9uKHZlcnNpb24sIHRoaXMuX3NldHRpbmdzKTtcblxuICAgICAgICBpZiAodmVyc2lvbi5tYWpvciA9PT0gaW50ZXJuYWxzLmFueSkge1xuICAgICAgICAgICAgdGhpcy5fcnVsZSgnPScsIHZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ydWxlKCc+PScsIHZlcnNpb24pO1xuXG4gICAgICAgIGlmICh2ZXJzaW9uLm1ham9yID09PSAwICYmXG4gICAgICAgICAgICB2ZXJzaW9uLm1pbm9yICE9PSBpbnRlcm5hbHMuYW55KSB7XG5cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLm1pbm9yID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnVsZSgnPCcsIHsgbWFqb3I6IDAsIG1pbm9yOiAwLCBwYXRjaDogdmVyc2lvbi5wYXRjaCArIDEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ydWxlKCc8JywgeyBtYWpvcjogMCwgbWlub3I6IHZlcnNpb24ubWlub3IgKyAxLCBwYXRjaDogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bGUoJzwnLCB7IG1ham9yOiB2ZXJzaW9uLm1ham9yICsgMSwgbWlub3I6IDAsIHBhdGNoOiAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcGF0dGVybihyYW5nZSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9wYXR0ZXJuKHJhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByYW5nZTogXCIke3JhbmdlfVwiIGJlY2F1c2U6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcGF0dGVybihyYW5nZSkge1xuXG4gICAgICAgIGlmIChyYW5nZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuX2FueXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBpbnRlcm5hbHMubm9ybWFsaXplKHJhbmdlKTtcbiAgICAgICAgY29uc3Qgb3JzID0gbm9ybWFsaXplZC5zcGxpdCgvXFxzKlxcfFxcfFxccyovKTtcbiAgICAgICAgZm9yIChjb25zdCBjb25kaXRpb24gb2Ygb3JzKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FueXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2Fub3RoZXIoKTtcblxuICAgICAgICAgICAgY29uc3QgYW5kcyA9IGNvbmRpdGlvbi5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhbmQgb2YgYW5kcykge1xuXG4gICAgICAgICAgICAgICAgLy8gSHlwaGVuIHJhbmdlXG5cbiAgICAgICAgICAgICAgICBjb25zdCBoeXBoZW4gPSBhbmQuaW5kZXhPZignQCcpOyAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgXCIgLSBcIlxuICAgICAgICAgICAgICAgIGlmIChoeXBoZW4gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBhbmQuc2xpY2UoMCwgaHlwaGVuKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBhbmQuc2xpY2UoaHlwaGVuICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmV0d2Vlbihmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFByZWZpeFxuXG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBhbmQubWF0Y2goL14oXFxefH58PFxcPXw+XFw9fDx8PnxcXD0pPyguKykkLyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gZXhwb3J0cy52ZXJzaW9uKHBhcnRzWzJdLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbi53aWxkY2FyZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbnl0aGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaWxkZVxuXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnficpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW5vcih2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FyZXRcblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gJ14nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGF0aWJsZSh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT25lIHNpZGVkIHJhbmdlXG5cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVsZShvcGVyYXRvciwgdmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFZlcnNpb25cblxuICAgICAgICAgICAgICAgIHRoaXMuZXF1YWwodmVyc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYXRjaCh2ZXJzaW9uKSB7XG5cbiAgICAgICAgdmVyc2lvbiA9IGV4cG9ydHMudmVyc2lvbih2ZXJzaW9uLCB0aGlzLl9zZXR0aW5ncyk7ICAgICAgIC8vIEFsd2F5cyBwYXJzZSB0byB2YWxpZGF0ZVxuXG4gICAgICAgIGlmICh0aGlzLl9hbnl0aGluZykge1xuICAgICAgICAgICAgcmV0dXJuICF2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCB7IHJ1bGVzIH0gb2YgdGhpcy5fb3IpIHtcbiAgICAgICAgICAgIGlmICghcnVsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBtYXRjaGVzID0gMDtcbiAgICAgICAgICAgIGxldCBleGNsdWRlcyA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmUgPSB2ZXJzaW9uLmNvbXBhcmUocnVsZS52ZXJzaW9uLCBPYmplY3QuYXNzaWduKHRoaXMuX3NldHRpbmdzLCB7IHJhbmdlOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlID0gTWF0aC5hYnMoY29tcGFyZSkgPT09IDI7XG5cbiAgICAgICAgICAgICAgICBpZiAocnVsZS5jb21wYXJlLmluY2x1ZGVzKGNvbXBhcmUgLyAoZXhjbHVkZSA/IDIgOiAxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKyttYXRjaGVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKytleGNsdWRlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlcyA9PT0gcnVsZXMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgZXhjbHVkZXMgPCBtYXRjaGVzKSB7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcblxuICAgICAgICBpZiAodGhpcy5fYW55dGhpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnKic7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgeyBydWxlcyB9IG9mIHRoaXMuX29yKSB7XG4gICAgICAgICAgICBpZiAoIXJ1bGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goYCR7cnVsZS5vcGVyYXRvciAhPT0gJz0nID8gcnVsZS5vcGVyYXRvciA6ICcnfSR7cnVsZS52ZXJzaW9uLnZlcnNpb259YCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0cmluZyArPSAoc3RyaW5nID8gJ3x8JyA6ICcnKSArIGNvbmRpdGlvbnMuam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5vcGVyYXRvciA9IGZ1bmN0aW9uIChjb21wYXJlKSB7XG5cbiAgICBzd2l0Y2ggKGNvbXBhcmUpIHtcbiAgICAgICAgY2FzZSAnPSc6IHJldHVybiBbMF07XG4gICAgICAgIGNhc2UgJz4nOiByZXR1cm4gWzFdO1xuICAgICAgICBjYXNlICc+PSc6IHJldHVybiBbMCwgMV07XG4gICAgICAgIGNhc2UgJzwnOiByZXR1cm4gWy0xXTtcbiAgICAgICAgY2FzZSAnPD0nOiByZXR1cm4gWzAsIC0xXTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5ub3JtYWxpemUgPSBmdW5jdGlvbiAocmFuZ2UpIHtcblxuICAgIHJldHVybiByYW5nZVxuICAgICAgICAucmVwbGFjZSgvIFxcLSAvZywgJ0AnKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSYW5nZSB0byBleGNsdWRlZCBzeW1ib2xcbiAgICAgICAgLnJlcGxhY2UoL34+L2csICd+JykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZWdhY3kgbnBtIG9wZXJhdG9yXG4gICAgICAgIC5yZXBsYWNlKC8oXFxefH58PFxcPXw+XFw9fDx8PnxcXD0pXFxzKihbXlxcc10rKS9nLCAoJDAsICQxLCAkMikgPT4gYCR7JDF9JHskMn1gKTsgICAgLy8gU3BhY2UgYmV0d2VlbiBvcGVyYXRvciBhbmQgdmVyc2lvblxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgUXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91bmNlID0gcmVxdWlyZSgnQGhhcGkvYm91bmNlJyk7XG5jb25zdCBCb3VybmUgPSByZXF1aXJlKCdAaGFwaS9ib3VybmUnKTtcbmNvbnN0IENyeXB0aWxlcyA9IHJlcXVpcmUoJ0BoYXBpL2NyeXB0aWxlcycpO1xuY29uc3QgSG9layA9IHJlcXVpcmUoJ0BoYXBpL2hvZWsnKTtcbmNvbnN0IElyb24gPSByZXF1aXJlKCdAaGFwaS9pcm9uJyk7XG5jb25zdCBKb2kgPSByZXF1aXJlKCdAaGFwaS9qb2knKTtcblxuXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcblxuXG5pbnRlcm5hbHMuc2NoZW1hID0gSm9pLm9iamVjdCh7XG4gICAgc3RyaWN0SGVhZGVyOiBKb2kuYm9vbGVhbigpLFxuICAgIGlnbm9yZUVycm9yczogSm9pLmJvb2xlYW4oKSxcbiAgICBpc1NlY3VyZTogSm9pLmJvb2xlYW4oKSxcbiAgICBpc0h0dHBPbmx5OiBKb2kuYm9vbGVhbigpLFxuICAgIGlzU2FtZVNpdGU6IEpvaS52YWxpZCgnU3RyaWN0JywgJ0xheCcpLmFsbG93KGZhbHNlKSxcbiAgICBwYXRoOiBKb2kuc3RyaW5nKCkuYWxsb3cobnVsbCksXG4gICAgZG9tYWluOiBKb2kuc3RyaW5nKCkuYWxsb3cobnVsbCksXG4gICAgdHRsOiBKb2kubnVtYmVyKCkuYWxsb3cobnVsbCksXG4gICAgZW5jb2Rpbmc6IEpvaS5zdHJpbmcoKS52YWxpZCgnYmFzZTY0anNvbicsICdiYXNlNjQnLCAnZm9ybScsICdpcm9uJywgJ25vbmUnKSxcbiAgICBzaWduOiBKb2kub2JqZWN0KHtcbiAgICAgICAgcGFzc3dvcmQ6IFtKb2kuc3RyaW5nKCksIEpvaS5iaW5hcnkoKSwgSm9pLm9iamVjdCgpXSxcbiAgICAgICAgaW50ZWdyaXR5OiBKb2kub2JqZWN0KClcbiAgICB9KSxcbiAgICBpcm9uOiBKb2kub2JqZWN0KCksXG4gICAgcGFzc3dvcmQ6IFtKb2kuc3RyaW5nKCksIEpvaS5iaW5hcnkoKSwgSm9pLm9iamVjdCgpXSxcblxuICAgIC8vIFVzZWQgYnkgaGFwaVxuXG4gICAgY2xlYXJJbnZhbGlkOiBKb2kuYm9vbGVhbigpLFxuICAgIGF1dG9WYWx1ZTogSm9pLmFueSgpLFxuICAgIHBhc3NUaHJvdWdoOiBKb2kuYm9vbGVhbigpXG59KTtcblxuXG5pbnRlcm5hbHMuZGVmYXVsdHMgPSB7XG4gICAgc3RyaWN0SGVhZGVyOiB0cnVlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVxdWlyZSBhbiBSRkMgNjI2NSBjb21wbGlhbnQgaGVhZGVyIGZvcm1hdFxuICAgIGlnbm9yZUVycm9yczogZmFsc2UsXG4gICAgaXNTZWN1cmU6IHRydWUsXG4gICAgaXNIdHRwT25seTogdHJ1ZSxcbiAgICBpc1NhbWVTaXRlOiAnU3RyaWN0JyxcbiAgICBwYXRoOiBudWxsLFxuICAgIGRvbWFpbjogbnVsbCxcbiAgICB0dGw6IG51bGwsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNU2VjcywgMCBtZWFucyByZW1vdmVcbiAgICBlbmNvZGluZzogJ25vbmUnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpb25zOiAnYmFzZTY0anNvbicsICdiYXNlNjQnLCAnZm9ybScsICdpcm9uJywgJ25vbmUnXG59O1xuXG5cbmV4cG9ydHMuRGVmaW5pdGlvbnMgPSBpbnRlcm5hbHMuRGVmaW5pdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXG4gICAgdGhpcy5zZXR0aW5ncyA9IEhvZWsuYXBwbHlUb0RlZmF1bHRzKGludGVybmFscy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG4gICAgSm9pLmFzc2VydCh0aGlzLnNldHRpbmdzLCBpbnRlcm5hbHMuc2NoZW1hLCAnSW52YWxpZCBzdGF0ZSBkZWZpbml0aW9uIGRlZmF1bHRzJyk7XG5cbiAgICB0aGlzLmNvb2tpZXMgPSB7fTtcbiAgICB0aGlzLm5hbWVzID0gW107XG59O1xuXG5cbmludGVybmFscy5EZWZpbml0aW9ucy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5hbWUsIG9wdGlvbnMpIHtcblxuICAgIEhvZWsuYXNzZXJ0KG5hbWUgJiYgdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBuYW1lJyk7XG4gICAgSG9lay5hc3NlcnQoIXRoaXMuY29va2llc1tuYW1lXSwgJ1N0YXRlIGFscmVhZHkgZGVmaW5lZDonLCBuYW1lKTtcblxuICAgIGNvbnN0IHNldHRpbmdzID0gSG9lay5hcHBseVRvRGVmYXVsdHModGhpcy5zZXR0aW5ncywgb3B0aW9ucyB8fCB7fSwgeyBudWxsT3ZlcnJpZGU6IHRydWUgfSk7XG4gICAgSm9pLmFzc2VydChzZXR0aW5ncywgaW50ZXJuYWxzLnNjaGVtYSwgJ0ludmFsaWQgc3RhdGUgZGVmaW5pdGlvbjogJyArIG5hbWUpO1xuXG4gICAgdGhpcy5jb29raWVzW25hbWVdID0gc2V0dGluZ3M7XG4gICAgdGhpcy5uYW1lcy5wdXNoKG5hbWUpO1xufTtcblxuXG5pbnRlcm5hbHMuZW1wdHkgPSBuZXcgaW50ZXJuYWxzLkRlZmluaXRpb25zKCk7XG5cblxuLy8gSGVhZGVyIGZvcm1hdFxuXG4vLyAgICAgICAgICAgICAgICAgICAgICAxOiBuYW1lICAgICAgICAgICAgICAgIDI6IHF1b3RlZCAgMzogdmFsdWVcbmludGVybmFscy5wYXJzZVJ4ID0gL1xccyooW149XFxzXSopXFxzKj1cXHMqKD86KD86XCIoW15cXFwiXSopXCIpfChbXlxcO10qKSkoPzooPzo7XFxzKil8JCkvZztcblxuaW50ZXJuYWxzLnZhbGlkYXRlUnggPSB7XG4gICAgbmFtZVJ4OiB7XG4gICAgICAgIHN0cmljdDogL15bXlxceDAwLVxceDIwXFwoXFwpPD5AXFwsO1xcOlxcXFxcIlxcL1xcW1xcXVxcP1xcPVxce1xcfVxceDdGXSskLyxcbiAgICAgICAgbG9vc2U6IC9eW149XFxzXSokL1xuICAgIH0sXG4gICAgdmFsdWVSeDoge1xuICAgICAgICBzdHJpY3Q6IC9eW15cXHgwMC1cXHgyMFxcXCJcXCxcXDtcXFxcXFx4N0ZdKiQvLFxuICAgICAgICBsb29zZTogL14oPzpcIihbXlxcXCJdKilcIil8KD86W15cXDtdKikkL1xuICAgIH0sXG4gICAgZG9tYWluUng6IC9eXFwuP1thLXpcXGRdKyg/Oig/OlthLXpcXGRdKil8KD86W2EtelxcZFxcLV0qW2EtelxcZF0pKSg/OlxcLlthLXpcXGRdKyg/Oig/OlthLXpcXGRdKil8KD86W2EtelxcZFxcLV0qW2EtelxcZF0pKSkqJC8sXG4gICAgZG9tYWluTGFiZWxMZW5SeDogL15cXC4/W2EtelxcZFxcLV17MSw2M30oPzpcXC5bYS16XFxkXFwtXXsxLDYzfSkqJC8sXG4gICAgcGF0aFJ4OiAvXlxcL1teXFx4MDAtXFx4MUZcXDtdKiQvXG59O1xuXG4vLyAgICAgICAgICAgICAgICAgICAgICAxOiBuYW1lICAgICAgICAgMjogdmFsdWVcbmludGVybmFscy5wYWlyc1J4ID0gL1xccyooW149XFxzXSopXFxzKj1cXHMqKFteXFw7XSopKD86KD86O1xccyopfCQpL2c7XG5cblxuaW50ZXJuYWxzLkRlZmluaXRpb25zLnByb3RvdHlwZS5wYXJzZSA9IGFzeW5jIGZ1bmN0aW9uIChjb29raWVzKSB7XG5cbiAgICBjb25zdCBzdGF0ZSA9IHt9O1xuICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgY29uc3QgdmVyaWZ5ID0gY29va2llcy5yZXBsYWNlKGludGVybmFscy5wYXJzZVJ4LCAoJDAsICQxLCAkMiwgJDMpID0+IHtcblxuICAgICAgICBjb25zdCBuYW1lID0gJDE7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gJDIgfHwgJDMgfHwgJyc7XG5cbiAgICAgICAgaWYgKHN0YXRlW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGVbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVbbmFtZV0gPSBbc3RhdGVbbmFtZV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdGF0ZVtuYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuXG4gICAgLy8gVmFsaWRhdGUgY29va2llIGhlYWRlciBzeW50YXhcblxuICAgIGNvbnN0IGZhaWxlZCA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbCBlcnJvcnNcblxuICAgIGlmICh2ZXJpZnkgIT09ICcnKSB7XG4gICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb29raWUgaGVhZGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmYWlsZWQucHVzaCh7IHNldHRpbmdzOiB0aGlzLnNldHRpbmdzLCByZWFzb246IGBIZWFkZXIgY29udGFpbnMgdW5leHBlY3RlZCBzeW50YXg6ICR7dmVyaWZ5fWAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29sbGVjdCBlcnJvcnNcblxuICAgIGNvbnN0IGVycm9yZWQgPSBbXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVuaWdub3JlZCBlcnJvcnNcbiAgICBjb25zdCByZWNvcmQgPSAocmVhc29uLCBuYW1lLCB2YWx1ZSwgZGVmaW5pdGlvbikgPT4ge1xuXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBzZXR0aW5nczogZGVmaW5pdGlvbixcbiAgICAgICAgICAgIHJlYXNvbjogdHlwZW9mIHJlYXNvbiA9PT0gJ3N0cmluZycgPyByZWFzb24gOiByZWFzb24ubWVzc2FnZVxuICAgICAgICB9O1xuXG4gICAgICAgIGZhaWxlZC5wdXNoKGRldGFpbHMpO1xuICAgICAgICBpZiAoIWRlZmluaXRpb24uaWdub3JlRXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcmVkLnB1c2goZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUGFyc2UgY29va2llc1xuXG4gICAgY29uc3QgcGFyc2VkID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3RhdGVbbmFtZV07XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLmNvb2tpZXNbbmFtZV0gfHwgdGhpcy5zZXR0aW5ncztcblxuICAgICAgICAvLyBWYWxpZGF0ZSBjb29raWVcblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5zdHJpY3RIZWFkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGludGVybmFscy52YWxpZGF0ZShuYW1lLCBzdGF0ZSk7XG4gICAgICAgICAgICBpZiAocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkKHJlYXNvbiwgbmFtZSwgdmFsdWUsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgY29va2llIGZvcm1hdFxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmVuY29kaW5nID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHBhcnNlZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5nbGUgdmFsdWVcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkID0gYXdhaXQgaW50ZXJuYWxzLnVuc2lnbihuYW1lLCB2YWx1ZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW50ZXJuYWxzLmRlY29kZSh1bnNpZ25lZCwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgcGFyc2VkW25hbWVdID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICAgICAgICAgIHJlY29yZChlcnIsIG5hbWUsIHZhbHVlLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcnJheVxuXG4gICAgICAgIGNvbnN0IGFycmF5UmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSB2YWx1ZVtqXTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bnNpZ25lZCA9IGF3YWl0IGludGVybmFscy51bnNpZ24obmFtZSwgYXJyYXlWYWx1ZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaW50ZXJuYWxzLmRlY29kZSh1bnNpZ25lZCwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgYXJyYXlSZXN1bHQucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIEJvdW5jZS5yZXRocm93KGVyciwgJ3N5c3RlbScpO1xuICAgICAgICAgICAgICAgIHJlY29yZChlcnIsIG5hbWUsIHZhbHVlLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlZFtuYW1lXSA9IGFycmF5UmVzdWx0O1xuICAgIH1cblxuICAgIGlmIChlcnJvcmVkLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBjb29raWUgdmFsdWUnLCBlcnJvcmVkKTtcbiAgICAgICAgZXJyb3Iuc3RhdGVzID0gcGFyc2VkO1xuICAgICAgICBlcnJvci5mYWlsZWQgPSBmYWlsZWQ7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXRlczogcGFyc2VkLCBmYWlsZWQgfTtcbn07XG5cblxuaW50ZXJuYWxzLnZhbGlkYXRlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXRlKSB7XG5cbiAgICBpZiAoIW5hbWUubWF0Y2goaW50ZXJuYWxzLnZhbGlkYXRlUngubmFtZVJ4LnN0cmljdCkpIHtcbiAgICAgICAgcmV0dXJuICdJbnZhbGlkIGNvb2tpZSBuYW1lJztcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZXMgPSBbXS5jb25jYXQoc3RhdGVbbmFtZV0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghdmFsdWVzW2ldLm1hdGNoKGludGVybmFscy52YWxpZGF0ZVJ4LnZhbHVlUnguc3RyaWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnZhbGlkIGNvb2tpZSB2YWx1ZSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLm1hY1ByZWZpeCA9ICdoYXBpLnNpZ25lZC5jb29raWUuMSc7XG5cblxuaW50ZXJuYWxzLnVuc2lnbiA9IGFzeW5jIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZGVmaW5pdGlvbikge1xuXG4gICAgaWYgKCFkZWZpbml0aW9uLnNpZ24pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcyA9IHZhbHVlLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgQm9vbS5iYWRSZXF1ZXN0KCdNaXNzaW5nIHNpZ25hdHVyZSBzZXBhcmF0b3InKTtcbiAgICB9XG5cbiAgICBjb25zdCB1bnNpZ25lZCA9IHZhbHVlLnNsaWNlKDAsIHBvcyk7XG4gICAgY29uc3Qgc2lnID0gdmFsdWUuc2xpY2UocG9zICsgMSk7XG5cbiAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ01pc3Npbmcgc2lnbmF0dXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2lnUGFydHMgPSBzaWcuc3BsaXQoJyonKTtcbiAgICBpZiAoc2lnUGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBzaWduYXR1cmUgZm9ybWF0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgaG1hY1NhbHQgPSBzaWdQYXJ0c1swXTtcbiAgICBjb25zdCBobWFjID0gc2lnUGFydHNbMV07XG5cbiAgICBjb25zdCBtYWNPcHRpb25zID0gSG9lay5jbG9uZShkZWZpbml0aW9uLnNpZ24uaW50ZWdyaXR5IHx8IElyb24uZGVmYXVsdHMuaW50ZWdyaXR5KTtcbiAgICBtYWNPcHRpb25zLnNhbHQgPSBobWFjU2FsdDtcbiAgICBjb25zdCBtYWMgPSBhd2FpdCBJcm9uLmhtYWNXaXRoUGFzc3dvcmQoZGVmaW5pdGlvbi5zaWduLnBhc3N3b3JkLCBtYWNPcHRpb25zLCBbaW50ZXJuYWxzLm1hY1ByZWZpeCwgbmFtZSwgdW5zaWduZWRdLmpvaW4oJ1xcbicpKTtcbiAgICBpZiAoIUNyeXB0aWxlcy5maXhlZFRpbWVDb21wYXJpc29uKG1hYy5kaWdlc3QsIGhtYWMpKSB7XG4gICAgICAgIHRocm93IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCBobWFjIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuc2lnbmVkO1xufTtcblxuXG5pbnRlcm5hbHMuZGVjb2RlID0gYXN5bmMgZnVuY3Rpb24gKHZhbHVlLCBkZWZpbml0aW9uKSB7XG5cbiAgICBpZiAoIXZhbHVlICYmXG4gICAgICAgIGRlZmluaXRpb24uZW5jb2RpbmcgPT09ICdmb3JtJykge1xuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBIb2VrLmFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLCAnSW52YWxpZCBzdHJpbmcnKTtcblxuICAgIC8vIEVuY29kaW5nczogJ2Jhc2U2NGpzb24nLCAnYmFzZTY0JywgJ2Zvcm0nLCAnaXJvbicsICdub25lJ1xuXG4gICAgaWYgKGRlZmluaXRpb24uZW5jb2RpbmcgPT09ICdpcm9uJykge1xuICAgICAgICByZXR1cm4gYXdhaXQgSXJvbi51bnNlYWwodmFsdWUsIGRlZmluaXRpb24ucGFzc3dvcmQsIGRlZmluaXRpb24uaXJvbiB8fCBJcm9uLmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAoZGVmaW5pdGlvbi5lbmNvZGluZyA9PT0gJ2Jhc2U2NGpzb24nKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSAoQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKSkudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJvdXJuZS5wYXJzZShkZWNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgSlNPTiBwYXlsb2FkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVmaW5pdGlvbi5lbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgcmV0dXJuIChCdWZmZXIuZnJvbSh2YWx1ZSwgJ2Jhc2U2NCcpKS50b1N0cmluZygnYmluYXJ5Jyk7XG4gICAgfVxuXG4gICAgLy8gZW5jb2Rpbmc6ICdmb3JtJ1xuXG4gICAgcmV0dXJuIFF1ZXJ5c3RyaW5nLnBhcnNlKHZhbHVlKTtcbn07XG5cblxuaW50ZXJuYWxzLkRlZmluaXRpb25zLnByb3RvdHlwZS5mb3JtYXQgPSBhc3luYyBmdW5jdGlvbiAoY29va2llcykge1xuXG4gICAgaWYgKCFjb29raWVzIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KGNvb2tpZXMpICYmICFjb29raWVzLmxlbmd0aCkpIHtcblxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb2tpZXMpKSB7XG4gICAgICAgIGNvb2tpZXMgPSBbY29va2llc107XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZGVyID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb29raWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNvb2tpZSA9IGNvb2tpZXNbaV07XG5cbiAgICAgICAgLy8gQXBwbHkgZGVmaW5pdGlvbiB0byBsb2NhbCBjb25maWd1cmF0aW9uXG5cbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuY29va2llc1tjb29raWUubmFtZV0gfHwgdGhpcy5zZXR0aW5ncztcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvb2tpZS5vcHRpb25zID8gSG9lay5hcHBseVRvRGVmYXVsdHMoYmFzZSwgY29va2llLm9wdGlvbnMsIHsgbnVsbE92ZXJyaWRlOiB0cnVlIH0pIDogYmFzZTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSBuYW1lXG5cbiAgICAgICAgY29uc3QgbmFtZVJ4ID0gKGRlZmluaXRpb24uc3RyaWN0SGVhZGVyID8gaW50ZXJuYWxzLnZhbGlkYXRlUngubmFtZVJ4LnN0cmljdCA6IGludGVybmFscy52YWxpZGF0ZVJ4Lm5hbWVSeC5sb29zZSk7XG4gICAgICAgIGlmICghbmFtZVJ4LnRlc3QoY29va2llLm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdJbnZhbGlkIGNvb2tpZSBuYW1lOiAnICsgY29va2llLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcGFyZSB2YWx1ZSAoZW5jb2RlLCBzaWduKVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhwb3J0cy5wcmVwYXJlVmFsdWUoY29va2llLm5hbWUsIGNvb2tpZS52YWx1ZSwgZGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgcHJlcGFyZWQgdmFsdWVcblxuICAgICAgICBjb25zdCB2YWx1ZVJ4ID0gKGRlZmluaXRpb24uc3RyaWN0SGVhZGVyID8gaW50ZXJuYWxzLnZhbGlkYXRlUngudmFsdWVSeC5zdHJpY3QgOiBpbnRlcm5hbHMudmFsaWRhdGVSeC52YWx1ZVJ4Lmxvb3NlKTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2godmFsdWVSeCkpKSB7XG5cbiAgICAgICAgICAgIHRocm93IEJvb20uYmFkSW1wbGVtZW50YXRpb24oJ0ludmFsaWQgY29va2llIHZhbHVlOiAnICsgY29va2llLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnN0cnVjdCBjb29raWVcblxuICAgICAgICBsZXQgc2VnbWVudCA9IGNvb2tpZS5uYW1lICsgJz0nICsgKHZhbHVlIHx8ICcnKTtcblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi50dGwgIT09IG51bGwgJiZcbiAgICAgICAgICAgIGRlZmluaXRpb24udHRsICE9PSB1bmRlZmluZWQpIHsgICAgICAgICAgICAvLyBDYW4gYmUgemVyb1xuXG4gICAgICAgICAgICBjb25zdCBleHBpcmVzID0gbmV3IERhdGUoZGVmaW5pdGlvbi50dGwgPyBEYXRlLm5vdygpICsgZGVmaW5pdGlvbi50dGwgOiAwKTtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50ICsgJzsgTWF4LUFnZT0nICsgTWF0aC5mbG9vcihkZWZpbml0aW9uLnR0bCAvIDEwMDApICsgJzsgRXhwaXJlcz0nICsgZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uaXNTZWN1cmUpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50ICsgJzsgU2VjdXJlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmlzSHR0cE9ubHkpIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50ICsgJzsgSHR0cE9ubHknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uaXNTYW1lU2l0ZSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQgKyBgOyBTYW1lU2l0ZT0ke2RlZmluaXRpb24uaXNTYW1lU2l0ZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlZmluaXRpb24uZG9tYWluKSB7XG4gICAgICAgICAgICBjb25zdCBkb21haW4gPSBkZWZpbml0aW9uLmRvbWFpbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKCFkb21haW4ubWF0Y2goaW50ZXJuYWxzLnZhbGlkYXRlUnguZG9tYWluTGFiZWxMZW5SeCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdDb29raWUgZG9tYWluIHRvbyBsb25nOiAnICsgZGVmaW5pdGlvbi5kb21haW4pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRvbWFpbi5tYXRjaChpbnRlcm5hbHMudmFsaWRhdGVSeC5kb21haW5SeCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdJbnZhbGlkIGNvb2tpZSBkb21haW46ICcgKyBkZWZpbml0aW9uLmRvbWFpbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50ICsgJzsgRG9tYWluPScgKyBkb21haW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5wYXRoKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmluaXRpb24ucGF0aC5tYXRjaChpbnRlcm5hbHMudmFsaWRhdGVSeC5wYXRoUngpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQm9vbS5iYWRJbXBsZW1lbnRhdGlvbignSW52YWxpZCBjb29raWUgcGF0aDogJyArIGRlZmluaXRpb24ucGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50ICsgJzsgUGF0aD0nICsgZGVmaW5pdGlvbi5wYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaGVhZGVyLnB1c2goc2VnbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcjtcbn07XG5cblxuZXhwb3J0cy5wcmVwYXJlVmFsdWUgPSBhc3luYyBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnLCAnTWlzc2luZyBvciBpbnZhbGlkIG9wdGlvbnMnKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBhd2FpdCBpbnRlcm5hbHMuZW5jb2RlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gYXdhaXQgaW50ZXJuYWxzLnNpZ24obmFtZSwgZW5jb2RlZCwgb3B0aW9ucy5zaWduKTtcbiAgICAgICAgcmV0dXJuIHNpZ25lZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBCb29tLmJhZEltcGxlbWVudGF0aW9uKCdGYWlsZWQgdG8gZW5jb2RlIGNvb2tpZSAoJyArIG5hbWUgKyAnKSB2YWx1ZTogJyArIGVyci5tZXNzYWdlKTtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5lbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcblxuICAgIC8vIEVuY29kaW5nczogJ2Jhc2U2NGpzb24nLCAnYmFzZTY0JywgJ2Zvcm0nLCAnaXJvbicsICdub25lJ1xuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgb3B0aW9ucy5lbmNvZGluZyA9PT0gJ25vbmUnKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnaXJvbicpIHtcbiAgICAgICAgcmV0dXJuIElyb24uc2VhbCh2YWx1ZSwgb3B0aW9ucy5wYXNzd29yZCwgb3B0aW9ucy5pcm9uIHx8IElyb24uZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgICAgICByZXR1cm4gKEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmluYXJ5JykpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2Jhc2U2NGpzb24nKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICByZXR1cm4gKEJ1ZmZlci5mcm9tKHN0cmluZ2lmaWVkLCAnYmluYXJ5JykpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICAvLyBlbmNvZGluZzogJ2Zvcm0nXG5cbiAgICByZXR1cm4gUXVlcnlzdHJpbmcuc3RyaW5naWZ5KHZhbHVlKTtcbn07XG5cblxuaW50ZXJuYWxzLnNpZ24gPSBhc3luYyBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICFvcHRpb25zKSB7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IG1hYyA9IGF3YWl0IElyb24uaG1hY1dpdGhQYXNzd29yZChvcHRpb25zLnBhc3N3b3JkLCBvcHRpb25zLmludGVncml0eSB8fCBJcm9uLmRlZmF1bHRzLmludGVncml0eSwgW2ludGVybmFscy5tYWNQcmVmaXgsIG5hbWUsIHZhbHVlXS5qb2luKCdcXG4nKSk7XG4gICAgY29uc3Qgc2lnbmVkID0gdmFsdWUgKyAnLicgKyBtYWMuc2FsdCArICcqJyArIG1hYy5kaWdlc3Q7XG4gICAgcmV0dXJuIHNpZ25lZDtcbn07XG5cblxuaW50ZXJuYWxzLkRlZmluaXRpb25zLnByb3RvdHlwZS5wYXNzVGhyb3VnaCA9IGZ1bmN0aW9uIChoZWFkZXIsIGZhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXRoaXMubmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgZXhjbHVkZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lc1tpXTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuY29va2llc1tuYW1lXTtcbiAgICAgICAgY29uc3QgcGFzc0Nvb2tpZSA9IGRlZmluaXRpb24ucGFzc1Rocm91Z2ggIT09IHVuZGVmaW5lZCA/IGRlZmluaXRpb24ucGFzc1Rocm91Z2ggOiBmYWxsYmFjaztcbiAgICAgICAgaWYgKCFwYXNzQ29va2llKSB7XG4gICAgICAgICAgICBleGNsdWRlLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5leGNsdWRlKGhlYWRlciwgZXhjbHVkZSk7XG59O1xuXG5cbmV4cG9ydHMuZXhjbHVkZSA9IGZ1bmN0aW9uIChjb29raWVzLCBleGNsdWRlcykge1xuXG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHZlcmlmeSA9IGNvb2tpZXMucmVwbGFjZShpbnRlcm5hbHMucGFpcnNSeCwgKCQwLCAkMSwgJDIpID0+IHtcblxuICAgICAgICBpZiAoZXhjbHVkZXMuaW5kZXhPZigkMSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyAocmVzdWx0ID8gJzsnIDogJycpICsgJDEgKyAnPScgKyAkMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcblxuICAgIHJldHVybiB2ZXJpZnkgPT09ICcnID8gcmVzdWx0IDogQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIGNvb2tpZSBoZWFkZXInKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IE9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IFF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgWmxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgQm9vbSA9IHJlcXVpcmUoJ0BoYXBpL2Jvb20nKTtcbmNvbnN0IEJvdXJuZSA9IHJlcXVpcmUoJ0BoYXBpL2JvdXJuZScpO1xuY29uc3QgQ29udGVudCA9IHJlcXVpcmUoJ0BoYXBpL2NvbnRlbnQnKTtcbmNvbnN0IEZpbGUgPSByZXF1aXJlKCdAaGFwaS9maWxlJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuY29uc3QgUGV6ID0gcmVxdWlyZSgnQGhhcGkvcGV6Jyk7XG5jb25zdCBXcmVjayA9IHJlcXVpcmUoJ0BoYXBpL3dyZWNrJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGRlY29kZXJzOiB7XG4gICAgICAgIGd6aXA6IChvcHRpb25zKSA9PiBabGliLmNyZWF0ZUd1bnppcChvcHRpb25zKSxcbiAgICAgICAgZGVmbGF0ZTogKG9wdGlvbnMpID0+IFpsaWIuY3JlYXRlSW5mbGF0ZShvcHRpb25zKVxuICAgIH1cbn07XG5cblxuZXhwb3J0cy5wYXJzZSA9IGFzeW5jIGZ1bmN0aW9uIChyZXEsIHRhcCwgb3B0aW9ucykge1xuXG4gICAgSG9lay5hc3NlcnQob3B0aW9ucywgJ01pc3Npbmcgb3B0aW9ucycpO1xuICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMucGFyc2UgIT09IHVuZGVmaW5lZCwgJ01pc3NpbmcgcGFyc2Ugb3B0aW9uIHNldHRpbmcnKTtcbiAgICBIb2VrLmFzc2VydChvcHRpb25zLm91dHB1dCAhPT0gdW5kZWZpbmVkLCAnTWlzc2luZyBvdXRwdXQgb3B0aW9uIHNldHRpbmcnKTtcblxuICAgIC8vIENvbnRlbnQgc2l6ZVxuXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHJlcS5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddO1xuICAgIGlmIChvcHRpb25zLm1heEJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgY29udGVudExlbmd0aCAmJlxuICAgICAgICBwYXJzZUludChjb250ZW50TGVuZ3RoLCAxMCkgPiBvcHRpb25zLm1heEJ5dGVzKSB7XG5cbiAgICAgICAgdGhyb3cgQm9vbS5lbnRpdHlUb29MYXJnZSgnUGF5bG9hZCBjb250ZW50IGxlbmd0aCBncmVhdGVyIHRoYW4gbWF4aW11bSBhbGxvd2VkOiAnICsgb3B0aW9ucy5tYXhCeXRlcyk7XG4gICAgfVxuXG4gICAgLy8gQ29udGVudCB0eXBlXG5cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IENvbnRlbnQudHlwZShvcHRpb25zLm92ZXJyaWRlIHx8IHJlcS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCBvcHRpb25zLmRlZmF1bHRDb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3cgJiZcbiAgICAgICAgICAgIG9wdGlvbnMuYWxsb3cuaW5kZXhPZihjb250ZW50VHlwZS5taW1lKSA9PT0gLTEpIHtcblxuICAgICAgICAgICAgdGhyb3cgQm9vbS51bnN1cHBvcnRlZE1lZGlhVHlwZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyc2VkID0geyBtaW1lOiBjb250ZW50VHlwZS5taW1lIH07XG5cbiAgICAgICAgLy8gUGFyc2U6IHRydWVcblxuICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGFyc2VkLnBheWxvYWQgPSBhd2FpdCBpbnRlcm5hbHMucGFyc2UocmVxLCB0YXAsIG9wdGlvbnMsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZTogZmFsc2UsICdndW56aXAnXG5cbiAgICAgICAgcGFyc2VkLnBheWxvYWQgPSBhd2FpdCBpbnRlcm5hbHMucmF3KHJlcSwgdGFwLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBlcnIubWltZSA9IGNvbnRlbnRUeXBlLm1pbWU7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59O1xuXG5cbmludGVybmFscy5wYXJzZSA9IGFzeW5jIGZ1bmN0aW9uIChyZXEsIHRhcCwgb3B0aW9ucywgY29udGVudFR5cGUpIHtcblxuICAgIGNvbnN0IG91dHB1dCA9IG9wdGlvbnMub3V0cHV0OyAgICAgICAgLy8gT3V0cHV0OiAnZGF0YScsICdzdHJlYW0nLCAnZmlsZSdcbiAgICBsZXQgc291cmNlID0gaW50ZXJuYWxzLmRlY29kZXIocmVxLCBvcHRpb25zKTtcblxuICAgIC8vIFRhcCByZXF1ZXN0XG5cbiAgICBpZiAodGFwKSB7XG4gICAgICAgIHNvdXJjZSA9IGludGVybmFscy5waXBlKHNvdXJjZSwgdGFwKTtcbiAgICB9XG5cbiAgICAvLyBNdWx0aXBhcnRcblxuICAgIGlmIChjb250ZW50VHlwZS5taW1lID09PSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlwYXJ0ID09PSBmYWxzZSkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICB0aHJvdyBCb29tLnVuc3VwcG9ydGVkTWVkaWFUeXBlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgaW50ZXJuYWxzLm11bHRpcGFydChyZXEsIG9wdGlvbnMsIHNvdXJjZSwgY29udGVudFR5cGUpO1xuICAgIH1cblxuICAgIC8vIE91dHB1dDogJ3N0cmVhbSdcblxuICAgIGlmIChvdXRwdXQgPT09ICdzdHJlYW0nKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLy8gT3V0cHV0OiAnZmlsZSdcblxuICAgIGlmIChvdXRwdXQgPT09ICdmaWxlJykge1xuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgaW50ZXJuYWxzLndyaXRlRmlsZShyZXEsIG9wdGlvbnMsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBmaWxlLml0ZW07XG4gICAgfVxuXG4gICAgLy8gT3V0cHV0OiAnZGF0YSdcblxuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBXcmVjay5yZWFkKHNvdXJjZSwgeyB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsIG1heEJ5dGVzOiBvcHRpb25zLm1heEJ5dGVzIH0pO1xuICAgIHJldHVybiBpbnRlcm5hbHMub2JqZWN0KG9wdGlvbnMsIHBheWxvYWQsIGNvbnRlbnRUeXBlLm1pbWUpO1xufTtcblxuXG5pbnRlcm5hbHMuZGVjb2RlciA9IGZ1bmN0aW9uIChzb3VyY2UsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IHNvdXJjZS5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgY29uc3QgZGVjb2RlciA9IChvcHRpb25zLmRlY29kZXJzIHx8IGludGVybmFscy5kZWNvZGVycylbY29udGVudEVuY29kaW5nXTtcbiAgICBpZiAoIWRlY29kZXIpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGVyT3B0aW9ucyA9IChvcHRpb25zLmNvbXByZXNzaW9uICYmIG9wdGlvbnMuY29tcHJlc3Npb25bY29udGVudEVuY29kaW5nXSkgfHwgbnVsbDtcbiAgICBjb25zdCBzdHJlYW0gPSBkZWNvZGVyKGRlY29kZXJPcHRpb25zKTtcblxuICAgIGNvbnN0IG9yaWcgPSBzdHJlYW0uZW1pdDtcbiAgICBzdHJlYW0uZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuXG4gICAgICAgIGlmIChldmVudCA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgYXJncyA9IFtCb29tLmJhZFJlcXVlc3QoJ0ludmFsaWQgY29tcHJlc3NlZCBwYXlsb2FkJywgYXJnc1swXSldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9yaWcuY2FsbChzdHJlYW0sIGV2ZW50LCAuLi5hcmdzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGludGVybmFscy5waXBlKHNvdXJjZSwgc3RyZWFtKTtcbn07XG5cblxuaW50ZXJuYWxzLnJhdyA9IGFzeW5jIGZ1bmN0aW9uIChyZXEsIHRhcCwgb3B0aW9ucykge1xuXG4gICAgY29uc3Qgb3V0cHV0ID0gb3B0aW9ucy5vdXRwdXQ7ICAgICAgLy8gT3V0cHV0OiAnZGF0YScsICdzdHJlYW0nLCAnZmlsZSdcbiAgICBsZXQgc291cmNlID0gcmVxO1xuXG4gICAgLy8gQ29udGVudC1lbmNvZGluZyAob3B0aW9uYWwpXG5cbiAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gJ2d1bnppcCcpIHtcbiAgICAgICAgc291cmNlID0gaW50ZXJuYWxzLmRlY29kZXIoc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBzb3VyY2VcblxuICAgIGlmICh0YXApIHtcbiAgICAgICAgc291cmNlID0gaW50ZXJuYWxzLnBpcGUoc291cmNlLCB0YXApO1xuICAgIH1cblxuICAgIC8vIE91dHB1dDogJ3N0cmVhbSdcblxuICAgIGlmIChvdXRwdXQgPT09ICdzdHJlYW0nKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfVxuXG4gICAgLy8gT3V0cHV0OiAnZmlsZSdcblxuICAgIGlmIChvdXRwdXQgPT09ICdmaWxlJykge1xuICAgICAgICBjb25zdCBmaWxlID0gYXdhaXQgaW50ZXJuYWxzLndyaXRlRmlsZShyZXEsIG9wdGlvbnMsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBmaWxlLml0ZW07XG4gICAgfVxuXG4gICAgLy8gT3V0cHV0OiAnZGF0YSdcblxuICAgIHJldHVybiBhd2FpdCBXcmVjay5yZWFkKHNvdXJjZSwgeyB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsIG1heEJ5dGVzOiBvcHRpb25zLm1heEJ5dGVzIH0pO1xufTtcblxuXG5pbnRlcm5hbHMub2JqZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBheWxvYWQsIG1pbWUpIHtcblxuICAgIC8vIEJpbmFyeVxuXG4gICAgaWYgKG1pbWUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgIHJldHVybiAocGF5bG9hZC5sZW5ndGggPyBwYXlsb2FkIDogbnVsbCk7XG4gICAgfVxuXG4gICAgLy8gVGV4dFxuXG4gICAgaWYgKG1pbWUubWF0Y2goL150ZXh0XFwvLiskLykpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB9XG5cbiAgICAvLyBKU09OXG5cbiAgICBpZiAoL15hcHBsaWNhdGlvblxcLyg/Oi4rXFwrKT9qc29uJC8udGVzdChtaW1lKSkge1xuICAgICAgICBpZiAoIXBheWxvYWQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQm91cm5lLnBhcnNlKHBheWxvYWQudG9TdHJpbmcoJ3V0ZjgnKSwgeyBwcm90b0FjdGlvbjogb3B0aW9ucy5wcm90b0FjdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IEJvb20uYmFkUmVxdWVzdCgnSW52YWxpZCByZXF1ZXN0IHBheWxvYWQgSlNPTiBmb3JtYXQnLCBlcnIpO1xuICAgICAgICAgICAgZXJyb3IucmF3ID0gcGF5bG9hZDtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybS1lbmNvZGVkXG5cbiAgICBpZiAobWltZSA9PT0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpIHtcbiAgICAgICAgY29uc3QgcGFyc2UgPSAob3B0aW9ucy5xdWVyeXN0cmluZyB8fCBRdWVyeXN0cmluZy5wYXJzZSk7XG4gICAgICAgIHJldHVybiAocGF5bG9hZC5sZW5ndGggPyBwYXJzZShwYXlsb2FkLnRvU3RyaW5nKCd1dGY4JykpIDoge30pO1xuICAgIH1cblxuICAgIGNvbnN0IGVycm9yID0gQm9vbS51bnN1cHBvcnRlZE1lZGlhVHlwZSgpO1xuICAgIGVycm9yLnJhdyA9IHBheWxvYWQ7XG4gICAgdGhyb3cgZXJyb3I7XG59O1xuXG5cbmludGVybmFscy5tdWx0aXBhcnQgPSBmdW5jdGlvbiAocmVxLCBvcHRpb25zLCBzb3VyY2UsIGNvbnRlbnRUeXBlKSB7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXG4gICAgICAgIC8vIFNldCBzdHJlYW0gdGltZW91dFxuXG4gICAgICAgIGNvbnN0IGNsaWVudFRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgICAgIGNvbnN0IGNsaWVudFRpbWVvdXRJZCA9IChjbGllbnRUaW1lb3V0ID8gc2V0VGltZW91dCgoKSA9PiByZWplY3QoQm9vbS5jbGllbnRUaW1lb3V0KCkpLCBjbGllbnRUaW1lb3V0KSA6IG51bGwpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBwYXJzZXJcblxuICAgICAgICBjb25zdCBkaXNwZW5zZXJPcHRpb25zID0gSG9lay5hcHBseVRvRGVmYXVsdHMoY29udGVudFR5cGUsIHsgbWF4Qnl0ZXM6IG9wdGlvbnMubWF4Qnl0ZXMgfSk7XG4gICAgICAgIGNvbnN0IGRpc3BlbnNlciA9IG5ldyBQZXouRGlzcGVuc2VyKGRpc3BlbnNlck9wdGlvbnMpO1xuXG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiByZWplY3QoQm9vbS5iYWRSZXF1ZXN0KCdJbnZhbGlkIG11bHRpcGFydCBwYXlsb2FkIGZvcm1hdCcsIGVycikpO1xuICAgICAgICBkaXNwZW5zZXIub25jZSgnZXJyb3InLCBvbkVycm9yKTtcblxuICAgICAgICBjb25zdCBkYXRhID0ge307XG4gICAgICAgIGNvbnN0IHBlbmRpbmdGaWxlcyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IHNldCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuXG4gICAgICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGFbbmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtuYW1lXS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSBbZGF0YVtuYW1lXSwgdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGZpbmFsaXplID0gYXN5bmMgKCkgPT4ge1xuXG4gICAgICAgICAgICAvLyBDbGVhbiB1cFxuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY2xpZW50VGltZW91dElkKTtcbiAgICAgICAgICAgIGRpc3BlbnNlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGRpc3BlbnNlci5yZW1vdmVMaXN0ZW5lcigncGFydCcsIG9uUGFydCk7XG4gICAgICAgICAgICBkaXNwZW5zZXIucmVtb3ZlTGlzdGVuZXIoJ2ZpZWxkJywgb25GaWVsZCk7XG4gICAgICAgICAgICBkaXNwZW5zZXIucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25DbG9zZSk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGZpbGVzXG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwZW5kaW5nRmlsZXMpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBpdGVtLCBuYW1lIH0gb2YgZmlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KG5hbWUsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gKG9wdGlvbnMubXVsdGlwYXJ0ID8gb3B0aW9ucy5tdWx0aXBhcnQub3V0cHV0IDogb3B0aW9ucy5vdXRwdXQpO1xuXG4gICAgICAgIGNvbnN0IG9uUGFydCA9IChwYXJ0KSA9PiB7XG5cbiAgICAgICAgICAgIGlmIChvdXRwdXQgPT09ICdmaWxlJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXRwdXQ6ICdmaWxlJ1xuICAgICAgICAgICAgICAgIHBlbmRpbmdGaWxlcy5wdXNoKGludGVybmFscy53cml0ZUZpbGUocmVxLCBvcHRpb25zLCBwYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHMucGFydChwYXJ0LCBvdXRwdXQsIHNldCwgb3B0aW9ucyk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPdXRwdXQ6ICdkYXRhJyAvICdzdHJlYW0nXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZGlzcGVuc2VyLm9uKCdwYXJ0Jywgb25QYXJ0KTtcblxuICAgICAgICBjb25zdCBvbkZpZWxkID0gKG5hbWUsIHZhbHVlKSA9PiBzZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICBkaXNwZW5zZXIub24oJ2ZpZWxkJywgb25GaWVsZCk7XG5cbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IGZpbmFsaXplKCk7XG4gICAgICAgIGRpc3BlbnNlci5vbmNlKCdjbG9zZScsIG9uQ2xvc2UpO1xuXG4gICAgICAgIHNvdXJjZS5waXBlKGRpc3BlbnNlcik7XG4gICAgfSk7XG59O1xuXG5cbmludGVybmFscy53cml0ZUZpbGUgPSBmdW5jdGlvbiAocmVxLCBvcHRpb25zLCBzdHJlYW0pIHtcblxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgY29uc3QgcGF0aCA9IEZpbGUudW5pcXVlRmlsZW5hbWUob3B0aW9ucy51cGxvYWRzIHx8IE9zLnRtcGRpcigpKTtcbiAgICAgICAgY29uc3QgZmlsZSA9IEZzLmNyZWF0ZVdyaXRlU3RyZWFtKHBhdGgsIHsgZmxhZ3M6ICd3eCcgfSk7XG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgaW50ZXJuYWxzLkNvdW50ZXIob3B0aW9ucyk7XG5cbiAgICAgICAgY29uc3QgZmluYWxpemUgPSAoZXJyKSA9PiB7XG5cbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcignYWJvcnRlZCcsIG9uQWJvcnQpO1xuICAgICAgICAgICAgZmlsZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBmaW5hbGl6ZSk7XG4gICAgICAgICAgICBmaWxlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGZpbmFsaXplKTtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHN0cmVhbS51bnBpcGUoY291bnRlcik7XG4gICAgICAgICAgICAgICAgY291bnRlci51bnBpcGUoZmlsZSk7XG5cbiAgICAgICAgICAgICAgICBmaWxlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICBGcy51bmxpbmsocGF0aCwgKC8qIGZzRXJyICovKSA9PiByZWplY3QoZXJyKSk7ICAgICAgLy8gSWdub3JlIHVubGluayBlcnJvcnNcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBpdGVtOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzOiBjb3VudGVyLmJ5dGVzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHN0cmVhbS5uYW1lKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWx0aXBhcnRcbiAgICAgICAgICAgICAgICByZXN1bHQubmFtZSA9IHN0cmVhbS5uYW1lO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pdGVtLmZpbGVuYW1lID0gc3RyZWFtLmZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pdGVtLmhlYWRlcnMgPSBzdHJlYW0uaGVhZGVycztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZpbGUub25jZSgnY2xvc2UnLCBmaW5hbGl6ZSk7XG4gICAgICAgIGZpbGUub25jZSgnZXJyb3InLCBmaW5hbGl6ZSk7XG5cbiAgICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IGZpbmFsaXplKEJvb20uYmFkUmVxdWVzdCgnQ2xpZW50IGNvbm5lY3Rpb24gYWJvcnRlZCcpKTtcbiAgICAgICAgcmVxLm9uY2UoJ2Fib3J0ZWQnLCBvbkFib3J0KTtcblxuICAgICAgICBpbnRlcm5hbHMucGlwZShzdHJlYW0sIGNvdW50ZXIpO1xuICAgICAgICBpbnRlcm5hbHMucGlwZShjb3VudGVyLCBmaWxlKTtcbiAgICB9KTtcblxuICAgIHByb21pc2UuY2F0Y2goSG9lay5pZ25vcmUpOyAgICAgLy8gUHJldmVudCB0cmlnZ2VyaW5nIG5vZGUncyBQcm9taXNlUmVqZWN0aW9uSGFuZGxlZFdhcm5pbmdcbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblxuaW50ZXJuYWxzLnBhcnQgPSBhc3luYyBmdW5jdGlvbiAocGFydCwgb3V0cHV0LCBzZXQsIG9wdGlvbnMpIHtcblxuICAgIGNvbnN0IHBheWxvYWQgPSBhd2FpdCBXcmVjay5yZWFkKHBhcnQpOyAgICAgICAgICAgICAvLyBFcnJvciBoYW5kbGVkIGJ5IGRpc3BlbnNlci5vbmNlKCdlcnJvcicpXG5cbiAgICBpZiAob3V0cHV0ID09PSAnc3RyZWFtJykgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3V0cHV0OiAnc3RyZWFtJ1xuICAgICAgICBjb25zdCBpdGVtID0gV3JlY2sudG9SZWFkYWJsZVN0cmVhbShwYXlsb2FkKTtcbiAgICAgICAgaXRlbS5oYXBpID0ge1xuICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICBoZWFkZXJzOiBwYXJ0LmhlYWRlcnNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc2V0KHBhcnQubmFtZSwgaXRlbSk7XG4gICAgfVxuXG4gICAgY29uc3QgY3QgPSBwYXJ0LmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnOyAgICAgIC8vIE91dHB1dDogJ2RhdGEnXG4gICAgY29uc3QgbWltZSA9IGN0LnNwbGl0KCc7JylbMF0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYW5ub3RhdGUgPSAodmFsdWUpID0+IHNldChwYXJ0Lm5hbWUsIG91dHB1dCA9PT0gJ2Fubm90YXRlZCcgPyB7IGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLCBoZWFkZXJzOiBwYXJ0LmhlYWRlcnMsIHBheWxvYWQ6IHZhbHVlIH0gOiB2YWx1ZSk7XG5cbiAgICBpZiAoIW1pbWUpIHtcbiAgICAgICAgcmV0dXJuIGFubm90YXRlKHBheWxvYWQpO1xuICAgIH1cblxuICAgIGlmICghcGF5bG9hZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGFubm90YXRlKHt9KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvYmplY3QgPSBpbnRlcm5hbHMub2JqZWN0KG9wdGlvbnMsIHBheWxvYWQsIG1pbWUpO1xuICAgICAgICBhbm5vdGF0ZShvYmplY3QpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGFubm90YXRlKHBheWxvYWQpO1xuICAgIH1cbn07XG5cblxuaW50ZXJuYWxzLnBpcGUgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcblxuICAgIGZyb20ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG5cbiAgICAgICAgZnJvbS51bnBpcGUodG8pO1xuICAgICAgICB0by5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn07XG5cblxuaW50ZXJuYWxzLkNvdW50ZXIgPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5UcmFuc2Zvcm0ge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuXG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSAwO1xuICAgICAgICB0aGlzLl9tYXhCeXRlcyA9IG9wdGlvbnMubWF4Qnl0ZXM7XG4gICAgfVxuXG4gICAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIG5leHQpIHtcblxuICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyArIGNodW5rLmxlbmd0aDtcblxuICAgICAgICBpZiAodGhpcy5fbWF4Qnl0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5ieXRlcyA+IHRoaXMuX21heEJ5dGVzKSB7XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0KEJvb20uZW50aXR5VG9vTGFyZ2UoJ1BheWxvYWQgY29udGVudCBsZW5ndGggZ3JlYXRlciB0aGFuIG1heGltdW0gYWxsb3dlZDogJyArIHRoaXMuX21heEJ5dGVzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dChudWxsLCBjaHVuayk7XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlRlYW0gPSBjbGFzcyB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9XG5cbiAgICBfaW5pdChvcHRpb25zID0ge30pIHtcblxuICAgICAgICB0aGlzLndvcmsgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtZWV0aW5ncyA9IG9wdGlvbnMubWVldGluZ3MgfHwgMTtcbiAgICAgICAgdGhpcy5fbWVldGluZ3MgPSBtZWV0aW5ncztcbiAgICAgICAgdGhpcy5fY291bnQgPSBtZWV0aW5ncztcbiAgICAgICAgdGhpcy5fbm90ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBhdHRlbmQobm90ZSkge1xuXG4gICAgICAgIGlmIChub3RlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWplY3Qobm90ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ub3Rlcy5wdXNoKG5vdGUpO1xuXG4gICAgICAgIGlmICgtLXRoaXMuX2NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh0aGlzLl9tZWV0aW5ncyA9PT0gMSA/IHRoaXMuX25vdGVzWzBdIDogdGhpcy5fbm90ZXMpO1xuICAgIH1cblxuICAgIGFzeW5jIHJlZ3JvdXAob3B0aW9ucykge1xuXG4gICAgICAgIGF3YWl0IHRoaXMud29yaztcblxuICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH1cbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJuYWxzLlRlYW0sIHtcbiAgICBfX2VzTW9kdWxlOiB7XG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICBkZWZhdWx0OiB7XG4gICAgICAgIHZhbHVlOiBpbnRlcm5hbHMuVGVhbVxuICAgIH0sXG4gICAgVGVhbXdvcms6IHtcbiAgICAgICAgdmFsdWU6IGludGVybmFscy5UZWFtXG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBBc3NlcnQgPSByZXF1aXJlKCdAaGFwaS9ob2VrL2xpYi9hc3NlcnQnKTtcclxuXHJcblxyXG5jb25zdCBpbnRlcm5hbHMgPSB7fTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFRvcG8ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG5cclxuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBhZGQobm9kZXMsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgICAgIC8vIFZhbGlkYXRlIHJ1bGVzXHJcblxyXG4gICAgICAgIGNvbnN0IGJlZm9yZSA9IFtdLmNvbmNhdChvcHRpb25zLmJlZm9yZSB8fCBbXSk7XHJcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSBbXS5jb25jYXQob3B0aW9ucy5hZnRlciB8fCBbXSk7XHJcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBvcHRpb25zLmdyb3VwIHx8ICc/JztcclxuICAgICAgICBjb25zdCBzb3J0ID0gb3B0aW9ucy5zb3J0IHx8IDA7ICAgICAgICAgICAgICAgICAgIC8vIFVzZWQgZm9yIG1lcmdpbmcgb25seVxyXG5cclxuICAgICAgICBBc3NlcnQoIWJlZm9yZS5pbmNsdWRlcyhncm91cCksIGBJdGVtIGNhbm5vdCBjb21lIGJlZm9yZSBpdHNlbGY6ICR7Z3JvdXB9YCk7XHJcbiAgICAgICAgQXNzZXJ0KCFiZWZvcmUuaW5jbHVkZXMoJz8nKSwgJ0l0ZW0gY2Fubm90IGNvbWUgYmVmb3JlIHVuYXNzb2NpYXRlZCBpdGVtcycpO1xyXG4gICAgICAgIEFzc2VydCghYWZ0ZXIuaW5jbHVkZXMoZ3JvdXApLCBgSXRlbSBjYW5ub3QgY29tZSBhZnRlciBpdHNlbGY6ICR7Z3JvdXB9YCk7XHJcbiAgICAgICAgQXNzZXJ0KCFhZnRlci5pbmNsdWRlcygnPycpLCAnSXRlbSBjYW5ub3QgY29tZSBhZnRlciB1bmFzc29jaWF0ZWQgaXRlbXMnKTtcclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xyXG4gICAgICAgICAgICBub2RlcyA9IFtub2Rlc107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgIHNlcTogdGhpcy5faXRlbXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgc29ydCxcclxuICAgICAgICAgICAgICAgIGJlZm9yZSxcclxuICAgICAgICAgICAgICAgIGFmdGVyLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXAsXHJcbiAgICAgICAgICAgICAgICBub2RlXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0IGV2ZW50XHJcblxyXG4gICAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5fc29ydCgpO1xyXG4gICAgICAgIEFzc2VydCh2YWxpZCwgJ2l0ZW0nLCBncm91cCAhPT0gJz8nID8gYGFkZGVkIGludG8gZ3JvdXAgJHtncm91cH1gIDogJycsICdjcmVhdGVkIGEgZGVwZW5kZW5jaWVzIGVycm9yJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xyXG4gICAgfVxyXG5cclxuICAgIG1lcmdlKG90aGVycykge1xyXG5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3RoZXJzKSkge1xyXG4gICAgICAgICAgICBvdGhlcnMgPSBbb3RoZXJzXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgb3RoZXIgb2Ygb3RoZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlcikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG90aGVyLl9pdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnB1c2goT2JqZWN0LmFzc2lnbih7fSwgaXRlbSkpOyAgICAgIC8vIFNoYWxsb3cgY2xvbmVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNvcnQgaXRlbXNcclxuXHJcbiAgICAgICAgdGhpcy5faXRlbXMuc29ydChpbnRlcm5hbHMubWVyZ2VTb3J0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zW2ldLnNlcSA9IGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB2YWxpZCA9IHRoaXMuX3NvcnQoKTtcclxuICAgICAgICBBc3NlcnQodmFsaWQsICdtZXJnZSBjcmVhdGVkIGEgZGVwZW5kZW5jaWVzIGVycm9yJyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xyXG4gICAgfVxyXG5cclxuICAgIF9zb3J0KCkge1xyXG5cclxuICAgICAgICAvLyBDb25zdHJ1Y3QgZ3JhcGhcclxuXHJcbiAgICAgICAgY29uc3QgZ3JhcGggPSB7fTtcclxuICAgICAgICBjb25zdCBncmFwaEFmdGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7ICAgICAgICAgICAgLy8gQSBwcm90b3R5cGUgY2FuIGJ1bmdsZSBsb29rdXBzIHcvIGZhbHNlIHBvc2l0aXZlc1xyXG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICBjb25zdCBzZXEgPSBpdGVtLnNlcTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmlxdWUgYWNyb3NzIGFsbCBpdGVtc1xyXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IGl0ZW0uZ3JvdXA7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgR3JvdXBzXHJcblxyXG4gICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gZ3JvdXBzW2dyb3VwXSB8fCBbXTtcclxuICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKHNlcSk7XHJcblxyXG4gICAgICAgICAgICAvLyBCdWlsZCBpbnRlcm1lZGlhcnkgZ3JhcGggdXNpbmcgJ2JlZm9yZSdcclxuXHJcbiAgICAgICAgICAgIGdyYXBoW3NlcV0gPSBpdGVtLmJlZm9yZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIHNlY29uZCBpbnRlcm1lZGlhcnkgZ3JhcGggd2l0aCAnYWZ0ZXInXHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFmdGVyIG9mIGl0ZW0uYWZ0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGdyYXBoQWZ0ZXJzW2FmdGVyXSA9IGdyYXBoQWZ0ZXJzW2FmdGVyXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGdyYXBoQWZ0ZXJzW2FmdGVyXS5wdXNoKHNlcSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEV4cGFuZCBpbnRlcm1lZGlhcnkgZ3JhcGhcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIGluIGdyYXBoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkR3JvdXBzID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdyYXBoTm9kZUl0ZW0gaW4gZ3JhcGhbbm9kZV0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gZ3JhcGhbbm9kZV1bZ3JhcGhOb2RlSXRlbV07XHJcbiAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gZ3JvdXBzW2dyb3VwXSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGV4cGFuZGVkR3JvdXBzLnB1c2goLi4uZ3JvdXBzW2dyb3VwXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdyYXBoW25vZGVdID0gZXhwYW5kZWRHcm91cHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNZXJnZSBpbnRlcm1lZGlhcnkgZ3JhcGggdXNpbmcgZ3JhcGhBZnRlcnMgaW50byBmaW5hbCBncmFwaFxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGdyb3VwIGluIGdyYXBoQWZ0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChncm91cHNbZ3JvdXBdKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZ3JvdXBzW2dyb3VwXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoW25vZGVdLnB1c2goLi4uZ3JhcGhBZnRlcnNbZ3JvdXBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29tcGlsZSBhbmNlc3RvcnNcclxuXHJcbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIGluIGdyYXBoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JhcGhbbm9kZV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tjaGlsZF0gPSBhbmNlc3RvcnNbY2hpbGRdIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgYW5jZXN0b3JzW2NoaWxkXS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUb3BvIHNvcnRcclxuXHJcbiAgICAgICAgY29uc3QgdmlzaXRlZCA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKytpKSB7ICAgICAgICAgIC8vIExvb3BpbmcgdGhyb3VnaCBpdGVtLnNlcSB2YWx1ZXMgb3V0IG9mIG9yZGVyXHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaTtcclxuXHJcbiAgICAgICAgICAgIGlmIChhbmNlc3RvcnNbaV0pIHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9pdGVtcy5sZW5ndGg7ICsraikgeyAgLy8gQXMgYWJvdmUsIHRoZXNlIGFyZSBpdGVtLnNlcSB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFtqXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYW5jZXN0b3JzW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2VzdG9yc1tqXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2VlQ291bnQgPSBhbmNlc3RvcnNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWVuQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgc2hvdWxkU2VlQ291bnQ7ICsraykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFthbmNlc3RvcnNbal1ba11dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3NlZW5Db3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW5Db3VudCA9PT0gc2hvdWxkU2VlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZpc2l0ZWRbbmV4dF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc29ydGVkLnB1c2gobmV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzb3J0ZWQubGVuZ3RoICE9PSB0aGlzLl9pdGVtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgc2VxSW5kZXggPSB7fTtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcclxuICAgICAgICAgICAgc2VxSW5kZXhbaXRlbS5zZXFdID0gaXRlbTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNvcnRlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRJdGVtID0gc2VxSW5kZXhbdmFsdWVdO1xyXG4gICAgICAgICAgICB0aGlzLm5vZGVzLnB1c2goc29ydGVkSXRlbS5ub2RlKTtcclxuICAgICAgICAgICAgdGhpcy5faXRlbXMucHVzaChzb3J0ZWRJdGVtKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuXHJcbmludGVybmFscy5tZXJnZVNvcnQgPSAoYSwgYikgPT4ge1xyXG5cclxuICAgIHJldHVybiBhLnNvcnQgPT09IGIuc29ydCA/IDAgOiAoYS5zb3J0IDwgYi5zb3J0ID8gLTEgOiAxKTtcclxufTtcclxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGludGVybmFscy5WaXNlID0gZnVuY3Rpb24gKGNodW5rcykge1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2NodW5rcyA9IFtdO1xuICAgIHRoaXMuX29mZnNldCA9IDA7XG5cbiAgICBpZiAoY2h1bmtzKSB7XG4gICAgICAgIGNodW5rcyA9IFtdLmNvbmNhdChjaHVua3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKGNodW5rc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbmludGVybmFscy5WaXNlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICBIb2VrLmFzc2VydChCdWZmZXIuaXNCdWZmZXIoY2h1bmspLCAnQ2h1bmsgbXVzdCBiZSBhIGJ1ZmZlcicpO1xuXG4gICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgZGF0YTogY2h1bmssXG4gICAgICAgIGxlbmd0aDogY2h1bmsubGVuZ3RoLFxuICAgICAgICBvZmZzZXQ6IHRoaXMubGVuZ3RoICsgdGhpcy5fb2Zmc2V0LFxuICAgICAgICBpbmRleDogdGhpcy5fY2h1bmtzLmxlbmd0aFxuICAgIH07XG5cbiAgICB0aGlzLl9jaHVua3MucHVzaChpdGVtKTtcbiAgICB0aGlzLmxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG59O1xuXG5cbmludGVybmFscy5WaXNlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcblxuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2T2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9jaHVua0F0KGxlbmd0aCk7XG5cbiAgICBsZXQgZHJvcFRvID0gdGhpcy5fY2h1bmtzLmxlbmd0aDtcbiAgICB0aGlzLl9vZmZzZXQgPSAwO1xuXG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgZHJvcFRvID0gaXRlbS5jaHVuay5pbmRleDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaXRlbS5vZmZzZXQ7XG4gICAgfVxuXG4gICAgLy8gRHJvcCBsb3dlciBjaHVua3NcblxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJvcFRvOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKGkgPT09IDAgJiZcbiAgICAgICAgICAgIHByZXZPZmZzZXQpIHtcblxuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmsuZGF0YS5zbGljZShwcmV2T2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaChjaHVuay5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9vZmZzZXQpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goaXRlbS5jaHVuay5kYXRhLnNsaWNlKGRyb3BUbyA/IDAgOiBwcmV2T2Zmc2V0LCB0aGlzLl9vZmZzZXQpKTtcbiAgICB9XG5cbiAgICAvLyBSZWNhbGN1bGF0ZSBleGlzdGluZyBjaHVua3NcblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tpXTtcbiAgICAgICAgY2h1bmsub2Zmc2V0ID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIGNodW5rLmluZGV4ID0gaTtcblxuICAgICAgICB0aGlzLmxlbmd0aCArPSBjaHVuay5sZW5ndGg7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggLT0gdGhpcy5fb2Zmc2V0O1xuXG4gICAgcmV0dXJuIGNodW5rcztcbn07XG5cblxuaW50ZXJuYWxzLlZpc2UucHJvdG90eXBlLmF0ID0gaW50ZXJuYWxzLlZpc2UucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChwb3MpIHtcblxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9jaHVua0F0KHBvcyk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmNodW5rLmRhdGFbaXRlbS5vZmZzZXRdIDogdW5kZWZpbmVkO1xufTtcblxuXG5pbnRlcm5hbHMuVmlzZS5wcm90b3R5cGUuX2NodW5rQXQgPSBmdW5jdGlvbiAocG9zKSB7XG5cbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwb3MgPSBwb3MgKyB0aGlzLl9vZmZzZXQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NodW5rc1tpXTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcG9zIC0gY2h1bmsub2Zmc2V0O1xuICAgICAgICBpZiAob2Zmc2V0IDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaHVuaywgb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblxuaW50ZXJuYWxzLlZpc2UucHJvdG90eXBlLmNodW5rcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jaHVua3NbaV07XG4gICAgICAgIGlmIChpID09PSAwICYmXG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQpIHtcblxuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmsuZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNodW5rcztcbn07XG5cblxuaW50ZXJuYWxzLlZpc2UucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAodmFsdWUsIHBvcywgbGVuZ3RoKSB7XG5cbiAgICBwb3MgPSBwb3MgfHwgMDtcblxuICAgIGxlbmd0aCA9IGxlbmd0aCA/IE1hdGgubWluKHZhbHVlLmxlbmd0aCwgbGVuZ3RoKSA6IHZhbHVlLmxlbmd0aDtcbiAgICBpZiAocG9zICsgbGVuZ3RoID4gdGhpcy5sZW5ndGgpIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBlbm91Z2ggbGVuZ3RoIHRvIGZpdCB2YWx1ZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jaHVua0F0KHBvcyk7XG4gICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGogPSBzdGFydC5jaHVuay5pbmRleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaiA8IHRoaXMuX2NodW5rcy5sZW5ndGggJiYgaSA8IGxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2h1bmtzW2pdO1xuXG4gICAgICAgIGxldCBrID0gKGogPT09IHN0YXJ0LmNodW5rLmluZGV4ID8gc3RhcnQub2Zmc2V0IDogMCk7XG4gICAgICAgIGZvciAoOyBrIDwgY2h1bmsubGVuZ3RoICYmIGkgPCBsZW5ndGg7ICsraywgKytpKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmsuZGF0YVtrXSAhPT0gdmFsdWVbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgSHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IEh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgVXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBabGliID0gcmVxdWlyZSgnemxpYicpO1xuXG5jb25zdCBCb29tID0gcmVxdWlyZSgnQGhhcGkvYm9vbScpO1xuY29uc3QgQm91cm5lID0gcmVxdWlyZSgnQGhhcGkvYm91cm5lJyk7XG5jb25zdCBIb2VrID0gcmVxdWlyZSgnQGhhcGkvaG9laycpO1xuXG5jb25zdCBQYXlsb2FkID0gcmVxdWlyZSgnLi9wYXlsb2FkJyk7XG5jb25zdCBSZWNvcmRlciA9IHJlcXVpcmUoJy4vcmVjb3JkZXInKTtcbmNvbnN0IFRhcCA9IHJlcXVpcmUoJy4vdGFwJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge1xuICAgIGpzb25SZWdleDogL15hcHBsaWNhdGlvblxcLyhbYS16MC05Ll0qWystXWpzb258anNvbikkLyxcbiAgICBzaGFsbG93T3B0aW9uczogWydhZ2VudCcsICdhZ2VudHMnLCAnYmVmb3JlUmVkaXJlY3QnLCAnZG93bnN0cmVhbVJlcycsICdwYXlsb2FkJywgJ3JlZGlyZWN0ZWQnXVxufTtcblxuXG4vLyBOZXcgaW5zdGFuY2UgaXMgZXhwb3J0ZWQgYXMgbW9kdWxlLmV4cG9ydHNcblxuaW50ZXJuYWxzLkNsaWVudCA9IGZ1bmN0aW9uIChvcHRpb25zID0ge30pIHtcblxuICAgIEhvZWsuYXNzZXJ0KCFvcHRpb25zLmFnZW50cyB8fCAob3B0aW9ucy5hZ2VudHMuaHR0cHMgJiYgb3B0aW9ucy5hZ2VudHMuaHR0cCAmJiBvcHRpb25zLmFnZW50cy5odHRwc0FsbG93VW5hdXRob3JpemVkKSwgJ09wdGlvbiBhZ2VudHMgbXVzdCBpbmNsdWRlIFwiaHR0cFwiLCBcImh0dHBzXCIsIGFuZCBcImh0dHBzQWxsb3dVbmF1dGhvcml6ZWRcIicpO1xuXG4gICAgdGhpcy5fZGVmYXVsdHMgPSBIb2VrLmNsb25lKG9wdGlvbnMsIHsgc2hhbGxvdzogaW50ZXJuYWxzLnNoYWxsb3dPcHRpb25zIH0pO1xuXG4gICAgdGhpcy5hZ2VudHMgPSB0aGlzLl9kZWZhdWx0cy5hZ2VudHMgfHwge1xuICAgICAgICBodHRwczogbmV3IEh0dHBzLkFnZW50KHsgbWF4U29ja2V0czogSW5maW5pdHkgfSksXG4gICAgICAgIGh0dHA6IG5ldyBIdHRwLkFnZW50KHsgbWF4U29ja2V0czogSW5maW5pdHkgfSksXG4gICAgICAgIGh0dHBzQWxsb3dVbmF1dGhvcml6ZWQ6IG5ldyBIdHRwcy5BZ2VudCh7IG1heFNvY2tldHM6IEluZmluaXR5LCByZWplY3RVbmF1dGhvcml6ZWQ6IGZhbHNlIH0pXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcbiAgICB0aGlzLl9lbWl0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblxuICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KC4uLmFyZ3MpO1xuICAgIH07XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLmRlZmF1bHRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMgJiYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyksICdvcHRpb25zIG11c3QgYmUgcHJvdmlkZWQgdG8gZGVmYXVsdHMnKTtcblxuICAgIG9wdGlvbnMgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyh0aGlzLl9kZWZhdWx0cywgb3B0aW9ucywgeyBzaGFsbG93OiBpbnRlcm5hbHMuc2hhbGxvd09wdGlvbnMgfSk7XG4gICAgcmV0dXJuIG5ldyBpbnRlcm5hbHMuQ2xpZW50KG9wdGlvbnMpO1xufTtcblxuXG4vLyBiYXNlVXJsIG5lZWRzIHRvIGVuZCBpbiBhIHRyYWlsaW5nIC8gaWYgaXQgY29udGFpbnMgcGF0aHMgdGhhdCBuZWVkIHRvIGJlIHByZXNlcnZlZFxuaW50ZXJuYWxzLnJlc29sdmVVcmwgPSBmdW5jdGlvbiAoYmFzZVVybCwgcGF0aCkge1xuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgIH1cblxuICAgIC8vIFdpbGwgZGVmYXVsdCB0byBwYXRoIGlmIGl0J3Mgbm90IGEgcmVsYXRpdmUgVVJMXG4gICAgY29uc3QgdXJsID0gbmV3IFVybC5VUkwocGF0aCwgYmFzZVVybCk7XG4gICAgcmV0dXJuIFVybC5mb3JtYXQodXJsKTtcbn07XG5cblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICB0cnkge1xuICAgICAgICBvcHRpb25zID0gSG9lay5hcHBseVRvRGVmYXVsdHModGhpcy5fZGVmYXVsdHMsIG9wdGlvbnMsIHsgc2hhbGxvdzogaW50ZXJuYWxzLnNoYWxsb3dPcHRpb25zIH0pO1xuXG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMucGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLnBheWxvYWQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLnBheWxvYWQgPT09ICdvYmplY3QnLCAnb3B0aW9ucy5wYXlsb2FkIG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFN0cmVhbSwgb3IgYW4gT2JqZWN0Jyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KChvcHRpb25zLmFnZW50ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5hZ2VudCA9PT0gbnVsbCkgfHwgKHR5cGVvZiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gJ2Jvb2xlYW4nKSwgJ29wdGlvbnMuYWdlbnQgY2Fubm90IGJlIHNldCB0byBhbiBBZ2VudCBhdCB0aGUgc2FtZSB0aW1lIGFzIG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkIGlzIHNldCcpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmJlZm9yZVJlZGlyZWN0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5iZWZvcmVSZWRpcmVjdCA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJywgJ29wdGlvbnMuYmVmb3JlUmVkaXJlY3QgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIEhvZWsuYXNzZXJ0KG9wdGlvbnMucmVkaXJlY3RlZCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucmVkaXJlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9ucy5yZWRpcmVjdGVkID09PSAnZnVuY3Rpb24nLCAnb3B0aW9ucy5yZWRpcmVjdGVkIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBIb2VrLmFzc2VydChvcHRpb25zLmd1bnppcCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zLmd1bnppcCA9PT0gJ2Jvb2xlYW4nIHx8IG9wdGlvbnMuZ3VuemlwID09PSAnZm9yY2UnLCAnb3B0aW9ucy5ndW56aXAgbXVzdCBiZSBhIGJvb2xlYW4gb3IgXCJmb3JjZVwiJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5iZWZvcmVSZWRpcmVjdCA9IG9wdGlvbnMuYmVmb3JlUmVkaXJlY3QgfHwgKChyZWRpcmVjdE1ldGhvZCwgc3RhdHVzQ29kZSwgbG9jYXRpb24sIHJlc0hlYWRlcnMsIHJlZGlyZWN0T3B0aW9ucywgbmV4dCkgPT4gbmV4dCgpKTtcblxuICAgIGlmIChvcHRpb25zLmJhc2VVcmwpIHtcbiAgICAgICAgdXJsID0gaW50ZXJuYWxzLnJlc29sdmVVcmwob3B0aW9ucy5iYXNlVXJsLCB1cmwpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5iYXNlVXJsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbGF5ID0ge307XG4gICAgY29uc3QgcmVxID0gdGhpcy5fcmVxdWVzdChtZXRob2QsIHVybCwgb3B0aW9ucywgcmVsYXkpO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgcmVsYXkuY2FsbGJhY2sgPSAoZXJyLCByZXMpID0+IHtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcHJvbWlzZS5yZXEgPSByZXE7XG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLl9yZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsLCBvcHRpb25zLCByZWxheSwgX3RyYWNlKSB7XG5cbiAgICBjb25zdCB1cmkgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5zb2NrZXRQYXRoKSB7XG4gICAgICAgIHVyaS5zb2NrZXRQYXRoID0gb3B0aW9ucy5zb2NrZXRQYXRoO1xuXG4gICAgICAgIGNvbnN0IHBhcnNlZFVyaSA9IG5ldyBVcmwuVVJMKHVybCwgYHVuaXg6Ly8ke29wdGlvbnMuc29ja2V0UGF0aH1gKTtcbiAgICAgICAgaW50ZXJuYWxzLmFwcGx5VXJsVG9PcHRpb25zKHVyaSwge1xuICAgICAgICAgICAgLy8gVGhlIGhvc3QgbXVzdCBiZSBlbXB0eSBhY2NvcmRpbmcgdG8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI2MTYjc2VjdGlvbi0xNC4yM1xuICAgICAgICAgICAgaG9zdDogJycsXG4gICAgICAgICAgICBwcm90b2NvbDogJ2h0dHA6JyxcbiAgICAgICAgICAgIGhhc2g6IHBhcnNlZFVyaS5oYXNoLFxuICAgICAgICAgICAgc2VhcmNoOiBwYXJzZWRVcmkuc2VhcmNoLFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiBwYXJzZWRVcmkuc2VhcmNoUGFyYW1zLFxuICAgICAgICAgICAgcGF0aG5hbWU6IHBhcnNlZFVyaS5wYXRobmFtZSxcbiAgICAgICAgICAgIGhyZWY6IHBhcnNlZFVyaS5ocmVmXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJpLnNldEhvc3QgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcGFyc2VkVXJpID0gbmV3IFVybC5VUkwodXJsKTtcbiAgICAgICAgaW50ZXJuYWxzLmFwcGx5VXJsVG9PcHRpb25zKHVyaSwgcGFyc2VkVXJpKTtcbiAgICB9XG5cbiAgICB1cmkubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgdXJpLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG5cbiAgICBjb25zdCBob3N0SGVhZGVyID0gaW50ZXJuYWxzLmZpbmRIZWFkZXIoJ2hvc3QnLCB1cmkuaGVhZGVycyk7XG5cbiAgICBpZiAoIWhvc3RIZWFkZXIpIHtcbiAgICAgICAgdXJpLmhlYWRlcnMuaG9zdCA9IHVyaS5ob3N0O1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0NvbnRlbnRMZW5ndGggPSBpbnRlcm5hbHMuZmluZEhlYWRlcignY29udGVudC1sZW5ndGgnLCB1cmkuaGVhZGVycykgIT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChvcHRpb25zLnBheWxvYWQgJiYgdHlwZW9mIG9wdGlvbnMucGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgIShvcHRpb25zLnBheWxvYWQgaW5zdGFuY2VvZiBTdHJlYW0pICYmICFCdWZmZXIuaXNCdWZmZXIob3B0aW9ucy5wYXlsb2FkKSkge1xuICAgICAgICBvcHRpb25zLnBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLnBheWxvYWQpO1xuICAgICAgICBpZiAoIWludGVybmFscy5maW5kSGVhZGVyKCdjb250ZW50LXR5cGUnLCB1cmkuaGVhZGVycykpIHtcbiAgICAgICAgICAgIHVyaS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmd1bnppcCAmJlxuICAgICAgICBpbnRlcm5hbHMuZmluZEhlYWRlcignYWNjZXB0LWVuY29kaW5nJywgdXJpLmhlYWRlcnMpID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICB1cmkuaGVhZGVyc1snYWNjZXB0LWVuY29kaW5nJ10gPSAnZ3ppcCc7XG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZFN1cHBvcnRlZCA9ICh1cmkubWV0aG9kICE9PSAnR0VUJyAmJiB1cmkubWV0aG9kICE9PSAnSEVBRCcgJiYgb3B0aW9ucy5wYXlsb2FkICE9PSBudWxsICYmIG9wdGlvbnMucGF5bG9hZCAhPT0gdW5kZWZpbmVkKTtcbiAgICBpZiAocGF5bG9hZFN1cHBvcnRlZCAmJlxuICAgICAgICAodHlwZW9mIG9wdGlvbnMucGF5bG9hZCA9PT0gJ3N0cmluZycgfHwgQnVmZmVyLmlzQnVmZmVyKG9wdGlvbnMucGF5bG9hZCkpICYmXG4gICAgICAgICghaGFzQ29udGVudExlbmd0aCkpIHtcblxuICAgICAgICB1cmkuaGVhZGVycyA9IEhvZWsuY2xvbmUodXJpLmhlYWRlcnMpO1xuICAgICAgICB1cmkuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IEJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLnBheWxvYWQpID8gb3B0aW9ucy5wYXlsb2FkLmxlbmd0aCA6IEJ1ZmZlci5ieXRlTGVuZ3RoKG9wdGlvbnMucGF5bG9hZCk7XG4gICAgfVxuXG4gICAgbGV0IHJlZGlyZWN0cyA9IChvcHRpb25zLmhhc093blByb3BlcnR5KCdyZWRpcmVjdHMnKSA/IG9wdGlvbnMucmVkaXJlY3RzIDogZmFsc2UpOyAgICAgIC8vIE5lZWRlZCB0byBhbGxvdyAwIGFzIHZhbGlkIHZhbHVlIHdoZW4gcGFzc2VkIHJlY3Vyc2l2ZWx5XG5cbiAgICBfdHJhY2UgPSAoX3RyYWNlIHx8IFtdKTtcbiAgICBfdHJhY2UucHVzaCh7IG1ldGhvZDogdXJpLm1ldGhvZCwgdXJsIH0pO1xuXG4gICAgY29uc3QgY2xpZW50ID0gKHVyaS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBIdHRwcyA6IEh0dHApO1xuXG4gICAgaWYgKG9wdGlvbnMucmVqZWN0VW5hdXRob3JpemVkICE9PSB1bmRlZmluZWQgJiYgdXJpLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICB1cmkuYWdlbnQgPSBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA/IHRoaXMuYWdlbnRzLmh0dHBzIDogdGhpcy5hZ2VudHMuaHR0cHNBbGxvd1VuYXV0aG9yaXplZDtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5hZ2VudCB8fCBvcHRpb25zLmFnZW50ID09PSBmYWxzZSkge1xuICAgICAgICB1cmkuYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXJpLmFnZW50ID0gdXJpLnByb3RvY29sID09PSAnaHR0cHM6JyA/IHRoaXMuYWdlbnRzLmh0dHBzIDogdGhpcy5hZ2VudHMuaHR0cDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zZWN1cmVQcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaS5zZWN1cmVQcm90b2NvbCA9IG9wdGlvbnMuc2VjdXJlUHJvdG9jb2w7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY2lwaGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaS5jaXBoZXJzID0gb3B0aW9ucy5jaXBoZXJzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0KSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3ByZVJlcXVlc3QnLCB1cmksIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCByZXEgPSBjbGllbnQucmVxdWVzdCh1cmkpO1xuXG4gICAgaWYgKHRoaXMuX2VtaXQpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgncmVxdWVzdCcsIHJlcSk7XG4gICAgfVxuXG4gICAgbGV0IHNoYWRvdyA9IG51bGw7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgY29weSBvZiB0aGUgc3RyZWFtZWQgcmVxdWVzdCBwYXlsb2FkIHdoZW4gcmVkaXJlY3RzIGFyZSBlbmFibGVkXG4gICAgbGV0IHRpbWVvdXRJZDtcblxuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG5cbiAgICAgICAgZXJyLnRyYWNlID0gX3RyYWNlO1xuICAgICAgICByZXR1cm4gZmluaXNoT25jZShCb29tLmJhZEdhdGV3YXkoJ0NsaWVudCByZXF1ZXN0IGVycm9yJywgZXJyKSk7XG4gICAgfTtcblxuICAgIHJlcS5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuXG4gICAgY29uc3Qgb25SZXNwb25zZSA9IChyZXMpID0+IHtcblxuICAgICAgICAvLyBQYXNzLXRocm91Z2ggcmVzcG9uc2VcblxuICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0TWV0aG9kID0gaW50ZXJuYWxzLnJlZGlyZWN0TWV0aG9kKHN0YXR1c0NvZGUsIHVyaS5tZXRob2QsIG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChyZWRpcmVjdHMgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAhcmVkaXJlY3RNZXRob2QpIHtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UobnVsbCwgcmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZGlyZWN0aW9uXG5cbiAgICAgICAgcmVzLmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAocmVkaXJlY3RzID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoT25jZShCb29tLmJhZEdhdGV3YXkoJ01heGltdW0gcmVkaXJlY3Rpb25zIHJlYWNoZWQnLCBfdHJhY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IHJlcy5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluaXNoT25jZShCb29tLmJhZEdhdGV3YXkoJ1JlY2VpdmVkIHJlZGlyZWN0aW9uIHdpdGhvdXQgbG9jYXRpb24nLCBfdHJhY2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghL15odHRwcz86L2kudGVzdChsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gVXJsLnJlc29sdmUodXJpLmhyZWYsIGxvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0T3B0aW9ucyA9IEhvZWsuY2xvbmUob3B0aW9ucywgeyBzaGFsbG93OiBpbnRlcm5hbHMuc2hhbGxvd09wdGlvbnMgfSk7XG4gICAgICAgIHJlZGlyZWN0T3B0aW9ucy5wYXlsb2FkID0gc2hhZG93IHx8IG9wdGlvbnMucGF5bG9hZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGFkb3cgbXVzdCBiZSByZWFkeSBhdCB0aGlzIHBvaW50IGlmIHNldFxuICAgICAgICByZWRpcmVjdE9wdGlvbnMucmVkaXJlY3RzID0gLS1yZWRpcmVjdHM7XG5cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYmVmb3JlUmVkaXJlY3QocmVkaXJlY3RNZXRob2QsIHN0YXR1c0NvZGUsIGxvY2F0aW9uLCByZXMuaGVhZGVycywgcmVkaXJlY3RPcHRpb25zLCAoKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZGlyZWN0UmVxID0gdGhpcy5fcmVxdWVzdChyZWRpcmVjdE1ldGhvZCwgbG9jYXRpb24sIHJlZGlyZWN0T3B0aW9ucywgeyBjYWxsYmFjazogZmluaXNoT25jZSB9LCBfdHJhY2UpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZWRpcmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZWRpcmVjdGVkKHN0YXR1c0NvZGUsIGxvY2F0aW9uLCByZWRpcmVjdFJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBSZWdpc3RlciBoYW5kbGVyc1xuXG4gICAgY29uc3QgZmluaXNoID0gKGVyciwgcmVzKSA9PiB7XG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXEuYWJvcnQgPSBfYWJvcnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGZ1bmN0aW9uIHRvIHJlbGVhc2UgbWVtb3J5XG4gICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICByZXEub24oJ2Vycm9yJywgSG9lay5pZ25vcmUpO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICAgIGlmICh0aGlzLl9lbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdyZXNwb25zZScsIGVyciwgeyByZXEsIHJlcywgc3RhcnQsIHVyaSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWxheS5jYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbmlzaE9uY2UgPSBIb2VrLm9uY2UoZmluaXNoKTtcblxuICAgIHJlcS5vbmNlKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpO1xuXG4gICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UoQm9vbS5nYXRld2F5VGltZW91dCgnQ2xpZW50IHJlcXVlc3QgdGltZW91dCcpKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMudGltZW91dDtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gYWJvcnQgbWV0aG9kIHRvIGRldGVjdCBlYXJseSBhYm9ydHNcblxuICAgIGNvbnN0IF9hYm9ydCA9IHJlcS5hYm9ydDtcbiAgICBsZXQgYWJvcnRlZCA9IGZhbHNlO1xuICAgIHJlcS5hYm9ydCA9ICgpID0+IHtcblxuICAgICAgICBpZiAoIWFib3J0ZWQgJiYgIXJlcS5yZXMgJiYgIXJlcS5zb2NrZXQpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuXG4gICAgICAgICAgICAgICAgLy8gRmFrZSBhbiBFQ09OTlJFU0VUIGVycm9yXG5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignc29ja2V0IGhhbmcgdXAnKTtcbiAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VDT05OUkVTRVQnO1xuICAgICAgICAgICAgICAgIGZpbmlzaE9uY2UoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF9hYm9ydC5jYWxsKHJlcSk7XG4gICAgfTtcblxuICAgIC8vIFdyaXRlIHBheWxvYWRcblxuICAgIGlmIChwYXlsb2FkU3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnBheWxvYWQgaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICAgICAgICAgIGxldCBzdHJlYW0gPSBvcHRpb25zLnBheWxvYWQ7XG5cbiAgICAgICAgICAgIGlmIChyZWRpcmVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0b3IgPSBuZXcgVGFwKCk7XG4gICAgICAgICAgICAgICAgY29sbGVjdG9yLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBzaGFkb3cgPSBjb2xsZWN0b3IuY29sbGVjdCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc3RyZWFtID0gb3B0aW9ucy5wYXlsb2FkLnBpcGUoY29sbGVjdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW50ZXJuYWxzLmRlZmVyUGlwZVVudGlsU29ja2V0Q29ubmVjdHMocmVxLCBzdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcS53cml0ZShvcHRpb25zLnBheWxvYWQpO1xuICAgIH1cblxuICAgIC8vIEZpbmFsaXplIHJlcXVlc3RcblxuICAgIHJlcS5lbmQoKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuXG5pbnRlcm5hbHMuZGVmZXJQaXBlVW50aWxTb2NrZXRDb25uZWN0cyA9IGZ1bmN0aW9uIChyZXEsIHN0cmVhbSkge1xuXG4gICAgY29uc3Qgb25Tb2NrZXQgPSAoc29ja2V0KSA9PiB7XG5cbiAgICAgICAgaWYgKCFzb2NrZXQuY29ubmVjdGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG9uU29ja2V0Q29ubmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc29ja2V0Lm9uY2UoJ2Nvbm5lY3QnLCBvblNvY2tldENvbm5lY3QpO1xuICAgIH07XG5cbiAgICBjb25zdCBvblNvY2tldENvbm5lY3QgPSAoKSA9PiB7XG5cbiAgICAgICAgc3RyZWFtLnBpcGUocmVxKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uU3RyZWFtRXJyb3IpO1xuICAgIH07XG5cbiAgICBjb25zdCBvblN0cmVhbUVycm9yID0gKGVycikgPT4ge1xuXG4gICAgICAgIHJlcS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfTtcblxuICAgIHJlcS5vbmNlKCdzb2NrZXQnLCBvblNvY2tldCk7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIG9uU3RyZWFtRXJyb3IpO1xufTtcblxuXG5pbnRlcm5hbHMucmVkaXJlY3RNZXRob2QgPSBmdW5jdGlvbiAoY29kZSwgbWV0aG9kLCBvcHRpb25zKSB7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSAzMDE6XG4gICAgICAgIGNhc2UgMzAyOlxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVkaXJlY3RNZXRob2QgfHwgbWV0aG9kO1xuXG4gICAgICAgIGNhc2UgMzAzOlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVkaXJlY3QzMDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0dFVCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzA3OlxuICAgICAgICBjYXNlIDMwODpcbiAgICAgICAgICAgIHJldHVybiBtZXRob2Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAocmVzLCBvcHRpb25zID0ge30pIHtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgdGhpcy5fcmVhZChyZXMsIG9wdGlvbnMsIChlcnIsIHBheWxvYWQpID0+IHtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZShwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKHJlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIG9wdGlvbnMgPSBIb2VrLmFwcGx5VG9EZWZhdWx0cyh0aGlzLl9kZWZhdWx0cywgb3B0aW9ucywgeyBzaGFsbG93OiBpbnRlcm5hbHMuc2hhbGxvd09wdGlvbnMgfSk7XG5cbiAgICAvLyBGaW5pc2ggb25jZVxuXG4gICAgbGV0IGNsaWVudFRpbWVvdXRJZCA9IG51bGw7XG5cbiAgICBjb25zdCBmaW5pc2ggPSAoZXJyLCBidWZmZXIpID0+IHtcblxuICAgICAgICBjbGVhclRpbWVvdXQoY2xpZW50VGltZW91dElkKTtcbiAgICAgICAgcmVhZGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uUmVhZGVyRXJyb3IpO1xuICAgICAgICByZWFkZXIucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uUmVhZGVyRmluaXNoKTtcbiAgICAgICAgcmVzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uUmVzRXJyb3IpO1xuICAgICAgICByZXMucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25SZXNBYm9ydGVkKTtcbiAgICAgICAgcmVzLnJlbW92ZUxpc3RlbmVyKCdhYm9ydGVkJywgb25SZXNBYm9ydGVkKTtcbiAgICAgICAgcmVzLm9uKCdlcnJvcicsIEhvZWsuaWdub3JlKTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgYnVmZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIEpTT05cblxuICAgICAgICBpZiAob3B0aW9ucy5qc29uID09PSAnZm9yY2UnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxzLnRyeVBhcnNlQnVmZmVyKGJ1ZmZlciwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbW9kZSBpcyBcInNtYXJ0XCIsIFwic3RyaWN0XCIgb3IgdHJ1ZVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gKHJlcy5oZWFkZXJzICYmIGludGVybmFscy5maW5kSGVhZGVyKCdjb250ZW50LXR5cGUnLCByZXMuaGVhZGVycykpIHx8ICcnO1xuICAgICAgICBjb25zdCBtaW1lID0gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXS50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoIWludGVybmFscy5qc29uUmVnZXgudGVzdChtaW1lKSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuanNvbiA9PT0gJ3N0cmljdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soQm9vbS5ub3RBY2NlcHRhYmxlKCdUaGUgY29udGVudC10eXBlIGlzIG5vdCBKU09OIGNvbXBhdGlibGUnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBidWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVybmFscy50cnlQYXJzZUJ1ZmZlcihidWZmZXIsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmluaXNoT25jZSA9IEhvZWsub25jZShmaW5pc2gpO1xuXG4gICAgY29uc3QgY2xpZW50VGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICBpZiAoY2xpZW50VGltZW91dCAmJlxuICAgICAgICBjbGllbnRUaW1lb3V0ID4gMCkge1xuXG4gICAgICAgIGNsaWVudFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXG4gICAgICAgICAgICBmaW5pc2hPbmNlKEJvb20uY2xpZW50VGltZW91dCgpKTtcbiAgICAgICAgfSwgY2xpZW50VGltZW91dCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGVyIGVycm9yc1xuXG4gICAgY29uc3Qgb25SZXNFcnJvciA9IChlcnIpID0+IHtcblxuICAgICAgICByZXR1cm4gZmluaXNoT25jZShlcnIuaXNCb29tID8gZXJyIDogQm9vbS5pbnRlcm5hbCgnUGF5bG9hZCBzdHJlYW0gZXJyb3InLCBlcnIpKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25SZXNBYm9ydGVkID0gKCkgPT4ge1xuXG4gICAgICAgIC8vIFdvcmthcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvMjA2MTFcbiAgICAgICAgLy8gVGhpcyBpcyBjb3ZlcmVkIGluIG5vZGUgMTBcbiAgICAgICAgLyogJGxhYjpjb3ZlcmFnZTpvZmYkICovXG4gICAgICAgIGlmIChyZXMuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiAkbGFiOmNvdmVyYWdlOm9uJCAqL1xuXG4gICAgICAgIHJldHVybiBmaW5pc2hPbmNlKEJvb20uaW50ZXJuYWwoJ1BheWxvYWQgc3RyZWFtIGNsb3NlZCBwcmVtYXR1cmVseScpKTtcbiAgICB9O1xuXG4gICAgcmVzLm9uY2UoJ2Vycm9yJywgb25SZXNFcnJvcik7XG4gICAgcmVzLm9uY2UoJ2Nsb3NlJywgb25SZXNBYm9ydGVkKTtcbiAgICByZXMub25jZSgnYWJvcnRlZCcsIG9uUmVzQWJvcnRlZCk7XG5cbiAgICAvLyBSZWFkIHBheWxvYWRcblxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWNvcmRlcih7IG1heEJ5dGVzOiBvcHRpb25zLm1heEJ5dGVzIH0pO1xuXG4gICAgY29uc3Qgb25SZWFkZXJFcnJvciA9IChlcnIpID0+IHtcblxuICAgICAgICBpZiAocmVzLmRlc3Ryb3kpIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdaaXAgc3RyZWFtIGhhcyBubyBkZXN0cm95KCkgbWV0aG9kXG4gICAgICAgICAgICByZXMuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbmlzaE9uY2UoZXJyKTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLm9uY2UoJ2Vycm9yJywgb25SZWFkZXJFcnJvcik7XG5cbiAgICBjb25zdCBvblJlYWRlckZpbmlzaCA9ICgpID0+IHtcblxuICAgICAgICByZXR1cm4gZmluaXNoT25jZShudWxsLCByZWFkZXIuY29sbGVjdCgpKTtcbiAgICB9O1xuXG4gICAgcmVhZGVyLm9uY2UoJ2ZpbmlzaCcsIG9uUmVhZGVyRmluaXNoKTtcblxuICAgIGlmIChvcHRpb25zLmd1bnppcCkge1xuICAgICAgICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBvcHRpb25zLmd1bnppcCA9PT0gJ2ZvcmNlJyA/XG4gICAgICAgICAgICAnZ3ppcCcgOlxuICAgICAgICAgICAgKHJlcy5oZWFkZXJzICYmIGludGVybmFscy5maW5kSGVhZGVyKCdjb250ZW50LWVuY29kaW5nJywgcmVzLmhlYWRlcnMpKSB8fCAnJztcblxuICAgICAgICBpZiAoL14oeC0pP2d6aXAoXFxzKixcXHMqaWRlbnRpdHkpPyQvLnRlc3QoY29udGVudEVuY29kaW5nKSkge1xuICAgICAgICAgICAgY29uc3QgZ3VuemlwID0gWmxpYi5jcmVhdGVHdW56aXAoKTtcblxuICAgICAgICAgICAgZ3VuemlwLm9uY2UoJ2Vycm9yJywgb25SZWFkZXJFcnJvcik7XG5cbiAgICAgICAgICAgIHJlcy5waXBlKGd1bnppcCkucGlwZShyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzLnBpcGUocmVhZGVyKTtcbn07XG5cblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUudG9SZWFkYWJsZVN0cmVhbSA9IGZ1bmN0aW9uIChwYXlsb2FkLCBlbmNvZGluZykge1xuXG4gICAgcmV0dXJuIG5ldyBQYXlsb2FkKHBheWxvYWQsIGVuY29kaW5nKTtcbn07XG5cblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUucGFyc2VDYWNoZUNvbnRyb2wgPSBmdW5jdGlvbiAoZmllbGQpIHtcblxuICAgIC8qXG4gICAgICAgIENhY2hlLUNvbnRyb2wgICA9IDEjY2FjaGUtZGlyZWN0aXZlXG4gICAgICAgIGNhY2hlLWRpcmVjdGl2ZSA9IHRva2VuIFsgXCI9XCIgKCB0b2tlbiAvIHF1b3RlZC1zdHJpbmcgKSBdXG4gICAgICAgIHRva2VuICAgICAgICAgICA9IFteXFx4MDAtXFx4MjBcXChcXCk8PkBcXCw7XFw6XFxcXFwiXFwvXFxbXFxdXFw/XFw9XFx7XFx9XFx4N0ZdK1xuICAgICAgICBxdW90ZWQtc3RyaW5nICAgPSBcIig/OlteXCJcXFxcXXxcXFxcLikqXCJcbiAgICAqL1xuXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE6IGRpcmVjdGl2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9ICAgMjogdG9rZW4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzogcXVvdGVkLXN0cmluZ1xuICAgIGNvbnN0IHJlZ2V4ID0gLyg/Ol58KD86XFxzKlxcLFxccyopKShbXlxceDAwLVxceDIwXFwoXFwpPD5AXFwsO1xcOlxcXFxcIlxcL1xcW1xcXVxcP1xcPVxce1xcfVxceDdGXSspKD86XFw9KD86KFteXFx4MDAtXFx4MjBcXChcXCk8PkBcXCw7XFw6XFxcXFwiXFwvXFxbXFxdXFw/XFw9XFx7XFx9XFx4N0ZdKyl8KD86XFxcIigoPzpbXlwiXFxcXF18XFxcXC4pKilcXFwiKSkpPy9nO1xuXG4gICAgY29uc3QgaGVhZGVyID0ge307XG4gICAgY29uc3QgZXJyb3IgPSBmaWVsZC5yZXBsYWNlKHJlZ2V4LCAoJDAsICQxLCAkMiwgJDMpID0+IHtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9ICQyIHx8ICQzO1xuICAgICAgICBoZWFkZXJbJDFdID0gdmFsdWUgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogdHJ1ZTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuXG4gICAgaWYgKGhlYWRlclsnbWF4LWFnZSddKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtYXhBZ2UgPSBwYXJzZUludChoZWFkZXJbJ21heC1hZ2UnXSwgMTApO1xuICAgICAgICAgICAgaWYgKGlzTmFOKG1heEFnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGVhZGVyWydtYXgtYWdlJ10gPSBtYXhBZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikgeyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChlcnJvciA/IG51bGwgOiBoZWFkZXIpO1xufTtcblxuXG4vLyBTaG9ydGN1dHNcblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHRoaXMuX3Nob3J0Y3V0KCdHRVQnLCB1cmksIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuQ2xpZW50LnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHRoaXMuX3Nob3J0Y3V0KCdQT1NUJywgdXJpLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fc2hvcnRjdXQoJ1BBVENIJywgdXJpLCBvcHRpb25zKTtcbn07XG5cblxuaW50ZXJuYWxzLkNsaWVudC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHVyaSwgb3B0aW9ucykge1xuXG4gICAgcmV0dXJuIHRoaXMuX3Nob3J0Y3V0KCdQVVQnLCB1cmksIG9wdGlvbnMpO1xufTtcblxuXG5pbnRlcm5hbHMuQ2xpZW50LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodXJpLCBvcHRpb25zKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fc2hvcnRjdXQoJ0RFTEVURScsIHVyaSwgb3B0aW9ucyk7XG59O1xuXG5cbmludGVybmFscy5DbGllbnQucHJvdG90eXBlLl9zaG9ydGN1dCA9IGFzeW5jIGZ1bmN0aW9uIChtZXRob2QsIHVyaSwgb3B0aW9ucyA9IHt9KSB7XG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnJlcXVlc3QobWV0aG9kLCB1cmksIG9wdGlvbnMpO1xuXG4gICAgbGV0IHBheWxvYWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcGF5bG9hZCA9IGF3YWl0IHRoaXMucmVhZChyZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVyci5kYXRhID0gZXJyLmRhdGEgfHwge307XG4gICAgICAgIGVyci5kYXRhLnJlcyA9IHJlcztcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIGlmIChyZXMuc3RhdHVzQ29kZSA8IDQwMCkge1xuICAgICAgICByZXR1cm4geyByZXMsIHBheWxvYWQgfTtcbiAgICB9XG5cbiAgICAvLyBSZXNwb25zZSBlcnJvclxuXG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgaXNSZXNwb25zZUVycm9yOiB0cnVlLFxuICAgICAgICBoZWFkZXJzOiByZXMuaGVhZGVycyxcbiAgICAgICAgcmVzLFxuICAgICAgICBwYXlsb2FkXG4gICAgfTtcblxuICAgIHRocm93IG5ldyBCb29tKGBSZXNwb25zZSBFcnJvcjogJHtyZXMuc3RhdHVzQ29kZX0gJHtyZXMuc3RhdHVzTWVzc2FnZX1gLCB7IHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlLCBkYXRhIH0pO1xufTtcblxuXG5pbnRlcm5hbHMudHJ5UGFyc2VCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyLCBuZXh0KSB7XG5cbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV4dChudWxsLCBudWxsKTtcbiAgICB9XG5cbiAgICBsZXQgcGF5bG9hZDtcbiAgICB0cnkge1xuICAgICAgICBwYXlsb2FkID0gQm91cm5lLnBhcnNlKGJ1ZmZlci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gbmV4dChCb29tLmJhZEdhdGV3YXkoZXJyLm1lc3NhZ2UsIHsgcGF5bG9hZDogYnVmZmVyIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dChudWxsLCBwYXlsb2FkKTtcbn07XG5cblxuaW50ZXJuYWxzLmZpbmRIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyTmFtZSwgaGVhZGVycykge1xuXG4gICAgY29uc3QgZm91bmRLZXkgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAuZmluZCgoa2V5KSA9PiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIHJldHVybiBmb3VuZEtleSAmJiBoZWFkZXJzW2ZvdW5kS2V5XTtcbn07XG5cbmludGVybmFscy5hcHBseVVybFRvT3B0aW9ucyA9IChvcHRpb25zLCB1cmwpID0+IHtcblxuICAgIG9wdGlvbnMuaG9zdCA9IHVybC5ob3N0O1xuICAgIG9wdGlvbnMub3JpZ2luID0gdXJsLm9yaWdpbjtcbiAgICBvcHRpb25zLnNlYXJjaFBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgb3B0aW9ucy5wcm90b2NvbCA9IHVybC5wcm90b2NvbDtcbiAgICBvcHRpb25zLmhvc3RuYW1lID0gdXJsLmhvc3RuYW1lO1xuICAgIG9wdGlvbnMuaGFzaCA9IHVybC5oYXNoO1xuICAgIG9wdGlvbnMuc2VhcmNoID0gdXJsLnNlYXJjaDtcbiAgICBvcHRpb25zLnBhdGhuYW1lID0gdXJsLnBhdGhuYW1lO1xuICAgIG9wdGlvbnMucGF0aCA9IGAke3VybC5wYXRobmFtZX0ke3VybC5zZWFyY2ggfHwgJyd9YDtcbiAgICBvcHRpb25zLmhyZWYgPSB1cmwuaHJlZjtcbiAgICBpZiAodXJsLnBvcnQgIT09ICcnKSB7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IE51bWJlcih1cmwucG9ydCk7XG4gICAgfVxuXG4gICAgaWYgKHVybC51c2VybmFtZSB8fCB1cmwucGFzc3dvcmQpIHtcbiAgICAgICAgb3B0aW9ucy5hdXRoID0gYCR7dXJsLnVzZXJuYW1lfToke3VybC5wYXNzd29yZH1gO1xuICAgICAgICBvcHRpb25zLnVzZXJuYW1lID0gdXJsLnVzZXJuYW1lO1xuICAgICAgICBvcHRpb25zLnBhc3N3b3JkID0gdXJsLnBhc3N3b3JkO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBpbnRlcm5hbHMuQ2xpZW50KCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlBheWxvYWQgPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5SZWFkYWJsZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBlbmNvZGluZykge1xuXG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IFtdLmNvbmNhdChwYXlsb2FkIHx8ICcnKTtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHNpemUgPSBzaXplICsgY2h1bmsubGVuZ3RoO1xuICAgICAgICAgICAgZGF0YVtpXSA9IEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgPyBjaHVuayA6IEJ1ZmZlci5mcm9tKGNodW5rKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RhdGEgPSBCdWZmZXIuY29uY2F0KGRhdGEsIHNpemUpO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2RpbmcgfHwgJ3V0ZjgnO1xuICAgIH1cblxuICAgIF9yZWFkKHNpemUpIHtcblxuICAgICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fcG9zaXRpb24sIHRoaXMuX3Bvc2l0aW9uICsgc2l6ZSk7XG4gICAgICAgIHRoaXMucHVzaChjaHVuaywgdGhpcy5fZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uICsgY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbiA+PSB0aGlzLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IEJvb20gPSByZXF1aXJlKCdAaGFwaS9ib29tJyk7XG5cblxuY29uc3QgaW50ZXJuYWxzID0ge307XG5cblxubW9kdWxlLmV4cG9ydHMgPSBpbnRlcm5hbHMuUmVjb3JkZXIgPSBjbGFzcyBleHRlbmRzIFN0cmVhbS5Xcml0YWJsZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnNldHRpbmdzID0gb3B0aW9uczsgICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjbG9uZSBzaW5jZSBjYWxsZWQgaW50ZXJuYWxseSB3aXRoIG5ldyBvYmplY3RcbiAgICAgICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBuZXh0KSB7XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MubWF4Qnl0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICsgY2h1bmsubGVuZ3RoID4gdGhpcy5zZXR0aW5ncy5tYXhCeXRlcykge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIEJvb20uZW50aXR5VG9vTGFyZ2UoJ1BheWxvYWQgY29udGVudCBsZW5ndGggZ3JlYXRlciB0aGFuIG1heGltdW0gYWxsb3dlZDogJyArIHRoaXMuc2V0dGluZ3MubWF4Qnl0ZXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGggKyBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgbmV4dCgpO1xuICAgIH1cblxuICAgIGNvbGxlY3QoKSB7XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDAgPyBCdWZmZXIuYWxsb2MoMCkgOiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMSA/IHRoaXMuYnVmZmVyc1swXSA6IEJ1ZmZlci5jb25jYXQodGhpcy5idWZmZXJzLCB0aGlzLmxlbmd0aCkpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGF5bG9hZCA9IHJlcXVpcmUoJy4vcGF5bG9hZCcpO1xuXG5cbmNvbnN0IGludGVybmFscyA9IHt9O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJuYWxzLlRhcCA9IGNsYXNzIGV4dGVuZHMgU3RyZWFtLlRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB9XG5cbiAgICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgbmV4dCkge1xuXG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgbmV4dChudWxsLCBjaHVuayk7XG4gICAgfVxuXG4gICAgY29sbGVjdCgpIHtcblxuICAgICAgICByZXR1cm4gbmV3IFBheWxvYWQodGhpcy5idWZmZXJzKTtcbiAgICB9XG59O1xuIiwiLy8gQGZsb3dcbid1c2Ugc3RyaWN0JztcblxudmFyIGtleSA9ICdfX2dsb2JhbF91bmlxdWVfaWRfXyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBnbG9iYWxba2V5XSA9IChnbG9iYWxba2V5XSB8fCAwKSArIDE7XG59O1xuIiwiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHJlc29sdmVQYXRobmFtZSBmcm9tICdyZXNvbHZlLXBhdGhuYW1lJztcbmltcG9ydCB2YWx1ZUVxdWFsIGZyb20gJ3ZhbHVlLWVxdWFsJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3Rpbnktd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ3RpbnktaW52YXJpYW50JztcblxuZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn1cbmZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59XG5mdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHBhdGgudG9Mb3dlckNhc2UoKS5pbmRleE9mKHByZWZpeC50b0xvd2VyQ2FzZSgpKSA9PT0gMCAmJiAnLz8jJy5pbmRleE9mKHBhdGguY2hhckF0KHByZWZpeC5sZW5ndGgpKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn1cbmZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuXG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG5cbiAgaWYgKHNlYXJjaEluZGV4ICE9PSAtMSkge1xuICAgIHNlYXJjaCA9IHBhdGhuYW1lLnN1YnN0cihzZWFyY2hJbmRleCk7XG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZS5zdWJzdHIoMCwgc2VhcmNoSW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogXCIjXCIgKyBoYXNoO1xuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbjtcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gT25lLWFyZyBmb3JtOiBwdXNoKGxvY2F0aW9uKVxuICAgIGxvY2F0aW9uID0gX2V4dGVuZHMoe30sIHBhdGgpO1xuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSByZXNvbHZlUGF0aG5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbmZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEucGF0aG5hbWUgPT09IGIucGF0aG5hbWUgJiYgYS5zZWFyY2ggPT09IGIuc2VhcmNoICYmIGEuaGFzaCA9PT0gYi5oYXNoICYmIGEua2V5ID09PSBiLmtleSAmJiB2YWx1ZUVxdWFsKGEuc3RhdGUsIGIuc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKSA6IHZvaWQgMDtcbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJykgOiB2b2lkIDA7XG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5mdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59XG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvcHN0YXRlIGV2ZW50IGlzIGFuIGV4dHJhbmVvdXMgV2ViS2l0IGV2ZW50LlxuICogQWNjb3VudHMgZm9yIHRoZSBmYWN0IHRoYXQgQ2hyb21lIG9uIGlPUyBmaXJlcyByZWFsIHBvcHN0YXRlIGV2ZW50c1xuICogY29udGFpbmluZyB1bmRlZmluZWQgc3RhdGUgd2hlbiBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uXG4gKi9cblxuZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufVxuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG5mdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeShwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cblxuICAhY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuVXNlSGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeSgpO1xuICB2YXIgbmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIgPSAhc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpO1xuICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICBfcHJvcHMkZm9yY2VSZWZyZXNoID0gX3Byb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IF9wcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdm9pZCAwID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IF9wcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB2b2lkIDAgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXRoID0gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJykgOiB2b2lkIDA7XG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cbiAgICBpZiAoaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkpIHJldHVybjtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH1cblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247IC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGZyb21Mb2NhdGlvbi5rZXkpO1xuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07IC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoe1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHN0YXRlOiBzdGF0ZVxuICAgICAgICB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ICsgMSk7XG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5JykgOiB2b2lkIDA7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodHlwZW9mIHBhdGggPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZSh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgc3RhdGU6IHN0YXRlXG4gICAgICAgIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKSA6IHZvaWQgMDtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICBnbygtMSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgZ28oMSk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gY2hlY2tET01MaXN0ZW5lcnMoZGVsdGEpIHtcbiAgICBsaXN0ZW5lckNvdW50ICs9IGRlbHRhO1xuXG4gICAgaWYgKGxpc3RlbmVyQ291bnQgPT09IDEgJiYgZGVsdGEgPT09IDEpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gYmxvY2socHJvbXB0KSB7XG4gICAgaWYgKHByb21wdCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcm9tcHQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQkMSA9ICdoYXNoY2hhbmdlJztcbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJpcEhhc2godXJsKSB7XG4gIHZhciBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xufVxuXG5mdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShzdHJpcEhhc2god2luZG93LmxvY2F0aW9uLmhyZWYpICsgJyMnICsgcGF0aCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuXG4gICFjYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuICB2YXIgX3Byb3BzID0gcHJvcHMsXG4gICAgICBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBfcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHZvaWQgMCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRoYXNoVHlwZSA9IF9wcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB2b2lkIDAgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG4gIGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpIDogdm9pZCAwO1xuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoKTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfVxuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgdmFyIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxvY2F0aW9uc0FyZUVxdWFsJCQxKGEsIGIpIHtcbiAgICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2g7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG4gICAgICBpZiAoIWZvcmNlTmV4dFBvcCAmJiBsb2NhdGlvbnNBcmVFcXVhbCQkMShwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHJldHVybjsgLy8gSWdub3JlIHRoaXMgY2hhbmdlOyB3ZSBhbHJlYWR5IHNldFN0YXRlIGluIHB1c2gvcmVwbGFjZS5cblxuICAgICAgaWdub3JlUGF0aCA9IG51bGw7XG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uOyAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgodG9Mb2NhdGlvbikpO1xuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG4gICAgdmFyIGZyb21JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoZnJvbUxvY2F0aW9uKSk7XG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH0gLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG5cblxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildOyAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHZhciBiYXNlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgIHZhciBocmVmID0gJyc7XG5cbiAgICBpZiAoYmFzZVRhZyAmJiBiYXNlVGFnLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB7XG4gICAgICBocmVmID0gc3RyaXBIYXNoKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZiArICcjJyArIGVuY29kZVBhdGgoYmFzZW5hbWUgKyBjcmVhdGVQYXRoKGxvY2F0aW9uKSk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlOyBpdCBpcyBpZ25vcmVkJykgOiB2b2lkIDA7XG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUFVTSCwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcHVzaEhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ICsgMSk7XG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKSA6IHZvaWQgMDtcbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKSA6IHZvaWQgMDtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSAmJiBkZWx0YSA9PT0gMSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50JDEsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoSGFzaENoYW5nZUV2ZW50JDEsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBibG9jayhwcm9tcHQpIHtcbiAgICBpZiAocHJvbXB0ID09PSB2b2lkIDApIHtcbiAgICAgIHByb21wdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG5cbiAgdmFyIF9wcm9wcyA9IHByb3BzLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gX3Byb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHZvaWQgMCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IF9wcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB2b2lkIDAgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBfcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdm9pZCAwID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgZW50cnkua2V5IHx8IGNyZWF0ZUtleSgpKTtcbiAgfSk7IC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGNyZWF0ZVBhdGg7XG5cbiAgZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG5cbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpIDogdm9pZCAwO1xuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChoaXN0b3J5LmluZGV4ICsgbiwgMCwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIGdvKC0xKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICBnbygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBibG9jayhwcm9tcHQpIHtcbiAgICBpZiAocHJvbXB0ID09PSB2b2lkIDApIHtcbiAgICAgIHByb21wdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5leHBvcnQgeyBjcmVhdGVCcm93c2VySGlzdG9yeSwgY3JlYXRlSGFzaEhpc3RvcnksIGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCwgcGFyc2VQYXRoLCBjcmVhdGVQYXRoIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICBuYW1lOiB0cnVlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgY2FsbGVyOiB0cnVlLFxuICAgIGNhbGxlZTogdHJ1ZSxcbiAgICBhcmd1bWVudHM6IHRydWUsXG4gICAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAgICckJHR5cGVvZic6IHRydWUsXG4gICAgcmVuZGVyOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWVcbn07XG5cbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgICBjb21wYXJlOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBwcm9wVHlwZXM6IHRydWUsXG4gICAgdHlwZTogdHJ1ZVxufTtcblxudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW1JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICAgIGlmIChSZWFjdElzLmlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gICAgfVxuICAgIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG5cbiAgICAgICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICAgICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKGJsYWNrbGlzdCAmJiBibGFja2xpc3Rba2V5XSkgJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG5cbi8vIFRoaXMgd2lsbCBiZSBhIHByb3BlciBpdGVyYWJsZSAnTWFwJyBpbiBlbmdpbmVzIHRoYXQgc3VwcG9ydCBpdCxcbi8vIG9yIGEgZmFrZXktZmFrZSBQc2V1ZG9NYXAgaW4gb2xkZXIgdmVyc2lvbnMuXG52YXIgTWFwID0gcmVxdWlyZSgncHNldWRvbWFwJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8vIEEgbGlua2VkIGxpc3QgdG8ga2VlcCB0cmFjayBvZiByZWNlbnRseS11c2VkLW5lc3NcbnZhciBZYWxsaXN0ID0gcmVxdWlyZSgneWFsbGlzdCcpXG5cbi8vIHVzZSBzeW1ib2xzIGlmIHBvc3NpYmxlLCBvdGhlcndpc2UganVzdCBfcHJvcHNcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb2Nlc3MuZW52Ll9ub2RlTFJVQ2FjaGVGb3JjZU5vU3ltYm9sICE9PSAnMSdcbnZhciBtYWtlU3ltYm9sXG5pZiAoaGFzU3ltYm9sKSB7XG4gIG1ha2VTeW1ib2wgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIFN5bWJvbChrZXkpXG4gIH1cbn0gZWxzZSB7XG4gIG1ha2VTeW1ib2wgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICdfJyArIGtleVxuICB9XG59XG5cbnZhciBNQVggPSBtYWtlU3ltYm9sKCdtYXgnKVxudmFyIExFTkdUSCA9IG1ha2VTeW1ib2woJ2xlbmd0aCcpXG52YXIgTEVOR1RIX0NBTENVTEFUT1IgPSBtYWtlU3ltYm9sKCdsZW5ndGhDYWxjdWxhdG9yJylcbnZhciBBTExPV19TVEFMRSA9IG1ha2VTeW1ib2woJ2FsbG93U3RhbGUnKVxudmFyIE1BWF9BR0UgPSBtYWtlU3ltYm9sKCdtYXhBZ2UnKVxudmFyIERJU1BPU0UgPSBtYWtlU3ltYm9sKCdkaXNwb3NlJylcbnZhciBOT19ESVNQT1NFX09OX1NFVCA9IG1ha2VTeW1ib2woJ25vRGlzcG9zZU9uU2V0JylcbnZhciBMUlVfTElTVCA9IG1ha2VTeW1ib2woJ2xydUxpc3QnKVxudmFyIENBQ0hFID0gbWFrZVN5bWJvbCgnY2FjaGUnKVxuXG5mdW5jdGlvbiBuYWl2ZUxlbmd0aCAoKSB7IHJldHVybiAxIH1cblxuLy8gbHJ1TGlzdCBpcyBhIHlhbGxpc3Qgd2hlcmUgdGhlIGhlYWQgaXMgdGhlIHlvdW5nZXN0XG4vLyBpdGVtLCBhbmQgdGhlIHRhaWwgaXMgdGhlIG9sZGVzdC4gIHRoZSBsaXN0IGNvbnRhaW5zIHRoZSBIaXRcbi8vIG9iamVjdHMgYXMgdGhlIGVudHJpZXMuXG4vLyBFYWNoIEhpdCBvYmplY3QgaGFzIGEgcmVmZXJlbmNlIHRvIGl0cyBZYWxsaXN0Lk5vZGUuICBUaGlzXG4vLyBuZXZlciBjaGFuZ2VzLlxuLy9cbi8vIGNhY2hlIGlzIGEgTWFwIChvciBQc2V1ZG9NYXApIHRoYXQgbWF0Y2hlcyB0aGUga2V5cyB0b1xuLy8gdGhlIFlhbGxpc3QuTm9kZSBvYmplY3QuXG5mdW5jdGlvbiBMUlVDYWNoZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTFJVQ2FjaGUpKSB7XG4gICAgcmV0dXJuIG5ldyBMUlVDYWNoZShvcHRpb25zKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHZhciBtYXggPSB0aGlzW01BWF0gPSBvcHRpb25zLm1heFxuICAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG4gIGlmICghbWF4IHx8XG4gICAgICAhKHR5cGVvZiBtYXggPT09ICdudW1iZXInKSB8fFxuICAgICAgbWF4IDw9IDApIHtcbiAgICB0aGlzW01BWF0gPSBJbmZpbml0eVxuICB9XG5cbiAgdmFyIGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgaWYgKHR5cGVvZiBsYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGxjID0gbmFpdmVMZW5ndGhcbiAgfVxuICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxjXG5cbiAgdGhpc1tBTExPV19TVEFMRV0gPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gIHRoaXNbTUFYX0FHRV0gPSBvcHRpb25zLm1heEFnZSB8fCAwXG4gIHRoaXNbRElTUE9TRV0gPSBvcHRpb25zLmRpc3Bvc2VcbiAgdGhpc1tOT19ESVNQT1NFX09OX1NFVF0gPSBvcHRpb25zLm5vRGlzcG9zZU9uU2V0IHx8IGZhbHNlXG4gIHRoaXMucmVzZXQoKVxufVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ21heCcsIHtcbiAgc2V0OiBmdW5jdGlvbiAobUwpIHtcbiAgICBpZiAoIW1MIHx8ICEodHlwZW9mIG1MID09PSAnbnVtYmVyJykgfHwgbUwgPD0gMCkge1xuICAgICAgbUwgPSBJbmZpbml0eVxuICAgIH1cbiAgICB0aGlzW01BWF0gPSBtTFxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbTUFYXVxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnYWxsb3dTdGFsZScsIHtcbiAgc2V0OiBmdW5jdGlvbiAoYWxsb3dTdGFsZSkge1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW0FMTE9XX1NUQUxFXVxuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbWF4QWdlJywge1xuICBzZXQ6IGZ1bmN0aW9uIChtQSkge1xuICAgIGlmICghbUEgfHwgISh0eXBlb2YgbUEgPT09ICdudW1iZXInKSB8fCBtQSA8IDApIHtcbiAgICAgIG1BID0gMFxuICAgIH1cbiAgICB0aGlzW01BWF9BR0VdID0gbUFcbiAgICB0cmltKHRoaXMpXG4gIH0sXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzW01BWF9BR0VdXG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWVcbn0pXG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgJ2xlbmd0aENhbGN1bGF0b3InLCB7XG4gIHNldDogZnVuY3Rpb24gKGxDKSB7XG4gICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbEMgPSBuYWl2ZUxlbmd0aFxuICAgIH1cbiAgICBpZiAobEMgIT09IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKSB7XG4gICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDXG4gICAgICB0aGlzW0xFTkdUSF0gPSAwXG4gICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgaGl0Lmxlbmd0aCA9IHRoaXNbTEVOR1RIX0NBTENVTEFUT1JdKGhpdC52YWx1ZSwgaGl0LmtleSlcbiAgICAgICAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgICAgIH0sIHRoaXMpXG4gICAgfVxuICAgIHRyaW0odGhpcylcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTEVOR1RIXSB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCAnaXRlbUNvdW50Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KVxuXG5MUlVDYWNoZS5wcm90b3R5cGUucmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgdmFyIHByZXYgPSB3YWxrZXIucHJldlxuICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKVxuICAgIHdhbGtlciA9IHByZXZcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RlcCAoc2VsZiwgZm4sIG5vZGUsIHRoaXNwKSB7XG4gIHZhciBoaXQgPSBub2RlLnZhbHVlXG4gIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICBkZWwoc2VsZiwgbm9kZSlcbiAgICBpZiAoIXNlbGZbQUxMT1dfU1RBTEVdKSB7XG4gICAgICBoaXQgPSB1bmRlZmluZWRcbiAgICB9XG4gIH1cbiAgaWYgKGhpdCkge1xuICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZilcbiAgfVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXNbTFJVX0xJU1RdLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICB2YXIgbmV4dCA9IHdhbGtlci5uZXh0XG4gICAgZm9yRWFjaFN0ZXAodGhpcywgZm4sIHdhbGtlciwgdGhpc3ApXG4gICAgd2Fsa2VyID0gbmV4dFxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrLmtleVxuICB9LCB0aGlzKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrLnZhbHVlXG4gIH0sIHRoaXMpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXNbRElTUE9TRV0gJiZcbiAgICAgIHRoaXNbTFJVX0xJU1RdICYmXG4gICAgICB0aGlzW0xSVV9MSVNUXS5sZW5ndGgpIHtcbiAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgIHRoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKVxuICAgIH0sIHRoaXMpXG4gIH1cblxuICB0aGlzW0NBQ0hFXSA9IG5ldyBNYXAoKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCkgLy8gbGlzdCBvZiBpdGVtcyBpbiBvcmRlciBvZiB1c2UgcmVjZW5jeVxuICB0aGlzW0xFTkdUSF0gPSAwIC8vIGxlbmd0aCBvZiBpdGVtcyBpbiB0aGUgbGlzdFxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLm1hcChmdW5jdGlvbiAoaGl0KSB7XG4gICAgaWYgKCFpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9XG4gICAgfVxuICB9LCB0aGlzKS50b0FycmF5KCkuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgcmV0dXJuIGhcbiAgfSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXBMcnUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzW0xSVV9MSVNUXVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuTFJVQ2FjaGUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAobiwgb3B0cykge1xuICB2YXIgc3RyID0gJ0xSVUNhY2hlIHsnXG4gIHZhciBleHRyYXMgPSBmYWxzZVxuXG4gIHZhciBhcyA9IHRoaXNbQUxMT1dfU1RBTEVdXG4gIGlmIChhcykge1xuICAgIHN0ciArPSAnXFxuICBhbGxvd1N0YWxlOiB0cnVlJ1xuICAgIGV4dHJhcyA9IHRydWVcbiAgfVxuXG4gIHZhciBtYXggPSB0aGlzW01BWF1cbiAgaWYgKG1heCAmJiBtYXggIT09IEluZmluaXR5KSB7XG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgc3RyICs9ICcsJ1xuICAgIH1cbiAgICBzdHIgKz0gJ1xcbiAgbWF4OiAnICsgdXRpbC5pbnNwZWN0KG1heCwgb3B0cylcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgbWF4QWdlID0gdGhpc1tNQVhfQUdFXVxuICBpZiAobWF4QWdlKSB7XG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgc3RyICs9ICcsJ1xuICAgIH1cbiAgICBzdHIgKz0gJ1xcbiAgbWF4QWdlOiAnICsgdXRpbC5pbnNwZWN0KG1heEFnZSwgb3B0cylcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgbGMgPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXVxuICBpZiAobGMgJiYgbGMgIT09IG5haXZlTGVuZ3RoKSB7XG4gICAgaWYgKGV4dHJhcykge1xuICAgICAgc3RyICs9ICcsJ1xuICAgIH1cbiAgICBzdHIgKz0gJ1xcbiAgbGVuZ3RoOiAnICsgdXRpbC5pbnNwZWN0KHRoaXNbTEVOR1RIXSwgb3B0cylcbiAgICBleHRyYXMgPSB0cnVlXG4gIH1cblxuICB2YXIgZGlkRmlyc3QgPSBmYWxzZVxuICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGRpZEZpcnN0KSB7XG4gICAgICBzdHIgKz0gJyxcXG4gICdcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGV4dHJhcykge1xuICAgICAgICBzdHIgKz0gJyxcXG4nXG4gICAgICB9XG4gICAgICBkaWRGaXJzdCA9IHRydWVcbiAgICAgIHN0ciArPSAnXFxuICAnXG4gICAgfVxuICAgIHZhciBrZXkgPSB1dGlsLmluc3BlY3QoaXRlbS5rZXkpLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4gICcpXG4gICAgdmFyIHZhbCA9IHsgdmFsdWU6IGl0ZW0udmFsdWUgfVxuICAgIGlmIChpdGVtLm1heEFnZSAhPT0gbWF4QWdlKSB7XG4gICAgICB2YWwubWF4QWdlID0gaXRlbS5tYXhBZ2VcbiAgICB9XG4gICAgaWYgKGxjICE9PSBuYWl2ZUxlbmd0aCkge1xuICAgICAgdmFsLmxlbmd0aCA9IGl0ZW0ubGVuZ3RoXG4gICAgfVxuICAgIGlmIChpc1N0YWxlKHRoaXMsIGl0ZW0pKSB7XG4gICAgICB2YWwuc3RhbGUgPSB0cnVlXG4gICAgfVxuXG4gICAgdmFsID0gdXRpbC5pbnNwZWN0KHZhbCwgb3B0cykuc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbiAgJylcbiAgICBzdHIgKz0ga2V5ICsgJyA9PiAnICsgdmFsXG4gIH0pXG5cbiAgaWYgKGRpZEZpcnN0IHx8IGV4dHJhcykge1xuICAgIHN0ciArPSAnXFxuJ1xuICB9XG4gIHN0ciArPSAnfSdcblxuICByZXR1cm4gc3RyXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdXG5cbiAgdmFyIG5vdyA9IG1heEFnZSA/IERhdGUubm93KCkgOiAwXG4gIHZhciBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KVxuXG4gIGlmICh0aGlzW0NBQ0hFXS5oYXMoa2V5KSkge1xuICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgIGRlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHZhciBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSlcbiAgICB2YXIgaXRlbSA9IG5vZGUudmFsdWVcblxuICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICBpZiAoIXRoaXNbTk9fRElTUE9TRV9PTl9TRVRdKSB7XG4gICAgICAgIHRoaXNbRElTUE9TRV0oa2V5LCBpdGVtLnZhbHVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGl0ZW0ubm93ID0gbm93XG4gICAgaXRlbS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICBpdGVtLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzW0xFTkdUSF0gKz0gbGVuIC0gaXRlbS5sZW5ndGhcbiAgICBpdGVtLmxlbmd0aCA9IGxlblxuICAgIHRoaXMuZ2V0KGtleSlcbiAgICB0cmltKHRoaXMpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgbGVuLCBub3csIG1heEFnZSlcblxuICAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICB0aGlzW0RJU1BPU0VdKGtleSwgdmFsdWUpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdGhpc1tMRU5HVEhdICs9IGhpdC5sZW5ndGhcbiAgdGhpc1tMUlVfTElTVF0udW5zaGlmdChoaXQpXG4gIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpXG4gIHRyaW0odGhpcylcbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlXG4gIHZhciBoaXQgPSB0aGlzW0NBQ0hFXS5nZXQoa2V5KS52YWx1ZVxuICBpZiAoaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbFxuICBpZiAoIW5vZGUpIHJldHVybiBudWxsXG4gIGRlbCh0aGlzLCBub2RlKVxuICByZXR1cm4gbm9kZS52YWx1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGtleSkge1xuICBkZWwodGhpcywgdGhpc1tDQUNIRV0uZ2V0KGtleSkpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGFycikge1xuICAvLyByZXNldCB0aGUgY2FjaGVcbiAgdGhpcy5yZXNldCgpXG5cbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgLy8gQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgZm9yICh2YXIgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgIHZhciBoaXQgPSBhcnJbbF1cbiAgICB2YXIgZXhwaXJlc0F0ID0gaGl0LmUgfHwgMFxuICAgIGlmIChleHBpcmVzQXQgPT09IDApIHtcbiAgICAgIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgIC8vIGRvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgaWYgKG1heEFnZSA+IDApIHtcbiAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wcnVuZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXNbQ0FDSEVdLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICBnZXQoc2VsZiwga2V5LCBmYWxzZSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0IChzZWxmLCBrZXksIGRvVXNlKSB7XG4gIHZhciBub2RlID0gc2VsZltDQUNIRV0uZ2V0KGtleSlcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaGl0ID0gbm9kZS52YWx1ZVxuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBub2RlKVxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkge1xuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGl0KSBoaXQgPSBoaXQudmFsdWVcbiAgfVxuICByZXR1cm4gaGl0XG59XG5cbmZ1bmN0aW9uIGlzU3RhbGUgKHNlbGYsIGhpdCkge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGZbTUFYX0FHRV0pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIHN0YWxlID0gZmFsc2VcbiAgdmFyIGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICBpZiAoaGl0Lm1heEFnZSkge1xuICAgIHN0YWxlID0gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgfSBlbHNlIHtcbiAgICBzdGFsZSA9IHNlbGZbTUFYX0FHRV0gJiYgKGRpZmYgPiBzZWxmW01BWF9BR0VdKVxuICB9XG4gIHJldHVybiBzdGFsZVxufVxuXG5mdW5jdGlvbiB0cmltIChzZWxmKSB7XG4gIGlmIChzZWxmW0xFTkdUSF0gPiBzZWxmW01BWF0pIHtcbiAgICBmb3IgKHZhciB3YWxrZXIgPSBzZWxmW0xSVV9MSVNUXS50YWlsO1xuICAgICAgc2VsZltMRU5HVEhdID4gc2VsZltNQVhdICYmIHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICAgIC8vIFdlIGtub3cgdGhhdCB3ZSdyZSBhYm91dCB0byBkZWxldGUgdGhpcyBvbmUsIGFuZCBhbHNvXG4gICAgICAvLyB3aGF0IHRoZSBuZXh0IGxlYXN0IHJlY2VudGx5IHVzZWQga2V5IHdpbGwgYmUsIHNvIGp1c3RcbiAgICAgIC8vIGdvIGFoZWFkIGFuZCBzZXQgaXQgbm93LlxuICAgICAgdmFyIHByZXYgPSB3YWxrZXIucHJldlxuICAgICAgZGVsKHNlbGYsIHdhbGtlcilcbiAgICAgIHdhbGtlciA9IHByZXZcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVsIChzZWxmLCBub2RlKSB7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIGhpdCA9IG5vZGUudmFsdWVcbiAgICBpZiAoc2VsZltESVNQT1NFXSkge1xuICAgICAgc2VsZltESVNQT1NFXShoaXQua2V5LCBoaXQudmFsdWUpXG4gICAgfVxuICAgIHNlbGZbTEVOR1RIXSAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZltDQUNIRV0uZGVsZXRlKGhpdC5rZXkpXG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKVxuICB9XG59XG5cbi8vIGNsYXNzeSwgc2luY2UgVjggcHJlZmVycyBwcmVkaWN0YWJsZSBvYmplY3RzLlxuZnVuY3Rpb24gRW50cnkgKGtleSwgdmFsdWUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgdGhpcy5rZXkgPSBrZXlcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMubm93ID0gbm93XG4gIHRoaXMubWF4QWdlID0gbWF4QWdlIHx8IDBcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdFxuXG5ZYWxsaXN0Lk5vZGUgPSBOb2RlXG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3RcblxuZnVuY3Rpb24gWWFsbGlzdCAobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KClcbiAgfVxuXG4gIHNlbGYudGFpbCA9IG51bGxcbiAgc2VsZi5oZWFkID0gbnVsbFxuICBzZWxmLmxlbmd0aCA9IDBcblxuICBpZiAobGlzdCAmJiB0eXBlb2YgbGlzdC5mb3JFYWNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBzZWxmLnB1c2goaXRlbSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnJlbW92ZU5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZS5saXN0ICE9PSB0aGlzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmluZyBub2RlIHdoaWNoIGRvZXMgbm90IGJlbG9uZyB0byB0aGlzIGxpc3QnKVxuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHRcbiAgdmFyIHByZXYgPSBub2RlLnByZXZcblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHByZXZcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dFxuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5leHRcbiAgfVxuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gcHJldlxuICB9XG5cbiAgbm9kZS5saXN0Lmxlbmd0aC0tXG4gIG5vZGUubmV4dCA9IG51bGxcbiAgbm9kZS5wcmV2ID0gbnVsbFxuICBub2RlLmxpc3QgPSBudWxsXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICB2YXIgdGFpbCA9IHRoaXMudGFpbFxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldlxuICAgIHdhbGtlci5wcmV2ID0gd2Fsa2VyLm5leHRcbiAgICB3YWxrZXIubmV4dCA9IHBcbiAgfVxuICB0aGlzLmhlYWQgPSB0YWlsXG4gIHRoaXMudGFpbCA9IGhlYWRcbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgZ3VkIGZyb20gJ2d1ZCc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuXG52YXIgTUFYX1NJR05FRF8zMV9CSVRfSU5UID0gMTA3Mzc0MTgyMztcblxuZnVuY3Rpb24gb2JqZWN0SXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50RW1pdHRlcih2YWx1ZSkge1xuICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHtcbiAgICBvbjogZnVuY3Rpb24gb24oaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXJzID0gaGFuZGxlcnMuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoICE9PSBoYW5kbGVyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG5ld1ZhbHVlLCBjaGFuZ2VkQml0cykge1xuICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIodmFsdWUsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuWzBdIDogY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlYWN0Q29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIHZhciBfUHJvdmlkZXIkY2hpbGRDb250ZXgsIF9Db25zdW1lciRjb250ZXh0VHlwZTtcblxuICB2YXIgY29udGV4dFByb3AgPSAnX19jcmVhdGUtcmVhY3QtY29udGV4dC0nICsgZ3VkKCkgKyAnX18nO1xuXG4gIHZhciBQcm92aWRlciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgICBmdW5jdGlvbiBQcm92aWRlcigpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgIF90aGlzLmVtaXR0ZXIgPSBjcmVhdGVFdmVudEVtaXR0ZXIoX3RoaXMucHJvcHMudmFsdWUpO1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBQcm92aWRlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIHJldHVybiBfcmVmID0ge30sIF9yZWZbY29udGV4dFByb3BdID0gdGhpcy5lbWl0dGVyLCBfcmVmO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gbmV4dFByb3BzLnZhbHVlKSB7XG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IG5leHRQcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGNoYW5nZWRCaXRzO1xuXG4gICAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKChjaGFuZ2VkQml0cyAmIE1BWF9TSUdORURfMzFfQklUX0lOVCkgPT09IGNoYW5nZWRCaXRzLCAnY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAnICsgY2hhbmdlZEJpdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWRCaXRzIHw9IDA7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZEJpdHMgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5zZXQobmV4dFByb3BzLnZhbHVlLCBjaGFuZ2VkQml0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3ZpZGVyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSAoX1Byb3ZpZGVyJGNoaWxkQ29udGV4ID0ge30sIF9Qcm92aWRlciRjaGlsZENvbnRleFtjb250ZXh0UHJvcF0gPSBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsIF9Qcm92aWRlciRjaGlsZENvbnRleCk7XG5cbiAgdmFyIENvbnN1bWVyID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShDb25zdW1lciwgX0NvbXBvbmVudDIpO1xuXG4gICAgZnVuY3Rpb24gQ29uc3VtZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyO1xuXG4gICAgICBfdGhpczIgPSBfQ29tcG9uZW50Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBfdGhpczIuc3RhdGUgPSB7XG4gICAgICAgIHZhbHVlOiBfdGhpczIuZ2V0VmFsdWUoKVxuICAgICAgfTtcblxuICAgICAgX3RoaXMyLm9uVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBjaGFuZ2VkQml0cykge1xuICAgICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gX3RoaXMyLm9ic2VydmVkQml0cyB8IDA7XG5cbiAgICAgICAgaWYgKChvYnNlcnZlZEJpdHMgJiBjaGFuZ2VkQml0cykgIT09IDApIHtcbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzIgPSBDb25zdW1lci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IG5leHRQcm9wcy5vYnNlcnZlZEJpdHM7XG4gICAgICB0aGlzLm9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCA/IE1BWF9TSUdORURfMzFfQklUX0lOVCA6IG9ic2VydmVkQml0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5vbih0aGlzLm9uVXBkYXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IHRoaXMucHJvcHMub2JzZXJ2ZWRCaXRzO1xuICAgICAgdGhpcy5vYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCB8fCBvYnNlcnZlZEJpdHMgPT09IG51bGwgPyBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgOiBvYnNlcnZlZEJpdHM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0ub2ZmKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8yLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5nZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG9ubHlDaGlsZCh0aGlzLnByb3BzLmNoaWxkcmVuKSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnN1bWVyO1xuICB9KENvbXBvbmVudCk7XG5cbiAgQ29uc3VtZXIuY29udGV4dFR5cGVzID0gKF9Db25zdW1lciRjb250ZXh0VHlwZSA9IHt9LCBfQ29uc3VtZXIkY29udGV4dFR5cGVbY29udGV4dFByb3BdID0gUHJvcFR5cGVzLm9iamVjdCwgX0NvbnN1bWVyJGNvbnRleHRUeXBlKTtcbiAgcmV0dXJuIHtcbiAgICBQcm92aWRlcjogUHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IENvbnN1bWVyXG4gIH07XG59XG5cbnZhciBpbmRleCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQgfHwgY3JlYXRlUmVhY3RDb250ZXh0O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG52YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSAgKyAnYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIVJlYWN0SXMuaXNWYWxpZEVsZW1lbnRUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50IHR5cGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudHMgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LCBnb3QgJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cy4gJyArXG4gICAgICAgICAgICAnQSBjb21tb24gbWlzdGFrZSBpcyB0byB3cml0ZSBvbmVPZih4LCB5LCB6KSBpbnN0ZWFkIG9mIG9uZU9mKFt4LCB5LCB6XSkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnc3ltYm9sJykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIFN0cmluZyhwcm9wVmFsdWUpICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChoYXMocHJvcFZhbHVlLCBrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsImlmIChwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lID09PSAncHNldWRvbWFwJyAmJlxuICAgIHByb2Nlc3MuZW52Lm5wbV9saWZlY3ljbGVfc2NyaXB0ID09PSAndGVzdCcpXG4gIHByb2Nlc3MuZW52LlRFU1RfUFNFVURPTUFQID0gJ3RydWUnXG5cbmlmICh0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmICFwcm9jZXNzLmVudi5URVNUX1BTRVVET01BUCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IE1hcFxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3BzZXVkb21hcCcpXG59XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbm1vZHVsZS5leHBvcnRzID0gUHNldWRvTWFwXG5cbmZ1bmN0aW9uIFBzZXVkb01hcCAoc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQc2V1ZG9NYXApKSAvLyB3aHl5eXl5eXlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ29uc3RydWN0b3IgUHNldWRvTWFwIHJlcXVpcmVzICduZXcnXCIpXG5cbiAgdGhpcy5jbGVhcigpXG5cbiAgaWYgKHNldCkge1xuICAgIGlmICgoc2V0IGluc3RhbmNlb2YgUHNldWRvTWFwKSB8fFxuICAgICAgICAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXQgaW5zdGFuY2VvZiBNYXApKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXQpKVxuICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKGt2KSB7XG4gICAgICAgIHRoaXMuc2V0KGt2WzBdLCBrdlsxXSlcbiAgICAgIH0sIHRoaXMpXG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhcmd1bWVudCcpXG4gIH1cbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgT2JqZWN0LmtleXModGhpcy5fZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnc2l6ZScpXG4gICAgICBmbi5jYWxsKHRoaXNwLCB0aGlzLl9kYXRhW2tdLnZhbHVlLCB0aGlzLl9kYXRhW2tdLmtleSlcbiAgfSwgdGhpcylcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoaykge1xuICByZXR1cm4gISFmaW5kKHRoaXMuX2RhdGEsIGspXG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGspIHtcbiAgdmFyIHJlcyA9IGZpbmQodGhpcy5fZGF0YSwgaylcbiAgcmV0dXJuIHJlcyAmJiByZXMudmFsdWVcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoaywgdikge1xuICBzZXQodGhpcy5fZGF0YSwgaywgdilcbn1cblxuUHNldWRvTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoaykge1xuICB2YXIgcmVzID0gZmluZCh0aGlzLl9kYXRhLCBrKVxuICBpZiAocmVzKSB7XG4gICAgZGVsZXRlIHRoaXMuX2RhdGFbcmVzLl9pbmRleF1cbiAgICB0aGlzLl9kYXRhLnNpemUtLVxuICB9XG59XG5cblBzZXVkb01hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBkYXRhLnNpemUgPSAwXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfZGF0YScsIHtcbiAgICB2YWx1ZTogZGF0YSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQc2V1ZG9NYXAucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuc2l6ZVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChuKSB7fSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KVxuXG5Qc2V1ZG9NYXAucHJvdG90eXBlLnZhbHVlcyA9XG5Qc2V1ZG9NYXAucHJvdG90eXBlLmtleXMgPVxuUHNldWRvTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9ycyBhcmUgbm90IGltcGxlbWVudGVkIGluIHRoaXMgdmVyc2lvbicpXG59XG5cbi8vIEVpdGhlciBpZGVudGljYWwsIG9yIGJvdGggTmFOXG5mdW5jdGlvbiBzYW1lIChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYlxufVxuXG5mdW5jdGlvbiBFbnRyeSAoaywgdiwgaSkge1xuICB0aGlzLmtleSA9IGtcbiAgdGhpcy52YWx1ZSA9IHZcbiAgdGhpcy5faW5kZXggPSBpXG59XG5cbmZ1bmN0aW9uIGZpbmQgKGRhdGEsIGspIHtcbiAgZm9yICh2YXIgaSA9IDAsIHMgPSAnXycgKyBrLCBrZXkgPSBzO1xuICAgICAgIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICAgICBrZXkgPSBzICsgaSsrKSB7XG4gICAgaWYgKHNhbWUoZGF0YVtrZXldLmtleSwgaykpXG4gICAgICByZXR1cm4gZGF0YVtrZXldXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0IChkYXRhLCBrLCB2KSB7XG4gIGZvciAodmFyIGkgPSAwLCBzID0gJ18nICsgaywga2V5ID0gcztcbiAgICAgICBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG4gICAgICAga2V5ID0gcyArIGkrKykge1xuICAgIGlmIChzYW1lKGRhdGFba2V5XS5rZXksIGspKSB7XG4gICAgICBkYXRhW2tleV0udmFsdWUgPSB2XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgZGF0YS5zaXplKytcbiAgZGF0YVtrZXldID0gbmV3IEVudHJ5KGssIHYsIGtleSlcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTEuMFxuICogcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMTEuMCc7XG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzIHdpdGhcbi8vIHRlbXBsYXRlIGxpdGVyYWwgc3RyaW5ncy4gVGhlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuLy8gZHVyaW5nIGJ1aWxkLlxuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xudmFyIHdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nV2l0aG91dFN0YWNrKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICAgIC8vIENoZWNrIGJlZm9yZSB0aGUgY29uZGl0aW9uIHRvIGNhdGNoIHZpb2xhdGlvbnMgZWFybHkuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhcm5pbmdXaXRob3V0U3RhY2soKSBjdXJyZW50bHkgc3VwcG9ydHMgYXQgbW9zdCA4IGFyZ3VtZW50cy4nKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICAgIH0pO1xuICAgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG5cbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUuZXJyb3IsIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG52YXIgd2FybmluZ1dpdGhvdXRTdGFjayQxID0gd2FybmluZ1dpdGhvdXRTdGFjaztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxuXG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcblxudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDsgLy8gUHJldmVudCBuZXdlciByZW5kZXJlcnMgZnJvbSBSVEUgd2hlbiB1c2VkIHdpdGggb2xkZXIgcmVhY3QgcGFja2FnZSB2ZXJzaW9ucy5cbi8vIEN1cnJlbnQgb3duZXIgYW5kIGRpc3BhdGNoZXIgdXNlZCB0byBzaGFyZSB0aGUgc2FtZSByZWYsXG4vLyBidXQgUFIgIzE0NTQ4IHNwbGl0IHRoZW0gb3V0IHRvIGJldHRlciBzdXBwb3J0IHRoZSByZWFjdC1kZWJ1Zy10b29scyBwYWNrYWdlLlxuXG5pZiAoIVJlYWN0U2hhcmVkSW50ZXJuYWxzLmhhc093blByb3BlcnR5KCdSZWFjdEN1cnJlbnREaXNwYXRjaGVyJykpIHtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG59XG5cbmlmICghUmVhY3RTaGFyZWRJbnRlcm5hbHMuaGFzT3duUHJvcGVydHkoJ1JlYWN0Q3VycmVudEJhdGNoQ29uZmlnJykpIHtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gICAgc3VzcGVuc2U6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSB3YXJuaW5nV2l0aG91dFN0YWNrJDE7XG5cbntcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC93YXJuaW5nLWFuZC1pbnZhcmlhbnQtYXJnc1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxLmFwcGx5KHZvaWQgMCwgW2ZhbHNlLCBmb3JtYXQgKyAnJXMnXS5jb25jYXQoYXJncywgW3N0YWNrXSkpO1xuICB9O1xufVxuXG52YXIgd2FybmluZyQxID0gd2FybmluZztcblxudmFyIFVuaW5pdGlhbGl6ZWQgPSAtMTtcbnZhciBQZW5kaW5nID0gMDtcbnZhciBSZXNvbHZlZCA9IDE7XG52YXIgUmVqZWN0ZWQgPSAyO1xuZnVuY3Rpb24gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KGxhenlDb21wb25lbnQpIHtcbiAgcmV0dXJuIGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQgPyBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgOiBudWxsO1xufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZUxhenlDb21wb25lbnRUeXBlKGxhenlDb21wb25lbnQpIHtcbiAgaWYgKGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIGxhenlDb21wb25lbnQuX3N0YXR1cyA9IFBlbmRpbmc7XG4gICAgdmFyIGN0b3IgPSBsYXp5Q29tcG9uZW50Ll9jdG9yO1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTtcbiAgICBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyBcImNvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXBvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgbGF6eUNvbXBvbmVudC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmIChsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgbGF6eUNvbXBvbmVudC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIGxhenlDb21wb25lbnQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgcmV0dXJuICdDb250ZXh0LlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0aGVuYWJsZSA9IHR5cGU7XG4gICAgICAgICAgdmFyIHJlc29sdmVkVGhlbmFibGUgPSByZWZpbmVSZXNvbHZlZExhenlDb21wb25lbnQodGhlbmFibGUpO1xuXG4gICAgICAgICAgaWYgKHJlc29sdmVkVGhlbmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHJlc29sdmVkVGhlbmFibGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHZvaWQgMCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2skMSA9IGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjaztcblxudmFyIEJFRk9SRV9TTEFTSF9SRSA9IC9eKC4qKVtcXFxcXFwvXS87XG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICB2YXIgc291cmNlSW5mbyA9ICcnO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgcGF0aCA9IHNvdXJjZS5maWxlTmFtZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBwYXRoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG5cbiAgICB7XG4gICAgICAvLyBJbiBERVYsIGluY2x1ZGUgY29kZSBmb3IgYSBjb21tb24gc3BlY2lhbCBjYXNlOlxuICAgICAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgICAgIGlmICgvXmluZGV4XFwuLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIHBhdGhCZWZvcmVTbGFzaCA9IG1hdGNoWzFdO1xuXG4gICAgICAgICAgaWYgKHBhdGhCZWZvcmVTbGFzaCkge1xuICAgICAgICAgICAgdmFyIGZvbGRlck5hbWUgPSBwYXRoQmVmb3JlU2xhc2gucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZm9sZGVyTmFtZSArICcvJyArIGZpbGVOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNvdXJjZUluZm8gPSAnIChhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJztcbiAgfSBlbHNlIGlmIChvd25lck5hbWUpIHtcbiAgICBzb3VyY2VJbmZvID0gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknO1xuICB9XG5cbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyBzb3VyY2VJbmZvO1xufTtcblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG5cbiAvLyBJbiBzb21lIGNhc2VzLCBTdHJpY3RNb2RlIHNob3VsZCBhbHNvIGRvdWJsZS1yZW5kZXIgbGlmZWN5Y2xlcy5cbi8vIFRoaXMgY2FuIGJlIGNvbmZ1c2luZyBmb3IgdGVzdHMgdGhvdWdoLFxuLy8gQW5kIGl0IGNhbiBiZSBiYWQgZm9yIHBlcmZvcm1hbmNlIGluIHByb2R1Y3Rpb24uXG4vLyBUaGlzIGZlYXR1cmUgZmxhZyBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBiZWhhdmlvcjpcblxuIC8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuIC8vIFdhcm4gYWJvdXQgZGVwcmVjYXRlZCwgYXN5bmMtdW5zYWZlIGxpZmVjeWNsZXM7IHJlbGF0ZXMgdG8gUkZDICM2OlxuXG52YXIgd2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMgPSB0cnVlOyAvLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuXG4gLy8gVHJhY2Ugd2hpY2ggaW50ZXJhY3Rpb25zIHRyaWdnZXIgZWFjaCBjb21taXQuXG5cbiAvLyBTU1IgZXhwZXJpbWVudHNcblxudmFyIGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgPSBmYWxzZTtcbiAvLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuIC8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG4gLy8gRGlzYWJsZSBqYXZhc2NyaXB0OiBVUkwgc3RyaW5ncyBpbiBocmVmIGZvciBYU1MgcHJvdGVjdGlvbi5cblxudmFyIGRpc2FibGVKYXZhU2NyaXB0VVJMcyA9IGZhbHNlOyAvLyBSZWFjdCBGaXJlOiBwcmV2ZW50IHRoZSB2YWx1ZSBhbmQgY2hlY2tlZCBhdHRyaWJ1dGVzIGZyb20gc3luY2luZ1xuLy8gd2l0aCB0aGVpciByZWxhdGVkIERPTSBwcm9wZXJ0aWVzXG5cbiAvLyBUaGVzZSBBUElzIHdpbGwgbm8gbG9uZ2VyIGJlIFwidW5zdGFibGVcIiBpbiB0aGUgdXBjb21pbmcgMTYuNyByZWxlYXNlLFxuLy8gQ29udHJvbCB0aGlzIGJlaGF2aW9yIHdpdGggYSBmbGFnIHRvIHN1cHBvcnQgMTYuNiBtaW5vciByZWxlYXNlcyBpbiB0aGUgbWVhbndoaWxlLlxuXG5cbiAvLyBFeHBlcmltZW50YWwgUmVhY3QgRmxhcmUgZXZlbnQgc3lzdGVtIGFuZCBldmVudCBjb21wb25lbnRzIHN1cHBvcnQuXG5cbnZhciBlbmFibGVGbGFyZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgSG9zdCBDb21wb25lbnQgc3VwcG9ydC5cblxudmFyIGVuYWJsZUZ1bmRhbWVudGFsQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gTmV3IEFQSSBmb3IgSlNYIHRyYW5zZm9ybXMgdG8gdGFyZ2V0IC0gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuXG4gLy8gV2Ugd2lsbCBlbmZvcmNlIG1vY2tpbmcgc2NoZWR1bGVyIHdpdGggc2NoZWR1bGVyL3Vuc3RhYmxlX21vY2sgYXQgc29tZSBwb2ludC4gKHYxNz8pXG4vLyBUaWxsIHRoZW4sIHdlIHdhcm4gYWJvdXQgdGhlIG1pc3NpbmcgbW9jaywgYnV0IHN0aWxsIGZhbGxiYWNrIHRvIGEgc3luYyBtb2RlIGNvbXBhdGlibGUgdmVyc2lvblxuXG4gLy8gRm9yIHRlc3RzLCB3ZSBmbHVzaCBzdXNwZW5zZSBmYWxsYmFja3MgaW4gYW4gYWN0IHNjb3BlO1xuLy8gKmV4Y2VwdCogaW4gc29tZSBvZiBvdXIgb3duIHRlc3RzLCB3aGVyZSB3ZSB0ZXN0IGluY3JlbWVudGFsIGxvYWRpbmcgc3RhdGVzLlxuXG4gLy8gQWRkIGEgY2FsbGJhY2sgcHJvcGVydHkgdG8gc3VzcGVuc2UgdG8gbm90aWZ5IHdoaWNoIHByb21pc2VzIGFyZSBjdXJyZW50bHlcbi8vIGluIHRoZSB1cGRhdGUgcXVldWUuIFRoaXMgYWxsb3dzIHJlcG9ydGluZyBhbmQgdHJhY2luZyBvZiB3aGF0IGlzIGNhdXNpbmdcbi8vIHRoZSB1c2VyIHRvIHNlZSBhIGxvYWRpbmcgc3RhdGUuXG4vLyBBbHNvIGFsbG93cyBoeWRyYXRpb24gY2FsbGJhY2tzIHRvIGZpcmUgd2hlbiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgZ2V0c1xuLy8gaHlkcmF0ZWQgb3IgZGVsZXRlZC5cblxuIC8vIFBhcnQgb2YgdGhlIHNpbXBsaWZpY2F0aW9uIG9mIFJlYWN0LmNyZWF0ZUVsZW1lbnQgc28gd2UgY2FuIGV2ZW50dWFsbHkgbW92ZVxuLy8gZnJvbSBSZWFjdC5jcmVhdGVFbGVtZW50IHRvIFJlYWN0LmpzeFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9ibG9iL2NyZWF0ZWxlbWVudC1yZmMvdGV4dC8wMDAwLWNyZWF0ZS1lbGVtZW50LWNoYW5nZXMubWRcblxuXG5cbnZhciBkaXNhYmxlTGVnYWN5Q29udGV4dCA9IGZhbHNlO1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5mdW5jdGlvbiBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KSB7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcblxuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG5cbiAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgbWFza2VkQ29udGV4dFtjb250ZXh0TmFtZV0gPSBjb250ZXh0W2NvbnRleHROYW1lXTtcbiAgfVxuXG4gIHJldHVybiBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAge1xuICAgIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgJ0NvbXBvbmVudCcsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCkge1xuICAvLyBJZiB3ZSBkb24ndCBoYXZlIGVub3VnaCBzbG90cyBpbiB0aGlzIGNvbnRleHQgdG8gc3RvcmUgdGhpcyB0aHJlYWRJRCxcbiAgLy8gZmlsbCBpdCBpbiB3aXRob3V0IGxlYXZpbmcgYW55IGhvbGVzIHRvIGVuc3VyZSB0aGF0IHRoZSBWTSBvcHRpbWl6ZXNcbiAgLy8gdGhpcyBhcyBub24taG9sZXkgaW5kZXggcHJvcGVydGllcy5cbiAgLy8gKE5vdGU6IElmIGByZWFjdGAgcGFja2FnZSBpcyA8IDE2LjYsIF90aHJlYWRDb3VudCBpcyB1bmRlZmluZWQuKVxuICBmb3IgKHZhciBpID0gY29udGV4dC5fdGhyZWFkQ291bnQgfCAwOyBpIDw9IHRocmVhZElEOyBpKyspIHtcbiAgICAvLyBXZSBhc3N1bWUgdGhhdCB0aGlzIGlzIHRoZSBzYW1lIGFzIHRoZSBkZWZhdWx0VmFsdWUgd2hpY2ggbWlnaHQgbm90IGJlXG4gICAgLy8gdHJ1ZSBpZiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIGEgc2Vjb25kYXJ5IHJlbmRlcmVyIGJ1dCB0aGV5IGFyZVxuICAgIC8vIHNlY29uZGFyeSBiZWNhdXNlIHRoZXNlIHVzZSBjYXNlcyBhcmUgdmVyeSByYXJlLlxuICAgIGNvbnRleHRbaV0gPSBjb250ZXh0Ll9jdXJyZW50VmFsdWUyO1xuICAgIGNvbnRleHQuX3RocmVhZENvdW50ID0gaSArIDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NDb250ZXh0KHR5cGUsIGNvbnRleHQsIHRocmVhZElELCBpc0NsYXNzKSB7XG4gIGlmIChpc0NsYXNzKSB7XG4gICAgdmFyIGNvbnRleHRUeXBlID0gdHlwZS5jb250ZXh0VHlwZTtcblxuICAgIHtcbiAgICAgIGlmICgnY29udGV4dFR5cGUnIGluIHR5cGUpIHtcbiAgICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZCh0eXBlKTtcbiAgICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dFR5cGUsIHRocmVhZElEKTtcbiAgICAgIHJldHVybiBjb250ZXh0VHlwZVt0aHJlYWRJRF07XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVMZWdhY3lDb250ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlLmNvbnRleHRUeXBlcykge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIHVzZXMgdGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgQVBJIHdoaWNoIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgKyAnVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tDb250ZXh0VHlwZXModHlwZS5jb250ZXh0VHlwZXMsIG1hc2tlZENvbnRleHQsICdjb250ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkaXNhYmxlTGVnYWN5Q29udGV4dCkge1xuICAgICAge1xuICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAnICsgJ1VzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgd2l0aCBSZWFjdC51c2VDb250ZXh0KCkgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdVbmtub3duJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9tYXNrZWRDb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tDb250ZXh0VHlwZXModHlwZS5jb250ZXh0VHlwZXMsIF9tYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWFza2VkQ29udGV4dDtcbiAgICB9XG4gIH1cbn1cblxuLy8gQWxsb2NhdGVzIGEgbmV3IGluZGV4IGZvciBlYWNoIHJlcXVlc3QuIFRyaWVzIHRvIHN0YXkgYXMgY29tcGFjdCBhcyBwb3NzaWJsZSBzbyB0aGF0IHRoZXNlXG4vLyBpbmRpY2VzIGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSBhIHRpZ2h0bHkgcGFja2VkIGFycmF5LiBBcyBvcHBvc2VkIHRvIGJlaW5nIHVzZWQgaW4gYSBNYXAuXG4vLyBUaGUgZmlyc3QgYWxsb2NhdGVkIGluZGV4IGlzIDEuXG52YXIgbmV4dEF2YWlsYWJsZVRocmVhZElEcyA9IG5ldyBVaW50MTZBcnJheSgxNik7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW2ldID0gaSArIDE7XG59XG5cbm5leHRBdmFpbGFibGVUaHJlYWRJRHNbMTVdID0gMDtcblxuZnVuY3Rpb24gZ3Jvd1RocmVhZENvdW50QW5kUmV0dXJuTmV4dEF2YWlsYWJsZSgpIHtcbiAgdmFyIG9sZEFycmF5ID0gbmV4dEF2YWlsYWJsZVRocmVhZElEcztcbiAgdmFyIG9sZFNpemUgPSBvbGRBcnJheS5sZW5ndGg7XG4gIHZhciBuZXdTaXplID0gb2xkU2l6ZSAqIDI7XG5cbiAgaWYgKCEobmV3U2l6ZSA8PSAweDEwMDAwKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKFwiTWF4aW11bSBudW1iZXIgb2YgY29uY3VycmVudCBSZWFjdCByZW5kZXJlcnMgZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgYXJlIG5vdCBwcm9wZXJseSBkZXN0cm95aW5nIHRoZSBSZWFkYWJsZSBwcm92aWRlZCBieSBSZWFjdC4gRW5zdXJlIHRoYXQgeW91IGNhbGwgLmRlc3Ryb3koKSBvbiBpdCBpZiB5b3Ugbm8gbG9uZ2VyIHdhbnQgdG8gcmVhZCBmcm9tIGl0LCBhbmQgZGlkIG5vdCByZWFkIHRvIHRoZSBlbmQuIElmIHlvdSB1c2UgLnBpcGUoKSB0aGlzIHNob3VsZCBiZSBhdXRvbWF0aWMuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdBcnJheSA9IG5ldyBVaW50MTZBcnJheShuZXdTaXplKTtcbiAgbmV3QXJyYXkuc2V0KG9sZEFycmF5KTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEcyA9IG5ld0FycmF5O1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gb2xkU2l6ZSArIDE7XG5cbiAgZm9yICh2YXIgX2kgPSBvbGRTaXplOyBfaSA8IG5ld1NpemUgLSAxOyBfaSsrKSB7XG4gICAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tfaV0gPSBfaSArIDE7XG4gIH1cblxuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW25ld1NpemUgLSAxXSA9IDA7XG4gIHJldHVybiBvbGRTaXplO1xufVxuXG5mdW5jdGlvbiBhbGxvY1RocmVhZElEKCkge1xuICB2YXIgbmV4dElEID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXTtcblxuICBpZiAobmV4dElEID09PSAwKSB7XG4gICAgcmV0dXJuIGdyb3dUaHJlYWRDb3VudEFuZFJldHVybk5leHRBdmFpbGFibGUoKTtcbiAgfVxuXG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW25leHRJRF07XG4gIHJldHVybiBuZXh0SUQ7XG59XG5mdW5jdGlvbiBmcmVlVGhyZWFkSUQoaWQpIHtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tpZF0gPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdO1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gaWQ7XG59XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDsgLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIHdoaXRlbGlzdCBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG5cbnZhciBTVFJJTkcgPSAxOyAvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cblxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjsgLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG5cbnZhciBCT09MRUFOID0gMzsgLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBOVU1FUklDID0gNTsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG52YXIgUk9PVF9BVFRSSUJVVEVfTkFNRSA9ICdkYXRhLXJlYWN0cm9vdCc7XG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuXG4gIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAocHJvcGVydHlJbmZvLnR5cGUpIHtcbiAgICAgIGNhc2UgQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuICF2YWx1ZTtcblxuICAgICAgY2FzZSBPVkVSTE9BREVEX0JPT0xFQU46XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gZmFsc2U7XG5cbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKTtcblxuICAgICAgY2FzZSBQT1NJVElWRV9OVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpIHx8IHZhbHVlIDwgMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSkge1xuICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgdHlwZSwgbXVzdFVzZVByb3BlcnR5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVOYW1lc3BhY2UsIHNhbml0aXplVVJMKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG59IC8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbi8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4vLyBuYW1lIHdhcm5pbmdzLlxuXG5cbnZhciBwcm9wZXJ0aWVzID0ge307IC8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuXG5bJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBSRVNFUlZFRCwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblxuWydhdXRvUmV2ZXJzZScsICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJywgJ2ZvY3VzYWJsZScsICdwcmVzZXJ2ZUFscGhhJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuXG5bJ2NoZWNrZWQnLCAvLyBOb3RlOiBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC4gV2UgaGF2ZSBzcGVjaWFsIGxvZ2ljIGZvciBoYW5kbGluZyB0aGlzLlxuJ211bHRpcGxlJywgJ211dGVkJywgJ3NlbGVjdGVkJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCB0cnVlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBudW1iZXJzLlxuXG5bJ3Jvd1NwYW4nLCAnc3RhcnQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE5VTUVSSUMsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCB3aGl0ZWxpc3QuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcHBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bWwgbmFtZXNwYWNlLlxuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cblxudmFyIHhsaW5rSHJlZiA9ICd4bGlua0hyZWYnO1xucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlKTtcbn0pO1xuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyID0gbnVsbDtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufSAvLyBBIGphdmFzY3JpcHQ6IFVSTCBjYW4gY29udGFpbiBsZWFkaW5nIEMwIGNvbnRyb2wgb3IgXFx1MDAyMCBTUEFDRSxcbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblxudmFyIGlzSmF2YVNjcmlwdFByb3RvY29sID0gL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKlxcOi9pO1xudmFyIGRpZFdhcm4gPSBmYWxzZTtcblxuZnVuY3Rpb24gc2FuaXRpemVVUkwodXJsKSB7XG4gIGlmIChkaXNhYmxlSmF2YVNjcmlwdFVSTHMpIHtcbiAgICBpZiAoISFpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdCBoYXMgYmxvY2tlZCBhIGphdmFzY3JpcHQ6IFVSTCBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uXCIgKyAoUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyLmdldFN0YWNrQWRkZW5kdW0oKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0cnVlICYmICFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgIGRpZFdhcm4gPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0EgZnV0dXJlIHZlcnNpb24gb2YgUmVhY3Qgd2lsbCBibG9jayBqYXZhc2NyaXB0OiBVUkxzIGFzIGEgc2VjdXJpdHkgcHJlY2F1dGlvbi4gJyArICdVc2UgZXZlbnQgaGFuZGxlcnMgaW5zdGVhZCBpZiB5b3UgY2FuLiBJZiB5b3UgbmVlZCB0byBnZW5lcmF0ZSB1bnNhZmUgSFRNTCB0cnkgJyArICd1c2luZyBkYW5nZXJvdXNseVNldElubmVySFRNTCBpbnN0ZWFkLiBSZWFjdCB3YXMgcGFzc2VkICVzLicsIEpTT04uc3RyaW5naWZ5KHVybCkpO1xuICB9XG59XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuLyoqXG4gKiBFc2NhcGVzIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgSFRNTCBlbnRpdGllcyBpbiBhIGdpdmVuIGh0bWwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIEhUTUwgc3RyaW5nIHRvIGVzY2FwZSBmb3IgbGF0ZXIgaW5zZXJ0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4O1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIC8vICZcbiAgICAgICAgZXNjYXBlID0gJyZhbXA7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgNjA6XG4gICAgICAgIC8vIDxcbiAgICAgICAgZXNjYXBlID0gJyZsdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufSAvLyBlbmQgY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICBpZiAodHlwZW9mIHRleHQgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgdGV4dCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyB0aGlzIHNob3J0Y2lyY3VpdCBoZWxwcyBwZXJmIGZvciB0eXBlcyB0aGF0IHdlIGtub3cgd2lsbCBuZXZlciBoYXZlXG4gICAgLy8gc3BlY2lhbCBjaGFyYWN0ZXJzLCBlc3BlY2lhbGx5IGdpdmVuIHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIG9mdGVuXG4gICAgLy8gZm9yIG51bWVyaWMgZG9tIGlkcy5cbiAgICByZXR1cm4gJycgKyB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIGVzY2FwZUh0bWwodGV4dCk7XG59XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclJvb3QoKSB7XG4gIHJldHVybiBST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbn1cbi8qKlxuICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIGlzJDEgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xudmFyIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2sgaXMgYSByZS1yZW5kZXJlZCBob29rXG5cbnZhciBpc1JlUmVuZGVyID0gZmFsc2U7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgZHVyaW5nIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHJlbmRlciBwYXNzLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBMYXppbHkgY3JlYXRlZCBtYXAgb2YgcmVuZGVyLXBoYXNlIHVwZGF0ZXNcblxudmFyIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7IC8vIENvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cblxudmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTtcbnZhciBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldjtcblxuZnVuY3Rpb24gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpIHtcbiAgaWYgKCEoY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgISFpc0luSG9va1VzZXJDb2RlSW5EZXYgPyB3YXJuaW5nJDEoZmFsc2UsICdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL2ZiLm1lL3J1bGVzLW9mLWhvb2tzJykgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpcyQxKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb29rKCkge1xuICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPiAwKSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgaWYgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7XG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcblxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBjb21wb25lbnRJZGVudGl0eTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxufVxuZnVuY3Rpb24gZmluaXNoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgY2hpbGRyZW4sIHJlZk9yQ29udGV4dCkge1xuICAvLyBUaGlzIG11c3QgYmUgY2FsbGVkIGFmdGVyIGV2ZXJ5IGZ1bmN0aW9uIGNvbXBvbmVudCB0byBwcmV2ZW50IGhvb2tzIGZyb21cbiAgLy8gYmVpbmcgdXNlZCBpbiBjbGFzc2VzLlxuICB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIC8vIFVwZGF0ZXMgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoZXkgYXJlIHN0b3JlZCBpblxuICAgIC8vIHRoZSBgcmVuZGVyUGhhc2VVcGRhdGVzYCBtYXAuIENhbGwgdGhlIGNvbXBvbmVudCBhZ2FpbiwgcmV1c2luZyB0aGVcbiAgICAvLyB3b3JrLWluLXByb2dyZXNzIGhvb2tzIGFuZCBhcHBseWluZyB0aGUgYWRkaXRpb25hbCB1cGRhdGVzIG9uIHRvcC4gS2VlcFxuICAgIC8vIHJlc3RhcnRpbmcgdW50aWwgbm8gbW9yZSB1cGRhdGVzIGFyZSBzY2hlZHVsZWQuXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICB9IC8vIFRoZXNlIHdlcmUgcmVzZXQgYWJvdmVcbiAgLy8gY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHZhciB0aHJlYWRJRCA9IGN1cnJlbnRUaHJlYWRJRDtcbiAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcblxuICB7XG4gICAgISFpc0luSG9va1VzZXJDb2RlSW5EZXYgPyB3YXJuaW5nJDEoZmFsc2UsICdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0W3RocmVhZElEXTtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICB9XG5cbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB2YXIgdGhyZWFkSUQgPSBjdXJyZW50VGhyZWFkSUQ7XG4gIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhjb250ZXh0LCB0aHJlYWRJRCk7XG4gIHJldHVybiBjb250ZXh0W3RocmVhZElEXTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICB9XG5cbiAgcmV0dXJuIHVzZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIsIC8vIHVzZVJlZHVjZXIgaGFzIGEgc3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgbGF6eSB1c2VTdGF0ZSBpbml0aWFsaXplcnNcbiAgaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB7XG4gICAgaWYgKHJlZHVjZXIgIT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChpc1JlUmVuZGVyKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgICAvLyBjdXJyZW50IGhvb2suXG4gICAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3NIb29rLnF1ZXVlO1xuICAgIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuXG4gICAgaWYgKHJlbmRlclBoYXNlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgICAgLy8gUmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXJlIHN0b3JlZCBpbiBhIG1hcCBvZiBxdWV1ZSAtPiBsaW5rZWQgbGlzdFxuICAgICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gICAgaWYgKHJlZHVjZXIgPT09IGJhc2ljU3RhdGVSZWR1Y2VyKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGB1c2VTdGF0ZWAuXG4gICAgICBpbml0aWFsU3RhdGUgPSB0eXBlb2YgaW5pdGlhbEFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGluaXRpYWxBcmcoKSA6IGluaXRpYWxBcmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGluaXQgIT09IHVuZGVmaW5lZCA/IGluaXQoaW5pdGlhbEFyZykgOiBpbml0aWFsQXJnO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgdmFyIF9xdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZSA9IHtcbiAgICAgIGxhc3Q6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgX2Rpc3BhdGNoID0gX3F1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQsIF9xdWV1ZSk7XG5cbiAgICByZXR1cm4gW3dvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlLCBfZGlzcGF0Y2hdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gIH1cblxuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCA9IHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBwcmV2aW91c1JlZiA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2aW91c1JlZiA9PT0gbnVsbCkge1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgICB9O1xuXG4gICAge1xuICAgICAgT2JqZWN0LnNlYWwocmVmKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgICByZXR1cm4gcmVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2aW91c1JlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gIH1cblxuICB3YXJuaW5nJDEoZmFsc2UsICd1c2VMYXlvdXRFZmZlY3QgZG9lcyBub3RoaW5nIG9uIHRoZSBzZXJ2ZXIsIGJlY2F1c2UgaXRzIGVmZmVjdCBjYW5ub3QgJyArIFwiYmUgZW5jb2RlZCBpbnRvIHRoZSBzZXJ2ZXIgcmVuZGVyZXIncyBvdXRwdXQgZm9ybWF0LiBUaGlzIHdpbGwgbGVhZCBcIiArICd0byBhIG1pc21hdGNoIGJldHdlZW4gdGhlIGluaXRpYWwsIG5vbi1oeWRyYXRlZCBVSSBhbmQgdGhlIGludGVuZGVkICcgKyAnVUkuIFRvIGF2b2lkIHRoaXMsIHVzZUxheW91dEVmZmVjdCBzaG91bGQgb25seSBiZSB1c2VkIGluICcgKyAnY29tcG9uZW50cyB0aGF0IHJlbmRlciBleGNsdXNpdmVseSBvbiB0aGUgY2xpZW50LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXVzZWxheW91dGVmZmVjdC1zc3IgZm9yIGNvbW1vbiBmaXhlcy4nKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKCEobnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudElkZW50aXR5ID09PSBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSByZW5kZXJQaGFzZVVwZGF0ZXMuZ2V0KHF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcy5zZXQocXVldWUsIHVwZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuXG4gICAgICBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7Ly8gVGhpcyBtZWFucyBhbiB1cGRhdGUgaGFzIGhhcHBlbmVkIGFmdGVyIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgaGFzXG4gICAgLy8gcmV0dXJuZWQuIE9uIHRoZSBzZXJ2ZXIgdGhpcyBpcyBhIG5vLW9wLiBJbiBSZWFjdCBGaWJlciwgdGhlIHVwZGF0ZVxuICAgIC8vIHdvdWxkIGJlIHNjaGVkdWxlZCBmb3IgYSBmdXR1cmUgcmVuZGVyLlxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIC8vIENhbGxiYWNrcyBhcmUgcGFzc2VkIGFzIHRoZXkgYXJlIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gdXNlUmVzcG9uZGVyKHJlc3BvbmRlciwgcHJvcHMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9wczogcHJvcHMsXG4gICAgcmVzcG9uZGVyOiByZXNwb25kZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgY29uZmlnKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKGNvbmZpZykge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG5cbiAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG5cbiAgcmV0dXJuIFtzdGFydFRyYW5zaXRpb24sIGZhbHNlXTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBjdXJyZW50VGhyZWFkSUQgPSAwO1xuZnVuY3Rpb24gc2V0Q3VycmVudFRocmVhZElEKHRocmVhZElEKSB7XG4gIGN1cnJlbnRUaHJlYWRJRCA9IHRocmVhZElEO1xufVxudmFyIERpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgdXNlTGF5b3V0RWZmZWN0OiB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayxcbiAgLy8gdXNlSW1wZXJhdGl2ZUhhbmRsZSBpcyBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnRcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbm9vcCxcbiAgLy8gRWZmZWN0cyBhcmUgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VFZmZlY3Q6IG5vb3AsXG4gIC8vIERlYnVnZ2luZyBlZmZlY3RcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCxcbiAgdXNlUmVzcG9uZGVyOiB1c2VSZXNwb25kZXIsXG4gIHVzZURlZmVycmVkVmFsdWU6IHVzZURlZmVycmVkVmFsdWUsXG4gIHVzZVRyYW5zaXRpb246IHVzZVRyYW5zaXRpb25cbn07XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59OyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQzID0gbnVsbDtcbnZhciBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IG51bGxcbn07XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQzID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgdmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGNoZWNrYm94OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGhpZGRlbjogdHJ1ZSxcbiAgICByYWRpbzogdHJ1ZSxcbiAgICByZXNldDogdHJ1ZSxcbiAgICBzdWJtaXQ6IHRydWVcbiAgfTtcbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHNbcHJvcE5hbWVdID09IG51bGwgfHwgZW5hYmxlRmxhcmVBUEkgJiYgcHJvcHMubGlzdGVuZXJzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH0sXG4gICAgY2hlY2tlZDogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzW3Byb3BOYW1lXSA9PSBudWxsIHx8IGVuYWJsZUZsYXJlQVBJICYmIHByb3BzLmxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuXG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBwcm9wcywgJ3Byb3AnLCB0YWdOYW1lLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDMuZ2V0U3RhY2tBZGRlbmR1bSk7XG4gIH07XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cblxufTtcblxuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gb3IgYWRkIHN0YWNrIGJ5IGRlZmF1bHQgdG8gaW52YXJpYW50cyB3aGVyZSBwb3NzaWJsZS5cblxudmFyIEhUTUwgPSAnX19odG1sJztcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDQgPSBudWxsO1xuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkNCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG5cblxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICBpZiAoIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKHRhZyArIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKyAoUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQ0LmdldFN0YWNrQWRkZW5kdW0oKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgICEocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyB3YXJuaW5nJDEoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB2b2lkIDA7XG4gIH1cblxuICBpZiAoIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCIgKyAoUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQ0LmdldFN0YWNrQWRkZW5kdW0oKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkkMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkkMi5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgY29ycmVjdE5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xuXG5cblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xuXG5cbi8qKlxuICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAqL1xuXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcbi8qKlxuICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAqL1xuXG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0ge307IC8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cblxuXG4vKipcbiAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAqXG4gKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAqL1xuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cblxuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG5cblxuICAgIGlmIChpc1Jlc2VydmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG5cblxuICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG5cblxuICAgIGlmICgodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJykgJiYgcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGNhblVzZUV2ZW50U3lzdGVtKTtcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3InLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3InLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSkge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG59XG5cbnZhciB0b0FycmF5ID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheTsgLy8gVGhpcyBpcyBvbmx5IHVzZWQgaW4gREVWLlxuLy8gRWFjaCBlbnRyeSBpcyBgdGhpcy5zdGFja2AgZnJvbSBhIGN1cnJlbnRseSBleGVjdXRpbmcgcmVuZGVyZXIgaW5zdGFuY2UuXG4vLyAoVGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgYmVjYXVzZSBSZWFjdERPTVNlcnZlciBpcyByZWVudHJhbnQpLlxuLy8gRWFjaCBzdGFjayBpcyBhbiBhcnJheSBvZiBmcmFtZXMgd2hpY2ggbWF5IGNvbnRhaW4gbmVzdGVkIHN0YWNrcyBvZiBlbGVtZW50cy5cblxudmFyIGN1cnJlbnREZWJ1Z1N0YWNrcyA9IFtdO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgcHJldkdldEN1cnJlbnRTdGFja0ltcGwgPSBudWxsO1xuXG52YXIgZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIGRlc2NyaWJlU3RhY2tGcmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiAnJztcbn07XG5cbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7fTtcblxudmFyIHB1c2hDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge307XG5cbnZhciBwdXNoRWxlbWVudFRvRGVidWdTdGFjayA9IGZ1bmN0aW9uIChlbGVtZW50KSB7fTtcblxudmFyIHBvcEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxue1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsXG4gICAgLyogY2FuVXNlRXZlbnRTeXN0ZW0gKi9cbiAgICBmYWxzZSk7XG4gIH07XG5cbiAgZGVzY3JpYmVTdGFja0ZyYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICB2YXIgb3duZXJOYW1lID0gbnVsbDtcbiAgICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSk7XG4gIH07XG5cbiAgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAgY3VycmVudERlYnVnU3RhY2tzLnB1c2goc3RhY2spO1xuXG4gICAgaWYgKGN1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIFdlIGFyZSBlbnRlcmluZyBhIHNlcnZlciByZW5kZXJlci5cbiAgICAgIC8vIFJlbWVtYmVyIHRoZSBwcmV2aW91cyAoZS5nLiBjbGllbnQpIGdsb2JhbCBzdGFjayBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGw7XG4gICAgfVxuICB9O1xuXG4gIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBGb3IgdGhlIGlubmVybW9zdCBleGVjdXRpbmcgUmVhY3RET01TZXJ2ZXIgY2FsbCxcbiAgICB2YXIgc3RhY2sgPSBjdXJyZW50RGVidWdTdGFja3NbY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCAtIDFdOyAvLyBUYWtlIHRoZSBpbm5lcm1vc3QgZXhlY3V0aW5nIGZyYW1lIChlLmcuIDxGb28+KSxcblxuICAgIHZhciBmcmFtZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdOyAvLyBhbmQgcmVjb3JkIHRoYXQgaXQgaGFzIG9uZSBtb3JlIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG4gICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTsgLy8gV2Ugb25seSBuZWVkIHRoaXMgYmVjYXVzZSB3ZSB0YWlsLW9wdGltaXplIHNpbmdsZS1lbGVtZW50XG4gICAgLy8gY2hpbGRyZW4gYW5kIGRpcmVjdGx5IGhhbmRsZSB0aGVtIGluIGFuIGlubmVyIGxvb3AgaW5zdGVhZCBvZlxuICAgIC8vIGNyZWF0aW5nIHNlcGFyYXRlIGZyYW1lcyBmb3IgdGhlbS5cbiAgfTtcblxuICBwb3BDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBjdXJyZW50RGVidWdTdGFja3MucG9wKCk7XG5cbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gV2UgYXJlIGV4aXRpbmcgdGhlIHNlcnZlciByZW5kZXJlci5cbiAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIChlLmcuIGNsaWVudCkgZ2xvYmFsIHN0YWNrIGltcGxlbWVudGF0aW9uLlxuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbDtcbiAgICAgIHByZXZHZXRDdXJyZW50U3RhY2tJbXBsID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gUmVhY3RET01TZXJ2ZXIgaXMgcmVlbnRyYW50IHNvIHRoZXJlIG1heSBiZSBtdWx0aXBsZSBjYWxscyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIFRha2UgdGhlIGZyYW1lcyBmcm9tIHRoZSBpbm5lcm1vc3QgY2FsbCB3aGljaCBpcyB0aGUgbGFzdCBpbiB0aGUgYXJyYXkuXG5cblxuICAgIHZhciBmcmFtZXMgPSBjdXJyZW50RGVidWdTdGFja3NbY3VycmVudERlYnVnU3RhY2tzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBHbyB0aHJvdWdoIGV2ZXJ5IGZyYW1lIGluIHRoZSBzdGFjayBmcm9tIHRoZSBpbm5lcm1vc3Qgb25lLlxuXG4gICAgZm9yICh2YXIgaSA9IGZyYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZyYW1lID0gZnJhbWVzW2ldOyAvLyBFdmVyeSBmcmFtZSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgZGVidWcgZWxlbWVudCBzdGFjayBlbnRyeSBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugc2luZ2xlLWNoaWxkIG5lc3RpbmcgZG9lc24ndCBjcmVhdGUgbWF0ZXJpYWxpemVkIGZyYW1lcy5cbiAgICAgIC8vIEluc3RlYWQgaXQgd291bGQgcHVzaCB0aGVtIHRocm91Z2ggYHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrKClgLlxuXG4gICAgICB2YXIgZGVidWdFbGVtZW50U3RhY2sgPSBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjaztcblxuICAgICAgZm9yICh2YXIgaWkgPSBkZWJ1Z0VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIHN0YWNrICs9IGRlc2NyaWJlU3RhY2tGcmFtZShkZWJ1Z0VsZW1lbnRTdGFja1tpaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxudmFyIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0Tm9vcFVwZGF0ZUZvckNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudCA9IHt9O1xudmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSB7fTtcbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gIGxpc3Rpbmc6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWVcbn07IC8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG5cbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCF2YWxpZGF0ZWRUYWdDYWNoZS5oYXNPd25Qcm9wZXJ0eSh0YWcpKSB7XG4gICAgaWYgKCFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCB0YWc6IFwiICsgdGFnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgc3R5bGVOYW1lQ2FjaGUgPSB7fTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIGlmIChzdHlsZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgcmV0dXJuIHN0eWxlTmFtZUNhY2hlW3N0eWxlTmFtZV07XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG4gIHN0eWxlTmFtZUNhY2hlW3N0eWxlTmFtZV0gPSByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciBzZXJpYWxpemVkID0gJyc7XG4gIHZhciBkZWxpbWl0ZXIgPSAnJztcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIChpc0N1c3RvbVByb3BlcnR5ID8gc3R5bGVOYW1lIDogcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpKSArICc6JztcbiAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgZ2V0Q29tcG9uZW50TmFtZShfY29uc3RydWN0b3IpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvdXRzaWRlIGNvbXBvbmVudFdpbGxNb3VudCgpIG9uIHRoZSBzZXJ2ZXIuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiBDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9uQ2hpbGRyZW5Jbm5lck1hcmt1cChwcm9wcykge1xuICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cbiAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlubmVySFRNTC5fX2h0bWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZW50ID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuVG9wTGV2ZWxDaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGNoaWxkcmVuKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY2hpbGRyZW47XG5cbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHJldHVybiBbZWxlbWVudF07XG4gIH1cblxuICB2YXIgZnJhZ21lbnRDaGlsZHJlbiA9IGVsZW1lbnQucHJvcHMuY2hpbGRyZW47XG5cbiAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChmcmFnbWVudENoaWxkcmVuKSkge1xuICAgIHJldHVybiB0b0FycmF5KGZyYWdtZW50Q2hpbGRyZW4pO1xuICB9XG5cbiAgdmFyIGZyYWdtZW50Q2hpbGRFbGVtZW50ID0gZnJhZ21lbnRDaGlsZHJlbjtcbiAgcmV0dXJuIFtmcmFnbWVudENoaWxkRWxlbWVudF07XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5PcHRpb25DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiAmJiB0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBjaGlsZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGwsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogbnVsbFxufTtcblxuZnVuY3Rpb24gY3JlYXRlT3BlblRhZ01hcmt1cCh0YWdWZXJiYXRpbSwgdGFnTG93ZXJjYXNlLCBwcm9wcywgbmFtZXNwYWNlLCBtYWtlU3RhdGljTWFya3VwLCBpc1Jvb3RFbGVtZW50KSB7XG4gIHZhciByZXQgPSAnPCcgKyB0YWdWZXJiYXRpbTtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGVuYWJsZUZsYXJlQVBJICYmIHByb3BLZXkgPT09ICdsaXN0ZW5lcnMnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgcHJvcFZhbHVlID0gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cCA9IG51bGw7XG5cbiAgICBpZiAoaXNDdXN0b21Db21wb25lbnQodGFnTG93ZXJjYXNlLCBwcm9wcykpIHtcbiAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgbWFya3VwID0gY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmt1cCkge1xuICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICB9XG4gIH0gLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gIC8vIGJ5dGVzLlxuXG5cbiAgaWYgKG1ha2VTdGF0aWNNYXJrdXApIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGlzUm9vdEVsZW1lbnQpIHtcbiAgICByZXQgKz0gJyAnICsgY3JlYXRlTWFya3VwRm9yUm9vdCgpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIHR5cGUpIHtcbiAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKChnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnKSArIFwiKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKGNoaWxkLCBjb250ZXh0LCB0aHJlYWRJRCkge1xuICB3aGlsZSAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgLy8gU2FmZSBiZWNhdXNlIHdlIGp1c3QgY2hlY2tlZCBpdCdzIGFuIGVsZW1lbnQuXG4gICAgdmFyIGVsZW1lbnQgPSBjaGlsZDtcbiAgICB2YXIgQ29tcG9uZW50ID0gZWxlbWVudC50eXBlO1xuXG4gICAge1xuICAgICAgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2soZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByb2Nlc3NDaGlsZChlbGVtZW50LCBDb21wb25lbnQpO1xuICB9IC8vIEV4dHJhIGNsb3N1cmUgc28gcXVldWUgYW5kIHJlcGxhY2UgY2FuIGJlIGNhcHR1cmVkIHByb3Blcmx5XG5cblxuICBmdW5jdGlvbiBwcm9jZXNzQ2hpbGQoZWxlbWVudCwgQ29tcG9uZW50KSB7XG4gICAgdmFyIGlzQ2xhc3MgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcbiAgICB2YXIgcHVibGljQ29udGV4dCA9IHByb2Nlc3NDb250ZXh0KENvbXBvbmVudCwgY29udGV4dCwgdGhyZWFkSUQsIGlzQ2xhc3MpO1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciByZXBsYWNlID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZXIgPSB7XG4gICAgICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgICAgIHJlcGxhY2UgPSB0cnVlO1xuICAgICAgICBxdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICAgIH0sXG4gICAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY3VycmVudFBhcnRpYWxTdGF0ZSkge1xuICAgICAgICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZS5wdXNoKGN1cnJlbnRQYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGluc3Q7XG5cbiAgICBpZiAoaXNDbGFzcykge1xuICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQoZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlcik7XG5cbiAgICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGluc3Quc3RhdGUgPT09IG51bGwgfHwgaW5zdC5zdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0LnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJ0aWFsU3RhdGUgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLmNhbGwobnVsbCwgZWxlbWVudC5wcm9wcywgaW5zdC5zdGF0ZSk7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGVbX2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgX2NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGVbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICBpbnN0LnN0YXRlID0gX2Fzc2lnbih7fSwgaW5zdC5zdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tfY29tcG9uZW50TmFtZTJdKSB7XG4gICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyKTtcbiAgICAgICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW19jb21wb25lbnROYW1lMl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgICAgIHByZXBhcmVUb1VzZUhvb2tzKGNvbXBvbmVudElkZW50aXR5KTtcbiAgICAgIGluc3QgPSBDb21wb25lbnQoZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlcik7XG4gICAgICBpbnN0ID0gZmluaXNoSG9va3MoQ29tcG9uZW50LCBlbGVtZW50LnByb3BzLCBpbnN0LCBwdWJsaWNDb250ZXh0KTtcblxuICAgICAgaWYgKGluc3QgPT0gbnVsbCB8fCBpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIGNoaWxkID0gaW5zdDtcbiAgICAgICAgdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIENvbXBvbmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSkge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUzLCBfY29tcG9uZW50TmFtZTMsIF9jb21wb25lbnROYW1lMyk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QucHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcblxuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3QuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMgJiYgaW5zdC5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtfY29tcG9uZW50TmFtZTRdKSB7XG4gICAgICAgICAgICAgIGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAvLyBrZWVwIHRoaXMgd2FybmluZyBpbiBzeW5jIHdpdGggUmVhY3RTdHJpY3RNb2RlV2FybmluZy5qc1xuICAgICAgICAgICAgICAnY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSBmcm9tIGNvbXBvbmVudFdpbGxNb3VudCB0byBjb21wb25lbnREaWRNb3VudCAocHJlZmVycmVkIGluIG1vc3QgY2FzZXMpICcgKyAnb3IgdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX2NvbXBvbmVudE5hbWU0KTtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZFdpbGxNb3VudFtfY29tcG9uZW50TmFtZTRdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgYW55IGNvbXBvbmVudCB3aXRoIHRoZSBuZXcgZ0RTRlAuXG5cblxuICAgICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgICAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGFueSBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGdEU0ZQLlxuICAgICAgICBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICAgICAgdmFyIG9sZFJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICBxdWV1ZSA9IG51bGw7XG4gICAgICAgIHJlcGxhY2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAob2xkUmVwbGFjZSAmJiBvbGRRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpbnN0LnN0YXRlID0gb2xkUXVldWVbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IG9sZFJlcGxhY2UgPyBvbGRRdWV1ZVswXSA6IGluc3Quc3RhdGU7XG4gICAgICAgICAgdmFyIGRvbnRNdXRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IG9sZFJlcGxhY2UgPyAxIDogMDsgaSA8IG9sZFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydGlhbCA9IG9sZFF1ZXVlW2ldO1xuXG4gICAgICAgICAgICB2YXIgX3BhcnRpYWxTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSAnZnVuY3Rpb24nID8gcGFydGlhbC5jYWxsKGluc3QsIG5leHRTdGF0ZSwgZWxlbWVudC5wcm9wcywgcHVibGljQ29udGV4dCkgOiBwYXJ0aWFsO1xuXG4gICAgICAgICAgICBpZiAoX3BhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChkb250TXV0YXRlKSB7XG4gICAgICAgICAgICAgICAgZG9udE11dGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIG5leHRTdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2Fzc2lnbihuZXh0U3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gaW5zdC5yZW5kZXIoKTtcblxuICAgIHtcbiAgICAgIGlmIChjaGlsZCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICBjaGlsZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIENvbXBvbmVudCk7XG4gICAgdmFyIGNoaWxkQ29udGV4dDtcblxuICAgIGlmIChkaXNhYmxlTGVnYWN5Q29udGV4dCkge1xuICAgICAge1xuICAgICAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgKyAnVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdC5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIF9jaGlsZENvbnRleHRUeXBlcyA9IENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcztcblxuICAgICAgICBpZiAodHlwZW9mIF9jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuXG4gICAgICAgICAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICghKGNvbnRleHRLZXkgaW4gX2NoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IF9hc3NpZ24oe30sIGNvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGlsZDogY2hpbGQsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9O1xufVxuXG52YXIgUmVhY3RET01TZXJ2ZXJSZW5kZXJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIFRPRE86IHR5cGUgdGhpcyBtb3JlIHN0cmljdGx5OlxuICAvLyBERVYtb25seVxuICBmdW5jdGlvbiBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGNoaWxkcmVuLCBtYWtlU3RhdGljTWFya3VwKSB7XG4gICAgdmFyIGZsYXRDaGlsZHJlbiA9IGZsYXR0ZW5Ub3BMZXZlbENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB2YXIgdG9wRnJhbWUgPSB7XG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgLy8gQXNzdW1lIGFsbCB0cmVlcyBzdGFydCBpbiB0aGUgSFRNTCBuYW1lc3BhY2UgKG5vdCB0b3RhbGx5IHRydWUsIGJ1dFxuICAgICAgLy8gdGhpcyBpcyB3aGF0IHdlIGRpZCBoaXN0b3JpY2FsbHkpXG4gICAgICBkb21OYW1lc3BhY2U6IE5hbWVzcGFjZXMuaHRtbCxcbiAgICAgIGNoaWxkcmVuOiBmbGF0Q2hpbGRyZW4sXG4gICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgY29udGV4dDogZW1wdHlPYmplY3QsXG4gICAgICBmb290ZXI6ICcnXG4gICAgfTtcblxuICAgIHtcbiAgICAgIHRvcEZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgfVxuXG4gICAgdGhpcy50aHJlYWRJRCA9IGFsbG9jVGhyZWFkSUQoKTtcbiAgICB0aGlzLnN0YWNrID0gW3RvcEZyYW1lXTtcbiAgICB0aGlzLmV4aGF1c3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLm1ha2VTdGF0aWNNYXJrdXAgPSBtYWtlU3RhdGljTWFya3VwO1xuICAgIHRoaXMuc3VzcGVuc2VEZXB0aCA9IDA7IC8vIENvbnRleHQgKG5ldyBBUEkpXG5cbiAgICB0aGlzLmNvbnRleHRJbmRleCA9IC0xO1xuICAgIHRoaXMuY29udGV4dFN0YWNrID0gW107XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFjayA9IFtdO1xuXG4gICAge1xuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFjayA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdERPTVNlcnZlclJlbmRlcmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmV4aGF1c3RlZCkge1xuICAgICAgdGhpcy5leGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jbGVhclByb3ZpZGVycygpO1xuICAgICAgZnJlZVRocmVhZElEKHRoaXMudGhyZWFkSUQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTm90ZTogV2UgdXNlIGp1c3QgdHdvIHN0YWNrcyByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGNvbnRleHQgcHJvdmlkZXJzIHlvdSBoYXZlLlxuICAgKiBQcm92aWRlcnMgYXJlIGFsd2F5cyBwb3BwZWQgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdG8gaG93IHRoZXkgd2VyZSBwdXNoZWRcbiAgICogc28gd2UgYWx3YXlzIGtub3cgb24gdGhlIHdheSBkb3duIHdoaWNoIHByb3ZpZGVyIHlvdSdsbCBlbmNvdW50ZXIgbmV4dCBvbiB0aGUgd2F5IHVwLlxuICAgKiBPbiB0aGUgd2F5IGRvd24sIHdlIHB1c2ggdGhlIGN1cnJlbnQgcHJvdmlkZXIsIGFuZCBpdHMgY29udGV4dCB2YWx1ZSAqYmVmb3JlKlxuICAgKiB3ZSBtdXRhdGVkIGl0LCBvbnRvIHRoZSBzdGFja3MuIFRoZXJlZm9yZSwgb24gdGhlIHdheSB1cCwgd2UgYWx3YXlzIGtub3cgd2hpY2hcbiAgICogcHJvdmlkZXIgbmVlZHMgdG8gYmUgXCJyZXN0b3JlZFwiIHRvIHdoaWNoIHZhbHVlLlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMjk4NSNpc3N1ZWNvbW1lbnQtMzk2MzAxMjQ4XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnB1c2hQcm92aWRlciA9IGZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlcikge1xuICAgIHZhciBpbmRleCA9ICsrdGhpcy5jb250ZXh0SW5kZXg7XG4gICAgdmFyIGNvbnRleHQgPSBwcm92aWRlci50eXBlLl9jb250ZXh0O1xuICAgIHZhciB0aHJlYWRJRCA9IHRoaXMudGhyZWFkSUQ7XG4gICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGNvbnRleHRbdGhyZWFkSURdOyAvLyBSZW1lbWJlciB3aGljaCB2YWx1ZSB0byByZXN0b3JlIHRoaXMgY29udGV4dCB0byBvbiBvdXIgd2F5IHVwLlxuXG4gICAgdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdID0gY29udGV4dDtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XSA9IHByZXZpb3VzVmFsdWU7XG5cbiAgICB7XG4gICAgICAvLyBPbmx5IHVzZWQgZm9yIHB1c2gvcG9wIG1pc21hdGNoIHdhcm5pbmdzLlxuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0gPSBwcm92aWRlcjtcbiAgICB9IC8vIE11dGF0ZSB0aGUgY3VycmVudCB2YWx1ZS5cblxuXG4gICAgY29udGV4dFt0aHJlYWRJRF0gPSBwcm92aWRlci5wcm9wcy52YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8ucG9wUHJvdmlkZXIgPSBmdW5jdGlvbiBwb3BQcm92aWRlcihwcm92aWRlcikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dEluZGV4O1xuXG4gICAge1xuICAgICAgIShpbmRleCA+IC0xICYmIHByb3ZpZGVyID09PSB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdVbmV4cGVjdGVkIHBvcC4nKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY29udGV4dFZhbHVlU3RhY2tbaW5kZXhdOyAvLyBcIkhpZGVcIiB0aGVzZSBudWxsIGFzc2lnbm1lbnRzIGZyb20gRmxvdyBieSB1c2luZyBgYW55YFxuICAgIC8vIGJlY2F1c2UgY29uY2VwdHVhbGx5IHRoZXkgYXJlIGRlbGV0aW9ucy0tYXMgbG9uZyBhcyB3ZVxuICAgIC8vIHByb21pc2UgdG8gbmV2ZXIgYWNjZXNzIHZhbHVlcyBiZXlvbmQgYHRoaXMuY29udGV4dEluZGV4YC5cblxuICAgIHRoaXMuY29udGV4dFN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dEluZGV4LS07IC8vIFJlc3RvcmUgdG8gdGhlIHByZXZpb3VzIHZhbHVlIHdlIHN0b3JlZCBhcyB3ZSB3ZXJlIHdhbGtpbmcgZG93bi5cbiAgICAvLyBXZSd2ZSBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgdGhpcyBjb250ZXh0IGhhcyBiZWVuIGV4cGFuZGVkIHRvIGFjY29tbW9kYXRlXG4gICAgLy8gdGhpcyB0aHJlYWQgaWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gaXQgYWdhaW4uXG5cbiAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJQcm92aWRlcnMgPSBmdW5jdGlvbiBjbGVhclByb3ZpZGVycygpIHtcbiAgICAvLyBSZXN0b3JlIGFueSByZW1haW5pbmcgcHJvdmlkZXJzIG9uIHRoZSBzdGFjayB0byBwcmV2aW91cyB2YWx1ZXNcbiAgICBmb3IgKHZhciBpbmRleCA9IHRoaXMuY29udGV4dEluZGV4OyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dFN0YWNrW2luZGV4XTtcbiAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF07XG4gICAgICBjb250ZXh0W3RoaXMudGhyZWFkSURdID0gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlYWQgPSBmdW5jdGlvbiByZWFkKGJ5dGVzKSB7XG4gICAgaWYgKHRoaXMuZXhoYXVzdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcHJldlRocmVhZElEID0gY3VycmVudFRocmVhZElEO1xuICAgIHNldEN1cnJlbnRUaHJlYWRJRCh0aGlzLnRocmVhZElEKTtcbiAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gRGlzcGF0Y2hlcjtcblxuICAgIHRyeSB7XG4gICAgICAvLyBNYXJrdXAgZ2VuZXJhdGVkIHdpdGhpbiA8U3VzcGVuc2U+IGVuZHMgdXAgYnVmZmVyZWQgdW50aWwgd2Uga25vd1xuICAgICAgLy8gbm90aGluZyBpbiB0aGF0IGJvdW5kYXJ5IHN1c3BlbmRlZFxuICAgICAgdmFyIG91dCA9IFsnJ107XG4gICAgICB2YXIgc3VzcGVuZGVkID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChvdXRbMF0ubGVuZ3RoIDwgYnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5leGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGZyZWVUaHJlYWRJRCh0aGlzLnRocmVhZElEKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc3VzcGVuZGVkIHx8IGZyYW1lLmNoaWxkSW5kZXggPj0gZnJhbWUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGZvb3RlciA9IGZyYW1lLmZvb3RlcjtcblxuICAgICAgICAgIGlmIChmb290ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZS50eXBlICE9IG51bGwgJiYgZnJhbWUudHlwZS50eXBlICE9IG51bGwgJiYgZnJhbWUudHlwZS50eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBmcmFtZS50eXBlO1xuICAgICAgICAgICAgdGhpcy5wb3BQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZS50eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFKSB7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNlRGVwdGgtLTtcbiAgICAgICAgICAgIHZhciBidWZmZXJlZCA9IG91dC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICBzdXNwZW5kZWQgPSBmYWxzZTsgLy8gSWYgcmVuZGVyaW5nIHdhcyBzdXNwZW5kZWQgYXQgdGhpcyBib3VuZGFyeSwgcmVuZGVyIHRoZSBmYWxsYmFja0ZyYW1lXG5cbiAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrRnJhbWUgPSBmcmFtZS5mYWxsYmFja0ZyYW1lO1xuXG4gICAgICAgICAgICAgIGlmICghZmFsbGJhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmVhY3RET01TZXJ2ZXIgZGlkIG5vdCBmaW5kIGFuIGludGVybmFsIGZhbGxiYWNrIGZyYW1lIGZvciBTdXNwZW5zZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmYWxsYmFja0ZyYW1lKTtcbiAgICAgICAgICAgICAgb3V0W3RoaXMuc3VzcGVuc2VEZXB0aF0gKz0gJzwhLS0kIS0tPic7IC8vIFNraXAgZmx1c2hpbmcgb3V0cHV0IHNpbmNlIHdlJ3JlIHN3aXRjaGluZyB0byB0aGUgZmFsbGJhY2tcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IGJ1ZmZlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gRmx1c2ggb3V0cHV0XG5cblxuICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IGZvb3RlcjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IGZyYW1lLmNoaWxkcmVuW2ZyYW1lLmNoaWxkSW5kZXgrK107XG4gICAgICAgIHZhciBvdXRCdWZmZXIgPSAnJztcblxuICAgICAgICB7XG4gICAgICAgICAgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrKHRoaXMuc3RhY2spOyAvLyBXZSdyZSBzdGFydGluZyB3b3JrIG9uIHRoaXMgZnJhbWUsIHNvIHJlc2V0IGl0cyBpbm5lciBzdGFjay5cblxuICAgICAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dEJ1ZmZlciArPSB0aGlzLnJlbmRlcihjaGlsZCwgZnJhbWUuY29udGV4dCwgZnJhbWUuZG9tTmFtZXNwYWNlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciAhPSBudWxsICYmIHR5cGVvZiBlcnIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgaWYgKCEodGhpcy5zdXNwZW5zZURlcHRoID4gMCkpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgUmVhY3QgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZW5kZXJpbmcsIGJ1dCBubyBmYWxsYmFjayBVSSB3YXMgc3BlY2lmaWVkLlxcblxcbkFkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gcHJvdmlkZSBhIGxvYWRpbmcgaW5kaWNhdG9yIG9yIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBTdXNwZW5zZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgcG9wQ3VycmVudERlYnVnU3RhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0Lmxlbmd0aCA8PSB0aGlzLnN1c3BlbnNlRGVwdGgpIHtcbiAgICAgICAgICBvdXQucHVzaCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBvdXRCdWZmZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRbMF07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgc2V0Q3VycmVudFRocmVhZElEKHByZXZUaHJlYWRJRCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoY2hpbGQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB0ZXh0ID0gJycgKyBjaGlsZDtcblxuICAgICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWFrZVN0YXRpY01hcmt1cCkge1xuICAgICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUpIHtcbiAgICAgICAgcmV0dXJuICc8IS0tIC0tPicgKyBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gdHJ1ZTtcbiAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRDaGlsZDtcblxuICAgICAgdmFyIF9yZXNvbHZlID0gcmVzb2x2ZShjaGlsZCwgY29udGV4dCwgdGhpcy50aHJlYWRJRCk7XG5cbiAgICAgIG5leHRDaGlsZCA9IF9yZXNvbHZlLmNoaWxkO1xuICAgICAgY29udGV4dCA9IF9yZXNvbHZlLmNvbnRleHQ7XG5cbiAgICAgIGlmIChuZXh0Q2hpbGQgPT09IG51bGwgfHwgbmV4dENoaWxkID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2UgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChuZXh0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBuZXh0Q2hpbGQuJCR0eXBlb2YgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENhdGNoIHVuZXhwZWN0ZWQgc3BlY2lhbCB0eXBlcyBlYXJseS5cbiAgICAgICAgICB2YXIgJCR0eXBlb2YgPSBuZXh0Q2hpbGQuJCR0eXBlb2Y7XG5cbiAgICAgICAgICBpZiAoISgkJHR5cGVvZiAhPT0gUkVBQ1RfUE9SVEFMX1RZUEUpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2F0Y2gtYWxsIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBpZiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KCkgc3VwcG9ydHMgc29tZSBuZXcgdHlwZS5cblxuXG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gZWxlbWVudC1saWtlIG9iamVjdCB0eXBlOiBcIiArICQkdHlwZW9mLnRvU3RyaW5nKCkgKyBcIi4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gdG9BcnJheShuZXh0Q2hpbGQpO1xuICAgICAgICB2YXIgZnJhbWUgPSB7XG4gICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dENoaWxkcmVuLFxuICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAge1xuICAgICAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnJhbWUpO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IC8vIFNhZmUgYmVjYXVzZSB3ZSBqdXN0IGNoZWNrZWQgaXQncyBhbiBlbGVtZW50LlxuXG5cbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZDtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IG5leHRFbGVtZW50LnR5cGU7XG5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckRPTShuZXh0RWxlbWVudCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlbGVtZW50VHlwZSkge1xuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbiA9IHRvQXJyYXkobmV4dENoaWxkLnByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdmFyIF9mcmFtZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9mcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgIHZhciBmYWxsYmFjayA9IG5leHRDaGlsZC5wcm9wcy5mYWxsYmFjaztcblxuICAgICAgICAgICAgICBpZiAoZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGZhbGxiYWNrLCB0aGVuIHRoaXMganVzdCBiZWhhdmVzIGFzIGEgZnJhZ21lbnQuXG4gICAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4zID0gdG9BcnJheShuZXh0Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZTMgPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjMsXG4gICAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lMy5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tDaGlsZHJlbiA9IHRvQXJyYXkoZmFsbGJhY2spO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuMiA9IHRvQXJyYXkobmV4dENoaWxkLnByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICB2YXIgZmFsbGJhY2tGcmFtZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBmYWxsYmFja0NoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICc8IS0tLyQtLT4nXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZhciBfZnJhbWUyID0ge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrRnJhbWU6IGZhbGxiYWNrRnJhbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogUkVBQ1RfU1VTUEVOU0VfVFlQRSxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjIsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJzwhLS0vJC0tPidcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lMi5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrRnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWUyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdXNwZW5zZURlcHRoKys7XG4gICAgICAgICAgICAgIHJldHVybiAnPCEtLSQtLT4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgU3VzcGVuc2UuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChlbGVtZW50VHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBuZXh0Q2hpbGQ7XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW40O1xuXG4gICAgICAgICAgICAgIHZhciBjb21wb25lbnRJZGVudGl0eSA9IHt9O1xuICAgICAgICAgICAgICBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSk7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW40ID0gZWxlbWVudFR5cGUucmVuZGVyKGVsZW1lbnQucHJvcHMsIGVsZW1lbnQucmVmKTtcbiAgICAgICAgICAgICAgX25leHRDaGlsZHJlbjQgPSBmaW5pc2hIb29rcyhlbGVtZW50VHlwZS5yZW5kZXIsIGVsZW1lbnQucHJvcHMsIF9uZXh0Q2hpbGRyZW40LCBlbGVtZW50LnJlZik7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW40ID0gdG9BcnJheShfbmV4dENoaWxkcmVuNCk7XG4gICAgICAgICAgICAgIHZhciBfZnJhbWU0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW40LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTQuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZWxlbWVudCA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW41ID0gW1JlYWN0LmNyZWF0ZUVsZW1lbnQoZWxlbWVudFR5cGUudHlwZSwgX2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgcmVmOiBfZWxlbWVudC5yZWZcbiAgICAgICAgICAgICAgfSwgX2VsZW1lbnQucHJvcHMpKV07XG4gICAgICAgICAgICAgIHZhciBfZnJhbWU1ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW41LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU1KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBuZXh0UHJvcHMgPSBwcm92aWRlci5wcm9wcztcblxuICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjYgPSB0b0FycmF5KG5leHRQcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTYgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW42LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTYuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMucHVzaFByb3ZpZGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTYpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHJlYWN0Q29udGV4dCA9IG5leHRDaGlsZC50eXBlOyAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbiAgICAgICAgICAgICAgLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbiAgICAgICAgICAgICAgLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4gICAgICAgICAgICAgIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4gICAgICAgICAgICAgIC8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4gICAgICAgICAgICAgIC8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuICAgICAgICAgICAgICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChyZWFjdENvbnRleHQuX2NvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgYmUgYmVjYXVzZSBpdCdzIGEgQ29udGV4dCAocmF0aGVyIHRoYW4gYSBDb25zdW1lcikuXG4gICAgICAgICAgICAgICAgICAvLyBPciBpdCBtYXkgYmUgYmVjYXVzZSBpdCdzIG9sZGVyIFJlYWN0IHdoZXJlIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gd2FybiBpZiB3ZSdyZSBzdXJlIGl0J3MgYSBuZXcgUmVhY3QuXG4gICAgICAgICAgICAgICAgICBpZiAocmVhY3RDb250ZXh0ICE9PSByZWFjdENvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWFjdENvbnRleHQgPSByZWFjdENvbnRleHQuX2NvbnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0UHJvcHMgPSBuZXh0Q2hpbGQucHJvcHM7XG4gICAgICAgICAgICAgIHZhciB0aHJlYWRJRCA9IHRoaXMudGhyZWFkSUQ7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ29udGV4dEJvdW5kcyhyZWFjdENvbnRleHQsIHRocmVhZElEKTtcbiAgICAgICAgICAgICAgdmFyIG5leHRWYWx1ZSA9IHJlYWN0Q29udGV4dFt0aHJlYWRJRF07XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW43ID0gdG9BcnJheShfbmV4dFByb3BzLmNoaWxkcmVuKG5leHRWYWx1ZSkpO1xuXG4gICAgICAgICAgICAgIHZhciBfZnJhbWU3ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG5leHRDaGlsZCxcbiAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjcsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX2ZyYW1lNy5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTcpO1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChlbmFibGVGdW5kYW1lbnRhbEFQSSkge1xuICAgICAgICAgICAgICAgIHZhciBmdW5kYW1lbnRhbEltcGwgPSBlbGVtZW50VHlwZS5pbXBsO1xuICAgICAgICAgICAgICAgIHZhciBvcGVuID0gZnVuZGFtZW50YWxJbXBsLmdldFNlcnZlclNpZGVTdHJpbmcobnVsbCwgbmV4dEVsZW1lbnQucHJvcHMpO1xuICAgICAgICAgICAgICAgIHZhciBnZXRTZXJ2ZXJTaWRlU3RyaW5nQ2xvc2UgPSBmdW5kYW1lbnRhbEltcGwuZ2V0U2VydmVyU2lkZVN0cmluZ0Nsb3NlO1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZSA9IGdldFNlcnZlclNpZGVTdHJpbmdDbG9zZSAhPT0gdW5kZWZpbmVkID8gZ2V0U2VydmVyU2lkZVN0cmluZ0Nsb3NlKG51bGwsIG5leHRFbGVtZW50LnByb3BzKSA6ICcnO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW44ID0gZnVuZGFtZW50YWxJbXBsLnJlY29uY2lsZUNoaWxkcmVuICE9PSBmYWxzZSA/IHRvQXJyYXkobmV4dENoaWxkLnByb3BzLmNoaWxkcmVuKSA6IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZTggPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogX25leHRDaGlsZHJlbjgsXG4gICAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIGZvb3RlcjogY2xvc2VcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lOC5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHRoZSBmdW5kYW1lbnRhbCBBUEkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfZWxlbWVudDIgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gbmV4dENoaWxkLnR5cGU7IC8vIEF0dGVtcHQgdG8gaW5pdGlhbGl6ZSBsYXp5IGNvbXBvbmVudCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlXG4gICAgICAgICAgICAgIC8vIHN1c3BlbnNlIHNlcnZlci1zaWRlIHJlbmRlcmVyIGlzIGVuYWJsZWQgc28gc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAvLyByZXNvbHZlZCBjb25zdHJ1Y3RvcnMgYXJlIHN1cHBvcnRlZC5cblxuICAgICAgICAgICAgICBpbml0aWFsaXplTGF6eUNvbXBvbmVudFR5cGUobGF6eUNvbXBvbmVudCk7XG5cbiAgICAgICAgICAgICAgc3dpdGNoIChsYXp5Q29tcG9uZW50Ll9zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlc29sdmVkOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbjkgPSBbUmVhY3QuY3JlYXRlRWxlbWVudChsYXp5Q29tcG9uZW50Ll9yZXN1bHQsIF9hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgIHJlZjogX2VsZW1lbnQyLnJlZlxuICAgICAgICAgICAgICAgICAgICB9LCBfZWxlbWVudDIucHJvcHMpKV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZnJhbWU5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW45LFxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIF9mcmFtZTkuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzZSBSZWplY3RlZDpcbiAgICAgICAgICAgICAgICAgIHRocm93IGxhenlDb21wb25lbnQuX3Jlc3VsdDtcblxuICAgICAgICAgICAgICAgIGNhc2UgUGVuZGluZzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBsYXp5LWxvYWRlZCBjb21wb25lbnRzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGVuYWJsZVNjb3BlQVBJKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4xMCA9IHRvQXJyYXkobmV4dENoaWxkLnByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUxMCA9IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuMTAsXG4gICAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIGZvb3RlcjogJydcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lMTAuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lMTApO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IHNjb3BlIGNvbXBvbmVudHMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIG93bmVyID0gbmV4dEVsZW1lbnQuX293bmVyO1xuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZWxlbWVudFR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWUob3duZXIpIDogbnVsbDtcblxuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArIChlbGVtZW50VHlwZSA9PSBudWxsID8gZWxlbWVudFR5cGUgOiB0eXBlb2YgZWxlbWVudFR5cGUpICsgXCIuXCIgKyBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyRE9NID0gZnVuY3Rpb24gcmVuZGVyRE9NKGVsZW1lbnQsIGNvbnRleHQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAgIHZhciB0YWcgPSBlbGVtZW50LnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgbmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuXG4gICAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gTmFtZXNwYWNlcy5odG1sKSB7XG4gICAgICBuYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAobmFtZXNwYWNlID09PSBOYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICAgICEodGFnID09PSBlbGVtZW50LnR5cGUpID8gd2FybmluZyQxKGZhbHNlLCAnPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIGVsZW1lbnQudHlwZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgICB2YXIgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAge1xuICAgICAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUpIHtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSBfYXNzaWduKHtcbiAgICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgICB9LCBwcm9wcywge1xuICAgICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgY2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAge1xuICAgICAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcyk7XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0VGV4dGFyZWFWYWx1ZSkge1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgICAgICBkaWRXYXJuRGVmYXVsdFRleHRhcmVhVmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAgICAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7IC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG5cbiAgICAgICAgdmFyIHRleHRhcmVhQ2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICBpZiAodGV4dGFyZWFDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEoZGVmYXVsdFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0ZXh0YXJlYUNoaWxkcmVuKSkge1xuICAgICAgICAgICAgaWYgKCEodGV4dGFyZWFDaGlsZHJlbi5sZW5ndGggPD0gMSkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0YXJlYUNoaWxkcmVuID0gdGV4dGFyZWFDaGlsZHJlblswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIHRleHRhcmVhQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBjaGlsZHJlbjogJycgKyBpbml0aWFsVmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAge1xuICAgICAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcblxuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4nLCBwcm9wTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4nLCBwcm9wTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUpIHtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgcHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ29wdGlvbicpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgICB2YXIgc2VsZWN0VmFsdWUgPSB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZTtcbiAgICAgIHZhciBvcHRpb25DaGlsZHJlbiA9IGZsYXR0ZW5PcHRpb25DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbkNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2pdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMgPSBfYXNzaWduKHtcbiAgICAgICAgICBzZWxlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWRcbiAgICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgY2hpbGRyZW46IG9wdGlvbkNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKTtcbiAgICB2YXIgb3V0ID0gY3JlYXRlT3BlblRhZ01hcmt1cChlbGVtZW50LnR5cGUsIHRhZywgcHJvcHMsIG5hbWVzcGFjZSwgdGhpcy5tYWtlU3RhdGljTWFya3VwLCB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMSk7XG4gICAgdmFyIGZvb3RlciA9ICcnO1xuXG4gICAgaWYgKG9taXR0ZWRDbG9zZVRhZ3MuaGFzT3duUHJvcGVydHkodGFnKSkge1xuICAgICAgb3V0ICs9ICcvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnPic7XG4gICAgICBmb290ZXIgPSAnPC8nICsgZWxlbWVudC50eXBlICsgJz4nO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbjtcbiAgICB2YXIgaW5uZXJNYXJrdXAgPSBnZXROb25DaGlsZHJlbklubmVyTWFya3VwKHByb3BzKTtcblxuICAgIGlmIChpbm5lck1hcmt1cCAhPSBudWxsKSB7XG4gICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGFnXSAmJiBpbm5lck1hcmt1cC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICAgIG91dCArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IGlubmVyTWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbiA9IHRvQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHZhciBmcmFtZSA9IHtcbiAgICAgIGRvbU5hbWVzcGFjZTogZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCBlbGVtZW50LnR5cGUpLFxuICAgICAgdHlwZTogdGFnLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBmb290ZXI6IGZvb3RlclxuICAgIH07XG5cbiAgICB7XG4gICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucHVzaChmcmFtZSk7XG4gICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICByZXR1cm4gUmVhY3RET01TZXJ2ZXJSZW5kZXJlcjtcbn0oKTtcblxuLyoqXG4gKiBSZW5kZXIgYSBSZWFjdEVsZW1lbnQgdG8gaXRzIGluaXRpYWwgSFRNTC4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIG9uIHRoZVxuICogc2VydmVyLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhlbGVtZW50KSB7XG4gIHZhciByZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIGZhbHNlKTtcblxuICB0cnkge1xuICAgIHZhciBtYXJrdXAgPSByZW5kZXJlci5yZWFkKEluZmluaXR5KTtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfVxufVxuLyoqXG4gKiBTaW1pbGFyIHRvIHJlbmRlclRvU3RyaW5nLCBleGNlcHQgdGhpcyBkb2Vzbid0IGNyZWF0ZSBleHRyYSBET00gYXR0cmlidXRlc1xuICogc3VjaCBhcyBkYXRhLXJlYWN0LWlkIHRoYXQgUmVhY3QgdXNlcyBpbnRlcm5hbGx5LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdGF0aWNtYXJrdXBcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChlbGVtZW50KSB7XG4gIHZhciByZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIHRydWUpO1xuXG4gIHRyeSB7XG4gICAgdmFyIG1hcmt1cCA9IHJlbmRlcmVyLnJlYWQoSW5maW5pdHkpO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH0gZmluYWxseSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFkYWJsZSkge1xuICBfaW5oZXJpdHNMb29zZShSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtLCBfUmVhZGFibGUpO1xuXG4gIGZ1bmN0aW9uIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgbWFrZVN0YXRpY01hcmt1cCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIC8vIENhbGxzIHRoZSBzdHJlYW0uUmVhZGFibGUob3B0aW9ucykgY29uc3RydWN0b3IuIENvbnNpZGVyIGV4cG9zaW5nIGJ1aWx0LWluXG4gICAgLy8gZmVhdHVyZXMgbGlrZSBoaWdoV2F0ZXJNYXJrIGluIHRoZSBmdXR1cmUuXG4gICAgX3RoaXMgPSBfUmVhZGFibGUuY2FsbCh0aGlzLCB7fSkgfHwgdGhpcztcbiAgICBfdGhpcy5wYXJ0aWFsUmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCBtYWtlU3RhdGljTWFya3VwKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgIHRoaXMucGFydGlhbFJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuXG4gIF9wcm90by5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKHNpemUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wdXNoKHRoaXMucGFydGlhbFJlbmRlcmVyLnJlYWQoc2l6ZSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0cm95KGVycik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtO1xufShzdHJlYW0uUmVhZGFibGUpO1xuLyoqXG4gKiBSZW5kZXIgYSBSZWFjdEVsZW1lbnQgdG8gaXRzIGluaXRpYWwgSFRNTC4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIG9uIHRoZVxuICogc2VydmVyLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9ub2Rlc3RyZWFtXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW0oZWxlbWVudCkge1xuICByZXR1cm4gbmV3IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgZmFsc2UpO1xufVxuLyoqXG4gKiBTaW1pbGFyIHRvIHJlbmRlclRvTm9kZVN0cmVhbSwgZXhjZXB0IHRoaXMgZG9lc24ndCBjcmVhdGUgZXh0cmEgRE9NIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgZGF0YS1yZWFjdC1pZCB0aGF0IFJlYWN0IHVzZXMgaW50ZXJuYWxseS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RhdGljbm9kZXN0cmVhbVxuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbShlbGVtZW50KSB7XG4gIHJldHVybiBuZXcgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCB0cnVlKTtcbn1cblxudmFyIFJlYWN0RE9NU2VydmVyTm9kZSA9IHtcbiAgcmVuZGVyVG9TdHJpbmc6IHJlbmRlclRvU3RyaW5nLFxuICByZW5kZXJUb1N0YXRpY01hcmt1cDogcmVuZGVyVG9TdGF0aWNNYXJrdXAsXG4gIHJlbmRlclRvTm9kZVN0cmVhbTogcmVuZGVyVG9Ob2RlU3RyZWFtLFxuICByZW5kZXJUb1N0YXRpY05vZGVTdHJlYW06IHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uXG59O1xuXG52YXIgUmVhY3RET01TZXJ2ZXJOb2RlJDEgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01TZXJ2ZXJOb2RlXG59KTtcblxudmFyIFJlYWN0RE9NU2VydmVyID0gKCBSZWFjdERPTVNlcnZlck5vZGUkMSAmJiBSZWFjdERPTVNlcnZlck5vZGUgKSB8fCBSZWFjdERPTVNlcnZlck5vZGUkMTtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3RcblxuXG52YXIgc2VydmVyX25vZGUgPSBSZWFjdERPTVNlcnZlci5kZWZhdWx0IHx8IFJlYWN0RE9NU2VydmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNlcnZlcl9ub2RlO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc2VydmVyLm5vZGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20tc2VydmVyLm5vZGUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjExLjBcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUpO1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xudmFyIGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2soY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh2b2lkIDAsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrJDEgPSBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2s7XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiaW1wb3J0IHsgUm91dGVyLCBfX1JvdXRlckNvbnRleHQsIG1hdGNoUGF0aCB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5leHBvcnQgKiBmcm9tICdyZWFjdC1yb3V0ZXInO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTG9jYXRpb24gfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd0aW55LXdhcm5pbmcnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIEhUTUw1IGhpc3RvcnkuXG4gKi9cblxudmFyIEJyb3dzZXJSb3V0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQnJvd3NlclJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnJvd3NlclJvdXRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoX3RoaXMucHJvcHMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCcm93c2VyUm91dGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQnJvd3NlclJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBCcm93c2VyUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgZm9yY2VSZWZyZXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBrZXlMZW5ndGg6IFByb3BUeXBlcy5udW1iZXJcbiAgfTtcblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPEJyb3dzZXJSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksIFwiICsgXCJ1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBCcm93c2VyUm91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIHdpbmRvdy5sb2NhdGlvbi5oYXNoLlxuICovXG5cbnZhciBIYXNoUm91dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKEhhc2hSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhhc2hIaXN0b3J5KF90aGlzLnByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gSGFzaFJvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhhc2hSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgSGFzaFJvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgIGhhc2hUeXBlOiBQcm9wVHlwZXMub25lT2YoW1wiaGFzaGJhbmdcIiwgXCJub3NsYXNoXCIsIFwic2xhc2hcIl0pXG4gIH07XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCBcIjxIYXNoUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCBcIiArIFwidXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgSGFzaFJvdXRlciBhcyBSb3V0ZXIgfWAuXCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgcmVzb2x2ZVRvTG9jYXRpb24gPSBmdW5jdGlvbiByZXNvbHZlVG9Mb2NhdGlvbih0bywgY3VycmVudExvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgdG8gPT09IFwiZnVuY3Rpb25cIiA/IHRvKGN1cnJlbnRMb2NhdGlvbikgOiB0bztcbn07XG52YXIgbm9ybWFsaXplVG9Mb2NhdGlvbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVRvTG9jYXRpb24odG8sIGN1cnJlbnRMb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gY3JlYXRlTG9jYXRpb24odG8sIG51bGwsIG51bGwsIGN1cnJlbnRMb2NhdGlvbikgOiB0bztcbn07XG5cbnZhciBmb3J3YXJkUmVmU2hpbSA9IGZ1bmN0aW9uIGZvcndhcmRSZWZTaGltKEMpIHtcbiAgcmV0dXJuIEM7XG59O1xuXG52YXIgZm9yd2FyZFJlZiA9IFJlYWN0LmZvcndhcmRSZWY7XG5cbmlmICh0eXBlb2YgZm9yd2FyZFJlZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICBmb3J3YXJkUmVmID0gZm9yd2FyZFJlZlNoaW07XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbnZhciBMaW5rQW5jaG9yID0gZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZiwgZm9yd2FyZGVkUmVmKSB7XG4gIHZhciBpbm5lclJlZiA9IF9yZWYuaW5uZXJSZWYsXG4gICAgICBuYXZpZ2F0ZSA9IF9yZWYubmF2aWdhdGUsXG4gICAgICBfb25DbGljayA9IF9yZWYub25DbGljayxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJpbm5lclJlZlwiLCBcIm5hdmlnYXRlXCIsIFwib25DbGlja1wiXSk7XG5cbiAgdmFyIHRhcmdldCA9IHJlc3QudGFyZ2V0O1xuXG4gIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKF9vbkNsaWNrKSBfb25DbGljayhldmVudCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aHJvdyBleDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uQ2xpY2sgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAoIC8vIGlnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAgICAgIXRhcmdldCB8fCB0YXJnZXQgPT09IFwiX3NlbGZcIikgJiYgLy8gbGV0IGJyb3dzZXIgaGFuZGxlIFwidGFyZ2V0PV9ibGFua1wiIGV0Yy5cbiAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIGlnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG5hdmlnYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBSZWFjdCAxNSBjb21wYXRcblxuXG4gIGlmIChmb3J3YXJkUmVmU2hpbSAhPT0gZm9yd2FyZFJlZikge1xuICAgIHByb3BzLnJlZiA9IGZvcndhcmRlZFJlZiB8fCBpbm5lclJlZjtcbiAgfSBlbHNlIHtcbiAgICBwcm9wcy5yZWYgPSBpbm5lclJlZjtcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCBwcm9wcyk7XG59KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBMaW5rQW5jaG9yLmRpc3BsYXlOYW1lID0gXCJMaW5rQW5jaG9yXCI7XG59XG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG5cbnZhciBMaW5rID0gZm9yd2FyZFJlZihmdW5jdGlvbiAoX3JlZjIsIGZvcndhcmRlZFJlZikge1xuICB2YXIgX3JlZjIkY29tcG9uZW50ID0gX3JlZjIuY29tcG9uZW50LFxuICAgICAgY29tcG9uZW50ID0gX3JlZjIkY29tcG9uZW50ID09PSB2b2lkIDAgPyBMaW5rQW5jaG9yIDogX3JlZjIkY29tcG9uZW50LFxuICAgICAgcmVwbGFjZSA9IF9yZWYyLnJlcGxhY2UsXG4gICAgICB0byA9IF9yZWYyLnRvLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmMi5pbm5lclJlZixcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiY29tcG9uZW50XCIsIFwicmVwbGFjZVwiLCBcInRvXCIsIFwiaW5uZXJSZWZcIl0pO1xuXG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KF9fUm91dGVyQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPExpbms+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgdmFyIGhpc3RvcnkgPSBjb250ZXh0Lmhpc3Rvcnk7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplVG9Mb2NhdGlvbihyZXNvbHZlVG9Mb2NhdGlvbih0bywgY29udGV4dC5sb2NhdGlvbiksIGNvbnRleHQubG9jYXRpb24pO1xuICAgIHZhciBocmVmID0gbG9jYXRpb24gPyBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pIDogXCJcIjtcblxuICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBocmVmOiBocmVmLFxuICAgICAgbmF2aWdhdGU6IGZ1bmN0aW9uIG5hdmlnYXRlKCkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSByZXNvbHZlVG9Mb2NhdGlvbih0bywgY29udGV4dC5sb2NhdGlvbik7XG4gICAgICAgIHZhciBtZXRob2QgPSByZXBsYWNlID8gaGlzdG9yeS5yZXBsYWNlIDogaGlzdG9yeS5wdXNoO1xuICAgICAgICBtZXRob2QobG9jYXRpb24pO1xuICAgICAgfVxuICAgIH0pOyAvLyBSZWFjdCAxNSBjb21wYXRcblxuXG4gICAgaWYgKGZvcndhcmRSZWZTaGltICE9PSBmb3J3YXJkUmVmKSB7XG4gICAgICBwcm9wcy5yZWYgPSBmb3J3YXJkZWRSZWYgfHwgaW5uZXJSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzLmlubmVyUmVmID0gaW5uZXJSZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG4gIH0pO1xufSk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgdmFyIHRvVHlwZSA9IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5mdW5jXSk7XG4gIHZhciByZWZUeXBlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY3VycmVudDogUHJvcFR5cGVzLmFueVxuICB9KV0pO1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG4gIExpbmsucHJvcFR5cGVzID0ge1xuICAgIGlubmVyUmVmOiByZWZUeXBlLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJlcGxhY2U6IFByb3BUeXBlcy5ib29sLFxuICAgIHRhcmdldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0bzogdG9UeXBlLmlzUmVxdWlyZWRcbiAgfTtcbn1cblxudmFyIGZvcndhcmRSZWZTaGltJDEgPSBmdW5jdGlvbiBmb3J3YXJkUmVmU2hpbShDKSB7XG4gIHJldHVybiBDO1xufTtcblxudmFyIGZvcndhcmRSZWYkMSA9IFJlYWN0LmZvcndhcmRSZWY7XG5cbmlmICh0eXBlb2YgZm9yd2FyZFJlZiQxID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIGZvcndhcmRSZWYkMSA9IGZvcndhcmRSZWZTaGltJDE7XG59XG5cbmZ1bmN0aW9uIGpvaW5DbGFzc25hbWVzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2xhc3NuYW1lcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBjbGFzc25hbWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzbmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGk7XG4gIH0pLmpvaW4oXCIgXCIpO1xufVxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuXG5cbnZhciBOYXZMaW5rID0gZm9yd2FyZFJlZiQxKGZ1bmN0aW9uIChfcmVmLCBmb3J3YXJkZWRSZWYpIHtcbiAgdmFyIF9yZWYkYXJpYUN1cnJlbnQgPSBfcmVmW1wiYXJpYS1jdXJyZW50XCJdLFxuICAgICAgYXJpYUN1cnJlbnQgPSBfcmVmJGFyaWFDdXJyZW50ID09PSB2b2lkIDAgPyBcInBhZ2VcIiA6IF9yZWYkYXJpYUN1cnJlbnQsXG4gICAgICBfcmVmJGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgYWN0aXZlQ2xhc3NOYW1lID0gX3JlZiRhY3RpdmVDbGFzc05hbWUgPT09IHZvaWQgMCA/IFwiYWN0aXZlXCIgOiBfcmVmJGFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgIGFjdGl2ZVN0eWxlID0gX3JlZi5hY3RpdmVTdHlsZSxcbiAgICAgIGNsYXNzTmFtZVByb3AgPSBfcmVmLmNsYXNzTmFtZSxcbiAgICAgIGV4YWN0ID0gX3JlZi5leGFjdCxcbiAgICAgIGlzQWN0aXZlUHJvcCA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBsb2NhdGlvblByb3AgPSBfcmVmLmxvY2F0aW9uLFxuICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICBzdHlsZVByb3AgPSBfcmVmLnN0eWxlLFxuICAgICAgdG8gPSBfcmVmLnRvLFxuICAgICAgaW5uZXJSZWYgPSBfcmVmLmlubmVyUmVmLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImFyaWEtY3VycmVudFwiLCBcImFjdGl2ZUNsYXNzTmFtZVwiLCBcImFjdGl2ZVN0eWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwiZXhhY3RcIiwgXCJpc0FjdGl2ZVwiLCBcImxvY2F0aW9uXCIsIFwic3RyaWN0XCIsIFwic3R5bGVcIiwgXCJ0b1wiLCBcImlubmVyUmVmXCJdKTtcblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChfX1JvdXRlckNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxOYXZMaW5rPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvblByb3AgfHwgY29udGV4dC5sb2NhdGlvbjtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IG5vcm1hbGl6ZVRvTG9jYXRpb24ocmVzb2x2ZVRvTG9jYXRpb24odG8sIGN1cnJlbnRMb2NhdGlvbiksIGN1cnJlbnRMb2NhdGlvbik7XG4gICAgdmFyIHBhdGggPSB0b0xvY2F0aW9uLnBhdGhuYW1lOyAvLyBSZWdleCB0YWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vcGlsbGFyanMvcGF0aC10by1yZWdleHAvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDIwMlxuXG4gICAgdmFyIGVzY2FwZWRQYXRoID0gcGF0aCAmJiBwYXRoLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbiAgICB2YXIgbWF0Y2ggPSBlc2NhcGVkUGF0aCA/IG1hdGNoUGF0aChjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIHtcbiAgICAgIHBhdGg6IGVzY2FwZWRQYXRoLFxuICAgICAgZXhhY3Q6IGV4YWN0LFxuICAgICAgc3RyaWN0OiBzdHJpY3RcbiAgICB9KSA6IG51bGw7XG4gICAgdmFyIGlzQWN0aXZlID0gISEoaXNBY3RpdmVQcm9wID8gaXNBY3RpdmVQcm9wKG1hdGNoLCBjdXJyZW50TG9jYXRpb24pIDogbWF0Y2gpO1xuICAgIHZhciBjbGFzc05hbWUgPSBpc0FjdGl2ZSA/IGpvaW5DbGFzc25hbWVzKGNsYXNzTmFtZVByb3AsIGFjdGl2ZUNsYXNzTmFtZSkgOiBjbGFzc05hbWVQcm9wO1xuICAgIHZhciBzdHlsZSA9IGlzQWN0aXZlID8gX2V4dGVuZHMoe30sIHN0eWxlUHJvcCwge30sIGFjdGl2ZVN0eWxlKSA6IHN0eWxlUHJvcDtcblxuICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHtcbiAgICAgIFwiYXJpYS1jdXJyZW50XCI6IGlzQWN0aXZlICYmIGFyaWFDdXJyZW50IHx8IG51bGwsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHRvOiB0b0xvY2F0aW9uXG4gICAgfSwgcmVzdCk7IC8vIFJlYWN0IDE1IGNvbXBhdFxuXG5cbiAgICBpZiAoZm9yd2FyZFJlZlNoaW0kMSAhPT0gZm9yd2FyZFJlZiQxKSB7XG4gICAgICBwcm9wcy5yZWYgPSBmb3J3YXJkZWRSZWYgfHwgaW5uZXJSZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzLmlubmVyUmVmID0gaW5uZXJSZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgcHJvcHMpO1xuICB9KTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIE5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbiAgdmFyIGFyaWFDdXJyZW50VHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXCJwYWdlXCIsIFwic3RlcFwiLCBcImxvY2F0aW9uXCIsIFwiZGF0ZVwiLCBcInRpbWVcIiwgXCJ0cnVlXCJdKTtcbiAgTmF2TGluay5wcm9wVHlwZXMgPSBfZXh0ZW5kcyh7fSwgTGluay5wcm9wVHlwZXMsIHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFR5cGUsXG4gICAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jLFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3RcbiAgfSk7XG59XG5cbmV4cG9ydCB7IEJyb3dzZXJSb3V0ZXIsIEhhc2hSb3V0ZXIsIExpbmssIE5hdkxpbmsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJvdXRlci1kb20uanMubWFwXG4iLCJpbXBvcnQgX2luaGVyaXRzTG9vc2UgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZU1lbW9yeUhpc3RvcnksIGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCwgY3JlYXRlUGF0aCB9IGZyb20gJ2hpc3RvcnknO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAndGlueS13YXJuaW5nJztcbmltcG9ydCBjcmVhdGVDb250ZXh0IGZyb20gJ21pbmktY3JlYXRlLXJlYWN0LWNvbnRleHQnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICd0aW55LWludmFyaWFudCc7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgcGF0aFRvUmVnZXhwIGZyb20gJ3BhdGgtdG8tcmVnZXhwJztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlJztcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuXG4vLyBUT0RPOiBSZXBsYWNlIHdpdGggUmVhY3QuY3JlYXRlQ29udGV4dCBvbmNlIHdlIGNhbiBhc3N1bWUgUmVhY3QgMTYrXG5cbnZhciBjcmVhdGVOYW1lZENvbnRleHQgPSBmdW5jdGlvbiBjcmVhdGVOYW1lZENvbnRleHQobmFtZSkge1xuICB2YXIgY29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcbiAgY29udGV4dC5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxudmFyIGNvbnRleHQgPVxuLyojX19QVVJFX18qL1xuY3JlYXRlTmFtZWRDb250ZXh0KFwiUm91dGVyXCIpO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwdXR0aW5nIGhpc3Rvcnkgb24gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgUm91dGVyLmNvbXB1dGVSb290TWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlUm9vdE1hdGNoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgdXJsOiBcIi9cIixcbiAgICAgIHBhcmFtczoge30sXG4gICAgICBpc0V4YWN0OiBwYXRobmFtZSA9PT0gXCIvXCJcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFJvdXRlcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgbG9jYXRpb246IHByb3BzLmhpc3RvcnkubG9jYXRpb25cbiAgICB9OyAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgaGF2ZSB0byBzdGFydCBsaXN0ZW5pbmcgZm9yIGxvY2F0aW9uXG4gICAgLy8gY2hhbmdlcyBoZXJlIGluIHRoZSBjb25zdHJ1Y3RvciBpbiBjYXNlIHRoZXJlIGFyZSBhbnkgPFJlZGlyZWN0PnNcbiAgICAvLyBvbiB0aGUgaW5pdGlhbCByZW5kZXIuIElmIHRoZXJlIGFyZSwgdGhleSB3aWxsIHJlcGxhY2UvcHVzaCB3aGVuXG4gICAgLy8gdGhleSBtb3VudCBhbmQgc2luY2UgY0RNIGZpcmVzIGluIGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLCB3ZSBtYXlcbiAgICAvLyBnZXQgYSBuZXcgbG9jYXRpb24gYmVmb3JlIHRoZSA8Um91dGVyPiBpcyBtb3VudGVkLlxuXG4gICAgX3RoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIF90aGlzLl9wZW5kaW5nTG9jYXRpb24gPSBudWxsO1xuXG4gICAgaWYgKCFwcm9wcy5zdGF0aWNDb250ZXh0KSB7XG4gICAgICBfdGhpcy51bmxpc3RlbiA9IHByb3BzLmhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICBpZiAoX3RoaXMuX2lzTW91bnRlZCkge1xuICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLl9wZW5kaW5nTG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl9wZW5kaW5nTG9jYXRpb24pIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBsb2NhdGlvbjogdGhpcy5fcGVuZGluZ0xvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMudW5saXN0ZW4pIHRoaXMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIHx8IG51bGwsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBoaXN0b3J5OiB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIGxvY2F0aW9uOiB0aGlzLnN0YXRlLmxvY2F0aW9uLFxuICAgICAgICBtYXRjaDogUm91dGVyLmNvbXB1dGVSb290TWF0Y2godGhpcy5zdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSksXG4gICAgICAgIHN0YXRpY0NvbnRleHQ6IHRoaXMucHJvcHMuc3RhdGljQ29udGV4dFxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHByZXZQcm9wcy5oaXN0b3J5ID09PSB0aGlzLnByb3BzLmhpc3RvcnksIFwiWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PlwiKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHN0b3JlcyBsb2NhdGlvbiBpbiBtZW1vcnkuXG4gKi9cblxudmFyIE1lbW9yeVJvdXRlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShNZW1vcnlSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1lbW9yeVJvdXRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlTWVtb3J5SGlzdG9yeShfdGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1lbW9yeVJvdXRlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICAgIGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSxcbiAgICAgIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbW9yeVJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBNZW1vcnlSb3V0ZXIucHJvcFR5cGVzID0ge1xuICAgIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgaW5pdGlhbEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICAgIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbiAgfTtcblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgXCI8TWVtb3J5Um91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCBcIiArIFwidXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgTWVtb3J5Um91dGVyIGFzIFJvdXRlciB9YC5cIikgOiB2b2lkIDA7XG4gIH07XG59XG5cbnZhciBMaWZlY3ljbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTGlmZWN5Y2xlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaWZlY3ljbGUoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExpZmVjeWNsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Nb3VudCkgdGhpcy5wcm9wcy5vbk1vdW50LmNhbGwodGhpcywgdGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vblVwZGF0ZSkgdGhpcy5wcm9wcy5vblVwZGF0ZS5jYWxsKHRoaXMsIHRoaXMsIHByZXZQcm9wcyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB0aGlzLnByb3BzLm9uVW5tb3VudC5jYWxsKHRoaXMsIHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIExpZmVjeWNsZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHJvbXB0aW5nIHRoZSB1c2VyIGJlZm9yZSBuYXZpZ2F0aW5nIGF3YXkgZnJvbSBhIHNjcmVlbi5cbiAqL1xuXG5mdW5jdGlvbiBQcm9tcHQoX3JlZikge1xuICB2YXIgbWVzc2FnZSA9IF9yZWYubWVzc2FnZSxcbiAgICAgIF9yZWYkd2hlbiA9IF9yZWYud2hlbixcbiAgICAgIHdoZW4gPSBfcmVmJHdoZW4gPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJHdoZW47XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxQcm9tcHQ+IG91dHNpZGUgYSA8Um91dGVyPlwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgaWYgKCF3aGVuIHx8IGNvbnRleHQuc3RhdGljQ29udGV4dCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIG1ldGhvZCA9IGNvbnRleHQuaGlzdG9yeS5ibG9jaztcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChMaWZlY3ljbGUsIHtcbiAgICAgIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoc2VsZikge1xuICAgICAgICBzZWxmLnJlbGVhc2UgPSBtZXRob2QobWVzc2FnZSk7XG4gICAgICB9LFxuICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKHNlbGYsIHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLm1lc3NhZ2UgIT09IG1lc3NhZ2UpIHtcbiAgICAgICAgICBzZWxmLnJlbGVhc2UoKTtcbiAgICAgICAgICBzZWxmLnJlbGVhc2UgPSBtZXRob2QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVubW91bnQ6IGZ1bmN0aW9uIG9uVW5tb3VudChzZWxmKSB7XG4gICAgICAgIHNlbGYucmVsZWFzZSgpO1xuICAgICAgfSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICB9KTtcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgdmFyIG1lc3NhZ2VUeXBlID0gUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKTtcbiAgUHJvbXB0LnByb3BUeXBlcyA9IHtcbiAgICB3aGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBtZXNzYWdlOiBtZXNzYWdlVHlwZS5pc1JlcXVpcmVkXG4gIH07XG59XG5cbnZhciBjYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxuZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0aCkge1xuICBpZiAoY2FjaGVbcGF0aF0pIHJldHVybiBjYWNoZVtwYXRoXTtcbiAgdmFyIGdlbmVyYXRvciA9IHBhdGhUb1JlZ2V4cC5jb21waWxlKHBhdGgpO1xuXG4gIGlmIChjYWNoZUNvdW50IDwgY2FjaGVMaW1pdCkge1xuICAgIGNhY2hlW3BhdGhdID0gZ2VuZXJhdG9yO1xuICAgIGNhY2hlQ291bnQrKztcbiAgfVxuXG4gIHJldHVybiBnZW5lcmF0b3I7XG59XG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIGdlbmVyYXRpbmcgYSBVUkwgcGF0aG5hbWUgZnJvbSBhIHBhdGggYW5kIHBhcmFtZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgocGF0aCwgcGFyYW1zKSB7XG4gIGlmIChwYXRoID09PSB2b2lkIDApIHtcbiAgICBwYXRoID0gXCIvXCI7XG4gIH1cblxuICBpZiAocGFyYW1zID09PSB2b2lkIDApIHtcbiAgICBwYXJhbXMgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBwYXRoID09PSBcIi9cIiA/IHBhdGggOiBjb21waWxlUGF0aChwYXRoKShwYXJhbXMsIHtcbiAgICBwcmV0dHk6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIG5hdmlnYXRpbmcgcHJvZ3JhbW1hdGljYWxseSB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbmZ1bmN0aW9uIFJlZGlyZWN0KF9yZWYpIHtcbiAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICB0byA9IF9yZWYudG8sXG4gICAgICBfcmVmJHB1c2ggPSBfcmVmLnB1c2gsXG4gICAgICBwdXNoID0gX3JlZiRwdXNoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkcHVzaDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAhY29udGV4dCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJlZGlyZWN0PiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIHZhciBoaXN0b3J5ID0gY29udGV4dC5oaXN0b3J5LFxuICAgICAgICBzdGF0aWNDb250ZXh0ID0gY29udGV4dC5zdGF0aWNDb250ZXh0O1xuICAgIHZhciBtZXRob2QgPSBwdXNoID8gaGlzdG9yeS5wdXNoIDogaGlzdG9yeS5yZXBsYWNlO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGNvbXB1dGVkTWF0Y2ggPyB0eXBlb2YgdG8gPT09IFwic3RyaW5nXCIgPyBnZW5lcmF0ZVBhdGgodG8sIGNvbXB1dGVkTWF0Y2gucGFyYW1zKSA6IF9leHRlbmRzKHt9LCB0bywge1xuICAgICAgcGF0aG5hbWU6IGdlbmVyYXRlUGF0aCh0by5wYXRobmFtZSwgY29tcHV0ZWRNYXRjaC5wYXJhbXMpXG4gICAgfSkgOiB0byk7IC8vIFdoZW4gcmVuZGVyaW5nIGluIGEgc3RhdGljIGNvbnRleHQsXG4gICAgLy8gc2V0IHRoZSBuZXcgbG9jYXRpb24gaW1tZWRpYXRlbHkuXG5cbiAgICBpZiAoc3RhdGljQ29udGV4dCkge1xuICAgICAgbWV0aG9kKGxvY2F0aW9uKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KExpZmVjeWNsZSwge1xuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgbWV0aG9kKGxvY2F0aW9uKTtcbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoc2VsZiwgcHJldlByb3BzKSB7XG4gICAgICAgIHZhciBwcmV2TG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwcmV2UHJvcHMudG8pO1xuXG4gICAgICAgIGlmICghbG9jYXRpb25zQXJlRXF1YWwocHJldkxvY2F0aW9uLCBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICAgICAgICBrZXk6IHByZXZMb2NhdGlvbi5rZXlcbiAgICAgICAgfSkpKSB7XG4gICAgICAgICAgbWV0aG9kKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRvOiB0b1xuICAgIH0pO1xuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBSZWRpcmVjdC5wcm9wVHlwZXMgPSB7XG4gICAgcHVzaDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZnJvbTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWRcbiAgfTtcbn1cblxudmFyIGNhY2hlJDEgPSB7fTtcbnZhciBjYWNoZUxpbWl0JDEgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50JDEgPSAwO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0aCQxKHBhdGgsIG9wdGlvbnMpIHtcbiAgdmFyIGNhY2hlS2V5ID0gXCJcIiArIG9wdGlvbnMuZW5kICsgb3B0aW9ucy5zdHJpY3QgKyBvcHRpb25zLnNlbnNpdGl2ZTtcbiAgdmFyIHBhdGhDYWNoZSA9IGNhY2hlJDFbY2FjaGVLZXldIHx8IChjYWNoZSQxW2NhY2hlS2V5XSA9IHt9KTtcbiAgaWYgKHBhdGhDYWNoZVtwYXRoXSkgcmV0dXJuIHBhdGhDYWNoZVtwYXRoXTtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlZ2V4cCA9IHBhdGhUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICByZWdleHA6IHJlZ2V4cCxcbiAgICBrZXlzOiBrZXlzXG4gIH07XG5cbiAgaWYgKGNhY2hlQ291bnQkMSA8IGNhY2hlTGltaXQkMSkge1xuICAgIHBhdGhDYWNoZVtwYXRoXSA9IHJlc3VsdDtcbiAgICBjYWNoZUNvdW50JDErKztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgVVJMIHBhdGhuYW1lIHRvIGEgcGF0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgcGF0aDogb3B0aW9uc1xuICAgIH07XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGF0aCA9IF9vcHRpb25zLnBhdGgsXG4gICAgICBfb3B0aW9ucyRleGFjdCA9IF9vcHRpb25zLmV4YWN0LFxuICAgICAgZXhhY3QgPSBfb3B0aW9ucyRleGFjdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRleGFjdCxcbiAgICAgIF9vcHRpb25zJHN0cmljdCA9IF9vcHRpb25zLnN0cmljdCxcbiAgICAgIHN0cmljdCA9IF9vcHRpb25zJHN0cmljdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRzdHJpY3QsXG4gICAgICBfb3B0aW9ucyRzZW5zaXRpdmUgPSBfb3B0aW9ucy5zZW5zaXRpdmUsXG4gICAgICBzZW5zaXRpdmUgPSBfb3B0aW9ucyRzZW5zaXRpdmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkc2Vuc2l0aXZlO1xuICB2YXIgcGF0aHMgPSBbXS5jb25jYXQocGF0aCk7XG4gIHJldHVybiBwYXRocy5yZWR1Y2UoZnVuY3Rpb24gKG1hdGNoZWQsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGggJiYgcGF0aCAhPT0gXCJcIikgcmV0dXJuIG51bGw7XG4gICAgaWYgKG1hdGNoZWQpIHJldHVybiBtYXRjaGVkO1xuXG4gICAgdmFyIF9jb21waWxlUGF0aCA9IGNvbXBpbGVQYXRoJDEocGF0aCwge1xuICAgICAgZW5kOiBleGFjdCxcbiAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgc2Vuc2l0aXZlOiBzZW5zaXRpdmVcbiAgICB9KSxcbiAgICAgICAgcmVnZXhwID0gX2NvbXBpbGVQYXRoLnJlZ2V4cCxcbiAgICAgICAga2V5cyA9IF9jb21waWxlUGF0aC5rZXlzO1xuXG4gICAgdmFyIG1hdGNoID0gcmVnZXhwLmV4ZWMocGF0aG5hbWUpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgIHZhciB1cmwgPSBtYXRjaFswXSxcbiAgICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG4gICAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuICAgIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAvLyB0aGUgcGF0aCB1c2VkIHRvIG1hdGNoXG4gICAgICB1cmw6IHBhdGggPT09IFwiL1wiICYmIHVybCA9PT0gXCJcIiA/IFwiL1wiIDogdXJsLFxuICAgICAgLy8gdGhlIG1hdGNoZWQgcG9ydGlvbiBvZiB0aGUgVVJMXG4gICAgICBpc0V4YWN0OiBpc0V4YWN0LFxuICAgICAgLy8gd2hldGhlciBvciBub3Qgd2UgbWF0Y2hlZCBleGFjdGx5XG4gICAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICAgIG1lbW9ba2V5Lm5hbWVdID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICB9LCB7fSlcbiAgICB9O1xuICB9LCBudWxsKTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGV2YWxDaGlsZHJlbkRldihjaGlsZHJlbiwgcHJvcHMsIHBhdGgpIHtcbiAgdmFyIHZhbHVlID0gY2hpbGRyZW4ocHJvcHMpO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKHZhbHVlICE9PSB1bmRlZmluZWQsIFwiWW91IHJldHVybmVkIGB1bmRlZmluZWRgIGZyb20gdGhlIGBjaGlsZHJlbmAgZnVuY3Rpb24gb2YgXCIgKyAoXCI8Um91dGVcIiArIChwYXRoID8gXCIgcGF0aD1cXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIgOiBcIlwiKSArIFwiPiwgYnV0IHlvdSBcIikgKyBcInNob3VsZCBoYXZlIHJldHVybmVkIGEgUmVhY3QgZWxlbWVudCBvciBgbnVsbGBcIikgOiB2b2lkIDA7XG4gIHJldHVybiB2YWx1ZSB8fCBudWxsO1xufVxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBzaW5nbGUgcGF0aCBhbmQgcmVuZGVyaW5nLlxuICovXG5cblxudmFyIFJvdXRlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvdXRlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZSgpIHtcbiAgICByZXR1cm4gX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUm91dGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0JDEpIHtcbiAgICAgICFjb250ZXh0JDEgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZT4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF90aGlzLnByb3BzLmxvY2F0aW9uIHx8IGNvbnRleHQkMS5sb2NhdGlvbjtcbiAgICAgIHZhciBtYXRjaCA9IF90aGlzLnByb3BzLmNvbXB1dGVkTWF0Y2ggPyBfdGhpcy5wcm9wcy5jb21wdXRlZE1hdGNoIC8vIDxTd2l0Y2g+IGFscmVhZHkgY29tcHV0ZWQgdGhlIG1hdGNoIGZvciB1c1xuICAgICAgOiBfdGhpcy5wcm9wcy5wYXRoID8gbWF0Y2hQYXRoKGxvY2F0aW9uLnBhdGhuYW1lLCBfdGhpcy5wcm9wcykgOiBjb250ZXh0JDEubWF0Y2g7XG5cbiAgICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCBjb250ZXh0JDEsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBtYXRjaDogbWF0Y2hcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIGNvbXBvbmVudCA9IF90aGlzJHByb3BzLmNvbXBvbmVudCxcbiAgICAgICAgICByZW5kZXIgPSBfdGhpcyRwcm9wcy5yZW5kZXI7IC8vIFByZWFjdCB1c2VzIGFuIGVtcHR5IGFycmF5IGFzIGNoaWxkcmVuIGJ5XG4gICAgICAvLyBkZWZhdWx0LCBzbyB1c2UgbnVsbCBpZiB0aGF0J3MgdGhlIGNhc2UuXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJiBjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9wc1xuICAgICAgfSwgcHJvcHMubWF0Y2ggPyBjaGlsZHJlbiA/IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZXZhbENoaWxkcmVuRGV2KGNoaWxkcmVuLCBwcm9wcywgX3RoaXMucHJvcHMucGF0aCkgOiBjaGlsZHJlbihwcm9wcykgOiBjaGlsZHJlbiA6IGNvbXBvbmVudCA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcykgOiByZW5kZXIgPyByZW5kZXIocHJvcHMpIDogbnVsbCA6IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gZXZhbENoaWxkcmVuRGV2KGNoaWxkcmVuLCBwcm9wcywgX3RoaXMucHJvcHMucGF0aCkgOiBjaGlsZHJlbihwcm9wcykgOiBudWxsKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUm91dGU7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGUucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm5vZGVdKSxcbiAgICBjb21wb25lbnQ6IGZ1bmN0aW9uIGNvbXBvbmVudChwcm9wcywgcHJvcE5hbWUpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gJiYgIWlzVmFsaWRFbGVtZW50VHlwZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3AgJ2NvbXBvbmVudCcgc3VwcGxpZWQgdG8gJ1JvdXRlJzogdGhlIHByb3AgaXMgbm90IGEgdmFsaWQgUmVhY3QgY29tcG9uZW50XCIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICAgIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHBhdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXSksXG4gICAgcmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICAgIHN0cmljdDogUHJvcFR5cGVzLmJvb2xcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSAmJiB0aGlzLnByb3BzLmNvbXBvbmVudCksIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY29tcG9uZW50PiB3aWxsIGJlIGlnbm9yZWRcIikgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSAmJiB0aGlzLnByb3BzLnJlbmRlciksIFwiWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSByZW5kZXI+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgcmVuZGVyPiB3aWxsIGJlIGlnbm9yZWRcIikgOiB2b2lkIDA7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMucmVuZGVyKSwgXCJZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSByZW5kZXI+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgcmVuZGVyPiB3aWxsIGJlIGlnbm9yZWRcIikgOiB2b2lkIDA7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEodGhpcy5wcm9wcy5sb2NhdGlvbiAmJiAhcHJldlByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEoIXRoaXMucHJvcHMubG9jYXRpb24gJiYgcHJldlByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBwcm92aWRlZCBhIFwibG9jYXRpb25cIiBwcm9wIGluaXRpYWxseSBidXQgb21pdHRlZCBpdCBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpIDogdm9pZCAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiID8gcGF0aCA6IFwiL1wiICsgcGF0aDtcbn1cblxuZnVuY3Rpb24gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcbiAgdmFyIGJhc2UgPSBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpO1xuICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlKSAhPT0gMCkgcmV0dXJuIGxvY2F0aW9uO1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihiYXNlLmxlbmd0aClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVSTChsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gbG9jYXRpb24gOiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gc3RhdGljSGFuZGxlcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgY2Fubm90ICVzIHdpdGggPFN0YXRpY1JvdXRlcj5cIiwgbWV0aG9kTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4vKipcbiAqIFRoZSBwdWJsaWMgdG9wLWxldmVsIEFQSSBmb3IgYSBcInN0YXRpY1wiIDxSb3V0ZXI+LCBzby1jYWxsZWQgYmVjYXVzZSBpdFxuICogY2FuJ3QgYWN0dWFsbHkgY2hhbmdlIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBJbnN0ZWFkLCBpdCBqdXN0IHJlY29yZHNcbiAqIGxvY2F0aW9uIGNoYW5nZXMgaW4gYSBjb250ZXh0IG9iamVjdC4gVXNlZnVsIG1haW5seSBpbiB0ZXN0aW5nIGFuZFxuICogc2VydmVyLXJlbmRlcmluZyBzY2VuYXJpb3MuXG4gKi9cblxuXG52YXIgU3RhdGljUm91dGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFN0YXRpY1JvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3RhdGljUm91dGVyKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuaGFuZGxlUHVzaCA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIF90aGlzLm5hdmlnYXRlVG8obG9jYXRpb24sIFwiUFVTSFwiKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlUmVwbGFjZSA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIF90aGlzLm5hdmlnYXRlVG8obG9jYXRpb24sIFwiUkVQTEFDRVwiKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdGF0aWNSb3V0ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5uYXZpZ2F0ZVRvID0gZnVuY3Rpb24gbmF2aWdhdGVUbyhsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgX3RoaXMkcHJvcHMkYmFzZW5hbWUgPSBfdGhpcyRwcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wcyRiYXNlbmFtZSA9PT0gdm9pZCAwID8gXCJcIiA6IF90aGlzJHByb3BzJGJhc2VuYW1lLFxuICAgICAgICBfdGhpcyRwcm9wcyRjb250ZXh0ID0gX3RoaXMkcHJvcHMuY29udGV4dCxcbiAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzJGNvbnRleHQgPT09IHZvaWQgMCA/IHt9IDogX3RoaXMkcHJvcHMkY29udGV4dDtcbiAgICBjb250ZXh0LmFjdGlvbiA9IGFjdGlvbjtcbiAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgX3RoaXMkcHJvcHMyJGJhc2VuYW1lID0gX3RoaXMkcHJvcHMyLmJhc2VuYW1lLFxuICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzMiRiYXNlbmFtZSA9PT0gdm9pZCAwID8gXCJcIiA6IF90aGlzJHByb3BzMiRiYXNlbmFtZSxcbiAgICAgICAgX3RoaXMkcHJvcHMyJGNvbnRleHQgPSBfdGhpcyRwcm9wczIuY29udGV4dCxcbiAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzMiRjb250ZXh0ID09PSB2b2lkIDAgPyB7fSA6IF90aGlzJHByb3BzMiRjb250ZXh0LFxuICAgICAgICBfdGhpcyRwcm9wczIkbG9jYXRpb24gPSBfdGhpcyRwcm9wczIubG9jYXRpb24sXG4gICAgICAgIGxvY2F0aW9uID0gX3RoaXMkcHJvcHMyJGxvY2F0aW9uID09PSB2b2lkIDAgPyBcIi9cIiA6IF90aGlzJHByb3BzMiRsb2NhdGlvbixcbiAgICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzMiwgW1wiYmFzZW5hbWVcIiwgXCJjb250ZXh0XCIsIFwibG9jYXRpb25cIl0pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB7XG4gICAgICBjcmVhdGVIcmVmOiBmdW5jdGlvbiBjcmVhdGVIcmVmKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSArIGNyZWF0ZVVSTChwYXRoKSk7XG4gICAgICB9LFxuICAgICAgYWN0aW9uOiBcIlBPUFwiLFxuICAgICAgbG9jYXRpb246IHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSksXG4gICAgICBwdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICByZXBsYWNlOiB0aGlzLmhhbmRsZVJlcGxhY2UsXG4gICAgICBnbzogc3RhdGljSGFuZGxlcihcImdvXCIpLFxuICAgICAgZ29CYWNrOiBzdGF0aWNIYW5kbGVyKFwiZ29CYWNrXCIpLFxuICAgICAgZ29Gb3J3YXJkOiBzdGF0aWNIYW5kbGVyKFwiZ29Gb3J3YXJkXCIpLFxuICAgICAgbGlzdGVuOiB0aGlzLmhhbmRsZUxpc3RlbixcbiAgICAgIGJsb2NrOiB0aGlzLmhhbmRsZUJsb2NrXG4gICAgfTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBoaXN0b3J5OiBoaXN0b3J5LFxuICAgICAgc3RhdGljQ29udGV4dDogY29udGV4dFxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gU3RhdGljUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIFN0YXRpY1JvdXRlci5wcm9wVHlwZXMgPSB7XG4gICAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY29udGV4dDogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBsb2NhdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksIFwiPFN0YXRpY1JvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgXCIgKyBcInVzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IFN0YXRpY1JvdXRlciBhcyBSb3V0ZXIgfWAuXCIpIDogdm9pZCAwO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN3aXRjaC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICFjb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBzaG91bGQgbm90IHVzZSA8U3dpdGNoPiBvdXRzaWRlIGEgPFJvdXRlcj5cIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgdmFyIGxvY2F0aW9uID0gX3RoaXMucHJvcHMubG9jYXRpb24gfHwgY29udGV4dC5sb2NhdGlvbjtcbiAgICAgIHZhciBlbGVtZW50LCBtYXRjaDsgLy8gV2UgdXNlIFJlYWN0LkNoaWxkcmVuLmZvckVhY2ggaW5zdGVhZCBvZiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KCkuZmluZCgpXG4gICAgICAvLyBoZXJlIGJlY2F1c2UgdG9BcnJheSBhZGRzIGtleXMgdG8gYWxsIGNoaWxkIGVsZW1lbnRzIGFuZCB3ZSBkbyBub3Qgd2FudFxuICAgICAgLy8gdG8gdHJpZ2dlciBhbiB1bm1vdW50L3JlbW91bnQgZm9yIHR3byA8Um91dGU+cyB0aGF0IHJlbmRlciB0aGUgc2FtZVxuICAgICAgLy8gY29tcG9uZW50IGF0IGRpZmZlcmVudCBVUkxzLlxuXG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKF90aGlzLnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwgJiYgUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgZWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgIHZhciBwYXRoID0gY2hpbGQucHJvcHMucGF0aCB8fCBjaGlsZC5wcm9wcy5mcm9tO1xuICAgICAgICAgIG1hdGNoID0gcGF0aCA/IG1hdGNoUGF0aChsb2NhdGlvbi5wYXRobmFtZSwgX2V4dGVuZHMoe30sIGNoaWxkLnByb3BzLCB7XG4gICAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgICAgfSkpIDogY29udGV4dC5tYXRjaDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBSZWFjdC5jbG9uZUVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGNvbXB1dGVkTWF0Y2g6IG1hdGNoXG4gICAgICB9KSA6IG51bGw7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBTd2l0Y2gucHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxuICB9O1xuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoISh0aGlzLnByb3BzLmxvY2F0aW9uICYmICFwcmV2UHJvcHMubG9jYXRpb24pLCAnPFN3aXRjaD4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKCEoIXRoaXMucHJvcHMubG9jYXRpb24gJiYgcHJldlByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHB1YmxpYyBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRvIGFjY2VzcyB0aGUgaW1wZXJhdGl2ZSBBUElcbiAqL1xuXG5mdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvbmVudCkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBcIndpdGhSb3V0ZXIoXCIgKyAoQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lKSArIFwiKVwiO1xuXG4gIHZhciBDID0gZnVuY3Rpb24gQyhwcm9wcykge1xuICAgIHZhciB3cmFwcGVkQ29tcG9uZW50UmVmID0gcHJvcHMud3JhcHBlZENvbXBvbmVudFJlZixcbiAgICAgICAgcmVtYWluaW5nUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgW1wid3JhcHBlZENvbXBvbmVudFJlZlwiXSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgIWNvbnRleHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IHNob3VsZCBub3QgdXNlIDxcIiArIGRpc3BsYXlOYW1lICsgXCIgLz4gb3V0c2lkZSBhIDxSb3V0ZXI+XCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHJlbWFpbmluZ1Byb3BzLCBjb250ZXh0LCB7XG4gICAgICAgIHJlZjogd3JhcHBlZENvbXBvbmVudFJlZlxuICAgICAgfSkpO1xuICAgIH0pO1xuICB9O1xuXG4gIEMuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgQy5XcmFwcGVkQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBDLnByb3BUeXBlcyA9IHtcbiAgICAgIHdyYXBwZWRDb21wb25lbnRSZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhvaXN0U3RhdGljcyhDLCBDb21wb25lbnQpO1xufVxuXG52YXIgdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQ7XG5mdW5jdGlvbiB1c2VIaXN0b3J5KCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgISh0eXBlb2YgdXNlQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCB1c2UgUmVhY3QgPj0gMTYuOCBpbiBvcmRlciB0byB1c2UgdXNlSGlzdG9yeSgpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiB1c2VDb250ZXh0KGNvbnRleHQpLmhpc3Rvcnk7XG59XG5mdW5jdGlvbiB1c2VMb2NhdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICEodHlwZW9mIHVzZUNvbnRleHQgPT09IFwiZnVuY3Rpb25cIikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgdXNlIFJlYWN0ID49IDE2LjggaW4gb3JkZXIgdG8gdXNlIHVzZUxvY2F0aW9uKClcIikgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICB9XG5cbiAgcmV0dXJuIHVzZUNvbnRleHQoY29udGV4dCkubG9jYXRpb247XG59XG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAhKHR5cGVvZiB1c2VDb250ZXh0ID09PSBcImZ1bmN0aW9uXCIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gaW52YXJpYW50KGZhbHNlLCBcIllvdSBtdXN0IHVzZSBSZWFjdCA+PSAxNi44IGluIG9yZGVyIHRvIHVzZSB1c2VQYXJhbXMoKVwiKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIH1cblxuICB2YXIgbWF0Y2ggPSB1c2VDb250ZXh0KGNvbnRleHQpLm1hdGNoO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5wYXJhbXMgOiB7fTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlTWF0Y2gocGF0aCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgISh0eXBlb2YgdXNlQ29udGV4dCA9PT0gXCJmdW5jdGlvblwiKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCB1c2UgUmVhY3QgPj0gMTYuOCBpbiBvcmRlciB0byB1c2UgdXNlUm91dGVNYXRjaCgpXCIpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBwYXRoID8gbWF0Y2hQYXRoKHVzZUxvY2F0aW9uKCkucGF0aG5hbWUsIHBhdGgpIDogdXNlQ29udGV4dChjb250ZXh0KS5tYXRjaDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBnbG9iYWwgPSB3aW5kb3c7XG4gICAgdmFyIGtleSA9IFwiX19yZWFjdF9yb3V0ZXJfYnVpbGRfX1wiO1xuICAgIHZhciBidWlsZE5hbWVzID0ge1xuICAgICAgY2pzOiBcIkNvbW1vbkpTXCIsXG4gICAgICBlc206IFwiRVMgbW9kdWxlc1wiLFxuICAgICAgdW1kOiBcIlVNRFwiXG4gICAgfTtcblxuICAgIGlmIChnbG9iYWxba2V5XSAmJiBnbG9iYWxba2V5XSAhPT0gXCJlc21cIikge1xuICAgICAgdmFyIGluaXRpYWxCdWlsZE5hbWUgPSBidWlsZE5hbWVzW2dsb2JhbFtrZXldXTtcbiAgICAgIHZhciBzZWNvbmRhcnlCdWlsZE5hbWUgPSBidWlsZE5hbWVzW1wiZXNtXCJdOyAvLyBUT0RPOiBBZGQgbGluayB0byBhcnRpY2xlIHRoYXQgZXhwbGFpbnMgaW4gZGV0YWlsIGhvdyB0byBhdm9pZFxuICAgICAgLy8gbG9hZGluZyAyIGRpZmZlcmVudCBidWlsZHMuXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgbG9hZGluZyB0aGUgXCIgKyBzZWNvbmRhcnlCdWlsZE5hbWUgKyBcIiBidWlsZCBvZiBSZWFjdCBSb3V0ZXIgXCIgKyAoXCJvbiBhIHBhZ2UgdGhhdCBpcyBhbHJlYWR5IHJ1bm5pbmcgdGhlIFwiICsgaW5pdGlhbEJ1aWxkTmFtZSArIFwiIFwiKSArIFwiYnVpbGQsIHNvIHRoaW5ncyB3b24ndCB3b3JrIHJpZ2h0LlwiKTtcbiAgICB9XG5cbiAgICBnbG9iYWxba2V5XSA9IFwiZXNtXCI7XG4gIH1cbn1cblxuZXhwb3J0IHsgTWVtb3J5Um91dGVyLCBQcm9tcHQsIFJlZGlyZWN0LCBSb3V0ZSwgUm91dGVyLCBTdGF0aWNSb3V0ZXIsIFN3aXRjaCwgY29udGV4dCBhcyBfX1JvdXRlckNvbnRleHQsIGdlbmVyYXRlUGF0aCwgbWF0Y2hQYXRoLCB1c2VIaXN0b3J5LCB1c2VMb2NhdGlvbiwgdXNlUGFyYW1zLCB1c2VSb3V0ZU1hdGNoLCB3aXRoUm91dGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yb3V0ZXIuanMubWFwXG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjExLjBcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4xMS4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG5cbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMgd2l0aFxuLy8gdGVtcGxhdGUgbGl0ZXJhbCBzdHJpbmdzLiBUaGUgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4vLyBkdXJpbmcgYnVpbGQuXG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHZvaWQgMCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2skMSA9IGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjaztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cbnZhciB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgd2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZ1dpdGhvdXRTdGFjayhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPiA4KSB7XG4gICAgICAvLyBDaGVjayBiZWZvcmUgdGhlIGNvbmRpdGlvbiB0byBjYXRjaCB2aW9sYXRpb25zIGVhcmx5LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YXJuaW5nV2l0aG91dFN0YWNrKCkgY3VycmVudGx5IHN1cHBvcnRzIGF0IG1vc3QgOCBhcmd1bWVudHMuJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgICB9KTtcbiAgICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmVycm9yLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxudmFyIHdhcm5pbmdXaXRob3V0U3RhY2skMSA9IHdhcm5pbmdXaXRob3V0U3RhY2s7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBfY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IF9jb25zdHJ1Y3RvciAmJiAoX2NvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IF9jb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgXCIuXCIgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG5cblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuXG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0OyAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cblxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICBpZiAoISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGRpc3BhdGNoZXIuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgYmF0Y2gncyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgaG93IGxvbmcgYW4gdXBkYXRlXG4gKiBzaG91bGQgc3VzcGVuZCBmb3IgaWYgaXQgbmVlZHMgdG8uXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IHtcbiAgc3VzcGVuc2U6IG51bGxcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIEJFRk9SRV9TTEFTSF9SRSA9IC9eKC4qKVtcXFxcXFwvXS87XG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICB2YXIgc291cmNlSW5mbyA9ICcnO1xuXG4gIGlmIChzb3VyY2UpIHtcbiAgICB2YXIgcGF0aCA9IHNvdXJjZS5maWxlTmFtZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBwYXRoLnJlcGxhY2UoQkVGT1JFX1NMQVNIX1JFLCAnJyk7XG5cbiAgICB7XG4gICAgICAvLyBJbiBERVYsIGluY2x1ZGUgY29kZSBmb3IgYSBjb21tb24gc3BlY2lhbCBjYXNlOlxuICAgICAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgICAgIGlmICgvXmluZGV4XFwuLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdmFyIHBhdGhCZWZvcmVTbGFzaCA9IG1hdGNoWzFdO1xuXG4gICAgICAgICAgaWYgKHBhdGhCZWZvcmVTbGFzaCkge1xuICAgICAgICAgICAgdmFyIGZvbGRlck5hbWUgPSBwYXRoQmVmb3JlU2xhc2gucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICAgICAgICAgIGZpbGVOYW1lID0gZm9sZGVyTmFtZSArICcvJyArIGZpbGVOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNvdXJjZUluZm8gPSAnIChhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJztcbiAgfSBlbHNlIGlmIChvd25lck5hbWUpIHtcbiAgICBzb3VyY2VJbmZvID0gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknO1xuICB9XG5cbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyBzb3VyY2VJbmZvO1xufTtcblxudmFyIFJlc29sdmVkID0gMTtcblxuZnVuY3Rpb24gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KGxhenlDb21wb25lbnQpIHtcbiAgcmV0dXJuIGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQgPyBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICByZXR1cm4gJ0NvbnRleHQuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdGhlbmFibGUgPSB0eXBlO1xuICAgICAgICAgIHZhciByZXNvbHZlZFRoZW5hYmxlID0gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KHRoZW5hYmxlKTtcblxuICAgICAgICAgIGlmIChyZXNvbHZlZFRoZW5hYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShyZXNvbHZlZFRoZW5hYmxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xudmFyIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgfVxufVxuXG57XG4gIC8vIFN0YWNrIGltcGxlbWVudGF0aW9uIGluamVjdGVkIGJ5IHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC50eXBlKTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSk7XG4gICAgfSAvLyBEZWxlZ2F0ZSB0byB0aGUgaW5qZWN0ZWQgcmVuZGVyZXItc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cblxuXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcblxuICAgIGlmIChpbXBsKSB7XG4gICAgICBzdGFjayArPSBpbXBsKCkgfHwgJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xufVxuXG4vKipcbiAqIFVzZWQgYnkgYWN0KCkgdG8gdHJhY2sgd2hldGhlciB5b3UncmUgaW5zaWRlIGFuIGFjdCgpIHNjb3BlLlxuICovXG52YXIgSXNTb21lUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnOiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyxcbiAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICBJc1NvbWVSZW5kZXJlckFjdGluZzogSXNTb21lUmVuZGVyZXJBY3RpbmcsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBfYXNzaWduKFJlYWN0U2hhcmVkSW50ZXJuYWxzLCB7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBwcm9kdWN0aW9uLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWU6IFJlYWN0RGVidWdDdXJyZW50RnJhbWUsXG4gICAgLy8gU2hpbSBmb3IgUmVhY3QgRE9NIDE2LjAuMCB3aGljaCBzdGlsbCBkZXN0cnVjdHVyZWQgKGJ1dCBub3QgdXNlZCkgdGhpcy5cbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuMC5cbiAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rOiB7fVxuICB9KTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSB3YXJuaW5nV2l0aG91dFN0YWNrJDE7XG5cbntcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC93YXJuaW5nLWFuZC1pbnZhcmlhbnQtYXJnc1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxLmFwcGx5KHZvaWQgMCwgW2ZhbHNlLCBmb3JtYXQgKyAnJXMnXS5jb25jYXQoYXJncywgW3N0YWNrXSkpO1xuICB9O1xufVxuXG52YXIgd2FybmluZyQxID0gd2FybmluZztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gIH1cblxuICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgfVxuXG4gIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgcmVmID0gY29uZmlnLnJlZjtcbiAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgfVxuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSB8fCByZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgIH1cblxuICAgIGlmIChyZWYpIHtcbiAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKFwiUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5cbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuXG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5cblxuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgdmFyIGludm9rZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLCAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgIWRpZFdhcm5BYm91dE1hcHMgPyB3YXJuaW5nJDEoZmFsc2UsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuXCIgKyBhZGRlbmR1bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5cblxuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudCAhPT0gbnVsbCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5cblxuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCwgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG5cbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG5cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgbnVsbCk7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbnRvYXJyYXlcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgaWYgKGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWxjdWxhdGVDaGFuZ2VkQml0cyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgIShjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnY3JlYXRlQ29udGV4dDogRXhwZWN0ZWQgdGhlIG9wdGlvbmFsIHNlY29uZCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjYWxjdWxhdGVDaGFuZ2VkQml0cyxcbiAgICAvLyBBcyBhIHdvcmthcm91bmQgdG8gc3VwcG9ydCBtdWx0aXBsZSBjb25jdXJyZW50IHJlbmRlcmVycywgd2UgY2F0ZWdvcml6ZVxuICAgIC8vIHNvbWUgcmVuZGVyZXJzIGFzIHByaW1hcnkgYW5kIG90aGVycyBhcyBzZWNvbmRhcnkuIFdlIG9ubHkgZXhwZWN0XG4gICAgLy8gdGhlcmUgdG8gYmUgdHdvIGNvbmN1cnJlbnQgcmVuZGVyZXJzIGF0IG1vc3Q6IFJlYWN0IE5hdGl2ZSAocHJpbWFyeSkgYW5kXG4gICAgLy8gRmFicmljIChzZWNvbmRhcnkpOyBSZWFjdCBET00gKHByaW1hcnkpIGFuZCBSZWFjdCBBUlQgKHNlY29uZGFyeSkuXG4gICAgLy8gU2Vjb25kYXJ5IHJlbmRlcmVycyBzdG9yZSB0aGVpciBjb250ZXh0IHZhbHVlcyBvbiBzZXBhcmF0ZSBmaWVsZHMuXG4gICAgX2N1cnJlbnRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuICAgIF9jdXJyZW50VmFsdWUyOiBkZWZhdWx0VmFsdWUsXG4gICAgLy8gVXNlZCB0byB0cmFjayBob3cgbWFueSBjb25jdXJyZW50IHJlbmRlcmVycyB0aGlzIGNvbnRleHQgY3VycmVudGx5XG4gICAgLy8gc3VwcG9ydHMgd2l0aGluIGluIGEgc2luZ2xlIHJlbmRlcmVyLiBTdWNoIGFzIHBhcmFsbGVsIHNlcnZlciByZW5kZXJpbmcuXG4gICAgX3RocmVhZENvdW50OiAwLFxuICAgIC8vIFRoZXNlIGFyZSBjaXJjdWxhclxuICAgIFByb3ZpZGVyOiBudWxsLFxuICAgIENvbnN1bWVyOiBudWxsXG4gIH07XG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX2N0b3I6IGN0b3IsXG4gICAgLy8gUmVhY3QgdXNlcyB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBudWxsXG4gIH07XG5cbiAge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQganVzdCBzZXQgaXQgb24gdGhlIG9iamVjdC5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIHZhciBwcm9wVHlwZXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QubGF6eSguLi4pOiBJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIGFzc2lnbiBgcHJvcFR5cGVzYCB0byAnICsgJ2EgbGF6eSBjb21wb25lbnQgaW1wb3J0LiBFaXRoZXIgc3BlY2lmeSB0aGVtIHdoZXJlIHRoZSBjb21wb25lbnQgJyArICdpcyBkZWZpbmVkLCBvciBjcmVhdGUgYSB3cmFwcGluZyBjb21wb25lbnQgYXJvdW5kIGl0LicpO1xuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobGF6eVR5cGUsICdwcm9wVHlwZXMnLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBsYXp5VHlwZTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlZihyZW5kZXIpIHtcbiAge1xuICAgIGlmIChyZW5kZXIgIT0gbnVsbCAmJiByZW5kZXIuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICEoIC8vIERvIG5vdCB3YXJuIGZvciAwIGFyZ3VtZW50cyBiZWNhdXNlIGl0IGNvdWxkIGJlIGR1ZSB0byB1c2FnZSBvZiB0aGUgJ2FyZ3VtZW50cycgb2JqZWN0XG4gICAgICByZW5kZXIubGVuZ3RoID09PSAwIHx8IHJlbmRlci5sZW5ndGggPT09IDIpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGFjY2VwdCBleGFjdGx5IHR3byBwYXJhbWV0ZXJzOiBwcm9wcyBhbmQgcmVmLiAlcycsIHJlbmRlci5sZW5ndGggPT09IDEgPyAnRGlkIHlvdSBmb3JnZXQgdG8gdXNlIHRoZSByZWYgcGFyYW1ldGVyPycgOiAnQW55IGFkZGl0aW9uYWwgcGFyYW1ldGVyIHdpbGwgYmUgdW5kZWZpbmVkLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXIgIT0gbnVsbCkge1xuICAgICAgIShyZW5kZXIuZGVmYXVsdFByb3BzID09IG51bGwgJiYgcmVuZGVyLnByb3BUeXBlcyA9PSBudWxsKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBkbyBub3Qgc3VwcG9ydCBwcm9wVHlwZXMgb3IgZGVmYXVsdFByb3BzLiAnICsgJ0RpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSBSZWFjdCBjb21wb25lbnQ/JykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFKTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEaXNwYXRjaGVyKCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDtcblxuICBpZiAoIShkaXNwYXRjaGVyICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLlwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICAhKHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkKSA/IHdhcm5pbmckMShmYWxzZSwgJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vZmIubWUvcnVsZXMtb2YtaG9va3MnIDogJycpIDogdm9pZCAwOyAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0NhbGxpbmcgdXNlQ29udGV4dChDb250ZXh0LlByb3ZpZGVyKSBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHVzZUNvbnRleHQoQ29udGV4dCkgaW5zdGVhZD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cyk7XG59XG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VTdGF0ZShpbml0aWFsU3RhdGUpO1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cbmZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWYoaW5pdGlhbFZhbHVlKTtcbn1cbmZ1bmN0aW9uIHVzZUVmZmVjdChjcmVhdGUsIGlucHV0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGlucHV0cyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGlucHV0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBpbnB1dHMpO1xufVxuZnVuY3Rpb24gdXNlTWVtbyhjcmVhdGUsIGlucHV0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBpbnB1dHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgaW5wdXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgaW5wdXRzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG52YXIgZW1wdHlPYmplY3QkMSA9IHt9O1xuZnVuY3Rpb24gdXNlUmVzcG9uZGVyKHJlc3BvbmRlciwgbGlzdGVuZXJQcm9wcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmIChyZXNwb25kZXIgPT0gbnVsbCB8fCByZXNwb25kZXIuJCR0eXBlb2YgIT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICd1c2VSZXNwb25kZXI6IGludmFsaWQgZmlyc3QgYXJndW1lbnQuIEV4cGVjdGVkIGFuIGV2ZW50IHJlc3BvbmRlciwgYnV0IGluc3RlYWQgZ290ICVzJywgcmVzcG9uZGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZXNwb25kZXIocmVzcG9uZGVyLCBsaXN0ZW5lclByb3BzIHx8IGVtcHR5T2JqZWN0JDEpO1xufVxuZnVuY3Rpb24gdXNlVHJhbnNpdGlvbihjb25maWcpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VUcmFuc2l0aW9uKGNvbmZpZyk7XG59XG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBjb25maWcpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWZlcnJlZFZhbHVlKHZhbHVlLCBjb25maWcpO1xufVxuXG5mdW5jdGlvbiB3aXRoU3VzcGVuc2VDb25maWcoc2NvcGUsIGNvbmZpZykge1xuICB2YXIgcHJldmlvdXNDb25maWcgPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy5zdXNwZW5zZTtcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcuc3VzcGVuc2UgPSBjb25maWcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWc7XG5cbiAgdHJ5IHtcbiAgICBzY29wZSgpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLnN1c3BlbnNlID0gcHJldmlvdXNDb25maWc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG4gIH1cblxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICB2YXIgcHJvcFR5cGVzO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BUeXBlcykge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0pO1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChmcmFnbWVudCk7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuICB9XG5cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QuanN4OiBTcHJlYWRpbmcgYSBrZXkgdG8gSlNYIGlzIGEgZGVwcmVjYXRlZCBwYXR0ZXJuLiAnICsgJ0V4cGxpY2l0bHkgcGFzcyBhIGtleSBhZnRlciBzcHJlYWRpbmcgcHJvcHMgaW4geW91ciBKU1ggY2FsbC4gJyArICdFLmcuIDxDb21wb25lbnROYW1lIHsuLi5wcm9wc30ga2V5PXtrZXl9IC8+Jyk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcbi8vIGV2ZW4gd2l0aCB0aGUgcHJvZCB0cmFuc2Zvcm0uIFRoaXMgbWVhbnMgdGhhdCBqc3hERVYgaXMgcHVyZWx5XG4vLyBvcHQtaW4gYmVoYXZpb3IgZm9yIGJldHRlciBtZXNzYWdlcyBidXQgdGhhdCB3ZSB3b24ndCBzdG9wXG4vLyBnaXZpbmcgeW91IHdhcm5pbmdzIGlmIHlvdSB1c2UgcHJvZHVjdGlvbiBhcGlzLlxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyh0eXBlLCBwcm9wcywga2V5KSB7XG4gIHJldHVybiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBmYWxzZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlOyAvLyBMZWdhY3kgaG9vazogcmVtb3ZlIGl0XG5cbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuXG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgdmFyIHRlc3RNYXAgPSBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIHZhciB0ZXN0U2V0ID0gbmV3IFNldChbZnJvemVuT2JqZWN0XSk7IC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBSb2xsdXAgdG8gbm90IGNvbnNpZGVyIHRoZXNlIHVudXNlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cC9pc3N1ZXMvMTc3MVxuICAgIC8vIFRPRE86IHdlIGNhbiByZW1vdmUgdGhlc2UgaWYgUm9sbHVwIGZpeGVzIHRoZSBidWcuXG5cbiAgICB0ZXN0TWFwLnNldCgwLCAwKTtcbiAgICB0ZXN0U2V0LmFkZCgwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5kYW1lbnRhbENvbXBvbmVudChpbXBsKSB7XG4gIC8vIFdlIHVzZSByZXNwb25kZXIgYXMgYSBNYXAga2V5IGxhdGVyIG9uLiBXaGVuIHdlIGhhdmUgYSBiYWRcbiAgLy8gcG9seWZpbGwsIHRoZW4gd2UgY2FuJ3QgdXNlIGl0IGFzIGEga2V5IGFzIHRoZSBwb2x5ZmlsbCB0cmllc1xuICAvLyB0byBhZGQgYSBwcm9wZXJ0eSB0byB0aGUgb2JqZWN0LlxuICBpZiAodHJ1ZSAmJiAhaGFzQmFkTWFwUG9seWZpbGwpIHtcbiAgICBPYmplY3QuZnJlZXplKGltcGwpO1xuICB9XG5cbiAgdmFyIGZ1bmRhbWFudGFsQ29tcG9uZW50ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFLFxuICAgIGltcGw6IGltcGxcbiAgfTtcblxuICB7XG4gICAgT2JqZWN0LmZyZWV6ZShmdW5kYW1hbnRhbENvbXBvbmVudCk7XG4gIH1cblxuICByZXR1cm4gZnVuZGFtYW50YWxDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50UmVzcG9uZGVyKGRpc3BsYXlOYW1lLCByZXNwb25kZXJDb25maWcpIHtcbiAgdmFyIGdldEluaXRpYWxTdGF0ZSA9IHJlc3BvbmRlckNvbmZpZy5nZXRJbml0aWFsU3RhdGUsXG4gICAgICBvbkV2ZW50ID0gcmVzcG9uZGVyQ29uZmlnLm9uRXZlbnQsXG4gICAgICBvbk1vdW50ID0gcmVzcG9uZGVyQ29uZmlnLm9uTW91bnQsXG4gICAgICBvblVubW91bnQgPSByZXNwb25kZXJDb25maWcub25Vbm1vdW50LFxuICAgICAgb25Sb290RXZlbnQgPSByZXNwb25kZXJDb25maWcub25Sb290RXZlbnQsXG4gICAgICByb290RXZlbnRUeXBlcyA9IHJlc3BvbmRlckNvbmZpZy5yb290RXZlbnRUeXBlcyxcbiAgICAgIHRhcmdldEV2ZW50VHlwZXMgPSByZXNwb25kZXJDb25maWcudGFyZ2V0RXZlbnRUeXBlcyxcbiAgICAgIHRhcmdldFBvcnRhbFByb3BhZ2F0aW9uID0gcmVzcG9uZGVyQ29uZmlnLnRhcmdldFBvcnRhbFByb3BhZ2F0aW9uO1xuICB2YXIgZXZlbnRSZXNwb25kZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1JFU1BPTkRFUl9UWVBFLFxuICAgIGRpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSxcbiAgICBnZXRJbml0aWFsU3RhdGU6IGdldEluaXRpYWxTdGF0ZSB8fCBudWxsLFxuICAgIG9uRXZlbnQ6IG9uRXZlbnQgfHwgbnVsbCxcbiAgICBvbk1vdW50OiBvbk1vdW50IHx8IG51bGwsXG4gICAgb25Sb290RXZlbnQ6IG9uUm9vdEV2ZW50IHx8IG51bGwsXG4gICAgb25Vbm1vdW50OiBvblVubW91bnQgfHwgbnVsbCxcbiAgICByb290RXZlbnRUeXBlczogcm9vdEV2ZW50VHlwZXMgfHwgbnVsbCxcbiAgICB0YXJnZXRFdmVudFR5cGVzOiB0YXJnZXRFdmVudFR5cGVzIHx8IG51bGwsXG4gICAgdGFyZ2V0UG9ydGFsUHJvcGFnYXRpb246IHRhcmdldFBvcnRhbFByb3BhZ2F0aW9uIHx8IGZhbHNlXG4gIH07IC8vIFdlIHVzZSByZXNwb25kZXIgYXMgYSBNYXAga2V5IGxhdGVyIG9uLiBXaGVuIHdlIGhhdmUgYSBiYWRcbiAgLy8gcG9seWZpbGwsIHRoZW4gd2UgY2FuJ3QgdXNlIGl0IGFzIGEga2V5IGFzIHRoZSBwb2x5ZmlsbCB0cmllc1xuICAvLyB0byBhZGQgYSBwcm9wZXJ0eSB0byB0aGUgb2JqZWN0LlxuXG4gIGlmICh0cnVlICYmICFoYXNCYWRNYXBQb2x5ZmlsbCkge1xuICAgIE9iamVjdC5mcmVlemUoZXZlbnRSZXNwb25kZXIpO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50UmVzcG9uZGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY29wZSgpIHtcbiAgdmFyIHNjb3BlQ29tcG9uZW50ID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9TQ09QRV9UWVBFXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5mcmVlemUoc2NvcGVDb21wb25lbnQpO1xuICB9XG5cbiAgcmV0dXJuIHNjb3BlQ29tcG9uZW50O1xufVxuXG4vLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gYmVnaW4tcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZSByZWR1Y2VyczpcblxuIC8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG4gLy8gVG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgZGVidWdnZXIsIHdlXG4vLyByZXBsYXkgdGhlIGJlZ2luIHBoYXNlIG9mIGEgZmFpbGVkIGNvbXBvbmVudCBpbnNpZGUgaW52b2tlR3VhcmRlZENhbGxiYWNrLlxuXG4gLy8gV2FybiBhYm91dCBkZXByZWNhdGVkLCBhc3luYy11bnNhZmUgbGlmZWN5Y2xlczsgcmVsYXRlcyB0byBSRkMgIzY6XG5cbiAvLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuXG4gLy8gVHJhY2Ugd2hpY2ggaW50ZXJhY3Rpb25zIHRyaWdnZXIgZWFjaCBjb21taXQuXG5cbiAvLyBTU1IgZXhwZXJpbWVudHNcblxuXG4gLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbiAvLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuIC8vIERpc2FibGUgamF2YXNjcmlwdDogVVJMIHN0cmluZ3MgaW4gaHJlZiBmb3IgWFNTIHByb3RlY3Rpb24uXG5cbiAvLyBSZWFjdCBGaXJlOiBwcmV2ZW50IHRoZSB2YWx1ZSBhbmQgY2hlY2tlZCBhdHRyaWJ1dGVzIGZyb20gc3luY2luZ1xuLy8gd2l0aCB0aGVpciByZWxhdGVkIERPTSBwcm9wZXJ0aWVzXG5cbiAvLyBUaGVzZSBBUElzIHdpbGwgbm8gbG9uZ2VyIGJlIFwidW5zdGFibGVcIiBpbiB0aGUgdXBjb21pbmcgMTYuNyByZWxlYXNlLFxuLy8gQ29udHJvbCB0aGlzIGJlaGF2aW9yIHdpdGggYSBmbGFnIHRvIHN1cHBvcnQgMTYuNiBtaW5vciByZWxlYXNlcyBpbiB0aGUgbWVhbndoaWxlLlxuXG52YXIgZXhwb3NlQ29uY3VycmVudE1vZGVBUElzID0gZmFsc2U7XG4gLy8gRXhwZXJpbWVudGFsIFJlYWN0IEZsYXJlIGV2ZW50IHN5c3RlbSBhbmQgZXZlbnQgY29tcG9uZW50cyBzdXBwb3J0LlxuXG52YXIgZW5hYmxlRmxhcmVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIEhvc3QgQ29tcG9uZW50IHN1cHBvcnQuXG5cbnZhciBlbmFibGVGdW5kYW1lbnRhbEFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgU2NvcGUgc3VwcG9ydC5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIE5ldyBBUEkgZm9yIEpTWCB0cmFuc2Zvcm1zIHRvIHRhcmdldCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcblxudmFyIGVuYWJsZUpTWFRyYW5zZm9ybUFQSSA9IGZhbHNlOyAvLyBXZSB3aWxsIGVuZm9yY2UgbW9ja2luZyBzY2hlZHVsZXIgd2l0aCBzY2hlZHVsZXIvdW5zdGFibGVfbW9jayBhdCBzb21lIHBvaW50LiAodjE3Pylcbi8vIFRpbGwgdGhlbiwgd2Ugd2FybiBhYm91dCB0aGUgbWlzc2luZyBtb2NrLCBidXQgc3RpbGwgZmFsbGJhY2sgdG8gYSBzeW5jIG1vZGUgY29tcGF0aWJsZSB2ZXJzaW9uXG5cbiAvLyBGb3IgdGVzdHMsIHdlIGZsdXNoIHN1c3BlbnNlIGZhbGxiYWNrcyBpbiBhbiBhY3Qgc2NvcGU7XG4vLyAqZXhjZXB0KiBpbiBzb21lIG9mIG91ciBvd24gdGVzdHMsIHdoZXJlIHdlIHRlc3QgaW5jcmVtZW50YWwgbG9hZGluZyBzdGF0ZXMuXG5cbiAvLyBBZGQgYSBjYWxsYmFjayBwcm9wZXJ0eSB0byBzdXNwZW5zZSB0byBub3RpZnkgd2hpY2ggcHJvbWlzZXMgYXJlIGN1cnJlbnRseVxuLy8gaW4gdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBhbGxvd3MgcmVwb3J0aW5nIGFuZCB0cmFjaW5nIG9mIHdoYXQgaXMgY2F1c2luZ1xuLy8gdGhlIHVzZXIgdG8gc2VlIGEgbG9hZGluZyBzdGF0ZS5cbi8vIEFsc28gYWxsb3dzIGh5ZHJhdGlvbiBjYWxsYmFja3MgdG8gZmlyZSB3aGVuIGEgZGVoeWRyYXRlZCBib3VuZGFyeSBnZXRzXG4vLyBoeWRyYXRlZCBvciBkZWxldGVkLlxuXG4gLy8gUGFydCBvZiB0aGUgc2ltcGxpZmljYXRpb24gb2YgUmVhY3QuY3JlYXRlRWxlbWVudCBzbyB3ZSBjYW4gZXZlbnR1YWxseSBtb3ZlXG4vLyBmcm9tIFJlYWN0LmNyZWF0ZUVsZW1lbnQgdG8gUmVhY3QuanN4XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL2Jsb2IvY3JlYXRlbGVtZW50LXJmYy90ZXh0LzAwMDAtY3JlYXRlLWVsZW1lbnQtY2hhbmdlcy5tZFxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcbiAgY3JlYXRlUmVmOiBjcmVhdGVSZWYsXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuICBjcmVhdGVDb250ZXh0OiBjcmVhdGVDb250ZXh0LFxuICBmb3J3YXJkUmVmOiBmb3J3YXJkUmVmLFxuICBsYXp5OiBsYXp5LFxuICBtZW1vOiBtZW1vLFxuICB1c2VDYWxsYmFjazogdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQ6IHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdDogdXNlRWZmZWN0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB1c2VJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VEZWJ1Z1ZhbHVlOiB1c2VEZWJ1Z1ZhbHVlLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVzZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG4gIFByb2ZpbGVyOiBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuICBTdHJpY3RNb2RlOiBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICBTdXNwZW5zZTogUkVBQ1RfU1VTUEVOU0VfVFlQRSxcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24sXG4gIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDogUmVhY3RTaGFyZWRJbnRlcm5hbHNcbn07XG5cbmlmIChleHBvc2VDb25jdXJyZW50TW9kZUFQSXMpIHtcbiAgUmVhY3QudXNlVHJhbnNpdGlvbiA9IHVzZVRyYW5zaXRpb247XG4gIFJlYWN0LnVzZURlZmVycmVkVmFsdWUgPSB1c2VEZWZlcnJlZFZhbHVlO1xuICBSZWFjdC5TdXNwZW5zZUxpc3QgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIFJlYWN0LnVuc3RhYmxlX3dpdGhTdXNwZW5zZUNvbmZpZyA9IHdpdGhTdXNwZW5zZUNvbmZpZztcbn1cblxuaWYgKGVuYWJsZUZsYXJlQVBJKSB7XG4gIFJlYWN0LnVuc3RhYmxlX3VzZVJlc3BvbmRlciA9IHVzZVJlc3BvbmRlcjtcbiAgUmVhY3QudW5zdGFibGVfY3JlYXRlUmVzcG9uZGVyID0gY3JlYXRlRXZlbnRSZXNwb25kZXI7XG59XG5cbmlmIChlbmFibGVGdW5kYW1lbnRhbEFQSSkge1xuICBSZWFjdC51bnN0YWJsZV9jcmVhdGVGdW5kYW1lbnRhbCA9IGNyZWF0ZUZ1bmRhbWVudGFsQ29tcG9uZW50O1xufVxuXG5pZiAoZW5hYmxlU2NvcGVBUEkpIHtcbiAgUmVhY3QudW5zdGFibGVfY3JlYXRlU2NvcGUgPSBjcmVhdGVTY29wZTtcbn0gLy8gTm90ZTogc29tZSBBUElzIGFyZSBhZGRlZCB3aXRoIGZlYXR1cmUgZmxhZ3MuXG4vLyBNYWtlIHN1cmUgdGhhdCBzdGFibGUgYnVpbGRzIGZvciBvcGVuIHNvdXJjZVxuLy8gZG9uJ3QgbW9kaWZ5IHRoZSBSZWFjdCBvYmplY3QgdG8gYXZvaWQgZGVvcHRzLlxuLy8gQWxzbyBsZXQncyBub3QgZXhwb3NlIHRoZWlyIG5hbWVzIGluIHN0YWJsZSBidWlsZHMuXG5cblxuaWYgKGVuYWJsZUpTWFRyYW5zZm9ybUFQSSkge1xuICB7XG4gICAgUmVhY3QuanN4REVWID0ganN4V2l0aFZhbGlkYXRpb247XG4gICAgUmVhY3QuanN4ID0ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljO1xuICAgIFJlYWN0LmpzeHMgPSBqc3hXaXRoVmFsaWRhdGlvblN0YXRpYztcbiAgfVxufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxuXG5cbnZhciByZWFjdCA9IFJlYWN0JDMuZGVmYXVsdCB8fCBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGVbdG9TdHJpbmdUYWdTeW1ib2xdID1cbiAgICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBwcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGlmICghKHRvU3RyaW5nVGFnU3ltYm9sIGluIGdlbkZ1bikpIHtcbiAgICAgICAgZ2VuRnVuW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yRnVuY3Rpb25cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KVxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8sIGZyb20pIHtcbiAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkgZnJvbSA9ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gKHRvICYmIHRvLnNwbGl0KCcvJykpIHx8IFtdO1xuICB2YXIgZnJvbVBhcnRzID0gKGZyb20gJiYgZnJvbS5zcGxpdCgnLycpKSB8fCBbXTtcblxuICB2YXIgaXNUb0FicyA9IHRvICYmIGlzQWJzb2x1dGUodG8pO1xuICB2YXIgaXNGcm9tQWJzID0gZnJvbSAmJiBpc0Fic29sdXRlKGZyb20pO1xuICB2YXIgbXVzdEVuZEFicyA9IGlzVG9BYnMgfHwgaXNGcm9tQWJzO1xuXG4gIGlmICh0byAmJiBpc0Fic29sdXRlKHRvKSkge1xuICAgIC8vIHRvIGlzIGFic29sdXRlXG4gICAgZnJvbVBhcnRzID0gdG9QYXJ0cztcbiAgfSBlbHNlIGlmICh0b1BhcnRzLmxlbmd0aCkge1xuICAgIC8vIHRvIGlzIHJlbGF0aXZlLCBkcm9wIHRoZSBmaWxlbmFtZVxuICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICBmcm9tUGFydHMgPSBmcm9tUGFydHMuY29uY2F0KHRvUGFydHMpO1xuICB9XG5cbiAgaWYgKCFmcm9tUGFydHMubGVuZ3RoKSByZXR1cm4gJy8nO1xuXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoO1xuICBpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0ID0gZnJvbVBhcnRzW2Zyb21QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gbGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicgfHwgbGFzdCA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBmcm9tUGFydHNbaV07XG5cbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXN0RW5kQWJzKSBmb3IgKDsgdXAtLTsgdXApIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuXG4gIGlmIChcbiAgICBtdXN0RW5kQWJzICYmXG4gICAgZnJvbVBhcnRzWzBdICE9PSAnJyAmJlxuICAgICghZnJvbVBhcnRzWzBdIHx8ICFpc0Fic29sdXRlKGZyb21QYXJ0c1swXSkpXG4gIClcbiAgICBmcm9tUGFydHMudW5zaGlmdCgnJyk7XG5cbiAgdmFyIHJlc3VsdCA9IGZyb21QYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgcmVzdWx0LnN1YnN0cigtMSkgIT09ICcvJykgcmVzdWx0ICs9ICcvJztcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlUGF0aG5hbWU7XG4iLCJ2YXIgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbnZhciBwcmVmaXggPSAnSW52YXJpYW50IGZhaWxlZCc7XG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArIFwiOiBcIiArIChtZXNzYWdlIHx8ICcnKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaW52YXJpYW50O1xuIiwidmFyIGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG5mdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWlzUHJvZHVjdGlvbikge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IFwiV2FybmluZzogXCIgKyBtZXNzYWdlO1xuXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKHRleHQpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBFcnJvcih0ZXh0KTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdhcm5pbmc7XG4iLCJmdW5jdGlvbiB2YWx1ZU9mKG9iaikge1xuICByZXR1cm4gb2JqLnZhbHVlT2YgPyBvYmoudmFsdWVPZigpIDogT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mLmNhbGwob2JqKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVFcXVhbChhLCBiKSB7XG4gIC8vIFRlc3QgZm9yIHN0cmljdCBlcXVhbGl0eSBmaXJzdC5cbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIC8vIE90aGVyd2lzZSwgaWYgZWl0aGVyIG9mIHRoZW0gPT0gbnVsbCB0aGV5IGFyZSBub3QgZXF1YWwuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICByZXR1cm4gKFxuICAgICAgQXJyYXkuaXNBcnJheShiKSAmJlxuICAgICAgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmXG4gICAgICBhLmV2ZXJ5KGZ1bmN0aW9uKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGFWYWx1ZSA9IHZhbHVlT2YoYSk7XG4gICAgdmFyIGJWYWx1ZSA9IHZhbHVlT2YoYik7XG5cbiAgICBpZiAoYVZhbHVlICE9PSBhIHx8IGJWYWx1ZSAhPT0gYikgcmV0dXJuIHZhbHVlRXF1YWwoYVZhbHVlLCBiVmFsdWUpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIGEsIGIpKS5ldmVyeShmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZUVxdWFsKGFba2V5XSwgYltrZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVFcXVhbDtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuY29uc3QgSG9tZSA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGgxPlJlYWN0LVNTUiBCb2lsZXJwbGF0ZTwvaDE+XG4gICAgICA8cD5UaGlzIGlzIGEgbWluaW1hbCBTU1IgYm9pbGVycGxhdGUgd2l0aCBSZWFjdEpTLCBOb2RlSlMsIEhhcGlKUywgV2VicGFjay48L3A+XG4gICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IGNvbnNvbGUubG9nKFwiQ2xpY2sgV29ya3MgPT09IEh5ZHJhdGUgV29ya3NcIil9PkNsaWNrICE8L2J1dHRvbj5cbiAgICAgIDxwPlVzZSBjb25zb2xlIHRvIHZhbGlkYXRlIEV2ZW50cyAvIEh5ZHJhdGUgaXMgd29ya2luZy4uLiA8L3A+XG4gICAgICA8aDI+RmVhdHVyZXMgJiBFeGFtcGxlczogPC9oMj5cbiAgICAgIDxwPkV4YW1wbGUgcm91dGluZzogPGEgaHJlZj1cIi90ZXN0XCI+VGVzdDwvYT48L3A+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5jb25zdCBUZXN0ID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8aDE+UmVhY3QtU1NSIEJvaWxlcnBsYXRlPC9oMT5cbiAgICAgIDxwPlRoaXMgaXMgYSB0ZXN0IHJvdXRlLjwvcD5cbiAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gY29uc29sZS5sb2coXCJDbGljayBXb3JrcyA9PT0gSHlkcmF0ZSBXb3Jrc1wiKX0+Q2xpY2sgITwvYnV0dG9uPlxuICAgIDwvPlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVGVzdDtcbiIsImltcG9ydCBIb21lIGZyb20gJy4vY29tcG9uZW50cy9Ib21lJztcbmltcG9ydCBUZXN0IGZyb20gJy4vY29tcG9uZW50cy9UZXN0JztcblxuY29uc3Qgcm91dGVzTGlzdCA9IFtcbiAge1xuICAgIHBhdGg6ICcvJyxcbiAgICBleGFjdDogdHJ1ZSxcbiAgICBjb21wb25lbnQ6IEhvbWVcbiAgfSxcbiAge1xuICAgIHBhdGg6ICcvdGVzdCcsXG4gICAgY29tcG9uZW50OiBUZXN0XG4gIH1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlc0xpc3Q7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBTdGF0aWNSb3V0ZXIsIFJvdXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgcm91dGVzTGlzdCBmcm9tICcuLi9jbGllbnQvcm91dGVzJztcbmltcG9ydCB7IGNsaWVudFNjcmlwdHMsIHZlbmRvclNjcmlwdHMgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgcmVxID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8aHRtbCBsYW5nPVwiZW5cIj5cbiAgICAgICAgPGhlYWQ+XG4gICAgICAgICAgICA8bWV0YSBjaGFyU2V0PVwiVVRGLThcIiAvPlxuICAgICAgICAgICAgPHRpdGxlPkJvaWxlcnBsYXRlIC0gU1NSIHdpdGggSGFwaUpTLCBSZWFjdDwvdGl0bGU+XG4gICAgICAgIDwvaGVhZD5cbiAgICAgICAgPGJvZHk+XG4gICAgICAgICAgICA8ZGl2IGlkPVwiYXBwXCI+XG4gICAgICAgICAgICAgICAgPFN0YXRpY1JvdXRlciBsb2NhdGlvbj17cmVxLnBhdGh9IGNvbnRleHQ9e3t9fT5cbiAgICAgICAgICAgICAgICAgIHtyb3V0ZXNMaXN0Lm1hcChyb3V0ZSA9PiA8Um91dGUga2V5PXtyb3V0ZS5wYXRofSB7Li4ucm91dGV9IC8+KX1cbiAgICAgICAgICAgICAgICA8L1N0YXRpY1JvdXRlcj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHt2ZW5kb3JTY3JpcHRzLm1hcChzY3JpcHRQYXRoID0+IHNjcmlwdFBhdGggJiYgPHNjcmlwdCBrZXk9eyBzY3JpcHRQYXRoIH0gc3JjPXsgc2NyaXB0UGF0aCB9IC8+KX1cbiAgICAgICAgICAgIHtjbGllbnRTY3JpcHRzLm1hcChzY3JpcHRQYXRoID0+IHNjcmlwdFBhdGggJiYgPHNjcmlwdCBrZXk9eyBzY3JpcHRQYXRoIH0gc3JjPXsgc2NyaXB0UGF0aCB9IC8+KX1cbiAgICAgICAgPC9ib2R5PlxuICAgICAgICA8L2h0bWw+XG4gICAgKVxufTtcbiIsImltcG9ydCBIYXBpIGZyb20gXCJAaGFwaS9oYXBpXCI7XG5pbXBvcnQgSW5lcnQgZnJvbSBcIkBoYXBpL2luZXJ0XCI7XG5pbXBvcnQgcm91dGVzIGZyb20gJy4vcm91dGVzJztcblxuY29uc3QgaW5pdCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3Qgc2VydmVyID0gSGFwaS5zZXJ2ZXIoe1xuICAgIHBvcnQ6IDMwMDBcbiAgfSk7XG5cbiAgYXdhaXQgc2VydmVyLnJlZ2lzdGVyKEluZXJ0KTtcbiAgYXdhaXQgc2VydmVyLnJvdXRlKHJvdXRlcyk7XG4gIGF3YWl0IHNlcnZlci5zdGFydCgpO1xuXG4gIGNvbnNvbGUubG9nKFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICBjb25zb2xlLmxvZyhcIiAgU0VSVkVSIHVwIGFuZCBydW5uaW5nLi4uXCIpO1xuICBjb25zb2xlLmxvZyhcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVwiKTtcbiAgY29uc29sZS5kaXIoc2VydmVyLmluZm8pO1xufTtcblxucHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLCBlcnIgPT4ge1xuICBjb25zb2xlLmxvZyhlcnIpO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59KTtcblxuaW5pdCgpOyIsImltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcbmltcG9ydCBodG1sVGVtcGxhdGUgZnJvbSAnLi9odG1sVGVtcGxhdGUnO1xuXG5jb25zdCByZWFjdEhhbmRsZXIgPSAocmVxdWVzdCwgaCkgPT4ge1xuICAgIHJldHVybiBcIjwhRE9DVFlQRSBodG1sPlwiK3JlbmRlclRvU3RyaW5nKGh0bWxUZW1wbGF0ZShyZXF1ZXN0KSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCByZWFjdEhhbmRsZXI7IiwiaW1wb3J0IHJlYWN0SGFuZGxlciBmcm9tICcuL3JlYWN0SGFuZGxlcic7XG5leHBvcnQgZGVmYXVsdCBbXG4gIC8vIFN0YXRpYyBGaWxlc1xuICB7XG4gICAgcGF0aDogXCIve3BhcmFtKn1cIixcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgY29uZmlnOiB7XG4gICAgICBoYW5kbGVyOiB7XG4gICAgICAgIGRpcmVjdG9yeToge1xuICAgICAgICAgIHBhdGg6ICdkaXN0J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIERlZmF1bHQgUm91dGVcbiAge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBwYXRoOiBcIi9cIixcbiAgICBoYW5kbGVyOiByZWFjdEhhbmRsZXJcbiAgfSxcbiAge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBwYXRoOiBcIi90ZXN0XCIsXG4gICAgaGFuZGxlcjogcmVhY3RIYW5kbGVyXG4gIH1cbl07XG4iLCJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5cbmNvbnN0IGNsaWVudFNjcmlwdHMgPSBmcy5yZWFkZGlyU3luYygnZGlzdCcsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtICYmICgvY2xpZW50LykudGVzdChpdGVtKSk7XG5cbmNvbnN0IHZlbmRvclNjcmlwdHMgPSBmcy5yZWFkZGlyU3luYygnZGlzdCcsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtICYmICgvdmVuZG9yLykudGVzdChpdGVtKSk7XG5cbmV4cG9ydCB7XG4gICAgY2xpZW50U2NyaXB0cyxcbiAgICB2ZW5kb3JTY3JpcHRzXG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwib3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzdHJlYW1cIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiemxpYlwiKTsiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNKQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcmdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbnJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdmdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2OUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3Y3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbnRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcmdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcndCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5L0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNTBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN1VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdDVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25kQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalhBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6YUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FJQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3dklBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQSxhQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzT0E7QUFDQTtBQUNBLGFBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2VEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3d0VBO0FBQ0E7QUFDQSxhQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcnRCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFBQTtBQUFBO0FBR0E7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDZkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDWkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBSEE7QUFNQTtBQUNBO0FBRkE7QUFNQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUlBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFBQTtBQUNBO0FBREE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDUEE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBREE7QUFEQTtBQUhBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQU1BO0FBQ0E7QUFDQTtBQUhBOzs7Ozs7Ozs7Ozs7QUNyQkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQUE7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUNOQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7OztBIiwic291cmNlUm9vdCI6IiJ9